[THOUGHT]
1. The function returns a tuple (W, H) where both are 2x2 matrices of ones. So W and H returned are:
   W = [[1., 1.], [1., 1.]]
   H = [[1., 1.], [1., 1.]]

2. In _check_w_h, the branch that produces W filled with a constant uses:
   - update_H == False
   - self.solver == 'mu'
   and sets W = np.full((n_samples, self._n_components), avg, dtype=X.dtype), with
   avg = sqrt(X.mean() / self._n_components)

   To get avg == 1, we need X.mean() == self._n_components.

3. Choose simple sizes: n_samples = 2, n_features = 2, _n_components = 2.
   Then X can be a 2x2 array of 2.0s so X.mean() = 2.0, and avg = sqrt(2.0 / 2) = 1.0.
   Provide H as a 2x2 array of 1.0s with the same dtype as X (float), and pass W as null so the function creates W.

4. Set other self attributes to reasonable defaults; the important ones are:
   - solver: "mu"
   - _n_components: 2
   - init and dtypes aligned (X and H floats)

5. Set update_H to false.

These inputs will result in W and H both being 2x2 matrices of ones as in the output.

[/THOUGHT]
[INPUT]
```
{
    "self": {
        "n_components": 2,
        "init": null,
        "beta_loss": "frobenius",
        "tol": 0.0001,
        "max_iter": 200,
        "random_state": null,
        "alpha_W": 0.0,
        "alpha_H": "same",
        "l1_ratio": 0.0,
        "verbose": 0,
        "solver": "mu",
        "shuffle": false,
        "n_features_in_": null,
        "_n_components": 2,
        "_beta_loss": null
    },
    "args": {
        "X": [[2.0, 2.0], [2.0, 2.0]],
        "W": null,
        "H": [[1.0, 1.0], [1.0, 1.0]],
        "update_H": false
    },
    "kwargs": {}
}
```
[/INPUT]