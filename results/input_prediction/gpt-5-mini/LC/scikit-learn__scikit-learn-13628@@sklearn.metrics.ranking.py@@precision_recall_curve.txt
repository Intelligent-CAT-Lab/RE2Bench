[THOUGHT]
We need inputs that produce:
- precision = [1,1,1,1,1]
- recall = [1, 0.85714286, 0.57142857, 0.28571429, 0]
- thresholds = [0.5, 0.6, 0.9, 1.0]

From the implementation:
- precision is tps/(tps+fps) and here precision entries are all 1 => fps must be 0 at each threshold point.
- recall entries (excluding the final 0) are tps / tps[-1]. The nonzero recalls are 1, 6/7, 4/7, 2/7, so tps[-1] (total positives) = 7 and tps at thresholds (in increasing index order returned by _binary_clf_curve) are [2,4,6,7].
- For fps to be zero with sample_weight=None, fps = 1 + threshold_idx - tps must be 0 => threshold_idx = tps - 1 for each tps (so threshold_idxs = [1,3,5,6]). That implies the sorted (descending) score array has duplicates so the distinct-value indices are [1,3,5] and the last index 6 is appended.
- A descending score array that yields threshold values (when sliced and reversed as precision_recall_curve does) of [0.5,0.6,0.9,1.0] is e.g.:
  [1.0, 1.0, 0.9, 0.9, 0.6, 0.6, 0.5]
- If all y_true are positive (all ones, total 7), the computed tps and fps match the needed values (fps=0 everywhere), producing the given precision and recall arrays and the thresholds order shown.

Therefore a simplest input is y_true = [1,1,1,1,1,1,1] and probas_pred = [1.0, 1.0, 0.9, 0.9, 0.6, 0.6, 0.5]. pos_label and sample_weight left as null (None).
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "y_true": [1, 1, 1, 1, 1, 1, 1],
        "probas_pred": [1.0, 1.0, 0.9, 0.9, 0.6, 0.6, 0.5]
    },
    "kwargs": {
        "pos_label": null,
        "sample_weight": null
    }
}
```
