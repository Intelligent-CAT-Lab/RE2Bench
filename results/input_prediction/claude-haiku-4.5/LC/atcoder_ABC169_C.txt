[THOUGHT]
Let me work backwards from the output to find the input.

Given output: 2017634310362021

The last operation is: `print(a * b // 100)`

So: `a * b // 100 = 2017634310362021`

This means: `a * b = 2017634310362021 * 100 = 201763431036202100`

Now I need to find what `a` and `b` are before the conversion to int.

We have:
- `a, b = input().split()` - splits input into two strings
- `b = b[0] + b[2:]` - takes first character of b, skips second character, then appends rest
- `a = int(a)` - converts a to integer
- `b = int(b)` - converts b to integer

Let's say the original input is: `string1 string2`
- `a = string1` (as string initially)
- `b = string2` (as string initially)

Then:
- `b = b[0] + b[2:]` modifies b by removing the character at index 1
- `a = int(a)` converts a to int
- `b = int(b)` converts b to int

So if original b is something like "XYZ...", after the operation it becomes "XZ..."

We need: `int(a) * int(b_modified) = 201763431036202100`

Let me try to factor 201763431036202100:
201763431036202100 = 100 * 2017634310362021

Let me think of reasonable factors. Let's try some possibilities:
- If a = 201763431036202100, b would be 1
- We need b_modified to be some reasonable number

Let me try: a * b = 201763431036202100

One factorization could be: 201763431036202100 = 20176343103620 * 10000
But that doesn't fit well with removing one character.

Let me think differently. If the input string is "20176343103620 10000" (just example):
- a = "20176343103620"
- b = "10000"
- b = b[0] + b[2:] = "1" + "00" = "100"
- a = int("20176343103620") = 20176343103620
- b = int("100") = 100
- a * b // 100 = 20176343103620 * 100 // 100 = 20176343103620 (not matching)

Let me try: if a * b = 201763431036202100
Could be: 2017634310362021 * 100 = 201763431036202100

So maybe:
- a = 2017634310362021 (this is our output!)
- b_modified = 100

If b_modified = 100, and b_modified = b[0] + b[2:], then:
- b[0] = "1"
- b[2:] = "00"
- So b = "1?00" where ? is the character removed
- The removed character is at index 1
- Possible b values: "1000", "1100", "1200", ..., "1900"

So the original input could be "2017634310362021 1000" (or any digit in place of 0 for the second character of the second number)

Let me verify with "2017634310362021 1000":
- a = "2017634310362021"
- b = "1000"
- b = b[0] + b[2:] = "1" + "00" = "100"
- a = int("2017634310362021") = 2017634310362021
- b = int("100") = 100
- a * b // 100 = 2017634310362021 * 100 // 100 = 2017634310362021 âœ“

This matches!

</THOUGHT>

[INPUT]
```
{
    "input": "2017634310362021 1000"
}
```
[/INPUT]