# Analysis of `_polynomial_integrate` function

Looking at the function:

```python
def _polynomial_integrate(polynomials, facets, hp_params):
    dims = (x, y)
    dim_length = len(dims)  # = 2
    integral_value = S.Zero
    for deg in polynomials:
        poly_contribute = S.Zero
        facet_count = 0
        for hp in hp_params:
            value_over_boundary = integration_reduction(facets, facet_count, hp[0], hp[1], polynomials[deg], dims, deg)
            poly_contribute += value_over_boundary * (hp[1] / norm(hp[0]))
            facet_count += 1
        poly_contribute /= dim_length + deg  # = /= (2 + deg)
        integral_value += poly_contribute
    return integral_value
```

To get output `-1/8`:

Since we only have degree 2 in the input polynomials dictionary, we need:
- `poly_contribute / (2 + 2) = -1/8`
- `poly_contribute / 4 = -1/8`
- `poly_contribute = -1/2`

For `poly_contribute` to equal `-1/2`, we need the sum of contributions from `hp_params` iterations to equal `-1/2`.

The simplest scenario is a single `hp` parameter where:
- `value_over_boundary * (hp[1] / norm(hp[0])) = -1/2`

Let me construct a minimal working example:
- `polynomials[2] = 1` (a constant)
- `hp_params = [(1, 1)]` (one hp parameter: base=1, coeff=1)
- `facets = [Segment2D(Point2D(0, 0), Point2D(0, 1))]` (a simple segment)
- `norm(1) = 1`
- `value_over_boundary = -1/2`

Then: `-1/2 * (1/1) / 4 = -1/8` âœ“

# Reasoning

For `integration_reduction` to return `-1/2` with polynomial `1`, degree `2`, and a simple geometry, we need the boundary integral computation to yield that value. With the segment from origin to (0,1) and appropriate hp parameters, this is achievable.

[INPUT]
```
{
    "self": {},
    "args": {
        "polynomials": {
            "2": "1"
        },
        "facets": [
            {
                "p1": {"x": "0", "y": "0"},
                "p2": {"x": "0", "y": "1"}
            }
        ],
        "hp_params": [
            ["1", "1"]
        ]
    },
    "kwargs": {}
}
```
[/INPUT]