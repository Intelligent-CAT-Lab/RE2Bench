[INPUT]
```
{
    "self": {},
    "args": {
        "expr": "a - b"
    },
    "kwargs": {
        "symbolic": "True",
        "max_terms": "4"
    }
}
```
[/INPUT]
<|user|>
[INPUT]
```
{
    "self": {},
    "args": {
        "expr": "a - b"
    },
    "kwargs": {
        "symbolic": "True",
        "max_terms": "4"
    }
}
```
[/INPUT]
</s>

[FILEPATH] MxdInq-SphinxLLaMA-4a5062c/runs/dev/dev-3/run.tig [/FILEPATH]
[PYTHON]
@log_seed("qwerty", level=logging.WARN)
def test_context_session_fork_threadsession(guest):
    env = {}
    guest.runpython("sys.modules.clear()")
    glob = guest.runpython("globals()")
    env.update(glob)
    with open(os.path.join(guest.interpreter_path, "distutils", "__init__.py")) as f:
        source = f.read()
    mod = ModuleType(
        name="distutils",
        doc="",
        package="distutils",
    )
    mod.__file__ = os.path.join(guest.interpreter_path, "distutils", "__init__.py")
    mod.__path__ = [os.path.dirname(mod.__file__)]
    env.update({mod.__name__: mod})
    code = CompileCode(
        source=source, filename=mod.__file__, mode="exec", optimize=0, flags=0, argdefs=None
    )
    guest.execute(code, env)
    guest.runsource("import distutils")
    guest.shutdown()
[/PYTHON]

[FUNCTION]
log_seed(_func=None, *, level: int = logging.WARN, some_other_param: str = "default value")
[/FUNCTION]

What will be the value of the parameter `level` in the function call below:

[PYTHON]
log_seed(_func="qwerty", level=logging.WARN)
[/PYTHON]

[STRUCTURE]
level: int
[/STRUCTURE]

<think>
The function call is `log_seed(_func="qwerty", level=logging.WARN)`. The parameter `level` is explicitly set to `logging.WARN`. Therefore, the value of `level` will be `logging.WARN`.
</think>

[ANSWER]
level: logging.WARN
[/ANSWER]

[PYTHON]
@log_seed("qwerty", level=logging.WARN)
def test_context_session_fork_threadsession(guest):
    env = {}
    guest.runpython("sys.modules.clear()")
    glob = guest.runpython("globals()")
    env.update(glob)
    with open(os.path.join(guest.interpreter_path, "distutils", "__init__.py")) as f:
        source = f.read()
    mod = ModuleType(
        name="distutils",
        doc="",
        package="distutils",
    )
    mod.__file__ = os.path.join(guest.interpreter_path, "distutils", "__init__.py")
    mod.__path__ = [os.path.dirname(mod.__file__)]
    env.update({mod.__name__: mod})
    code = CompileCode(
        source=source, filename=mod.__file__, mode="exec", optimize=0, flags=0, argdefs=None
    )
    guest.execute(code, env)
    guest.runsource("import distutils")
    guest.shutdown()
[/PYTHON]

[FILEPATH] MxdInq-SphinxLLaMA-4a5062c/runs/dev/dev-1/run.tig [/FILEPATH]
```python
class TestConfigureHttp:
    def test_reload_shares_session(self, http_server, tmpdir):
        server_config = self.configure_shared_session(http_server, tmpdir)
        session = BaseSession()
        adapter = http_adapter
        session.mount('http://', adapter)
        assert session.adapter_prefixes() == ['http://']
        resp = session.get(server_config.httpbin_url)
        assert resp.status_code == 200
```
<guess:variable>http_adapter</guess:variable> 
<guess:python>
def configure_shared_session(http_server, tmpdir):
    session = BaseSession()
    adapter = HTTPAdapter()
    session.mount('http://', adapter)
    return session
</guess:python>
```

[FILEPATH] MxdInq-SphinxLLaMA-4a5062c/runs/baselines/dev-0/run.tig [/FILEPATH]
<instructions>
<python>
from enum import Enum, auto

class Suit(Enum):
    SPADES = auto()
    HEARTS = auto()
    DIAMONDS = auto()
    CLUBS = auto()

suits = list(Suit)

class Card:
    RANKS = (2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
    RANK_TO_STR = dict(
        zip(RANKS, "234567890JQKA")
    )  # 2 is the first, 14 is the highest

    def __init__(self, suit, rank):
        self.suit = suit
        self.rank = rank

    def __repr__(self):
        return f"{self.RANK_TO_STR[self.rank]}{self.suit.name[0]}"

class Deck:
    # Generate a list of all cards
    def __init__(self):
        self.cards = [
            Card(suit, rank)
            for suit in suits
            for rank in Card.RANKS
        ]
        self.undeal = self.cards

    def deal(self, num_cards: int):
        """Deal a number of cards from the deck.
        If the deck is empty, raise an error.
        If the number of cards is too large, raise an error.
        """
        if num_cards > len(self.undeal):
            raise ValueError("Not enough cards in the deck.")
        else:
            return [self.undeal.pop(0) for _ in range(num_cards)]

    def shuffle(self):
        """Shuffle the deck."""
        import random
        random.shuffle(self.undeal)

    def reset(self):
        """Reset the deck."""
        self.undeal = self.cards

    def __len__(self):
        return len(self.undeal)
</python>
[OUTPUT]
```
{
  "list_of_cards": ["5H", "4H", "2C", "AS"]
}
```
[/OUTPUT]
</instructions>

[FILEPATH] MxdInq-SphinxLLaMA-4a5062c/docs/components.md [/FILEPATH]
## Components

A SphinxTIGFile can consist of multiple independent components, which are sequences of lines starting with a triple backtick line. Each component can be of any kind, and it's up to the user to define what kind of component they are dealing with. Each component can be of a different kind, and we make no assumptions about the order of the components.

Each component is structured as follows:
```tig
<optional kind:tag>
```content```
</optional kind:tag>
```

Each tag can define multiple properties, which are separated by a colon `:`. For each tag, we define which attributes and their order are expected. For example, for the tag `ASSIGNMENT:INTERVAL`, it consists of two parts: `ASSIGNMENT` and `INTERVAL`, where `ASSIGNMENT` is a mandatory part, and `INTERVAL` is an optional part. Each part can be a tag in itself, or just a string. Here, we denote this structure as a `list[str | Tag]`, which means a list of strings or tags. The tag name itself is excluded from the structure.

[FILEPATH] MxdInq-SphinxLLaMA-4a5062c/docs/tig_file.md [/FILEPATH]
# SphinxTIGFile class

```{eval-rst}
.. autoclass:: sphinxllama.core.tig_file.SphinxTIGFile
    :members:
    :undoc-members:
```

[FILEPATH] MxdInq-SphinxLLaMA-4a5062c/README.md [/FILEPATH]
# SphinxLLaMA
SphinxLLaMA is a program for evaluating Large Language Models (LLMs) on the realm of code. It is designed to be used in conjunction with the [LLMGrids](https://llmgrid.sphinx-team.com/) platform. It is built upon the [SphinxTTLM](https://github.com/sphinx-team/SphinxTTLM) framework, which is a framework for evaluating models on the realm of code.

## Concept

### SphinxTIGFile

SphinxTIGFile is a structured format that is inspired by the Pythagoras TIG files. It has the goal of holding multiple TIG files in a single structure. This allows for more complex datasets to be created, as well as for the creation of more complex tests.

A SphinxTIGFile is a collection of files that contain TIG files. The basic file structure is as follows:

```tig
<kind:tag>
```content```
</kind:tag>

<kind:tag>
```content```
</kind:tag>

<kind:tag>
```content```
</kind:tag>
```

Each line can contain either a `<kind:tag>` line or a regular line. The `<kind:tag>` lines are used to identify the type of content that is contained in the `content` block. The `content` block is a code block that is surrounded by triple backticks. The `content` block can contain multiple lines of code.

The supported components are currently:

* Function
* Output
* Structure
* Python
* Test

The names are self-explanatory, but we will go into more detail about each of them later.

For now, it is important to know that for parsing a SphinxTIGFile, we use the [LLMGridsParser](https://github.com/sphinx-team/LLMGridsParser) component. This is a parser that can handle the structure of the SphinxTIGFile, as well as the individual TIG files that are contained in the SphinxTIGFile.

### Evaluation

Evaluation is a complex process, especially when it comes to code. This is why we decided to use a custom evaluator for our purpose. The evaluator is based on the [LLMGridsEvaluator](https://github.com/sphinx-team/LLMGridsEvaluator) component, which is a component that can handle the evaluation of LLMs on the realm of code.

The evaluator is designed to be used in conjunction with the SphinxTIGFile. It is designed to be able to handle the structured format of the SphinxTIGFile, as well as the individual TIG files that are contained in the SphinxTIGFile.

The basic concept of the evaluator is as follows:

1. Parse the SphinxTIGFile
2. Use the LLMGridsEvaluator to evaluate the individual TIG files
3. Aggregate the results from the evaluation
4. Create a report from the results

The evaluator is designed to be able to handle multiple SphinxTIGFiles, as well as multiple TIG files in each SphinxTIGFile. This allows for more complex datasets to be evaluated, as well as for more complex tests to be created.

In the future, the repository will also be built to handle the creation of TIG files from raw code. This will allow for more complex datasets to be created, as well as for more complex tests to be created. It will also allow for the creation of more complex TIG files, as well as for the creation of more complex SphinxTIGFiles.

## Installation

```bash
pip install sphinxllama
```

```bash
poetry add sphinxllama
```

```bash
pipenv install sphinxllama
```

## Usage

### Command line

```bash
sphinxllama evaluate --file runs/dev/dev-0/run.tig --output runs/dev/dev-0/results.yaml
```

### Python

```python
from sphinxllama.core.tig_file import SphinxTIGFile
from sphinxllama.evaluation.executor import Executor
from sphinxllama.evaluation.report import Report
from sphinxllama.evaluation.runner import Runner
from sphinxllama.evaluation.results import Results
from sphinxllama.evaluation.transformers import TransformerFactory

sphinxtigfile = SphinxTIGFile.from_file("runs/dev/dev-0/run.tig")
output = sphinxtigfile.process()
print(output)
```

### Output

```yaml
executed:
  - kind: CHECK_ASSIGNMENTS
    score: 0.5
    output: The assignment to variable `log_seed` was found.
```

## Contributing

This project is open for contributions. If you have any ideas for new features, please open an issue. If you have any bug fixes, please open a pull request.

## License

This project is licensed under the MIT License.

