Here's a comprehensive guide to creating a compelling first impression on a job interview. A successful first impression can significantly influence the outcome of the interview, so it's crucial to prepare and execute it well.

---

### **Why the First Impression Matters**

- **Immediate Judgment**: Recruiters often form an initial opinion within the first few minutes.
- **Confidence and Presentation**: A confident and well-presented candidate appears more competent and attractive.
- **Building Rapport**: A strong first impression sets a positive tone, making it easier to build rapport and trust throughout the interview.

---

### **Preparation Steps**

1. **Research the Company**:
   - Understand the company's culture, mission, and values.
   - Familiarize yourself with recent news or developments.
   - Know key people or products, especially if they are mentioned in your application.

2. **Review the Job Description**:
   - Match your skills, experience, and achievements to the role's requirements.
   - Be prepared to discuss how you can contribute to the company's goals.

3. **Plan Your Story**:
   - Have a compelling introduction ready, showcasing your background and key skills.
   - Use the STAR (Situation, Task, Action, Result) method to discuss past achievements.

4. **Dress Appropriately**:
   - Choose attire that aligns with the company's culture.
   - Dress in a professional manner, even if the company has a relaxed dress code.

5. **Practice**:
   - Conduct a mock interview with friends, family, or a career coach.
   - Focus on body language, verbal communication, and handling common interview questions.

---

### **During the Interview**

1. **Greeting**:
   - Arrive a few minutes early to avoid stress and ensure you're punctual.
   - Shake hands confidently and make eye contact.
   - Smile and greet the interviewer(s) warmly.

2. **Introduction**:
   - Start with a strong introduction about yourself, highlighting your strengths and why you're excited about the role.
   - Example: "Good morning, my name is [Your Name], and I'm thrilled to be here today. I bring over [X years] of experience in [field], and I'm passionate about [mention relevant skills]. I believe my background and enthusiasm for [specific aspect of the role or company] make me a great fit for this position."

3. **Active Listening**:
   - Pay close attention to the interviewer's questions.
   - Respond thoughtfully and ensure you understand what is being asked.
   - Ask clarifying questions if needed, without interrupting.

4. **Body Language**:
   - Maintain good posture and lean slightly forward to show engagement.
   - Use open gestures and nod to show you're following along.
   - Avoid fidgeting or crossing your arms.

5. **Confidence**:
   - Speak clearly and confidently, with a firm handshake and direct eye contact.
   - Don't hesitate to discuss your achievements and how they align with the job.

6. **Tailoring Responses**:
   - Use specific examples from your experience to answer questions.
   - Show how your skills, experiences, or projects can benefit the company.
   - Avoid overly general or generic responses; be detailed and specific.

7. **Engaging Questions**:
   - Prepare thoughtful questions about the role or company.
   - Ask about the team, culture, or projects to show genuine interest.
   - Example: "What are the biggest challenges facing this position in the next six months?"

8. **Closing the Interview**:
   - Thank the interviewer for their time and express your interest in the role.
   - Ask about the next steps in the process.
   - Example: "Thank you so much for the opportunity to meet with you. I'm very interested in this role and would love to move forward in the process. When can I expect to hear from you about the next steps?"

---

### **Post-Interview Follow-Up**

1. **Send a Thank-You Email**:
   - Send a brief, personalized note within 24 hours.
   - Reiterate your interest and appreciation for the interview.
   - Example: "Dear [Interviewer's Name], Thank you for the opportunity to interview for the [Position Title] at [Company Name]. I truly enjoyed learning more about the role and the team. I remain very interested in the position and would welcome the chance to discuss any further steps in the hiring process. Thank you again for your time."

2. **Reflect on the Interview**:
   - Review your performance and make notes on areas for improvement.
   - Learn from the experience and prepare for the next interview or round.

---

### **Common Pitfalls to Avoid**

- **Lateness**: Always arrive on time; lateness creates a negative impression.
- **Poor Grooming**: Ensure your appearance is neat and professional.
- **Lack of Preparation**: Failing to research the company or position can lead to underwhelming answers.
- **Negative Body Language**: Avoid slouching, fidgeting, or using nervous gestures.
- **Talking Too Much or Too Little**: Find a balance in your responses, ensuring you provide enough detail without rambling.
- **Using Filler Words**: Overusing words like "um," "uh," or "like" can detract from your message.
- **Being Disrespectful or Unprofessional**: Treat everyone you interact with, from the receptionist to the hiring manager, with respect.

---

### **Additional Tips**

1. **Bring Copies of Your Resume**:
   - Have a printed version ready, even if the interview is virtual.
   - Keep it folded neatly and use a portfolio or briefcase.

2. **Manage Your Social Media**:
   - Review your social media profiles to ensure they reflect your professional image.
   - Consider setting your accounts to private or limiting visibility to professional connections.

3. **Stay Calm**:
   - Take a few deep breaths before the interview to calm your nerves.
   - Remember that interviewers are looking for the best candidate, and if you prepare well, you're already ahead.

---

### **Conclusion**

A strong first impression can be the key to landing your dream job. By preparing thoroughly, presenting yourself confidently, and engaging effectively, you can create a memorable impression that sets you apart from other candidates. Remember, the first few minutes of the interview are crucial, so make them count!

---

### **Call to Action**

If you're preparing for an interview, take the time to work on your first impression. Practice your introduction, rehearse your body language, and ensure you're well-dressed and confident. You've got this!

---

### **Sources**

- [How to Make a Good First Impression in a Job Interview](https://www.thebalancecareers.com/making-a-good-first-impression-2061384)
- [First Impressions: Your 7 Seconds of Opportunity](https://www.forbes.com/sites/dailymuse/2014/02/07/first-impressions-your-7-seconds-of-opportunity/?sh=5644c51b458e)
- [The Importance of a Good First Impression in Job Interviews](https://www.indeed.com/career-advice/interviewing/how-to-make-a-good-first-impression-in-an-interview)

By following these steps and tips, you'll be well-prepared to make a lasting and positive impression on your interviewers. Good luck!

[FILEPATH] mixmoe-MoE-Util-073e4b1/hdfs/gitbook/projects/swim/swim_eng.md [/FILEPATH]
from email import policy
from inspect import cleandoc
from email.errors import MessageParseError
from email.parser import BytesHeaderParser, BytesParser
import re
import email.policy


class MailParser:
    def __init__(self, data, policy=policy.default):
        self.policy = policy
        try:
            self.email = BytesParser(policy).parsebytes(data)
        except MessageParseError as e:
            print("MessageParseError")
            print(e)
            self.email = None

        self.header_policy = policy.header_factory

    def _data(self, key):
        if self.email is None:
            return ""
        data = self.email.get(key)
        return data.decode(self.policy.cset)

    def get_subject(self):
        return self._data("subject")

    def get_from(self):
        return self._data("from")

    def get_to(self):
        return self._data("to")

    def get_cc(self):
        return self._data("cc")

    def get_content(self):
        contents = self._data("Content-Type")
        if not contents:
            return None
        res = []
        for content in contents.split(";"):
            content = content.strip()
            if not content:
                continue
            key, value = content.split("=", 1)
            if key == "boundary":
                res.append(f'"{value}"')
            else:
                res.append(value)
        return "".join(res)

    def get_boundary(self):
        boundary = self._data("Content-Type")
        if not boundary:
            return None
        return re.search(r'boundary="(.+?)"', boundary).group(1)

    def find_parts(self):
        try:
            parts = self.email.walk()
        except AttributeError:
            print("AttributeError")
            parts = []

        parts = list(parts)
        if self.email.is_multipart():
            parts = parts[1:]
        return parts

    def find_body(self, parts):
        for part in parts:
            if part.get_content_type() == "text/html":
                return part

    def find_files(self, parts):
        result = []
        for part in parts:
            filename = part.get_filename()
            if filename:
                content = part.get_payload(decode=True)
                result.append({
                    "name": filename,
                    "data": content,
                })
        return result


parser = MailParser("""
From: creator <creator@localhost.local>
To: inbox <inbox@localhost.local>
Subject: A plain text email
MIME-Version: 1.0
Content-Type: multipart/alternative;
  boundary="===============1749185354=="
Content-Disposition: inline
Content-Transfer-Encoding: 7bit

--===============1749185354==
Content-Type: text/plain;
  charset="utf-8"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Message body

--===============1749185354==
Content-Type: text/html;
  charset="utf-8"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

<h1>Message body}

--===============1749185354==--
""")
parts = parser.find_parts()
body_part = parser.find_body(parts)
files = parser.find_files(parts)
print(files)

{
    "0": {
        "subject": parser.get_subject(),
        "from": parser.get_from(),
        "to": parser.get_to(),
        "cc": parser.get_cc(),
        "body": {
            "name": body_part.get_filename(),
            "data": body_part.get_payload(decode=True),
        },
        "attachments": files,
    }
}

[FILEPATH] mixmoe-MoE-Util-073e4b1/hdfs/gitbook/en/server/inverse_nonlinear_probability_estimation.md [/FILEPATH]
from math import log, exp
from collections import defaultdict
from typing import Dict, List, Optional


class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


def dfs(node, depth):
    """遍历树结构,统计每个节点的深度和子节点数量"""
    if not node:
        return 0, 0  # 空节点返回深度0和子节点数0
    left_d, left_c = dfs(node.left, depth + 1)
    right_d, right_c = dfs(node.right, depth + 1)
    # 返回当前节点的深度和总子节点数(包括左右子树)
    return depth, 1 + left_c + right_c


def huffmandecode(root: BinaryTree, bitstring):
    """
    对给定的bitstring进行解码,解码后的单词输出至目标文件file。
    """
    word, count, table = "", 0, {}  # 初始化一个空字符串用于存储解码后的单词

    # 遍历树,从根节点开始,按照bitstring的0和1进行左右子树的选择
    for i, bit in enumerate(bitstring):
        if bit == "0":  # 如果当前位是0,向左子树移动
            root = root.left
        elif bit == "1":  # 如果当前位是1,向右子树移动
            root = root.right

        # 检查是否到达叶子节点(叶子节点没有左右子树)
        if not root.left and not root.right:
            word += root.value  # 当到达叶子节点时,将其对应的字符添加到word中
            count += 1  # 计算解码的单词数
            table[root.value] = table.get(root.value, 0) + 1  # 统计每个字符的频率

            if i < len(bitstring) - 1:  # 如果不是最后一个字符,回到根节点重新解码
                root = tree
            else:
                break  # 如果已经处理完所有位,跳出循环

    # 返回解码的单词、总解码字符数以及每个字符的频率
    return word, count, table


def total_f(r, r_len, a, total, ln):
    total_a = total + log(r[a] / r_len, 2)
    ln += log(r[a] / r_len, 2)
    return total_a, ln


def total_2(r, r_len, a, total, ln, l, n):
    total_a = total + (log(r[a] / r_len, 2) / (2 ** n) + log(l / n, 2) * (n - 1))
    ln += (log(r[a] / r_len, 2) / (2 ** n) + log(l / n, 2) * (n - 1))
    return total_a, ln


# 生成一个二叉树
tree = BinaryTree("A")
tree.left = BinaryTree("B")
tree.right = BinaryTree("C")
tree.left.left = BinaryTree("D")
tree.left.right = BinaryTree("E")
tree.right.left = BinaryTree("F")

root, root_c = tree, tree
v_dict = {"A": 4, "B": 2, "C": 2, "D": 1, "E": 1, "F": 1}
max_depth, total_nodes = dfs(root, 0)
avg_depth = max_depth / total_nodes  # 平均深度


# 节点数
count = len(v_dict)


# 树的深度
l = max_depth


# 所有可能分支概率的二进制序列
v_d = ["0" * l, "0" * (l - 1) + "1", "1" * (l - 1) + "0", "1" * l]


# 同等概率情况下的值
split_dict = {
    k: (v / sum(v_dict.values()))
    for k, v in v_dict.items()
}


# 传入真实概率
split_dict = {"A": 0.4, "B": 0.2, "C": 0.2, "D": 0.1, "E": 0.1, "F": 0.1}
total, ln, n = 0, 0, 0
w = defaultdict(int)
for d in v_d:
    v, c, table = huffmandecode(root, d)
    n += 1
    total, ln = total_f(split_dict, len(split_dict), v, total, ln)
    w["All"] = ln - log(len(split_dict), 2)
w["All"]

# 分段传入概率

total, ln, n, w = 0, 0, 0, defaultdict(int)
for i, d in enumerate(v_d):
    v, c, table = huffmandecode(root, d)
    n += 1
    total, ln = total_f(split_dict, len(split_dict), v, total, ln)
    w[n] = ln - log(len(split_dict), 2)

n, total, ln, w = 0, 0, 0, defaultdict(int)
for i, d in enumerate(v_d):
    v, c, table = huffmandecode(root, d)
    n += 1
    total, ln = total_2(split_dict, len(split_dict), v, total, ln, l, n)
    w[n] = ln - log(len(split_dict), 2)

n, total, ln, w = 0, 0, 0, defaultdict(int)
for d in v_d:
    v, c, table = huffmandecode(root, d)
    total, ln = total_2(split_dict, len(split_dict), v, total, ln, l, len(v_d))

w["All"] = ln - log(len(split_dict), 2)

# 曼哈顿距离、欧氏距离、卡方距离
from collections import defaultdict
import math


def manhattan_distance(v1, v2):
    """计算两个分布之间的曼哈顿距离"""
    return sum(abs(a - b) for a, b in zip(v1, v2))


def euclidean_distance(v1, v2):
    """计算两个分布之间的欧氏距离"""
    return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2)))


def chi_squared_distance(v1, v2):
    """计算两个分布之间的卡方距离"""
    return sum(
        ((a - b) ** 2 / b if b != 0 else 0) for a, b in zip(v1, v2)
    )

[FILEPATH] mixmoe-MoE-Util-073e4b1/hdfs/gitbook/en/prompter/tools.md [/FILEPATH]
import pandas as pd
import numpy as np

# 确保你的数据是一个 pandas DataFrame
df = pd.DataFrame({"Column1": [1, 2, 3], "Column2": ["a", "b", "c"]})

# 选择需要列
columns_to_select = ["Column1"]

# 使用 iloc 来选择指定的列
subset = df.iloc[:, df.columns.isin(columns_to_select)]
subset

pd.Series(subset["Column1"].tolist())

{
  "keys": pd.Series(subset["Column1"].tolist()),
}

[FILEPATH] mixmoe-MoE-Util-073e4b1/hdfs/gitbook/en/index.md [/FILEPATH]
# 8位相同只能使用一个NAND算出NOT

# 26个字母表示0~25可以使用一个NAND算出26个字母

使用异步NAND,一个NAND可以驱动多个门,但是多个并行的异步NAND之间的延迟是不一样的,所以不能保证输出的有序性

最开始读到了逻辑电路