Let’s reason step-by-step.

The function `_cmp_name(x, y)` returns:

- `0` if `x.__name__ == y.__name__`
- `-1` if `y` is not a subclass of `Basic`
- Otherwise, it looks up `x.__name__` and `y.__name__` in `ordering_of_classes`.
- If both names are found in `ordering_of_classes`, it compares their indices: returns `1` if `i1 > i2`, `-1` if `i1 < i2`.
- If neither is in `ordering_of_classes`, it compares names lexicographically (`(n1 > n2) - (n1 < n2)`, so `1` if `n1 > n2`, `-1` if `n1 < n2`).
- If one is in `ordering_of_classes` and the other is not, the one in the list will have a smaller index (`UNKNOWN` is `len(ordering_of_classes)+1`), so the unknown name gets a larger index (`UNKNOWN`), meaning the known name comes first (index smaller) → returns `-1` if known < unknown, `1` if known > unknown? Wait, `UNKNOWN` is bigger than any valid index. Let’s check:  
  If `i1` is valid and `i2` is `UNKNOWN`, then `i1 < i2`, so `(i1 > i2) - (i1 < i2)` = `0 - 1` = `-1`. That means `x` comes before `y` when `x` is known and `y` is unknown.  
  If `i1` is `UNKNOWN` and `i2` is valid, `i1 > i2`, so `(i1 > i2) - (i1 < i2)` = `1 - 0` = `1`.

Given the **output is `1`**, possibilities:

- `y` is subclass of `Basic` (otherwise we’d get `-1` immediately)
- `x.__name__ != y.__name__`
- The `ordering_of_classes` lookup results in `i1 > i2` (with both known), OR `x` unknown, `y` known (`i1 == UNKNOWN, i2 valid`), OR lexicographic `n1 > n2` if both unknown.

Since we don’t know `ordering_of_classes`, we can guess simplest case:  
Let `x.__name__` be unknown (not in ordering_of_classes), `y.__name__` be known (in ordering_of_classes). Then `i1 = UNKNOWN`, `i2` valid, `i1 > i2` → result `1`.

Also `y` must be subclass of `Basic`.  
We need example class names: `ordering_of_classes` is internal but likely includes something like `"Add", "Mul", "Pow"`, etc. So pick `x.__name__ = "UnknownClass"` (not in list), `y.__name__ = "Add"` (in list).

We should import relevant symbols in mind:  
From SymPy, `Add` is a `Basic` subclass. `UnknownClass` could be any user-defined class that is also a `Basic` subclass? Actually `issubclass(y, Basic)` check happens first only if names unequal, but `y` not subclass of `Basic` → `-1`. So we want `y` subclass of `Basic`. We can pick `x` not subclass of `Basic`? Wait, `issubclass(y, Basic)` returns `True`, fine. `x` can be anything with `__name__` attribute (since we access `x.__name__`), but it could be `Basic` subclass too, doesn’t matter.

Thus set:
```
x = some class with __name__ "Zebra" (unknown ordering)
y = Add (in ordering_of_classes)
```
Then: `n1 != n2`, `y` subclass of `Basic`, `i1 = UNKNOWN`, `i2` valid, `i1 > i2` → returns `1`.

So answer matches output `1`.

Let’s write final input.

[INPUT]
```
{
    "self": {},
    "args": {
        "x": type("Zebra", (), {}),
        "y": sympy.core.add.Add
    },
    "kwargs": {}
}
```
[/INPUT]