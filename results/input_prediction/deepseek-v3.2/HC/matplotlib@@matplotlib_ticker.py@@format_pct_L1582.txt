Let’s reason through this step by step.  

1. The output string is `"120%"`.  
   So `format_pct` returned `"120" + self.symbol`, where `self.symbol` appears to be `"%"`.  

2. In `format_pct`, the first step is:  
   ```python
   x = self.convert_to_pct(x)
   ```  
   This divides `x` by `self.xmax` and multiplies by 100. So after conversion, `x` becomes 120.  

3. Therefore:  
   \[
   \frac{x_{\text{original}}}{xmax} \times 100 = 120
   \]
   \[
   x_{\text{original}} = \frac{120}{100} \times xmax = 1.2 \times xmax
   \]  
   This means `x` (passed argument) is 1.2 times `xmax`.  

4. Now, `decimals` logic:  
   - If `self.decimals` is `None`, then it calculates `scaled_range = self.convert_to_pct(display_range)`.  
   - If `scaled_range <= 0`, `decimals = 0`.  
   - Else:  
     \[
     decimals = \text{ceil}(2.0 - \log10(2.0 \times scaled\_range))
     \]  
     Then clip between 0 and 5.  
   - Since the output is `"120"` with **no decimal places**, that means `decimals = 0` in the formatting.  

5. Possible ways `decimals = 0`:  
   - `self.decimals` explicitly set to `0`.  
   - Or `self.decimals = None`, but `scaled_range <= 0`.  
   - Or `self.decimals = None`, and `scaled_range` is such that the formula yields `decimals = 0`.  

6. Let’s test `scaled_range <= 0` possibility:  
   `scaled_range = 100 * (display_range / xmax)` is `<= 0` only if `display_range <= 0`. This is plausible if `display_range = 0` or negative (but `display_range` likely positive in normal ticks logic). If `scaled_range <= 0` is true, then `decimals = 0`.  

7. Alternatively, formula for positive `scaled_range`:  
   We need `ceil(2.0 - log10(2.0 * scaled_range)) = 0`.  
   For `ceil(...) = 0`, the argument must be ≤ 0 and > -1. So:  
   \[
   2.0 - \log10(2.0 \times scaled\_range) \le 0
   \]
   \[
   \log10(2.0 \times scaled\_range) \ge 2.0
   \]
   \[
   2.0 \times scaled\_range \ge 100
   \]
   \[
   scaled\_range \ge 50
   \]  
   Also, for `ceil(...) = 0` but > -1:  
   \[
   2.0 - \log10(2.0 \times scaled\_range) > -1
   \]
   \[
   \log10(2.0 \times scaled\_range) < 3.0
   \]
   \[
   2.0 \times scaled\_range < 1000
   \]
   \[
   scaled\_range < 500
   \]  
   So `50 ≤ scaled_range < 500`.  

8. But with `scaled_range = self.convert_to_pct(display_range) = 100 * (display_range / xmax)`.  
   That means:  
   \[
   50 \le 100 \times \frac{\text{display\_range}}{xmax} < 500
   \]
   So:
   \[
   0.5 \times xmax \le \text{display\_range} < 5 \times xmax
   \]  

   This is a plausible range for `display_range`.  

9. Let’s pick simple numbers:  
   - Let `xmax = 100`.  
   - Then original `x = 1.2 * xmax = 120`.  
   - `display_range` could be `60` (which satisfies `0.5*xmax ≤ 60 < 5*xmax`).  
   - Then `scaled_range = 100 * (60 / 100) = 60`.  
   - `decimals = ceil(2.0 - log10(2 * 60)) = ceil(2.0 - log10(120)) ≈ ceil(2.0 - 2.079) = ceil(-0.079) = 0`.  

   That works.  

10. `self._symbol` must be `"%"`, `self._is_latex` irrelevant since `mpl.rcParams['text.usetex']` not given but output is plain `%`.  

11. Let’s check `self.decimals`: they said `self.decimals` is `None` in our guess, but could be `0` too — but the formula gave us `decimals = 0` anyway.  
Let's use `decimals = None` as typical default.  

So:  
- `self.xmax = 100`  
- `self.decimals = None`  
- `self._symbol = "%"`  
- `self._is_latex = False`  
- `args.x = 120`  
- `args.display_range = 60`  

[INPUT]
```
{
    "self": {
        "xmax": 100,
        "decimals": null,
        "_symbol": "%",
        "_is_latex": false
    },
    "args": {
        "x": 120,
        "display_range": 60
    },
    "kwargs": {}
}
```
[/INPUT]