Let’s reason step-by-step.

---

We are given an output:

```json
{
    "0": { "0": 1 },
    "1": { "0": 1 },
    "2": { "0": 1 }
}
```

That means:

- Row indices in the result matrix: `0, 1, 2`
- Column index in the result matrix: `0`
- All nonzero entries are `1` at `(0,0)`, `(1,0)`, `(2,0)`.

---

The `SDM.extract(rows, cols)` logic takes:

1. `self` – original sparse matrix in dict-of-dicts format: `{row_index: {col_index: value}}`.
2. `rows` – list of row indices from original matrix to pick.
3. `cols` – list of col indices from original matrix to pick.

Result shape: `(len(rows), len(cols))`.

Here `len(rows) = 3` and `len(cols) = 1`.

---

The output suggests:

- In the **original** matrix, the extracted rows (in original indices) all had a nonzero in the same original column (call it `j_orig`).
- After extraction, `j_orig` maps to new column index `0` in `cols`.
- These original rows `i_orig` map to new row indices `0, 1, 2`.

---

Looking at the code:

Let `m, n = self.shape`.

- `rows`: list of original row indices (can be negative Python-style indexing: `i1 = rows[i2]`).
- `cols`: likewise for columns.

`rowmap` maps original row index `i1` to list of new row indices `i2` in the result.
`colmap` maps original col index `j1` to list of new col indices `j2` in the result.

Then for each `i1` in `rowset & sdm1.keys()` (original rows that exist in the matrix and are selected),  
for each `j1` in `colset & row1.keys()` (original columns that exist in this row and are selected),  
take entry `row1[j1]` and put it at `row2[j2]` for each `j2` in `colmap[j1]`.

---

For output `{0:{0:1}, 1:{0:1}, 2:{0:1}}`:

- For new row `0`: row `i2=0` comes from original row `i1` = `rows[0]`.
- For new row `1`: from `rows[1]`.
- For new row `2`: from `rows[2]`.

All have value `1` in extracted column `0` (original col `j1` = `cols[0]`).

Meaning: All original rows `rows[0], rows[1], rows[2]` must have value `1` at original column `cols[0]` in `self`.

---

So `self` SDM must be something like:

```
{ r0: { c0: 1 }, r1: { c0: 1 }, r2: { c0: 1 } }
```

Where `r0 = rows[0]`, `r1 = rows[1]`, `r2 = rows[2]`, and `c0 = cols[0]`.

---

We don’t know `rows` or `cols`. Could be nonsequential original indices, but simplest guess:  
Perhaps `rows = [0, 1, 2]` and `cols = [0]`? Then original matrix has those 3 rows and at least 1 column.

But then `self` would be `{0: {0: 1}, 1: {0: 1}, 2: {0: 1}}` and extraction just copies them with same indices in result.

They specifically give `SDM` output dict format — exactly the internal representation — so possibly input `self` is actually that same dict, and `rows = [0,1,2]`, `cols = [0]`.

---

But need to satisfy bounds:

- `m = self.shape[0]` ≥ max(rows)+1 if rows are positive. If rows has `2`, then m≥3.
- `n = self.shape[1]` ≥ max(cols)+1, so n≥1.

Choose minimal: `shape=(3,1)`.

Domain can be anything, e.g., `ZZ`.

Rows list `[0,1,2]`. Cols list `[0]`.

---

Check:  
`extract([0,1,2], [0])` from `self = {0:{0:1}, 1:{0:1}, 2:{0:1}}`, shape=(3,1), domain=ZZ.

`rowmap`: i1=0 → [0], i1=1 → [1], i1=2 → [2].  
`colmap`: j1=0 → [0].

Rowset = {0,1,2} & self.keys() = {0,1,2}. Intersection all present.

For i1=0: row1={0:1}, colset={0} ∩ row1.keys()={0} → j1=0, row1[0]=1, j2 in colmap[0]=[0] → row2={0:1}.  
Assign i2=0: sdm2[0]={0:1}.

Similarly i1=1: gives sdm2[1]={0:1}, i1=2 gives sdm2[2]={0:1}.

Matches output exactly.

---

Thus:

```
{
    "self": {
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "ZZ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
```

---

[THOUGHT]
The output SDM has rows 0,1,2 each with a single entry at column 0.  
This means the extracted slice chose all three rows and the first column of the original matrix.  
The simplest input is an original matrix with exactly those entries (1's in positions (0,0), (1,0), (2,0)), shape (3,1), domain ZZ, and extraction arguments rows=[0,1,2], cols=[0].
[/THOUGHT]

[INPUT]
{
    "self": {
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "ZZ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
[/INPUT]