[THOUGHT]
Let me trace through the `extract` function with the given output to determine the required inputs.

The output is:
```
{
    "0": {"0": 1},
    "1": {"0": 1},
    "2": {"0": 1}
}
```

This represents an SDM with 3 rows and 1 column, where each row has one element (column 0) with value 1.

**Analyzing the extract function logic:**

1. First check: `if not (self and rows and cols)` - Since output is non-empty, all three must be truthy (non-empty).

2. The function builds `rowmap` and `colmap` to translate between original and new indices:
   - For each i2, i1 in enumerate(rows): rowmap[i1 % m].append(i2)
   - For each j2, j1 in enumerate(cols): colmap[j1 % n].append(j2)

3. For the result to have rows labeled 0, 1, 2 in output, I need:
   - len(rows) = 3
   - len(cols) = 1

4. The simplest `rows` parameter for this is [0, 1, 2], which gives:
   - rowmap = {0: [0], 1: [1], 2: [2]}

5. The simplest `cols` parameter is [0], which gives:
   - colmap = {0: [0]} (assuming n > 0)

6. With rows = [0, 1, 2], I need m > 2, so self.shape should have m ≥ 3.
   With cols = [0], I need n > 0.
   Given the output shape is (3, 1), the simplest self.shape = (3, 1).

7. For the function to copy value 1 to all three output positions, self must have:
   - self[0][0] = 1
   - self[1][0] = 1
   - self[2][0] = 1

**Tracing with proposed inputs:**
- self = {0: {0: 1}, 1: {0: 1}, 2: {0: 1}}
- rows = [0, 1, 2], cols = [0]
- rowset & sdm1.keys() = {0, 1, 2}
- For each i1 in {0, 1, 2}: copies row content to sdm2[0], sdm2[1], sdm2[2]
- Result matches: {0: {0: 1}, 1: {0: 1}, 2: {0: 1}} ✓

</THOUGHT]

[INPUT]
```
{
    "self": {
        "0": {"0": 1},
        "1": {"0": 1},
        "2": {"0": 1},
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "QQ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
```
[/INPUT]