[THOUGHT]
Let me trace through the `radsimp` function to understand what input would produce the output `"1/(a - b)"`.

The `radsimp` function simplifies radical expressions. At a high level, it:

1. Separates coefficient from the expression: `coeff, expr = expr.as_coeff_Add()`
2. Normalizes the expression: `expr = expr.normal()`
3. Processes through a `handle()` function that rationalizes denominators
4. Returns: `coeff + _unevaluated_Mul(n, 1 / d)` where n is numerator, d is denominator

For the output `"1/(a - b)"` to be produced, I need to trace what expression would simplify to this.

**Case: Input is `1/(a - b)` itself**

If `expr = 1/(a - b)`:
- After `as_coeff_Add()`: coeff = 0 (additive constant), expr = 1/(a - b)
- After `expr.normal()`: still `1/(a - b)` (already normalized)
- In `handle()`: 
  - `fraction(1/(a-b))` gives n=1, d=(a-b)
  - Since n is atomic and equals S.One, it skips most conditions
  - The while loop extracts radical terms from d=(a-b)
  - Since a-b is Add with no radicals: collected = {(): [a, -b]}
  - rterms = [(1, a-b)]
  - nrad = 1 - 1 = 0 (breaks immediately since no radicals)
  - Returns `1/(a-b)`
- Final return: `0 + 1/(a-b) = 1/(a-b)` âœ“

Since the function is being called with the default parameters (no indication of non-defaults from the output), I use:
- `symbolic = True` (default)
- `max_terms = 4` (default)

For JSON representation, SymPy expressions are represented as their string form since JSON doesn't support arbitrary Python objects.
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "expr": "1/(a - b)"
    },
    "kwargs": {
        "symbolic": true,
        "max_terms": 4
    }
}
```
[/INPUT]