[THOUGHT]
1. The function lowercases header names and looks them up in _EMAIL_TO_RAW_MAPPING to map email header names to raw metadata keys. The expected raw output has key "download_url" with value "VaLuE", so the header must be the "Download-URL" header (or any case variant), which maps to raw key "download_url".
2. The code collects header values into a list; if the mapped raw_name is in _STRING_FIELDS and len(value) == 1, it stores the single string value directly. "download_url" is a single string field, so providing a single header "Download-URL: VaLuE" will produce raw["download_url"] = "VaLuE".
3. To keep unparsed empty, encoding must be valid (no binary decoding fallback) and there must be no headers that are unmapped or invalid; using a simple ASCII string header ensures valid encoding and mapping. Also the payload/body should be empty so it doesn't add anything to unparsed.
4. Therefore providing the email as a text string with the header "Download-URL: VaLuE" followed by a blank line (end of headers) will produce the tuple ({ "download_url": "VaLuE" }, {}) which matches the provided output.

[INPUT]
```
{
    "self": {},
    "args": {
        "data": "Download-URL: VaLuE\n\n"
    },
    "kwargs": {}
}
```
[/INPUT]