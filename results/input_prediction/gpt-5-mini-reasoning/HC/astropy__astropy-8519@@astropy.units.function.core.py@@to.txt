[THOUGHT]
We need inputs that make FunctionUnitBase.to(...) return 100.0.

Inspecting the function:
- If other is self.physical_unit: it returns self.to_physical(value). Hard to guarantee what to_physical returns.
- Otherwise it gets other_function_unit = getattr(other, 'function_unit', other).
- If self.function_unit.is_equivalent(other_function_unit) is True:
    - other_physical_unit = getattr(other, 'physical_unit', dimensionless_unscaled)
    - If self.physical_unit != other_physical_unit, a physical conversion is performed (calls self.physical_unit.to(...), then self.from_physical(...)), then function conversion.
    - If self.physical_unit == other_physical_unit, no physical conversion; final return is self.function_unit.to(other_function_unit, value).
So the simplest, most controllable path is:
- Make self.function_unit.is_equivalent(other_function_unit) True.
- Make self.physical_unit == other_physical_unit so no physical conversion.
- Make self.function_unit.to(other_function_unit, value) simply return the input value (this will be the case if the function units are identical or equivalent and the conversion is identity).
Therefore set value = 100.0, and give other a unit object that is effectively equal to self's physical unit and same function unit (so function_unit.to will be identity). For the JSON structure, populate the unit internals with identical fields for self and other. Provide an empty equivalencies list.

Given these assumptions, the function will follow the is_equivalent branch, skip physical conversion, and return the function-level conversion of 100.0 to 100.0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_physical_unit": {
            "_names": ["m"],
            "_short_names": ["m"],
            "_long_names": ["meter"],
            "_format": {},
            "__doc__": "meter",
            "_hash": 123456789
        },
        "_function_unit": {
            "_bases": ["m"],
            "_powers": [1],
            "_scale": 1.0,
            "_decomposed_cache": {
                "_scale": 1.0,
                "_bases": ["m"],
                "_powers": [1]
            }
        }
    },
    "args": {
        "other": {
            "_names": ["m"],
            "_short_names": ["m"],
            "_long_names": ["meter"],
            "_format": {},
            "__doc__": "meter",
            "_hash": 123456789
        },
        "value": 100.0
    },
    "kwargs": {
        "equivalencies": []
    }
}
```
[/INPUT]