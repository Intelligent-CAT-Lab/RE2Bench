[THOUGHT]
We need _cmp_name(x, y) to return 1.

Step through the code:
- n1 = x.__name__, n2 = y.__name__. If n1 == n2 => 0, so they must differ.
- If not issubclass(y, Basic) => returns -1, so y must be a subclass of Basic (or Basic itself).
- UNKNOWN = len(ordering_of_classes) + 1; the function then attempts to find indices of n1 and n2 in ordering_of_classes. If both names are not found (both get UNKNOWN), it falls back to lexicographic string comparison: return (n1 > n2) - (n1 < n2). That yields 1 when n1 > n2 lexicographically.
- Alternatively, if either name is found in ordering_of_classes, the function returns (i1 > i2) - (i1 < i2), which is 1 when i1 > i2.

The simplest guaranteed way to get 1 is:
- Make y a subclass of Basic (so issubclass(y, Basic) is True).
- Make x and y have names such that n1 > n2 lexicographically (and to be safe, choose names unlikely to be present in ordering_of_classes so the code uses the lexicographic branch).

A minimal, clear choice is:
- x with name "int" (x = int gives n1 == "int").
- y as Basic itself (y = Basic gives n2 == "Basic" and issubclass(Basic, Basic) is True).

Comparing "int" > "Basic" is True (lexicographically), so the function will return 1.

Thus the input values are x = int and y = Basic (represented here by their names).
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "x": "int",
        "y": "Basic"
    },
    "kwargs": {}
}
```
[/INPUT]