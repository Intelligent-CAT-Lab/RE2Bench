The logic of the `TR8` function is to perform trigonometric power reduction. It converts products and powers of sines and cosines into sums of trigonometric functions with multiple angles. Specifically, it implements formulas like $\cos(a)\cos(b) = \frac{1}{2}(\cos(a-b) + \cos(a+b))$.

The output provided is `"cos(2*phi)/2 + 1/2"`.
This corresponds to the identity for cosine squared:
$$ \cos^2(\phi) = \frac{1 + \cos(2\phi)}{2} = \frac{1}{2} + \frac{\cos(2\phi)}{2} $$

Let's trace the execution of `TR8` with the proposed input `rv = cos(phi)**2`:
1.  **Call**: `TR8(cos(phi)**2, first=True)`.
2.  **`bottom_up`**: Helper traverses the expression tree. It calls the inner function `f` on the node `cos(phi)**2`.
3.  **`f` execution (first=True)**:
    *   The `first=True` block executes.
    *   It splits the expression into numerator `cos(phi)**2` and denominator `1`.
    *   It recursively calls `TR8(cos(phi)**2, first=False)`.
4.  **Recursive Call (first=False)**:
    *   `bottom_up` calls `f` on `cos(phi)**2`.
    *   The condition `rv.is_Pow` matches (base `cos`, exp `2`).
    *   It collects arguments: `args[cos]` becomes `[phi, phi]`.
    *   It enters the loop `while len(c) > 1`.
    *   It pops two `phi`s (`a1`, `a2`) and creates the term `(cos(a1+a2) + cos(a1-a2))/2`.
    *   This evaluates to `(cos(2*phi) + cos(0))/2` which is `cos(2*phi)/2 + 1/2`.
    *   The function returns this transformed expression.
5.  **Return**: The outer call receives this result, `gcd_terms` doesn't change it significantly structure-wise in this simple case, and it returns `cos(2*phi)/2 + 1/2`.

The logic holds. The input `rv` should be `"cos(phi)**2"`. The argument `first` defaults to `True` in the function signature, so `true` is the appropriate value.

[INPUT]
```
{
    "self": {},
    "args": {
        "rv": "cos(phi)**2",
        "first": true
    },
    "kwargs": {}
}
```
[/INPUT]