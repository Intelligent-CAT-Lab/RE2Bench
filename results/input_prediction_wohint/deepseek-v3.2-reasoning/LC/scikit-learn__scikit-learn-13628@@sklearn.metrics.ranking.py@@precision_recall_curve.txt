[THOUGHT]
Given the output of `precision_recall_curve`, we need to reverse-engineer the inputs `y_true`, `probas_pred`, `pos_label`, and `sample_weight`. The output consists of three arrays: precision = [1., 1., 1., 1., 1.], recall = [1., 0.85714286, 0.57142857, 0.28571429, 0.], and thresholds = [0.5, 0.6, 0.9, 1.].

From the function logic:
- `precision = tps / (tps + fps)` with NaN set to 0.
- `recall = tps / tps[-1]`.
- `last_ind = tps.searchsorted(tps[-1])` and `sl = slice(last_ind, None, -1)`.
- The returned arrays are `np.r_[precision[sl], 1]`, `np.r_[recall[sl], 0]`, and `thresholds[sl]`.

Since `precision[sl]` is all 1's, this implies `fps = 0` at the selected thresholds. The recall values (before appending 0) are [1., 0.857..., 0.571..., 0.285...], which are fractions of sevenths: 1, 6/7, 4/7, 2/7. Thus, `tps` at these thresholds are proportional to [7, 6, 4, 2] (assuming total true positives `T = 7`). The thresholds in descending order are [1., 0.9, 0.6, 0.5], and the corresponding `tps` values are [2, 4, 6, 7] (with `T = 7`). This matches the recall fractions.

To achieve `fps = 0` at these thresholds, all negative samples (if any) must have scores strictly less than 0.5. However, the simplest solution is to have no negative samples, i.e., `y_true` consists entirely of the positive class. Using `pos_label = 1`, we set `y_true = [1, 1, 1, 1, 1, 1, 1]`. The scores `probas_pred` must have distinct values 1, 0.9, 0.6, 0.5 with frequencies 2, 2, 2, 1 respectively, e.g., `[1, 1, 0.9, 0.9, 0.6, 0.6, 0.5]`. This yields the exact output.

Alternatively, adding negative samples with scores < 0.5 would also produce the same output but is not required. Thus, the minimal input is chosen.

[/THOUGHT]

[INPUT]
```
{
    "args": [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0.9, 0.9, 0.6, 0.6, 0.5]
    ],
    "kwargs": {
        "pos_label": 1,
        "sample_weight": null
    }
}
```
[/INPUT]