[THOUGHT]
1. The output from `parse_email` is a tuple where the first element is a raw metadata dict containing `{"download_url": "VaLuE"}` and the second element is an empty dict (no unparsed headers).
2. To get `download_url` in raw metadata, there must be an email header that maps to it via `_EMAIL_TO_RAW_MAPPING`. Typically, "download-url" maps to "download_url".
3. The header value "VaLuE" must be a single string (since `download_url` is a `_STRING_FIELD`). The header processing should not encounter encoding issues (so it's valid UTF-8 or Latin-1).
4. No other headers should be present; otherwise, they'd appear in raw or unparsed. The email body must be empty to avoid adding a description field.
5. Thus, the input email data should consist of a single header: "Download-URL: VaLuE" followed by an empty body (separated by a blank line).
6. The input can be a string or bytes. A simple string is sufficient: "Download-URL: VaLuE\n\n".
7. Following the example's input structure, we provide `data` as a named argument in `args`.
[/THOUGHT]

[INPUT]
{
    "args": {
        "data": "Download-URL: VaLuE\n\n"
    },
    "kwargs": {}
}
[/INPUT]