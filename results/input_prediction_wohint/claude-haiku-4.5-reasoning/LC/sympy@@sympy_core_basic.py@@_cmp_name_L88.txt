[THOUGHT]
Let me work backwards from the output to determine what inputs to `_cmp_name` would produce output = 1.

The function structure is:
```python
def _cmp_name(x: type, y: type) -> int:
    n1 = x.__name__
    n2 = y.__name__
    if n1 == n2:
        return 0  # Not this path since output is 1
    if not issubclass(y, Basic):
        return -1  # Not this path since output is 1
    # ... proceeds to index lookups
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)  # This returns 1 if n1 > n2
    return (i1 > i2) - (i1 < i2)  # This returns 1 if i1 > i2
```

For output = 1, I have two main scenarios:

**Scenario 1**: Both class names are not in `ordering_of_classes`, and n1 > n2 lexicographically
- n1 = "Z", n2 = "A" (both not in ordering_of_classes)
- Returns: ("Z" > "A") - ("Z" < "A") = 1 - 0 = 1 ✓

**Scenario 2**: x's class name not in ordering_of_classes (i1=UNKNOWN), y's class name is in ordering_of_classes (i2 < UNKNOWN)
- i1 = UNKNOWN > i2, so returns 1 ✓

I'll use Scenario 1 as it doesn't depend on knowing the contents of `ordering_of_classes`.

With x having __name__ = "Z" and y having __name__ = "A":
- n1 = "Z", n2 = "A"
- n1 != n2 ✓
- y must be a subclass of Basic (required to not return -1) ✓
- Assuming neither "Z" nor "A" are in ordering_of_classes:
  - i1 = UNKNOWN, i2 = UNKNOWN
  - return (True) - (False) = 1 ✓
</THOUGHT>

[INPUT]
```json
{
    "args": {
        "x": {
            "__name__": "Z"
        },
        "y": {
            "__name__": "A"
        }
    },
    "kwargs": {}
}
```
[/INPUT]