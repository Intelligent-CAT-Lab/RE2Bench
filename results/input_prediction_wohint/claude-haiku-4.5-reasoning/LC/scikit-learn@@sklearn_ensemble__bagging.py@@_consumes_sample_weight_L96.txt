[THOUGHT]
Let me trace through the execution of `_consumes_sample_weight(estimator)` to determine what input would produce `output: false`.

The function has a conditional path:
1. If `_routing_enabled()` returns `True`, it calls `request_or_router.consumes('fit', ('sample_weight',))`
2. If `_routing_enabled()` returns `False`, it calls `has_fit_parameter(estimator, 'sample_weight')`

According to the code, `_routing_enabled()` defaults to `False` (it returns `get_config().get("enable_metadata_routing", False)`), so the second path is the typical case.

For `has_fit_parameter(estimator, 'sample_weight')` to return `False`:
```python
def has_fit_parameter(estimator, parameter):
    return (
        hasattr(estimator, "fit") and parameter in signature(estimator.fit).parameters
    )
```

The function returns `False` when:
- The estimator doesn't have a `fit` method (making the `and` expression short-circuit to `False`), OR
- The estimator has a `fit` method but `sample_weight` is not in its parameters

The simplest case is to provide an estimator without any `fit` method. An empty object representation would work:
- `hasattr({}, "fit")` returns `False`
- So `has_fit_parameter({}, 'sample_weight')` returns `False`
- Therefore `_consumes_sample_weight(estimator)` returns `False`
</THOUGHT>

[INPUT]
```
{
    "estimator": {}
}
```
[/INPUT]