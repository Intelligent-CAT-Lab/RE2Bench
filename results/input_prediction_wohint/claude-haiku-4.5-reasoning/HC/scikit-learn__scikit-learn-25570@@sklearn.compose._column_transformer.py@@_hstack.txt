[THOUGHT]
Let me trace through the `_hstack` function to determine what input `Xs` would produce the given output.

The output is: `[[-1. -1.  2.]\n [ 1.  1.  5.]]`
This represents a 2x3 numpy array:
```
[[-1. -1.  2.]
 [ 1.  1.  5.]]
```

The `_hstack` method has three possible execution paths:
1. If `self.sparse_output_` is True → returns `sparse.hstack(converted_Xs).tocsr()` (sparse matrix)
2. If `self.sparse_output_` is False, `config['dense'] == 'pandas'`, and all Xs have `iloc` → returns pandas DataFrame
3. Otherwise → returns `np.hstack(Xs)` (numpy array)

Since the output is a numpy array (not sparse or pandas), we must be taking path 3: `return np.hstack(Xs)`

This means `self.sparse_output_` must be False.

Now, `np.hstack` concatenates arrays horizontally (along axis=1). To produce `[[-1. -1.  2.], [1. 1. 5.]]` (shape 2x3), I need to decompose this into arrays that stack horizontally.

A reasonable decomposition is:
- Array 1: `[[-1., -1.], [1., 1.]]` (shape 2x2) - output from first transformer
- Array 2: `[[2.], [5.]]` (shape 2x1) - output from second transformer

When `np.hstack([array1, array2])` is called:
```python
np.hstack([
    [[-1., -1.], [1., 1.]],
    [[2.], [5.]]
])
# Results in: [[-1., -1., 2.], [1., 1., 5.]]
```

This matches the output.
</THOUGHT>

[INPUT]
```json
{
    "self": {
        "sparse_output_": false
    },
    "args": {
        "Xs": [
            [[-1.0, -1.0], [1.0, 1.0]],
            [[2.0], [5.0]]
        ]
    },
    "kwargs": {}
}
```
[/INPUT]