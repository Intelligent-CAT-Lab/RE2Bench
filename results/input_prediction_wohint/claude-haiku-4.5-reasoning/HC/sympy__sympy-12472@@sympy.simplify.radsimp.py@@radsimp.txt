[THOUGHT]
Let me trace through the `radsimp` function to determine what input would produce the output `"1/(a - b)"`.

The function signature is:
```python
def radsimp(expr, symbolic=True, max_terms=4):
```

At the end of execution, the function returns:
```python
return coeff + _unevaluated_Mul(n, 1 / d)
```

For the output to be `"1/(a - b)"`, we need:
- `coeff = 0` (no additional coefficient)
- `n = 1` (numerator is 1)
- `d = a - b` (denominator is a - b)

Tracing backwards through the function:
1. The expression starts with: `coeff, expr = expr.as_coeff_Add()`
2. Then: `expr = expr.normal()` 
3. Then: `n, d = fraction(handle(expr))`
4. Finally returns: `coeff + _unevaluated_Mul(n, 1 / d)` which should equal `1/(a-b)`

The simplest input that would produce this output is an expression that is already in simplified form: `1/(a - b)`.

When we pass `1/(a - b)` to radsimp:
- It extracts the coefficient (which is 0)
- It normalizes the expression (remains `1/(a-b)`)
- The handler processes it (no radicals to simplify, so largely unchanged)
- Returns `0 + 1/(a-b)` = `1/(a-b)`

The output string `"1/(a - b)"` is the string representation of this returned sympy expression.

For the kwargs, I'll use the explicit default values to be clear.
</THOUGHT>

[INPUT]
```json
{
    "args": {
        "expr": "1/(a - b)"
    },
    "kwargs": {
        "symbolic": true,
        "max_terms": 4
    }
}
```
[/INPUT]