[THOUGHT]
Looking at the `add` method of the Dispatcher class, I need to determine what inputs would produce `null` (None in Python) as output.

Let me trace through the execution:

1. The `add` method signature is: `def add(self, signature, func, on_ambiguity=ambiguity_warn)`

2. Looking at the method body, all code paths either:
   - Return early: `return` (returns None implicitly)
   - Reach the end of the function (implicitly returns None)
   - Raise a TypeError (but this would be an error, not null output)

3. For a successful execution that returns None without raising exceptions:
   - `self` should be a valid Dispatcher instance
   - `signature` should be a valid sequence of types (e.g., [int, str])
   - `func` should be a valid function object
   - `on_ambiguity` can use the default value

4. The function execution flow:
   - It checks if signature is empty (if so, tries to extract from annotations)
   - It checks for union types (tuples within signature)
   - It validates that all elements in signature are actual types
   - It adds the signature to `self.funcs`
   - It calls `reorder` and clears `_cache`
   - It returns None

5. For a simple, successful case without union types or special conditions:
   - Dispatcher with minimal initial state (empty funcs, empty cache, etc.)
   - Signature as a list of type objects
   - A simple function object
   - No custom on_ambiguity handler (use default)

[/THOUGHT]

[INPUT]
```json
{
    "self": {
        "__name__": "add",
        "name": "add",
        "funcs": {},
        "ordering": [],
        "_cache": {},
        "doc": null
    },
    "args": {
        "signature": ["int", "str"],
        "func": "handler_function"
    },
    "kwargs": {}
}
```
[/INPUT]