[THOUGHT]
Let me trace through the `axis_aligned_extrema` method to determine what input would produce two empty arrays.

Looking at the function:
```python
def axis_aligned_extrema(self):
    n = self.degree
    if n <= 1:
        return (np.array([]), np.array([]))
    # ... rest of code
    return (dims[in_range], np.real(roots)[in_range])
```

The output shows two empty float64 arrays: `[array([], dtype=float64), array([], dtype=float64)]`

The most straightforward way to get this output is through the early return when `n <= 1`.

The degree is calculated as: `degree = self._N - 1`

So if `n <= 1`, then `self._N - 1 <= 1`, which means `self._N <= 2` (the number of control points is at most 2).

The simplest case is `self._N = 1` (single control point), which gives `degree = 0`.

Let me verify what happens when initializing with 1 control point, e.g., `[[0, 0]]`:
- `self._cpoints = np.array([[0, 0]])` with shape (1, 2)
- `self._N = 1, self._d = 2`
- `self._orders = np.arange(1) = [0]`
- For `_px`: `coeff = [math.factorial(0) // (math.factorial(0) * math.factorial(0))] = [1]`
- `self._px = ([[0], [0]] * [1]).T = [[0, 0]]`

When calling `axis_aligned_extrema()`:
- `n = self.degree = 1 - 1 = 0`
- `if n <= 1:` evaluates to True
- Returns `(np.array([]), np.array([]))`

This matches the expected output!
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_cpoints": [[0, 0]],
        "_N": 1,
        "_d": 2,
        "_orders": [0],
        "_px": [[0, 0]]
    }
}
```
[/INPUT]