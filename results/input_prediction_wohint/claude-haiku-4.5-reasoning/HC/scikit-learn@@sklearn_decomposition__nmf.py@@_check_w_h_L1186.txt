[THOUGHT]
Looking at the `_check_w_h` method and the output, I need to trace through the code to determine what inputs would produce two 2x2 numpy arrays of all 1.0 values.

The output is a tuple of two arrays:
- Array 1: [[1., 1.], [1., 1.]] (shape: 2x2)
- Array 2: [[1., 1.], [1., 1.]] (shape: 2x2)

These are returned as `(W, H)` from the method.

The method has three main branches:

**Branch 1**: `if self.init == 'custom' and update_H:`
- Returns the provided W and H after validation
- Simplest path to get two 2x2 arrays of all 1s

**Branch 2**: `elif not update_H:`
- Creates W using `np.full()` where avg = sqrt(X.mean() / n_components)
- Would need X.mean() = 2.0 to get avg = 1.0

**Branch 3**: `else:`
- Uses `_initialize_nmf()` - unlikely to naturally produce all 1s

For **Branch 1** with `init='custom'` and `update_H=True`:
- If W and H are both provided as 2x2 arrays of 1.0
- The validation checks in `_check_init()` would pass (arrays are non-negative with max > 0)
- The method returns them directly

Required conditions:
- `n_samples = 2` and `n_features = 2` (from X.shape)
- `self._n_components = 2` (since H shape is (2, 2))
- X, W, H all have matching dtype (float64)
- All arrays are non-negative (which they are)

This is the most straightforward path to produce the exact output.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "init": "custom",
        "_n_components": 2
    },
    "args": {
        "X": [[1.0, 1.0], [1.0, 1.0]],
        "W": [[1.0, 1.0], [1.0, 1.0]],
        "H": [[1.0, 1.0], [1.0, 1.0]],
        "update_H": true
    },
    "kwargs": {}
}
```
[/INPUT]