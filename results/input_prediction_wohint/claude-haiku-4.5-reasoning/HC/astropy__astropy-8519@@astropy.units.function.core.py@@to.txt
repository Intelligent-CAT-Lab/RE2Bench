[THOUGHT]
Looking at the `to` method, there are three possible return paths:
1. `return self.to_physical(value)` - if `other is self.physical_unit`
2. `return self.function_unit.to(other_function_unit, value)` - if function units are equivalent
3. `return self.physical_unit.to(other, self.to_physical(value), equivalencies)` - fallback to physical unit conversion

To get output `100.0`, I need to determine which path was taken and what inputs would produce this result.

The simplest path is path 1: If `other` is the same object as `self.physical_unit`, the method returns `self.to_physical(value)`. 

With the default `value=1.0`, for the output to be `100.0`, we need `self.to_physical(1.0)` to return `100.0`. This would represent a unit conversion with a scaling factor of 100.

For this path to execute:
- `other` must be identical to `self.physical_unit` (using the `is` operator which checks object identity)
- In JSON representation, using the same string value for both represents this scenario
- `value` uses default `1.0`
- `equivalencies` uses default `[]`

The self object needs:
- A `physical_unit` attribute (representing some astropy unit like "kelvin")
- A `function_unit` attribute (representing a function unit like "mag")
- An implicit `to_physical` method that performs the conversion correctly

By passing the same unit string as `other` that matches `self.physical_unit`, and using the default value of 1.0, the first return statement is executed and produces 100.0.
[/THOUGHT]

[INPUT]
```json
{
    "self": {
        "physical_unit": "kelvin",
        "function_unit": "mag"
    },
    "args": {
        "other": "kelvin"
    },
    "kwargs": {}
}
```
[/INPUT]