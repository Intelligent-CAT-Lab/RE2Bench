[THOUGHT]

Let me trace through the execution of `TR8` to understand what input produces the output "cos(2*phi)/2 + 1/2".

The TR8 function applies trigonometric product-to-sum formulas. The output "cos(2*phi)/2 + 1/2" matches the double-angle formula result.

Recall the product-to-sum formula:
- cos(a)*cos(b) = (cos(a+b) + cos(a-b))/2

When a = b = φ:
- cos(φ)*cos(φ) = (cos(2φ) + cos(0))/2 = (cos(2φ) + 1)/2 = cos(2φ)/2 + 1/2 ✓

Let me verify by tracing through the code with input `cos(phi)**2`:

1. Initial call: `TR8(cos(phi)**2, first=True)`
2. Calls `bottom_up(rv, f)` which recursively applies function `f`
3. With `first=True`, the code executes:
   - `n, d = [expand_mul(i) for i in rv.as_numer_denom()]`
   - n = cos(phi)²,  d = 1
   - `newn = TR8(n, first=False)`
   - `newd = TR8(d, first=False)` = 1

4. With `first=False` on cos(phi)**2:
   - It's a Pow with base=cos(phi), exp=2
   - Code extracts: `c = [phi, phi]` (two copies of phi from cos)
   - Since len(c) > 1, it applies the product-to-sum formula:
     - Pops two φ's and creates: `(cos(φ + φ) + cos(φ - φ))/2 = (cos(2φ) + cos(0))/2`
   - Returns `TR8((cos(2*phi) + cos(0))/2, first=False)`
   - With cos(0) = 1, this becomes: `(cos(2*phi) + 1)/2`

5. Back in the `first=True` block:
   - Since newn ≠ n, it applies `gcd_terms()` to simplify
   - Result: `cos(2*phi)/2 + 1/2`

This matches the expected output perfectly.

[/THOUGHT]

[INPUT]
```json
{
    "args": {
        "rv": "cos(phi)**2"
    },
    "kwargs": {}
}
```
[/INPUT]