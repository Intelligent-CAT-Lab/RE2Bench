[THOUGHT]

Let me trace through the `to_euler` function with the given output to determine the input.

The output tuple is:
```
[
    "2*atan2(sin(phi/2), cos(phi/2))",
    "2*atan2(0, sqrt(sin(phi/2)**2 + cos(phi/2)**2))",
    "0"
]
```

The function returns either `(angles2, angles1, angles0)` for extrinsic sequences or `(angles0, angles1, angles2)` for intrinsic sequences.

Looking at the structure, I notice:
1. The third element is `0`, which matches `angles0 = 0` in case 1 (when c and d are both zero)
2. The second element involves `sqrt(...)` with the quaternion components squared, suggesting `angles1 = 2 * atan2(sqrt(c²+d²), sqrt(a²+b²))`
3. The first element is `2*atan2(sin(phi/2), cos(phi/2))`, which appears to be `2*atan2(b, a)`

For case 1 to trigger, I need: `is_eq(c, S.Zero) and is_eq(d, S.Zero)` in the local variables.

If `seq = 'zxz'` (a symmetric Euler angle sequence):
- `i=3, j=1, k=3` → extrinsic=True, symmetric=True
- After adjustment: `k = 6 - 3 - 1 = 2`
- `sign = (3-1)*(1-2)*(2-3)//2 = 1`

Local variable mapping:
```
a = elements[0] = self.a
b = elements[3] = self.d
c = elements[1] = self.b
d = elements[2] = self.c
```

So I need `self.b = 0` and `self.c = 0`.

For the output expressions to match:
- `a = cos(phi/2)` (from the second atan2 expression)
- `b = sin(phi/2)` (from the first atan2 expression)
- `c = 0`
- `d = 0`

This gives quaternion: `Quaternion(cos(phi/2), 0, 0, sin(phi/2))`

Verification:
- angles1 = `2 * atan2(sqrt(0+0), sqrt(cos²(phi/2)+sin²(phi/2)))` = `2*atan2(0, sqrt(sin(phi/2)**2 + cos(phi/2)**2))` ✓
- angles2 = `2*atan2(sin(phi/2), cos(phi/2))` ✓
- angles0 = `0` ✓
- For extrinsic, returns `(angles2, angles1, angles0)` ✓

The default parameters `angle_addition=True` and `avoid_square_root=False` are used since the output doesn't indicate otherwise.

[/THOUGHT]

[INPUT]
```json
{
    "self": {
        "args": ["cos(phi/2)", "0", "0", "sin(phi/2)"]
    },
    "args": {
        "seq": "zxz"
    },
    "kwargs": {}
}
```
[/INPUT]