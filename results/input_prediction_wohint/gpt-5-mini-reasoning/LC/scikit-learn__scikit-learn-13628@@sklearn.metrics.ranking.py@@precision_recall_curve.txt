[THOUGHT]
We need y_true and probas_pred that produce:
- precision array: [1., 1., 1., 1., 1.]
- recall array: [1., 0.85714286, 0.57142857, 0.28571429, 0.]
- thresholds array printed as [0.5 0.6 0.9 1. ]

From precision_recall_curve implementation:
- thresholds returned are thresholds[sl] where sl reverses the thresholds up to last_ind; printed thresholds ascending [0.5,0.6,0.9,1.0] implies original thresholds (from _binary_clf_curve) were descending [1.0,0.9,0.6,0.5].
- precision values are tps/(tps+fps) and all ones => fps must be zero at each threshold index, so the sorted list must have all positives before any negatives (or no negatives).
- recall values are tps/tps[-1]. The visible recall[sl] (before appending 0) are [1, 6/7, 4/7, 2/7] (since 0.85714286=6/7, 0.57142857=4/7, 0.28571429=2/7), so total positives tps[-1] = 7 and tps (in descending-score order) = [2,4,6,7]. That corresponds to groups of positives per distinct score: [2,2,2,1] for scores [1.0, 0.9, 0.6, 0.5].
A minimal input matching this is y_true = seven positives (all 1s) and probas_pred sorted (or unsorted) consisting of the scores [1.0,1.0,0.9,0.9,0.6,0.6,0.5].

So choose:
y_true = [1,1,1,1,1,1,1]
probas_pred = [1.0, 1.0, 0.9, 0.9, 0.6, 0.6, 0.5]
pos_label and sample_weight left as null (defaults).
[/THOUGHT]

[INPUT]
```
{
    "y_true": [1, 1, 1, 1, 1, 1, 1],
    "probas_pred": [1.0, 1.0, 0.9, 0.9, 0.6, 0.6, 0.5],
    "pos_label": null,
    "sample_weight": null
}
```
[/INPUT]