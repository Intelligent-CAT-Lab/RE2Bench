[THOUGHT]
We need _jaccard(...) to return 1.0. The function computes:
intersection = (a_rows * b_rows).sum() * (a_cols * b_cols).sum()
a_size = a_rows.sum() * a_cols.sum()
b_size = b_rows.sum() * b_cols.sum()
and returns intersection / (a_size + b_size - intersection).

For the ratio to equal 1, intersection must equal a_size and b_size (so numerator = denominator). A simple sufficient condition is to make b_rows identical to a_rows and b_cols identical to a_cols (elementwise), and ensure the sums are nonzero.

Choose small integer (binary) arrays:
- a_rows = [1, 0, 1] (sum = 2)
- a_cols = [1, 1]    (sum = 2)
- b_rows = same as a_rows
- b_cols = same as a_cols

Compute:
(a_rows * b_rows).sum() = 1+0+1 = 2
(a_cols * b_cols).sum() = 1+1 = 2
intersection = 2 * 2 = 4
a_size = 2 * 2 = 4
b_size = 4
result = 4 / (4 + 4 - 4) = 1.0

So these inputs produce the given output.
[/THOUGHT]

[INPUT]
```
{
    "a_rows": [1, 0, 1],
    "a_cols": [1, 1],
    "b_rows": [1, 0, 1],
    "b_cols": [1, 1]
}
```
[/INPUT]