[THOUGHT]
We need exprs and opt such that the function returns:
- polys = [ { (1,): 1 } ] and
- gens = (cos(phi),)

Walk through the code:
- For each expr, non-Add and non-Mul factors will be treated as a generator when they are not considered coefficients.
- To get a single generator cos(phi) with exponent 1 and coefficient 1, use expr = cos(phi).
- The factor cos(phi) must not be treated as a numeric coefficient, so _is_coeff(factor) must return False for cos(phi). That is satisfied if opt.domain is None, opt.extension is False, and opt.greedy is True (the middle branch returns factor is S.ImaginaryUnit, which is False for cos(phi)).
- opt.series should be False so decompose_power is used, yielding base = cos(phi), exp = 1.
- gens becomes {cos(phi)}, sorted to (cos(phi),), k = 1. The monomial tuple is (1,), and Mul(*coeff) with empty coeff list yields 1.
Thus the function inputs are exprs = [cos(phi)] and an opt object with attributes domain=None, extension=False, greedy=True, series=False, and harmless sort/wrt (empty sort list, wrt None) so _sort_gens can access them.

So the input JSON will contain exprs as ["cos(phi)"] and opt with those attributes.
[/THOUGHT]

[INPUT]
```
{
    "exprs": [
        "cos(phi)"
    ],
    "opt": {
        "domain": null,
        "extension": false,
        "greedy": true,
        "series": false,
        "sort": [],
        "wrt": null
    }
}
```
[/INPUT]