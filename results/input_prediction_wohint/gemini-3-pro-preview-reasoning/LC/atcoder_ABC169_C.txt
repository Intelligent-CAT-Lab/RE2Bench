To predict the input, we analyze the provided Python code and the output.

**Code Analysis:**
1.  `a, b = input().split()`: Reads a line of input and splits it into two string parts, `a` and `b`.
2.  `b = b[0] + b[2:]`: This manipulation is typical for removing a decimal point from a floating-point number string, assuming the decimal point is at index 1 (e.g., "1.23" becomes "123"). This implies `b` is expected to be a number like `X.YZ...` where `X` is a single digit.
3.  `a = int(a)` and `b = int(b)`: Converts both modified parts to integers.
    *   Let $A$ be the integer value of `a`.
    *   Let $B'$ be the integer value of `b` (the string `b` with the character at index 1 removed).
4.  `print(a * b // 100)`: Prints the result of integer division of $A \times B'$ by 100.
    *   Mathematically, if the original `b` string represented a float $B_{float}$ with 2 decimal places, $B'$ would be $100 \times B_{float}$.
    *   The operation predicts `floor(A * B_{float})`.

**Backward Reasoning:**
*   **Output:** `2017634310362021`
*   Let $Y = 2017634310362021$. We need to find input strings `a` and `b` such that the calculated value equals $Y$.
*   Equation: $(A \times B') // 100 = 2017634310362021$.

We look for the simplest input that satisfies this. The variable structure ($A$ as a large integer, `b` as a multiplier) suggests this might be a test case from a problem like AtCoder ABC 169 C (Multiplication 3).
1.  **Case 1: $B'$ corresponds to "1.00" (Multiplication by 1)**
    *   If input `b` is `"1.00"`, `b` becomes `"1" + "00" = "100"`. So $B' = 100$.
    *   The formula becomes $(A \times 100) // 100 = A$.
    *   Condition: $A = Y = 2017634310362021$.
    *   This requires `a` to be `"2017634310362021"` and `b` to be `"1.00"`.
    *   This is a valid input format and produces the exact output.

2.  **Case 2: Standard constraints ($A \le 10^{15}$)**
    *   If the code implies constraints where $A \le 10^{15}$, the Case 1 solution ($A \approx 2 \times 10^{15}$) would be invalid.
    *   We would need a multiplier $B_{float} > 2$.
    *   For example, if $B_{str} = "2.02"$, $B' = 202$. We solve $(A \times 202) // 100 = Y$.
    *   $A = \lceil 100 \times Y / 202 \rceil$. $100 \times Y$ with $Y$ ending in ...021 ends in ...100. $202$ divides $100 Y$ cleanly if we adjust for the floor. A value like $A = 998828866515852$ with $b="2.02"$ works.
    *   However, without explicit constraints provided in the prompt, the "trivial" identity multiplication (Case 1) is the most direct reconstruction of the input variables for an arbitrary logic snippet, as it assumes the least about the input domain.

Therefore, we predict the input corresponding to Case 1.

[INPUT]
```
{
    "input": "2017634310362021 1.00"
}
```
[/INPUT]