[THOUGHT]
Input: `expr = "3 + I"` with `radical=False, clear=False, fraction=False, sign=False`.

1. `expr = "3 + I"` gets sympified to `3 + I` where I is imaginary unit.
2. Inside `do(expr)`:
   - `is_iterable = iterable(expr)` returns False since it's a symbolic expression.
   - `isinstance(expr, Basic)` is True, `expr.is_Atom` is False.
   - `expr.is_Pow` or `expr.is_Function` is False, `is_iterable` is False, but `hasattr(expr, 'args_cnc')` is True for Add/Mul? Actually `3 + I` is an Add, which has `args_cnc`, so we skip the Pow/Function block.
   - `isinstance(expr, (Sum, Integral))` is False.
   - `cont, p = expr.as_content_primitive(radical=False, clear=False)`:
     - For `3 + I`, the numeric content is `1`, primitive part is `3 + I`.
     - So `cont = 1`, `p = 3 + I`.
   - `p.is_Add` is True, so enter the Add branch.
   - `Add.make_args(p)` gives `(3, I)`.
   - `list_args = [do(a) for a in Add.make_args(p)]`:
     - First `a = 3`: `do(3)` → returns `3`.
     - Second `a = I`: `do(I)` → returns `I`.
     - So `list_args = [3, I]`.
   - Check condition: `any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None for a in list_args)`:
     - For `a = 3`: `a.as_coeff_Mul()` gives `(3, 1)`, extract `3.extract_multiplicatively(-1)` is `None`? Wait: `3.extract_multiplicatively(-1)` returns `-3`? No, `extract_multiplicatively(-1)` returns `-3` if `3 = -1 * -3`, but `-3` is not `None`. Actually `extract_multiplicatively(x)` returns `y` such that `self = x*y`, else `None`. For `3` and `-1`: `3.extract_multiplicatively(-1)` returns `-3` because `3 = -1 * (-3)`. So not `None`.
     - For `a = I`: `I.as_coeff_Mul()` gives `(1, I)`, `1.extract_multiplicatively(-1)` returns `-1`. Not `None`.
     - So condition is False, so `cont` stays `1`, `list_args` stays `[3, I]`.
   - Now loop `for i, a in enumerate(list_args)`:
     - `i` takes values `0, 1`.
     - `a` takes values `3, I`.
     - `list_args` stays `[3, I]` throughout because we only modify inside loop if condition met.
     - Condition: `b, e = a.as_base_exp()`:
       - For `a = 3`: `as_base_exp()` gives `(3, 1)`. `e.is_Mul` is False, so no modification.
       - For `a = I`: `as_base_exp()` gives `(I, 1)`. `e.is_Mul` is False, so no modification.
     - So `list_args` unchanged: `[3, I]`.
   - So states:
     - `i = [0, 1]`
     - `a = [3, I]`
     - `list_args` at each iteration: first iteration `list_args = [3, I]`, second iteration `list_args = [3, I]`. Since it doesn't change, we repeat the same list twice.

[/THOUGHT]

[ANSWER]
1 from .add import Add
2 from .mul import Mul, _keep_coeff
3 from .basic import Basic
4 from .expr import Expr
5 from .sympify import sympify
6 from .symbol import Dummy
7 from sympy.utilities.iterables import (common_prefix, common_suffix,
8         variations, iterable, is_sequence)
9 from sympy.concrete.summations import Sum
10 from sympy.integrals.integrals import Integral
11 from .symbol import Dummy
12 
13 def factor_terms(expr: Expr | complex, radical=False, clear=False, fraction=False, sign=True) -> Expr:
14     def do(expr):
15         from sympy.concrete.summations import Sum
16         from sympy.integrals.integrals import Integral
17         is_iterable = iterable(expr)
18 
19         if not isinstance(expr, Basic) or expr.is_Atom:
20             if is_iterable:
21                 return type(expr)([do(i) for i in expr])
22             return expr
23 
24         if expr.is_Pow or expr.is_Function or \
25                 is_iterable or not hasattr(expr, 'args_cnc'):
26             args = expr.args
27             newargs = tuple([do(i) for i in args])
28             if newargs == args:
29                 return expr
30             return expr.func(*newargs)
31 
32         if isinstance(expr, (Sum, Integral)):
33             return _factor_sum_int(expr,
34                 radical=radical, clear=clear,
35                 fraction=fraction, sign=sign)
36 
37         cont, p = expr.as_content_primitive(radical=radical, clear=clear)
38         if p.is_Add:
39             list_args = [do(a) for a in Add.make_args(p)]
40 
41             if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None
42                        for a in list_args):
43                 cont = -cont
44                 list_args = [-a for a in list_args]
45 
46             special = {}
47             for i, a in enumerate(list_args):## [STATE]i=[0,1][/STATE] [STATE]a=[3, I][/STATE] [STATE]list_args=[[3, I], [3, I]][/STATE]
48                 b, e = a.as_base_exp()
49                 if e.is_Mul and e != Mul(*e.args):
50                     list_args[i] = Dummy()
51                     special[list_args[i]] = a
52 
53             p = Add._from_args(list_args)
54             p = gcd_terms(p,
55                 isprimitive=True,
56                 clear=clear,
57                 fraction=fraction).xreplace(special)
58         elif p.args:
59             p = p.func(
60                 *[do(a) for a in p.args])
61         rv = _keep_coeff(cont, p, clear=clear, sign=sign)
62         return rv
63     expr2 = sympify(expr)
64     return do(expr2)
[/ANSWER]