[OUTPUT]
[ANSWER]
1 from numbers import Integral, Real
2 from itertools import chain
3 from collections import Counter
4 import numpy as np
5 from scipy import sparse
6 from ..base import clone, TransformerMixin
7 from ..utils._estimator_html_repr import _VisualBlock
8 from ..pipeline import _fit_transform_one, _transform_one, _name_estimators
9 from ..preprocessing import FunctionTransformer
10 from ..utils import Bunch
11 from ..utils import _safe_indexing
12 from ..utils import _get_column_indices
13 from ..utils._param_validation import HasMethods, Interval, StrOptions, Hidden
14 from ..utils._set_output import _get_output_config, _safe_set_output
15 from ..utils import check_pandas_support
16 from ..utils.metaestimators import _BaseComposition
17 from ..utils.validation import check_array, check_is_fitted, _check_feature_names_in
18 from ..utils.validation import _num_samples
19 from ..utils.parallel import delayed, Parallel
20 
21 __all__ = ["ColumnTransformer", "make_column_transformer", "make_column_selector"]
22 _ERR_MSG_1DCOLUMN = (
23     "1D data passed to a transformer that expects 2D data. "
24     "Try to specify the column selection as a list of one "
25     "item instead of a scalar."
26 )
27 
28 class ColumnTransformer(TransformerMixin, _BaseComposition):
29 
30     _required_parameters = ["transformers"]
31 
32     _parameter_constraints: dict = {
33         "transformers": [list, Hidden(tuple)],
34         "remainder": [
35             StrOptions({"drop", "passthrough"}),
36             HasMethods(["fit", "transform"]),
37             HasMethods(["fit_transform", "transform"]),
38         ],
39         "sparse_threshold": [Interval(Real, 0, 1, closed="both")],
40         "n_jobs": [Integral, None],
41         "transformer_weights": [dict, None],
42         "verbose": ["verbose"],
43         "verbose_feature_names_out": ["boolean"],
44     }
45 
46     def __init__(
47         self,
48         transformers,
49         *,
50         remainder="drop",
51         sparse_threshold=0.3,
52         n_jobs=None,
53         transformer_weights=None,
54         verbose=False,
55         verbose_feature_names_out=True,
56     ):
57         self.transformers = transformers
58         self.remainder = remainder
59         self.sparse_threshold = sparse_threshold
60         self.n_jobs = n_jobs
61         self.transformer_weights = transformer_weights
62         self.verbose = verbose
63         self.verbose_feature_names_out = verbose_feature_names_out
64 
65     @property
66     def _transformers(self):
67         try:
68             return [(name, trans) for name, trans, _ in self.transformers]
69         except (TypeError, ValueError):
70             return self.transformers
71 
72     @_transformers.setter
73     def _transformers(self, value):
74         try:
75             self.transformers = [
76                 (name, trans, col)
77                 for ((name, trans), (_, _, col)) in zip(value, self.transformers)
78             ]
79         except (TypeError, ValueError):
80             self.transformers = value
81 
82     def set_output(self, *, transform=None):
83         super().set_output(transform=transform)
84 
85         transformers = (
86             trans
87             for _, trans, _ in chain(## [STATE]_, trans, _=['trans_0', 'trans_1', 'trans_2'][/STATE] [STATE]chain=('trans_0', 'trans_1', 'trans_2')[/STATE]
88                 self.transformers, getattr(self, "transformers_", [])
89             )
90             if trans not in {"passthrough", "drop"}
91         )
92         for trans in transformers:
93             _safe_set_output(trans, transform=transform)
94 
95         if self.remainder not in {"passthrough", "drop"}:
96             _safe_set_output(self.remainder, transform=transform)
97 
98         return self
99 
100     def get_params(self, deep=True):
101         return self._get_params("_transformers", deep=deep)
102 
103     def set_params(self, **kwargs):
104         self._set_params("_transformers", **kwargs)
105         return self
106 
107     def _iter(self, fitted=False, replace_strings=False, column_as_strings=False):
108         if fitted:
109             if replace_strings:
110 
111                 def replace_passthrough(name, trans, columns):
112                     if name not in self._name_to_fitted_passthrough:
113                         return name, trans, columns
114                     return name, self._name_to_fitted_passthrough[name], columns
115 
116                 transformers = [
117                     replace_passthrough(*trans) for trans in self.transformers_
118                 ]
119             else:
120                 transformers = self.transformers_
121         else:
122 
123             transformers = [
124                 (name, trans, column)
125                 for (name, trans, _), column in zip(self.transformers, self._columns)
126             ]
127 
128             if self._remainder[2]:
129                 transformers = chain(transformers, [self._remainder])
130         get_weight = (self.transformer_weights or {}).get
131 
132         output_config = _get_output_config("transform", self)
133         for name, trans, columns in transformers:
134             if replace_strings:
135 
136                 if trans == "passthrough":
137                     trans = FunctionTransformer(
138                         accept_sparse=True,
139                         check_inverse=False,
140                         feature_names_out="one-to-one",
141                     ).set_output(transform=output_config["dense"])
142                 elif trans == "drop":
143                     continue
144                 elif _is_empty_column_selection(columns):
145                     continue
146 
147             if column_as_strings:
148 
149                 columns_is_scalar = np.isscalar(columns)
150 
151                 indices = self._transformer_to_input_indices[name]
152                 columns = self.feature_names_in_[indices]
153 
154                 if columns_is_scalar:
155 
156                     columns = columns[0]
157 
158             yield (name, trans, columns, get_weight(name))
159 
160     def _validate_transformers(self):
161         if not self.transformers:
162             return
163 
164         names, transformers, _ = zip(*self.transformers)
165 
166         self._validate_names(names)
167 
168         for t in transformers:
169             if t in ("drop", "passthrough"):
170                 continue
171             if not (hasattr(t, "fit") or hasattr(t, "fit_transform")) or not hasattr(
172                 t, "transform"
173             ):
174 
175                 raise TypeError(
176                     "All estimators should implement fit and "
177                     "transform, or can be 'drop' or 'passthrough' "
178                     "specifiers. '%s' (type %s) doesn't." % (t, type(t))
179                 )
180 
181     def _validate_column_callables(self, X):
182         all_columns = []
183         transformer_to_input_indices = {}
184         for name, _, columns in self.transformers:
185             if callable(columns):
186                 columns = columns(X)
187             all_columns.append(columns)
188             transformer_to_input_indices[name] = _get_column_indices(X, columns)
189 
190         self._columns = all_columns
191         self._transformer_to_input_indices = transformer_to_input_indices
192 
193     def _validate_remainder(self, X):
194         self._n_features = X.shape[1]
195         cols = set(chain(*self._transformer_to_input_indices.values()))
196         remaining = sorted(set(range(self._n_features)) - cols)
197         self._remainder = ("remainder", self.remainder, remaining)
198         self._transformer_to_input_indices["remainder"] = remaining
199 
200     @property
201     def named_transformers_(self):
202 
203         return Bunch(**{name: trans for name, trans, _ in self.transformers_})
204 
205     def _get_feature_name_out_for_transformer(
206         self, name, trans, column, feature_names_in
207     ):
208         column_indices = self._transformer_to_input_indices[name]
209         names = feature_names_in[column_indices]
210         if trans == "drop" or _is_empty_column_selection(column):
211             return
212         elif trans == "passthrough":
213             return names
214 
215         if not hasattr(trans, "get_feature_names_out"):
216             raise AttributeError(
217                 f"Transformer {name} (type {type(trans).__name__}) does "
218                 "not provide get_feature_names_out."
219             )
220         return trans.get_feature_names_out(names)
221 
222     def get_feature_names_out(self, input_features=None):
223         check_is_fitted(self)
224         input_features = _check_feature_names_in(self, input_features)
225 
226         transformer_with_feature_names_out = []
227         for name, trans, column, _ in self._iter(fitted=True):
228             feature_names_out = self._get_feature_name_out_for_transformer(
229                 name, trans, column, input_features
230             )
231             if feature_names_out is None:
232                 continue
233             transformer_with_feature_names_out.append((name, feature_names_out))
234 
235         if not transformer_with_feature_names_out:
236 
237             return np.array([], dtype=object)
238 
239         return self._add_prefix_for_feature_names_out(
240             transformer_with_feature_names_out
241         )
242 
243     def _add_prefix_for_feature_names_out(self, transformer_with_feature_names_out):
244         if self.verbose_feature_names_out:
245 
246             names = list(
247                 chain.from_iterable(
248                     (f"{name}__{i}" for i in feature_names_out)
249                     for name, feature_names_out in transformer_with_feature_names_out
250                 )
251             )
252             return np.asarray(names, dtype=object)
253 
254         feature_names_count = Counter(
255             chain.from_iterable(s for _, s in transformer_with_feature_names_out)
256         )
257         top_6_overlap = [
258             name for name, count in feature_names_count.most_common(6) if count > 1
259         ]
260         top_6_overlap.sort()
261         if top_6_overlap:
262             if len(top_6_overlap) == 6:
263 
264                 names_repr = str(top_6_overlap[:5])[:-1] + ", ...]"
265             else:
266                 names_repr = str(top_6_overlap)
267             raise ValueError(
268                 f"Output feature names: {names_repr} are not unique. Please set "
269                 "verbose_feature_names_out=True to add prefixes to feature names"
270             )
271 
272         return np.concatenate(
273             [name for _, name in transformer_with_feature_names_out],
274         )
275 
276     def _update_fitted_transformers(self, transformers):
277 
278         fitted_transformers = iter(transformers)
279         transformers_ = []
280         self._name_to_fitted_passthrough = {}
281 
282         for name, old, column, _ in self._iter():
283             if old == "drop":
284                 trans = "drop"
285             elif old == "passthrough":
286 
287                 func_transformer = next(fitted_transformers)
288                 trans = "passthrough"
289 
290                 self._name_to_fitted_passthrough[name] = func_transformer
291             elif _is_empty_column_selection(column):
292                 trans = old
293             else:
294                 trans = next(fitted_transformers)
295             transformers_.append((name, trans, column))
296 
297         assert not list(fitted_transformers)
298         self.transformers_ = transformers_
299 
300     def _validate_output(self, result):
301         names = [
302             name for name, _, _, _ in self._iter(fitted=True, replace_strings=True)
303         ]
304         for Xs, name in zip(result, names):
305             if not getattr(Xs, "ndim", 0) == 2:
306                 raise ValueError(
307                     "The output of the '{0}' transformer should be 2D (scipy "
308                     "matrix, array, or pandas DataFrame).".format(name)
309                 )
310 
311     def _record_output_indices(self, Xs):
312         idx = 0
313         self.output_indices_ = {}
314 
315         for transformer_idx, (name, _, _, _) in enumerate(
316             self._iter(fitted=True, replace_strings=True)
317         ):
318             n_columns = Xs[transformer_idx].shape[1]
319             self.output_indices_[name] = slice(idx, idx + n_columns)
320             idx += n_columns
321 
322         all_names = [t[0] for t in self.transformers] + ["remainder"]
323         for name in all_names:
324             if name not in self.output_indices_:
325                 self.output_indices_[name] = slice(0, 0)
326 
327     def _log_message(self, name, idx, total):
328         if not self.verbose:
329             return None
330         return "(%d of %d) Processing %s" % (idx, total, name)
331 
332     def _fit_transform(self, X, y, func, fitted=False, column_as_strings=False):
333         transformers = list(
334             self._iter(
335                 fitted=fitted, replace_strings=True, column_as_strings=column_as_strings
336             )
337         )
338         try:
339             return Parallel(n_jobs=self.n_jobs)(
340                 delayed(func)(
341                     transformer=clone(trans) if not fitted else trans,
342                     X=_safe_indexing(X, column, axis=1),
343                     y=y,
344                     weight=weight,
345                     message_clsname="ColumnTransformer",
346                     message=self._log_message(name, idx, len(transformers)),
347                 )
348                 for idx, (name, trans, column, weight) in enumerate(transformers, 1)
349             )
350         except ValueError as e:
351             if "Expected 2D array, got 1D array instead" in str(e):
352                 raise ValueError(_ERR_MSG_1DCOLUMN) from e
353             else:
354                 raise
355 
356     def fit(self, X, y=None):
357         self._validate_params()
358 
359         self.fit_transform(X, y=y)
360         return self
361 
362     def fit_transform(self, X, y=None):
363         self._validate_params()
364         self._check_feature_names(X, reset=True)
365 
366         X = _check_X(X)
367 
368         self._check_n_features(X, reset=True)
369         self._validate_transformers()
370         self._validate_column_callables(X)
371         self._validate_remainder(X)
372 
373         result = self._fit_transform(X, y, _fit_transform_one)
374 
375         if not result:
376             self._update_fitted_transformers([])
377 
378             return np.zeros((X.shape[0], 0))
379 
380         Xs, transformers = zip(*result)
381 
382         if any(sparse.issparse(X) for X in Xs):
383             nnz = sum(X.nnz if sparse.issparse(X) else X.size for X in Xs)
384             total = sum(
385                 X.shape[0] * X.shape[1] if sparse.issparse(X) else X.size for X in Xs
386             )
387             density = nnz / total
388             self.sparse_output_ = density < self.sparse_threshold
389         else:
390             self.sparse_output_ = False
391 
392         self._update_fitted_transformers(transformers)
393         self._validate_output(Xs)
394         self._record_output_indices(Xs)
395 
396         return self._hstack(list(Xs))
397 
398     def transform(self, X):
399         check_is_fitted(self)
400         X = _check_X(X)
401 
402         fit_dataframe_and_transform_dataframe = hasattr(
403             self, "feature_names_in_"
404         ) and hasattr(X, "columns")
405 
406         if fit_dataframe_and_transform_dataframe:
407             named_transformers = self.named_transformers_
408 
409             non_dropped_indices = [
410                 ind
411                 for name, ind in self._transformer_to_input_indices.items()
412                 if name in named_transformers
413                 and isinstance(named_transformers[name], str)
414                 and named_transformers[name] != "drop"
415             ]
416 
417             all_indices = set(chain(*non_dropped_indices))
418             all_names = set(self.feature_names_in_[ind] for ind in all_indices)
419 
420             diff = all_names - set(X.columns)
421             if diff:
422                 raise ValueError(f"columns are missing: {diff}")
423         else:
424 
425             self._check_n_features(X, reset=False)
426 
427         Xs = self._fit_transform(
428             X,
429             None,
430             _transform_one,
431             fitted=True,
432             column_as_strings=fit_dataframe_and_transform_dataframe,
433         )
434         self._validate_output(Xs)
435 
436         if not Xs:
437 
438             return np.zeros((X.shape[0], 0))
439 
440         return self._hstack(list(Xs))
441 
442     def _hstack(self, Xs):
443         if self.sparse_output_:
444             try:
445 
446                 converted_Xs = [
447                     check_array(X, accept_sparse=True, force_all_finite=False)
448                     for X in Xs
449                 ]
450             except ValueError as e:
451                 raise ValueError(
452                     "For a sparse output, all columns should "
453                     "be a numeric or convertible to a numeric."
454                 ) from e
455 
456             return sparse.hstack(converted_Xs).tocsr()
457         else:
458             Xs = [f.toarray() if sparse.issparse(f) else f for f in Xs]
459             config = _get_output_config("transform", self)
460             if config["dense"] == "pandas" and all(hasattr(X, "iloc") for X in Xs):
461                 pd = check_pandas_support("transform")
462                 output = pd.concat(Xs, axis=1)
463 
464                 output_samples = output.shape[0]
465                 if any(_num_samples(X) != output_samples for X in Xs):
466                     raise ValueError(
467                         "Concatenating DataFrames from the transformer's output lead to"
468                         " an inconsistent number of samples. The output may have Pandas"
469                         " Indexes that do not match."
470                     )
471 
472                 if not self.verbose_feature_names_out:
473                     return output
474 
475                 transformer_names = [
476                     t[