[INPUT]
```
{
    "self": {
        "_loaded_entry_points": false,
        "_backend_to_gui_framework": {
            "module://matplotlib.backends.backend_agg": "unknown"
        },
        "_name_to_module": {
            "notebook": "nbagg"
        }
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
<|python_tag|>
import importlib.metadata as im
from matplotlib import _parse_to_version_info

class BackendRegistry:
    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {'gtk3agg': 'gtk3', 'gtk3cairo': 'gtk3', 'gtk4agg': 'gtk4', 'gtk4cairo': 'gtk4', 'macosx': 'macosx', 'nbagg': 'nbagg', 'notebook': 'nbagg', 'qtagg': 'qt', 'qtcairo': 'qt', 'qt5agg': 'qt5', 'qt5cairo': 'qt5', 'tkagg': 'tk', 'tkcairo': 'tk', 'webagg': 'webagg', 'wx': 'wx', 'wxagg': 'wx', 'wxcairo': 'wx', 'agg': 'headless', 'cairo': 'headless', 'pdf': 'headless', 'pgf': 'headless', 'ps': 'headless', 'svg': 'headless', 'template': 'headless'}
    _GUI_FRAMEWORK_TO_BACKEND = {'gtk3': 'gtk3agg', 'gtk4': 'gtk4agg', 'headless': 'agg', 'macosx': 'macosx', 'qt': 'qtagg', 'qt5': 'qt5agg', 'qt6': 'qtagg', 'tk': 'tkagg', 'wx': 'wxagg'}

    def __init__(self):
        self._loaded_entry_points = False
        self._backend_to_gui_framework = {}
        self._name_to_module = {'notebook': 'nbagg'}

    def _ensure_entry_points_loaded(self):
        if not self._loaded_entry_points:
            entries = self._read_entry_points()
            self._validate_and_store_entry_points(entries)
            self._loaded_entry_points = True

    def _read_entry_points(self):
        import importlib.metadata as im
        entry_points = im.entry_points(group='matplotlib.backend')
        entries = [(entry.name, entry.value) for entry in entry_points]

        def backward_compatible_entry_points(entries, module_name, threshold_version, names, target):
            from matplotlib import _parse_to_version_info
            try:
                module_version = im.version(module_name)
                if _parse_to_version_info(module_version) < threshold_version:
                    for name in names:
                        entries.append((name, target))
            except im.PackageNotFoundError:
                pass
        names = [entry[0] for entry in entries]
        if 'inline' not in names:
            backward_compatible_entry_points(entries, 'matplotlib_inline', (0, 1, 7), ['inline'], 'matplotlib_inline.backend_inline')
        if 'ipympl' not in names:
            backward_compatible_entry_points(entries, 'ipympl', (0, 9, 4), ['ipympl', 'widget'], 'ipympl.backend_nbagg')
        return entries

    def _validate_and_store_entry_points(self, entries):
        for name, module in set(entries):
            name = name.lower()
            if name.startswith('module://'):
                raise RuntimeError(f"Entry point name '{name}' cannot start with 'module://'")
            if name in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK:
                raise RuntimeError(f"Entry point name '{name}' is a built-in backend")
            if name in self._backend_to_gui_framework:
                raise RuntimeError(f"Entry point name '{name}' duplicated")
            self._name_to_module[name] = 'module://' + module
            self._backend_to_gui_framework[name] = 'unknown'

    def list_all(self):
        self._ensure_entry_points_loaded()
        return [*self.list_builtin(), *self._backend_to_gui_framework]

    def list_builtin(self, filter_=None):
        if filter_ == BackendFilter.INTERACTIVE:
            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items() if v != 'headless']
        elif filter_ == BackendFilter.NON_INTERACTIVE:
            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items() if v == 'headless']
        return [*self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK]
[/PYTHON]

Functions called during the execution:
[PYTHON]
matplotlib.lib.matplotlib.backends.registry._ensure_entry_points_loaded

def _ensure_entry_points_loaded(self):
    # Load entry points, if they have not already been loaded.
    if not self._loaded_entry_points:
        entries = self._read_entry_points()
        self._validate_and_store_entry_points(entries)
        self._loaded_entry_points = True

matplotlib.lib.matplotlib.backends.registry.list_builtin

def list_builtin(self, filter_=None):
    """
    Return list of backends that are built into Matplotlib.

    Parameters
    ----------
    filter_ : `~.BackendFilter`, optional
        Filter to apply to returned backends. For example, to return only
        non-interactive backends use `.BackendFilter.NON_INTERACTIVE`.

    Returns
    -------
    list of str
        Backend names.
    """
    if filter_ == BackendFilter.INTERACTIVE:
        return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()
                if v != "headless"]
    elif filter_ == BackendFilter.NON_INTERACTIVE:
        return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()
                if v == "headless"]

    return [*self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK]


[/PYTHON]
<answer>
[INPUT]
```
{
    "self": {
        "_loaded_entry_points": false,
        "_backend_to_gui_framework": {
            "module://matplotlib.backends.backend_agg": "unknown"
        },
        "_name_to_module": {
            "notebook": "nbagg"
        }
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]
[/answer]
</|python_tag|>