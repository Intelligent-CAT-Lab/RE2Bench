[INPUT]
{
    "self": {
        "transformers": [
            ["scale", {
                "standard": true,
                "mean": {
                    "X1": 0.0,
                    "X2": 0.0,
                    "X3": 3.0
                },
                "var": {
                    "X1": 0.33333333333333326,
                    "X2": 1.0,
                    "X3": 1.0
                },
                "scale": {
                    "X1": 0.5773502691896258,
                    "X2": 1.0,
                    "X3": 1.0
                },
                "n_samples_seen_": 3,
                "n_features_in_": 3,
                "feature_names_in_": [
                    "X1",
                    "X2",
                    "X3"
                ]
            }, [
                "X1",
                "X2"
            ]]
        ],
        "remainder": "passthrough",
        "sparse_threshold": 0.3,
        "n_jobs": null,
        "transformer_weights": null,
        "verbose": false,
        "verbose_feature_names_out": true,
        "n_features_in_": 3,
        "_columns": [
            [
                "X1",
                "X2"
            ]
        ],
        "_transformer_to_input_indices": {
            "scale": [
                0,
                1
            ],
            "remainder": [
                2
            ]
        },
        "_n_features": 3,
        "_remainder": [
            "remainder",
            "passthrough",
            [
                2
            ]
        ],
        "sparse_output_": false,
        "_name_to_fitted_passthrough": {
            "remainder": {
                "func": "<function identity at 0x13c11eac0>",
                "inverse_func": "<function identity at 0x13c11eac0>",
                "validate": false,
                "accept_sparse": true,
                "check_inverse": false,
                "feature_names_out": "one-to-one",
                "kw_args": {},
                "inv_kw_args": {},
                "_sklearn_output_config": {
                    "transform": {
                        "dense": false
                    }
                },
                "n_features_in_": 1
            }
        },
        "transformers_": [
            [
                "scale",
                {
                    "standard": true,
                    "mean": {
                        "X1": 0.0,
                        "X2": 0.0,
                        "X3": 3.0
                    },
                    "var": {
                        "X1": 0.33333333333333326,
                        "X2": 1.0,
                        "X3": 1.0
                    },
                    "scale": {
                        "X1": 0.5773502691896258,
                        "X2": 1.0,
                        "X3": 1.0
                    },
                    "n_samples_seen_": 3,
                    "n_features_in_": 3,
                    "feature_names_in_": [
                        "X1",
                        "X2",
                        "X3"
                    ]
                },
                [
                    "X1",
                    "X2"
                ]
            ],
            [
                "remainder",
                "passthrough",
                [
                    2
                ]
            ]
        ],
        "output_indices_": {
            "scale": [
                0,
                2
            ],
            "remainder": [
                2,
                3
            ]
        }
    },
    "args": {
        "Xs": [
            [
                [
                    -1.73205081,
                    -1.
                ],
                [
                    1.73205081,
                    1.
                ]
            ],
            [
                2.,
                5.
            ]
        ]
    },
    "kwargs": {}
}
[/INPUT]
[/OUTPUT]
<tool: python>
from numbers import Integral, Real
from itertools import chain
from collections import Counter
import numpy as np
from scipy import sparse
from ..base import clone, TransformerMixin
from ..utils._estimator_html_repr import _VisualBlock
from ..pipeline import _fit_transform_one, _transform_one, _name_estimators
from ..preprocessing import FunctionTransformer
from ..utils import Bunch
from ..utils import _safe_indexing
from ..utils import _get_column_indices
from ..utils._param_validation import HasMethods, Interval, StrOptions, Hidden
from ..utils._set_output import _get_output_config, _safe_set_output
from ..utils import check_pandas_support
from ..utils.metaestimators import _BaseComposition
from ..utils.validation import check_array, check_is_fitted, _check_feature_names_in
from ..utils.parallel import delayed, Parallel
__all__ = ['ColumnTransformer', 'make_column_transformer', 'make_column_selector']
_ERR_MSG_1DCOLUMN = '1D data passed to a transformer that expects 2D data. Try to specify the column selection as a list of one item instead of a scalar.'

class ColumnTransformer(TransformerMixin, _BaseComposition):
    _required_parameters = ['transformers']
    _parameter_constraints: dict = {'transformers': [list, Hidden(tuple)], 'remainder': [StrOptions({'drop', 'passthrough'}), HasMethods(['fit', 'transform']), HasMethods(['fit_transform', 'transform'])], 'sparse_threshold': [Interval(Real, 0, 1, closed='both')], 'n_jobs': [Integral, None], 'transformer_weights': [dict, None], 'verbose': ['verbose'], 'verbose_feature_names_out': ['boolean']}

    def __init__(self, transformers, *, remainder='drop', sparse_threshold=0.3, n_jobs=None, transformer_weights=None, verbose=False, verbose_feature_names_out=True):
        self.transformers = transformers
        self.remainder = remainder
        self.sparse_threshold = sparse_threshold
        self.n_jobs = n_jobs
        self.transformer_weights = transformer_weights
        self.verbose = verbose
        self.verbose_feature_names_out = verbose_feature_names_out

    @property
    def _transformers(self):
        try:
            return [(name, trans) for name, trans, _ in self.transformers]
        except (TypeError, ValueError):
            return self.transformers

    @_transformers.setter
    def _transformers(self, value):
        try:
            self.transformers = [(name, trans, col) for (name, trans), (_, _, col) in zip(value, self.transformers)]
        except (TypeError, ValueError):
            self.transformers = value

    def set_output(self, *, transform=None):
        super().set_output(transform=transform)
        transformers = (trans for _, trans, _ in chain(self.transformers, getattr(self, 'transformers_', [])) if trans not in {'passthrough', 'drop'})
        for trans in transformers:
            _safe_set_output(trans, transform=transform)
        return self

    def get_params(self, deep=True):
        return self._get_params('_transformers', deep=deep)

    def set_params(self, **kwargs):
        self._set_params('_transformers', **kwargs)
        return self

    def _iter(self, fitted=False, replace_strings=False, column_as_strings=False):
        if fitted:
            if replace_strings:

                def replace_passthrough(name, trans, columns):
                    if name not in self._name_to_fitted_passthrough:
                        return (name, trans, columns)
                    return (name, self._name_to_fitted_passthrough[name], columns)
                transformers = [replace_passthrough(*trans) for trans in self.transformers_]
            else:
                transformers = self.transformers_
        else:
            transformers = [(name, trans, column) for (name, trans, _), column in zip(self.transformers, self._columns)]
            if self._remainder[2]:
                transformers = chain(transformers, [self._remainder])
        get_weight = (self.transformer_weights or {}).get
        output_config = _get_output_config('transform', self)
        for name, trans, columns in transformers:
            if replace_strings:
                if trans == 'passthrough':
                    trans = FunctionTransformer(accept_sparse=True, check_inverse=False, feature_names_out='one-to-one').set_output(transform=output_config['dense'])
                elif trans == 'drop':
                    continue
                elif _is_empty_column_selection(columns):
                    continue
            if column_as_strings:
                columns_is_scalar = np.isscalar(columns)
                indices = self._transformer_to_input_indices[name]
                columns = self.feature_names_in_[indices]
                if columns_is_scalar:
                    columns = columns[0]
            yield (name, trans, columns, get_weight(name))

    def _validate_transformers(self):
        if not self.transformers:
            return
        names, transformers, _ = zip(*self.transformers)
        self._validate_names(names)
        for t in transformers:
            if t in ('drop', 'passthrough'):
                continue
            if not (hasattr(t, 'fit') or hasattr(t, 'fit_transform')) or not hasattr(t, 'transform'):
                raise TypeError("All estimators should implement fit and transform, or can be 'drop' or 'passthrough' specifiers. '%s' (type %s) doesn't." % (t, type(t)))

    def _validate_column_callables(self, X):
        all_columns = []
        transformer_to_input_indices = {}
        for name, _, columns in self.transformers:
            if callable(columns):
                columns = columns(X)
            all_columns.append(columns)
            transformer_to_input_indices[name] = _get_column_indices(X, columns)
        self._columns = all_columns
        self._transformer_to_input_indices = transformer_to_input_indices

    def _validate_remainder(self, X):
        self._n_features = X.shape[1]
        cols = set(chain(*self._transformer_to_input_indices.values()))
        remaining = sorted(set(range(self._n_features)) - cols)
        self._remainder = ('remainder', self.remainder, remaining)
        self._transformer_to_input_indices['remainder'] = remaining

    @property
    def named_transformers_(self):
        return Bunch(**{name: trans for name, trans, _ in self.transformers_})

    def _get_feature_name_out_for_transformer(self, name, trans, column, feature_names_in):
        column_indices = self._transformer_to_input_indices[name]
        names = feature_names_in[column_indices]
        if trans == 'drop' or _is_empty_column_selection(column):
            return
        elif trans == 'passthrough':
            return names
        if not hasattr(trans, 'get_feature_names_out'):
            raise AttributeError(f'Transformer {name} (type {type(trans).__name__}) does not provide get_feature_names_out.')
        return trans.get_feature_names_out(names)

    def get_feature_names_out(self, input_features=None):
        check_is_fitted(self)
        input_features = _check_feature_names_in(self, input_features)
        transformer_with_feature_names_out = []
        for name, trans, column, _ in self._iter(fitted=True):
            feature_names_out = self._get_feature_name_out_for_transformer(name, trans, column, input_features)
            if feature_names_out is None:
                continue
            transformer_with_feature_names_out.append((name, feature_names_out))
        if not transformer_with_feature_names_out:
            return np.array([], dtype=object)
        return self._add_prefix_for_feature_names_out(transformer_with_feature_names_out)

    def _add_prefix_for_feature_names_out(self, transformer_with_feature_names_out):
        if self.verbose_feature_names_out:
            names = list(chain.from_iterable(((f'{name}__{i}' for i in feature_names_out) for name, feature_names_out in transformer_with_feature_names_out)))
            return np.asarray(names, dtype=object)
        feature_names_count = Counter(chain.from_iterable((s for _, s in transformer_with_feature_names_out)))
        top_6_overlap = [name for name, count in feature_names_count.most_common(6) if count > 1]
        top_6_overlap.sort()
        if top_6_overlap:
            if len(top_6_overlap) == 6:
                names_repr = str(top_6_overlap[:5])[:-1] + ', ...]'
            else:
                names_repr = str(top_6_overlap)
            raise ValueError(f'Output feature names: {names_repr} are not unique. Please set verbose_feature_names_out=True to add prefixes to feature names')
        return np.concatenate([name for _, name in transformer_with_feature_names_out])

    def _update_fitted_transformers(self, transformers):
        fitted_transformers = iter(transformers)
        transformers_ = []
        self._name_to_fitted_passthrough = {}
        for name, old, column, _ in self._iter():
            if old == 'drop':
                trans = 'drop'
            elif old == 'passthrough':
                func_transformer = next(fitted_transformers)
                trans = 'passthrough'
                self._name_to_fitted_passthrough[name] = func_transformer
            elif _is_empty_column_selection(column):
                trans = old
            else:
                trans = next(fitted_transformers)
            transformers_.append((name, trans, column))
        assert not list(fitted_transformers)
        self.transformers_ = transformers_

    def _validate_output(self, result):
        names = [name for name, _, _, _ in self._iter(fitted=True, replace_strings=True)]
        for Xs, name in zip(result, names):
            if not getattr(Xs, 'ndim', 0) == 2:
                raise ValueError("The output of the '{0}' transformer should be 2D (scipy matrix, array, or pandas DataFrame).".format(name))

    def _record_output_indices(self, Xs):
        idx = 0
        self.output_indices_ = {}
        for transformer_idx, (name, _, _, _) in enumerate(self._iter(fitted=True, replace_strings=True)):
            n_columns = Xs[transformer_idx].shape[1]
            self.output_indices_[name] = slice(idx, idx + n_columns)
            idx += n_columns
        all_names = [t[0] for t in self.transformers] + ['remainder']
        for name in all_names:
            if name not in self.output_indices_:
                self.output_indices_[name] = slice(0, 0)

    def _log_message(self, name, idx, total):
        if not self.verbose:
            return None
        return '(%d of %d) Processing %s' % (idx, total, name)

    def _fit_transform(self, X, y, func, fitted=False, column_as_strings=False):
        transformers = list(self._iter(fitted=fitted, replace_strings=True, column_as_strings=column_as_strings))
        try:
            return Parallel(n_jobs=self.n_jobs)((delayed(func)(transformer=clone(trans) if not fitted else trans, X=_safe_indexing(X, column, axis=1), y=y, weight=weight, message_clsname='ColumnTransformer', message=self._log_message(name, idx, len(transformers))) for idx, (name, trans, column, weight) in enumerate(transformers, 1)))
        except ValueError as e:
            if 'Expected 2D array, got 1D array instead' in str(e):
                raise ValueError(_ERR_MSG_1DCOLUMN) from e
            else:
                raise

    def fit(self, X, y=None):
        self._validate_params()
        self.fit_transform(X, y=y)
        return self

    def fit_transform(self, X, y=None):
        self._validate_params()
        self._check_feature_names(X, reset=True)
        X = _check_X(X)
        self._check_n_features(X, reset=True)
        self._validate_transformers()
        self._validate_column_callables(X)
        self._validate_remainder(X)
        result = self._fit_transform(X, y, _fit_transform_one)
        if not result:
            self._update_fitted_transformers([])
            return np.zeros((X.shape[0], 0))
        Xs, transformers = zip(*result)
        if any((sparse.issparse(X) for X in Xs)):
            nnz = sum((X.nnz if sparse.issparse(X) else X.size for X in Xs))
            total = sum((X.shape[0] * X.shape[1] if sparse.issparse(X) else X.size for X in Xs))
            density = nnz / total
            self.sparse_output_ = density < self.sparse_threshold
        else:
            self.sparse_output_ = False
        self._update_fitted_transformers(transformers)
        self._validate_output(Xs)
        self._record_output_indices(Xs)
        return self._hstack(list(Xs))

    def transform(self, X):
        check_is_fitted(self)
        X = _check_X(X)
        fit_dataframe_and_transform_dataframe = hasattr(self, 'feature_names_in_') and hasattr(X, 'columns')
        if fit_dataframe_and_transform_dataframe:
            named_transformers = self.named_transformers_
            non_dropped_indices = [ind for name, ind in self._transformer_to_input_indices.items() if name in named_transformers and isinstance(named_transformers[name], str) and (named_transformers[name] != 'drop')]
            all_indices = set(chain(*non_dropped_indices))
            all_names = set((self.feature_names_in_[ind] for ind in all_indices))
            diff = all_names - set(X.columns)
            if diff:
                raise ValueError(f'columns are missing: {diff}')
        else:
            self._check_n_features(X, reset=False)
        Xs = self._fit_transform(X, None, _transform_one, fitted=True, column_as_strings=fit_dataframe_and_transform_dataframe)
        self._validate_output(Xs)
        if not Xs:
            return np.zeros((X.shape[0], 0))
        return self._hstack(list(Xs))

    def _hstack(self, Xs):
        if self.sparse_output_:
            try:
                converted_Xs = [check_array(X, accept_sparse=True, force_all_finite=False) for X in Xs]
            except ValueError as e:
                raise ValueError('For a sparse output, all columns should be a numeric or convertible to a numeric.') from e
            return sparse.hstack(converted_Xs).tocsr()
        else:
            Xs = [f.toarray() if sparse.issparse(f) else f for f in Xs]
            config = _get_output_config('transform', self)
            if config['dense'] == 'pandas' and all((hasattr(X, 'iloc') for X in Xs)):
                pd = check_pandas_support('transform')
                output = pd.concat(Xs, axis=1)
                if not self.verbose_feature_names_out:
                    return output
                transformer_names = [t[0] for t in self._iter(fitted=True, replace_strings=True)]
                feature_names_outs = [X.columns for X in Xs if X.shape[1] != 0]
                names_out = self._add_prefix_for_feature_names_out(list(zip(transformer_names, feature_names