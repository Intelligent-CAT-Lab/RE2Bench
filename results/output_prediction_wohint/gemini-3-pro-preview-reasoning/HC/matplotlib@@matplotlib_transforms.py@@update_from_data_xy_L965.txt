The user wants to predict the output of the function `Bbox.update_from_data_xy` based on the provided code and input.

**Step-by-step Execution Simulation:**

1.  **Initialize Parameters**:
    *   `self` is a `Bbox` object.
        *   `self._points` = `[[inf, inf], [-inf, -inf]]`
        *   `self._minpos` = `[inf, inf]`
        *   `self._ignore` = `True` # Note: effectively ignored because `ignore` arg is passed.
    *   `args`:
        *   `xy`: A numpy array-like structure.
            ```python
            [[1., 1.],
             [1., 1.],
             [1., 1.]]
            ```
        *   `ignore`: `True`
        *   `updatex`: `True`
        *   `updatey`: `True`

2.  **Call `update_from_data_xy(self, xy, ignore=True, updatex=True, updatey=True)`**:
    *   Check `if len(xy) == 0`: `len(xy)` is 3. Condition is False.
    *   Create Path: `path = Path(xy)`.
        *   `Path.__init__` stores these vertices. `path.vertices` is now the (3, 2) array of `1.0`s.

3.  **Call `self.update_from_path(path, ignore=True, updatex=True, updatey=True)`**:
    *   **Determine `ignore` state**: The argument `ignore` is `True` (not None), so `ignore` remains `True`.
    *   **Check skip conditions**: `path.vertices.size` is 6 (not 0). `updatex` or `updatey` is True. Proceed.
    *   **Initialize working variables**:
        *   Since `ignore` is `True`:
            *   `points` = `[[np.inf, np.inf], [-np.inf, -np.inf]]` (Standard "null" bbox, min=+inf, max=-inf).
            *   `minpos` = `[np.inf, np.inf]`.
    *   **Compute `valid_points`**:
        *   Checks finite values in `path.vertices`. All are `1.0` (finite).
        *   `valid_points` is `[True, True, True]`.
    *   **Update X (`if updatex`)**:
        *   Extract `x` values: `[1.0, 1.0, 1.0]`.
        *   `min_x` = 1.0, `max_x` = 1.0.
        *   Update `points`:
            *   `points[0, 0] = min(inf, 1.0)` -> 1.0.
            *   `points[1, 0] = max(-inf, 1.0)` -> 1.0.
        *   Update `minpos`:
            *   `x[x > 0]` is `[1.0, 1.0, 1.0]`. Min is 1.0.
            *   `minpos[0] = min(inf, 1.0)` -> 1.0.
    *   **Update Y (`if updatey`)**:
        *   Extract `y` values: `[1.0, 1.0, 1.0]`.
        *   `min_y` = 1.0, `max_y` = 1.0.
        *   Update `points`:
            *   `points[0, 1] = min(inf, 1.0)` -> 1.0.
            *   `points[1, 1] = max(-inf, 1.0)` -> 1.0.
        *   Update `minpos`:
            *   `y[y > 0]` is `[1.0, 1.0, 1.0]`. Min is 1.0.
            *   `minpos[1] = min(inf, 1.0)` -> 1.0.
    *   **Check for changes**:
        *   Current calculated `points` is `[[1.0, 1.0], [1.0, 1.0]]`.
        *   `self._points` (from input context) is `[[inf, inf], [-inf, -inf]]`.
        *   They are different.
    *   **Apply updates**:
        *   `self.invalidate()` is called.
        *   `self._points` updated to `[[1.0, 1.0], [1.0, 1.0]]`.
        *   `self._minpos` updated to `[1.0, 1.0]`.
    *   **Return**: The function ends without a return statement, returning `None`.

4.  **Back in `update_from_data_xy`**:
    *   The function ends without a return statement, returning `None`.

5.  **Final Output**:
    *   The return value is `None`. In JSON format, this is `null`.

[OUTPUT]
null
[/OUTPUT]