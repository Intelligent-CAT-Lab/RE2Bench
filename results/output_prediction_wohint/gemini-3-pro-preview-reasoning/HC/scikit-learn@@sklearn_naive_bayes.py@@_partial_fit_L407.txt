The `_partial_fit` method updates the `GaussianNB` estimator with a batch of samples.

**Step-by-step execution:**

1.  **Initialization**:
    *   `_refit` is `True`, so `self.classes_` is set to `None`.
    *   `_check_partial_fit_first_call`: `classes` is provided (`[0, 1, 2]`). `self.classes_` becomes `[0, 1, 2]`. It is the first call.
    *   `validate_data`: Input `X` (shape 120, 2) and `y` (shape 120) are validated. `self.n_features_in_` is set to 2.

2.  **Epsilon Calculation**:
    *   The `var_smoothing` parameter is `1e-09`.
    *   `epsilon_` is calculated as `var_smoothing * max(var(X))`.
    *   **Feature 0 (Sepal Width approx.)**:
        *   Mean $\approx 3.055$.
        *   Variance $\approx 0.213$.
    *   **Feature 1 (Petal Length approx.)**:
        *   Mean $\approx 3.736$.
        *   Variance $\approx 3.116$.
    *   Max variance is $\approx 3.116$.
    *   `self.epsilon_` = $10^{-9} \times 3.11613264 \approx 3.116 \times 10^{-9}$.

3.  **Initializing Statistics**:
    *   `theta_` (means), `var_` (variances), `class_count_` (counts), `class_prior_` (priors) are initialized to zeros since it's the first call.

4.  **Looping through Classes**:
    *   **Class 0**:
        *   Rows 0-39 (40 samples).
        *   Feature 0: sum = 137.5, mean = 3.4375, var = 0.16684375.
        *   Feature 1: sum = 57.6, mean = 1.44, var = 0.0219.
        *   `class_count_[0]` = 40.
        *   `theta_[0]` = `[3.4375, 1.44]`.
        *   `var_[0]` = `[0.16684375, 0.0219]`.
    *   **Class 1**:
        *   Rows 40-79 (40 samples).
        *   Feature 0: sum = 110.0, mean = 2.75, var = 0.1095.
        *   Feature 1: sum = 168.1, mean = 4.2025, var = 0.20574375.
        *   `class_count_[1]` = 40.
        *   `theta_[1]` = `[2.75, 4.2025]`.
        *   `var_[1]` = `[0.1095, 0.20574375]`.
    *   **Class 2**:
        *   Rows 80-119 (40 samples).
        *   Feature 0: sum = 119.1, mean = 2.9775, var = 0.11724375.
        *   Feature 1: sum = 222.6, mean = 5.565, var = 0.286275.
        *   `class_count_[2]` = 40.
        *   `theta_[2]` = `[2.9775, 5.565]`.
        *   `var_[2]` = `[0.11724375, 0.286275]`.

5.  **Finalizing**:
    *   `self.var_` is updated by adding `self.epsilon_`.
    *   `self.class_prior_` is computed as `class_count_ / sum(class_count_)` -> `[1/3, 1/3, 1/3]`.

[OUTPUT]
```json
{
    "class_count_": [
        40.0,
        40.0,
        40.0
    ],
    "class_prior_": [
        0.3333333333333333,
        0.3333333333333333,
        0.3333333333333333
    ],
    "classes_": [
        0,
        1,
        2
    ],
    "epsilon_": 3.116132638888889e-09,
    "n_features_in_": 2,
    "priors": null,
    "theta_": [
        [
            3.4375,
            1.44
        ],
        [
            2.75,
            4.2025
        ],
        [
            2.9775,
            5.565
        ]
    ],
    "var_": [
        [
            0.16684375311613265,
            0.02190000311613264
        ],
        [
            0.10950000311613264,
            0.20574375311613265
        ],
        [
            0.11724375311613265,
            0.28627500311613265
        ]
    ],
    "var_smoothing": 1e-09
}
```
[/OUTPUT]