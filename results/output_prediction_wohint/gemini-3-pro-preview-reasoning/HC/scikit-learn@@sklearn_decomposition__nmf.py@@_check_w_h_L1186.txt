[THOUGHT]
The function `_check_w_h` is called.
1.  **Input Analysis**:
    *   `X` is a 2x2 array `[[1., 1.], [1., 1.]]`.
    *   `W` is `None`.
    *   `H` is `None`.
    *   `update_H` is `True`.
    *   `self.n_components` is "auto" (and `self._n_components` is "auto").
    *   `self.init` is `None`.

2.  **Flow inside `_check_w_h`**:
    *   The `if` condition `self.init == 'custom' and update_H` evaluates to False because `init` is `None`.
    *   The `elif not update_H` evaluates to False because `update_H` is True.
    *   The `else` block is executed.
        *   `self._n_components` is "auto", so it is updated to `X.shape[1]`, which is 2.
        *   `_initialize_nmf` is called with arguments `X`, `n_components=2`, `init=None`, `random_state=None`.

3.  **Flow inside `_initialize_nmf`**:
    *   `n_samples` = 2, `n_features` = 2.
    *   `init` is `None`. Since `n_components` (2) <= `min(n_samples, n_features)` (2), `init` is set to `"nndsvda"`.
    *   **SVD Calculation**:
        *   `X` is `[[1., 1.], [1., 1.]]`. This is a rank-1 matrix.
        *   Singular values are roughly $\sigma_1 = 2.0$ and $\sigma_2 = 0.0$.
        *   First component ($j=0$):
            *   Left singular vector $u_0 \approx [0.707, 0.707]$. Right singular vector $v_0 \approx [0.707, 0.707]$.
            *   $\sqrt{\sigma_1} \approx 1.414$.
            *   $W[:, 0] = 1.414 \times [0.707, 0.707] = [1., 1.]$.
            *   $H[0, :] = 1.414 \times [0.707, 0.707] = [1., 1.]$.
        *   Second component ($j=1$):
            *   Singular value $\sigma_2 = 0$.
            *   $W[:, 1]$ and $H[1, :]$ will be computed as 0s because of the singular value multiplier.
        *   Resulting matrices before NNDSVDa filling:
            *   $W = [[1., 0.], [1., 0.]]$
            *   $H = [[1., 1.], [0., 0.]]$
    *   **NNDSVDa filling**:
        *   `avg = X.mean() = 1.0`.
        *   `W[W == 0] = avg`: Zeros in `W` are replaced by 1.0. `W` becomes `[[1., 1.], [1., 1.]]`.
        *   `H[H == 0] = avg`: Zeros in `H` are replaced by 1.0. `H` becomes `[[1., 1.], [1., 1.]]`.
    *   Returns `W`, `H`.

4.  **Return**:
    *   `_check_w_h` returns the tuple `(W, H)`.
    *   Both are 2x2 arrays containing all `1.`s.

[/THOUGHT]

[OUTPUT]
[
    "array([[1., 1.],\n       [1., 1.]])",
    "array([[1., 1.],\n       [1., 1.]])"
]
[/OUTPUT]