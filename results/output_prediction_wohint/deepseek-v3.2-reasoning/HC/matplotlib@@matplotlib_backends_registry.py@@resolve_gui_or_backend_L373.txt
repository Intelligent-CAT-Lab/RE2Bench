[THOUGHT]
1. The function `resolve_gui_or_backend` is called with `gui_or_backend = "no-such-name"`.
2. The argument is lowercased (already lowercase).
3. `backend_for_gui_framework("no-such-name")` is called, which looks up "no-such-name" in `_GUI_FRAMEWORK_TO_BACKEND`. It is not present, so it returns `None`.
4. Since `backend_for_gui_framework` returned `None`, the function proceeds to the `try` block and calls `resolve_backend("no-such-name")`.
5. In `resolve_backend`, the argument is lowercased again. It checks the built-in backends (`_BUILTIN_BACKEND_TO_GUI_FRAMEWORK`) and the dynamically loaded backends (`_backend_to_gui_framework`). Both are empty or do not contain "no-such-name", so `gui` remains `None`.
6. Since `gui` is `None` and the backend does not start with "module://", it proceeds to check if entry points are loaded. `_loaded_entry_points` is `false`, so it calls `_ensure_entry_points_loaded()`.
7. `_ensure_entry_points_loaded` reads entry points from the environment. Given the input state, there are no entry points, and the backward compatibility checks do not add any (assuming the relevant packages are not installed). Thus, `_backend_to_gui_framework` remains empty.
8. After loading entry points, `gui` is still `None` because "no-such-name" is not in `_backend_to_gui_framework`.
9. Since `gui` is `None` (not "unknown"), the function raises `RuntimeError("'no-such-name' is not a recognised backend name")`.
10. This exception is caught in `resolve_gui_or_backend`, which then raises a new `RuntimeError("'no-such-name' is not a recognised GUI loop or backend name")`.
11. Therefore, the function does not return a value; it raises an exception.
[/THOUGHT]

[OUTPUT]
{
  "error": "RuntimeError: 'no-such-name' is not a recognised GUI loop or backend name"
}
[/OUTPUT]