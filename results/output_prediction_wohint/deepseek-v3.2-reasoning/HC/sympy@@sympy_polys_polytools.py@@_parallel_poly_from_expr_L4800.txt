[THOUGHT]
1. The function `_parallel_poly_from_expr` is called with `exprs` as `["2", "-1*2*cos(phi)"]` and `opt` as `{}`.
2. First, `sympify` converts the strings to SymPy objects: `"2"` becomes `Integer(2)` and `"-1*2*cos(phi)"` becomes `-2*cos(phi)`, where `cos` is the cosine function and `phi` is a symbol.
3. Since `opt` has no generators specified, `_parallel_dict_from_expr` determines generators from the expressions. The only symbol present is `phi`, so `opt.gens` is set to `[phi]`.
4. The expressions are converted to dictionary representations. For `2`, a constant, the representation is `{(): 2}`. For `-2*cos(phi)`, which is not a polynomial in `phi`, it is treated as a constant term with respect to `phi`, so the representation is `{(): -2*cos(phi)}`.
5. The coefficients from both dictionaries are extracted: `[2, -2*cos(phi)]`. `construct_domain` is called on this list. Since `-2*cos(phi)` involves a transcendental function, the domain is set to `EX` (expression domain).
6. The coefficients are converted to domain elements in `EX`.
7. Poly objects are created using `_from_dict`. For the first, `Poly._from_dict({(): EX(2)}, opt)` yields `Poly(2, phi, domain='EX')`. For the second, `Poly._from_dict({(): EX(-2*cos(phi))}, opt)` yields `Poly(-2*cos(phi), phi, domain='EX')`.
8. `opt` is updated with `gens=[phi]` and `domain='EX'`.
9. The function returns a tuple: a list of Poly objects and the updated options.

[/THOUGHT]

[OUTPUT]
{
  "polys": [
    "Poly(2, phi, domain='EX')",
    "Poly(-2*cos(phi), phi, domain='EX')"
  ],
  "opt": {
    "gens": ["phi"],
    "domain": "EX"
  }
}
[/OUTPUT]