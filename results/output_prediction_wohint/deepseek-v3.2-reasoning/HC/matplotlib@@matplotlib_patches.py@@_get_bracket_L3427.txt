[THOUGHT]
We compute step by step.
Given:
x0=358.0020718742162, y0=329.4117647058823
x1=220.00292802695185, y1=329.4117647058823
width=25.0, length=5.0, angle=null (None)

In _get_bracket:
1. cos_t, sin_t = get_cos_sin(x1, y1, x0, y0)
   => dx = x0 - x1 = 137.99914384726435, dy = 0
   => d = sqrt(dx^2) = 137.99914384726435
   => cos_t = dx/d = 1.0, sin_t = 0.0
2. Call get_normal_points(x0, y0, cos_t, sin_t, width)
   => With cos_t=1.0, sin_t=0.0, width=25.0:
      cos_t1, sin_t1 = sin_t, -cos_t = 0.0, -1.0
      cos_t2, sin_t2 = -sin_t, cos_t = 0.0, 1.0
   => x1 = 358.0020718742162 + 25.0*0.0 = 358.0020718742162
      y1 = 329.4117647058823 + 25.0*(-1.0) = 304.4117647058823
      x2 = 358.0020718742162 + 25.0*0.0 = 358.0020718742162
      y2 = 329.4117647058823 + 25.0*1.0 = 354.4117647058823
   => So get_normal_points returns (358.0020718742162, 304.4117647058823, 358.0020718742162, 354.4117647058823)
   Now these values are assigned to x1,y1,x2,y2 (overwriting the original x1,y1).
3. dx, dy = length * cos_t, length * sin_t = 5.0 * 1.0, 5.0 * 0.0 = 5.0, 0.0
4. vertices_arrow = [
   (x1 + dx, y1 + dy) = (358.0020718742162+5.0, 304.4117647058823) = (363.0020718742162, 304.4117647058823),
   (x1, y1) = (358.0020718742162, 304.4117647058823),
   (x2, y2) = (358.0020718742162, 354.4117647058823),
   (x2 + dx, y2 + dy) = (358.0020718742162+5.0, 354.4117647058823) = (363.0020718742162, 354.4117647058823)
   ]
5. codes_arrow = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO] which are typically 1,2,2,2.
6. Since angle is None, we skip the rotation.
7. Return (vertices_arrow, codes_arrow)

Therefore, the output is a tuple containing the list of vertices and the list of codes.
[/THOUGHT]

[OUTPUT]
[
  [
    [363.0020718742162, 304.4117647058823],
    [358.0020718742162, 304.4117647058823],
    [358.0020718742162, 354.4117647058823],
    [363.0020718742162, 354.4117647058823]
  ],
  [1, 2, 2, 2]
]
[/OUTPUT]