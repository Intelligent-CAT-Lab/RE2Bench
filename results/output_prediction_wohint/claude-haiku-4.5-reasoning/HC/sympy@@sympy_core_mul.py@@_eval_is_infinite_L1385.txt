[THOUGHT]
Let me trace through the execution of `_eval_is_infinite` for the expression "pi/2".

1. The method `_eval_is_infinite` first calls `self._eval_is_zero_infinite_helper()`.

2. For "pi/2", this is a multiplication operation. In SymPy, pi/2 would be represented as `Mul(pi, Rational(1, 2))` with arguments being pi and 1/2.

3. Tracing through `_eval_is_zero_infinite_helper`:
   - Initialize: `seen_zero = False`, `seen_infinite = False`
   
   - For arg = pi:
     - `pi.is_zero` = False (pi is not zero)
     - `pi.is_infinite` = False (pi is not infinite)
     - So we enter the `else` branch
     - Both conditions `seen_zero is False and a.is_zero is None` and `seen_infinite is False and a.is_infinite is None` are False (because a.is_zero and a.is_infinite are False, not None)
     - No changes to seen_zero or seen_infinite
   
   - For arg = Rational(1, 2):
     - `(1/2).is_zero` = False
     - `(1/2).is_infinite` = False
     - Same logic as above, no changes
   
   - Return `(False, False)`

4. Back in `_eval_is_infinite`:
   - `seen_zero = False`, `seen_infinite = False`
   - Check `if seen_infinite is True and seen_zero is False:` → `False is True` = False
   - Check `elif seen_infinite is False:` → `False is False` = True ✓
   - Execute `return False`

The function returns `False` because pi/2 is a finite (non-infinite) number.
[/THOUGHT]

[OUTPUT]
```
false
```
[/OUTPUT]