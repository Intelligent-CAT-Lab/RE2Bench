[THOUGHT]
Let me trace through the execution of `_eval_is_zero_infinite_helper` for the expression `-pi/4`:

1. The function is called on `self = "-pi/4"`, which is a `Mul` object in SymPy.

2. In SymPy, `-pi/4` is represented as a multiplication of components: `-1 * pi * (1/4)`.

3. Initial state:
   - `seen_zero = False`
   - `seen_infinite = False`

4. The function iterates through `self.args`. For `-pi/4`, the args would be the constituent parts like `[-1, pi, Rational(1, 4)]` or similar.

5. For each component in the expression `-pi/4`:
   - `-1`: `is_zero = False`, `is_infinite = False`
   - `pi`: `is_zero = False`, `is_infinite = False`
   - `1/4`: `is_zero = False`, `is_infinite = False`

6. For each argument `a`:
   - `if a.is_zero:` → False (since all components are not zero)
   - `elif a.is_infinite:` → False (since all components are finite)
   - `else:` → True, but in the else block:
     - `if seen_zero is False and a.is_zero is None:` → False (because `a.is_zero` is False, not None)
     - `if seen_infinite is False and a.is_infinite is None:` → False (because `a.is_infinite` is False, not None)
   - No state changes occur

7. After iterating through all args with no state modifications:
   - `seen_zero` remains `False`
   - `seen_infinite` remains `False`

8. Return `(seen_zero, seen_infinite)` = `(False, False)`
</THOUGHT>

[OUTPUT]
```
{
    "result": [false, false]
}
```
[/OUTPUT]