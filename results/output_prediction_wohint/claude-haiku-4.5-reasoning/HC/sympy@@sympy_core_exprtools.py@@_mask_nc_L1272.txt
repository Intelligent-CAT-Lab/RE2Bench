[THOUGHT]

Let me trace through the execution of `_mask_nc` with the given input.

**Input:**
- `eq` = "2 - 2*cos(phi)" (a SymPy expression representing 2 - 2*cos(phi))
- `name` = None

**Step-by-step execution:**

1. `name = name or 'mask'` → `name = 'mask'` (since name is None)

2. A `numbered_names()` generator is created that yields 'mask0', 'mask1', etc.

3. `expr = eq` → `expr = 2 - 2*cos(phi)` (a SymPy expression)

4. **Critical check:** `if expr.is_commutative:`
   - The expression `2 - 2*cos(phi)` contains only:
     - `2`: a numeric constant (commutative)
     - `phi`: a symbol (commutative by default)
     - `cos(phi)`: trigonometric function of a commutative expression (commutative)
     - `2 - 2*cos(phi)`: subtraction/addition of commutative terms (commutative)
   - Therefore, `expr.is_commutative` evaluates to **True**

5. Since the condition is True, the function returns immediately:
   ```python
   return (eq, {}, [])
   ```

This returns a 3-tuple containing:
- The original expression: `2 - 2*cos(phi)`
- An empty dictionary: `{}`
- An empty list: `[]`

The function never enters the loop that would identify and mask non-commutative elements, because the entire expression is commutative.

[/THOUGHT]

[OUTPUT]
```json
{
    "expr": "2 - 2*cos(phi)",
    "mapping": {},
    "nc_syms": []
}
```
[/OUTPUT]