[THOUGHT]
We call precision_score(y_true=None, y_pred=None).

1. precision_score calls precision_recall_fscore_support(y_true=None, y_pred=None, average='binary', warn_for=('precision',), ...).
2. precision_recall_fscore_support calls _check_targets(y_true, y_pred).
3. _check_targets first calls check_consistent_length(y_true, y_pred). Since both inputs are None, the internal list of arrays to check is empty and check_consistent_length does not raise.
4. _check_targets then calls type_of_target(y_true) with y_true == None.
5. In type_of_target, the initial validity check fails for None (it's not sequence-like nor has __array__), so type_of_target raises a ValueError with the message formatted using %r: "Expected array-like (array or non-string sequence), got None".
6. This exception propagates out, so precision_score raises ValueError with that message.

No numeric result is returned; a ValueError is raised.
[/THOUGHT]
[OUTPUT]
```
{
    "exception": "ValueError",
    "message": "Expected array-like (array or non-string sequence), got None"
}
```
[/OUTPUT]