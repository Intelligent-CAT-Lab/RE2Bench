[THOUGHT]
We run _parallel_dict_from_expr_no_gens on exprs = [cos(phi)] with opt having only "fraction": true (other attributes treated as None).

1. Determine coefficient-test function: opt.domain is None, opt.extension is None, opt.greedy is not False (None != False) so the code uses
   _is_coeff(factor) -> factor is S.ImaginaryUnit.
   opt.series is not False (None), so decompose_power_rat will be used.

2. Iterate expressions:
   - For expr = cos(phi):
     - It's not an Equality; Add.make_args(expr) returns (cos(phi),) so we have a single term = cos(phi).
     - Mul.make_args(term) returns (cos(phi),) so the single factor = cos(phi).
     - Check if factor is a coefficient: factor.is_Number is False and _is_coeff(factor) is False, so it is treated as a non-coefficient factor.
     - Use decompose_power_rat on cos(phi): it returns (base=cos(phi), exp=1).
     - elements becomes { cos(phi): 1 }, gens adds cos(phi).
     - The term entry is (coeff=[], elements={cos(phi): 1}).

3. After processing all exprs:
   - reprs = [[ ([], {cos(phi): 1}) ]]
   - gens = tuple(sorted gens) -> (cos(phi),)
   - k = 1, indices = { cos(phi): 0 }

4. Build polys:
   - For the single term: monom = [0]*1 -> [0]; populate monom[0] = 1 -> monom = (1,)
   - coefficient list is empty, so Mul(*coeff) yields 1
   - poly = { (1,): 1 }
   - polys = [ { (1,): 1 } ]

5. The function returns (polys, tuple(gens)), i.e.
   (
     [ { (1,): 1 } ],
     (cos(phi),)
   )

JSON can't have tuple or SymPy objects directly, so represent the monomial tuple as the string "(1,)" and the generator as the string "cos(phi)". The coefficient 1 is represented as the integer 1.
[/THOUGHT]

[OUTPUT]
```
{
  "polys": [
    {
      "(1,)": 1
    }
  ],
  "gens": [
    "cos(phi)"
  ]
}
```
[/OUTPUT]