[THOUGHT]
We call parse_email with data being a str: "download-url: VaLuE".

1. The function detects data is a str and uses email.parser.Parser(...).parsestr(data). This yields a Message with a single header "download-url" whose value is "VaLuE" and an empty payload/body.

2. It iterates over the parsed header names (lowercasing them to name). For the header "download-url", headers = parsed.get_all(name) yields ["VaLuE"]. The loop over headers appends the string value "VaLuE" to value = ["VaLuE"]. valid_encoding remains True.

3. It looks up raw_name = _EMAIL_TO_RAW_MAPPING.get(name). In packaging.metadata mapping, "download-url" maps to the raw field name "download_url". So raw_name is "download_url".

4. Since raw_name is in _STRING_FIELDS (download_url is a single-valued string field) and len(value) == 1, it sets raw["download_url"] = "VaLuE". unparsed remains empty.

5. It calls _get_payload(parsed, data). Because data is a str, _get_payload returns the message payload (an empty string for no body). Since payload is empty, no changes are made to raw or unparsed.

6. The function returns a tuple (raw, unparsed). raw is {"download_url": "VaLuE"} and unparsed is {}.

So the returned value is the tuple ({"download_url": "VaLuE"}, {}).
[/THOUGHT]

[OUTPUT]
```
[
    {
        "download_url": "VaLuE"
    },
    {}
]
```
[/OUTPUT]