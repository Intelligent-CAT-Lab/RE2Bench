[THOUGHT]
We need to simulate BboxBase.splitx.

1. extents calls get_points().flatten().
   - get_points() (on a Bbox instance) returns the 2x2 points array given by self._points:
     [[0.125, 0.1],
      [0.9,   0.9]]
   - flatten() gives extents = [x0, y0, x1, y1] = [0.125, 0.1, 0.9, 0.9].

2. Extract variables:
   - x0 = 0.125
   - y0 = 0.1
   - x1 = 0.9
   - y1 = 0.9
   - w = x1 - x0 = 0.9 - 0.125 = 0.775

3. splitx builds xf = [0, *args, 1] where args are [0.85, 0.85]:
   - xf = [0, 0.85, 0.85, 1]

4. itertools.pairwise(xf) produces pairs:
   - (0, 0.85)
   - (0.85, 0.85)
   - (0.85, 1)

5. For each pair (xf0, xf1) construct a Bbox with points:
   [[x0 + xf0 * w, y0],
    [x0 + xf1 * w, y1]]

   Compute x positions:
   - For xf = 0 -> x = 0.125 + 0*0.775 = 0.125
   - For xf = 0.85 -> x = 0.125 + 0.85*0.775
       0.85 * 0.775 = 0.65875
       x = 0.125 + 0.65875 = 0.78375
   - For xf = 1 -> x = 0.125 + 1*0.775 = 0.9

6. The three resulting Bboxes (expressed as their point arrays) are:
   - [[0.125,   0.1], [0.78375, 0.9]]
   - [[0.78375, 0.1], [0.78375, 0.9]]
   - [[0.78375, 0.1], [0.9,     0.9]]

So splitx returns a list of three Bbox-like point arrays as above.
[/THOUGHT]

[OUTPUT]
```
{
    "return": [
        [[0.125, 0.1], [0.78375, 0.9]],
        [[0.78375, 0.1], [0.78375, 0.9]],
        [[0.78375, 0.1], [0.9, 0.9]]
    ]
}
```
[/OUTPUT]