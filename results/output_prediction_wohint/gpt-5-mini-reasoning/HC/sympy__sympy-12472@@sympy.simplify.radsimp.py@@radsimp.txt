[THOUGHT]
We call radsimp(expr=1/(a - b), symbolic=False, max_terms=1).

- Inside radsimp, handle(expr) is invoked.
- handle starts by computing n, d = fraction(expr) => n = 1, d = a - b.
- There's an early check: if not symbolic and d.free_symbols: since symbolic is False and d contains symbols a and b, this condition is true, so handle immediately returns the original expr (1/(a - b)).
- Back in radsimp, old = fraction(expr) is (1, a - b) and n, d = fraction(handle(expr)) is also (1, a - b), so old == (n, d) and the big transformation block is skipped.
- Minimal post-processing occurs and the function ultimately returns the same expression 1/(a - b).

Thus the result is unchanged: 1/(a - b).
[/THOUGHT]

[OUTPUT]
```
{
  "result": "1/(a - b)"
}
```