<think>
Step 1: The function decode_cf_datetime is called with the given arguments: num_dates, units, calendar.
Step 2: Since the num_dates is null, numpy will convert it to an array of dtype 'float64' (possibly with nan values). It is then flattened into a 1D array.
Step 3: The calendar is set to '366_day' based on the provided kwargs.
Step 4: Since use_cftime is not provided, the function first attempts to decode the date with pandas using _decode_datetime_with_pandas.
Step 5: _decode_datetime_with_pandas is called with the arguments flat_num_dates, units, and calendar. Inside this function:
   a. It checks if the calendar is not in _STANDARD_CALENDARS, which is true for '366_day'. Therefore, it raises an OutOfBoundsDatetime exception.
Step 6: Because of the raised exception, the function proceeds to decode the date with cftime using _decode_datetime_with_cftime.
Step 7: Inside _decode_datetime_with_cftime, it calls cftime.num2date with the num_dates, units, and calendar arguments.
Step 8: The resulting dates from cftime are then converted to numpy datetime64 objects using cftime_to_nptime.
Step 9: Finally, the decoded dates are reshaped to match the original shape of num_dates and returned.
</think>
[OUTPUT]
function_name = decode_cf_datetime
args = []
kwargs = {}
code_segment = """
    import numpy as np
    import pandas as pd
    from xarray.coding.times import decode_cf_datetime

    # Initialize num_dates as a numpy array
    num_dates = np.array([0, 1, 2])  # Example values

    # Define units and calendar
    units = "days since 0001-01-01"
    calendar = "366_day"

    # Call the decode_cf_datetime function
    decoded_dates = decode_cf_datetime(num_dates, units, calendar=calendar)

    print("Decoded Dates:", decoded_dates)
"""
[/OUTPUT]