[THOUGHT]
Let me trace through the execution of `resolve_gui_or_backend` with the given input:

1. `gui_or_backend = "no-such-name"` (a string)
   - It doesn't start with `'module://'`, so it's converted to lowercase:
   - `gui_or_backend = "no-such-name"` (already lowercase)

2. Call `self.backend_for_gui_framework("no-such-name")`
   - This calls `self._GUI_FRAMEWORK_TO_BACKEND.get("no-such-name".lower())`
   - `"no-such-name"` is not in `_GUI_FRAMEWORK_TO_BACKEND` dictionary (which contains: gtk3, gtk4, headless, macosx, qt, qt5, qt6, tk, wx)
   - Returns `None`

3. Since `backend is None`, we don't return early and proceed to the try block:
   - Call `self.resolve_backend("no-such-name")`

4. Inside `resolve_backend("no-such-name")`:
   - `backend = "no-such-name"` (string, not starting with "module://", so it stays as is)
   - Check if backend is known: `gui = self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.get("no-such-name") or self._backend_to_gui_framework.get("no-such-name")`
   - `"no-such-name"` is not in either dictionary, so `gui = None`
   - Not a "module://" backend
   - Since `gui is None` and `self._loaded_entry_points = False`, we call `_ensure_entry_points_loaded()`
   - After loading entry points, "no-such-name" still wouldn't be found, so `gui` remains `None`
   - Final check: `if gui is None:` is True, so it raises:
     - `RuntimeError(f"'{backend}' is not a recognised backend name")`
     - Which is: `RuntimeError("'no-such-name' is not a recognised backend name")`

5. This exception is caught by the `except Exception` clause in `resolve_gui_or_backend`
   - A new exception is raised:
   - `RuntimeError(f"'{gui_or_backend}' is not a recognised GUI loop or backend name")`
   - Which is: `RuntimeError("'no-such-name' is not a recognised GUI loop or backend name")`

The function raises a RuntimeError with that message.
[/THOUGHT]

[OUTPUT]
```
{
    "output": "RuntimeError: 'no-such-name' is not a recognised GUI loop or backend name"
}
```
[/OUTPUT]