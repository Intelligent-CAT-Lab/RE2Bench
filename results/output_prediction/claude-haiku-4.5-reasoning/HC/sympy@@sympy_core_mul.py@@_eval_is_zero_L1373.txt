[THOUGHT]
Let me trace through the execution of `_eval_is_zero` for the expression "pi/2":

1. `_eval_is_zero` calls `self._eval_is_zero_infinite_helper()` first.

2. In `_eval_is_zero_infinite_helper()`:
   - Initial state: `seen_zero = False`, `seen_infinite = False`
   
3. The Mul object for "pi/2" has args: `[pi, Rational(1,2)]` (or similar factors)

4. Loop iteration 1 (for pi):
   - `if a.is_zero:` → `if pi.is_zero:` → `if False:` → False (π is not zero)
   - `elif a.is_infinite:` → `if pi.is_infinite:` → `if False:` → False (π is not infinite)
   - `else:` branch executes:
     - `if seen_zero is False and a.is_zero is None:` → `if True and (False is None):` → `if True and False:` → False (π.is_zero is False, not None)
     - `if seen_infinite is False and a.is_infinite is None:` → `if True and (False is None):` → `if True and False:` → False
   - After iteration: `seen_zero = False`, `seen_infinite = False`

5. Loop iteration 2 (for Rational(1,2)):
   - Same logic as above - no conditions trigger
   - After iteration: `seen_zero = False`, `seen_infinite = False`

6. `_eval_is_zero_infinite_helper()` returns `(False, False)`

7. Back in `_eval_is_zero()`:
   ```python
   seen_zero, seen_infinite = (False, False)
   if seen_zero is False:  # This evaluates to True
       return False
   ```
   
Since `seen_zero is False` is True, the function returns `False`.

π/2 is neither zero nor infinite, so this is correct: the function returns False.
</THOUGHT>

[OUTPUT]
```
{
    "output": false        
}
```
[/OUTPUT]