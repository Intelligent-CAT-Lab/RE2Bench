Let's simulate the `split_super_sub` function step by step.  

**Input:** `text = "Fvec"`  

1. Length is `4` ≠ 0, so proceed.  
2. `pos = 0`, `name = None`, `supers = []`, `subs = []`.  
3. `pos < len(text)` → `0 < 4` → True.  
4. `start = pos + 1 = 1`.  
5. `text[pos:pos+2] = "Fv"` → not `"__"`.  
6. `pos_hat = text.find('^', start=1)`. No `'^'` found, so `pos_hat = 4`.  
7. `pos_usc = text.find('_', start=1)`. No `'_'` found, so `pos_usc = 4`.  
8. `pos_next = min(pos_hat, pos_usc) = 4`.  
9. `part = text[pos:pos_next] = text[0:4] = "Fvec"`.  
10. `pos = pos_next = 4`.  
11. `name is None` → `name = "Fvec"`.  
12. Loop again: `pos < len(text)?` → `4 < 4` → False, exit loop.  
13. Now `m = _name_with_digits_p.match(name)`.  
    - Pattern `"^([a-zA-Z]+)([0-9]+)$"` matches strings like `"Fvec"`?  
    - `"Fvec"` → letters only, no digits at end → no match → `m` is `None`.  
    - So skip the block with `subs.insert(0, sub)`.  

14. Return `(name, supers, subs)` → `("Fvec", [], [])`.  

The structure wants `"output": XXX` — output is a tuple `("Fvec", [], [])`.  

[OUTPUT]
```
{
    "output": ["Fvec", [], []]
}
```
[/OUTPUT]