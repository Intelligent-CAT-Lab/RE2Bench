Let's simulate the function step by step.  

**1. Parse the email:**  
Input data is a string: `"download-url: VaLuE"`.  
We call:  
```python
parsed = email.parser.Parser(policy=email.policy.compat32).parsestr("download-url: VaLuE")
```  
The parsed email has one header `download-url` (case-preserved as in input) with value `VaLuE`.  

**2. Iterate over `frozenset(parsed.keys())`:**  
The only key is `"download-url"` (original case).  
`name = name_with_case.lower()` → `"download-url"`.  
`headers = parsed.get_all(name) or []` → headers = `["VaLuE"]`.  

**3. Process `headers`:**  
`h = "VaLuE"` (it's a `str`, not `email.header.Header`).  
So `value.append(h)` → `value = ["VaLuE"]`.  
`valid_encoding = True`.  

**4. Map name to raw field:**  
`raw_name = _EMAIL_TO_RAW_MAPPING.get(name)`.  
We don't have that mapping defined in the provided snippet, but from standard metadata fields for Python packages, `download-url` maps to `download_url` (underscore). Let's assume that's defined elsewhere in the original code.  
`download-url` → `download_url`.  

**5. Check raw field type:**  
`download_url` is likely in `_STRING_FIELDS` (since it's a single URL).  
`len(value) == 1` → true, so `raw[raw_name] = value[0]` → `raw["download_url"] = "VaLuE"`.  

**6. No unparsed for this header.**  

**7. Get payload:**  
The email has no body (payload is empty string).  
`_get_payload(parsed, data)` will call `msg.get_payload()` → returns empty string (or maybe `None`?), but since `source` is a string, it returns payload as `""`.  
No `ValueError`, so `payload = ""`.  

**8. Check payload:**  
`if payload:` → `if ""` → `False`, so no description logic triggers.  

**9. Return:**  
`raw = {"download_url": "VaLuE"}`  
`unparsed = {}`  

Final output tuple: `({"download_url": "VaLuE"}, {})`.  

[THOUGHT]
The function returns a tuple: (raw_metadata_dict, unparsed_dict).  
Here raw_metadata_dict = {"download_url": "VaLuE"} and unparsed_dict = {}.

[OUTPUT]
```
{
    "output": ({"download_url": "VaLuE"}, {})
}
```
[/OUTPUT]