[THOUGHT]
We need to simulate StratifiedKFold._make_test_folds with n_splits=5, shuffle=False on the given y.

Key points of the implementation:
- It encodes class labels so classes are ordered by first appearance. For the provided y the encoding mapping is: original 0 -> encoded 0, original 2 -> encoded 1, original 1 -> encoded 2.
- For each encoded class k, it computes allocation of class members to the 5 folds. Each class has 50 samples, so allocation per fold is 10 samples per class per fold.
- The algorithm assigns fold indices to the samples of each class in the order those samples appear in y: each block of 10 successive occurrences of a given class gets assigned folds 0,1,2,3,4 respectively.
- So for each sample in original order, the fold assigned is floor(number_of_previous_occurrences_of_same_original_label / 10).

I iterated through the y sequence (150 elements), tracking for each original label how many times it has occurred so far, and computed fold = occ_before // 10, then incremented the occurrence counter. That yields the following test_folds array (one integer per sample, fold indices 0..4).
[/THOUGHT]

[OUTPUT]
{
    "output": [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,3,3,2,3,2,2,2,2,2,2,3,3,3,3,3,3,2,2,3,2,3,2,3,3,3,2,3,3,3,3,3,3,3,3,4,4,3,3,3,3,3,4,3,4,4,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]
}
[/OUTPUT]