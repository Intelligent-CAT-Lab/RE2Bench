[THOUGHT]
1. The input data is a str: "download-url: VaLuE", so parse_email will use email.parser.Parser(...).parsestr(data).
2. The parser will produce a Message with one header "download-url" whose value is "VaLuE" and an empty body.
3. In the loop, name_with_case becomes "download-url", name = name_with_case.lower() -> "download-url".
4. headers = parsed.get_all(name) returns ["VaLuE"]. Each header is a str, so value becomes ["VaLuE"]. valid_encoding remains True.
5. raw_name = _EMAIL_TO_RAW_MAPPING.get(name). The standard mapping maps the header "download-url" to the raw field name "download_url".
6. "download_url" is a single-valued string field, so raw["download_url"] = "VaLuE".
7. _get_payload(parsed, data) is called with source as a str; it returns the message payload, which is an empty string for this input. Since payload is falsy, nothing is added to raw or unparsed payload-wise.
8. unparsed remains empty.
9. The function returns the tuple (raw, unparsed), i.e. ({"download_url": "VaLuE"}, {}).

So the JSON output is the two-element tuple represented as a list: first dict with download_url, second the empty unparsed dict.
[/THOUGHT]
[OUTPUT]
```
{
    "output": [
        {
            "download_url": "VaLuE"
        },
        {}
    ]
}
```
[/OUTPUT]