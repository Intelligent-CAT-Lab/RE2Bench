[THOUGHT]
We simulate radsimp.handle on expr = 1/(a - b).

1. fraction(expr) gives n = 1, d = a - b.
2. expr is not an Atom and d is not an Atom, so proceed.
3. n is S.One, so branches that modify n don't run.
4. d is an Add (a - b). symbolic is True so we continue.
5. In the while loop we collect terms of the denominator:
   - Add.make_args(a - b) yields (a, -b).
   - For both terms no p2 (no square-root-containing factors) are found, so all parts go into the "other" group.
   - collected groups become {(): [a, -b]} which produces rterms = [(1, a - b)].
6. nrad = len(rterms) - (1 if first term is S.One else 0) = 1 - 1 = 0, so the loop breaks without changing n or d.
7. keep remains True, so handle returns _unevaluated_Mul(n, 1/d) which corresponds to 1/(a - b).

Therefore the output is 1/(a - b).
[/THOUGHT]
[OUTPUT]
```
{
    "output": "1/(a - b)"        
}
```
[/OUTPUT]