[THOUGHT]
1. resolve_gui_or_backend is called with gui_or_backend = "no-such-name".
2. It lowercases the input (stays "no-such-name").
3. It calls backend_for_gui_framework("no-such-name"), which looks up the class-level _GUI_FRAMEWORK_TO_BACKEND mapping. "no-such-name" is not present, so backend_for_gui_framework returns None.
4. Because backend is None, resolve_gui_or_backend calls self.resolve_backend("no-such-name") inside a try block.
5. resolve_backend lowercases the backend (still "no-such-name") and checks the built-in mapping _BUILTIN_BACKEND_TO_GUI_FRAMEWORK and self._backend_to_gui_framework for that key; neither has an entry, so gui is None.
6. gui is None and _loaded_entry_points is False, so resolve_backend calls _ensure_entry_points_loaded(), which reads entry points and validates/stores them. Given no entry points are present (and backward-compatible additions do not append any here), no new backends are registered; _loaded_entry_points becomes True.
7. After loading entry points, resolve_backend still finds no entry for "no-such-name" in _backend_to_gui_framework, so gui remains None.
8. Since gui is still None, resolve_backend raises RuntimeError("'no-such-name' is not a recognised backend name").
9. resolve_gui_or_backend catches this exception and raises a new RuntimeError with the message "'no-such-name' is not a recognised GUI loop or backend name".
10. Therefore the call results in a RuntimeError with that message.

[/THOUGHT]
[OUTPUT]
```
{
    "output": {
        "exc_type": "RuntimeError",
        "exc_msg": "'no-such-name' is not a recognised GUI loop or backend name"
    }
}
```
[/OUTPUT]