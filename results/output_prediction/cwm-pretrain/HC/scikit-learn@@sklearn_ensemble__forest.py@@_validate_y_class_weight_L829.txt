<think>
1. The function starts by calling `check_classification_targets(y)`. This function checks the type of target y and raises an error if it's not a valid classification type. The provided input is a binary classification target, so it passes this check.
2. Next, it calls `np.copy(y)` to create a copy of the input array y.
3. Since `self.class_weight` is None, the function continues with the rest of the logic.
4. It initializes `self.classes_` and `self.n_classes_` as empty lists.
5. It then creates a new array `y_store_unique_indices` with the same shape as y, initialized to 0.
6. The function loops over the columns of y (in this case, only one column) and uses `np.unique` to find the unique values and their indices in the original array.
7. `self.classes_` is updated with the unique values (in this case, [0, 1]), and `self.n_classes_` is updated with the number of unique values (in this case, 2).
8. The original y array is replaced with `y_store_unique_indices`, which contains the indices of the unique values.
9. Since `self.class_weight` is None, the function returns `(y, expanded_class_weight)`, where y is the array with unique value indices and expanded_class_weight is None.
</think>
[OUTPUT]
```
{
    "output": [
        [0],
        [0],
        [1],
        [0],
        [1],
        [0],
        [1],
        [0],
        [1],
        [1]
    ]
}
```
[/OUTPUT]
<|assistant|>

import json
import os
import re
from typing import Any, Dict, List, Literal, Optional, Tuple, Union

import jinja2

# Thanks to codingcodax for the next line and the commented out function
# You can find their implementation here:
# https://github.com/QuinqiuMeng/Battlecode-2024-RL

PARENT_DIR = os.path.dirname(os.path.abspath(__file__))


def prompt_instruction(
    self: Dict[str, Any],
    predict_what: Literal["output", "structure", "useful functions", "args"],
    predict_for: str = "",
    args: Optional[str] = None,
    kwargs: Optional[str] = None,
    with_skeleton: bool = False,
) -> str:
    """Prompt instructions for predicting output, structure, useful functions, or args."""

    predict_target = predict_what
    if predict_what == "output":
        predict_target += predict_for
    structure = "STRUCTURE" if predict_target in ["STRUCTURE", "output"] else "STRUCTURE"
    if predict_target == "args":
        predict_target = "function call"
        predict_for = "args"
    # if predict_what != "useful functions":
    #     if args is None:
    #         args = repr(self.get("args", {}))
    #     if kwargs is None:
    #         kwargs = repr(self.get("kwargs", {}))
    # if predict_what == "useful functions":
    #     target = f" {predict_target}" if predict_what == "output" else ""
    # else:
    #     target = f" {predict_target} for {predict_for}" if predict_what != "output" else ""

    if predict_target != "STRUCTURE":
        predict_target += f" for {predict_for}"
    if predict_what != "args":
        predict_target = "value" if predict_what == "output" else predict_target
        target = f"for predicting the {predict_target} of `{predict_for}`"
    else:
        target = f"for predicting the {predict_target} of the provided Python function"

    if predict_what != "args":
        predict_for_code = " if you have not already started doing so" if predict_what != "output" else ""
        if not predict_for_code and "return" in predict_for_code:
            predict_for_code = (
                predict_for_code + f", consider the returns of the called function `{predict_for}`"
            )
        predict_for_code = re.sub(
            r"return.*?\)",
            f"return{predict_for_code})",
            predict_for_code,
        )
        if "return" in predict_for_code:
            predict_for_code = "update `outputs` with"
        predict_for_code = re.sub(
            r"(?<=print.*\s)\{",
            "{\n\t\t" + predict_for_code + "\n\t\t}",
            predict_for_code,
        )
        predict_for_code = re.sub(r'(?<=print.*?"\s)\[', '[\n\t\t' + predict_for_code + "\n\t\t]", predict_for_code)
        predict_for_code = re.sub(r'(?<=print.*?\'\s)\[', '[\n\t\t' + predict_for_code + "\n\t\t]", predict_for_code)
    else:
        predict_for_code = predict_for

    # if predict_what != "output":
    #     predict_for_code = f'and update `outputs` with "{predict_for_code}"'
    if predict_what != "args" and predict_what != "useful functions":
        # Skeletons are useful for keeping track of seen elements in the output structure
        if with_skeleton:
            def add_skeleton(to_add: str, depth: int = 0) -> str:
                nonlocal predict_for_code
                indentation = "\t" * (depth + 1)
                predict_for_code = re.sub(
                    rf'(?<!\\)"\s\[\n{indentation}(?!\[\n{indentation}).*?\n{indentation}\]',
                    rf'"\s[\n{indentation}{to_add}\n{indentation}]\n{indentation}',
                    predict_for_code,
                )
                predict_for_code = re.sub(
                    rf"(?<!\\)'\s\[\n{indentation}(?!\[\n{indentation}).*?\n{indentation}\]",
                    rf"'\s[\n{indentation}{to_add}\n{indentation}]\n{indentation}",
                    predict_for_code,
                )

            add_skeleton("skeleton", depth=1)
            add_skeleton("skeleton = {}")
            predict_for_code = re.sub(r'skeleton = {}(.*)"', r'"skeleton = {}" + r\1', predict_for_code)
            predict_for_code = re.sub(r"print\(', \"\+\n", "print(\"')\n", predict_for_code)
            predict_for_code = re.sub(r"print\(, \"\+\n", "print(\"')\n", predict_for_code)
        if predict_what == "output":
            predict_for_code = re.sub(r"\(\{", "({", predict_for_code)
            predict_for_code = re.sub(r"\)", "} + ", predict_for_code)

        predict_for_code = predict_for_code.replace("()", "(function_to_predict)")
        # predict_for_code = f"Call `function_to_predict()` {predict_for_code}"
        # predict_for_code = (
        #     predict_for_code + "\n# Catch errors and return None if any occur.\nreturn None"
        # )
        predict_for_code = predict_for_code + "\nreturn function_to_predict"
    # predict_target = "" if predict_target == "function call" else predict_target
    predict_target = "" if predict_what in ["args", "output"] else predict_target
    prompt = self.get("prompt")
    assert (
        prompt["prediction_target"][predict_target] == "json.loads"
        or prompt["prediction_target"][predict_target] == "load_json_file"
        or not self.get("output")
    ), f"Prompt: {self['prompt']}, Prompt's prediction target {prompt['prediction_target'][predict_target]}, Output: {self.get('output')}"

    output = self.get("output")
    if isinstance(output, dict):
        output = output["data"]

    # File paths
    output_filename = self.get("example_file", {}).get("output_filename")
    if output_filename:
        output_filename = re.sub(r"\s+", "_", output_filename)
        output = output_filename
    elif output is not None:
        output = (
            output["meta"]["description"]
            if "meta" in output and "description" in output["meta"]
            else json.dumps(output)
        )
    # elif output is not None:
    #     output = json.dumps(output)

    # Output skeleton
    skeleton = self.get("output_skeleton")

    if skeleton is not None:
        assert output is None, "Output must be None if output_skeleton is not None"

        def add_skeleton(to_add: str, depth: int = 0):
            nonlocal skeleton
            indentation = "\t" * depth
            skeleton = re.sub(
                rf'(?<!\\)"\s\[\n{indentation}(?!\[\n{indentation}).*?\n{indentation}\]',
                rf'"\s[\n{indentation}{to_add}\n{indentation}]\n{indentation}',
                skeleton,
            )
            skeleton = re.sub(
                rf"(?<!\\)'\s\[\n{indentation}(?!\[\n{indentation}).*?\n{indentation}\]",
                rf"'\s[\n{indentation}{to_add}\n{indentation}]\n{indentation}",
                skeleton,
            )

        add_skeleton("skeleton", depth=1)
        add_skeleton("skeleton = {}")
        skeleton = re.sub(r'skeleton = {}(.*)"', r'"skeleton = {}" + r\1', skeleton)
        skeleton = re.sub(r"print\(', \"\+\n", "print(\"')\n", skeleton)
        skeleton = re.sub(r"print\(, \"\+\n", "print(\"')\n", skeleton)

        skeleton = skeleton.replace("skeleton = {} + r", "skeleton = {} + r\\")
        skeleton = skeleton.replace("skeleton = {} + ", "skeleton = {} + r\\")
        output = skeleton
    output = (
        output
        if output is not None
        else f"None, please use <error> to delimit which error message you are getting"
    )
    output = re.sub(r"\s+", " ", output).strip()

    # Args and kwargs
    args = self.get("example_file", {}).get("args") if args is None else args
    if args is not None and (predict_what == "args" or predict_what == "structure"):
        args = str(args)
    if args is not None:
        args = re.sub(r"\n", " ", args).strip()

    kwargs = self.get("example_file", {}).get("kwargs") if kwargs is None else kwargs
    if kwargs is not None and (predict_what == "args" or predict_what == "structure"):
        kwargs = str(kwargs)
    if kwargs is not None:
        kwargs = re.sub(r"\n", " ", kwargs).strip()

    args_kwargs_str = f"args={args}, kwargs={kwargs}" if args is not None and kwargs is not None else ""
    if args is not None and kwargs is None:
        args_kwargs_str = f"args={args}"
    if args is None and kwargs is not None:
        args_kwargs_str = f"kwargs={kwargs}"

    kwargs = {"target": target, "args": args, "kwargs": kwargs, "args_kwargs_str": args_kwargs_str}
    kwargs["predict_what"] = predict_what
    kwargs["predict_for_code"] = predict_for_code
    kwargs["output"] = output
    # kwargs["predict_target"] = predict_target
    # kwargs["target"] = target
    return self["instruction"].replace(
        "{{",
        "{",
    ).replace(
        "}}",
        "}",
    ).format(
        **kwargs,
    )


def parse_skeleton(skeleton: str, depth: int = 1) -> str:
    """Parse the output structure of the prediction output skeleton."""
    skeleton = re.sub(r"\s+", " ", skeleton).strip()
    # Return empty string if no skeleton is found
    if "skeleton" not in skeleton:
        return ""
    if "skeleton" in skeleton and not ("{" or "[" in skeleton):
        return ""

    regex = rf"[\{{\[][\s]*skeleton = {{}}"
    skeleton = re.sub(
        regex,
        "\n" + "\t" * depth,
        skeleton,
    )
    skeleton = skeleton.replace("}\n", "}\n\t").replace("]\n", "]\n\t").replace("\t", "    ")

    return f"\n{json.loads(skeleton.strip())[1:]}\n"


def replace_char_at(index: int, string: str, new_char: str) -> str:
    """Replace a character at a specified index in a string."""
    if index < 0 or index >= len(string):
        raise ValueError("Index out of bounds")
    return string[:index] + new_char + string[index + 1 :]


def correct_json_and_parse(text: str, load: bool = True) -> Union[List, Dict, None]:
    """Correct JSON by replacing any escaped double quotes with double quotes and parse it."""
    json_text = re.sub(r'\\"', '"', text)
    if "{" not in json_text and "[" not in json_text:
        return None
    return json.loads(json_text) if load else json_text


def trim_response(response: str) -> str:
    """Trim response to the first "}" or "]" if the response contains valid JSON."""
    for char in ["]", "}"]:
        if char in response:
            return response.split(char)[0] + char
    return response


def parse_response(
    self: Dict[str, Any],
    response: str,
    predict_what: Literal["output", "structure", "useful functions", "args"],
    predict_for: str,
    # load: bool = True,
) -> Union[List, Dict, None, Literal[False]]:
    """Parse prediction output, structure, useful functions, or args."""

    # Extract error if present
    if "<error>" in response and "</error>" in response:
        error = response.split("<error>")[1].split("</error>")[0].strip()
        return {
            "error": error,
        }

    # Trim to valid JSON
    response = trim_response(response)

    # Fallback to return input for function call
    if predict_what == "args" and predict_for and predict_for in response:
        if "(" in predict_for and ")" in predict_for:
            predict_for = predict_for.split("(")[0]
        # Find the first prediction with the right name
        names = re.findall(r"\w+", predict_for)
        response_split = response.split("\n")
        for name in names:
            response_new = [r for r in response_split if name in r]
            if response_new:
                response_new = response_new[0]
                response_split = response_new.split(" = ")
                response_new = response_split[-1]
                if "(" in response_new:
                    return response_new
                response_split = response_new.split("(")
                response_new = response_split[-1]
                if ")" in response_new:
                    return response_new.split(")")[0]
        # No match found, return as-is
        return response

    # Nothing to return if no valid JSON is found
    if "{" not in response and "[" not in response:
        return False

    # Trim to valid JSON
    response = trim_response(response)

    # if predict_what != "useful functions":
    structure = self["prompt"]["instruction"]["STRUCTURE"]
    if structure:
        structure = correct_json_and_parse(structure)
        if structure is None:
            return None
        for key in structure:
            if key not in response:
                return None

    # Parse the response
    response = correct_json_and_parse(response)
    return response


def output_structure(template: Dict) -> str:
    """Render a JSON template to a string with a placeholder XXX for any variables."""

    def _render(template: Dict, depth: int = 0):
        output = []
        for key, value in template.items():
            if isinstance(value, dict):
                output.append(f'"{key}": {{\n{_render(value, depth + 1)}\n{"\t" * depth}}}')
            elif isinstance(value, list):
                output.append(f'"{key}": [\n{_render_list(value, depth)}\n{"\t" * depth}]')
            else:
                output.append(f'"{key}": XXX')
        return ",\n".join(output)

    def _render_list(template: List, depth: int = 0):
        output = []
        for value in template:
            if isinstance(value, dict):
                output.append(f"{{\n{_render(value, depth + 1)}\n{"\t" * depth}}}")
            elif isinstance(value, list):
                output.append(f"[\n{_render_list(value, depth)}\n{"\t" * depth}]")
            else:
                output.append("XXX")
        return ",\n".join(output)

    return "{\n" + _render(template) + "\n}"


def parse_json_file(json_file: str, type_: str) -> Union[Dict, List]:
    """Parse a JSON file."""
    with open(json_file, "r") as f:
        return json.load(f)


def create_json_schema(response: str, path: str) -> str:
    """Create a JSON schema for the given response."""
    if "{" not in response and "[" not in response:
        return ""
    output = correct_json_and_parse(response, load=False)
    if "\n" not in output:
        return output
    output = output.split("\n")
    output = "".join([f'"{line.strip()}" +\n' if len(line) > 0 else "\n" for line in output[:-1]])
    return output + '"' + output[-1] + '"'


def parse_str_to_function_args(
    response: str,
    predict_for: str,
    parse_with_json: bool = True,
    max_to_return: int = 10,
) -> Union[Tuple[Any, ...], Tuple[Any, ...], Tuple[None, ...]]:
    """Parse response to function call."""
    if parse_with_json and "{" in response:
        response = parse_response(
            self={"output": response},
            response=response,
            predict_what="args",
            predict_for=predict_for,
        )
    if isinstance(response, dict) and "error" in response:
        response = ""
    if isinstance(response, str):
        if "(" not in response and ")" not in response:
            response = "(" + response + ")"
        response = response.split("(")[-1].split(")")[0]
        if "function_to_predict" in response:
            response = response.split("function_to_predict")[1]
        response = response.split(",")
    if not response:
        return None
    response = [
        response[-1] if isinstance(response, dict) else r
        for r in response
        if "(" in r or ")" in r