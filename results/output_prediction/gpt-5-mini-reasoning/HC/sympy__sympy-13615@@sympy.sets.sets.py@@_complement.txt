[THOUGHT]
We call Set._complement(self, other) with other being a FiniteSet containing the single element 1 (other._elements = frozenset({1})). The method's branch for FiniteSet runs:

- It defines ternary_sift(el) which computes contains = self.contains(el) and returns contains if it is strictly True or False, otherwise None.

- We iterate the elements of other (just 1) and apply ternary_sift:

  - If self is effectively the empty set (no elements), then self.contains(1) is False. Thus ternary_sift(1) -> False.
    - sift groups this into sifted[False] = [1], sifted[None] = [].

  - (If instead self were a generic Set with unknown containment then self.contains(1) would return a symbolic Contains and ternary_sift would yield None; that path would produce Complement(FiniteSet(1), self). But given the provided minimal self (empty mapping), the intended interpretation is an empty set, so contains -> False.)

- The method returns:
  Union(FiniteSet(*sifted[False]), Complement(FiniteSet(*sifted[None]), self, evaluate=False))

  With sifted[False] = [1] and sifted[None] = [] this becomes:
  Union(FiniteSet(1), Complement(FiniteSet(), self, evaluate=False))

  FiniteSet() (no args) evaluates to EmptySet, so Complement(EmptySet, self) is empty; Union(FiniteSet(1), Empty) simplifies to FiniteSet(1).

So the result is a FiniteSet containing the element 1, whose internal _elements is frozenset({1}).
[/THOUGHT]
[OUTPUT]
```
{
    "_elements": "frozenset({1})"
}
```