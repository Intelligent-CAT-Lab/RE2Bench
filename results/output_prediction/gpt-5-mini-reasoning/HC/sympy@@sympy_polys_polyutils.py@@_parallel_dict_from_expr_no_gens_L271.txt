[THOUGHT]
We run _parallel_dict_from_expr_no_gens on exprs = [cos(phi)] with opt having only "fraction": True (we treat opt as an options-like object with default attributes for the other flags).

Step-by-step:

1. Choose _is_coeff: opt.domain is None, opt.extension is False, and opt.greedy is not False by default, so the code path sets
   _is_coeff(factor) to (factor is S.ImaginaryUnit). That means only the imaginary unit would be treated as a coefficient via this predicate.

2. Initialize gens = set(), reprs = [].

3. Process the single expr = cos(phi):
   - expr.is_Equality is False.
   - Add.make_args(expr) yields (cos(phi),) so the single term is cos(phi).
   - For that term, Mul.make_args(term) yields (cos(phi),) so the single factor is cos(phi).
   - Check whether factor should be treated as a numeric coefficient:
     - _not_a_coeff(cos(phi)) is falsy (cos(phi) is not an illegal type or NaN).
     - factor.is_Number is False.
     - _is_coeff(cos(phi)) is False (cos(phi) is not S.ImaginaryUnit).
     So the factor is not a coefficient; go to the else branch.

   - opt.series is not explicitly False (default != False), so use decompose_power_rat on cos(phi).
     decompose_power_rat(cos(phi)) returns (base=cos(phi), exp=1).

   - elements becomes { cos(phi): 1 } and gens adds cos(phi).

   - terms for this expr becomes [ (coeff=[], elements={cos(phi):1}) ] and reprs becomes [that terms].

4. After loop, gens is sorted by _sort_gens; with a single generator cos(phi) the result is tuple(gens) == (cos(phi),).

5. Build indices mapping: indices = { cos(phi): 0 }, k = 1.

6. Convert reprs to polys:
   - For the single terms list, create poly = {}.
   - For the sole (coeff, term): monom = [0] * 1 -> [0]; then set monom[0] = 1 -> monom = [1]; monom tuple (1,).
   - coeff is empty list -> Mul(*coeff) is the multiplicative identity 1.
   - So poly becomes { (1,): 1 }.
   - polys becomes [ { (1,): 1 } ].

7. Return (polys, tuple(gens)) which is ([{(1,): 1}], (cos(phi),)).

Note: Mul(*coeff) with empty coeff yields 1 (SymPy's multiplicative identity). The generator tuple contains the base expression cos(phi).

[/THOUGHT]
[OUTPUT]
```
{
    "output": ([{(1,): 1}], (cos(phi),))
}
```
[/OUTPUT]