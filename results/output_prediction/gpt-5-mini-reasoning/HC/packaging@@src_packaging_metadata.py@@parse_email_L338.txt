[THOUGHT]
- The input is a str, so parse_email uses email.parser.Parser(policy=compat32).parsestr(data) to get a Message.
- The message has one header: "download-url" with value "VaLuE".
- Loop over headers:
  - name_with_case is "download-url"; name = name_with_case.lower() -> "download-url".
  - headers = parsed.get_all(name) -> ["VaLuE"].
  - Each header is a str, so value becomes ["VaLuE"]. valid_encoding stays True.
- Look up raw_name = _EMAIL_TO_RAW_MAPPING.get("download-url"). In packaging metadata mapping, "download-url" maps to the raw field name "download_url".
- "download_url" is a string field (in _STRING_FIELDS) and len(value) == 1, so raw["download_url"] = "VaLuE".
- unparsed remains empty.
- _get_payload is called with source as a str, so it returns parsed.get_payload(). For a message with only headers and no body this is the empty string ''. Since payload is falsy, nothing is added to raw or unparsed.
- The function returns (raw, unparsed) which is ({"download_url": "VaLuE"}, {}).

So the JSON output representation of the returned tuple is an array with the two dicts.
[/THOUGHT]
[OUTPUT]
```
{
    "output": [
        {
            "download_url": "VaLuE"
        },
        {}
    ]
}
```
[/OUTPUT]