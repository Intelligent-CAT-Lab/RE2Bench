[THOUGHT]
1. resolve_gui_or_backend receives gui_or_backend = "no-such-name".
2. It lowercases it (stays "no-such-name").
3. Calls backend_for_gui_framework("no-such-name"): that dictionary does not contain this key, so backend is None.
4. Since backend is None, it calls resolve_backend("no-such-name").
5. In resolve_backend:
   - backend is a str, lowercased to "no-such-name".
   - It checks built-in backends and _backend_to_gui_framework; neither contains "no-such-name", so gui is None.
   - It's not a "module://" name.
   - _loaded_entry_points is False, so _ensure_entry_points_loaded() is called. _read_entry_points yields no entries, and _validate_and_store_entry_points makes no changes, then _loaded_entry_points is set to True.
   - After loading entry points, self._backend_to_gui_framework still has no entry for "no-such-name", so gui is still None.
   - Because gui is None, resolve_backend raises RuntimeError("'no-such-name' is not a recognised backend name").
6. That exception propagates back to resolve_gui_or_backend, which catches any exception from resolve_backend and raises a new RuntimeError with the message "'no-such-name' is not a recognised GUI loop or backend name".
7. Therefore the call does not return normally; it raises RuntimeError with that message.
[/THOUGHT]
[OUTPUT]
```
{
    "output": "RuntimeError: 'no-such-name' is not a recognised GUI loop or backend name"
}
```
[/OUTPUT]