[THOUGHT]
We call TR8(rv = cos(phi)**2, first=False).

1. TR8 returns bottom_up(rv, f). bottom_up traverses the expression tree from the bottom up.
2. At the leaves (phi, integers) f does nothing; cos(phi) stays cos(phi).
3. At the Pow node cos(phi)**2, f is invoked with rv = cos(phi)**2 and first=False.
   - The initial check passes because rv.is_Pow is True, base.func is cos, and exp is integer.
   - Since first is False, the code gathers cosine/sine factors via Mul.make_args. For cos(phi)**2, Mul.make_args yields the Pow object, and the code's elif branch treats it as two cos factors, so args[cos] becomes [phi, phi].
   - Because len(c) > 1, it combines two cos(phi) factors using the identity cos(a)cos(b) = (cos(a+b)+cos(a-b))/2. With a = phi, b = phi this yields (cos(2*phi)+cos(0))/2 = (cos(2*phi)+1)/2.
   - The function returns TR8(expand_mul(Mul(*args))) where args contains the single element (cos(2*phi)+1)/2. expand_mul distributes the division giving cos(2*phi)/2 + 1/2.
4. That triggers a recursive TR8 call with first=True on the expression cos(2*phi)/2 + 1/2. Traversal with first=True does not change the expression (it only attempts gcd_terms when subcalls change, but nothing further changes).
5. The final result is cos(2*phi)/2 + 1/2, which is the standard double-angle identity for cos^2(phi).

Therefore the output expression is "cos(2*phi)/2 + 1/2".
[/THOUGHT]
[OUTPUT]
```
{
    "output": "cos(2*phi)/2 + 1/2"        
}
```
[/OUTPUT]