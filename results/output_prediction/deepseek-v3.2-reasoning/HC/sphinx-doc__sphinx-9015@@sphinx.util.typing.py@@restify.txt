[THOUGHT]
The function `restify` is called with `cls` being a dictionary: `{"__module__": "tests.test_util_typing", "__doc__": null}`. The function first checks if `cls` is `None` or `NoneType`, which it isn't. It then checks if `cls` is `Ellipsis`, which it isn't. Next, it checks if `cls` is in `INVALID_BUILTIN_CLASSES` (which contains `Struct` and `TracebackType`); the dictionary is not in that set. Then it calls `inspect.isNewType(cls)`. `isNewType` uses `safe_getattr` to get `__module__` and `__qualname__` from the dictionary. For a dictionary instance, `getattr(cls, '__module__')` returns the class's `__module__` (which is `'builtins'`), not the dictionary's key `"__module__"`. Similarly, `__qualname__` is `'dict'`. Since `__module__` is `'builtins'` (not `'typing'`), `isNewType` returns `False`.

Back in `restify`, the next condition checks `types_Union and isinstance(cls, types_Union)`. The dictionary is not an instance of `types_Union` (which is likely `typing.Union`). Then it checks `cls.__module__ in ('__builtin__', 'builtins')`. As noted, `cls.__module__` (via `getattr`) returns `'builtins'`, so this condition is true. The function then returns `':class:`%s`' % cls.__name__`. For a dictionary instance, `cls.__name__` (via `getattr`) returns the class's `__name__`, which is `'dict'`. Therefore, the output is `':class:`dict`'`.
[/THOUGHT]
[OUTPUT]
{
    "output": ":class:`dict`"
}
[/OUTPUT]