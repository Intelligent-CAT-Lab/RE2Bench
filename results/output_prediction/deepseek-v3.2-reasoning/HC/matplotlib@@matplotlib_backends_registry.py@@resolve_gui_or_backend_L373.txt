[THOUGHT]
1. We are to simulate the call to `resolve_gui_or_backend` with the given input.
2. The argument `gui_or_backend` is "no-such-name". It does not start with "module://", so it is lowercased to "no-such-name".
3. We call `self.backend_for_gui_framework("no-such-name")`. This checks the class attribute `_GUI_FRAMEWORK_TO_BACKEND`, which does not contain "no-such-name", so it returns `None`.
4. Since `backend` is `None`, we proceed to the `try` block and call `self.resolve_backend("no-such-name")`.
5. In `resolve_backend`, the backend is lowercased again (no change). We then try to get `gui` from `_BUILTIN_BACKEND_TO_GUI_FRAMEWORK` and `_backend_to_gui_framework`. Both are empty or do not contain "no-such-name", so `gui` is `None`.
6. Since `gui` is `None` and the backend does not start with "module://", and `self._loaded_entry_points` is `false`, we call `self._ensure_entry_points_loaded()`.
7. `_ensure_entry_points_loaded` calls `_read_entry_points` and `_validate_and_store_entry_points`. We assume there are no entry points in the environment, and the backward compatibility checks do not add any entry points for "no-such-name". So `_backend_to_gui_framework` remains empty.
8. Back in `resolve_backend`, after loading entry points, `gui` is still `None` because "no-such-name" is not in `_backend_to_gui_framework`.
9. Since `gui` is `None` (not "unknown"), and `gui` is `None`, we raise a `RuntimeError` in `resolve_backend`.
10. This exception is caught in `resolve_gui_or_backend`, and it raises a new `RuntimeError` with the message: "'no-such-name' is not a recognised GUI loop or backend name".
11. Therefore, the function does not return a value but raises an exception. The output of the function is this exception message.
[/THOUGHT]
[OUTPUT]
{
    "output": "'no-such-name' is not a recognised GUI loop or backend name"
}
[/OUTPUT]