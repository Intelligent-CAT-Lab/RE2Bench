[THOUGHT]
Let me trace through the execution of `_get_bracket` step by step.

Given inputs:
- x0 = 358.0020718742162
- y0 = 329.4117647058823
- x1 = 220.00292802695185
- y1 = 329.4117647058823
- width = 25.0
- length = 5.0
- angle = null (None)

Step 1: Call `get_cos_sin(x1, y1, x0, y0)`
```
get_cos_sin(220.00292802695185, 329.4117647058823, 358.0020718742162, 329.4117647058823)
```
- dx = x1 - x0 = 220.00292802695185 - 358.0020718742162 = -137.99914384726435
- dy = y1 - y0 = 329.4117647058823 - 329.4117647058823 = 0.0
- d = sqrt((-137.99914384726435)^2 + 0.0^2) = sqrt(19042.1503...) ≈ 138.0
- cos_t = dx/d = -137.99914384726435 / 138.0 ≈ -1.0 (approximately, but more precisely -0.9999938...)
- sin_t = dy/d = 0.0 / 138.0 = 0.0

More precisely:
- d = 137.99914384726435
- cos_t = -1.0
- sin_t = 0.0

Step 2: Call `get_normal_points(x0, y0, cos_t, sin_t, width)`
```
get_normal_points(358.0020718742162, 329.4117647058823, -1.0, 0.0, 25.0)
```
- cx = 358.0020718742162, cy = 329.4117647058823
- cos_t = -1.0, sin_t = 0.0
- length = 25.0

Since length != 0:
- cos_t1 = sin_t = 0.0
- sin_t1 = -cos_t = -(-1.0) = 1.0
- cos_t2 = -sin_t = 0.0
- sin_t2 = cos_t = -1.0

- x1 = length * cos_t1 + cx = 25.0 * 0.0 + 358.0020718742162 = 358.0020718742162
- y1 = length * sin_t1 + cy = 25.0 * 1.0 + 329.4117647058823 = 354.4117647058823
- x2 = length * cos_t2 + cx = 25.0 * 0.0 + 358.0020718742162 = 358.0020718742162
- y2 = length * sin_t2 + cy = 25.0 * (-1.0) + 329.4117647058823 = 304.4117647058823

So get_normal_points returns: (358.0020718742162, 354.4117647058823, 358.0020718742162, 304.4117647058823)

Step 3: Calculate dx, dy
- dx = length * cos_t = 5.0 * (-1.0) = -5.0
- dy = length * sin_t = 5.0 * 0.0 = 0.0

Step 4: Build vertices_arrow
- vertices_arrow = [
    (x1 + dx, y1 + dy) = (358.0020718742162 - 5.0, 354.4117647058823 + 0.0) = (353.0020718742162, 354.4117647058823),
    (x1, y1) = (358.0020718742162, 354.4117647058823),
    (x2, y2) = (358.0020718742162, 304.4117647058823),
    (x2 + dx, y2 + dy) = (358.0020718742162 - 5.0, 304.4117647058823 + 0.0) = (353.0020718742162, 304.4117647058823)
  ]

Step 5: Create codes_arrow
- codes_arrow = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO]

Step 6: Check angle
- angle = None, so the condition `if angle:` is False, no transformation is applied

Step 7: Return tuple
Return (vertices_arrow, codes_arrow)

Let me format this more precisely as tuples of tuples:

vertices_arrow = [
    (353.0020718742162, 354.4117647058823),
    (358.0020718742162, 354.4117647058823),
    (358.0020718742162, 304.4117647058823),
    (353.0020718742162, 304.4117647058823)
]

codes_arrow = [1, 2, 2, 2] (assuming Path.MOVETO=1, Path.LINETO=2)

The function returns a tuple of (vertices_arrow, codes_arrow)
</THOUGHT>

[OUTPUT]
```
{
    "output": [
        [
            [353.0020718742162, 354.4117647058823],
            [358.0020718742162, 354.4117647058823],
            [358.0020718742162, 304.4117647058823],
            [353.0020718742162, 304.4117647058823]
        ],
        [1, 2, 2, 2]
    ]
}
```
[/OUTPUT]