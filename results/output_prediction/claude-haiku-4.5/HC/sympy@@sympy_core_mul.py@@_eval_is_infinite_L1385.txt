[THOUGHT]
Let me trace through the execution of `_eval_is_infinite` for the expression "pi/2".

1. First, `_eval_is_infinite` calls `self._eval_is_zero_infinite_helper()` to get `seen_zero` and `seen_infinite`.

2. In `_eval_is_zero_infinite_helper`:
   - Initialize: `seen_zero = False`, `seen_infinite = False`
   - The expression is "pi/2", which would have args that represent pi and 2 (or their quotient)
   - However, based on the input, we need to consider what "pi/2" evaluates to:
     - pi is a mathematical constant that is neither zero nor infinite
     - 2 is a finite non-zero number
     - pi/2 is finite and non-zero
   
   - When iterating through args (assuming they represent the components):
     - For pi: `pi.is_zero` is False, `pi.is_infinite` is False
     - For 2 (or the division result): similar properties
   
   - Since neither argument has `is_zero=True` or `is_infinite=True`, we go to the else branch for each arg
   - For each arg where `is_zero` is False and `is_infinite` is False (not None):
     - The conditions `seen_zero is False and a.is_zero is None` would be False
     - The conditions `seen_infinite is False and a.is_infinite is None` would be False
     - So no changes to seen_zero or seen_infinite
   
   - After the loop: `seen_zero = False`, `seen_infinite = False`

3. Back in `_eval_is_infinite`:
   - `seen_zero = False`, `seen_infinite = False`
   - Check: `if seen_infinite is True and seen_zero is False:` → False (seen_infinite is False, not True)
   - Check: `elif seen_infinite is False:` → True
   - Return: `False`

So the output should be `False` because pi/2 is a finite, non-infinite number.
</THOUGHT>

[OUTPUT]
```
{
    "output": false
}
```
[/OUTPUT]