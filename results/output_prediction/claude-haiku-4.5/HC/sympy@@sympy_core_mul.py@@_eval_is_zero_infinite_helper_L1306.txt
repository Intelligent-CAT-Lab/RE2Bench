[THOUGHT]
Let me trace through the execution of `_eval_is_zero_infinite_helper` for the input "-pi/4".

1. The method initializes:
   - `seen_zero = False`
   - `seen_infinite = False`

2. It then iterates through `self.args`. For "-pi/4", this is a unary expression (negation of pi/4), so `self.args` would be `(pi/4,)` or potentially `(-1, pi/4)` depending on how sympy structures it. Actually, "-pi/4" is likely represented as a multiplication: `Mul(-1, pi, Pow(4, -1))` or similar. Let me reconsider - it could just be `(-pi/4,)` as a single argument, or it could be structured as a Mul with multiple args.

Actually, looking at the structure more carefully, "-pi/4" when represented as a Mul would have args like `(-1, pi, Pow(4, -1))` or `(Rational(-1, 4), pi)` depending on simplification. But the key question is: what are the `is_zero` and `is_infinite` properties of each argument?

3. For any numeric argument like `-1`, `pi`, or `1/4`:
   - `is_zero` would be `False` (they're not zero)
   - `is_infinite` would be `False` (they're not infinite)

4. So in the loop:
   - For each argument `a` in args:
     - `a.is_zero` is `False` (not True, not None)
     - `a.is_infinite` is `False` (not True, not None)
     - We skip the first if block (since `a.is_zero` is `False`, not `True`)
     - We skip the elif block (since `a.is_infinite` is `False`, not `True`)
     - We enter the else block, but both conditions inside are false:
       - `seen_zero is False and a.is_zero is None` → `True and False` = `False`
       - `seen_infinite is False and a.is_infinite is None` → `True and False` = `False`
     - So nothing happens in the else block

5. After iterating through all args without finding any zeros or infinities, the function returns:
   `(seen_zero, seen_infinite)` = `(False, False)`

</THOUGHT>

[OUTPUT]
```
{
    "output": "(False, False)"
}
```
[/OUTPUT]