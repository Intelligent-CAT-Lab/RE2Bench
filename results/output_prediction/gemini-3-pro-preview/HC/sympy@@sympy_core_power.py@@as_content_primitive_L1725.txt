The function `as_content_primitive` on a `Pow` object like `sqrt(2)` works by separating the integer part of the rational exponent from the fractional part to extract rational content from the base.

1.  **Initialize**: `self` is `sqrt(2)`, which corresponds to `Pow(2, 1/2)`. `radical=False`, `clear=False`.
2.  **Base and Exponent Extraction**: `self.as_base_exp()` is called. Since the base `2` is a `Rational` (Integer) and not a fraction `1/n`, it returns `b=2`, `e=1/2`.
3.  **Primitive of Base**: `b.as_content_primitive()` is called. `2` is positive, so it returns `(2, 1)`. `b` remains `2`.
4.  **Primitive of Exponent**: `e.as_content_primitive()` is called. `1/2` is a positive Rational, so it returns `(1/2, 1)`. `ce` (coeff of e) is `1/2`, `pe` (primitive of e) is `1`.
5.  **Rational Check**: The code checks `if b.is_Rational:`. `2` is Rational, so we proceed.
    *   `h, t = pe.as_coeff_Add()`. `pe` is `1`. `as_coeff_Add()` on `1` returns `h=1`, `t=0`.
    *   `if h.is_Rational and b != S.Zero:` checks out (`1` is rational, `2 != 0`).
    *   `ceh = ce * h` = `1/2 * 1` = `1/2`.
    *   `c = self.func(b, ceh)` = `2**(1/2) = sqrt(2)`.
    *   `if not c.is_Rational:` checks out (`sqrt(2)` is irrational).
    *   **Divmod Calculation**: `iceh, r = divmod(ceh.p, ceh.q)`. `ceh` is `1/2`. `p=1`, `q=2`. `divmod(1, 2)` gives `iceh=0`, `r=1`.
    *   **Content Calculation**: `c = self.func(b, iceh)` = `2**0` = `1`.
    *   **Primitive Calculation**: The new exponent term is calculated as `t + r / ce / ceh.q`.
        *   `t = 0`.
        *   `r = 1`.
        *   `ce = 1/2`.
        *   `ceh.q = 2`.
        *   Term = `0 + 1 / (1/2) / 2` = `(1 * 2) / 2` = `1`.
        *   New exponent `_keep_coeff(ce, 1)` = `1/2 * 1` = `1/2`.
        *   Primitive term = `b**new_exponent` = `2**(1/2)` = `sqrt(2)`.
    *   The function returns `(c, primitive)`.
6.  **Result**: `(1, sqrt(2))`.

[OUTPUT]
```
{
    "output": "(1, sqrt(2))"
}
```
[/OUTPUT]