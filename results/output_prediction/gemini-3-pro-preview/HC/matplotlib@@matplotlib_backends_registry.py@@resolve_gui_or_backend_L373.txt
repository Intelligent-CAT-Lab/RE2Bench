[THOUGHT]
The function `resolve_gui_or_backend` is called with argument `"no-such-name"`.

1.  **Normalization**: The input string is not starting with "module://", so it is lowercased to `"no-such-name"`.
2.  **GUI Framework Lookup**: `self.backend_for_gui_framework("no-such-name")` is called.
    *   It checks `self._GUI_FRAMEWORK_TO_BACKEND`. The keys are (gtk3, gtk4, headless, macosx, qt, ...). `"no-such-name"` is not present.
    *   It returns `None`.
3.  **Backend Resolution**: Since the GUI lookup returned `None`, the code enters the `try/except` block and calls `self.resolve_backend("no-such-name")`.
    *   Inside `resolve_backend`:
        *   It checks `self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK`. `"no-such-name"` is not present.
        *   It checks `self._backend_to_gui_framework`. `"no-such-name"` is not present.
        *   It checks for the "module://" prefix. It is absent.
        *   `self._loaded_entry_points` is `False`, so `self._ensure_entry_points_loaded()` is called. Assuming no external package "no-such-name" is installed in this simulated execution context, no new backend is registered for it.
        *   `gui` remains `None`.
        *   Since `gui` is `None`, `resolve_backend` raises `RuntimeError("'no-such-name' is not a recognised backend name")`.
4.  **Exception Handling**: The `RuntimeError` raised by `resolve_backend` is caught by the `except Exception:` block in `resolve_gui_or_backend`.
5.  **Re-raising**: The `except` block raises a NEW `RuntimeError` with a specific message: `f"'{gui_or_backend}' is not a recognised GUI loop or backend name"`.
    *   The message evaluates to: `"'no-such-name' is not a recognised GUI loop or backend name"`.

The output of the function execution is that this exception is raised.
[/THOUGHT]
[OUTPUT]
```
{
    "output": "RuntimeError(\"'no-such-name' is not a recognised GUI loop or backend name\")"
}
```
[/OUTPUT]