[THOUGHT]
1.  **Identify the Method Call**: The user wants to predict the output of `_get_bracket`.
    The input matches the signature: `_get_bracket(self, x0, y0, x1, y1, width, length, angle)`.
    Values:
    `x0` = 358.0020718742162
    `y0` = 329.4117647058823
    `x1` = 220.00292802695185
    `y1` = 329.4117647058823
    `width` = 25.0
    `length` = 5.0
    `angle` = None

2.  **Trace `get_cos_sin`**:
    The method calls `cos_t, sin_t = get_cos_sin(x1, y1, x0, y0)`.
    Function definition: `get_cos_sin(x0, y0, x1, y1)` (parameter names).
    Mapping arguments:
    `get_cos_sin_x0` = `x1` (220.00292802695185)
    `get_cos_sin_y0` = `y1` (329.4117647058823)
    `get_cos_sin_x1` = `x0` (358.0020718742162)
    `get_cos_sin_y1` = `y0` (329.4117647058823)

    Inside `get_cos_sin`:
    `dx = 358.0020718742162 - 220.00292802695185` â‰ˆ `137.99914384726435`
    `dy = 329.4117647058823 - 329.4117647058823 = 0.0`
    `d` = 137.99914384726435 (magnitude)
    `cos_t` = dx/d = 1.0
    `sin_t` = dy/d = 0.0

3.  **Trace `get_normal_points`**:
    The method calls `x1, y1, x2, y2 = get_normal_points(x0, y0, cos_t, sin_t, width)`.
    Note: The method assigns returned values to local variables `x1, y1, x2, y2`, shadowing the arguments.
    Inputs to `get_normal_points`:
    `cx` = 358.0020718742162
    `cy` = 329.4117647058823
    `cos_t` = 1.0
    `sin_t` = 0.0
    `length` (param name in function) = `width` (arg passed) = 25.0

    Inside `get_normal_points`:
    `cos_t1, sin_t1 = sin_t, -cos_t` -> `0.0, -1.0`
    `cos_t2, sin_t2 = -sin_t, cos_t` -> `0.0, 1.0`

    Point 1:
    `val_x1 = length * cos_t1 + cx` = 25.0 * 0.0 + 358... = 358.0020718742162
    `val_y1 = length * sin_t1 + cy` = 25.0 * (-1.0) + 329.4117647058823 = 304.4117647058823

    Point 2:
    `val_x2 = length * cos_t2 + cx` = 25.0 * 0.0 + 358... = 358.0020718742162
    `val_y2 = length * sin_t2 + cy` = 25.0 * 1.0 + 329.4117647058823 = 354.4117647058823

    So, local `x1, y1` = (358.002..., 304.411...)
    Local `x2, y2` = (358.002..., 354.411...)

4.  **Calculate Arrow Vertices**:
    `dx, dy = (length * cos_t, length * sin_t)`
    `length` (arg passed) = 5.0
    `dx = 5.0 * 1.0 = 5.0`
    `dy = 5.0 * 0.0 = 0.0`

    `vertices_arrow = [(x1 + dx, y1 + dy), (x1, y1), (x2, y2), (x2 + dx, y2 + dy)]`
    (Using local x1, y1, x2, y2)

    Vertex 0: `(358.002... + 5.0, 304.411... + 0.0)` -> `(363.0020718742162, 304.4117647058823)`
    Vertex 1: `(358.0020718742162, 304.4117647058823)`
    Vertex 2: `(358.0020718742162, 354.4117647058823)`
    Vertex 3: `(358.002... + 5.0, 354.411... + 0.0)` -> `(363.0020718742162, 354.4117647058823)`

5.  **Calculate Codes**:
    `codes_arrow = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO]`
    Assuming standard Matplotlib Path constants: MOVETO=1, LINETO=2.
    `codes_arrow = [1, 2, 2, 2]`

6.  **Handle Angle**:
    `angle` is `null` (None). The `if angle:` block is skipped.

7.  **Return**:
    Returns tuple `(vertices_arrow, codes_arrow)`.
[/THOUGHT]

[OUTPUT]
```
{
    "output": [
        [
            [
                363.0020718742162,
                304.4117647058823
            ],
            [
                358.0020718742162,
                304.4117647058823
            ],
            [
                358.0020718742162,
                354.4117647058823
            ],
            [
                363.0020718742162,
                354.4117647058823
            ]
        ],
        [
            1,
            2,
            2,
            2
        ]
    ]
}
```
[/OUTPUT]