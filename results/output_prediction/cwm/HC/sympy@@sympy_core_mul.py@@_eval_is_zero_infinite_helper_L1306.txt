<think>
I need to find the output of the `_eval_is_zero_infinite_helper` method for the input "-pi/4". Let me look at the code step by step.

The method initializes two flags: `seen_zero` and `seen_infinite` to False. Then it iterates over each argument in `self.args`. For each argument, it checks if it's zero, infinite, or neither, and updates the flags accordingly. If conflicting conditions are found (like seeing both zero and infinite), it returns (None, None).

First, I should determine what `self.args` is for the input "-pi/4". Since "-pi/4" is likely a SymPy expression, I'll assume it's a `Mul` object (since multiplication is involved) with arguments involving `-1`, `pi`, and `4`. However, the exact structure depends on how SymPy parses "-pi/4".

Assuming "-pi/4" is parsed as a `Mul` object with arguments like `-1`, `pi`, and `Rational(1, 4)`, let's consider each argument:

1. `-1`: This is a finite number, not zero or infinite.
2. `pi`: This is an irrational number, also finite, not zero or infinite.
3. `Rational(1, 4)`: A rational number, finite, not zero or infinite.

For each of these arguments:
- None are zero (so `seen_zero` remains False).
- None are infinite (so `seen_infinite` remains False).

Since none of the arguments are zero or infinite, the flags `seen_zero` and `seen_infinite` stay False throughout the loop. Therefore, the method returns `(False, False)`.

But wait, let me double-check. The method checks `a.is_zero` and `a.is_infinite` for each argument. If any argument is zero, it sets `seen_zero` to True (or None if uncertain). Similarly for infinite. Since none of the arguments here are zero or infinite, the flags remain False.

So the final output should be `(False, False)`.
</think>
[OUTPUT]
{
    "output": [false, false]
}
[/OUTPUT]