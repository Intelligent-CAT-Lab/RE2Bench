<think>
1. The `restify` function is called with `cls` being an object with `__module__` set to "tests.test_util_typing" and `__doc__` set to null.
2. Since `cls` is not None, NoneType, or Ellipsis, the function checks if `cls` is in `INVALID_BUILTIN_CLASSES`. It is not, so it moves on.
3. The function then checks if `cls` is a NewType using `inspect.isNewType(cls)`. 
4. Inside `isNewType`, it retrieves `__module__` and `__qualname__` from `cls`. 
5. Since `__module__` is "tests.test_util_typing" and not "typing", `isNewType` returns False.
6. The function then checks if `cls` is a Union type. Since `cls` is not a Union type, it moves on.
7. Next, it checks if `cls` is from the `__builtin__` or `builtins` module. Since `cls` is from "tests.test_util_typing", it moves on.
8. The function then checks the Python version. Assuming it's Python 3.7 or higher, it calls `_restify_py37(cls)`.
9. However, the implementation of `_restify_py37` is not provided, so we assume it will return a string representation of `cls`.
10. Therefore, the output of `restify` will be a string representation of the class `cls`.
</think>
[OUTPUT]
{
    "output": ":class:`tests.test_util_typing.cls`"
}
[/OUTPUT]