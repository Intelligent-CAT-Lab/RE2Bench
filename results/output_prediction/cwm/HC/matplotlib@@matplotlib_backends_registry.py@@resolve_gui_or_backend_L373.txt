<think>
Okay, I need to figure out what `resolve_gui_or_backend` will return when given "no-such-name" as the input. Let's go step by step through the function.

First, the function checks if the input `gui_or_backend` starts with "module://". Since "no-such-name" doesn't, it converts it to lowercase, which is still "no-such-name".

Next, it calls `self.backend_for_gui_framework(gui_or_backend)`. This function looks up the input in `_GUI_FRAMEWORK_TO_BACKEND`. The keys in that dictionary are like 'gtk3', 'headless', etc. Since "no-such-name" isn't a key there, this returns `None`.

Then, the code tries to call `self.resolve_backend(gui_or_backend)`. Let's look into that function.

Inside `resolve_backend`, since the input is a string and doesn't start with "module://", it converts it to lowercase again (still "no-such-name"). 

It checks if the backend is known by looking in `_BUILTIN_BACKEND_TO_GUI_FRAMEWORK` and `_backend_to_gui_framework`. Both are empty except for the built-in ones. "no-such-name" isn't a built-in backend, so `gui` remains `None`.

Since `gui` is `None` and the entry points haven't been loaded yet (`_loaded_entry_points` is False), it calls `_ensure_entry_points_loaded()`. This would load any entry points, but since the input is "no-such-name", which isn't an entry point, this might not help.

After loading entry points (if any), it checks again for `gui`. Still `None`, so it raises a `RuntimeError` because "no-such-name" isn't a recognized backend.

But wait, the `resolve_gui_or_backend` function has a try-except block around the call to `resolve_backend`. If `resolve_backend` raises an exception, it catches it and raises a new `RuntimeError` with the message "'no-such-name' is not a recognised GUI loop or backend name".

So the final output should be that error message.
</think>
[OUTPUT]
{
    "output": "'no-such-name' is not a recognised GUI loop or backend name"        
}
[/OUTPUT]