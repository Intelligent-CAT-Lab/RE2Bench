<think>
Let's go step by step through the function `to_euler` with the given input.

1. **Initial Checks:**
   - The function starts by checking if the quaternion is a zero quaternion. It calls `is_zero_quaternion`, which in turn calls `norm`. However, the input `_norm` is `null`, so `norm` computes `sqrt(trigsimp(q.a**2 + q.b**2 + q.c**2 + q.d**2))`. But since the values of `a`, `b`, `c`, and `d` are not provided directly in the input, we assume they are non-zero. Thus, the quaternion is not a zero quaternion, and the function proceeds.

2. **Determine Rotation Sequence:**
   - The function checks if the sequence `seq="zyz"` is extrinsic or intrinsic by calling `_is_extrinsic`. Since "zyz" is lowercase, it's an intrinsic rotation.

3. **Axis Indices:**
   - The code converts the sequence into indices: `i`, `j`, `k` corresponding to 'z', 'y', 'z'. These are mapped to 3, 2, 3 (since 'x' is 1, 'y' is 2, 'z' is 3).

4. **Symmetric and Sign Calculation:**
   - Since `i == k` (3 == 3), it's a symmetric rotation, and `k` is recalculated as `6 - i - j = 6 - 3 - 2 = 1`.
   - The sign is calculated as `(i - j) * (j - k) * (k - i) // 2 = (3 - 2) * (2 - 1) * (1 - 3) // 2 = 1 * 1 * (-2) // 2 = -1`.

5. **Element Extraction:**
   - The code extracts `a`, `b`, `c`, `d` from `self.args`. Since the actual values of `a`, `b`, `c`, and `d` are not provided, we'll denote them as `a`, `b`, `c`, and `d`.

6. **Avoid Square Root:**
   - Since `avoid_square_root` is `False`, it calculates angles using `atan2` and square roots.

7. **Angle Calculations:**
   - `angles1 = 2 * atan2(sqrt(c**2 + d**2), sqrt(a**2 + b**2)) - S.Pi / 2` (since it's not symmetric).
   - For `case == 0`, since `c` and `d` are not zero, it calculates `angles0` and `angles2` using `atan2(b, a) + atan2(d, c)` and `atan2(b, a) - atan2(d, c)` respectively.

8. **Adjustments:**
   - Since it's not symmetric, `angles0` is multiplied by `sign` (-1).

9. **Return Values:**
   - The function returns `(angles0, angles1, angles2)`.

However, without the actual values of `a`, `b`, `c`, and `d`, we can't compute the exact numerical output. But based on the structure and the logic, the output will be a tuple of three expressions representing the Euler angles.
</think>
[OUTPUT]
```
{
    "output": [XXX, XXX, XXX]        
}
```
[/OUTPUT]