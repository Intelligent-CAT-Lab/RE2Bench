 [OUTPUT]
import numpy as np
from scipy import sparse as sp
from sklearn.base import BaseEstimator, TransformerMixin, _fit_context
from sklearn.utils._mask import _get_mask
from sklearn.utils._missing import is_pandas_na, is_scalar_nan
from sklearn.utils._param_validation import MissingValues, StrOptions
from sklearn.utils.validation import (
    FLOAT_DTYPES,
    _check_feature_names_in,
    _check_n_features,
    check_is_fitted,
    validate_data,
)

class MissingIndicator(TransformerMixin, BaseEstimator):
    _parameter_constraints: dict = {'missing_values': [MissingValues()], 'features': [StrOptions({'missing-only', 'all'})], 'sparse': ['boolean', StrOptions({'auto'})], 'error_on_new': ['boolean']}

    def __init__(self, *, missing_values=np.nan, features='missing-only', sparse='auto', error_on_new=True):
        self.missing_values = missing_values
        self.features = features
        self.sparse = sparse
        self.error_on_new = error_on_new

    def _get_missing_features_info(self, X):
        if not self._precomputed: ## [BRANCH]taken=['N'][/BRANCH]
            imputer_mask = _get_mask(X, self.missing_values)
        else: ## [BRANCH]taken=['Y'][/BRANCH]
            imputer_mask = X
        if sp.issparse(X):
            imputer_mask.eliminate_zeros()
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is False:
                imputer_mask = imputer_mask.toarray()
            elif imputer_mask.format == 'csr':
                imputer_mask = imputer_mask.tocsc()
        else:
            if not self._precomputed:
                imputer_mask = _get_mask(X, self.missing_values)
            else:
                imputer_mask = X
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is True:
                imputer_mask = sp.csc_matrix(imputer_mask)
        if self.features == 'all':
            features_indices = np.arange(X.shape[1])
        else:
            features_indices = np.flatnonzero(n_missing)
        return (imputer_mask, features_indices)

    def _validate_input(self, X, in_fit):
        if not is_scalar_nan(self.missing_values):
            ensure_all_finite = True
        else:
            ensure_all_finite = 'allow-nan'
        X = validate_data(self, X, reset=in_fit, accept_sparse=('csc', 'csr'), dtype=None, ensure_all_finite=ensure_all_finite)
        _check_inputs_dtype(X, self.missing_values)
        if X.dtype.kind not in ('i', 'u', 'f', 'O'): ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('MissingIndicator does not support data with dtype {0}. Please provide either a numeric array (with a floating point or integer dtype) or categorical data represented either as an array with integer dtype or an array of string values with an object dtype.'.format(X.dtype))
        if sp.issparse(X) and self.missing_values == 0: ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('Sparse input with missing_values=0 is not supported. Provide a dense array instead.')
        return X

    def _fit(self, X, y=None, precomputed=False):
        if precomputed:
            if not (hasattr(X, 'dtype') and X.dtype.kind == 'b'): ## [BRANCH]taken=['N'][/BRANCH]
                raise ValueError('precomputed is True but the input data is not a mask')
            self._precomputed = True
        else:
            self._precomputed = False
        if not self._precomputed:
            X = self._validate_input(X, in_fit=True)
        else:
            _check_n_features(self, X, reset=True)
        self._n_features = X.shape[1]
        missing_features_info = self._get_missing_features_info(X)
        self.features_ = missing_features_info[1]
        return missing_features_info[0]
[/OUTPUT]</s>
<|user|>
 [OUTPUT]
import numpy as np
from scipy import sparse as sp
from sklearn.base import BaseEstimator, TransformerMixin, _fit_context
from sklearn.utils._mask import _get_mask
from sklearn.utils._missing import is_pandas_na, is_scalar_nan
from sklearn.utils._param_validation import MissingValues, StrOptions
from sklearn.utils.validation import (
    FLOAT_DTYPES,
    _check_feature_names_in,
    _check_n_features,
    check_is_fitted,
    validate_data,
)

class MissingIndicator(TransformerMixin, BaseEstimator):
    _parameter_constraints: dict = {'missing_values': [MissingValues()], 'features': [StrOptions({'missing-only', 'all'})], 'sparse': ['boolean', StrOptions({'auto'})], 'error_on_new': ['boolean']}

    def __init__(self, *, missing_values=np.nan, features='missing-only', sparse='auto', error_on_new=True):
        self.missing_values = missing_values
        self.features = features
        self.sparse = sparse
        self.error_on_new = error_on_new

    def _get_missing_features_info(self, X):
        if not self._precomputed: ## [BRANCH]taken=['N'][/BRANCH]
            imputer_mask = _get_mask(X, self.missing_values)
        else: ## [BRANCH]taken=['Y'][/BRANCH]
            imputer_mask = X
        if sp.issparse(X):
            imputer_mask.eliminate_zeros()
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is False:
                imputer_mask = imputer_mask.toarray()
            elif imputer_mask.format == 'csr':
                imputer_mask = imputer_mask.tocsc()
        else:
            if not self._precomputed:
                imputer_mask = _get_mask(X, self.missing_values)
            else:
                imputer_mask = X
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is True:
                imputer_mask = sp.csc_matrix(imputer_mask)
        if self.features == 'all':
            features_indices = np.arange(X.shape[1])
        else:
            features_indices = np.flatnonzero(n_missing)
        return (imputer_mask, features_indices)

    def _validate_input(self, X, in_fit):
        if not is_scalar_nan(self.missing_values):
            ensure_all_finite = True
        else:
            ensure_all_finite = 'allow-nan'
        X = validate_data(self, X, reset=in_fit, accept_sparse=('csc', 'csr'), dtype=None, ensure_all_finite=ensure_all_finite)
        _check_inputs_dtype(X, self.missing_values)
        if X.dtype.kind not in ('i', 'u', 'f', 'O'): ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('MissingIndicator does not support data with dtype {0}. Please provide either a numeric array (with a floating point or integer dtype) or categorical data represented either as an array with integer dtype or an array of string values with an object dtype.'.format(X.dtype))
        if sp.issparse(X) and self.missing_values == 0: ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('Sparse input with missing_values=0 is not supported. Provide a dense array instead.')
        return X

    def _fit(self, X, y=None, precomputed=False):
        if precomputed:
            if not (hasattr(X, 'dtype') and X.dtype.kind == 'b'): ## [BRANCH]taken=['N'][/BRANCH]
                raise ValueError('precomputed is True but the input data is not a mask')
            self._precomputed = True
        else:
            self._precomputed = False
        if not self._precomputed:
            X = self._validate_input(X, in_fit=True)
        else:
            _check_n_features(self, X, reset=True)
        self._n_features = X.shape[1]
        missing_features_info = self._get_missing_features_info(X)
        self.features_ = missing_features_info[1]
        return missing_features_info[0]
[/OUTPUT]</s>
<|user|>
 [OUTPUT]
import numpy as np
from scipy import sparse as sp
from sklearn.base import BaseEstimator, TransformerMixin, _fit_context
from sklearn.utils._mask import _get_mask
from sklearn.utils._missing import is_pandas_na, is_scalar_nan
from sklearn.utils._param_validation import MissingValues, StrOptions
from sklearn.utils.validation import (
    FLOAT_DTYPES,
    _check_feature_names_in,
    _check_n_features,
    check_is_fitted,
    validate_data,
)

class MissingIndicator(TransformerMixin, BaseEstimator):
    _parameter_constraints: dict = {'missing_values': [MissingValues()], 'features': [StrOptions({'missing-only', 'all'})], 'sparse': ['boolean', StrOptions({'auto'})], 'error_on_new': ['boolean']}

    def __init__(self, *, missing_values=np.nan, features='missing-only', sparse='auto', error_on_new=True):
        self.missing_values = missing_values
        self.features = features
        self.sparse = sparse
        self.error_on_new = error_on_new

    def _get_missing_features_info(self, X):
        if not self._precomputed: ## [BRANCH]taken=['N'][/BRANCH]
            imputer_mask = _get_mask(X, self.missing_values)
        else: ## [BRANCH]taken=['Y'][/BRANCH]
            imputer_mask = X
        if sp.issparse(X):
            imputer_mask.eliminate_zeros()
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is False:
                imputer_mask = imputer_mask.toarray()
            elif imputer_mask.format == 'csr':
                imputer_mask = imputer_mask.tocsc()
        else:
            if not self._precomputed:
                imputer_mask = _get_mask(X, self.missing_values)
            else:
                imputer_mask = X
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is True:
                imputer_mask = sp.csc_matrix(imputer_mask)
        if self.features == 'all':
            features_indices = np.arange(X.shape[1])
        else:
            features_indices = np.flatnonzero(n_missing)
        return (imputer_mask, features_indices)

    def _validate_input(self, X, in_fit):
        if not is_scalar_nan(self.missing_values):
            ensure_all_finite = True
        else:
            ensure_all_finite = 'allow-nan'
        X = validate_data(self, X, reset=in_fit, accept_sparse=('csc', 'csr'), dtype=None, ensure_all_finite=ensure_all_finite)
        _check_inputs_dtype(X, self.missing_values)
        if X.dtype.kind not in ('i', 'u', 'f', 'O'): ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('MissingIndicator does not support data with dtype {0}. Please provide either a numeric array (with a floating point or integer dtype) or categorical data represented either as an array with integer dtype or an array of string values with an object dtype.'.format(X.dtype))
        if sp.issparse(X) and self.missing_values == 0: ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('Sparse input with missing_values=0 is not supported. Provide a dense array instead.')
        return X

    def _fit(self, X, y=None, precomputed=False):
        if precomputed:
            if not (hasattr(X, 'dtype') and X.dtype.kind == 'b'): ## [BRANCH]taken=['N'][/BRANCH]
                raise ValueError('precomputed is True but the input data is not a mask')
            self._precomputed = True
        else:
            self._precomputed = False
        if not self._precomputed:
            X = self._validate_input(X, in_fit=True)
        else:
            _check_n_features(self, X, reset=True)
        self._n_features = X.shape[1]
        missing_features_info = self._get_missing_features_info(X)
        self.features_ = missing_features_info[1]
        return missing_features_info[0]
[/OUTPUT]</s>
<|user|>
 [OUTPUT]
import numpy as np
from scipy import sparse as sp
from sklearn.base import BaseEstimator, TransformerMixin, _fit_context
from sklearn.utils._mask import _get_mask
from sklearn.utils._missing import is_pandas_na, is_scalar_nan
from sklearn.utils._param_validation import MissingValues, StrOptions
from sklearn.utils.validation import (
    FLOAT_DTYPES,
    _check_feature_names_in,
    _check_n_features,
    check_is_fitted,
    validate_data,
)

class MissingIndicator(TransformerMixin, BaseEstimator):
    _parameter_constraints: dict = {'missing_values': [MissingValues()], 'features': [StrOptions({'missing-only', 'all'})], 'sparse': ['boolean', StrOptions({'auto'})], 'error_on_new': ['boolean']}

    def __init__(self, *, missing_values=np.nan, features='missing-only', sparse='auto', error_on_new=True):
        self.missing_values = missing_values
        self.features = features
        self.sparse = sparse
        self.error_on_new = error_on_new

    def _get_missing_features_info(self, X):
        if not self._precomputed: ## [BRANCH]taken=['N'][/BRANCH]
            imputer_mask = _get_mask(X, self.missing_values)
        else: ## [BRANCH]taken=['Y'][/BRANCH]
            imputer_mask = X
        if sp.issparse(X):
            imputer_mask.eliminate_zeros()
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is False:
                imputer_mask = imputer_mask.toarray()
            elif imputer_mask.format == 'csr':
                imputer_mask = imputer_mask.tocsc()
        else:
            if not self._precomputed:
                imputer_mask = _get_mask(X, self.missing_values)
            else:
                imputer_mask = X
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is True:
                imputer_mask = sp.csc_matrix(imputer_mask)
        if self.features == 'all':
            features_indices = np.arange(X.shape[1])
        else:
            features_indices = np.flatnonzero(n_missing)
        return (imputer_mask, features_indices)

    def _validate_input(self, X, in_fit):
        if not is_scalar_nan(self.missing_values):
            ensure_all_finite = True
        else:
            ensure_all_finite = 'allow-nan'
        X = validate_data(self, X, reset=in_fit, accept_sparse=('csc', 'csr'), dtype=None, ensure_all_finite=ensure_all_finite)
        _check_inputs_dtype(X, self.missing_values)
        if X.dtype.kind not in ('i', 'u', 'f', 'O'): ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('MissingIndicator does not support data with dtype {0}. Please provide either a numeric array (with a floating point or integer dtype) or categorical data represented either as an array with integer dtype or an array of string values with an object dtype.'.format(X.dtype))
        if sp.issparse(X) and self.missing_values == 0: ## [BRANCH]taken=['N'][/BRANCH]
            raise ValueError('Sparse input with missing_values=0 is not supported. Provide a dense array instead.')
        return X

    def _fit(self, X, y=None, precomputed=False):
        if precomputed:
            if not (hasattr(X, 'dtype') and X.dtype.kind == 'b'): ## [BRANCH]taken=['N'][/BRANCH]
                raise ValueError('precomputed is True but the input data is not a mask')
            self._precomputed = True
        else:
            self._precomputed = False
        if not self._precomputed:
            X = self._validate_input(X, in_fit=True)
        else:
            _check_n_features(self, X, reset=True)
        self._n_features = X.shape[1]
        missing_features_info = self._get_missing_features_info(X)
        self.features_ = missing_features_info[1]
        return missing_features_info[0]
[/OUTPUT]</s>
<|user|>
 [OUTPUT]
import numpy as np
from scipy import sparse as sp
from sklearn.base import BaseEstimator, TransformerMixin, _fit_context
from sklearn.utils._mask import _get_mask
from sklearn.utils._missing import is_pandas_na, is_scalar_nan
from sklearn.utils._param_validation import MissingValues, StrOptions
from sklearn.utils.validation import (
    FLOAT_DTYPES,
    _check_feature_names_in,
    _check_n_features,
    check_is_fitted,
    validate_data,
)

class MissingIndicator(TransformerMixin, BaseEstimator):
    _parameter_constraints: dict = {'missing_values': [MissingValues()], 'features': [StrOptions({'missing-only', 'all'})], 'sparse': ['boolean', StrOptions({'auto'})], 'error_on_new': ['boolean']}

    def __init__(self, *, missing_values=np.nan, features='missing-only', sparse='auto', error_on_new=True):
        self.missing_values = missing_values
        self.features = features
        self.sparse = sparse
        self.error_on_new = error_on_new

    def _get_missing_features_info(self, X):
        if not self._precomputed: ## [BRANCH]taken=['N'][/BRANCH]
            imputer_mask = _get_mask(X, self.missing_values)
        else: ## [BRANCH]taken=['Y'][/BRANCH]
            imputer_mask = X
        if sp.issparse(X):
            imputer_mask.eliminate_zeros()
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is False:
                imputer_mask = imputer_mask.toarray()
            elif imputer_mask.format == 'csr':
                imputer_mask = imputer_mask.tocsc()
        else:
            if not self._precomputed:
                imputer_mask = _get_mask(X, self.missing_values)
            else:
                imputer_mask = X
            if self.features == 'missing-only':
                n_missing = imputer_mask.sum(axis=0)
            if self.sparse is True:
                imputer_mask = sp.csc_matrix(imputer_mask)
        if self.features == 'all':
            features_indices = np.arange(X.shape[1])
        else:
            features_indices = np.flatnonzero(n_missing)
        return (imputer_mask, features