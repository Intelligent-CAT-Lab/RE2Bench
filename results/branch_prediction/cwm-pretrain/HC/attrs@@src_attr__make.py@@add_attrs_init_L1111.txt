<|system|>
You are a helpful AI assistant. You always reason before responding, using the following format:
<think>
your internal reasoning
</think>
your external response
</s>
<|user|>
You will be given:
1. A Python code snippet wrapped in [PYTHON] ... [/PYTHON]. The code includes branch markers in comments of the form # [BRANCH]taken=??[/BRANCH].
2. A method input wrapped in [INPUT] ... [/INPUT].
Your task is to replace every "??" in "taken=??" with your prediction of whether the branches are taken during execution for the given input.

Detailed Instructions:
* Replace ?? with a list (e.g., ['Y', 'N', ...]).
* For each time that branch point is encountered during execution:
   ** Append 'Y' if that branch is taken.
   ** Append 'N' if that branch is not taken.
* Determine branch outcomes by tracing the code step by step, paying special attention to conditionals and loop iterations. Wrap your reasoning in <think> ... </think>
* Output the fully annotated code (with ?? replaced) wrapped in [ANSWER] ... [/ANSWER]
* Do not remove, reorder, or add any code lines. 
* Preserve the original line numbers exactly as they appear in the [PYTHON] ... [/PYTHON] block.

Please follow the format in the example below:


[EXAMPLE]
[PYTHON]
1   class TempPathFactory(object):
2       _given_basetemp = attr.ib(
3           converter=attr.converters.optional(
4               lambda p: Path(os.path.abspath(six.text_type(p)))
5           )
6       )
7       _trace = attr.ib()
8       _basetemp = attr.ib(default=None)
9
10      def mktemp(self, basename, numbered=True):
11          if not numbered: ## [BRANCH]taken=??[/BRANCH]
12              p = self.getbasetemp().joinpath(basename)
13              p.mkdir()
14          else: ## [BRANCH]taken=??[/BRANCH]
15              p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
16              self._trace("mktemp", p)
17          return p
18
19      def getbasetemp(self):
20          if self._basetemp is not None:
21              return self._basetemp
22
23          if self._given_basetemp is not None:
24              basetemp = self._given_basetemp
25              ensure_reset_dir(basetemp)
26              basetemp = basetemp.resolve()
27          else:
28              from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
29              temproot = Path(from_env or tempfile.gettempdir()).resolve()
30              user = get_user() or "unknown"
31              rootdir = temproot.joinpath("pytest-of-{}".format(user))
32              rootdir.mkdir(exist_ok=True)
33              basetemp = make_numbered_dir_with_cleanup(
34                  prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
35              )
36          assert basetemp is not None, basetemp
37          self._basetemp = t = basetemp
38          self._trace("new basetemp", t)
39          return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

The input to method ```mktemp``` is:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

Complete the branch annotation in the code with "Y" and "N".

<think>
In mktemp, the condition `if not numbered:` is checked once. 
Since numbered=True, it is not taken â†’ ['N']. 
Therefore the execution goes to the else: branch.
</think>

[ANSWER]
1   class TempPathFactory(object):
2       _given_basetemp = attr.ib(
3           converter=attr.converters.optional(
4               lambda p: Path(os.path.abspath(six.text_type(p)))
5           )
6       )
7       _trace = attr.ib()
8       _basetemp = attr.ib(default=None)
9
10      def mktemp(self, basename, numbered=True):
11          if not numbered: ## [BRANCH]taken=[N][/BRANCH]
12              p = self.getbasetemp().joinpath(basename)
13              p.mkdir()
14          else: ## [BRANCH]taken=[Y][/BRANCH]
15              p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
16              self._trace("mktemp", p)
17          return p
18
19      def getbasetemp(self):
20          if self._basetemp is not None:
21              return self._basetemp
22
23          if self._given_basetemp is not None:
24              basetemp = self._given_basetemp
25              ensure_reset_dir(basetemp)
26              basetemp = basetemp.resolve()
27          else:
28              from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
29              temproot = Path(from_env or tempfile.gettempdir()).resolve()
30              user = get_user() or "unknown"
31              rootdir = temproot.joinpath("pytest-of-{}".format(user))
32              rootdir.mkdir(exist_ok=True)
33              basetemp = make_numbered_dir_with_cleanup(
34                  prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
35              )
36          assert basetemp is not None, basetemp
37          self._basetemp = t = basetemp
38          self._trace("new basetemp", t)
39          return t
[/ANSWER]
[/EXAMPLE]

<Python>
1 import asyncio
2 import os
3 import textwrap
4 import threading
5 import time
6 from contextlib import contextmanager, suppress
7 from unittest.mock import Mock
8 
9 import attr
10 import pytest
11 import pytest_asyncio
12 
13 from graphql.execution.execute import execute, get_operation_root_type
14 from graphql.language.ast import OperationDefinition
15 from graphql.language.printer import print_ast
16 from graphql.pyutils import AwaitableOrValue
17 from graphql.validation import ValidationContext, validate
18 
19 from .utils import (
20     SNAPSHOT_STRATEGY,
21     SnapshotSnapshotStrategy,
22     _check_file_perms,
23     _filter,
24     _subprocess_call,
25     _write_path_to_result,
26     async_test,
27     check_path,
28     check_paths_collected,
29     check_snapshot_strategies,
30     import_from_node_module,
31     process_snapshots,
32     raise_too_long,
33 )
34 from ..cli import Main
35 from ..diff import DIFF_BASE_NAME, DIFF_SEPARATOR, DIFF_PREFIX
36 from ..types import SnapshotUpdateResult, SnapshotUpdateResults
37 from ..utils import c, zipx
38 
39 __all__ = [
40     'SnapshotAssertionError',
41     'SnapshotExtension',
42     'TemporaryDirectory',
43 ]
44 
45 
46 class SnapshotExtension:
47     def __init__(self, *,
48         diff: bool,
49         is_wsl: bool,
50         process_cwd: str,
51         process_timeout: float,
52         snapshot_update: bool,
53         tmp_path_factory: _compat.TempPathFactory,
54         use_pkg_resources: bool,
55     ):
56         self.diff = diff
57         self.is_wsl = is_wsl
58         self.process_cwd = process_cwd
59         self.process_timeout = process_timeout
60         self.snapshot_update = snapshot_update
61         self.tmp_path_factory = tmp_path_factory
62         self.use_pkg_resources = use_pkg_resources
63 
64         self.basepath: str = None
65         self.snapshot_strategy: SnapshotSnapshotStrategy = None
66 
67     def autouse(self, config: _pytest.config.Config) -> None:
68         self.basepath = config.rootpath
69 
70         if config.option.doctestmodules and not self.snapshot_update:
71             # prevent the plugin from erroring on doctests
72             return
73 
74         self.snapshot_strategy = _get_snapshot_strategy(config, config.rootpath, use_pkg_resources=self.use_pkg_resources)
75 
76     def pytest_sessionstart(self, session: _pytest.main.Session) -> None:
77         self.pytest_config = session.config
78         session.config._store[self] = self  # register for snapupdate
79 
80         if self.snapshot_update:
81             self._update_snapshots(session=self.pytest_config.hook, print_value='printing')
82         else:
83             self.snapshot_strategy.reset_snapshot_dir()
84 
85     def pytest_collection_modifyitems(self, session: _pytest.main.Session, config: _pytest.config.Config, items: list[_pytest.nodes.Item]) -> None:
86         no_snapshots = []
87         for item in items:
88             if isinstance(item, _pytest.doctest.DoctestItem):
89                 # don't collect doctests if --snapshot-update
90                 no_snapshots.append(item)
91             else:
92                 # monkeypatch items with a _snapshots() method
93                 item._snapshots = _snapshots
94         if no_snapshots:
95             config.hook.pytest_deselected(items=no_snapshots)
96             items[:] = _filter(items, lambda item: item not in no_snapshots)
97 
98     def pytest_runtest_logreport(self, report: _pytest.runner.TestReport) -> None:
99         if report.when != 'call' or report.failed and not self.snapshot_update:
100             return
101 
102         maybe_snap_update = self.pytest_config.hook.pytest_snap_update(snapshot_update_results=self.snapshot_strategy.copy_update_result())
103         updates: list[AwaitableOrValue[SnapshotUpdateResults]] = []
104         for x in maybe_snap_update:
105             updates.extend(list(x) if hasattr(x, '__iter__') else [x])
106 
107         async def process(result: SnapshotUpdateResults) -> None:
108             errors = self.snapshot_strategy.filter_snaps(result, raise_no_update=True)
109             await asyncio.gather(
110                 *(self.snapshot_strategy.async_replace_snaps(path=path, snap=SnapResult(snaps, basepath=self.basepath)) for snaps in errors)
111             )
112 
113         # handle any update results
114         if updates:
115             asyncio.run(self.snapshot_strategy.handle_snapshot_update(results=updates, handler=process))
116         else:
117             self.snapshot_strategy.raise_if_failed_snaps()
118 
119     def pytest_report_header(self, config: _pytest.config.Config, start_path: os.PathLike) -> list[str]:
120         if not self.snapshot_update:
121             return ['snapshot_dates: {}'.format(self.snapshot_strategy.snapshot_dates)]
122 
123     def pytest_snapshot(self, *, snapshot_update_results: SnapshotUpdateResults) -> Iterable[AwaitableOrValue[None]]:
124         # run snapshot reporting
125         error_snaps = snapshot_update_results.errors
126         if error_snaps and not self.pytest_config.option.verbose:
127             self.pytest_config.warn(code='pytest-snapshot', message='These failed to update.\n{}'.format(error_snaps))
128         self.pytest_config.hook.pytest_report_snapshot(snapshot_update_results=snapshot_update_results, config=self.pytest_config, start_path=self.pytest_config.startpath)
129 
130     def pytest_report_snapshot(self, snapshot_update_results: SnapshotUpdateResults, config: _pytest.config.Config, start_path: os.PathLike) -> None:
131         if not snapshot_update_results or not self.pytest_update:
132             # if `--no-snapshot-update` is set, report any update results
133             return
134         updates = [
135             c.Oxfblue(x.reason + DIFF_SEPARATOR) for x in snapshot_update_results[0].updates if x.reason in {SnapshotUpdateResult.INCORRECT, SnapshotUpdateResult.NOT_IN_LINKS}
136         ]
137         if updates:
138             update_str = '\n'.join(updates)
139         else:
140             update_str = ''
141 
142         error_str = '\n'.join(
143             x.reason + DIFF_SEPARATOR + x.snapshot_path for x in snapshot_update_results[0].errors
144         )
145         message = '\n'
146         if error_str:
147             message += c.Fore.red('Error(s) while updating snapshots:') + c.Fore.white + error_str + c.Fore.reset
148         if update_str:
149             message += c.Fore.green('\nUpdate(s) to snapshots:') + c.Fore.white + update_str + c.Fore.reset
150         config.workeroutput[0].writeln(message)
151 
152     @property
153     def _has_failed_snaps(self) -> bool:
154         return bool(self.snapshot_strategy.failed)
155 
156     @contextmanager
157     def _update_snapshots(self, *,
158         session: _pytest.hookspec.Session,
159         print_value: str,
160     ) -> Generator:
161         try:
162             message = 'Updating snapshots'
163             if print_value is not None:
164                 message += f' ({print_value})'
165             session.pytest_collectreport(report=self.pytest_config.hook.pytest_report_header(config=self.pytest_config, start_path=self.basepath))
166 
167             all_passed = all(map(lambda x: isinstance(x, _pytest.runner.TestReport), session.pytest_runtestloop(session=self.pytest_config)))
168             if all_passed:
169                 message += ' - Success!'
170             else:
171                 message += ' - FAILURE!'
172             session.pytest_sessionfinish(exitstatus=0, session=self.pytest_config)
173             self.pytest_config.hook.pytest_terminal_summary(terminalreporter=self.pytest_config.pluginmanager.getplugin('terminalreporter'), exitstatus=0, config=self.pytest_config)
174             yield
175         except Exception as e:
176             self.pytest_config.hook.pytest_terminal_summary(terminalreporter=self.pytest_config.pluginmanager.getplugin('terminalreporter'), exitstatus=1, config=self.pytest_config)
177             self.pytest_config.hook.pytest_sessionfinish(session=self.pytest_config)
178             raise type(e)(f'{message}!\n{e}') from e
179         else:
180             report = self.pytest_config.hook.pytest_report_teststatus(report=self.pytest_config.hook.pytest_runtest_makereport(item=None, call=None))
181             if report.longreprtext and not any(map(lambda x: self.pytest_config.hook.pytest_report_teststatus(report=x) in report.longreprtext, report.longreprtext)):
182                 report.longreprtext = report.longreprtext.split('\n\n')[1:]
183 
184     def _get_run_args(
185         self,
186         test: Union[
187             _pytest.python.Function,
188             _pytest.nodes.Node,
189             str,
190         ],
191     ) -> tuple[list[str], list[str]]:
192         args = []
193         nodeid = test.nodeid if isinstance(test, _pytest.python.Function) else test.nodeid if hasattr(test, 'nodeid') else test
194         try:
195             # try to use short version for <TestModule ...>
196             nodeid = re.sub(r'(\<[A-Za-z0-9]* )([^:]*)', r'\1...', nodeid)
197         except Exception:  # if no match
198             pass
199         # Make command args
200         if 'test_' in nodeid or ('_' in nodeid and 'test' in nodeid): ## [BRANCH]taken=??[/BRANCH]
201             if ':' in nodeid:
202                 for i in nodeid.split('::'):
203                     if 'test_' in i:
204                         args.append(nodeid)
205                         break
206                     else:
207                         for i in nodeid.split('::'):
208                             if 'test_' in i:
209                                 args.append(nodeid)
210                                 break
211                             else:
212                                 if 'test_' in i:
213                                     args.append(nodeid)
214                                     break
215                                 else:
216                                     args.append(nodeid)
217                                     break
218                                 else:
219                                     for i in nodeid.split('::'):
220                                         if 'test_' in i:
221                                             args.append(nodeid)
222                                             break
223                                         else:
224                                             args.append(nodeid)
225                                             break
226                                         else:
227                                             args.append(nodeid)
228                                             break
229                                         else:
240                                             args.append(nodeid)
241                                             break
242                                         else:
243                                             args.append(nodeid)
244                                             break
245                                         else:
246                                             args.append(nodeid)
247                                             break
248                                         else:
249                                             args.append(nodeid)
250                                             break
251                                         else:
252                                             args.append(nodeid)
253                                             break
254                                         else:
255                                             args.append(nodeid)
256                                             break
257                                         else:
258                                             args.append(nodeid)
259                                             break
260                                         else:
261                                             args.append(nodeid)
262                                             break
263                                         else:
264                                             args.append(nodeid)
265                                             break
266                                         else:
267                                             args.append(nodeid)
268                                             break
269                                         else:
270                                             args.append(nodeid)
271                                             break
272                                         else:
273                                             args.append(nodeid)
274                                             break
275                                         else:
276                                             args.append(nodeid)
277                                             break
278                                         else:
279                                             args.append(nodeid)
280                                             break
281                                         else:
282                                             args.append(nodeid)
283                                             break
284                                         else:
285                                             args.append(nodeid)
286                                             break
287                                         else:
288                                             args.append(nodeid)
289                                             break
290                                         else:
291                                             args.append(nodeid)
292                                             break
293                                         else:
294                                             args.append(nodeid)
295                                             break
296                                         else:
297                                             args.append(nodeid)
298                                             break
299                                        