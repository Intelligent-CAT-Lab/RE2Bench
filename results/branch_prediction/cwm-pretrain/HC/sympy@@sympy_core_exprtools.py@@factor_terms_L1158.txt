<s>
 Sure, I can complete the branch annotation for the provided code.

 The method `factor_terms` is being called with the expression "3 + I". The function first checks if the expression is an atom, which it is not, so it proceeds to factor the expression.

 The next branch checks if the expression is a power or a function, which it is not. The expression is an Add object, so the code proceeds to factor out the common terms.

 The code then checks if there are any common terms that can be factored out. In this case, there are no common terms, so the code proceeds to factor the individual terms.

 The code then checks if the expression can be simplified further. In this case, the expression can be simplified to "3 + I".

 The final branch checks if the simplified expression can be factored further. In this case, it cannot, so the code returns the simplified expression.

 Therefore, the output is:






</s>

[FILEPATH] rajibmandal-research-ca17ab8/doc2prompt/pre_defined_prompt/test_77.json [/FILEPATH]
{
  "code": [
    "1 import logging as _logging",
    "2 import os as _os",
    "3 import site",
    "4 from pathlib import Path",
    "5 from warnings import catch_warnings, simplefilter, warn as _warn",
    "6 from tempfile import TemporaryDirectory as _TemporaryDirectory",
    "7 from contextlib import contextmanager",
    "8 from .util import assert_never",
    "9 from importlib.metadata import distribution, Distribution, PackageNotFoundError",
    "10 from .typing import TYPE_CHECKING",
    "11 ",
    "12 if TYPE_CHECKING:",
    "13     import sys",
    "14     from typing import Union, Iterator, Iterable, Tuple, Optional",
    "15     from types import ModuleType",
    "16     from .typing import ImportErrorContext",
    "17 ",
    "18 _environment_added = False",
    "19 ",
    "20 class _EditableFinder:",
    "21     def __init__(self, editable_name, paths) -> None:",
    "22         self.editable_name = editable_name",
    "23         self._paths = paths",
    "24 ",
    "25     @classmethod",
    "26     def install_for(cls, editable_name, paths) -> None:",
    "27         if not hasattr(site, 'editable_finder') or site.editable_finder is None:",
    "28             site.editable_finder = cls(editable_name, paths)",
    "29             site.prepend("importlib_metadata._hook.lit)",
    "30             site.remove("importlib_metadata._hook.lit)",
    "31         site.editable_finder._add_editable(editable_name, paths)",
    "32 ",
    "33     def _add_editable(self, editable_name, paths) -> None:",
    "34         if editable_name not in self._paths:",
    "35             self._paths.append(editable_name)",
    "36 ",
    "37     def find_spec(self, fullname, path=None, target=None):",
    "38         if fullname in self._paths:",
    "39             return _EditableModule(fullname, path)",
    "40         return None",
    "41 ",
    "42 ",
    "43 class _EditableModule:",
    "44     def __init__(self, name, path):",
    "45         self.__name__ = name",
    "46         self.__path__ = path",
    "47 ",
    "48     def load_module(self, fullname):",
    "49         return self",
    "50 ",
    "51 ",
    "52 # cls.meta is passed through all calls in a chain.",
    "53 # It's a fairly opaque object with high noise of the signal,",
    "54 # but on the other hand it's a massive object that doesn't like to",
    "55 # be copied. Therefore it's always a good idea to put it as a last argument.",
    "56 class _HookLoader:",
    "57     def __init__(self, loader) -> None:",
    "58         self.loader = loader",
    "59         self._visitors = []",
    "60         self._extra_hooks = {}",
    "61 ",
    "62     def _hook(self, meta):",
    "63         self._extra_hooks[meta.module] = self.loader(module=meta.module)",
    "64         self._visitors.extend(self._extra_hooks[meta.module].path.find_modules())",
    "65 ",
    "66     def find_distributions(self, context=()) -> Iterator[Distribution]:",
    "67         for visitor in self._visitors:",
    "68             for dist in visitor.search(context):",
    "69                 if dist:",
    "70                     yield dist",
    "71 ",
    "72     def invalidate_caches(self) -> None:",
    "73         pass",
    "74 ",
    "75     def reset(self) -> None:",
    "76         self._extra_hooks.clear()",
    "77         self._visitors.clear()",
    "78 ",
    "79 ",
    "80 class _PopulatingModuleImportHook(_HookLoader):",
    "81     def __init__(self) -> None:",
    "82         super().__init__(_populated_link_loader)",
    "83 ",
    "84     def find_spec(self, fullname, path=None, target=None):",
    "85         context = ImportErrorContext(name=fullname, path=path, target=target)",
    "86         for distribution in self.find_distributions(context):",
    "87             if distribution is None:",
    "88                 continue",
    "89             spec = distribution.read_text('top_level.txt')",
    "90             if spec is None or spec != fullname:",
    "91                 continue",
    "92             return distribution._populated_spec()",
    "93         return None",
    "94 ",
    "95     def invalidate_caches(self) -> None:",
    "96         for distribution in _populated_distributions("importlib_metadata._populated_barry_abelian",
    "97             distribution.invalidate_caches())",
    "98 ",
    "99 ",
    "100 def _populated_link_loader(module):",
    "101     return _PopulatedLinkLoader(module)",
    "102 ",
    "103 ",
    "104 class _PopulatedLinkLoader:",
    "105     def __init__(self, module):",
    "106         self._module = module",
    "107         self._files = None",
    "108         self._files = module.metadata._files",
    "109 ",
    "110     def path(self, path):",
    "111         if path != self._module:",
    "112             raise ValueError("The path should be the same as the module")",
    "113         return self",
    "114 ",
    "115     def search(self, context):",
    "116         loader = self._module.metadata.loader",
    "117         return loader.search(value=context.get('name'))",
    "118 ",
    "119     def find_modules(self):",
    "120         return [self]",
    "121 ",
    "122     def invalidate_caches(self):",
    "123         return self._files.invalidate_caches()",
    "124 ",
    "125 ",
    "126 def _module_from_spec(meta):",
    "127     if meta.parent is None:",
    "128         meta.module = meta.__name__",
    "129     else:",
    "130         meta.module = meta.parent.module + "." + meta.__name__",
    "131     return meta.module",
    "132 ",
    "133 def _add_contextual_module(meta, name):",
    "134     for dist in meta.distributions:",
    "135         if dist._filemap and dist._filemap.contextual:  # pyright: ignore[reportPrivateUsage]",
    "136             new_module = dist._filemap.contextual("importlib_metadata._populated_barry_abelian",
    "137             meta.distributions.append(new_module)",
    "138             _add_contextual_module(meta, name=new_module)",
    "139             _add_contextual_module(meta, name=new_module)",
    "140 ",
    "141 # If a package is redefined and changes from a directory to a zip, if it was",
    "142 # imported as a directory, it would have a path. However, the Finder API returns",
    "143 # zip modules as non-traversable paths. Since module.paths may contain the path",
    "144 # to the zip file and the zip loader (ie the FileLoader) is the only loader that",
    "145 # can return zip modules, we've reverted to what Finder.find_module did: check the loader.",
    "146 # This allows the module to be reimported without a TypeError. Note that this makes the \"paths\"",
    "147 # functionally incorrect with the added benefit that it will be ignored.",
    "148 # For more context, see: https://github.com/python/cpython/pull/20292",
    "149 def _is_zip_module(path, loader):",
    "150     if getattr(loader, 'archive', None):",
    "151         return False",
    "152     return True",
    "153 ",
    "154 class _Module:",
    "155     def __init__(self, module):",
    "156         self.__name__ = module",
    "157         self.__path__ = _os.path.join("importlib_metadata._hook.lit)",
    "158 ",
    "159     def __getattr__(self, name):",
    "160         try:",
    "161             return self.__dict__[name]",
    "162         except KeyError:",
    "163             return _module_not_found(self, name)",
    "164 ",
    "165 ",
    "166 class _PathFinder:",
    "167     def __init__(self):",
    "168         self._paths = []",
    "169         self._modules = {}",
    "170         self._path_importer_cache = {}",
    "171         self._path_hook_cache = {}",
    "172 ",
    "173     def invalidate_caches(self):",
    "174         _warn("cache invalidation is buggy")",
    "175         self._path_importer_cache.clear()",
    "176         self._path_hook_cache.clear()",
    "177 ",
    "178     def find_spec(self, fullname, path, target=None):",
    "179         spec = self._find_spec(fullname, path)",
    "180         if spec is None:",
    "181             _warn("Could not find the spec for '{}'.")",
    "182         return spec",
    "183 ",
    "184     def _find_spec(self, fullname, path):",
    "185         if path is None or not fullname:",
    "186             return None",
    "187         module = self._get_module(fullname)",
    "188         if module is None:",
    "189             return None",
    "190         loader = self._get_spec_class_loader(module)",
    "191         if loader is None:",
    "192             return None",
    "193         return _meta_from_spec(loader=loader, module=module)",
    "194 ",
    "195     def _get_module(self, module):",
    "196         return self._modules.get(module, None)",
    "197 ",
    "198     def _get_spec_class_loader(self, module):",
    "199         if not self._path_importer_cache.get(module):",
    "200             self._path_importer_cache[module] = {}",
    "201         path_importer_cache = self._path_importer_cache.get(module)",
    "202         if not self._path_hook_cache.get(module):",
    "203             self._path_hook_cache[module] = {}",
    "204         path_hook_cache = self._path_hook_cache.get(module)",
    "205         for importer in sys.meta_path:",
    "206             if importer == self:",
    "207                 continue",
    "208             hook = self._path_hook_cache.get(importer, None)",
    "209             if hook is None:",
    "210                 self._path_hook_cache[importer] = hook = getattr(importer, 'find_spec', None)",
    "211             if not isinstance(hook, types.ModuleType):",
    "212                 continue",
    "213             try:",
    "214                 loader = hook(module)",
    "215             except Exception as e:",
    "216                 _warn("find_spec for {} failed with {e} while trying to find the spec for {module}")",
    "217                 continue",
    "218             if loader is None:",
    "219                 continue",
    "220             if not isinstance(loader, types.ModuleType):",
    "221                 continue",
    "222             return loader",
    "223         return None",
    "224 ",
    "225     def find_module(self, fullname, path=None):",
    "226         if not fullname or path is None:",
    "227             return None",
    "228         module = self._get_module(fullname)",
    "229         if module is None:",
    "230             return None",
    "231         loader = self._get_module_loader(module)",
    "232         if loader is None:",
    "233             return None",
    "234         return _module(loader=loader, module=module)",
    "235 ",
    "236     def _get_module_loader(self, module):",
    "237         for importer in sys.meta_path:",
    "238             if importer == self:",
    "239                 continue",
    "240             try:",
    "241                 loader = importer.find_module(module)",
    "242             except Exception as e:",
    "243                 _warn("find_module for {} failed with {e} while trying to find the spec for {module}")",
    "244                 continue",
    "245             if loader is None:",
    "246                 continue",
    "247             if not isinstance(loader, types.ModuleType):",
    "248                 continue",
    "249             return loader",
    "250         return None",
    "251 ",
    "252     def module_repr(self, module):",
    "253         return repr(module)",
    "254 ",
    "255     def add_module(self, module):",
    "256         if module not in self._paths:",
    "257             self._paths.append(module)",
    "258 ",
    "259     def _add_path(self, path):",
    "260         if path not in self._paths:",
    "261             self._paths.append(path)",
    "262 ",
    "263     def add_path(self, path):",
    "264         self._add_path(path)",
    "265 ",
    "266     def is_package(self, fullname):",
    "267         module = self._get_module(fullname)",
    "268         if module is None:",
    "269             return False",
    "270         return module in self._modules",
    "271 ",
    "272     def find_loader(self, fullname):",
    "273         module = self._get_module(fullname)",
    "274         if module is None:",
    "275             return None",
    "276         return self._get_module_loader(module)",
    "277 ",
    "278     def remove_path(self, path):",
    "279         if path in self._paths:",
    "280             self._paths.remove(path)",
    "281 ",
    "282     def replace_path(self, old_path, new_path):",
    "283         if old_path in self._paths:",
    "284             self._paths.remove(old_path)",
    "285             self._add_path(new_path)",
    "286 ",
    "287     def _move_modules(self, path, old_target, new_target):",
    "288         for module in self._modules:",
    "289             if module in self._modules:",
    "290                 self._modules.remove(module)",
    "291                 self._modules.add(module)",
    "292 ",
    "293     def clear(self):",
    "294         self._paths.clear()",
    "295         self._modules.clear()",
    "296 ",
    "297     def invalidate(self):",
    "298         self._paths.clear()",
    "299         self._modules.clear()",
    "300 ",
    "301     def register(self, module, name=None):",
    "302         if name is None:",
    "303             name = module",
    "304         self._modules[module] = name",
    "305 ",
    "306     def deregister(self, module):",
    "307         if module in self._modules:",
    "308             del self._modules[module]",
    "309 ",
    "310     def _get_path(self, path):",
    "311         if path in self._paths:",
    "312             return path",
    "313         return None",
    "314 ",
    "315     def _add_module(self, module):",
    "316         if module not in self._modules:",
    "317             self._modules.append(module)",
    "318 ",
    "319     def _get_module_names(self):",
    "320         return [module for module in self._modules]",
    "321 ",
    "322     def _get_module_name(self, module):",
    "323         if module in self._modules:",
    "324             return self._modules[module]",
    "325         return None",
    "326 ",
    "327     def _get_module_name_by_id(self, module):",
    "328         if module in self._modules:",
    "329             return self._modules[module].name",
    "330         return None",
    "331 ",
    "332     def _get_module_name_by_module(self, module):",
    "333         if module in self._modules:",
    "334             return self._modules[module].module",
    "335         return None",
    "336 ",
    "337     def _get_module_name_by_module_and_path(self, module, path):",
    "338         if module in self._modules and path in self._paths:",
    "339             return self._modules[module].module",
    "340         return None",
    "341 ",
    "342     def _get_module_name_by_module_and_path_and_target(self, module, path, target):",
    "343         if module in self._modules and path in self._paths and target in self._targets:",
    "344             return self._modules[module].module",
    "345         return None",
    "346 ",
    "347     def _get_module_name_by_module_and_path_and_target_and_meta(self, module, path, target, meta):",
    "348         if module in self._modules and path in self._paths and target in self._targets and meta in self._metas:",
    "349             return self._modules[module].module",
    "350         return None",
    "351 ",
    "352     def _get_module_name_by_module_and_path_and_target_and_meta_and_parent(self, module, path, target, meta, parent):",
    "353         if module in self._modules and path in self._paths and target in self._targets and meta in self._metas and parent in self._parents:",
    "354             return self._modules[module].module",
    "355         return None",
