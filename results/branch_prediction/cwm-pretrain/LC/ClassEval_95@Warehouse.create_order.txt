<think>
Let's simulate the execution of `create_order(order_id=1, product_id=1, quantity=10)` step by step, paying special attention to conditionals:

1. `self.get_product_quantity(product_id=1)` is called:
   - Check if `1 in self.inventory`: Yes, so we return `self.inventory[1]['quantity']` which is `90`.
   - So, `self.get_product_quantity(product_id=1)` returns `90`.

2. Check if `self.get_product_quantity(product_id=1) >= quantity`:
   - `90 >= 10` is `True`, so this branch is taken â†’ append 'Y'.

3. `self.update_product_quantity(product_id=1, (-10))`:
   - `self.inventory[1]['quantity']` becomes `80`.

4. Assign order details:
   - `self.orders[1]` is updated.

</think>
<|output|>
1 class Warehouse():
2 
3     def __init__(self):
4         self.inventory = {}
5         self.orders = {}
6 
7     def update_product_quantity(self, product_id, quantity):
8         if (product_id in self.inventory):
9             self.inventory[product_id]['quantity'] += quantity
10 
11     def get_product_quantity(self, product_id):
12         if (product_id in self.inventory): ## [BRANCH]taken=[Y][/BRANCH]
13             return self.inventory[product_id]['quantity']
14         else: ## [BRANCH]taken=[N][/BRANCH]
15             return False
16 
17     def create_order(self, order_id, product_id, quantity):
18         if (self.get_product_quantity(product_id) >= quantity): ## [BRANCH]taken=[Y][/BRANCH]
19             self.update_product_quantity(product_id, (- quantity))
20             self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
21         else:
22             return False
23 
</|output|>

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/examples/python/testdata_03_prompt.py [/FILEPATH]
# pytest -vvv --tb=short testdata_03_prompt.py

from __future__ import annotations

from typing import Any, Literal, NamedTuple
from collections import deque
from typing import Dict
from typing import List
from typing import Optional
from typing import Set

import pytest

from hc_graphdb_gael.gael import GraphDatabase
from hc_graphdb_gael.record import DbEvent
from hc_graphdb_gael.record import read_record

from hc_graphdb_client.gdbc_client import GraphDatabaseClient

# from gael import Record
from hc_graphdb_gael.record import Record

rec_id = "test_record"
prog_id = "test_prog"

# def make_gdbc() -> GraphDatabaseClient:
#     return GraphDatabaseClient.connect("testsystem")
#
# def clear_all() -> None:
#     for record in gdbc_record_list():
#         print(f"Record: {record}")
#         gdbc_record_delete(record.name)

gdbc = GraphDatabaseClient.connect("testsystem")

# def read_record(record_id: str) -> Record:
#     return make_gdbc().read_record(record_id)
def gdbc_read_record(record_id: str) -> Record:
    print("gdbc_read_record")
    record = gdbc.read_record(record_id)
    print(f"record: {record}")
    return record

def gdbc_record_delete(record_id: str) -> None:
    gdbc.delete_record(record_id)

def gdbc_record_list() -> list[str]:
    return gdbc.record_list()

def run_blobs(tcx: GraphDatabase) -> tuple[DbEvent, DbEvent]:
    rec_id = "test_record"
    prog_id = "test_prog"
    rec_value_1 = Record(
        name=rec_id,
        rec_type="node",
        proj="testsystem",
        anchor=None,
        data={
            "body": "Body1",
            "context": [
                ["NAME", "Value1"],
            ],
        },
    )
    rec_value_2 = Record(
        name="test_record",
        rec_type="node",
        proj="testsystem",
        anchor=None,
        data={
            "body": "Body2",
            "context": [
                ["NAME", "Value2"],
            ],
        },
    )
    tcx.write_record(prog_id, rec_id, rec_value_1)
    print("ran blobs")
    tcx.write_record(prog_id, rec_id, rec_value_2)
    print("ran blobs")
    val1 = tcx.read_record(rec_id)
    val2 = tcx.read_record(rec_id)
    return val1, val2


def test_01_blobs_graphdb(client: GraphDatabaseClient) -> None:
    tcx = GraphDatabase(client)
    db_event_list = list[DbEvent]()
    for db_event in run_blobs(tcx):
        db_event_list.append(db_event)
    # db_event_1, db_event_2 = run_blobs(tcx)
    print(f"db_event_list: {db_event_list}")
    db_event_1 = db_event_list[0]
    db_event_2 = db_event_list[1]
    rec_value_1 = db_event_1.record_value
    rec_value_2 = db_event_2.record_value
    print(rec_value_1)
    print(rec_value_2)
    assert db_event_1 == DbEvent(
        prog_id=prog_id,
        record_name=rec_id,
        record_type="node",
        record_value=rec_value_1,
    )
    assert db_event_2 == DbEvent(
        prog_id=prog_id,
        record_name=rec_id,
        record_type="node",
        record_value=rec_value_2,
    )
    # assert db_event_1.record_value.to_dict() == {
    #     "name": "test_record",
    #     "rec_type": "node",
    #     "proj": "testsystem",
    #     "anchor": None,
    #     "data": {
    #         "body": "Body1",
    #         "context": [["NAME", "Value1"]],
    #     },
    # }
    # assert db_event_2.record_value.to_dict() == {
    #     "name": "test_record",
    #     "rec_type": "node",
    #     "proj": "testsystem",
    #     "anchor": None,
    #     "data": {
    #         "body": "Body2",
    #         "context": [["NAME", "Value2"]],
    #     },
    # }
    db_history = tcx.history(rec_id)
    print(db_history)
    assert db_history == [
        DbEvent(
            prog_id=prog_id,
            record_name=rec_id,
            record_type="node",
            record_value=rec_value_1,
        ),
        DbEvent(
            prog_id=prog_id,
            record_name=rec_id,
            record_type="node",
            record_value=rec_value_2,
        ),
    ]
    # gdbc.delete_record(rec_id)
    # gdbc.delete_record(rec_id)
    gdbc_record_delete(rec_id)

# from database.gdbc_python import GraphDatabaseClient
# from database.record import Record, DbEvent
#
# class GraphDatabase:
#     def __init__(self, client: GraphDatabaseClient) -> None:
#         self.client = client
#
#     def read_record(self, record_id: str) -> DbEvent:
#         rec_val = self.client.read_record(record_id)
#         return DbEvent(
#             prog_id="TestProg",
#             record_name=record_id,
#             record_type=rec_val.rec_type,
#             record_value=rec_val,
#         )
#
#     def write_record(self, prog_id: str, record_id: str, record: Record) -> None:
#         self.client.write_record(record)
#
#     def history(self, record_id: str) -> List[DbEvent]:
#         rec = self.client.read_record(record_id)
#         hist = list[DbEvent]()
#         if rec is not None:
#             hist.append(
#                 DbEvent(
#                     prog_id="TestProg",
#                     record_name=record_id,
#                     record_type=rec.rec_type,
#                     record_value=rec,
#                 )
#             )
#         return hist


# def test_01_blobs(client: GraphDatabaseClient) -> None:
#     tcx = GraphDatabase(client)
#     db_event_1 = tcx.read_record(rec_id)
#     db_event_2 = tcx.read_record(rec_id)
#     print(db_event_1)
#     print(db_event_2)
#     assert db_event_1 == DbEvent(
#         prog_id="TestProg",
#         record_name=rec_id,
#         record_type="node",
#         record_value=read_record(rec_id),
#     )
#     assert db_event_2 == DbEvent(
#         prog_id="TestProg",
#         record_name=rec_id,
#         record_type="node",
#         record_value=read_record(rec_id),
#     )
#     db_history = tcx.history(rec_id)
#     assert db_history == [
#         DbEvent(
#             prog_id="TestProg",
#             record_name=rec_id,
#             record_type="node",
#             record_value=read_record(rec_id),
#         ),
#         DbEvent(
#             prog_id="TestProg",
#             record_name=rec_id,
#             record_type="node",
#             record_value=read_record(rec_id),
#         ),
#     ]


# def test_blobs(tmp_gdbc: GraphDatabaseClient) -> None:
#     tcx = GraphDatabase(tmp_gdbc)
#     db_event_1 = tcx.read_record(rec_id)
#     db_event_2 = tcx.read_record(rec_id)
#     print(db_event_1)
#     print(db_event_2)
#     assert db_event_1 == DbEvent(
#         prog_id=prog_id,
#         record_name=rec_id,
#         record_type="node",
#         record_value=read_record(rec_id),
#     )
#     assert db_event_2 == DbEvent(
#         prog_id=prog_id,
#         record_name=rec_id,
#         record_type="node",
#         record_value=read_record(rec_id),
#     )
#     db_history = tcx.history(rec_id)
#     assert db_history == [
#         DbEvent(
#             prog_id=prog_id,
#             record_name=rec_id,
#             record_type="node",
#             record_value=read_record(rec_id),
#         ),
#         DbEvent(
#             prog_id=prog_id,
#             record_name=rec_id,
#             record_type="node",
#             record_value=read_record(rec_id),
#         ),
#     ]
#
#     for record in gdbc_record_list():
#         print(f"Record: {record}")
#         gdbc_record_delete(record.name)

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/hc_graphdb_gael/pdb.py [/FILEPATH]
from __future__ import annotations

import argparse
import logging
import os

import pprint  # noqa: TID251

from .record import Record


logger = logging.getLogger(__name__)


def read_record(name: str) -> Record | None:
    from graphdb_client import GraphDatabaseClient  # noqa: TID251

    gdbc = GraphDatabaseClient("testsystem")
    record = gdbc.read_record(name)
    return record


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("--record")
    parser.add_argument("--graphdb-url")
    args = parser.parse_args()

    record = read_record(args.record)

    pprint.pprint(record)  # noqa: TID251


if __name__ == "__main__":
    main()

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/hc_graphdb_gael/record.py [/FILEPATH]
from __future__ import annotations

from typing import NamedTuple, Optional, Union

from pydantic import BaseModel


class Record(BaseModel):
    name: str
    rec_type: str
    proj: str
    anchor: Optional[str]
    data: dict[str, Union[list[list[str]], str]]


class DbEvent(NamedTuple):
    prog_id: str
    record_name: str
    record_type: str
    record_value: Record


def read_record(record_id: str) -> Record:
    # from graphdb_client import GraphDatabaseClient

    # gdbc = GraphDatabaseClient.connect("testsystem")
    # record = gdbc.read_record(record_id)
    # return record

    record = Record(
        name=record_id,
        rec_type="node",
        proj="testsystem",
        anchor=None,
        data={
            "body": "Test",
            "context": [["NAME", "Value"]],
        },
    )
    return record

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/hc_graphdb_gael/__init__.py [/FILEPATH]
# Keep __init__.py almost empty. Only import what you have to for your package to function.
#
# Everything else needed to make your package usable goes in your main module.

from .gael import *
from .gael.version import VERSION as __version__  # noqa: N812
from .gael.version import VERSION_STR as __version_str__  # noqa: N812

__all__ = [
    "__version__",
    "__version_str__",
    "GraphDatabase",
]

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/hc_graphdb_gael/gael.py [/FILEPATH]
from __future__ import annotations

from typing import Optional

from hc_graphdb_client import GraphDatabaseClient
from hc_graphdb_gael.record import DbEvent
from hc_graphdb_gael.record import Record


class GraphDatabase:
    def __init__(self, client: GraphDatabaseClient) -> None:
        self.client = client

    def read_record(self, record_id: str) -> DbEvent:
        rec_val = self.client.read_record(record_id)
        return DbEvent(
            prog_id="TestProg",
            record_name=record_id,
            record_type=rec_val.rec_type,
            record_value=rec_val,
        )

    def write_record(
        self, prog_id: str, record_id: str, record: Record
    ) -> Optional[DbEvent]:
        rec_val = self.client.write_record(record)
        return DbEvent(
            prog_id=prog_id,
            record_name=record_id,
            record_type=rec_val.rec_type,
            record_value=rec_val,
        )

    # def write_record(self, prog_id: str, record_id: str, record: Record) -> None:
    #     self.client.write_record(record)

    def history(self, record_id: str) -> list[DbEvent]:
        rec = self.client.read_record(record_id)
        hist = list[DbEvent]()
        if rec is not None:
            hist.append(
                DbEvent(
                    prog_id="TestProg",
                    record_name=record_id,
                    record_type=rec.rec_type,
                    record_value=rec,
                )
            )
        return hist

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/experimental/lib.py [/FILEPATH]
from __future__ import annotations

import openai
import streamlit as st


st.set_page_config(page_title="GPT-4 Vision Demo", page_icon="ðŸ‘€")

openai.api_key = st.secrets["openai_key"]


def clear_log() -> None:
    st.session_state["log"] = []


def send_prompt(prompt: str) -> None:
    from streamlit.runtime.uploaded_file_manager import UploadedFile

    def openai_call(*args: object, **kwargs: object) -> object:
        print("openai_call")
        return "Response"

    # if st.session_state["model"] == "GPT-4 Vision":
    #     prompt = process_image_message(st.session_state["messages"], prompt)
    st.session_state["log"].append(
        {
            "role": "user",
            "content": [{"type": "text", "text": prompt}],
        },
    )
    with st.spinner("Running..."):
        print(f'LOG: {st.session_state["log"]}')
        response = openai.chat.completions.create(
            model=st.session_state["model"],  # type: ignore
            messages=st.session_state["log"],
        )
        st.session_state["log"].append(
            {"role": "assistant", "content": response.choices[0].message.content}  # type: ignore
        )


def main() -> None:
    # Clear session state
    for key in [
        "log",
        "model",
        "messages",
    ]:
        if key not in st.session_state:
            st.session_state[key] = None
    print(st.session_state)
    st.button("Clear chat history", on_click=clear_log)
    if st.session_state["log"] is None:
        st.session_state["log"] = []

    # st.chat_message("assistant").write(
    #     "Hi, I'm a chatbot who can see. You can upload an image and I'll process it."
    # )
    # Choose a model
    st.session_state["model"] = "GPT-4 Vision"
    # st.selectbox(
    #     "Choose a model:", ["GPT-4 Vision", "GPT-3.5"], key="model"
    # )
    # if st.session_state["model"] == "GPT-4 Vision":
    #     st.caption("âœ¨ Experimental feature")

    # Upload image (if GPT-4 Vision is selected)
    if st.session_state["model"] == "GPT-4 Vision":
        st.file_uploader(
            "Upload an image",
            type=["png", "jpg", "jpeg"],
            key="image",
        )

    # Render existing chat
    for message in st.session_state["log"]:
        print(message)
        st.chat_message(message["role"]).write(message["content"])
        # if st.session_state["model"] == "GPT-4 Vision":
        #     if isinstance(message["content"], list):
        #         for content in message["content"]:
        #             if content["type"] == "text":
        #                 st.write(content["text"])
        #             elif content["type"] == "image_url":
        #                 st.image(content["image_url"]["url"])
        #     else:
        #         st.write(message["content"])

    # Chat input
    prompt = st.chat_input()
    if prompt:
        send_prompt(prompt)

    # Print final result
    # print(f'final {st.session_state["log"]}')


if __name__ == "__main__":
    main()

[FILEPATH] hc-engineering-hc-graphdb-gael-4ca6e1f/experimental/openai_conf.py [/FILEPATH]
from __future__ import annotations


# from dotenv import load_dotenv

# load_dotenv()
# print(f"Loaded env: