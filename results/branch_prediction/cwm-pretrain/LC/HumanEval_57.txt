<|think>
The input to the function is l = [9, 9, 9, 9]. We need to determine whether this list is monotonic.
At line 5, the condition is if l == sorted(l) or l == sorted(l, reverse=True):

sorted(l) will be [9, 9, 9, 9], so the first condition is True. Therefore, the branch is taken.
The second condition doesn't need to be evaluated since the first condition is True.
</think>

[ANSWER]
3 def monotonic(l: list):
4 
5     if l == sorted(l) or l == sorted(l, reverse=True): ## [BRANCH]taken=['Y'][/BRANCH]
6         return True
7     return False
[/ANSWER]

[FILEPATH] templates/egs/annotators/uncertain_include_nl_template.py [/FILEPATH]
SYSTEM_PROMPT = '''
<|system|>
You are a helpful AI assistant. You always reason before responding, using the following format:
<think>
your internal reasoning
</think>
your external response
</s>
<|user|>
You will be given:
1. A Python code snippet wrapped in [PYTHON] ... [/PYTHON]. The code includes branch markers in comments of the form # [BRANCH]taken=??[/BRANCH].
2. A method input wrapped in [INPUT] ... [/INPUT].
Your task is to replace every "??" in "taken=??" with your prediction of whether the branches are taken during execution for the given input.

Detailed Instructions:
* Replace ?? with a list (e.g., ['Y', 'N', ...]).
* For each time that branch point is encountered during execution:
   ** Append 'Y' if that branch is taken.
   ** Append 'N' if that branch is not taken.
* Determine branch outcomes by tracing the code step by step, paying special attention to conditionals and loop iterations. Wrap your reasoning in <think> ... </think>
* Output the fully annotated code (with ?? replaced) wrapped in [ANSWER] ... [/ANSWER]
* Do not remove, reorder, or add any code lines. 
* Preserve the original line numbers exactly as they appear in the [PYTHON] ... [/PYTHON] block.

Please follow the format in the example below:

[EXAMPLE]
[PYTHON]
1 def func(t):
2     count = 0 
3     for c in t:
4         if not c.isnumeric(): ## [BRANCH]taken=??[/BRANCH]
5             count += 1
6     return count
[/PYTHON]
The input to the method ```func``` is :
[INPUT]
{
    "self": {},
    "args": {
        "t": "#284"
    },
    "kwargs": {}
}
[/INPUT]

Complete the branch annotation in the code with "Y" and "N".

<think>
t = "#284" so the loop sees characters in order: '#', '2', '8', '4'.
At line 4, the condition is if not c.isnumeric():
c = '#': '#'.isnumeric() is False → not False is True → branch taken
c = '2': '2'.isnumeric() is True → not True is False → branch not taken
c = '8': branch not taken
c = '4':  branch not taken
</think>

[ANSWER]
1 def func(t):
2     count = 0 
3     for c in t:
4         if not c.isnumeric(): ## [BRANCH]taken=[Y,N,N,N][/BRANCH]
5             count += 1
6     return count
[/ANSWER]
[/EXAMPLE]

'''

INSTRUCTION_PROMPT = '''
1 
2 
3 def problem_helper(u: int, v: int, target: int, taken: set, visited: set, seen_pairs: dict) -> list:
4     if (u, v) in seen_pairs:
5         return seen_pairs[(u, v)]
6     if u in visited:
7         return False
8     if u == target:
9         return [str(u)] if not v else [str(u), "0"]
10     seen_pairs[(u, v)] = []
11     visited.add(u)
12     for c in children[u]:
13         for b in between(u, c):
14             if (b, c) in taken:
15                 x = problem_helper(c, b, target, taken, visited, seen_pairs)
16                 if len(x) > 0:
17                     seen_pairs[(u, v)] = [str(u)] + x
18     visited.remove(u)
19     return seen_pairs[(u, v)]
20 
21 
22 def reach(u: int, v: int, target: int) -> list:
23     return problem_helper(u, v, target, taken, set(), {})
24 

The input to the method ```reach``` is: 
 {
    "self": {},
    "args": {
        "u": 1,
        "v": 1,
        "target": 0
    },
    "kwargs": {}
}

Complete the branch annotation in the code with "Y" and "N".

 Always use the tags [OUTPUT] and [/OUTPUT] to enclose the predicted output in your external response. DO NOT generate any code or irrelevant text after your response. </s>
<|assistant|>
'''

