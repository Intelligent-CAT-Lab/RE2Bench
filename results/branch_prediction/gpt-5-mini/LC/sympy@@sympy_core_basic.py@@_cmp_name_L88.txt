[THOUGHT]
We execute _cmp_name with x = ImaginaryUnit, y = Pi.

- Lines 2-3 set n1 = 'ImaginaryUnit', n2 = 'Pi'. The equality check n1 == n2 is false, so the first "if n1 == n2" branch is not taken -> ['N'].

- Next we evaluate "if not issubclass(y, Basic)". In SymPy, Pi is a Basic subclass (numbers like Pi inherit from Basic), so issubclass(y, Basic) is True and "not issubclass(...)" is False. Thus that branch is not taken -> ['N'].

- Then i1 and i2 are looked up in ordering_of_classes. Typical ordering_of_classes contains named classes including 'ImaginaryUnit' and 'Pi', so both lookups succeed and neither index equals UNKNOWN. Therefore the condition "if i1 == UNKNOWN and i2 == UNKNOWN" is False, so that branch is not taken -> ['N'].

So the three branch points are all not taken.
[/THOUGHT]

[ANSWER]
1 def _cmp_name(x: type, y: type) -> int:
2     n1 = x.__name__
3     n2 = y.__name__
4     if n1 == n2: ## [BRANCH]taken=['N'][/BRANCH]
5         return 0
6 
7     if not issubclass(y, Basic): ## [BRANCH]taken=['N'][/BRANCH]
8         return -1
9 
10     UNKNOWN = len(ordering_of_classes) + 1
11     try:
12         i1 = ordering_of_classes.index(n1)
13     except ValueError:
14         i1 = UNKNOWN
15     try:
16         i2 = ordering_of_classes.index(n2)
17     except ValueError:
18         i2 = UNKNOWN
19     if i1 == UNKNOWN and i2 == UNKNOWN: ## [BRANCH]taken=['N'][/BRANCH]
20         return (n1 > n2) - (n1 < n2)
21     return (i1 > i2) - (i1 < i2)
22