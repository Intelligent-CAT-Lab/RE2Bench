[THOUGHT]
We trace get_integer_part with expr = 1/2, no = -1, options = {}, return_ints = True.

- evalf(...): for a real rational 1/2, the real part exists (ire truthy) and the imaginary part does not (iim falsy). So the "if ire and iim" branch is not taken, the "elif ire" branch is taken, and the "elif iim" branch is not taken.
- gap will be some finite number not extremely negative; comparing to -margin (-10) will almost certainly be >= -10, so the "if gap >= -margin" branch is taken, causing a second evalf call. That keeps ire truthy and iim falsy.
- Later, calc_part is called for the real part. Inside calc_part, the part's exponent p is not zero for 1/2 (it's not an integer), so "if not is_int" is taken.
- options has no 'subs', so s is False; the "if s" branch is not taken.
- calc_part proceeds and returns a numeric nint; im part is not processed (iim false).
- return_ints is True in kwargs, so the final "if return_ints" branch is taken and integer results are returned.

Each of these branch points is encountered once during this execution, so we annotate each with a single 'Y' or 'N' accordingly.
[/THOUGHT]

[ANSWER]
62 def get_integer_part(expr, no, options, return_ints=False):
63     from sympy.functions.elementary.complexes import re, im
64     assumed_size = 30
65     ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)
66 
67     if ire and iim: ## [BRANCH]taken=[N][/BRANCH]
68         gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)
69     elif ire: ## [BRANCH]taken=[Y][/BRANCH]
70         gap = fastlog(ire) - ire_acc
71     elif iim: ## [BRANCH]taken=[N][/BRANCH]
72         gap = fastlog(iim) - iim_acc
73     else:
74         return None, None, None, None
75 
76     margin = 10
77 
78     if gap >= -margin: ## [BRANCH]taken=[Y][/BRANCH]
79         ire, iim, ire_acc, iim_acc = \
80             evalf(expr, margin + assumed_size + gap, options)
81 
82     def calc_part(expr, nexpr):
83         from sympy.core.add import Add
84         nint = int(to_int(nexpr, rnd))
85         n, c, p, b = nexpr
86         is_int = (p == 0)
87         if not is_int: ## [BRANCH]taken=[Y][/BRANCH]
88             s = options.get('subs', False)
89             if s: ## [BRANCH]taken=[N][/BRANCH]
90                 doit = True
91                 from sympy.core.compatibility import as_int
92                 for v in s.values():
93                     try:
94                         as_int(v)
95                     except ValueError:
96                         try:
97                             [as_int(i) for i in v.as_real_imag()]
98                             continue
99                         except (ValueError, AttributeError):
100                             doit = False
101                             break
102                 if doit:
103                     expr = expr.subs(s)
104 
105             expr = Add(expr, -nint, evaluate=False)
106             x, _, x_acc, _ = evalf(expr, 10, options)
107             try:
108                 check_target(expr, (x, None, x_acc, None), 3)
109             except PrecisionExhausted:
110                 if not expr.equals(0):
111                     raise PrecisionExhausted
112                 x = fzero
113             nint += int(no*(mpf_cmp(x or fzero, fzero) == no))
114         nint = from_int(nint)
115         return nint, INF
116 
117     re_, im_, re_acc, im_acc = None, None, None, None
118 
119     if ire: ## [BRANCH]taken=[Y][/BRANCH]
120         re_, re_acc = calc_part(re(expr, evaluate=False), ire)
121     if iim: ## [BRANCH]taken=[N][/BRANCH]
122         im_, im_acc = calc_part(im(expr, evaluate=False), iim)
123 
124     if return_ints: ## [BRANCH]taken=[Y][/BRANCH]
125         return int(to_int(re_ or fzero)), int(to_int(im_ or fzero))
126     return re_, im_, re_acc, im_acc
[/ANSWER]