[THOUGHT]
function is sympified from "1" -> Integer(1), so:
- isinstance(function, Equality)? No -> ['N']
- function is S.NaN? No -> ['N']
- symbols is non-empty (["x"]) -> if symbols is True -> ['Y'], so the else branch for that is not taken -> ['N']
- For limits returned by _process_limits for a single symbol "x", each limit li will have length != 4 (typically length 1), so the inner if len(li) == 4 is not taken -> ['N']
[/THOUGHT]

[ANSWER]
1 from sympy.core.containers import Tuple
2 from sympy.core.relational import Equality, Relational
3 from sympy.core.singleton import S
4 from sympy.core.symbol import Symbol, Dummy
5 from sympy.core.sympify import sympify
6 from sympy.functions.elementary.piecewise import (piecewise_fold,
7     Piecewise)
8 from sympy.utilities.exceptions import sympy_deprecation_warning
9 
10 def _common_new(cls, function, *symbols, discrete, **assumptions):
11     function = sympify(function)
12 
13     if isinstance(function, Equality): ## [BRANCH]taken=[N][/BRANCH]
14         limits, orientation = _process_limits(*symbols, discrete=discrete)
15         if not (limits and all(len(limit) == 3 for limit in limits)):
16             sympy_deprecation_warning(
17                 deprecated_since_version="1.6",
18                 active_deprecations_target="deprecated-indefinite-integral-eq",
19                 stacklevel=5,
20             )
21 
22         lhs = function.lhs
23         rhs = function.rhs
24         return Equality(cls(lhs, *symbols, **assumptions), \
25                         cls(rhs, *symbols, **assumptions))
26 
27     if function is S.NaN: ## [BRANCH]taken=[N][/BRANCH]
28         return S.NaN
29 
30     if symbols: ## [BRANCH]taken=[Y][/BRANCH]
31         limits, orientation = _process_limits(*symbols, discrete=discrete)
32         for i, li in enumerate(limits):
33             if len(li) == 4: ## [BRANCH]taken=[N][/BRANCH]
34                 function = function.subs(li[0], li[-1])
35                 limits[i] = Tuple(*li[:-1])
36     else: ## [BRANCH]taken=[N][/BRANCH]
37         free = function.free_symbols
38         if len(free) != 1:
39             raise ValueError(
40                 "specify dummy variables for %s" % function)
41         limits, orientation = [Tuple(s) for s in free], 1
42 
43     while cls == type(function):
44         limits = list(function.limits) + limits
45         function = function.function
46 
47     reps = {}
48     symbols_of_integration = {i[0] for i in limits}
49     for p in function.atoms(Piecewise):
50         if not p.has(*symbols_of_integration):
51             reps[p] = Dummy()
52     function = function.xreplace(reps)
53     function = piecewise_fold(function)
54     function = function.xreplace({v: k for k, v in reps.items()})
55 
56     return function, limits, orientation
57 [/ANSWER]