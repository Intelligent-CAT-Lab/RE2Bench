[THOUGHT]
We are given the function get_integer_part with input expr=1/2, no=-1, options={}, return_ints=True.

The expression 1/2 is a real number, so its imaginary part is 0.

We assume that evalf returns an mpf tuple for the real part (ire) and for the imaginary part (iim), with iim being fzero (the mpf representation of 0). In Python, mpf tuples are truthy, so both ire and iim are truthy.

Therefore, at line 67, condition `if ire and iim:` evaluates to True, so branch taken: Y.

Since the if branch is taken, the elif conditions at lines 69 and 71 are not evaluated, so they are never encountered. Hence their taken lists are empty.

We compute gap as max(fastlog(ire)-ire_acc, fastlog(iim)-iim_acc). For ire (0.5), fastlog(0.5) is -1, ire_acc is 30, so -1-30 = -31. For iim (0), fastlog(0) might be -inf or a large negative number, so the max is -31. Thus gap = -31.

At line 78, margin=10, condition gap >= -margin is -31 >= -10, which is false, so branch not taken: N.

We then define calc_part. We set re_, im_ to None.

At line 119, condition `if ire:` is true, so taken: Y. We call calc_part for the real part.

Inside calc_part for real part (ire = mpf for 0.5):
- nint = int(to_int(0.5, round_nearest)). Likely 0.
- Unpack nexpr: (n,c,p,b). For 0.5, p != 0, so is_int = (p==0) is false.
- At line 87, `if not is_int:` is true, so taken: Y.
- s = options.get('subs', False) = False.
- At line 89, `if s:` is false, so not taken: N.
- Then compute expr = Add(re(expr), -nint), evaluate with evalf, etc.
- nint does not change because no*(mpf_cmp(x,0)==no) evaluates to 0.
- Return nint (0) and INF.

At line 121, condition `if iim:` is true (since iim is fzero, truthy), so taken: Y. We call calc_part for the imaginary part.

Inside calc_part for imaginary part (iim = fzero):
- nint = int(to_int(fzero, round_nearest)) = 0.
- Unpack: fzero is (0,0,0,0), so p=0, is_int = true.
- At line 87, `if not is_int:` is false, so not taken: N.
- We skip the block, so line 89 is not encountered.
- Return nint (0) and INF.

At line 124, condition `if return_ints:` is true, so taken: Y.
We return (int(to_int(re_ or fzero)), int(to_int(im_ or fzero))) which is (0,0).

Thus the branch outcomes are:
- Line 67: ['Y']
- Line 69: []
- Line 71: []
- Line 78: ['N']
- Line 87: ['Y','N'] (first call Y, second call N)
- Line 89: ['N'] (only encountered in first call, false)
- Line 119: ['Y']
- Line 121: ['Y']
- Line 124: ['Y']
[/THOUGHT]

[ANSWER]
1 from __future__ import print_function, division
2 import math
3 import mpmath.libmp as libmp
4 from mpmath import (
5     make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec)
6 from mpmath import inf as mpmath_inf
7 from mpmath.libmp import (from_int, from_man_exp, from_rational, fhalf,
8         fnan, fnone, fone, fzero, mpf_abs, mpf_add,
9         mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt,
10         mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin,
11         mpf_sqrt, normalize, round_nearest, to_int, to_str)
12 from mpmath.libmp import bitcount as mpmath_bitcount
13 from mpmath.libmp.backend import MPZ
14 from mpmath.libmp.libmpc import _infs_nan
15 from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps
16 from mpmath.libmp.gammazeta import mpf_bernoulli
17 from .compatibility import SYMPY_INTS, range
18 from .sympify import sympify
19 from .singleton import S
20 from sympy.utilities.iterables import is_sequence
21 from sympy.functions.elementary.complexes import re, im
22 from sympy.core.numbers import Float
23 from sympy.core.numbers import Float
24 from sympy import cos, sin
25 from sympy import Abs, Add, log
26 from sympy import Float, Integer
27 from sympy.core.numbers import Infinity, NegativeInfinity, Zero
28 from sympy import Poly
29 from sympy import Float, hypersimp, lambdify
30 from sympy import Sum
31 from sympy import Float
32 from sympy.functions.combinatorial.numbers import bernoulli
33 from sympy.concrete.products import Product
34 from sympy.concrete.summations import Sum
35 from sympy.core.add import Add
36 from sympy.core.mul import Mul
37 from sympy.core.numbers import Exp1, Float, Half, ImaginaryUnit, Integer, NaN, NegativeOne, One, Pi, Rational, Zero
38 from sympy.core.power import Pow
39 from sympy.core.symbol import Dummy, Symbol
40 from sympy.functions.elementary.complexes import Abs, im, re
41 from sympy.functions.elementary.exponential import exp, log
42 from sympy.functions.elementary.integers import ceiling, floor
43 from sympy.functions.elementary.piecewise import Piecewise
44 from sympy.functions.elementary.trigonometric import atan, cos, sin
45 from sympy.integrals.integrals import Integral
46 from sympy import re as re_, im as im_
47 from sympy.core.add import Add
48 from sympy.core.add import Add
49 from sympy.core.mul import Mul
50 from sympy import cos, sin, Wild
51 from sympy import Float, Number
52 from sympy.core.expr import _mag
53 from sympy.core.compatibility import as_int
54 
55 LG10 = math.log(10, 2)
56 rnd = round_nearest
57 INF = float(mpmath_inf)
58 MINUS_INF = float(-mpmath_inf)
59 DEFAULT_MAXPREC = 333
60 evalf_table = None
61 
62 def get_integer_part(expr, no, options, return_ints=False):
63     from sympy.functions.elementary.complexes import re, im
64     assumed_size = 30
65     ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)
66 
67     if ire and iim: ## [BRANCH]taken=['Y'][/BRANCH]
68         gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)
69     elif ire: ## [BRANCH]taken=[] [/BRANCH]
70         gap = fastlog(ire) - ire_acc
71     elif iim: ## [BRANCH]taken=[] [/BRANCH]
72         gap = fastlog(iim) - iim_acc
73     else:
74         return None, None, None, None
75 
76     margin = 10
77 
78     if gap >= -margin: ## [BRANCH]taken=['N'][/BRANCH]
79         ire, iim, ire_acc, iim_acc = \
80             evalf(expr, margin + assumed_size + gap, options)
81 
82     def calc_part(expr, nexpr):
83         from sympy.core.add import Add
84         nint = int(to_int(nexpr, rnd))
85         n, c, p, b = nexpr
86         is_int = (p == 0)
87         if not is_int: ## [BRANCH]taken=['Y','N'][/BRANCH]
88             s = options.get('subs', False)
89             if s: ## [BRANCH]taken=['N'][/BRANCH]
90                 doit = True
91                 from sympy.core.compatibility import as_int
92                 for v in s.values():
93                     try:
94                         as_int(v)
95                     except ValueError:
96                         try:
97                             [as_int(i) for i in v.as_real_imag()]
98                             continue
99                         except (ValueError, AttributeError):
100                             doit = False
101                             break
102                 if doit:
103                     expr = expr.subs(s)
104 
105             expr = Add(expr, -nint, evaluate=False)
106             x, _, x_acc, _ = evalf(expr, 10, options)
107             try:
108                 check_target(expr, (x, None, x_acc, None), 3)
109             except PrecisionExhausted:
110                 if not expr.equals(0):
111                     raise PrecisionExhausted
112                 x = fzero
113             nint += int(no*(mpf_cmp(x or fzero, fzero) == no))
114         nint = from_int(nint)
115         return nint, INF
116 
117     re_, im_, re_acc, im_acc = None, None, None, None
118 
119     if ire: ## [BRANCH]taken=['Y'][/BRANCH]
120         re_, re_acc = calc_part(re(expr, evaluate=False), ire)
121     if iim: ## [BRANCH]taken=['Y'][/BRANCH]
122         im_, im_acc = calc_part(im(expr, evaluate=False), iim)
123 
124     if return_ints: ## [BRANCH]taken=['Y'][/BRANCH]
125         return int(to_int(re_ or fzero)), int(to_int(im_ or fzero))
126     return re_, im_, re_acc, im_acc
127 
[/ANSWER]