[THOUGHT]
Let me trace through the `_check_w_h` method with the given input:

Input parameters:
- `self.init = null` (None)
- `update_H = true` (True)
- `W = null` (None)
- `H = null` (None)
- `self._n_components = "auto"`
- `X.shape = (2, 2)`, so `n_samples=2, n_features=2`

Line 30: `if self.init == 'custom' and update_H:`
- `self.init = None`, so `self.init == 'custom'` is False
- Since the first part of the AND is False, the entire condition is False
- Branch is NOT taken → ['N']

Line 33: `if self._n_components == 'auto':`
- This is inside the first `if` block (line 30) which was not taken
- So this line is NOT executed

Line 37: `elif not update_H:`
- `update_H = True`, so `not update_H = False`
- Branch is NOT taken → ['N']

Line 48: `else:`
- This is inside the `elif not update_H:` block (line 37) which was not taken
- So this line is NOT executed

Line 51: `if W is not None or H is not None:`
- This is in the final `else:` block (line 50) which IS taken (since the first if at line 30 was False and the elif at line 37 was False)
- `W = None` and `H = None`, so both conditions are False
- `W is not None or H is not None` evaluates to `False or False = False`
- Branch is NOT taken → ['N']

So the branches taken are:
1. Line 30: N
2. Line 33: (not executed, so not counted)
3. Line 37: N
4. Line 48: (not executed, so not counted)
5. Line 51: N

Wait, let me reconsider. The instructions say "For each time that branch point is encountered during execution". Branch points are marked with [BRANCH] tags. Let me identify all branch points:

1. Line 30: `if self.init == 'custom' and update_H:` - BRANCH 1
2. Line 33: `if self._n_components == 'auto':` - BRANCH 2
3. Line 37: `elif not update_H:` - BRANCH 3
4. Line 48: `else:` - BRANCH 4
5. Line 51: `if W is not None or H is not None:` - BRANCH 5

Now, execution trace:
- Line 30: `self.init = None`, `update_H = True`. `None == 'custom' and True` = `False and True` = `False`. NOT taken → N
- Since line 30 is false, we skip lines 31-34 and go to line 37
- Line 33 is inside the if block, so it's NOT executed
- Line 37: `not update_H` = `not True` = `False`. NOT taken → N
- Since line 37 is false, we skip lines 38-44 and go to line 50
- Line 48 is inside the elif block, so it's NOT executed
- Line 50: `else:` is taken (since both if and elif were false)
- Line 51: `W is not None or H is not None` = `None is not None or None is not None` = `False or False` = `False`. NOT taken → N

So the branches that are actually encountered are:
1. Line 30: N
2. Line 37: N
3. Line 51: N

But wait, I need to check if line 33 is a separate branch point. Looking at the code structure, line 33 is inside the if block at line 30. Since line 30 is not taken, line 33 is never encountered.

Similarly, line 48 is in the elif block, so it's never encountered.

So the executed branches are:
1. Line 30: N
2. Line 37: N
3. Line 51: N
</THOUGHT>

[ANSWER]
1 import warnings
2 from abc import ABC
3 from numbers import Integral, Real
4 import numpy as np
5 from sklearn.base import (
6     BaseEstimator,
7     ClassNamePrefixFeaturesOutMixin,
8     TransformerMixin,
9     _fit_context,
10 )
11 from sklearn.utils._param_validation import Interval, StrOptions, validate_params
12 
13 class _BaseNMF(ClassNamePrefixFeaturesOutMixin, TransformerMixin, BaseEstimator, ABC):
14     _parameter_constraints: dict = {'n_components': [Interval(Integral, 1, None, closed='left'), None, StrOptions({'auto'})], 'init': [StrOptions({'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}), None], 'beta_loss': [StrOptions({'frobenius', 'kullback-leibler', 'itakura-saito'}), Real], 'tol': [Interval(Real, 0, None, closed='left')], 'max_iter': [Interval(Integral, 1, None, closed='left')], 'random_state': ['random_state'], 'alpha_W': [Interval(Real, 0, None, closed='left')], 'alpha_H': [Interval(Real, 0, None, closed='left'), StrOptions({'same'})], 'l1_ratio': [Interval(Real, 0, 1, closed='both')], 'verbose': ['verbose']}
15 
16     def __init__(self, n_components='auto', *, init=None, beta_loss='frobenius', tol=0.0001, max_iter=200, random_state=None, alpha_W=0.0, alpha_H='same', l1_ratio=0.0, verbose=0):
17         self.n_components = n_components
18         self.init = init
19         self.beta_loss = beta_loss
20         self.tol = tol
21         self.max_iter = max_iter
22         self.random_state = random_state
23         self.alpha_W = alpha_W
24         self.alpha_H = alpha_H
25         self.l1_ratio = l1_ratio
26         self.verbose = verbose
27 
28     def _check_w_h(self, X, W, H, update_H):
29         n_samples, n_features = X.shape
30         if self.init == 'custom' and update_H: ## [BRANCH]taken=['N'][/BRANCH]
31             _check_init(H, (self._n_components, n_features), 'NMF (input H)')
32             _check_init(W, (n_samples, self._n_components), 'NMF (input W)')
33             if self._n_components == 'auto': ## [BRANCH]taken=??[/BRANCH]
34                 self._n_components = H.shape[0]
35             if H.dtype != X.dtype or W.dtype != X.dtype:
36                 raise TypeError('H and W should have the same dtype as X. Got H.dtype = {} and W.dtype = {}.'.format(H.dtype, W.dtype))
37         elif not update_H: ## [BRANCH]taken=['N'][/BRANCH]
38             if W is not None:
39                 warnings.warn('When update_H=False, the provided initial W is not used.', RuntimeWarning)
40             _check_init(H, (self._n_components, n_features), 'NMF (input H)')
41             if self._n_components == 'auto':
42                 self._n_components = H.shape[0]
43             if H.dtype != X.dtype:
44                 raise TypeError('H should have the same dtype as X. Got H.dtype = {}.'.format(H.dtype))
45             if self.solver == 'mu':
46                 avg = np.sqrt(X.mean() / self._n_components)
47                 W = np.full((n_samples, self._n_components), avg, dtype=X.dtype)
48             else: ## [BRANCH]taken=??[/BRANCH]
49                 W = np.zeros((n_samples, self._n_components), dtype=X.dtype)
50         else:
51             if W is not None or H is not None: ## [BRANCH]taken=['N'][/BRANCH]
52                 warnings.warn("When init!='custom', provided W or H are ignored. Set  init='custom' to use them as initialization.", RuntimeWarning)
53             if self._n_components == 'auto':
54                 self._n_components = X.shape[1]
55             W, H = _initialize_nmf(X, self._n_components, init=self.init, random_state=self.random_state)
56         return (W, H)
[/ANSWER]