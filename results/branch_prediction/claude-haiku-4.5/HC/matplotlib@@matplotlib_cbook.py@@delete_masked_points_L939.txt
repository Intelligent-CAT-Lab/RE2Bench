[THOUGHT]
Let me trace through the code step by step with the given input.

The input has:
- args = [array([0., 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45]), array([0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95]), None]

Line 4: `if not len(args):` 
- len(args) = 3, so not 3 = False → Branch NOT taken → ['N']

Line 6: `if is_scalar_or_string(args[0]):`
- args[0] is an array, not a scalar or string → Branch NOT taken → ['N']

Line 8: nrecs = len(args[0]) = 10

Line 11-19: Loop through enumerate(args):
- i=0, x=array([0., 0.05, ...])
  - Line 12: `if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:`
    - x is not a string: True
    - np.iterable(x): True
    - len(x) == 10: True
    - All conditions true → Branch TAKEN → ['Y']
  - Line 14: `if isinstance(x, np.ma.MaskedArray):`
    - x is a regular numpy array, not MaskedArray → Branch NOT taken → ['N']
  - Line 17: else branch is taken (implicit)
    - x = np.asarray(x) converts it (though already array)
  - Line 13: seqlist[0] = True

- i=1, x=array([0.5, 0.55, ...])
  - Line 12: Same logic, all conditions true → Branch TAKEN → ['Y']
  - Line 14: Same, not MaskedArray → Branch NOT taken → ['N']
  - Line 17: else branch taken
  - Line 13: seqlist[1] = True

- i=2, x=None
  - Line 12: `if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:`
    - x is not a string: True
    - np.iterable(None): False (None is not iterable)
    - Short-circuit evaluation → Branch NOT taken → ['N']

Line 21-35: Loop through enumerate(margs):
margs = [array([0., 0.05, ...]), array([0.5, 0.55, ...]), None]

- i=0, x=array([0., 0.05, ...])
  - Line 22: `if seqlist[i]:` → seqlist[0] = True → Branch TAKEN → ['Y']
  - Line 23: `if x.ndim > 1:` → x.ndim = 1 → 1 > 1 = False → Branch NOT taken → ['N']
  - Line 25: `if isinstance(x, np.ma.MaskedArray):` → False (regular array)
  - Line 28: else branch taken (implicit)
  - xd = x
  - Line 30-35: try block
    - Line 31: mask = np.isfinite(xd) → returns array of boolean values
    - Line 32: `if isinstance(mask, np.ndarray):` → mask is ndarray → Branch TAKEN → ['Y']
    - Line 33: masks.append(mask)

- i=1, x=array([0.5, 0.55, ...])
  - Line 22: `if seqlist[i]:` → seqlist[1] = True → Branch TAKEN → ['Y']
  - Line 23: `if x.ndim > 1:` → x.ndim = 1 → False → Branch NOT taken → ['N']
  - Line 25: `if isinstance(x, np.ma.MaskedArray):` → False
  - Line 28: else branch taken (implicit)
  - xd = x
  - Line 31: mask = np.isfinite(xd) → returns array of boolean values
  - Line 32: `if isinstance(mask, np.ndarray):` → True → Branch TAKEN → ['Y']
  - Line 33: masks.append(mask)

- i=2, x=None
  - Line 22: `if seqlist[i]:` → seqlist[2] = False → Branch NOT taken → ['N']

Line 36: `if len(masks):` 
- masks now contains two boolean arrays → len(masks) = 2 → True → Branch TAKEN → ['Y']

Line 37-42: 
- mask = np.logical_and.reduce(masks) → combines the two boolean arrays
- igood = mask.nonzero()[0] → gets indices where mask is True
- Line 39: `if len(igood) < nrecs:` → We need to determine if some elements are masked out
  - Both input arrays contain finite values, so np.isfinite returns all True
  - mask = True & True = all True
  - len(igood) = 10, nrecs = 10 → 10 < 10 = False → Branch NOT taken → ['N']

Line 43-45: Loop through enumerate(margs):
- i=0, x=array([0., 0.05, ...])
  - Line 44: `if seqlist[i] and isinstance(x, np.ma.MaskedArray):` 
    - seqlist[0] = True
    - isinstance(x, np.ma.MaskedArray) = False
    - True and False = False → Branch NOT taken → ['N']

- i=1, x=array([0.5, 0.55, ...])
  - Line 44: `if seqlist[i] and isinstance(x, np.ma.MaskedArray):`
    - seqlist[1] = True
    - isinstance(x, np.ma.MaskedArray) = False
    - True and False = False → Branch NOT taken → ['N']

- i=2, x=None
  - Line 44: `if seqlist[i] and isinstance(x, np.ma.MaskedArray):`
    - seqlist[2] = False
    - False and ... = False → Branch NOT taken → ['N']

Summary of branches:
Line 4: ['N']
Line 6: ['N']
Line 12: ['Y', 'Y', 'N']
Line 14: ['N', 'N']
Line 22: ['Y', 'Y', 'N']
Line 23: ['N', 'N']
Line 32: ['Y', 'Y']
Line 36: ['Y']
Line 39: ['N']
Line 44: ['N', 'N', 'N']
</THOUGHT>

[ANSWER]
1 import numpy as np
2 
3 def delete_masked_points(*args):
4     if not len(args): ## [BRANCH]taken=['N'][/BRANCH]
5         return ()
6     if is_scalar_or_string(args[0]): ## [BRANCH]taken=['N'][/BRANCH]
7         raise ValueError("First argument must be a sequence")
8     nrecs = len(args[0])
9     margs = []
10     seqlist = [False] * len(args)
11     for i, x in enumerate(args):
12         if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs: ## [BRANCH]taken=['Y', 'Y', 'N'][/BRANCH]
13             seqlist[i] = True
14             if isinstance(x, np.ma.MaskedArray): ## [BRANCH]taken=['N', 'N'][/BRANCH]
15                 if x.ndim > 1: ## [BRANCH]taken=[][/BRANCH]
16                     raise ValueError("Masked arrays must be 1-D")
17             else: ## [BRANCH]taken=[][/BRANCH]
18                 x = np.asarray(x)
19         margs.append(x)
20     masks = []
21     for i, x in enumerate(margs):
22         if seqlist[i]: ## [BRANCH]taken=['Y', 'Y', 'N'][/BRANCH]
23             if x.ndim > 1:## [BRANCH]taken=['N', 'N'][/BRANCH]
24                 continue
25             if isinstance(x, np.ma.MaskedArray):
26                 masks.append(~np.ma.getmaskarray(x))
27                 xd = x.data
28             else:
29                 xd = x
30             try:
31                 mask = np.isfinite(xd)
32                 if isinstance(mask, np.ndarray): ## [BRANCH]taken=['Y', 'Y'][/BRANCH]
33                     masks.append(mask)
34             except Exception:
35                 pass
36     if len(masks): ## [BRANCH]taken=['Y'][/BRANCH]
37         mask = np.logical_and.reduce(masks)
38         igood = mask.nonzero()[0]
39         if len(igood) < nrecs: ## [BRANCH]taken=['N'][/BRANCH]
40             for i, x in enumerate(margs):
41                 if seqlist[i]:
42                     margs[i] = x[igood]
43     for i, x in enumerate(margs):
44         if seqlist[i] and isinstance(x, np.ma.MaskedArray): ## [BRANCH]taken=['N', 'N', 'N'][/BRANCH]
45             margs[i] = x.filled()
46     return margs
[/ANSWER]