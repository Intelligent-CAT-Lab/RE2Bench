[THOUGHT]
For n = 3, reversed(range(3)) yields i = 2, 1, 0 in that order.
- i = 2: 3 % 2 == 1 -> condition false -> branch not taken.
- i = 1: 3 % 1 == 0 -> condition true -> branch taken and function returns 1.
The loop stops before reaching i = 0.
[/THOUGHT]

[ANSWER]
1 
2 
3 def largest_divisor(n: int) -> int:
4 
5     for i in reversed(range(n)):
6         if n % i == 0: ## [BRANCH]taken=[N,Y][/BRANCH]
7             return i
8 
[/ANSWER]