[THOUGHT]
We treat the first two inputs as numpy arrays (length 10) and the third as None.

- At line 4, len(args) == 3 → not len(args) is False → ['N'].
- At line 6, first arg is an array, not a scalar/string → is_scalar_or_string(...) is False → ['N'].
- Loop (line 11-19) runs 3 times:
  - i=0: x is ndarray, iterable, len == nrecs → condition True ['Y']; it's not a MaskedArray → isinstance(...) False ['N'], so else branch at line 17 runs ['Y'].
  - i=1: same as i=0 → line12 True ['Y'], line14 False ['N'], line17 True ['Y'].
  - i=2: x is None → condition False ['N']; no masked checks.
- The masked-array-specific check at line 15 (x.ndim > 1) is only reached inside the MaskedArray branch which never occurs → [].
- Second loop over margs (3 items):
  - i=0: seqlist True → line22 ['Y']; x.ndim == 1 so line23 (x.ndim > 1) is False ['N']; mask computed is an ndarray → line32 ['Y'].
  - i=1: same as i=0 → line22 ['Y'], line23 ['N'], line32 ['Y'].
  - i=2: seqlist False → line22 ['N'].
- masks ends up non-empty (2 masks) → line36 ['Y'].
- igood length equals nrecs → line39 condition False ['N'] (no trimming).
- Final loop (line 43-45) runs 3 times; none are MaskedArray instances, so line44 is False each time → ['N','N','N'].

These produce the following branch outcome lists.
[/THOUGHT]

[ANSWER]
1 import numpy as np
2 
3 def delete_masked_points(*args):
4     if not len(args): ## [BRANCH]taken=['N'][/BRANCH]
5         return ()
6     if is_scalar_or_string(args[0]): ## [BRANCH]taken=['N'][/BRANCH]
7         raise ValueError("First argument must be a sequence")
8     nrecs = len(args[0])
9     margs = []
10     seqlist = [False] * len(args)
11     for i, x in enumerate(args):
12         if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs: ## [BRANCH]taken=['Y', 'Y', 'N'][/BRANCH]
13             seqlist[i] = True
14             if isinstance(x, np.ma.MaskedArray): ## [BRANCH]taken=['N', 'N'][/BRANCH]
15                 if x.ndim > 1: ## [BRANCH]taken=[][/BRANCH]
16                     raise ValueError("Masked arrays must be 1-D")
17             else: ## [BRANCH]taken=['Y', 'Y'][/BRANCH]
18                 x = np.asarray(x)
19         margs.append(x)
20     masks = []
21     for i, x in enumerate(margs):
22         if seqlist[i]: ## [BRANCH]taken=['Y', 'Y', 'N'][/BRANCH]
23             if x.ndim > 1:## [BRANCH]taken=['N', 'N'][/BRANCH]
24                 continue
25             if isinstance(x, np.ma.MaskedArray):
26                 masks.append(~np.ma.getmaskarray(x))
27                 xd = x.data
28             else:
29                 xd = x
30             try:
31                 mask = np.isfinite(xd)
32                 if isinstance(mask, np.ndarray): ## [BRANCH]taken=['Y', 'Y'][/BRANCH]
33                     masks.append(mask)
34             except Exception:
35                 pass
36     if len(masks): ## [BRANCH]taken=['Y'][/BRANCH]
37         mask = np.logical_and.reduce(masks)
38         igood = mask.nonzero()[0]
39         if len(igood) < nrecs: ## [BRANCH]taken=['N'][/BRANCH]
40             for i, x in enumerate(margs):
41                 if seqlist[i]:
42                     margs[i] = x[igood]
43     for i, x in enumerate(margs):
44         if seqlist[i] and isinstance(x, np.ma.MaskedArray): ## [BRANCH]taken=['N', 'N', 'N'][/BRANCH]
45             margs[i] = x.filled()
46     return margs
47