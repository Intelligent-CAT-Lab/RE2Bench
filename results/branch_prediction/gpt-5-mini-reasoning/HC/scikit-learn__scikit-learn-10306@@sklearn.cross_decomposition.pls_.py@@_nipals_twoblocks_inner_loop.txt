[THOUGHT]
We run with mode="B", norm_y_weights=True. X_pinv and Y_pinv start as None so their "is None" branches are taken on the first iteration and not taken on subsequent iterations. The x_weights norm checks against machine eps are false (norms are much larger than eps) on the iterations, so those branches are not taken. norm_y_weights is True, so that branch is taken each time it's reached. The convergence check (squared change < tol or Y.shape[1] == 1) is false on the first iteration (change > tol, Y has 2 columns), and becomes true on the second iteration (algorithm converges), so the loop breaks then. The max-iteration check is only reached on iterations where convergence was false; it is checked once (first iteration) and is False.
So the per-encounter outcomes are:
- line 24 (X_pinv is None): ['Y','N']
- line 29 (x_weights norm < eps): ['N','N']
- line 34 (Y_pinv is None): ['Y','N']
- line 39 (norm_y_weights): ['Y','Y']
- line 43 (convergence or Y.shape[1] == 1): ['N','Y']
- line 45 (ite == max_iter): ['N']
[/THOUGHT]

[ANSWER]
1 import warnings
2 from abc import ABCMeta, abstractmethod
3 import numpy as np
4 from scipy.linalg import pinv2, svd
5 from scipy.sparse.linalg import svds
6 from ..base import BaseEstimator, RegressorMixin, TransformerMixin
7 from ..utils import check_array, check_consistent_length
8 from ..utils.extmath import svd_flip
9 from ..utils.validation import check_is_fitted, FLOAT_DTYPES
10 from ..exceptions import ConvergenceWarning
11 from ..externals import six
12 
13 __all__ = ['PLSCanonical', 'PLSRegression', 'PLSSVD']
14 
15 def _nipals_twoblocks_inner_loop(X, Y, mode="A", max_iter=500, tol=1e-06,
16                                  norm_y_weights=False):
17     y_score = Y[:, [0]]
18     x_weights_old = 0
19     ite = 1
20     X_pinv = Y_pinv = None
21     eps = np.finfo(X.dtype).eps
22     while True:
23         if mode == "B":
24             if X_pinv is None: ## [BRANCH]taken=['Y','N'][/BRANCH]
25                 X_pinv = pinv2(X, check_finite=False)
26             x_weights = np.dot(X_pinv, y_score)
27         else:
28             x_weights = np.dot(X.T, y_score) / np.dot(y_score.T, y_score)
29         if np.dot(x_weights.T, x_weights) < eps: ## [BRANCH]taken=['N','N'][/BRANCH]
30             x_weights += eps
31         x_weights /= np.sqrt(np.dot(x_weights.T, x_weights)) + eps
32         x_score = np.dot(X, x_weights)
33         if mode == "B":
34             if Y_pinv is None: ## [BRANCH]taken=['Y','N'][/BRANCH]
35                 Y_pinv = pinv2(Y, check_finite=False)
36             y_weights = np.dot(Y_pinv, x_score)
37         else:
38             y_weights = np.dot(Y.T, x_score) / np.dot(x_score.T, x_score)
39         if norm_y_weights: ## [BRANCH]taken=['Y','Y'][/BRANCH]
40             y_weights /= np.sqrt(np.dot(y_weights.T, y_weights)) + eps
41         y_score = np.dot(Y, y_weights) / (np.dot(y_weights.T, y_weights) + eps)
42         x_weights_diff = x_weights - x_weights_old
43         if np.dot(x_weights_diff.T, x_weights_diff) < tol or Y.shape[1] == 1: ## [BRANCH]taken=['N','Y'][/BRANCH]
44             break
45         if ite == max_iter: ## [BRANCH]taken=['N'][/BRANCH]
46             warnings.warn('Maximum number of iterations reached',
47                           ConvergenceWarning)
48             break
49         x_weights_old = x_weights
50         ite += 1
51     return x_weights, y_weights, ite
52 [/ANSWER]