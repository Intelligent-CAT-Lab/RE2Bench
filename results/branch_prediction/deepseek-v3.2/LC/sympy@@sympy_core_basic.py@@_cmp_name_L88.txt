[THOUGHT]
We need to trace through `_cmp_name(x, y)` with the given input:
- `x = <class 'sympy.core.numbers.ImaginaryUnit'>`
- `y = <class 'sympy.core.numbers.Pi'>`

The function compares two types by name and ordering.

Step 1: Get names.
- `n1 = x.__name__`. For ImaginaryUnit class, likely `'ImaginaryUnit'`.
- `n2 = y.__name__`. For Pi class, likely `'Pi'`.
So `n1 == n2`? `'ImaginaryUnit' != 'Pi'` → branch not taken → `'N'`.

Step 2: Check `if not issubclass(y, Basic):`.
`Basic` is presumably a base class in SymPy (maybe sympy.core.basic.Basic).
Both `ImaginaryUnit` and `Pi` are subclasses of `Basic`. So `issubclass(y, Basic)` is True → `not issubclass(y, Basic)` is False → branch not taken → `'N'`.

Step 3: We have `ordering_of_classes` undefined in provided snippet, but we know it's a list of class names in order for sorting. Need to see if `'ImaginaryUnit'` and `'Pi'` are in that list.

Looking up SymPy's ordering: For numbers, typical ordering: `Zero`, `One`, `Half`, `Rational`, `Integer`, `NegativeOne`, `ImaginaryUnit`, `Pi`, `Exp1`, etc. Actually, from SymPy source, `ordering_of_classes` might be defined elsewhere. But we can reason: `i1` and `i2` will be indices if found, else `UNKNOWN`.

Let's assume `ordering_of_classes` contains `'ImaginaryUnit'` and `'Pi'`. Then:
- `i1 = ordering_of_classes.index('ImaginaryUnit')` → some integer.
- `i2 = ordering_of_classes.index('Pi')` → some integer.
Both are not `UNKNOWN` → `i1 == UNKNOWN and i2 == UNKNOWN` is False → branch not taken → `'N'`.

If one of them not in list? But both are standard SymPy numeric classes, so likely in list. So branch `i1 == UNKNOWN and i2 == UNKNOWN` is False.

Thus branch outcomes:
- Line 4: `['N']`
- Line 7: `['N']`
- Line 19: `['N']`

Each branch encountered once, so single char lists.
[/THOUGHT]

[ANSWER]
1 def _cmp_name(x: type, y: type) -> int:
2     n1 = x.__name__
3     n2 = y.__name__
4     if n1 == n2: ## [BRANCH]taken=[N][/BRANCH]
5         return 0
6 
7     if not issubclass(y, Basic): ## [BRANCH]taken=[N][/BRANCH]
8         return -1
9 
10     UNKNOWN = len(ordering_of_classes) + 1
11     try:
12         i1 = ordering_of_classes.index(n1)
13     except ValueError:
14         i1 = UNKNOWN
15     try:
16         i2 = ordering_of_classes.index(n2)
17     except ValueError:
18         i2 = UNKNOWN
19     if i1 == UNKNOWN and i2 == UNKNOWN: ## [BRANCH]taken=[N][/BRANCH]
20         return (n1 > n2) - (n1 < n2)
21     return (i1 > i2) - (i1 < i2)
22 
[/ANSWER]