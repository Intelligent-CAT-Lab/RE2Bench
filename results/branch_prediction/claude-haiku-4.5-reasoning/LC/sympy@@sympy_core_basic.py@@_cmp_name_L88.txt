[THOUGHT]
Let me trace through the code step by step with the given inputs:

**Input Analysis:**
- x = `<class 'sympy.core.numbers.ImaginaryUnit'>`
- y = `<class 'sympy.core.numbers.Pi'>`

**Line 2-3: Extract names**
- n1 = x.__name__ = "ImaginaryUnit"
- n2 = y.__name__ = "Pi"

**Branch at Line 4: `if n1 == n2:`**
- Checking: "ImaginaryUnit" == "Pi"
- This is False (different names)
- Branch NOT taken → [N]

**Branch at Line 7: `if not issubclass(y, Basic):`**
- y is the Pi class from sympy.core.numbers
- In SymPy, Pi inherits from Basic through the expression hierarchy
- Therefore: issubclass(y, Basic) = True
- Therefore: not issubclass(y, Basic) = False
- Branch NOT taken → [N]

**Lines 11-18: Lookups in ordering_of_classes**
- The code attempts to find "ImaginaryUnit" and "Pi" in ordering_of_classes
- ordering_of_classes typically contains core SymPy class names like 'Add', 'Mul', 'Symbol', 'Integer', etc.
- ImaginaryUnit and Pi are specialized number classes that would not be in this core ordering list
- Both lookups would raise ValueError and catch it
- i1 = UNKNOWN, i2 = UNKNOWN

**Branch at Line 19: `if i1 == UNKNOWN and i2 == UNKNOWN:`**
- Both i1 and i2 are UNKNOWN
- Condition evaluates to: True and True = True
- Branch IS taken → [Y]
</THOUGHT>

[ANSWER]
1 def _cmp_name(x: type, y: type) -> int:
2     n1 = x.__name__
3     n2 = y.__name__
4     if n1 == n2: ## [BRANCH]taken=[N][/BRANCH]
5         return 0
6 
7     if not issubclass(y, Basic): ## [BRANCH]taken=[N][/BRANCH]
8         return -1
9 
10     UNKNOWN = len(ordering_of_classes) + 1
11     try:
12         i1 = ordering_of_classes.index(n1)
13     except ValueError:
14         i1 = UNKNOWN
15     try:
16         i2 = ordering_of_classes.index(n2)
17     except ValueError:
18         i2 = UNKNOWN
19     if i1 == UNKNOWN and i2 == UNKNOWN: ## [BRANCH]taken=[Y][/BRANCH]
20         return (n1 > n2) - (n1 < n2)
21     return (i1 > i2) - (i1 < i2)
[/ANSWER]