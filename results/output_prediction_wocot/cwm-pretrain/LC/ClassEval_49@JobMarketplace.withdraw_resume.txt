[/PYTHON]
import re
import sys
import time
from collections import defaultdict, deque, OrderedDict, Counter
from functools import cache, lru_cache, reduce
from itertools import accumulate, combinations, permutations, product
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
from typing import List, Set, Dict, Tuple, Optional, Union, Callable, Iterator, TypeVar

# {{ Topological Sort }}
def topological_sort(deps: Dict[str, List[str]]) -> List[str]:
    indegree = {node: 0 for node in deps}
    for node in deps:
        for neighbor in deps[node]:
            indegree[neighbor] += 1

    queue = deque([node for node in indegree if indegree[node] == 0])
    order = []
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in deps[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)

    if len(order) != len(indegree):
        raise ValueError("Graph has cycles")
    
    return order
# {{ Topological Sort }}

# {{ DFS }}
def dfs(node: str, deps: Dict[str, List[str]], visited: Set[str], order: List[str]) -> None:
    visited.add(node)
    for neighbor in deps[node]:
        if neighbor not in visited:
            dfs(neighbor, deps, visited, order)
    order.append(node)

def topological_sort_dfs(deps: Dict[str, List[str]]) -> List[str]:
    visited = set()
    order = []
    for node in deps:
        if node not in visited:
            dfs(node, deps, visited, order)
    order.reverse()
    return order
# {{ DFS }}

# {{ Kruskal's Algorithm }}
class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u: int) -> int:
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u: int, v: int) -> bool:
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1
            return True
        return False
# {{ Kruskal's Algorithm }}

# {{ Dijkstra's Algorithm }}
def dijkstra(n: int, edges: List[Tuple[int, int, int]]) -> List[int]:
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((v, w))

    dist = [float('inf')] * n
    dist[0] = 0
    queue = [(0, 0)]
    while queue:
        d, u = heappop(queue)
        if d > dist[u]:
            continue
        for v, w in graph[u]:
            if d + w < dist[v]:
                dist[v] = d + w
                heappush(queue, (d + w, v))
    
    return dist
# {{ Dijkstra's Algorithm }}

# {{ Bellman-Ford Algorithm }}
def bellman_ford(n: int, edges: List[Tuple[int, int, int]]) -> List[int]:
    dist = [float('inf')] * n
    dist[0] = 0
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            raise ValueError("Graph contains negative weight cycle")
    return dist
# {{ Bellman-Ford Algorithm }}

# {{ Floyd-Warshall Algorithm }}
def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]:
    dist = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        dist[i][i] = 0
    for u, v, w in edges:
        dist[u][v] = min(dist[u][v], w)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist
# {{ Floyd-Warshall Algorithm }}

# {{ N-Queens Problem }}
def solve_n_queens(n: int) -> List[List[str]]:
    def is_valid(board: List[List[bool]], row: int, col: int) -> bool:
        for i in range(row):
            if board[i][col]:
                return False
            if col - (row - i) >= 0 and board[i][col - (row - i)]:
                return False
            if col + (row - i) < n and board[i][col + (row - i)]:
                return False
        return True

    def backtrack(board: List[List[bool]], row: int) -> List[List[str]]:
        if row == n:
            res = []
            for i in range(n):
                row_str = []
                for j in range(n):
                    if board[i][j]:
                        row_str.append('Q')
                    else:
                        row_str.append('.')
                res.append(''.join(row_str))
            return [res]
        solutions = []
        for col in range(n):
            if is_valid(board, row, col):
                board[row][col] = True
                solutions.extend(backtrack(board, row + 
def topological_sort(deps: Dict[str, List[str]]) -> List[str]:
    """
    Args:
    deps: Dict[str, List[str]] - A dictionary representing the directed graph.
        The keys are nodes, and the values are lists of nodes that the key node depends on.

    Returns:
    List[str] - A list of nodes in topological order.

    Raises:
    ValueError: If the graph has cycles.

    Time Complexity: O(V + E)
    Space Complexity: O(V + E)
    """
    indegree = {node: 0 for node in deps}
    for node in deps:
        for neighbor in deps[node]:
            indegree[neighbor] += 1

    queue = deque([node for node in indegree if indegree[node] == 0])
    order = []
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in deps[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)

    if len(order) != len(indegree):
        raise ValueError("Graph has cycles")
    
    return order

def dfs(node: str, deps: Dict[str, List[str]], visited: Set[str], order: List[str]) -> None:
    """
    Args:
    node: str - The current node.
    deps: Dict[str, List[str]] - A dictionary representing the directed graph.
        The keys are nodes, and the values are lists of nodes that the key node depends on.
    visited: Set[str] - A set of visited nodes.
    order: List[str] - A list to store the topological order.

    Returns:
    None
    """
    visited.add(node)
    for neighbor in deps[node]:
        if neighbor not in visited:
            dfs(neighbor, deps, visited, order)
    order.append(node)

def topological_sort_dfs(deps: Dict[str, List[str]]) -> List[str]:
    """
    Args:
    deps: Dict[str, List[str]] - A dictionary representing the directed graph.
        The keys are nodes, and the values are lists of nodes that the key node depends on.

    Returns:
    List[str] - A list of nodes in topological order.

    Time Complexity: O(V + E)
    Space Complexity: O(V + E)
    """
    visited = set()
    order = []
    for node in deps:
        if node not in visited:
            dfs(node, deps, visited, order)
    order.reverse()
    return order

class UnionFind:
    def __init__(self, n: int):
        """
        Args:
        n: int - The number of nodes.

        Time Complexity: O(n)
        Space Complexity: O(n)
        """
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u: int) -> int:
        """
        Args:
        u: int - The node to find.

        Returns:
        int - The root of the node.

        Time Complexity: O(α(n))
        Space Complexity: O(1)
        """
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u: int, v: int) -> bool:
        """
        Args:
        u: int - The first node.
        v: int - The second node.

        Returns:
        bool - True if the nodes are connected, False otherwise.

        Time Complexity: O(α(n))
        Space Complexity: O(1)
        """
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1
            return True
        return False

class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        """
        Args:
        times: List[List[int]] - A list of lists representing the edges of the network.
            Each list contains three integers: u, v, and w, representing the source node,
            the destination node, and the time it takes to travel from the source node to
            the destination node.
        n: int - The number of nodes in the network.
        k: int - The starting node.

        Returns:
        int - The time it takes for all the n nodes to receive the signal from node k.

        Time Complexity: O(V + ElogV)
        Space Complexity: O(V + E)
        """
        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))

        dist = [float('inf')] * (n + 1)
        dist[k] = 0
        queue = [(0, k)]
        while queue:
            d, u = heappop(queue)
            if d > dist[u]:
                continue
            for v, w in graph[u]:
                if d + w < dist[v]:
                    dist[v] = d + w
                    heappush(queue, (d + w, v))
        
        max_time = max(dist[1:])
        return max_time if max_time < float('inf') else -1

def bellman_ford(n: int, edges: List[Tuple[int, int, int]]) -> List[int]:
    dist = [float('inf')] * n
    dist[0] = 0
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            raise ValueError("Graph contains negative weight cycle")
    return dist

def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]:
    dist = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        dist[i][i] = 0
    for u, v, w in edges:
        dist[u][v] = min(dist[u][v], w)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist

def solve_n_queens(n: int) -> List[List[str]]:
    def is_valid(board: List[List[bool]], row: int, col: int) -> bool:
        for i in range(row):
            if board[i][col]:
                return False
            if col - (row - i) >= 0 and board[i][col - (row - i)]:
                return False
            if col + (row - i) < n and board[i][col + (row - i)]:
                return False
        return True

    def backtrack(board: List[List[bool]], row: int) -> List[List[str]]:
        if row == n:
            res = []
            for i in range(n):
                row_str = []
                for j in range(n):
                    if board[i][j]:
                        row_str.append('Q')
                    else:
                        row_str.append('.')
                res.append(''.join(row_str))
            return [res]
        solutions = []
        for col in range(n):
            if is_valid(board, row, col):
                board[row][col] = True
                solutions.extend(backtrack(board, row + 1))
                board[row][col] = False
        return solutions

    board = [[False] * n for _ in range(n)]
    return backtrack(board, 0)

class Solution:
    def is_valid(self, board: List[List[bool]], row: int, col: int) -> bool:
        n = len(board)
        for i in range(row):
            if board[i][col]:
                return False
            if col - (row - i) >= 0 and board[i][col - (row - i)]:
                return False
            if col + (row - i) < n and board[i][col + (row - i)]:
                return False
        return True

    def backtrack(self, board: List[List[bool]], row: int) -> List[List[str]]:
        n = len(board)
        if row == n:
            res = []
            for i in range(n):
                row_str = []
                for j in range(n):
                    if board[i][j]:
                        row_str.append('Q')
                    else:
                        row_str.append('.')
                res.append(''.join(row_str))
            return [res]
        solutions = []
        for col in range(n):
            if self.is_valid(board, row, col):
                board[row][col] = True
                solutions.extend(self.backtrack(board, row + 1))
                board[row][col] = False
        return solutions

    def solve_n_queens(self, n: int) -> List[List[str]]:
        board = [[False] * n for _ in range(n)]
        return self.backtrack(board, 0)

class Solution:
    def solve_n_queens(self, n: int) -> List[List[str]]:
        def is_valid(board: List[List[bool]], row: int, col: int) -> bool:
            for i in range(row):
                if board[i][col]:
                    return False
                if col - (row - i) >= 0 and board[i][col - (row - i)]:
                    return False
                if col + (row - i) < n and board[i][col + (row - i)]:
                    return False
            return True

        def backtrack(board: List[List[bool]], row: int) -> List[List[str]]:
            if row == n:
                res = []
                for i in range(n):
                    row_str = []
                    for j in range(n):
                        if board[i][j]:
                            row_str.append('Q')
                        else:
                            row_str.append('.')
                    res.append(''.join(row_str))
                return [res]
            solutions = []
            for col in range(n):
                if is_valid(board, row, col):
                    board[row][col] = True
                    solutions.extend(backtrack(board, row + 1))
                    board[row][col] = False
            return solutions

        board = [[False] * n for _ in range(n)]
        return backtrack(board, 0)

class Solution:
    def solve_n_queens(self, n: int) -> List[List[str]]:
        def is_valid(board: List[List[bool]], row: int, col: int) -> bool:
            for i in range(row):
                if board[i][col]:
                    return False
                if col - (row - i) >= 0 and board[i][col - (row - i)]:
                    return False
                if col + (row - i) < n and board[i][col + (row - i)]:
                    return False
            return True

        def backtrack(board: List[List[bool]], row: int) -> List[List[str]]:
            if row == n:
                res = []
                for i in range(n):
                    row_str = []
                    for j in range(n):
                        if board[i][j]:
                            row_str.append('Q')
                        else:
                            row_str.append('.')
                    res.append(''.join(row_str))
                return [res]
            solutions = []
            for col in range(n):
                if is_valid(board, row, col):
                    board[row][col] = True
                    solutions.extend(backtrack(board, row + 1))
                    board[row][col] = False
            return solutions

        board = [[False] * n for _ in range(n)]
        return backtrack(board, 0)

class Solution:
    def solve_n_queens(self, n: int) -> List[List[str]]:
        def is_valid(board: List[List[bool]], row: int, col: int) -> bool:
            for i in range(row):
                if board[i][col]:
                    return False
                if col - (row - i) >= 0 and board[i][col - (row - i)]:
                    return False
                if col + (row - i) < n and board[i][col + (row - i)]:
                    return False
            return True

        def backtrack(board: List[List[bool]], row: int) -> List[List[str]]:
            if row == n:
                res = []
                for i in range(n):
                    row_str = []
                    for j in range(n):
                        if board[i][j]:
                            row_str.append('Q')
                        else:
                            row_str.append('.')
                    res.append(''.join(row_str))
                return [res]
            solutions = []
            for col in range(n):
                if is_valid(board, row, col):
                    board[row][col] = True
                    solutions.extend(backtrack(board, row + 1))
                    board[row][col] = False
            return solutions

        board = [[False] * n for _ in