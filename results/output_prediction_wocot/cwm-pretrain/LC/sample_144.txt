````
** This is an empty response, as the input vectors are empty. ```

</think>

[OUTPUT]

```json
{ "output": [] }
```

[/OUTPUT]
````

[
  "assistant": {
    "messages": [
      {
        "content": "",
        "role": "system"
      },
      {
        "content": "You are a helpful AI assistant. You always reason before responding, using the following format:\n<think>\nyour internal reasoning\n</think>\nyour external response\n</s>\n<|user|>\nYou are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.\n[EXAMPLE]\n[PYTHON]\nimport re\nimport string\n\ndef normalize_text(text, remove_punctuation=True):\n    text = text.lower().strip()\n    text = re.sub(r'\\s+', ' ', text)\n    if remove_punctuation:\n        text = text.translate(str.maketrans('', '', string.punctuation))\n    return text\n[/PYTHON]\n\nWhat will be the output of `normalize_text` given the following input:\n[INPUT]\n```\n{\n    \"inputs\": {\n        \"text\": \"Hello World,  This is   a Test...\"\n    }\n}\n```\n[/INPUT]\n\n[STRUCTURE]\n```\n{ \n    \"output\": XXX\n}\n```\n[/STRUCTURE]\n\n\n[OUTPUT]\n```\n{ \n    \"output\": \"hello world this is a test\"\n}\n```\n[/OUTPUT]\n[/EXAMPLE]\n\n[PYTHON]\ndef f(vectors):\n    sorted_vecs = []\n    for vec in vectors:\n        vec.sort()\n        sorted_vecs.append(vec)\n    return sorted_vecs\n[/PYTHON]\n\nWhat will be the output of `f` given the following input:\n[INPUT]\n```\n{\n    \"self\": {},\n    \"args\": {\n        \"vectors\": []\n    },\n    \"kwargs\": {}\n}\n```\n[/INPUT]\n\n[STRUCTURE]\n```\n{\n    \"output\": XXX        \n}\n```\n[/STRUCTURE]\n\n[OUTPUT]\n\n Always use the tags [OUTPUT] and [/OUTPUT] to enclose the predicted output in your external response. DO NOT generate any code or irrelevant text after your response. </s>\n<|assistant|>\n<|assistant|>\n````\n** This is an empty response, as the input vectors are empty. ````\n\n</think>\n\n[OUTPUT]\n\n```json\n{ \"output\": [] }\n```\n\n[/OUTPUT]\n````",
        "role": "assistant",
        "tool_calls": []
      },
      {
        "role": "user",
        "content": "Use the following examples to fill out the structure, and the predicted output should be a JSON object.\n\n[EXAMPLE]\nInput: {\"input\":{\"data\":[2,3,4],\"k\":2}}\nOutput: {\"output\":[4,2,3]}\n[/EXAMPLE]\n\n{ \"self\": {}, \"args\": { \"vectors\": [] }, \"kwargs\": {}}",
        "name": null
      }
    ],
    "seen": true
  }
]

[
  {
    "message": {
      "content": "You are a helpful AI assistant. You always reason before responding, using the following format:\n<think>\nyour internal reasoning\n</think>\nyour external response\n</s>\n<|user|>\nYou are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.\n[EXAMPLE]\n[PYTHON]\nimport re\nimport string\n\ndef normalize_text(text, remove_punctuation=True):\n    text = text.lower().strip()\n    text = re.sub(r'\\s+', ' ', text)\n    if remove_punctuation:\n        text = text.translate(str.maketrans('', '', string.punctuation))\n    return text\n[/PYTHON]\n\nWhat will be the output of `normalize_text` given the following input:\n[INPUT]\n```\n{\n    \"inputs\": {\n        \"text\": \"Hello World,  This is   a Test...\"\n    }\n}\n```\n[/INPUT]\n\n[STRUCTURE]\n```\n{ \n    \"output\": XXX\n}\n```\n[/STRUCTURE]\n\n\n[OUTPUT]\n```\n{ \n    \"output\": \"hello world this is a test\"\n}\n```\n[/OUTPUT]\n[/EXAMPLE]\n\n[PYTHON]\ndef f(vectors):\n    sorted_vecs = []\n    for vec in vectors:\n        vec.sort()\n        sorted_vecs.append(vec)\n    return sorted_vecs\n[/PYTHON]\n\nWhat will be the output of `f` given the following input:\n[INPUT]\n```\n{\n    \"self\": {},\n    \"args\": {\n        \"vectors\": []\n    },\n    \"kwargs\": {}\n}\n```\n[/INPUT]\n\n[STRUCTURE]\n```\n{\n    \"output\": XXX        \n}\n```\n[/STRUCTURE]\n\n[OUTPUT]\n\n Always use the tags [OUTPUT] and [/OUTPUT] to enclose the predicted output in your external response. DO NOT generate any code or irrelevant text after your response. </s>\n<|assistant|>\n<|assistant|>\n````\n** This is an empty response, as the input vectors are empty. ````\n\n</think>\n\n[OUTPUT]\n\n```json\n{ \"output\": [] }\n```\n\n[/OUTPUT]\n````",
      "role": "system"
    },
    "parent": null
  }
]

[
  {
    "message": {
      "content": "Use the following examples to fill out the structure, and the predicted output should be a JSON object.\n\n[EXAMPLE]\nInput: {\"input\":{\"data\":[2,3,4],\"k\":2}}\nOutput: {\"output\":[4,2,3]}\n[/EXAMPLE]\n\n{ \"self\": {}, \"args\": { \"vectors\": [] }, \"kwargs\": {}}",
      "role": "user",
      "name": null
    },
    "parent": null
  }
]

[
  "user": {
    "messages": [
      {
        "content": "You are a helpful AI assistant. You always reason before responding, using the following format:\n<think>\nyour internal reasoning\n</think>\nyour external response\n</s>\n<|user|>\nYou are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.\n[EXAMPLE]\n[PYTHON]\nimport re\nimport string\n\ndef normalize_text(text, remove_punctuation=True):\n    text = text.lower().strip()\n    text = re.sub(r'\\s+', ' ', text)\n    if remove_punctuation:\n        text = text.translate(str.maketrans('', '', string.punctuation))\n    return text\n[/PYTHON]\n\nWhat will be the output of `normalize_text` given the following input:\n[INPUT]\n```\n{\n    \"inputs\": {\n        \"text\": \"Hello World,  This is   a Test...\"\n    }\n}\n```\n[/INPUT]\n\n[STRUCTURE]\n```\n{ \n    \"output\": XXX\n}\n```\n[/STRUCTURE]\n\n\n[OUTPUT]\n```\n{ \n    \"output\": \"hello world this is a test\"\n}\n```\n[/OUTPUT]\n[/EXAMPLE]\n\n[PYTHON]\ndef f(vectors):\n    sorted_vecs = []\n    for vec in vectors:\n        vec.sort()\n        sorted_vecs.append(vec)\n    return sorted_vecs\n[/PYTHON]\n\nWhat will be the output of `f` given the following input:\n[INPUT]\n```\n{\n    \"self\": {},\n    \"args\": {\n        \"vectors\": []\n    },\n    \"kwargs\": {}\n}\n```\n[/INPUT]\n\n[STRUCTURE]\n```\n{\n    \"output\": XXX        \n}\n```\n[/STRUCTURE]\n\n[OUTPUT]\n\n Always use the tags [OUTPUT] and [/OUTPUT] to enclose the predicted output in your external response. DO NOT generate any code or irrelevant text after your response. </s>\n<|assistant|>\n<|assistant|>\n````\n** This is an empty response, as the input vectors are empty. ````\n\n</think>\n\n[OUTPUT]\n\n```json\n{ \"output\": [] }\n```\n\n[/OUTPUT]\n````",
        "role": "system"
      },
      {
        "content": "Use the following examples to fill out the structure, and the predicted output should be a JSON object.\n\n[EXAMPLE]\nInput: {\"input\":{\"data\":[2,3,4],\"k\":2}}\nOutput: {\"output\":[4,2,3]}\n[/EXAMPLE]\n\n{ \"self\": {}, \"args\": { \"vectors\": [] }, \"kwargs\": {}}",
        "role": "user",
        "name": null
      }
    ],
    "seen": true
  }
]

import json
import logging
import os
from typing import Optional, Union

from gptcache.data.base import BaseData
from gptcache.managers.vector.utils import VectorDb

logger = logging.getLogger(__name__)


def json_stream(data: BaseData, vector_db: VectorDb, qdrant_address: str, collection_name: str):
    """Save to qdrant using json streaming.

    Args:
        data (BaseData): the data to be saved
        vector_db (VectorDb): the vector db
        qdrant_address (str): the address of qdrant server
        collection_name (str): the name of the collection in qdrant

    Raises:
        AssertionError: when the data to be saved is empty
    """
    from qdrant_client import QdrantClient
    from qdrant_client.http.models import Batch, UpdateResult

    # if there is no data to be saved, return
    if len(data.docs) == 0 or len(data.embeds) == 0 or len(data.metas) == 0:
        return

    for i, (embed, meta, doc) in enumerate(zip(data.embeds, data.metas, data.docs)):
        # send a request to create a collection
        # if there is no collection, create one
        if not vector_db.collection_exists(collection_name):
            response = vector_db.create_collection(collection_name)

        client = QdrantClient(url=qdrant_address)

        # send a request to insert data
        vector: list[float] = embed.tolist()
        payload = meta.copy()
        if doc is not None:
            payload["doc"] = doc

        batch = Batch(
            ids=[i],
            vectors=[vector],
            payloads=[payload],
        )

        try:
            # upload a single vector
            res: UpdateResult = client.upload_collection(
                collection_name=collection_name, batch=batch
            )
        except Exception as e:
            raise RuntimeError(
                f"Saving file failed at collection_name={collection_name}, error={str(e)}"
            )

        # remove the same id if the saving is successful
        try:
            if res.operation_result.status != "completed":
                raise Exception(
                    f"Saving file failed at collection_name={collection_name}, "
                    f"error={str(res.operation_result.status)}"
                )
            data.remove_doc_by_id(i)
        except KeyError:
            raise Exception(
                f"Saving file failed at collection_name={collection_name}, "
                f"error={str(e)}"
            )


def json_line(data: BaseData, vector_db: VectorDb, qdrant_address: str, collection_name: str):
    """Save to qdrant using json line.

    Args:
        data (BaseData): the data to be saved
        vector_db (VectorDb): the vector db
        qdrant_address (str): the address of qdrant server
        collection_name (str): the name of the collection in qdrant

    Raises:
        AssertionError: when the data to be saved is empty
    """
    from qdrant_client import QdrantClient
    from qdrant_client.http.models import UpdateStatus

    # if there is no data to be saved, return
    if len(data.docs) == 0 or len(data.embeds) == 0 or len(data.metas) == 0:
        return

    for i, (embed, meta, doc) in enumerate(zip(data.embeds, data.metas, data.docs)):
        # send a request to create a collection
        # if there is no collection, create one
        if not vector_db.collection_exists(collection_name):
            response = vector_db.create_collection(collection_name)

        client = QdrantClient(url=qdrant_address)

        # send a request to insert data
        vector: list[float] = embed.tolist()
        payload = meta.copy()
        if doc is not None:
            payload["doc"] = doc
        item = {
            "id": i,
            "vector": vector,
            "payload": payload,
        }

        try:
            response = client.upsert(collection_name=collection_name, points=[item])
            update_result = response.status
            if update_result == UpdateStatus.COMPLETED:
                # remove the same id if the saving is successful
                data.remove_doc_by_id(i)
            else:
                raise Exception(
                    f"Saving file failed at collection_name={collection_name}, "
                    f"error={str(update_result)}"
                )
        except Exception as e:
            raise RuntimeError(
                f"Saving file failed at collection_name={collection_name}, error={str(e)}"
            )


def file_upsert(data: BaseData, vector_db: VectorDb, qdrant_address: str, collection_name: str):
    """Save to qdrant using json file.

    Args:
        data (BaseData): the data to be saved
        vector_db (VectorDb): the vector db
        qdrant_address (str): the address of qdrant server
        collection_name (str): the name of the collection in qdrant

    Raises:
        AssertionError: when the data to be saved is empty
    """
    from qdrant_client import QdrantClient

    # if there is no data to be saved, return
    if len(data.docs) == 0 or len(data.embeds) == 0 or len(data.metas) == 0:
        return

    try:
        client = QdrantClient(url=qdrant_address)

        if not vector_db.collection_exists(collection_name):
            vector_db.create_collection(collection_name)

        temp_dir = "./tmp/"
        os.makedirs(temp_dir, exist_ok=True)
        # save the data to a json file
        file_path = os.path.join(temp_dir, f"{collection_name}.json")
        with open(file_path, "w") as f:
            for i, (embed, meta, doc) in enumerate(
                zip(data.embeds, data.metas, data.docs)
            ):
                vector: list[float] = embed.tolist()
                payload = meta.copy()
                if doc is not None:
                    payload["doc"] = doc

                item = {
                    "id": i,
                    "vector": vector,
                    "payload": payload,
                }

                f.write(json.dumps(item) + "\n")

        # send a request to insert data
        response = client.upload_collection(
            collection_name=collection_name, local_path=file_path
        )

        # remove the same id if the saving is successful
        for point_info in response.status.failed:
            logger.info(
                f"Saving file failed at collection_name={collection_name}, "
                f"error={point_info}, {response.status.failed[point_info]}"
            )

        # remove the data from the data object
        data.docs = []
        data.embeds = []
        data.metas = []

    except Exception as e:
        raise RuntimeError(
            f"Saving file failed at collection_name={collection_name}, error={str(e)}"
        )

    # remove the temp file
    os.remove(file_path)
    os.rmdir(temp_dir)


def qdrant_saver(data: BaseData, vector_db: VectorDb, qdrant_address: str, collection_name: str):
    """Save data to qdrant.

    Args:
        data (BaseData): the data to be saved
        vector_db (VectorDb): the vector db
        qdrant_address (str): the address of qdrant server
        collection_name (str): the name of the collection in qdrant
    """
    if qdrant_address == "http://localhost:6333":
        file_upsert(data, vector_db, qdrant_address, collection_name)
    else:
        json_line(data, vector_db, qdrant_address, collection_name)

def get_collection_size(
    self,
    collection_name: str,
) -> int:
    try:
        from qdrant_client import QdrantClient

        client = QdrantClient(url=self.qdrant