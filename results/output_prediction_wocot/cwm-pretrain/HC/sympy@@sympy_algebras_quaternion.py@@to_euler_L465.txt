<|system|>
You are a helpful AI assistant. You always reason before responding, using the following format:
<think>
your internal reasoning
</think>
your external response
</s>
<|user|>
You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from typing import TYPE_CHECKING, overload
from sympy.core.singleton import S
from sympy.core.relational import is_eq
from sympy.functions.elementary.complexes import conjugate, im, re, sign
from sympy.functions.elementary.miscellaneous import sqrt
from sympy.functions.elementary.trigonometric import acos, asin, atan2
from sympy.simplify.trigsimp import trigsimp
from sympy.core.expr import Expr

class Quaternion(Expr):
    _op_priority = 11.0
    is_commutative = False
    if TYPE_CHECKING:

        @property
        def args(self) -> tuple[Expr, Expr, Expr, Expr]:
            ...
        _real_field: bool
        _norm: Expr | None

    @property
    def a(self) -> Expr:
        return self.args[0]

    @property
    def b(self) -> Expr:
        return self.args[1]

    @property
    def c(self) -> Expr:
        return self.args[2]

    @property
    def d(self) -> Expr:
        return self.args[3]

    def to_euler(self, seq: str, angle_addition: bool=True, avoid_square_root: bool=False) -> tuple[Expr, Expr, Expr]:
        if self.is_zero_quaternion():
            raise ValueError('Cannot convert a quaternion with norm 0.')
        extrinsic = _is_extrinsic(seq)
        i1, j1, k1 = list(seq.lower())
        i = 'xyz'.index(i1) + 1
        j = 'xyz'.index(j1) + 1
        k = 'xyz'.index(k1) + 1
        if not extrinsic:
            i, k = (k, i)
        symmetric = i == k
        if symmetric:
            k = 6 - i - j
        sign = (i - j) * (j - k) * (k - i) // 2
        elements = [self.a, self.b, self.c, self.d]
        a = elements[0]
        b = elements[i]
        c = elements[j]
        d = elements[k] * sign
        if not symmetric:
            a, b, c, d = (a - c, b + d, c + a, d - b)
        if avoid_square_root:
            if symmetric:
                n2 = self.norm() ** 2
                angles1 = acos((a * a + b * b - c * c - d * d) / n2)
            else:
                n2 = 2 * self.norm() ** 2
                angles1 = asin((c * c + d * d - a * a - b * b) / n2)
        else:
            angles1 = 2 * atan2(sqrt(c * c + d * d), sqrt(a * a + b * b))
            if not symmetric:
                angles1 -= S.Pi / 2
        case = 0
        if is_eq(c, S.Zero) and is_eq(d, S.Zero):
            case = 1
        if is_eq(a, S.Zero) and is_eq(b, S.Zero):
            case = 2
        if case == 0:
            if angle_addition:
                angles0 = atan2(b, a) + atan2(d, c)
                angles2 = atan2(b, a) - atan2(d, c)
            else:
                angles0 = atan2(b * c + a * d, a * c - b * d)
                angles2 = atan2(b * c - a * d, a * c + b * d)
        elif case == 1:
            if extrinsic:
                angles0 = S.Zero
                angles2 = 2 * atan2(b, a)
            else:
                angles0 = 2 * atan2(b, a)
                angles2 = S.Zero
        elif extrinsic:
            angles0 = S.Zero
            angles2 = -2 * atan2(d, c)
        else:
            angles0 = 2 * atan2(d, c)
            angles2 = S.Zero
        if not symmetric:
            angles0 *= sign
        if extrinsic:
            return (angles2, angles1, angles0)
        else:
            return (angles0, angles1, angles2)

    def norm(self) -> Expr:
        if self._norm is None:
            q = self
            return sqrt(trigsimp(q.a ** 2 + q.b ** 2 + q.c ** 2 + q.d ** 2))
        return self._norm

    def is_zero_quaternion(self) -> bool | None:
        return self.norm().is_zero
[/PYTHON]

Functions called during the execution:
[PYTHON]
sympy.sympy.algebras.quaternion.is_zero_quaternion

def is_zero_quaternion(self) -> bool | None:
    """
    Returns true if the quaternion is a zero quaternion or false if it is not a zero quaternion
    and None if the value is unknown.

    Explanation
    ===========

    A zero quaternion is a quaternion with both scalar part and
    vector part equal to 0.

    Examples
    ========

    >>> from sympy.algebras.quaternion import Quaternion
    >>> q = Quaternion(1, 0, 0, 0)
    >>> q.is_zero_quaternion()
    False

    >>> q = Quaternion(0, 0, 0, 0)
    >>> q.is_zero_quaternion()
    True

    See Also
    ========
    scalar_part
    vector_part

    """

    return self.norm().is_zero

sympy.sympy.algebras.quaternion.a

@property
def a(self) -> Expr:
    return self.args[0]

sympy.sympy.algebras.quaternion.b

@property
def b(self) -> Expr:
    return self.args[1]

sympy.sympy.algebras.quaternion.c

@property
def c(self) -> Expr:
    return self.args[2]

sympy.sympy.algebras.quaternion.d

@property
def d(self) -> Expr:
    return self.args[3]

sympy.sympy.algebras.quaternion._is_extrinsic

def _is_extrinsic(seq: str) -> bool:
    """validate seq and return True if seq is lowercase and False if uppercase"""
    if type(seq) != str:
        raise ValueError('Expected seq to be a string.')
    if len(seq) != 3:
        raise ValueError("Expected 3 axes, got `{}`.".format(seq))

    intrinsic = seq.isupper()
    extrinsic = seq.islower()
    if not (intrinsic or extrinsic):
        raise ValueError("seq must either be fully uppercase (for extrinsic "
                         "rotations), or fully lowercase, for intrinsic "
                         "rotations).")

    i, j, k = list(seq.lower())
    if (i == j) or (j == k):
        raise ValueError("Consecutive axes must be different")

    bad = set(seq) - set('xyzXYZ')
    if bad:
        raise ValueError("Expected axes from `seq` to be from "
                         "['x', 'y', 'z'] or ['X', 'Y', 'Z'], "
                         "got {}".format(''.join(bad)))

    return extrinsic

sympy.sympy.core.cache.wrapper

@wraps(func)
def wrapper(*args, **kwargs):
    try:
        retval = cfunc(*args, **kwargs)
    except TypeError as e:
        if not e.args or not e.args[0].startswith('unhashable type:'):
            raise
        retval = func(*args, **kwargs)
    return retval

sympy.sympy.core.decorators._func

@wraps(func)
def _func(self, other):
    # XXX: The check for _op_priority here should be removed. It is
    # needed to stop mutable matrices from being sympified to
    # immutable matrices which breaks things in quantum...
    if not hasattr(other, '_op_priority'):
        try:
            other = sympify(other, strict=True)
        except SympifyError:
            return retval
    if not isinstance(other, expectedcls):
        return retval
    return func(self, other)

sympy.sympy.core.decorators.__sympifyit_wrapper

@wraps(func)
def __sympifyit_wrapper(a, b):
    try:
        # If an external class has _op_priority, it knows how to deal
        # with SymPy objects. Otherwise, it must be converted.
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

sympy.sympy.core.numbers.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational._new(self.p*other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

sympy.sympy.core.numbers.__sub__

def __sub__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational._new(self.p*other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

sympy.sympy.core.numbers.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p*other)
        elif isinstance(other, Integer):
            return Integer(self.p*other.p)
        elif isinstance(other, Rational):
            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

sympy.sympy.core.numbers.__rmul__

def __rmul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(other*self.p)
        elif isinstance(other, Rational):
            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))
        return Rational.__rmul__(self, other)
    return Rational.__rmul__(self, other)

sympy.sympy.core.relational.is_eq

def is_eq(lhs: Basic, rhs: Basic, assumptions=None) -> bool | None:
    """
    Fuzzy bool representing mathematical equality between *lhs* and *rhs*.

    Parameters
    ==========

    lhs : Expr
        The left-hand side of the expression, must be sympified.

    rhs : Expr
        The right-hand side of the expression, must be sympified.

    assumptions: Boolean, optional
        Assumptions taken to evaluate the equality.

    Returns
    =======

    ``True`` if *lhs* is equal to *rhs*, ``False`` is *lhs* is not equal to *rhs*,
    and ``None`` if the comparison between *lhs* and *rhs* is indeterminate.

    Explanation
    ===========

    This function is intended to give a relatively fast determination and
    deliberately does not attempt slow calculations that might help in
    obtaining a determination of True or False in more difficult cases.

    :func:`~.is_neq` calls this function to return its value, so supporting
    new type with this function will ensure correct behavior for ``is_neq``
    as well.

    Examples
    ========

    >>> from sympy import Q, S
    >>> from sympy.core.relational import is_eq, is_neq
    >>> from sympy.abc import x
    >>> is_eq(S(0), S(0))
    True
    >>> is_neq(S(0), S(0))
    False
    >>> is_eq(S(0), S(2))
    False
    >>> is_neq(S(0), S(2))
    True

    Assumptions can be passed to evaluate the equality which is otherwise
    indeterminate.

    >>> print(is_eq(x, S(0)))
    None
    >>> is_eq(x, S(0), assumptions=Q.zero(x))
    True

    New types can be supported by dispatching to ``_eval_is_eq``.

    >>> from sympy import Basic, sympify
    >>> from sympy.multipledispatch import dispatch
    >>> class MyBasic(Basic):
    ...     def __new__(cls, arg):
    ...         return Basic.__new__(cls, sympify(arg))
    ...     @property
    ...     def value(self):
    ...         return self.args[0]
    ...
    >>> @dispatch(MyBasic, MyBasic)
    ... def _eval_is_eq(a, b):
    ...     return is_eq(a.value, b.value)
    ...
    >>> a = MyBasic(1)
    >>> b = MyBasic(1)
    >>> is_eq(a, b)
    True
    >>> is_neq(a, b)
    False

    """
    # here, _eval_Eq is only called for backwards compatibility
    # new code should use is_eq with multiple dispatch as
    # outlined in the docstring
    for side1, side2 in (lhs, rhs), (rhs, lhs):
        eval_func = getattr(side1, '_eval_Eq', None)
        if eval_func is not None:
            retval = eval_func(side2)
            if retval is not None:
                return retval

    retval = _eval_is_eq(lhs, rhs)
    if retval is not None:
        return retval

    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):
        retval = _eval_is_eq(rhs, lhs)
        if retval is not None:
            return retval

    # retval is still None, so go through the equality logic
    # If expressions have the same structure, they must be equal.
    if lhs == rhs:
        return True  # e.g. True == True
    elif all(isinstance(i, BooleanAtom) for i in (rhs, lhs)):
        return False  # True != False
    elif not (lhs.is_Symbol or rhs.is_Symbol) and (
        isinstance(lhs, Boolean) !=
        isinstance(rhs, Boolean)):
        return False  # only Booleans can equal Booleans

    from sympy.assumptions.wrapper import (AssumptionsWrapper,
        is_infinite, is_extended_real)
    from .add import Add

    _lhs = AssumptionsWrapper(lhs, assumptions)
    _