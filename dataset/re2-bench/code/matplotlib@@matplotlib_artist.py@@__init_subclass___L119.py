from inspect import Signature, Parameter
import matplotlib as mpl
from . import _api, cbook

class Artist:
    """
    Abstract base class for objects that render into a FigureCanvas.

    Typically, all visible elements in a figure are subclasses of Artist.
    """
    zorder = 0

    def __init_subclass__(cls):
        if not hasattr(cls.draw, '_supports_rasterization'):
            cls.draw = _prevent_rasterization(cls.draw)
        if not hasattr(cls.set, '_autogenerated_signature'):
            return
        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
        cls.set.__name__ = 'set'
        cls.set.__qualname__ = f'{cls.__qualname__}.set'
        cls._update_set_signature_and_docstring()
    _PROPERTIES_EXCLUDED_FROM_SET = ['navigate_mode', 'figure', '3d_properties']

    @classmethod
    def _update_set_signature_and_docstring(cls):
        """
        Update the signature of the set function to list all properties
        as keyword arguments.

        Property aliases are not listed in the signature for brevity, but
        are still accepted as keyword arguments.
        """
        cls.set.__signature__ = Signature([Parameter('self', Parameter.POSITIONAL_OR_KEYWORD), *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_api.UNSET) for prop in ArtistInspector(cls).get_setters() if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])
        cls.set._autogenerated_signature = True
        cls.set.__doc__ = 'Set multiple properties at once.\n\nSupported properties are\n\n' + kwdoc(cls)

    def __init__(self):
        self._stale = True
        self.stale_callback = None
        self._axes = None
        self._parent_figure = None
        self._transform = None
        self._transformSet = False
        self._visible = True
        self._animated = False
        self._alpha = None
        self.clipbox = None
        self._clippath = None
        self._clipon = True
        self._label = ''
        self._picker = None
        self._rasterized = False
        self._agg_filter = None
        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data
        self._callbacks = cbook.CallbackRegistry(signals=['pchanged'])
        try:
            self.axes = None
        except AttributeError:
            pass
        self._remove_method = None
        self._url = None
        self._gid = None
        self._snap = None
        self._sketch = mpl.rcParams['path.sketch']
        self._path_effects = mpl.rcParams['path.effects']
        self._sticky_edges = _XYPair([], [])
        self._in_layout = True

    @property
    def axes(self):
        """The `~.axes.Axes` instance the artist resides in, or *None*."""
        return self._axes

    @axes.setter
    def axes(self, new_axes):
        if new_axes is not None and self._axes is not None and (new_axes != self._axes):
            raise ValueError('Can not reset the Axes. You are probably trying to reuse an artist in more than one Axes which is not supported')
        self._axes = new_axes
        if new_axes is not None and new_axes is not self:
            self.stale_callback = _stale_axes_callback

    @property
    def stale(self):
        """
        Whether the artist is 'stale' and needs to be re-drawn for the output
        to match the internal state of the artist.
        """
        return self._stale

    @stale.setter
    def stale(self, val):
        self._stale = val
        if self._animated:
            return
        if val and self.stale_callback is not None:
            self.stale_callback(self, val)

    def pchanged(self):
        """
        Call all of the registered callbacks.

        This function is triggered internally when a property is changed.

        See Also
        --------
        add_callback
        remove_callback
        """
        self._callbacks.process('pchanged')
    figure = property(get_figure, set_figure, doc='The (Sub)Figure that the artist is on.  For more control, use the `get_figure` method.')

    def get_visible(self):
        """Return the visibility."""
        return self._visible

    def draw(self, renderer):
        """
        Draw the Artist (and its children) using the given renderer.

        This has no effect if the artist is not visible (`.Artist.get_visible`
        returns False).

        Parameters
        ----------
        renderer : `~matplotlib.backend_bases.RendererBase` subclass.

        Notes
        -----
        This method is overridden in the Artist subclasses.
        """
        if not self.get_visible():
            return
        self.stale = False

    def _update_props(self, props, errfmt):
        """
        Helper for `.Artist.set` and `.Artist.update`.

        *errfmt* is used to generate error messages for invalid property
        names; it gets formatted with ``type(self)`` for "{cls}" and the
        property name for "{prop_name}".
        """
        ret = []
        with cbook._setattr_cm(self, eventson=False):
            for k, v in props.items():
                if k == 'axes':
                    ret.append(setattr(self, k, v))
                else:
                    func = getattr(self, f'set_{k}', None)
                    if not callable(func):
                        raise AttributeError(errfmt.format(cls=type(self), prop_name=k), name=k)
                    ret.append(func(v))
        if ret:
            self.pchanged()
            self.stale = True
        return ret

    def _internal_update(self, kwargs):
        """
        Update artist properties without prenormalizing them, but generating
        errors as if calling `set`.

        The lack of prenormalization is to maintain backcompatibility.
        """
        return self._update_props(kwargs, '{cls.__name__}.set() got an unexpected keyword argument {prop_name!r}')

    def set(self, **kwargs):
        return self._internal_update(cbook.normalize_kwargs(kwargs, self))
    mouseover = property(get_mouseover, set_mouseover)
