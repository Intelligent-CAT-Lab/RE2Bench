{
    "scikit-learn.sklearn.impute._base.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = is_scalar_nan(self.missing_values)\n    return tags",
    "scikit-learn.sklearn.utils._missing.is_pandas_na": "def is_pandas_na(x):\n    \"\"\"Test if x is pandas.NA.\n\n    We intentionally do not use this function to return `True` for `pd.NA` in\n    `is_scalar_nan`, because estimators that support `pd.NA` are the exception\n    rather than the rule at the moment. When `pd.NA` is more universally\n    supported, we may reconsider this decision.\n\n    Parameters\n    ----------\n    x : any type\n        The input value to test.\n\n    Returns\n    -------\n    boolean\n        True if `x` is `pandas.NA`, False otherwise.\n    \"\"\"\n    with suppress(ImportError):\n        from pandas import NA\n\n        return x is NA\n\n    return False",
    "scikit-learn.sklearn.utils._missing.is_scalar_nan": "def is_scalar_nan(x):\n    \"\"\"Test if x is NaN.\n\n    This function is meant to overcome the issue that np.isnan does not allow\n    non-numerical types as input, and that np.nan is not float('nan').\n\n    Parameters\n    ----------\n    x : any type\n        Any scalar value.\n\n    Returns\n    -------\n    bool\n        Returns true if x is NaN, and false otherwise.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.utils._missing import is_scalar_nan\n    >>> is_scalar_nan(np.nan)\n    True\n    >>> is_scalar_nan(float(\"nan\"))\n    True\n    >>> is_scalar_nan(None)\n    False\n    >>> is_scalar_nan(\"\")\n    False\n    >>> is_scalar_nan([np.nan])\n    False\n    \"\"\"\n    return (\n        not isinstance(x, numbers.Integral)\n        and isinstance(x, numbers.Real)\n        and math.isnan(x)\n    )"
}