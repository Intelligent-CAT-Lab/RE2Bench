{
    "sympy.sympy.ntheory.multinomial.multinomial_coefficients_iterator": "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    \"\"\"multinomial coefficient iterator\n\n    This routine has been optimized for `m` large with respect to `n` by taking\n    advantage of the fact that when the monomial tuples `t` are stripped of\n    zeros, their coefficient is the same as that of the monomial tuples from\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\n    precomputed to save memory and time.\n\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\n    True\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\n    >>> it = multinomial_coefficients_iterator(20,3)\n    >>> next(it)\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\n    \"\"\"\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2*n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for k, v in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0  # j will be the leftmost nonzero position\n        else:\n            j = m\n        # enumerate tuples in co-lex order\n        while j < m - 1:\n            # compute next tuple\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
    "sympy.sympy.ntheory.multinomial.binomial_coefficients": "def binomial_coefficients(n):\n    \"\"\"Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import binomial_coefficients\n    >>> binomial_coefficients(9)\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\n\n    See Also\n    ========\n\n    binomial_coefficients_list, multinomial_coefficients\n    \"\"\"\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n//2 + 1):\n        a = (a * (n - k + 1))//k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}