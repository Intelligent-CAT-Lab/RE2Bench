{
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.expr.as_coeff_Add": "def as_coeff_Add(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return S.Zero, self",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.relational.lhs": "@property\ndef lhs(self) -> Basic:\n    \"\"\"The left-hand side of the relation.\"\"\"\n    return self._args[0]",
    "sympy.sympy.core.relational.rhs": "@property\ndef rhs(self) -> Basic:\n    \"\"\"The right-hand side of the relation.\"\"\"\n    return self._args[1]",
    "sympy.sympy.core.relational.reversed": "@property\ndef reversed(self):\n    \"\"\"Return the relationship with sides reversed.\n\n    Examples\n    ========\n\n    >>> from sympy import Eq\n    >>> from sympy.abc import x\n    >>> Eq(x, 1)\n    Eq(x, 1)\n    >>> _.reversed\n    Eq(1, x)\n    >>> x < 1\n    x < 1\n    >>> _.reversed\n    1 > x\n    \"\"\"\n    ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}\n    a, b = self.args\n    return Relational.__new__(ops.get(self.func, self.func), b, a)",
    "sympy.sympy.core.relational.canonical": "@property\ndef canonical(self):\n    \"\"\"Return a canonical form of the relational by putting a\n    number on the rhs, canonically removing a sign or else\n    ordering the args canonically. No other simplification is\n    attempted.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> x < 2\n    x < 2\n    >>> _.reversed.canonical\n    x < 2\n    >>> (-y < x).canonical\n    x > -y\n    >>> (-y > x).canonical\n    x < -y\n    >>> (-y < -x).canonical\n    x < y\n\n    The canonicalization is recursively applied:\n\n    >>> from sympy import Eq\n    >>> Eq(x < y, y > x).canonical\n    True\n    \"\"\"\n    args = tuple([i.canonical if isinstance(i, Relational) else i for i in self.args])\n    if args != self.args:\n        r = self.func(*args)\n        if not isinstance(r, Relational):\n            return r\n    else:\n        r = self\n    if r.rhs.is_number:\n        if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:\n            r = r.reversed\n    elif r.lhs.is_number or tuple(ordered(args)) != args:\n        r = r.reversed\n\n    LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)\n    RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)\n\n    if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):\n        return r\n\n    # Check if first value has negative sign\n    if LHS_CEMS and LHS_CEMS():\n        return r.reversedsign\n    elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():\n        # Right hand side has a minus, but not lhs.\n        # How does the expression with reversed signs behave?\n        # This is so that expressions of the type\n        # Eq(x, -y) and Eq(-x, y)\n        # have the same canonical representation\n        expr1, _ = ordered([r.lhs, -r.rhs])\n        if expr1 != r.lhs:\n            return r.reversed.reversedsign\n\n    return r",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False"
}