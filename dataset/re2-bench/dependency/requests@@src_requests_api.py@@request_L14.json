{
    "requests.src.requests.sessions.__init__": "def __init__(self):\n    #: A case-insensitive dictionary of headers to be sent on each\n    #: :class:`Request <Request>` sent from this\n    #: :class:`Session <Session>`.\n    self.headers = default_headers()\n\n    #: Default Authentication tuple or object to attach to\n    #: :class:`Request <Request>`.\n    self.auth = None\n\n    #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n    #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n    #: be used on each :class:`Request <Request>`.\n    self.proxies = {}\n\n    #: Event-handling hooks.\n    self.hooks = default_hooks()\n\n    #: Dictionary of querystring data to attach to each\n    #: :class:`Request <Request>`. The dictionary values may be lists for\n    #: representing multivalued query parameters.\n    self.params = {}\n\n    #: Stream response content default.\n    self.stream = False\n\n    #: SSL Verification default.\n    #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n    #: remote end.\n    #: If verify is set to `False`, requests will accept any TLS certificate\n    #: presented by the server, and will ignore hostname mismatches and/or\n    #: expired certificates, which will make your application vulnerable to\n    #: man-in-the-middle (MitM) attacks.\n    #: Only set this to `False` for testing.\n    self.verify = True\n\n    #: SSL client certificate default, if String, path to ssl client\n    #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n    self.cert = None\n\n    #: Maximum number of redirects allowed. If the request exceeds this\n    #: limit, a :class:`TooManyRedirects` exception is raised.\n    #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n    #: 30.\n    self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n    #: Trust environment settings for proxy configuration, default\n    #: authentication and similar.\n    self.trust_env = True\n\n    #: A CookieJar containing all currently outstanding cookies set on this\n    #: session. By default it is a\n    #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n    #: may be any other ``cookielib.CookieJar`` compatible object.\n    self.cookies = cookiejar_from_dict({})\n\n    # Default connection adapters.\n    self.adapters = OrderedDict()\n    self.mount(\"https://\", HTTPAdapter())\n    self.mount(\"http://\", HTTPAdapter())",
    "requests.src.requests.sessions.__enter__": "def __enter__(self):\n    return self",
    "requests.src.requests.sessions.__exit__": "def __exit__(self, *args):\n    self.close()",
    "requests.src.requests.sessions.request": "def request(\n    self,\n    method,\n    url,\n    params=None,\n    data=None,\n    headers=None,\n    cookies=None,\n    files=None,\n    auth=None,\n    timeout=None,\n    allow_redirects=True,\n    proxies=None,\n    hooks=None,\n    stream=None,\n    verify=None,\n    cert=None,\n    json=None,\n):\n    \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n    Returns :class:`Response <Response>` object.\n\n    :param method: method for the new :class:`Request` object.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary or bytes to be sent in the query\n        string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) json to send in the body of the\n        :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the\n        :class:`Request`.\n    :param cookies: (optional) Dict or CookieJar object to send with the\n        :class:`Request`.\n    :param files: (optional) Dictionary of ``'filename': file-like-objects``\n        for multipart encoding upload.\n    :param auth: (optional) Auth tuple or callable to enable\n        Basic/Digest/Custom HTTP Auth.\n    :param timeout: (optional) How many seconds to wait for the server to send\n        data before giving up, as a float, or a :ref:`(connect timeout,\n        read timeout) <timeouts>` tuple.\n    :type timeout: float or tuple\n    :param allow_redirects: (optional) Set to True by default.\n    :type allow_redirects: bool\n    :param proxies: (optional) Dictionary mapping protocol or protocol and\n        hostname to the URL of the proxy.\n    :param hooks: (optional) Dictionary mapping hook name to one event or\n        list of events, event must be callable.\n    :param stream: (optional) whether to immediately download the response\n        content. Defaults to ``False``.\n    :param verify: (optional) Either a boolean, in which case it controls whether we verify\n        the server's TLS certificate, or a string, in which case it must be a path\n        to a CA bundle to use. Defaults to ``True``. When set to\n        ``False``, requests will accept any TLS certificate presented by\n        the server, and will ignore hostname mismatches and/or expired\n        certificates, which will make your application vulnerable to\n        man-in-the-middle (MitM) attacks. Setting verify to ``False``\n        may be useful during local development or testing.\n    :param cert: (optional) if String, path to ssl client cert file (.pem).\n        If Tuple, ('cert', 'key') pair.\n    :rtype: requests.Response\n    \"\"\"\n    # Create the Request.\n    req = Request(\n        method=method.upper(),\n        url=url,\n        headers=headers,\n        files=files,\n        data=data or {},\n        json=json,\n        params=params or {},\n        auth=auth,\n        cookies=cookies,\n        hooks=hooks,\n    )\n    prep = self.prepare_request(req)\n\n    proxies = proxies or {}\n\n    settings = self.merge_environment_settings(\n        prep.url, proxies, stream, verify, cert\n    )\n\n    # Send the request.\n    send_kwargs = {\n        \"timeout\": timeout,\n        \"allow_redirects\": allow_redirects,\n    }\n    send_kwargs.update(settings)\n    resp = self.send(prep, **send_kwargs)\n\n    return resp"
}