{
    "sympy.sympy.external.ntheory.iroot": "def iroot(y, n):\n    if y < 0:\n        raise ValueError(\"y must be nonnegative\")\n    if n < 1:\n        raise ValueError(\"n must be positive\")\n    if y in (0, 1):\n        return y, True\n    if n == 1:\n        return y, True\n    if n == 2:\n        x, rem = mlib.sqrtrem(y)\n        return int(x), not rem\n    if n >= y.bit_length():\n        return 1, False\n    # Get initial estimate for Newton's method. Care must be taken to\n    # avoid overflow\n    try:\n        guess = int(y**(1./n) + 0.5)\n    except OverflowError:\n        exp = math.log2(y)/n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0**(exp - shift) + 1) << shift\n        else:\n            guess = int(2.0**exp)\n    if guess > 2**50:\n        # Newton iteration\n        xprev, x = -1, guess\n        while 1:\n            t = x**(n - 1)\n            xprev, x = x, ((n - 1)*x + y//t)//n\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    # Compensate\n    t = x**n\n    while t < y:\n        x += 1\n        t = x**n\n    while t > y:\n        x -= 1\n        t = x**n\n    return x, t == y",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}