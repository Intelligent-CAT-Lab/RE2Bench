{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.linear_model._ridge._compute_gram": "def _compute_gram(self, X, sqrt_sw):\n    \"\"\"Computes the Gram matrix XX^T with possible centering.\n\n    Parameters\n    ----------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The preprocessed design matrix.\n\n    sqrt_sw : ndarray of shape (n_samples,)\n        square roots of sample weights\n\n    Returns\n    -------\n    gram : ndarray of shape (n_samples, n_samples)\n        The Gram matrix.\n    X_mean : ndarray of shape (n_feature,)\n        The weighted mean of ``X`` for each feature.\n\n    Notes\n    -----\n    When X is dense the centering has been done in preprocessing\n    so the mean is 0 and we just compute XX^T.\n\n    When X is sparse it has not been centered in preprocessing, but it has\n    been scaled by sqrt(sample weights).\n\n    When self.fit_intercept is False no centering is done.\n\n    The centered X is never actually computed because centering would break\n    the sparsity of X.\n    \"\"\"\n    xp, _ = get_namespace(X)\n    center = self.fit_intercept and sparse.issparse(X)\n    if not center:\n        # in this case centering has been done in preprocessing\n        # or we are not fitting an intercept.\n        X_mean = xp.zeros(X.shape[1], dtype=X.dtype)\n        return safe_sparse_dot(X, X.T, dense_output=True), X_mean\n    # X is sparse\n    n_samples = X.shape[0]\n    sample_weight_matrix = sparse.dia_matrix(\n        (sqrt_sw, 0), shape=(n_samples, n_samples)\n    )\n    X_weighted = sample_weight_matrix.dot(X)\n    X_mean, _ = mean_variance_axis(X_weighted, axis=0)\n    X_mean *= n_samples / sqrt_sw.dot(sqrt_sw)\n    X_mX = sqrt_sw[:, None] * safe_sparse_dot(X_mean, X.T, dense_output=True)\n    X_mX_m = np.outer(sqrt_sw, sqrt_sw) * np.dot(X_mean, X_mean)\n    return (\n        safe_sparse_dot(X, X.T, dense_output=True) + X_mX_m - X_mX - X_mX.T,\n        X_mean,\n    )",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant"
}