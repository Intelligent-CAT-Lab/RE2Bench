{
    "matplotlib.lib.matplotlib.backend_bases.show": "# Could not extract code for matplotlib.lib.matplotlib.backend_bases.show",
    "matplotlib.lib.matplotlib.pyplot._get_backend_mod": "def _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:\n    \"\"\"\n    Ensure that a backend is selected and return it.\n\n    This is currently private, but may be made public in the future.\n    \"\"\"\n    if _backend_mod is None:\n        # Use rcParams._get(\"backend\") to avoid going through the fallback\n        # logic (which will (re)import pyplot and then call switch_backend if\n        # we need to resolve the auto sentinel)\n        switch_backend(rcParams._get(\"backend\"))\n    return cast(type[matplotlib.backend_bases._Backend], _backend_mod)",
    "matplotlib.lib.matplotlib.pyplot._warn_if_gui_out_of_main_thread": "def _warn_if_gui_out_of_main_thread() -> None:\n    warn = False\n    canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)\n    if canvas_class.required_interactive_framework:\n        if hasattr(threading, 'get_native_id'):\n            # This compares native thread ids because even if Python-level\n            # Thread objects match, the underlying OS thread (which is what\n            # really matters) may be different on Python implementations with\n            # green threads.\n            if threading.get_native_id() != threading.main_thread().native_id:\n                warn = True\n        else:\n            # Fall back to Python-level Thread if native IDs are unavailable,\n            # mainly for PyPy.\n            if threading.current_thread() is not threading.main_thread():\n                warn = True\n    if warn:\n        _api.warn_external(\n            \"Starting a Matplotlib GUI outside of the main thread will likely \"\n            \"fail.\")"
}