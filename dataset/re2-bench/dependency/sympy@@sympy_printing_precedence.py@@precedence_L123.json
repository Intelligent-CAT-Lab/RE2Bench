{
    "sympy.sympy.printing.precedence.precedence_FracElement": "def precedence_FracElement(item):\n    if item.denom == 1:\n        return precedence_PolyElement(item.numer)\n    else:\n        return PRECEDENCE[\"Mul\"]",
    "sympy.sympy.printing.precedence.precedence_UnevaluatedExpr": "def precedence_UnevaluatedExpr(item):\n    return precedence(item.args[0]) - 0.5",
    "sympy.sympy.printing.precedence.precedence_Mul": "def precedence_Mul(item):\n    from sympy.core.function import Function\n    if any(hasattr(arg, 'precedence') and isinstance(arg, Function) and\n           arg.precedence < PRECEDENCE[\"Mul\"] for arg in item.args):\n        return PRECEDENCE[\"Mul\"]\n\n    if item.could_extract_minus_sign():\n        return PRECEDENCE[\"Add\"]\n    return PRECEDENCE[\"Mul\"]",
    "sympy.sympy.printing.precedence.precedence_Rational": "def precedence_Rational(item):\n    if item.p < 0:\n        return PRECEDENCE[\"Add\"]\n    return PRECEDENCE[\"Mul\"]",
    "sympy.sympy.printing.precedence.precedence_Integer": "def precedence_Integer(item):\n    if item.p < 0:\n        return PRECEDENCE[\"Add\"]\n    return PRECEDENCE[\"Atom\"]",
    "sympy.sympy.printing.precedence.precedence_Float": "def precedence_Float(item):\n    if item < 0:\n        return PRECEDENCE[\"Add\"]\n    return PRECEDENCE[\"Atom\"]",
    "sympy.sympy.printing.precedence.precedence_PolyElement": "def precedence_PolyElement(item):\n    if item.is_generator:\n        return PRECEDENCE[\"Atom\"]\n    elif item.is_ground:\n        return precedence(item.coeff(1))\n    elif item.is_term:\n        return PRECEDENCE[\"Mul\"]\n    else:\n        return PRECEDENCE[\"Add\"]",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}