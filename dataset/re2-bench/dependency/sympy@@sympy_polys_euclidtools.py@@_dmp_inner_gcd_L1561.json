{
    "sympy.sympy.polys.densebasic.dmp_convert": "def dmp_convert(f: dmp[Er], u: int, K0: Domain[Er] | None, K1: Domain[Es]) -> dmp[Es]:\n    \"\"\"\n    Convert the ground domain of ``f`` from ``K0`` to ``K1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_convert\n\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> dmp_convert([[R(1)], [R(2)]], 1, R.to_domain(), ZZ)\n    [[1], [2]]\n    >>> dmp_convert([[ZZ(1)], [ZZ(2)]], 1, ZZ, R.to_domain())\n    [[1], [2]]\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_convert(_dup(f), K0, K1))\n    if K0 is not None and K0 == K1:\n        return cast('dmp[Es]', f)\n\n    v = u - 1\n\n    return dmp_strip([dmp_convert(c, v, K0, K1) for c in f], u, K1)",
    "sympy.sympy.polys.domains.compositedomain.is_Exact": "@property\ndef is_Exact(self):\n    \"\"\"Returns ``True`` if this domain is exact. \"\"\"\n    return self.domain.is_Exact",
    "sympy.sympy.polys.domains.realfield.get_exact": "def get_exact(self):\n    \"\"\"Returns an exact domain associated with ``self``. \"\"\"\n    from sympy.polys.domains import QQ\n    return QQ",
    "sympy.sympy.polys.euclidtools.dmp_rr_prs_gcd": "def dmp_rr_prs_gcd(f, g, u, K):\n    \"\"\"\n    Computes polynomial GCD using subresultants over a ring.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``, ``cff = quo(f, h)``,\n    and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_rr_prs_gcd(f, g)\n    (x + y, x + y, x)\n\n    \"\"\"\n    if not u:\n        return dup_rr_prs_gcd(f, g, K)\n\n    result = _dmp_rr_trivial_gcd(f, g, u, K)\n\n    if result is not None:\n        return result\n\n    fc, F = dmp_primitive(f, u, K)\n    gc, G = dmp_primitive(g, u, K)\n\n    h = dmp_subresultants(F, G, u, K)[-1]\n    c, _, _ = dmp_rr_prs_gcd(fc, gc, u - 1, K)\n\n    _, h = dmp_primitive(h, u, K)\n    h = dmp_mul_term(h, c, 0, u, K)\n\n    unit = K.canonical_unit(dmp_ground_LC(h, u, K))\n\n    if unit != K.one:\n        h = dmp_mul_ground(h, unit, u, K)\n\n    cff = dmp_quo(f, h, u, K)\n    cfg = dmp_quo(g, h, u, K)\n\n    return h, cff, cfg",
    "sympy.sympy.polys.euclidtools.dmp_ff_prs_gcd": "def dmp_ff_prs_gcd(f, g, u, K):\n    \"\"\"\n    Computes polynomial GCD using subresultants over a field.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``, ``cff = quo(f, h)``,\n    and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y, = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,2)*x**2 + x*y + QQ(1,2)*y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_ff_prs_gcd(f, g)\n    (x + y, 1/2*x + 1/2*y, x)\n\n    \"\"\"\n    if not u:\n        return dup_ff_prs_gcd(f, g, K)\n\n    result = _dmp_ff_trivial_gcd(f, g, u, K)\n\n    if result is not None:\n        return result\n\n    fc, F = dmp_primitive(f, u, K)\n    gc, G = dmp_primitive(g, u, K)\n\n    h = dmp_subresultants(F, G, u, K)[-1]\n    c, _, _ = dmp_ff_prs_gcd(fc, gc, u - 1, K)\n\n    _, h = dmp_primitive(h, u, K)\n    h = dmp_mul_term(h, c, 0, u, K)\n    h = dmp_ground_monic(h, u, K)\n\n    cff = dmp_quo(f, h, u, K)\n    cfg = dmp_quo(g, h, u, K)\n\n    return h, cff, cfg",
    "sympy.sympy.polys.euclidtools.dmp_zz_heu_gcd": "def dmp_zz_heu_gcd(f, g, u, K):\n    \"\"\"\n    Heuristic polynomial GCD in `Z[X]`.\n\n    Given univariate polynomials `f` and `g` in `Z[X]`, returns\n    their GCD and cofactors, i.e. polynomials ``h``, ``cff`` and ``cfg``\n    such that::\n\n          h = gcd(f, g), cff = quo(f, h) and cfg = quo(g, h)\n\n    The algorithm is purely heuristic which means it may fail to compute\n    the GCD. This will be signaled by raising an exception. In this case\n    you will need to switch to another GCD method.\n\n    The algorithm computes the polynomial GCD by evaluating polynomials\n    f and g at certain points and computing (fast) integer GCD of those\n    evaluations. The polynomial GCD is recovered from the integer image\n    by interpolation. The evaluation process reduces f and g variable by\n    variable into a large integer.  The final step is to verify if the\n    interpolated polynomial is the correct GCD. This gives cofactors of\n    the input polynomials as a side effect.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_zz_heu_gcd(f, g)\n    (x + y, x + y, x)\n\n    References\n    ==========\n\n    .. [1] [Liao95]_\n\n    \"\"\"\n    if not u:\n        return dup_zz_heu_gcd(f, g, K)\n\n    result = _dmp_rr_trivial_gcd(f, g, u, K)\n\n    if result is not None:\n        return result\n\n    gcd, f, g = dmp_ground_extract(f, g, u, K)\n\n    f_norm = dmp_max_norm(f, u, K)\n    g_norm = dmp_max_norm(g, u, K)\n\n    B = K(2*min(f_norm, g_norm) + 29)\n\n    x = max(min(B, 99*K.sqrt(B)),\n            2*min(f_norm // abs(dmp_ground_LC(f, u, K)),\n                  g_norm // abs(dmp_ground_LC(g, u, K))) + 4)\n\n    for i in range(0, HEU_GCD_MAX):\n        ff = dmp_eval(f, x, u, K)\n        gg = dmp_eval(g, x, u, K)\n\n        v = u - 1\n\n        if not (dmp_zero_p(ff, v) or dmp_zero_p(gg, v)):\n            h, cff, cfg = dmp_zz_heu_gcd(ff, gg, v, K)\n\n            h = _dmp_zz_gcd_interpolate(h, x, v, K)\n            h = dmp_ground_primitive(h, u, K)[1]\n\n            cff_, r = dmp_div(f, h, u, K)\n\n            if dmp_zero_p(r, u):\n                cfg_, r = dmp_div(g, h, u, K)\n\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return h, cff_, cfg_\n\n            cff = _dmp_zz_gcd_interpolate(cff, x, v, K)\n\n            h, r = dmp_div(f, cff, u, K)\n\n            if dmp_zero_p(r, u):\n                cfg_, r = dmp_div(g, h, u, K)\n\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return h, cff, cfg_\n\n            cfg = _dmp_zz_gcd_interpolate(cfg, x, v, K)\n\n            h, r = dmp_div(g, cfg, u, K)\n\n            if dmp_zero_p(r, u):\n                cff_, r = dmp_div(f, h, u, K)\n\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return h, cff_, cfg\n\n        x = 73794*x * K.sqrt(K.sqrt(x)) // 27011\n\n    raise HeuristicGCDFailed('no luck')",
    "sympy.sympy.polys.euclidtools.dmp_qq_heu_gcd": "def dmp_qq_heu_gcd(f, g, u, K0):\n    \"\"\"\n    Heuristic polynomial GCD in `Q[X]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y, = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,4)*x**2 + x*y + y**2\n    >>> g = QQ(1,2)*x**2 + x*y\n\n    >>> R.dmp_qq_heu_gcd(f, g)\n    (x + 2*y, 1/4*x + 1/2*y, 1/2*x)\n\n    \"\"\"\n    result = _dmp_ff_trivial_gcd(f, g, u, K0)\n\n    if result is not None:\n        return result\n\n    K1 = K0.get_ring()\n\n    cf, f = dmp_clear_denoms(f, u, K0, K1)\n    cg, g = dmp_clear_denoms(g, u, K0, K1)\n\n    f = dmp_convert(f, u, K0, K1)\n    g = dmp_convert(g, u, K0, K1)\n\n    h, cff, cfg = dmp_zz_heu_gcd(f, g, u, K1)\n\n    h = dmp_convert(h, u, K1, K0)\n\n    c = dmp_ground_LC(h, u, K0)\n    h = dmp_ground_monic(h, u, K0)\n\n    cff = dmp_convert(cff, u, K1, K0)\n    cfg = dmp_convert(cfg, u, K1, K0)\n\n    cff = dmp_mul_ground(cff, K0.quo(c, cf), u, K0)\n    cfg = dmp_mul_ground(cfg, K0.quo(c, cg), u, K0)\n\n    return h, cff, cfg",
    "sympy.sympy.polys.euclidtools._dmp_inner_gcd": "def _dmp_inner_gcd(f, g, u, K):\n    \"\"\"Helper function for `dmp_inner_gcd()`. \"\"\"\n    if not K.is_Exact:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return dmp_one(u, K), f, g\n\n        f = dmp_convert(f, u, K, exact)\n        g = dmp_convert(g, u, K, exact)\n\n        h, cff, cfg = _dmp_inner_gcd(f, g, u, exact)\n\n        h = dmp_convert(h, u, exact, K)\n        cff = dmp_convert(cff, u, exact, K)\n        cfg = dmp_convert(cfg, u, exact, K)\n\n        return h, cff, cfg\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dmp_qq_heu_gcd(f, g, u, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dmp_ff_prs_gcd(f, g, u, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dmp_zz_heu_gcd(f, g, u, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dmp_rr_prs_gcd(f, g, u, K)",
    "sympy.sympy.polys.polyconfig.query": "def query(key: str) -> bool | int | str | None:\n    \"\"\"Ask for a value of the given configuration item. \"\"\"\n    return _current_config.get(key.upper(), None)"
}