{
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.matrices.expressions.blockmatrix.<setcomp>": "ok = len({i.rows for i in r}) == 1\n",
    "sympy.sympy.matrices.expressions.blockmatrix.<lambda>": "isMat = lambda i: getattr(i, 'is_Matrix', False)\n",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))",
    "sympy.sympy.utilities.misc.filldedent": "def filldedent(s, w=70, **kwargs):\n    \"\"\"\n    Strips leading and trailing empty lines from a copy of ``s``, then dedents,\n    fills and returns it.\n\n    Empty line stripping serves to deal with docstrings like this one that\n    start with a newline after the initial triple quote, inserting an empty\n    line at the beginning of the string.\n\n    Additional keyword arguments will be passed to ``textwrap.fill()``.\n\n    See Also\n    ========\n    strlines, rawlines\n\n    \"\"\"\n    return '\\n' + fill(dedent(str(s)).strip('\\n'), width=w, **kwargs)"
}