{
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return other is not S.Infinity and other != float('inf')",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    rv = self._Frel(other, mlib.mpf_gt)\n    if rv is None:\n        return Expr.__gt__(self, other)\n    return rv",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.evalf": "def evalf(self, prec=None, **options):\n    return self._eval_evalf(prec)",
    "sympy.sympy.core.power.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if self.exp.is_Integer:\n        from sympy.polys.polytools import poly\n\n        exp = self.exp\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n        if not im_e:\n            return self, S.Zero\n        a, b = symbols('a b', cls=Dummy)\n        if exp >= 0:\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial(self.base**exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly(\n                (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp\n        else:\n            mag = re_e**2 + im_e**2\n            re_e, im_e = re_e/mag, -im_e/mag\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial((re_e + im_e*S.ImaginaryUnit)**-exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly((a + b)**-exp)\n\n        # Terms with even b powers will be real\n        r = [i for i in expr.terms() if not i[0][1] % 2]\n        re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        # Terms with odd b powers will be imaginary\n        r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n        im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n        im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n\n        return (re_part.subs({a: re_e, b: S.ImaginaryUnit*im_e}),\n        im_part1.subs({a: re_e, b: im_e}) + im_part3.subs({a: re_e, b: -im_e}))\n\n    from sympy.functions.elementary.trigonometric import atan2, cos, sin\n\n    if self.exp.is_Rational:\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n\n        if im_e.is_zero and self.exp is S.Half:\n            if re_e.is_extended_nonnegative:\n                return self, S.Zero\n            if re_e.is_extended_nonpositive:\n                return S.Zero, (-self.base)**self.exp\n\n        # XXX: This is not totally correct since for x**(p/q) with\n        #      x being imaginary there are actually q roots, but\n        #      only a single one is returned from here.\n        r = self.func(self.func(re_e, 2) + self.func(im_e, 2), S.Half)\n\n        t = atan2(im_e, re_e)\n\n        rp, tp = self.func(r, self.exp), t*self.exp\n\n        return rp*cos(tp), rp*sin(tp)\n    elif self.base is S.Exp1:\n        from sympy.functions.elementary.exponential import exp\n        re_e, im_e = self.exp.as_real_imag()\n        if deep:\n            re_e = re_e.expand(deep, **hints)\n            im_e = im_e.expand(deep, **hints)\n        c, s = cos(im_e), sin(im_e)\n        return exp(re_e)*c, exp(re_e)*s\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        if deep:\n            hints['complex'] = False\n\n            expanded = self.expand(deep, **hints)\n            if hints.get('ignore') == expanded:\n                return None\n            else:\n                return (re(expanded), im(expanded))\n        else:\n            return re(self), im(self)"
}