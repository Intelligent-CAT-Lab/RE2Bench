{
    "scikit-learn.sklearn.utils._metadata_requests.get_routing_for_object": "def get_routing_for_object(obj=None):\n    \"\"\"Get a ``Metadata{Router, Request}`` instance from the given object.\n\n    This function returns a\n    :class:`~sklearn.utils.metadata_routing.MetadataRouter` or a\n    :class:`~sklearn.utils.metadata_routing.MetadataRequest` from the given input.\n\n    This function always returns a copy or an instance constructed from the\n    input, such that changing the output of this function will not change the\n    original object.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    obj : object\n        - If the object provides a `get_metadata_routing` method, return a copy\n            of the output of that method.\n        - If the object is already a\n            :class:`~sklearn.utils.metadata_routing.MetadataRequest` or a\n            :class:`~sklearn.utils.metadata_routing.MetadataRouter`, return a copy\n            of that.\n        - Returns an empty :class:`~sklearn.utils.metadata_routing.MetadataRequest`\n            otherwise.\n\n    Returns\n    -------\n    obj : MetadataRequest or MetadataRouter\n        A ``MetadataRequest`` or a ``MetadataRouter`` taken or created from\n        the given object.\n    \"\"\"\n    # doing this instead of a try/except since an AttributeError could be raised\n    # for other reasons.\n    if hasattr(obj, \"get_metadata_routing\"):\n        return deepcopy(obj.get_metadata_routing())\n\n    elif getattr(obj, \"_type\", None) in [\"metadata_request\", \"metadata_router\"]:\n        return deepcopy(obj)\n\n    return MetadataRequest(owner=None)",
    "scikit-learn.sklearn.utils._metadata_requests._get_class_level_metadata_request_values": "@classmethod\ndef _get_class_level_metadata_request_values(cls, method: str):\n    \"\"\"Get class level metadata request values.\n\n    This method first checks the `method`'s signature for passable metadata and then\n    updates these with the metadata request values set at class level via the\n    ``__metadata_request__{method}`` class attributes.\n\n    This method (being a class-method), does not take request values set at\n    instance level into account.\n    \"\"\"\n    # Here we use `isfunction` instead of `ismethod` because calling `getattr`\n    # on a class instead of an instance returns an unbound function.\n    if not hasattr(cls, method) or not inspect.isfunction(getattr(cls, method)):\n        return dict()\n    # ignore the first parameter of the method, which is usually \"self\"\n    signature_items = list(\n        inspect.signature(getattr(cls, method)).parameters.items()\n    )[1:]\n    params = defaultdict(\n        str,\n        {\n            param_name: None\n            for param_name, param_info in signature_items\n            if param_name not in {\"X\", \"y\", \"Y\", \"Xt\", \"yt\"}\n            and param_info.kind\n            not in {param_info.VAR_POSITIONAL, param_info.VAR_KEYWORD}\n        },\n    )\n    # Then overwrite those defaults with the ones provided in\n    # `__metadata_request__{method}` class attributes, which take precedence over\n    # signature sniffing.\n\n    # need to go through the MRO since this is a classmethod and\n    # ``vars`` doesn't report the parent class attributes. We go through\n    # the reverse of the MRO so that child classes have precedence over\n    # their parents.\n    substr = f\"__metadata_request__{method}\"\n    for base_class in reversed(inspect.getmro(cls)):\n        # Copy is needed with free-threaded context to avoid\n        # RuntimeError: dictionary changed size during iteration.\n        # copy.deepcopy applied on an instance of base_class adds\n        # __slotnames__ attribute to base_class.\n        base_class_items = vars(base_class).copy().items()\n        for attr, value in base_class_items:\n            # we don't check for equivalence since python prefixes attrs\n            # starting with __ with the `_ClassName`.\n            if substr not in attr:\n                continue\n            for prop, alias in value.items():\n                # Here we add request values specified via those class attributes\n                # to the result dictionary (params). Adding a request which already\n                # exists will override the previous one. Since we go through the\n                # MRO in reverse order, the one specified by the lowest most classes\n                # in the inheritance tree are the ones which take effect.\n                if prop not in params and alias == UNUSED:\n                    raise ValueError(\n                        f\"Trying to remove parameter {prop} with UNUSED which\"\n                        \" doesn't exist.\"\n                    )\n\n                params[prop] = alias\n\n    return {param: alias for param, alias in params.items() if alias is not UNUSED}",
    "scikit-learn.sklearn.utils._metadata_requests.__init__": "def __init__(self, owner):\n    self.owner = owner\n    for method in SIMPLE_METHODS:\n        setattr(\n            self,\n            method,\n            MethodMetadataRequest(owner=owner, method=method),\n        )"
}