{
    "scikit-learn.sklearn.base.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags = TransformerTags()\n    return tags",
    "scikit-learn.sklearn.calibration.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    estimator_tags = get_tags(self._get_estimator())\n    tags.input_tags.sparse = estimator_tags.input_tags.sparse\n    tags.array_api_support = (\n        estimator_tags.array_api_support and self.method == \"temperature\"\n    )\n    return tags",
    "scikit-learn.sklearn.cluster._affinity_propagation.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.pairwise = self.affinity == \"precomputed\"\n    tags.input_tags.sparse = self.affinity != \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.cluster._bicluster.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.cluster._birch.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.cluster._bisect_k_means.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.cluster._dbscan.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.pairwise = self.metric == \"precomputed\"\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.cluster._hdbscan.hdbscan.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.input_tags.allow_nan = self.metric != \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.cluster._kmeans.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.cluster._spectral.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.input_tags.pairwise = self.affinity in [\n        \"precomputed\",\n        \"precomputed_nearest_neighbors\",\n    ]\n    return tags",
    "scikit-learn.sklearn.compose._column_transformer.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    try:\n        tags.input_tags.sparse = all(\n            get_tags(trans).input_tags.sparse\n            for name, trans, _ in self.transformers\n            if trans not in {\"passthrough\", \"drop\"}\n        )\n    except Exception:\n        # If `transformers` does not comply with our API (list of tuples)\n        # then it will fail. In this case, we assume that `sparse` is False\n        # but the parameter validation will raise an error during `fit`.\n        pass  # pragma: no cover\n    return tags",
    "scikit-learn.sklearn.compose._target.__sklearn_tags__": "def __sklearn_tags__(self):\n    regressor = self._get_regressor()\n    tags = super().__sklearn_tags__()\n    tags.regressor_tags.poor_score = True\n    tags.input_tags.sparse = get_tags(regressor).input_tags.sparse\n    tags.target_tags.multi_output = get_tags(regressor).target_tags.multi_output\n    return tags",
    "scikit-learn.sklearn.cross_decomposition._pls.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.regressor_tags.poor_score = True\n    tags.target_tags.required = False\n    return tags",
    "scikit-learn.sklearn.decomposition._dict_learning.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.decomposition._fastica.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.decomposition._incremental_pca.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    # Beware that fit accepts sparse data but partial_fit doesn't\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.decomposition._kernel_pca.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    tags.input_tags.pairwise = self.kernel == \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.decomposition._lda.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.positive_only = True\n    tags.input_tags.sparse = True\n    tags.transformer_tags.preserves_dtype = [\"float32\", \"float64\"]\n    return tags",
    "scikit-learn.sklearn.decomposition._nmf.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.positive_only = True\n    tags.input_tags.sparse = True\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.decomposition._pca.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    solver = getattr(self, \"_fit_svd_solver\", self.svd_solver)\n    tags.array_api_support = solver not in [\"arpack\", \"randomized\"] or (\n        solver == \"randomized\" and self.power_iteration_normalizer == \"QR\"\n    )\n    tags.input_tags.sparse = self.svd_solver in (\n        \"auto\",\n        \"arpack\",\n        \"covariance_eigh\",\n    )\n    return tags",
    "scikit-learn.sklearn.decomposition._sparse_pca.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.decomposition._truncated_svd.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.discriminant_analysis.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.array_api_support = True\n    return tags",
    "scikit-learn.sklearn.dummy.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.regressor_tags.poor_score = True\n    tags.no_validation = True\n    return tags",
    "scikit-learn.sklearn.ensemble._forest.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.ensemble._iforest.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = True\n    return tags",
    "scikit-learn.sklearn.ensemble._voting.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = []\n    return tags",
    "scikit-learn.sklearn.feature_extraction._dict_vectorizer.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.dict = True\n    tags.input_tags.two_d_array = False\n    return tags",
    "scikit-learn.sklearn.feature_extraction._hash.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.two_d_array = False\n    if self.input_type == \"string\":\n        tags.input_tags.string = True\n    elif self.input_type == \"dict\":\n        tags.input_tags.dict = True\n    tags.requires_fit = False\n    return tags",
    "scikit-learn.sklearn.feature_extraction.image.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.two_d_array = False\n    tags.input_tags.three_d_array = True\n    tags.requires_fit = False\n    return tags",
    "scikit-learn.sklearn.feature_extraction.text.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.string = True\n    tags.input_tags.two_d_array = False\n    tags.requires_fit = False\n    return tags",
    "scikit-learn.sklearn.feature_selection._from_model.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = get_tags(self.estimator).input_tags.sparse\n    tags.input_tags.allow_nan = get_tags(self.estimator).input_tags.allow_nan\n    return tags",
    "scikit-learn.sklearn.feature_selection._rfe.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    sub_estimator_tags = get_tags(self.estimator)\n    tags.estimator_type = sub_estimator_tags.estimator_type\n    tags.classifier_tags = deepcopy(sub_estimator_tags.classifier_tags)\n    tags.regressor_tags = deepcopy(sub_estimator_tags.regressor_tags)\n    if tags.classifier_tags is not None:\n        tags.classifier_tags.poor_score = True\n    if tags.regressor_tags is not None:\n        tags.regressor_tags.poor_score = True\n    tags.target_tags.required = True\n    tags.input_tags.sparse = sub_estimator_tags.input_tags.sparse\n    tags.input_tags.allow_nan = sub_estimator_tags.input_tags.allow_nan\n    return tags",
    "scikit-learn.sklearn.feature_selection._sequential.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = get_tags(self.estimator).input_tags.allow_nan\n    tags.input_tags.sparse = get_tags(self.estimator).input_tags.sparse\n    return tags",
    "scikit-learn.sklearn.feature_selection._univariate_selection.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.target_tags.required = False\n    return tags",
    "scikit-learn.sklearn.feature_selection._variance_threshold.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = True\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.frozen._frozen.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = deepcopy(get_tags(self.estimator))\n    tags._skip_test = True\n    return tags",
    "scikit-learn.sklearn.gaussian_process._gpr.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.requires_fit = False\n    return tags",
    "scikit-learn.sklearn.impute._base.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.input_tags.allow_nan = is_pandas_na(self.missing_values) or is_scalar_nan(\n        self.missing_values\n    )\n    return tags",
    "scikit-learn.sklearn.isotonic.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.one_d_array = True\n    tags.input_tags.two_d_array = False\n    return tags",
    "scikit-learn.sklearn.kernel_approximation.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.requires_fit = False\n    tags.input_tags.positive_only = True\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.kernel_ridge.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.input_tags.pairwise = self.kernel == \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.linear_model._base.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = not self.positive\n    return tags",
    "scikit-learn.sklearn.linear_model._coordinate_descent.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.target_tags.single_output = False\n    return tags",
    "scikit-learn.sklearn.linear_model._glm.glm.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    try:\n        # Create instance of BaseLoss if fit wasn't called yet. This is necessary as\n        # TweedieRegressor might set the used loss during fit different from\n        # self._base_loss.\n        base_loss = self._get_loss()\n        tags.target_tags.positive_only = not base_loss.in_y_true_range(-1.0)\n    except (ValueError, AttributeError, TypeError):\n        # This happens when the link or power parameter of TweedieRegressor is\n        # invalid. We fallback on the default tags in that case.\n        pass  # pragma: no cover\n    return tags",
    "scikit-learn.sklearn.linear_model._huber.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.linear_model._least_angle.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.target_tags.multi_output = False\n    return tags",
    "scikit-learn.sklearn.linear_model._logistic.__sklearn_tags__": "# Could not extract code for scikit-learn.sklearn.linear_model._logistic.__sklearn_tags__",
    "scikit-learn.sklearn.linear_model._quantile.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.linear_model._ransac.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    if self.estimator is None:\n        tags.input_tags.sparse = True  # default estimator is LinearRegression\n    else:\n        tags.input_tags.sparse = get_tags(self.estimator).input_tags.sparse\n    return tags",
    "scikit-learn.sklearn.linear_model._ridge.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    # Required since this is neither a RegressorMixin nor a ClassifierMixin\n    tags.target_tags.required = True\n    return tags",
    "scikit-learn.sklearn.linear_model._stochastic_gradient.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.manifold._classical_mds.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.pairwise = self.metric == \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.manifold._isomap.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.manifold._mds.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.pairwise = (self.dissimilarity == \"precomputed\") | (\n        self.metric == \"precomputed\"\n    )\n    return tags",
    "scikit-learn.sklearn.manifold._spectral_embedding.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.input_tags.pairwise = self.affinity in [\n        \"precomputed\",\n        \"precomputed_nearest_neighbors\",\n    ]\n    return tags",
    "scikit-learn.sklearn.manifold._t_sne.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.pairwise = self.metric == \"precomputed\"\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.mixture._gaussian_mixture.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.array_api_support = (\n        self.init_params in [\"random\", \"random_from_data\"] and not self.warm_start\n    )\n    return tags",
    "scikit-learn.sklearn.model_selection._classification_threshold.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.classifier_tags.multi_class = False\n    tags.input_tags.sparse = get_tags(self.estimator).input_tags.sparse\n    return tags",
    "scikit-learn.sklearn.model_selection._search.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    sub_estimator_tags = get_tags(self.estimator)\n    tags.estimator_type = sub_estimator_tags.estimator_type\n    tags.classifier_tags = deepcopy(sub_estimator_tags.classifier_tags)\n    tags.regressor_tags = deepcopy(sub_estimator_tags.regressor_tags)\n    # allows cross-validation to see 'precomputed' metrics\n    tags.input_tags.pairwise = sub_estimator_tags.input_tags.pairwise\n    tags.input_tags.sparse = sub_estimator_tags.input_tags.sparse\n    tags.array_api_support = sub_estimator_tags.array_api_support\n    return tags",
    "scikit-learn.sklearn.multiclass.__sklearn_tags__": "def __sklearn_tags__(self):\n    \"\"\"Indicate if wrapped estimator is using a precomputed Gram matrix\"\"\"\n    tags = super().__sklearn_tags__()\n    tags.input_tags.pairwise = get_tags(self.estimator).input_tags.pairwise\n    tags.input_tags.sparse = get_tags(self.estimator).input_tags.sparse\n    return tags",
    "scikit-learn.sklearn.multioutput.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    # FIXME\n    tags._skip_test = True\n    return tags",
    "scikit-learn.sklearn.naive_bayes.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.positive_only = True\n    return tags",
    "scikit-learn.sklearn.neighbors._base.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = self.metric == \"nan_euclidean\"\n    return tags",
    "scikit-learn.sklearn.neighbors._classification.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.classifier_tags.multi_label = True\n    return tags",
    "scikit-learn.sklearn.neighbors._nca.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.target_tags.required = True\n    return tags",
    "scikit-learn.sklearn.neighbors._nearest_centroid.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = self.metric == \"nan_euclidean\"\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.neighbors._regression.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    # For cross-validation routines to split data correctly\n    tags.input_tags.pairwise = self.metric == \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.neural_network._multilayer_perceptron.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.classifier_tags.multi_label = True\n    return tags",
    "scikit-learn.sklearn.neural_network._rbm.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    return tags",
    "scikit-learn.sklearn.pipeline.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    try:\n        tags.input_tags.sparse = all(\n            get_tags(trans).input_tags.sparse\n            for name, trans in self.transformer_list\n            if trans not in {\"passthrough\", \"drop\"}\n        )\n    except Exception:\n        # If `transformer_list` does not comply with our API (list of tuples)\n        # then it will fail. In this case, we assume that `sparse` is False\n        # but the parameter validation will raise an error during `fit`.\n        pass  # pragma: no cover\n    return tags",
    "scikit-learn.sklearn.preprocessing._data.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.allow_nan = True\n    tags.array_api_support = True\n    return tags",
    "scikit-learn.sklearn.preprocessing._encoders.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.categorical = True\n    tags.input_tags.allow_nan = True\n    return tags",
    "scikit-learn.sklearn.preprocessing._function_transformer.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.no_validation = not self.validate\n    tags.requires_fit = False\n    tags.input_tags.sparse = not self.validate or self.accept_sparse\n    return tags",
    "scikit-learn.sklearn.preprocessing._label.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.two_d_array = False\n    tags.target_tags.one_d_labels = True\n    return tags",
    "scikit-learn.sklearn.preprocessing._polynomial.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    tags.array_api_support = True\n    return tags",
    "scikit-learn.sklearn.preprocessing._target_encoder.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.target_tags.required = True\n    return tags",
    "scikit-learn.sklearn.random_projection.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.transformer_tags.preserves_dtype = [\"float64\", \"float32\"]\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.semi_supervised._label_propagation.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.semi_supervised._self_training.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = get_tags(self.estimator).input_tags.sparse\n    return tags",
    "scikit-learn.sklearn.svm._base.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = self.kernel != \"precomputed\"\n    return tags",
    "scikit-learn.sklearn.svm._classes.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags.input_tags.sparse = True\n    return tags",
    "scikit-learn.sklearn.tree._classes.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    # XXX: nan is only supported for dense arrays, but we set this for the\n    # common test to pass, specifically: check_estimators_nan_inf\n    allow_nan = self.splitter == \"random\" and self.criterion in {\n        \"squared_error\",\n        \"friedman_mse\",\n        \"poisson\",\n    }\n    tags.input_tags.allow_nan = allow_nan\n    return tags",
    "scikit-learn.sklearn.utils._mocking.__sklearn_tags__": "def __sklearn_tags__(self):\n    tags = super().__sklearn_tags__()\n    tags._skip_test = True\n    tags.input_tags.two_d_array = False\n    tags.target_tags.one_d_labels = True\n    return tags"
}