{
    "matplotlib.lib.matplotlib.tri._triinterpolate._safe_inv22_vectorized": "def _safe_inv22_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) matrices, returns 0 for rank-deficient\n    matrices.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    _api.check_shape((None, 2, 2), M=M)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n\n    # We set delta_inv to 0. in case of a rank deficient matrix; a\n    # rank-deficient input matrix *M* will lead to a null matrix in output\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        delta_inv = 1./delta\n    else:\n        # 'Pathologic' flow.\n        delta_inv = np.zeros(M.shape[0])\n        delta_inv[rank2] = 1./delta[rank2]\n\n    M_inv[:, 0, 0] = M[:, 1, 1]*delta_inv\n    M_inv[:, 0, 1] = -M[:, 0, 1]*delta_inv\n    M_inv[:, 1, 0] = -M[:, 1, 0]*delta_inv\n    M_inv[:, 1, 1] = M[:, 0, 0]*delta_inv\n    return M_inv",
    "matplotlib.lib.matplotlib.tri._triinterpolate._to_matrix_vectorized": "def _to_matrix_vectorized(M):\n    \"\"\"\n    Build an array of matrices from individuals np.arrays of identical shapes.\n\n    Parameters\n    ----------\n    M\n        ncols-list of nrows-lists of shape sh.\n\n    Returns\n    -------\n    M_res : np.array of shape (sh, nrow, ncols)\n        *M_res* satisfies ``M_res[..., i, j] = M[i][j]``.\n    \"\"\"\n    assert isinstance(M, (tuple, list))\n    assert all(isinstance(item, (tuple, list)) for item in M)\n    c_vec = np.asarray([len(item) for item in M])\n    assert np.all(c_vec-c_vec[0] == 0)\n    r = len(M)\n    c = c_vec[0]\n    M00 = np.asarray(M[0][0])\n    dt = M00.dtype\n    sh = [M00.shape[0], r, c]\n    M_ret = np.empty(sh, dtype=dt)\n    for irow in range(r):\n        for icol in range(c):\n            M_ret[:, irow, icol] = np.asarray(M[irow][icol])\n    return M_ret"
}