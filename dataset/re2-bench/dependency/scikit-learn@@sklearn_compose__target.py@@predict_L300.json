{
    "scikit-learn.sklearn.linear_model._base.predict": "def predict(self, X):\n    \"\"\"\n    Predict using the linear model.\n\n    Parameters\n    ----------\n    X : array-like or sparse matrix, shape (n_samples, n_features)\n        Samples.\n\n    Returns\n    -------\n    C : array, shape (n_samples,)\n        Returns predicted values.\n    \"\"\"\n    return self._decision_function(X)",
    "scikit-learn.sklearn.preprocessing._data.inverse_transform": "def inverse_transform(self, X, copy=None):\n    \"\"\"Scale back the data to the original representation.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data used to scale along the features axis.\n\n    copy : bool, default=None\n        Copy the input `X` or not.\n\n    Returns\n    -------\n    X_original : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Transformed array.\n    \"\"\"\n    xp, _, X_device = get_namespace_and_device(X)\n    check_is_fitted(self)\n\n    copy = copy if copy is not None else self.copy\n    X = check_array(\n        X,\n        accept_sparse=\"csr\",\n        copy=copy,\n        dtype=supported_float_dtypes(xp, X_device),\n        force_writeable=True,\n        ensure_all_finite=\"allow-nan\",\n    )\n\n    if sparse.issparse(X):\n        if self.with_mean:\n            raise ValueError(\n                \"Cannot uncenter sparse matrices: pass `with_mean=False` \"\n                \"instead See docstring for motivation and alternatives.\"\n            )\n        if self.scale_ is not None:\n            inplace_column_scale(X, self.scale_)\n    else:\n        if self.with_std:\n            X *= xp.astype(self.scale_, X.dtype)\n        if self.with_mean:\n            X += xp.astype(self.mean_, X.dtype)\n    return X",
    "scikit-learn.sklearn.preprocessing._function_transformer.inverse_transform": "def inverse_transform(self, X):\n    \"\"\"Transform X using the inverse function.\n\n    Parameters\n    ----------\n    X : {array-like, sparse-matrix} of shape (n_samples, n_features) \\\n            if `validate=True` else any object that `inverse_func` can handle\n        Input array.\n\n    Returns\n    -------\n    X_original : array-like, shape (n_samples, n_features)\n        Transformed input.\n    \"\"\"\n    if self.validate:\n        X = check_array(X, accept_sparse=self.accept_sparse)\n    return self._transform(X, func=self.inverse_func, kw_args=self.inv_kw_args)",
    "scikit-learn.sklearn.utils._bunch.__init__": "def __init__(self, **kwargs):\n    super().__init__(kwargs)\n\n    # Map from deprecated key to warning message\n    self.__dict__[\"_deprecated_key_to_warnings\"] = {}",
    "scikit-learn.sklearn.utils._bunch.__getattr__": "def __getattr__(self, key):\n    try:\n        return self[key]\n    except KeyError:\n        raise AttributeError(key)",
    "scikit-learn.sklearn.utils._metadata_requests.process_routing": "def process_routing(_obj, _method, /, **kwargs):\n    \"\"\"Validate and route metadata.\n\n    This function is used inside a :term:`router`'s method, e.g. :term:`fit`,\n    to validate the metadata and handle the routing.\n\n    Assuming this signature of a router's fit method:\n    ``fit(self, X, y, sample_weight=None, **fit_params)``,\n    a call to this function would be:\n    ``process_routing(self, \"fit\", sample_weight=sample_weight, **fit_params)``.\n\n    Note that if routing is not enabled and ``kwargs`` is empty, then it\n    returns an empty routing where ``process_routing(...).ANYTHING.ANY_METHOD``\n    is always an empty dictionary.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    _obj : object\n        An object implementing ``get_metadata_routing``. Typically a\n        :term:`meta-estimator`.\n\n    _method : str\n        The name of the router's method in which this function is called.\n\n    **kwargs : dict\n        Metadata to be routed.\n\n    Returns\n    -------\n    routed_params : Bunch\n        A :class:`~utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        A :class:`~sklearn.utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        corresponding methods or corresponding child objects. The object names\n        are those defined in `obj.get_metadata_routing()`.\n    \"\"\"\n    if not kwargs:\n        # If routing is not enabled and kwargs are empty, then we don't have to\n        # try doing any routing, we can simply return a structure which returns\n        # an empty dict on routed_params.ANYTHING.ANY_METHOD.\n        class EmptyRequest:\n            def get(self, name, default=None):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getitem__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getattr__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n        return EmptyRequest()\n\n    if not (hasattr(_obj, \"get_metadata_routing\") or isinstance(_obj, MetadataRouter)):\n        raise AttributeError(\n            f\"The given object ({_routing_repr(_obj)}) needs to either\"\n            \" implement the routing method `get_metadata_routing` or be a\"\n            \" `MetadataRouter` instance.\"\n        )\n    if _method not in METHODS:\n        raise TypeError(\n            f\"Can only route and process input on these methods: {METHODS}, \"\n            f\"while the passed method is: {_method}.\"\n        )\n\n    request_routing = get_routing_for_object(_obj)\n    request_routing.validate_metadata(params=kwargs, method=_method)\n    routed_params = request_routing.route_params(params=kwargs, caller=_method)\n\n    return routed_params",
    "scikit-learn.sklearn.utils._metadata_requests._routing_enabled": "def _routing_enabled():\n    \"\"\"Return whether metadata routing is enabled.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    enabled : bool\n        Whether metadata routing is enabled. If the config is not set, it\n        defaults to False.\n    \"\"\"\n    return get_config().get(\"enable_metadata_routing\", False)",
    "scikit-learn.sklearn.utils._metadata_requests.__getattr__": "def __getattr__(self, name):\n    return Bunch(**{method: dict() for method in METHODS})",
    "scikit-learn.sklearn.utils.validation.check_is_fitted": "def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):\n    \"\"\"Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by verifying the presence of\n    fitted attributes (ending with a trailing underscore) and otherwise\n    raises a :class:`~sklearn.exceptions.NotFittedError` with the given message.\n\n    If an estimator does not set any attributes with a trailing underscore, it\n    can define a ``__sklearn_is_fitted__`` method returning a boolean to\n    specify if the estimator is fitted or not. See\n    :ref:`sphx_glr_auto_examples_developing_estimators_sklearn_is_fitted.py`\n    for an example on how to use the API.\n\n    If no `attributes` are passed, this function will pass if an estimator is stateless.\n    An estimator can indicate it's stateless by setting the `requires_fit` tag. See\n    :ref:`estimator_tags` for more information. Note that the `requires_fit` tag\n    is ignored if `attributes` are passed.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator instance for which the check is performed.\n\n    attributes : str, list or tuple of str, default=None\n        Attribute name(s) given as string or a list/tuple of strings\n        Eg.: ``[\"coef_\", \"estimator_\", ...], \"coef_\"``\n\n        If `None`, `estimator` is considered fitted if there exist an\n        attribute that ends with a underscore and does not start with double\n        underscore.\n\n    msg : str, default=None\n        The default error message is, \"This %(name)s instance is not fitted\n        yet. Call 'fit' with appropriate arguments before using this\n        estimator.\"\n\n        For custom messages if \"%(name)s\" is present in the message string,\n        it is substituted for the estimator name.\n\n        Eg. : \"Estimator, %(name)s, must be fitted before sparsifying\".\n\n    all_or_any : callable, {all, any}, default=all\n        Specify whether all or any of the given attributes must exist.\n\n    Raises\n    ------\n    TypeError\n        If the estimator is a class or not an estimator instance\n\n    NotFittedError\n        If the attributes are not found.\n\n    Examples\n    --------\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.utils.validation import check_is_fitted\n    >>> from sklearn.exceptions import NotFittedError\n    >>> lr = LogisticRegression()\n    >>> try:\n    ...     check_is_fitted(lr)\n    ... except NotFittedError as exc:\n    ...     print(f\"Model is not fitted yet.\")\n    Model is not fitted yet.\n    >>> lr.fit([[1, 2], [1, 3]], [1, 0])\n    LogisticRegression()\n    >>> check_is_fitted(lr)\n    \"\"\"\n    if isclass(estimator):\n        raise TypeError(\"{} is a class, not an instance.\".format(estimator))\n    if msg is None:\n        msg = (\n            \"This %(name)s instance is not fitted yet. Call 'fit' with \"\n            \"appropriate arguments before using this estimator.\"\n        )\n\n    if not hasattr(estimator, \"fit\"):\n        raise TypeError(\"%s is not an estimator instance.\" % (estimator))\n\n    tags = get_tags(estimator)\n\n    if not tags.requires_fit and attributes is None:\n        return\n\n    if not _is_fitted(estimator, attributes, all_or_any):\n        raise NotFittedError(msg % {\"name\": type(estimator).__name__})"
}