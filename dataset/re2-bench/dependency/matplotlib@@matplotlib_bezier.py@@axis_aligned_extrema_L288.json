{
    "matplotlib.lib.matplotlib.bezier.degree": "@property\ndef degree(self):\n    \"\"\"Degree of the polynomial. One less the number of control points.\"\"\"\n    return self._N - 1",
    "matplotlib.lib.matplotlib.bezier.polynomial_coefficients": "@property\ndef polynomial_coefficients(self):\n    r\"\"\"\n    The polynomial coefficients of the B\u00e9zier curve.\n\n    .. warning:: Follows opposite convention from `numpy.polyval`.\n\n    Returns\n    -------\n    (n+1, d) array\n        Coefficients after expanding in polynomial basis, where :math:`n`\n        is the degree of the B\u00e9zier curve and :math:`d` its dimension.\n        These are the numbers (:math:`C_j`) such that the curve can be\n        written :math:`\\sum_{j=0}^n C_j t^j`.\n\n    Notes\n    -----\n    The coefficients are calculated as\n\n    .. math::\n\n        {n \\choose j} \\sum_{i=0}^j (-1)^{i+j} {j \\choose i} P_i\n\n    where :math:`P_i` are the control points of the curve.\n    \"\"\"\n    n = self.degree\n    # matplotlib uses n <= 4. overflow plausible starting around n = 15.\n    if n > 10:\n        warnings.warn(\"Polynomial coefficients formula unstable for high \"\n                      \"order Bezier curves!\", RuntimeWarning)\n    P = self.control_points\n    j = np.arange(n+1)[:, None]\n    i = np.arange(n+1)[None, :]  # _comb is non-zero for i <= j\n    prefactor = (-1)**(i + j) * _comb(j, i)  # j on axis 0, i on axis 1\n    return _comb(n, j) * prefactor @ P  # j on axis 0, self.dimension on 1"
}