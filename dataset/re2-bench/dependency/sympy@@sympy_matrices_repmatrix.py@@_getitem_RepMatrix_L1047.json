{
    "sympy.sympy.core.containers.__len__": "def __len__(self):\n    return len(self.args)",
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.numbers.__rdivmod__": "def __rdivmod__(self, other):\n    if isinstance(other, int) and global_parameters.evaluate:\n        return Tuple(*(divmod(other, self.p)))\n    else:\n        try:\n            other = Number(other)\n        except TypeError:\n            msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n            oname = type(other).__name__\n            sname = type(self).__name__\n            raise TypeError(msg % (oname, sname))\n        return Number.__divmod__(other, self)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    "sympy.sympy.core.numbers.__index__": "def __index__(self):\n    return self.p",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, name, n, m):\n    n, m = map(_sympify, (n, m))\n    if isinstance(name, str):\n        name = Symbol(name)\n    else:\n        if isinstance(name, MatrixBase):\n            if n.is_Integer and m.is_Integer:\n                return name[n, m]\n            name = _sympify(name)  # change mutable into immutable\n        else:\n            name = _sympify(name)\n            if not isinstance(name.kind, MatrixKind):\n                raise TypeError(\"First argument of MatrixElement should be a matrix\")\n        if not getattr(name, 'valid_index', lambda n, m: True)(n, m):\n            raise IndexError('indices out of range')\n    obj = Expr.__new__(cls, name, n, m)\n    return obj",
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.immutable.shape": "@property\ndef shape(self):\n    return self._rows, self._cols",
    "sympy.sympy.matrices.matrixbase.shape": "@property\ndef shape(self) -> tuple[int, int]:\n    \"\"\"The shape (dimensions) of the matrix as the 2-tuple (rows, cols).\n\n    Examples\n    ========\n\n    >>> from sympy import zeros\n    >>> M = zeros(2, 3)\n    >>> M.shape\n    (2, 3)\n    >>> M.rows\n    2\n    >>> M.cols\n    3\n    \"\"\"\n    return (self.rows, self.cols)",
    "sympy.sympy.matrices.matrixbase.extract": "def extract(self, rowsList: Sequence[int], colsList: Sequence[int], /) -> Self:\n    r\"\"\"Return a submatrix by specifying a list of rows and columns.\n    Negative indices can be given. All indices must be in the range\n    $-n \\le i < n$ where $n$ is the number of rows or columns.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> m = Matrix(4, 3, range(12))\n    >>> m\n    Matrix([\n    [0,  1,  2],\n    [3,  4,  5],\n    [6,  7,  8],\n    [9, 10, 11]])\n    >>> m.extract([0, 1, 3], [0, 1])\n    Matrix([\n    [0,  1],\n    [3,  4],\n    [9, 10]])\n\n    Rows or columns can be repeated:\n\n    >>> m.extract([0, 0, 1], [-1])\n    Matrix([\n    [2],\n    [2],\n    [5]])\n\n    Every other row can be taken by using range to provide the indices:\n\n    >>> m.extract(range(0, m.rows, 2), [-1])\n    Matrix([\n    [2],\n    [8]])\n\n    RowsList or colsList can also be a list of booleans, in which case\n    the rows or columns corresponding to the True values will be selected:\n\n    >>> m.extract([0, 1, 2, 3], [True, False, True])\n    Matrix([\n    [0,  2],\n    [3,  5],\n    [6,  8],\n    [9, 11]])\n    \"\"\"\n\n    if not is_sequence(rowsList) or not is_sequence(colsList):\n        raise TypeError(\"rowsList and colsList must be iterable\")\n    # ensure rowsList and colsList are lists of integers\n    if rowsList and all(isinstance(i, bool) for i in rowsList):\n        rowsList = [index for index, item in enumerate(rowsList) if item]\n    if colsList and all(isinstance(i, bool) for i in colsList):\n        colsList = [index for index, item in enumerate(colsList) if item]\n\n    # ensure everything is in range\n    rowsList = [a2idx(k, self.rows) for k in rowsList]\n    colsList = [a2idx(k, self.cols) for k in colsList]\n\n    return self._eval_extract(rowsList, colsList)",
    "sympy.sympy.matrices.repmatrix.<listcomp>": "values = [to_sympy(val) for val in values]\n\n",
    "sympy.sympy.polys.domains.domain.__ne__": "def __ne__(self, other):\n    \"\"\"Returns ``False`` if two domains are equivalent. \"\"\"\n    return not self == other",
    "sympy.sympy.polys.matrices.domainmatrix.getitem_sympy": "def getitem_sympy(self, i, j):\n    return self.domain.to_sympy(self.rep.getitem(i, j))",
    "sympy.sympy.polys.matrices.sdm.getitem": "def getitem(self, i, j):\n    try:\n        return self[i][j]\n    except KeyError:\n        m, n = self.shape\n        if -m <= i < m and -n <= j < n:\n            try:\n                return self[i % m][j % n]\n            except KeyError:\n                return self.domain.zero\n        else:\n            raise IndexError(\"index out of range\")",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))"
}