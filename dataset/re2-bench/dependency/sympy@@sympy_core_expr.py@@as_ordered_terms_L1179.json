{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.expr._parse_order": "@classmethod\ndef _parse_order(cls, order):\n    \"\"\"Parse and configure the ordering of terms. \"\"\"\n    from sympy.polys.orderings import monomial_key\n\n    startswith = getattr(order, \"startswith\", None)\n    if startswith is None:\n        reverse = False\n    else:\n        reverse = startswith('rev-')\n        if reverse:\n            order = order[4:]\n\n    monom_key = monomial_key(order)\n\n    def neg(monom):\n        return tuple([neg(m) if isinstance(m, tuple) else -m for m in monom])\n\n    def key(term):\n        _, ((re, im), monom, ncpart) = term\n\n        monom = neg(monom_key(monom))\n        ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n        coeff = ((bool(im), im), (re, im))\n\n        return monom, ncpart, coeff\n\n    return key, reverse",
    "sympy.sympy.core.expr.key": "def key(term):\n    _, ((re, im), monom, ncpart) = term\n\n    monom = neg(monom_key(monom))\n    ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n    coeff = ((bool(im), im), (re, im))\n\n    return monom, ncpart, coeff",
    "sympy.sympy.core.expr.<lambda>": "key = lambda x:not isinstance(x, (Number, NumberSymbol))\n",
    "sympy.sympy.core.expr.<genexpr>": "if not any(term.is_Order for term, _ in terms):\n    ordered = sorted(terms, key=key, reverse=reverse)\n",
    "sympy.sympy.core.expr.<listcomp>": "return [term for term, _ in ordered]\n\n",
    "sympy.sympy.core.expr.as_terms": "def as_terms(self) -> tuple[list[tuple[Expr, Any]], list[Expr]]:\n    \"\"\"Transform an expression to a list of terms. \"\"\"\n    from .exprtools import decompose_power\n\n    gens_set, terms = set(), []\n\n    for term in Add.make_args(self):\n        coeff, _term = term.as_coeff_Mul()\n\n        coeff_complex = complex(coeff)\n        cpart, ncpart = {}, []\n\n        if _term is not S.One:\n            for factor in Mul.make_args(_term):\n                if factor.is_number:\n                    try:\n                        coeff_complex *= complex(factor)\n                    except (TypeError, ValueError):\n                        pass\n                    else:\n                        continue\n\n                if factor.is_commutative:\n                    base, exp = decompose_power(factor)\n\n                    cpart[base] = exp\n                    gens_set.add(base)\n                else:\n                    ncpart.append(factor)\n\n        coeff_tuple = coeff_complex.real, coeff_complex.imag\n        ncpart_tuple = tuple(ncpart)\n\n        terms.append((term, (coeff_tuple, cpart, ncpart_tuple)))\n\n    gens = sorted(gens_set, key=default_sort_key)\n\n    k, indices = len(gens), {}\n\n    for i, g in enumerate(gens):\n        indices[g] = i\n\n    result = []\n\n    for term, (coeff_tuple, cpart, ncpart_tuple) in terms:\n        monom = [0]*k\n\n        for base, exp in cpart.items():\n            monom[indices[base]] = exp\n\n        result.append((term, (coeff_tuple, tuple(monom), ncpart_tuple)))\n\n    return result, gens",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.utilities.iterables._sift_true_false": "def _sift_true_false(seq: Iterable[T], keyfunc: Callable[[T], bool]) -> tuple[list[T], list[T]]:\n    \"\"\"Sift iterable for items with keyfunc(item) = True/False.\"\"\"\n    true: list[T] = []\n    false: list[T] = []\n    for i in seq:\n        if keyfunc(i):\n            true.append(i)\n        else:\n            false.append(i)\n    return true, false"
}