{
    "scikit-learn.sklearn.calibration.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = (\n        MetadataRouter(owner=self)\n        .add_self_request(self)\n        .add(\n            estimator=self._get_estimator(),\n            method_mapping=MethodMapping().add(caller=\"fit\", callee=\"fit\"),\n        )\n        .add(\n            splitter=self.cv,\n            method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n        )\n    )\n    return router",
    "scikit-learn.sklearn.compose._column_transformer.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n    # Here we don't care about which columns are used for which\n    # transformers, and whether or not a transformer is used at all, which\n    # might happen if no columns are selected for that transformer. We\n    # request all metadata requested by all transformers.\n    transformers = self.transformers\n    if self.remainder not in (\"drop\", \"passthrough\"):\n        transformers = chain(transformers, [(\"remainder\", self.remainder, None)])\n    for name, step, _ in transformers:\n        method_mapping = MethodMapping()\n        if hasattr(step, \"fit_transform\"):\n            (\n                method_mapping.add(caller=\"fit\", callee=\"fit_transform\").add(\n                    caller=\"fit_transform\", callee=\"fit_transform\"\n                )\n            )\n        else:\n            (\n                method_mapping.add(caller=\"fit\", callee=\"fit\")\n                .add(caller=\"fit\", callee=\"transform\")\n                .add(caller=\"fit_transform\", callee=\"fit\")\n                .add(caller=\"fit_transform\", callee=\"transform\")\n            )\n        method_mapping.add(caller=\"transform\", callee=\"transform\")\n        router.add(method_mapping=method_mapping, **{name: step})\n\n    return router",
    "scikit-learn.sklearn.compose._target.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.6\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        regressor=self._get_regressor(),\n        method_mapping=MethodMapping()\n        .add(caller=\"fit\", callee=\"fit\")\n        .add(caller=\"predict\", callee=\"predict\"),\n    )\n    return router",
    "scikit-learn.sklearn.covariance._graph_lasso.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        splitter=check_cv(self.cv),\n        method_mapping=MethodMapping().add(callee=\"split\", caller=\"fit\"),\n    )\n    return router",
    "scikit-learn.sklearn.ensemble._bagging.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n\n    method_mapping = MethodMapping()\n    method_mapping.add(caller=\"fit\", callee=\"fit\").add(\n        caller=\"decision_function\", callee=\"decision_function\"\n    )\n\n    # the router needs to be built depending on whether the sub-estimator has a\n    # `predict_proba` method (as BaggingClassifier decides dynamically at runtime):\n    if hasattr(self._get_estimator(), \"predict_proba\"):\n        (\n            method_mapping.add(caller=\"predict\", callee=\"predict_proba\").add(\n                caller=\"predict_proba\", callee=\"predict_proba\"\n            )\n        )\n\n    else:\n        (\n            method_mapping.add(caller=\"predict\", callee=\"predict\").add(\n                caller=\"predict_proba\", callee=\"predict\"\n            )\n        )\n\n    # the router needs to be built depending on whether the sub-estimator has a\n    # `predict_log_proba` method (as BaggingClassifier decides dynamically at\n    # runtime):\n    if hasattr(self._get_estimator(), \"predict_log_proba\"):\n        method_mapping.add(caller=\"predict_log_proba\", callee=\"predict_log_proba\")\n\n    else:\n        # if `predict_log_proba` is not available in BaggingClassifier's\n        # sub-estimator, the routing should go to its `predict_proba` if it is\n        # available or else to its `predict` method; according to how\n        # `sample_weight` is passed to the respective methods dynamically at\n        # runtime:\n        if hasattr(self._get_estimator(), \"predict_proba\"):\n            method_mapping.add(caller=\"predict_log_proba\", callee=\"predict_proba\")\n\n        else:\n            method_mapping.add(caller=\"predict_log_proba\", callee=\"predict\")\n\n    router.add(estimator=self._get_estimator(), method_mapping=method_mapping)\n    return router",
    "scikit-learn.sklearn.ensemble._stacking.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.6\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n\n    # `self.estimators` is a list of (name, est) tuples\n    for name, estimator in self.estimators:\n        router.add(\n            **{name: estimator},\n            method_mapping=MethodMapping().add(callee=\"fit\", caller=\"fit\"),\n        )\n\n    try:\n        final_estimator_ = self.final_estimator_\n    except AttributeError:\n        final_estimator_ = self.final_estimator\n\n    router.add(\n        final_estimator_=final_estimator_,\n        method_mapping=MethodMapping().add(caller=\"predict\", callee=\"predict\"),\n    )\n\n    return router",
    "scikit-learn.sklearn.ensemble._voting.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n\n    # `self.estimators` is a list of (name, est) tuples\n    for name, estimator in self.estimators:\n        router.add(\n            **{name: estimator},\n            method_mapping=MethodMapping().add(callee=\"fit\", caller=\"fit\"),\n        )\n    return router",
    "scikit-learn.sklearn.feature_selection._from_model.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping()\n        .add(caller=\"partial_fit\", callee=\"partial_fit\")\n        .add(caller=\"fit\", callee=\"fit\"),\n    )\n    return router",
    "scikit-learn.sklearn.feature_selection._rfe.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.6\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n    router.add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"fit\"),\n    )\n    router.add(\n        splitter=check_cv(self.cv),\n        method_mapping=MethodMapping().add(\n            caller=\"fit\",\n            callee=\"split\",\n        ),\n    )\n    router.add(\n        scorer=self._get_scorer(),\n        method_mapping=MethodMapping()\n        .add(caller=\"fit\", callee=\"score\")\n        .add(caller=\"score\", callee=\"score\"),\n    )\n\n    return router",
    "scikit-learn.sklearn.feature_selection._sequential.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.6\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n    router.add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"fit\"),\n    )\n    router.add(\n        splitter=check_cv(self.cv, classifier=is_classifier(self.estimator)),\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n    )\n    router.add(\n        scorer=check_scoring(self.estimator, scoring=self.scoring),\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"score\"),\n    )\n    return router",
    "scikit-learn.sklearn.impute._iterative.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping().add(callee=\"fit\", caller=\"fit\"),\n    )\n    return router",
    "scikit-learn.sklearn.linear_model._coordinate_descent.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = (\n        MetadataRouter(owner=self)\n        .add_self_request(self)\n        .add(\n            splitter=check_cv(self.cv),\n            method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n        )\n    )\n    return router",
    "scikit-learn.sklearn.linear_model._least_angle.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        splitter=check_cv(self.cv),\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n    )\n    return router",
    "scikit-learn.sklearn.linear_model._logistic.get_metadata_routing": "# Could not extract code for scikit-learn.sklearn.linear_model._logistic.get_metadata_routing",
    "scikit-learn.sklearn.linear_model._omp.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n\n    router = MetadataRouter(owner=self).add(\n        splitter=self.cv,\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n    )\n    return router",
    "scikit-learn.sklearn.linear_model._ransac.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping()\n        .add(caller=\"fit\", callee=\"fit\")\n        .add(caller=\"fit\", callee=\"score\")\n        .add(caller=\"score\", callee=\"score\")\n        .add(caller=\"predict\", callee=\"predict\"),\n    )\n    return router",
    "scikit-learn.sklearn.linear_model._ridge.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = (\n        MetadataRouter(owner=self)\n        .add_self_request(self)\n        .add(\n            scorer=self._get_scorer(),\n            method_mapping=MethodMapping().add(caller=\"fit\", callee=\"score\"),\n        )\n        .add(\n            splitter=self.cv,\n            method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n        )\n    )\n    return router",
    "scikit-learn.sklearn.metrics._scorer.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get requested data properties.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    return get_routing_for_object(self._estimator)",
    "scikit-learn.sklearn.model_selection._classification_threshold.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = (\n        MetadataRouter(owner=self)\n        .add(\n            estimator=self.estimator,\n            method_mapping=MethodMapping().add(callee=\"fit\", caller=\"fit\"),\n        )\n        .add(\n            splitter=self.cv,\n            method_mapping=MethodMapping().add(callee=\"split\", caller=\"fit\"),\n        )\n        .add(\n            scorer=self._get_curve_scorer(),\n            method_mapping=MethodMapping().add(callee=\"score\", caller=\"fit\"),\n        )\n    )\n    return router",
    "scikit-learn.sklearn.model_selection._search.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n    router.add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"fit\"),\n    )\n\n    scorer, _ = self._get_scorers()\n    router.add(\n        scorer=scorer,\n        method_mapping=MethodMapping()\n        .add(caller=\"score\", callee=\"score\")\n        .add(caller=\"fit\", callee=\"score\"),\n    )\n    router.add(\n        splitter=self.cv,\n        method_mapping=MethodMapping().add(caller=\"fit\", callee=\"split\"),\n    )\n    return router",
    "scikit-learn.sklearn.multiclass.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.4\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n\n    router = (\n        MetadataRouter(owner=self)\n        .add_self_request(self)\n        .add(\n            estimator=self.estimator,\n            method_mapping=MethodMapping()\n            .add(caller=\"fit\", callee=\"fit\")\n            .add(caller=\"partial_fit\", callee=\"partial_fit\"),\n        )\n    )\n    return router",
    "scikit-learn.sklearn.multioutput.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self).add(\n        estimator=self.estimator,\n        method_mapping=MethodMapping()\n        .add(caller=\"partial_fit\", callee=\"partial_fit\")\n        .add(caller=\"fit\", callee=\"fit\"),\n    )\n    return router",
    "scikit-learn.sklearn.pipeline.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.5\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n\n    for name, transformer in self.transformer_list:\n        router.add(\n            **{name: transformer},\n            method_mapping=MethodMapping()\n            .add(caller=\"fit\", callee=\"fit\")\n            .add(caller=\"fit_transform\", callee=\"fit_transform\")\n            .add(caller=\"fit_transform\", callee=\"fit\")\n            .add(caller=\"fit_transform\", callee=\"transform\")\n            .add(caller=\"transform\", callee=\"transform\"),\n        )\n\n    return router",
    "scikit-learn.sklearn.semi_supervised._self_training.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Get metadata routing of this object.\n\n    Please check :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.6\n\n    Returns\n    -------\n    routing : MetadataRouter\n        A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n        routing information.\n    \"\"\"\n    router = MetadataRouter(owner=self)\n    router.add(\n        estimator=self.estimator,\n        method_mapping=(\n            MethodMapping()\n            .add(callee=\"fit\", caller=\"fit\")\n            .add(callee=\"score\", caller=\"fit\")\n            .add(callee=\"predict\", caller=\"predict\")\n            .add(callee=\"predict_proba\", caller=\"predict_proba\")\n            .add(callee=\"decision_function\", caller=\"decision_function\")\n            .add(callee=\"predict_log_proba\", caller=\"predict_log_proba\")\n            .add(callee=\"score\", caller=\"score\")\n        ),\n    )\n    return router",
    "scikit-learn.sklearn.utils._metadata_requests.get_metadata_routing": "def get_metadata_routing(self):\n    \"\"\"Raise `NotImplementedError`.\n\n    This estimator does not support metadata routing yet.\"\"\"\n    raise NotImplementedError(\n        f\"{_routing_repr(self)} has not implemented metadata routing yet.\"\n    )",
    "scikit-learn.sklearn.utils._metadata_requests.__init__": "def __init__(self, owner):\n    self.owner = owner\n    for method in SIMPLE_METHODS:\n        setattr(\n            self,\n            method,\n            MethodMetadataRequest(owner=owner, method=method),\n        )",
    "scikit-learn.sklearn.utils._metadata_requests.__getattr__": "def __getattr__(self, name):\n    # Called when the default attribute access fails with an AttributeError\n    # (either __getattribute__() raises an AttributeError because name is\n    # not an instance attribute or an attribute in the class tree for self;\n    # or __get__() of a name property raises AttributeError). This method\n    # should either return the (computed) attribute value or raise an\n    # AttributeError exception.\n    # https://docs.python.org/3/reference/datamodel.html#object.__getattr__\n    if name not in COMPOSITE_METHODS:\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n        )\n\n    requests = {}\n    for method in COMPOSITE_METHODS[name]:\n        mmr = getattr(self, method)\n        existing = set(requests.keys())\n        upcoming = set(mmr.requests.keys())\n        common = existing & upcoming\n        conflicts = [key for key in common if requests[key] != mmr._requests[key]]\n        if conflicts:\n            raise ValueError(\n                f\"Conflicting metadata requests for {', '.join(conflicts)} while\"\n                f\" composing the requests for {name}. Metadata with the same name\"\n                f\" for methods {', '.join(COMPOSITE_METHODS[name])} should have the\"\n                \" same request value.\"\n            )\n        requests.update(mmr._requests)\n    return MethodMetadataRequest(owner=self.owner, method=name, requests=requests)"
}