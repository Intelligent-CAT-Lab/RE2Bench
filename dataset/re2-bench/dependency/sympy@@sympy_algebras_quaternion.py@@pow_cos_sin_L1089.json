{
    "sympy.sympy.algebras.quaternion.to_axis_angle": "def to_axis_angle(self) -> tuple[tuple[Expr, Expr, Expr], Expr]:\n    \"\"\"Returns the axis and angle of rotation of a quaternion.\n\n    Returns\n    =======\n\n    tuple\n        Tuple of (axis, angle)\n\n    Examples\n    ========\n\n    >>> from sympy import Quaternion\n    >>> q = Quaternion(1, 1, 1, 1)\n    >>> (axis, angle) = q.to_axis_angle()\n    >>> axis\n    (sqrt(3)/3, sqrt(3)/3, sqrt(3)/3)\n    >>> angle\n    2*pi/3\n\n    \"\"\"\n    q = self\n    if q.a.is_negative:\n        q = q * -1\n\n    q = q.normalize()\n    angle = trigsimp(2 * acos(q.a))\n\n    # Since quaternion is normalised, q.a is less than 1.\n    s = sqrt(1 - q.a*q.a)\n\n    x = trigsimp(q.b / s)\n    y = trigsimp(q.c / s)\n    z = trigsimp(q.d / s)\n\n    v = (x, y, z)\n    t = (v, angle)\n\n    return t",
    "sympy.sympy.algebras.quaternion.from_axis_angle": "@classmethod\ndef from_axis_angle(cls, vector: tuple[SExpr, SExpr, SExpr], angle: SExpr) -> Quaternion:\n    \"\"\"Returns a rotation quaternion given the axis and the angle of rotation.\n\n    Parameters\n    ==========\n\n    vector : tuple of three numbers\n        The vector representation of the given axis.\n    angle : number\n        The angle by which axis is rotated (in radians).\n\n    Returns\n    =======\n\n    Quaternion\n        The normalized rotation quaternion calculated from the given axis and the angle of rotation.\n\n    Examples\n    ========\n\n    >>> from sympy import Quaternion\n    >>> from sympy import pi, sqrt\n    >>> q = Quaternion.from_axis_angle((sqrt(3)/3, sqrt(3)/3, sqrt(3)/3), 2*pi/3)\n    >>> q\n    1/2 + 1/2*i + 1/2*j + 1/2*k\n\n    \"\"\"\n    (x, y, z) = vector\n    norm = sqrt(x**2 + y**2 + z**2)\n    (x, y, z) = (x / norm, y / norm, z / norm)\n    s = sin(angle * S.Half)\n    a = cos(angle * S.Half)\n    b = x * s\n    c = y * s\n    d = z * s\n\n    # note that this quaternion is already normalized by construction:\n    # c^2 + (s*x)^2 + (s*y)^2 + (s*z)^2 = c^2 + s^2*(x^2 + y^2 + z^2) = c^2 + s^2 * 1 = c^2 + s^2 = 1\n    # so, what we return is a normalized quaternion\n\n    return cls(a, b, c, d)",
    "sympy.sympy.algebras.quaternion.__mul__": "def __mul__(self, other: SExpr | Quaternion) -> Quaternion:\n    return self._generic_mul(self, _sympify(other))",
    "sympy.sympy.algebras.quaternion.norm": "def norm(self) -> Expr:\n    \"\"\"Returns the norm of the quaternion.\"\"\"\n    if self._norm is None:  # check if norm is pre-defined\n        q = self\n        # trigsimp is used to simplify sin(x)^2 + cos(x)^2 (these terms\n        # arise when from_axis_angle is used).\n        return sqrt(trigsimp(q.a**2 + q.b**2 + q.c**2 + q.d**2))\n\n    return self._norm",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented"
}