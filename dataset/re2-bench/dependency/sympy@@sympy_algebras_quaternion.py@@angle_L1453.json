{
    "sympy.sympy.algebras.quaternion.scalar_part": "def scalar_part(self) -> Expr:\n    r\"\"\"Returns scalar part($\\mathbf{S}(q)$) of the quaternion q.\n\n    Explanation\n    ===========\n\n    Given a quaternion $q = a + bi + cj + dk$, returns $\\mathbf{S}(q) = a$.\n\n    Examples\n    ========\n\n    >>> from sympy.algebras.quaternion import Quaternion\n    >>> q = Quaternion(4, 8, 13, 12)\n    >>> q.scalar_part()\n    4\n\n    \"\"\"\n\n    return self.a",
    "sympy.sympy.algebras.quaternion.vector_part": "def vector_part(self) -> Quaternion:\n    r\"\"\"\n    Returns $\\mathbf{V}(q)$, the vector part of the quaternion $q$.\n\n    Explanation\n    ===========\n\n    Given a quaternion $q = a + bi + cj + dk$, returns $\\mathbf{V}(q) = bi + cj + dk$.\n\n    Examples\n    ========\n\n    >>> from sympy.algebras.quaternion import Quaternion\n    >>> q = Quaternion(1, 1, 1, 1)\n    >>> q.vector_part()\n    0 + 1*i + 1*j + 1*k\n\n    >>> q = Quaternion(4, 8, 13, 12)\n    >>> q.vector_part()\n    0 + 8*i + 13*j + 12*k\n\n    \"\"\"\n\n    return Quaternion(0, self.b, self.c, self.d)",
    "sympy.sympy.algebras.quaternion.norm": "def norm(self) -> Expr:\n    \"\"\"Returns the norm of the quaternion.\"\"\"\n    if self._norm is None:  # check if norm is pre-defined\n        q = self\n        # trigsimp is used to simplify sin(x)^2 + cos(x)^2 (these terms\n        # arise when from_axis_angle is used).\n        return sqrt(trigsimp(q.a**2 + q.b**2 + q.c**2 + q.d**2))\n\n    return self._norm",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)"
}