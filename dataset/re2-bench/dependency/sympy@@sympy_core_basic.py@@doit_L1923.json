{
    "sympy.sympy.codegen.ast.__new__": "def __new__(cls, *args, **kwargs):\n    # Pass through existing instances when given as sole argument\n    if len(args) == 1 and not kwargs and isinstance(args[0], cls):\n        return args[0]\n\n    if len(args) > len(cls._fields):\n        raise ValueError(\"Too many arguments (%d), expected at most %d\" % (len(args), len(cls._fields)))\n\n    attrvals = []\n\n    # Process positional arguments\n    for attrname, argval in zip(cls._fields, args):\n        if attrname in kwargs:\n            raise TypeError('Got multiple values for attribute %r' % attrname)\n\n        attrvals.append(cls._construct(attrname, argval))\n\n    # Process keyword arguments\n    for attrname in cls._fields[len(args):]:\n        if attrname in kwargs:\n            argval = kwargs.pop(attrname)\n\n        elif attrname in cls.defaults:\n            argval = cls.defaults[attrname]\n\n        else:\n            raise TypeError('No value for %r given and attribute has no default' % attrname)\n\n        attrvals.append(cls._construct(attrname, argval))\n\n    if kwargs:\n        raise ValueError(\"Unknown keyword arguments: %s\" % ' '.join(kwargs))\n\n    # Parent constructor\n    basic_args = [\n        val for attr, val in zip(cls._fields, attrvals)\n        if attr not in cls.not_in_args\n    ]\n    obj = CodegenAST.__new__(cls, *basic_args)\n\n    # Set attributes\n    for attr, arg in zip(cls._fields, attrvals):\n        setattr(obj, attr, arg)\n\n    return obj",
    "sympy.sympy.combinatorics.permutations.__new__": "def __new__(cls, perm, x, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    perm = _sympify(perm)\n    x = _sympify(x)\n\n    if not isinstance(perm, Permutation):\n        raise ValueError(\"{} must be a Permutation instance.\"\n            .format(perm))\n\n    if evaluate:\n        if x.is_Integer:\n            return perm.apply(x)\n\n    obj = super().__new__(cls, perm, x)\n    return obj",
    "sympy.sympy.core.basic.<listcomp>": "terms = [term.doit(**hints) if isinstance(term, Basic) else term\n                             for term in self.args]\n",
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.core.singleton.<lambda>": "cls.__new__ = lambda cls: obj\n",
    "sympy.sympy.diffgeom.diffgeom.__new__": "def __new__(cls, coord_sys, index, **kwargs):\n    index = _sympify(index)\n    obj = super().__new__(cls, coord_sys, index)\n    obj._coord_sys = coord_sys\n    obj._index = index\n    return obj",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.functions.special.hyper.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 5:\n        args = [(args[0], args[1]), (args[2], args[3]), args[4]]\n    if len(args) != 3:\n        raise TypeError(\"args must be either as, as', bs, bs', z or \"\n                        \"as, bs, z\")\n\n    def tr(p):\n        if len(p) != 2:\n            raise TypeError(\"wrong argument\")\n        p = [list(ordered(i)) for i in p]\n        return TupleArg(_prep_tuple(p[0]), _prep_tuple(p[1]))\n\n    arg0, arg1 = tr(args[0]), tr(args[1])\n    if Tuple(arg0, arg1).has(oo, zoo, -oo):\n        raise ValueError(\"G-function parameters must be finite\")\n    if any((a - b).is_Integer and a - b > 0\n           for a in arg0[0] for b in arg1[0]):\n        raise ValueError(\"no parameter a1, ..., an may differ from \"\n                     \"any b1, ..., bm by a positive integer\")\n\n    # TODO should we check convergence conditions?\n    return super().__new__(cls, arg0, arg1, args[2], **kwargs)",
    "sympy.sympy.geometry.point.__new__": "def __new__(cls, *args, _nocheck=False, **kwargs):\n    if not _nocheck:\n        kwargs['dim'] = 2\n        args = Point(*args, **kwargs)\n    return GeometryEntity.__new__(cls, *args)",
    "sympy.sympy.matrices.expressions.blockmatrix.__new__": "def __new__(cls, *args, **kwargs):\n    from sympy.matrices.immutable import ImmutableDenseMatrix\n    isMat = lambda i: getattr(i, 'is_Matrix', False)\n    if len(args) != 1 or \\\n            not is_sequence(args[0]) or \\\n            len({isMat(r) for r in args[0]}) != 1:\n        raise ValueError(filldedent('''\n            expecting a sequence of 1 or more rows\n            containing Matrices.'''))\n    rows = args[0] if args else []\n    if not isMat(rows):\n        if rows and isMat(rows[0]):\n            rows = [rows]  # rows is not list of lists or []\n        # regularity check\n        # same number of matrices in each row\n        blocky = ok = len({len(r) for r in rows}) == 1\n        if ok:\n            # same number of rows for each matrix in a row\n            for r in rows:\n                ok = len({i.rows for i in r}) == 1\n                if not ok:\n                    break\n            blocky = ok\n            if ok:\n                # same number of cols for each matrix in each col\n                for c in range(len(rows[0])):\n                    ok = len({rows[i][c].cols\n                        for i in range(len(rows))}) == 1\n                    if not ok:\n                        break\n        if not ok:\n            # same total cols in each row\n            ok = len({\n                sum(i.cols for i in r) for r in rows}) == 1\n            if blocky and ok:\n                raise ValueError(filldedent('''\n                    Although this matrix is comprised of blocks,\n                    the blocks do not fill the matrix in a\n                    size-symmetric fashion. To create a full matrix\n                    from these arguments, pass them directly to\n                    Matrix.'''))\n            raise ValueError(filldedent('''\n                When there are not the same number of rows in each\n                row's matrices or there are not the same number of\n                total columns in each row, the matrix is not a\n                block matrix. If this matrix is known to consist of\n                blocks fully filling a 2-D space then see\n                Matrix.irregular.'''))\n    mat = ImmutableDenseMatrix(rows, evaluate=False)\n    obj = Basic.__new__(cls, mat)\n    return obj",
    "sympy.sympy.matrices.expressions.fourier.__new__": "def __new__(cls, n):\n    n = _sympify(n)\n    cls._check_dim(n)\n\n    obj = super().__new__(cls, n)\n    return obj",
    "sympy.sympy.matrices.expressions.funcmatrix.__new__": "def __new__(cls, rows, cols, lamda):\n    rows, cols = _sympify(rows), _sympify(cols)\n    cls._check_dim(rows)\n    cls._check_dim(cols)\n\n    lamda = sympify(lamda)\n    if not isinstance(lamda, (FunctionClass, Lambda)):\n        raise ValueError(\n            \"{} should be compatible with SymPy function classes.\"\n            .format(lamda))\n\n    if 2 not in lamda.nargs:\n        raise ValueError(\n            '{} should be able to accept 2 arguments.'.format(lamda))\n\n    if not isinstance(lamda, Lambda):\n        i, j = Dummy('i'), Dummy('j')\n        lamda = Lambda((i, j), lamda(i, j))\n\n    return super().__new__(cls, rows, cols, lamda)",
    "sympy.sympy.matrices.expressions.hadamard.__new__": "def __new__(cls, base, exp):\n    base = sympify(base)\n    exp = sympify(exp)\n\n    if base.is_scalar and exp.is_scalar:\n        return base ** exp\n\n    if isinstance(base, MatrixExpr) and isinstance(exp, MatrixExpr):\n        validate(base, exp)\n\n    obj = super().__new__(cls, base, exp)\n    return obj",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, *args, **kwargs):\n    args = map(_sympify, args)\n    return Basic.__new__(cls, *args, **kwargs)",
    "sympy.sympy.matrices.expressions.slice.__new__": "def __new__(cls, parent, rowslice, colslice):\n    rowslice = normalize(rowslice, parent.shape[0])\n    colslice = normalize(colslice, parent.shape[1])\n    if not (len(rowslice) == len(colslice) == 3):\n        raise IndexError()\n    if ((0 > rowslice[0]) == True or\n        (parent.shape[0] < rowslice[1]) == True or\n        (0 > colslice[0]) == True or\n        (parent.shape[1] < colslice[1]) == True):\n        raise IndexError()\n    if isinstance(parent, MatrixSlice):\n        return mat_slice_of_slice(parent, rowslice, colslice)\n    return Basic.__new__(cls, parent, Tuple(*rowslice), Tuple(*colslice))",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, rows, cols, i, j):\n    obj = MatrixExpr.__new__(cls, rows, cols, i, j)\n    obj._i = i\n    obj._j = j\n    return obj",
    "sympy.sympy.physics.control.lti.__new__": "def __new__(cls, A=None, B=None, C=None, D=None, sampling_time=1):\n    if sampling_time == 0:\n        raise ValueError(filldedent(\"\"\"\n            The sampling time cannot be zero.\n            If you want to create a continuous state space,\n            use the StateSpace class instead.\"\"\"))\n\n    sampling_time = sympify(sampling_time)\n    obj = super(DiscreteStateSpace, cls).__new__(cls, A, B, C, D, sampling_time)\n    obj._sampling_time = sampling_time\n\n    return obj",
    "sympy.sympy.physics.quantum.boson.__new__": "def __new__(cls, *args, **hints):\n    if not len(args) in [1, 2]:\n        raise ValueError('1 or 2 parameters expected, got %s' % args)\n\n    if len(args) == 1:\n        args = (args[0], S.One)\n\n    if len(args) == 2:\n        args = (args[0], Integer(args[1]))\n\n    return Operator.__new__(cls, *args)",
    "sympy.sympy.physics.quantum.dagger.__new__": "def __new__(cls, arg, evaluate=True):\n    if hasattr(arg, 'adjoint') and evaluate:\n        return arg.adjoint()\n    elif hasattr(arg, 'conjugate') and hasattr(arg, 'transpose') and evaluate:\n        return arg.conjugate().transpose()\n    return Expr.__new__(cls, sympify(arg))",
    "sympy.sympy.physics.quantum.fermion.__new__": "def __new__(cls, *args, **hints):\n    if not len(args) in [1, 2]:\n        raise ValueError('1 or 2 parameters expected, got %s' % args)\n\n    if len(args) == 1:\n        args = (args[0], S.One)\n\n    if len(args) == 2:\n        args = (args[0], Integer(args[1]))\n\n    return Operator.__new__(cls, *args)",
    "sympy.sympy.physics.quantum.operator.__new__": "def __new__(cls, *args, **old_assumptions):\n    from sympy.physics.quantum.state import KetBase, BraBase\n\n    if len(args) != 2:\n        raise ValueError('2 parameters expected, got %d' % len(args))\n\n    ket_expr = expand(args[0])\n    bra_expr = expand(args[1])\n\n    if (isinstance(ket_expr, (KetBase, Mul)) and\n            isinstance(bra_expr, (BraBase, Mul))):\n        ket_c, kets = ket_expr.args_cnc()\n        bra_c, bras = bra_expr.args_cnc()\n\n        if len(kets) != 1 or not isinstance(kets[0], KetBase):\n            raise TypeError('KetBase subclass expected'\n                            ', got: %r' % Mul(*kets))\n\n        if len(bras) != 1 or not isinstance(bras[0], BraBase):\n            raise TypeError('BraBase subclass expected'\n                            ', got: %r' % Mul(*bras))\n\n        if not kets[0].dual_class() == bras[0].__class__:\n            raise TypeError(\n                'ket and bra are not dual classes: %r, %r' %\n                (kets[0].__class__, bras[0].__class__)\n                )\n\n        # TODO: make sure the hilbert spaces of the bra and ket are\n        # compatible\n        obj = Expr.__new__(cls, *(kets[0], bras[0]), **old_assumptions)\n        obj.hilbert_space = kets[0].hilbert_space\n        return Mul(*(ket_c + bra_c)) * obj\n\n    op_terms = []\n    if isinstance(ket_expr, Add) and isinstance(bra_expr, Add):\n        for ket_term in ket_expr.args:\n            for bra_term in bra_expr.args:\n                op_terms.append(OuterProduct(ket_term, bra_term,\n                                             **old_assumptions))\n    elif isinstance(ket_expr, Add):\n        for ket_term in ket_expr.args:\n            op_terms.append(OuterProduct(ket_term, bra_expr,\n                                         **old_assumptions))\n    elif isinstance(bra_expr, Add):\n        for bra_term in bra_expr.args:\n            op_terms.append(OuterProduct(ket_expr, bra_term,\n                                         **old_assumptions))\n    else:\n        raise TypeError(\n            'Expected ket and bra expression, got: %r, %r' %\n            (ket_expr, bra_expr)\n            )\n\n    return Add(*op_terms)",
    "sympy.sympy.physics.quantum.pauli.__new__": "def __new__(cls, *args, **hints):\n    return SigmaOpBase.__new__(cls, *args, **hints)",
    "sympy.sympy.physics.quantum.qexpr.__new__": "def __new__(cls, *args, **kwargs):\n    \"\"\"Construct a new quantum object.\n\n    Parameters\n    ==========\n\n    args : tuple\n        The list of numbers or parameters that uniquely specify the\n        quantum object. For a state, this will be its symbol or its\n        set of quantum numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.qexpr import QExpr\n    >>> q = QExpr(0)\n    >>> q\n    0\n    >>> q.label\n    (0,)\n    >>> q.hilbert_space\n    H\n    >>> q.args\n    (0,)\n    >>> q.is_commutative\n    False\n    \"\"\"\n\n    # First compute args and call Expr.__new__ to create the instance\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    # Now set the slots on the instance\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    "sympy.sympy.physics.quantum.spin.__new__": "def __new__(cls, j, m):\n    j = sympify(j)\n    m = sympify(m)\n    if j.is_number:\n        if 2*j != int(2*j):\n            raise ValueError(\n                'j must be integer or half-integer, got: %s' % j)\n        if j < 0:\n            raise ValueError('j must be >= 0, got: %s' % j)\n    if m.is_number:\n        if 2*m != int(2*m):\n            raise ValueError(\n                'm must be integer or half-integer, got: %s' % m)\n    if j.is_number and m.is_number:\n        if abs(m) > j:\n            raise ValueError('Allowed values for m are -j <= m <= j, got j, m: %s, %s' % (j, m))\n        if int(j - m) != j - m:\n            raise ValueError('Both j and m must be integer or half-integer, got j, m: %s, %s' % (j, m))\n    return State.__new__(cls, j, m)",
    "sympy.sympy.physics.secondquant.__new__": "def __new__(cls, occupations):\n    \"\"\"\n    occupations is a list with two possible meanings:\n\n    - For bosons it is a list of occupation numbers.\n      Element i is the number of particles in state i.\n\n    - For fermions it is a list of occupied orbits.\n      Element 0 is the state that was occupied first, element i\n      is the i'th occupied state.\n    \"\"\"\n    occupations = list(map(sympify, occupations))\n    obj = Basic.__new__(cls, Tuple(*occupations))\n    return obj",
    "sympy.sympy.polys.polytools.__new__": "def __new__(cls, rep, *gens, **args) -> Self:\n    \"\"\"Create a new polynomial instance out of something useful. \"\"\"\n    opt = options.build_options(gens, args)\n\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n\n    if isinstance(rep, (DMP, DMF, ANP, DomainElement)):\n        return cls._from_domain_element(rep, opt)\n    elif iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep, evaluate=type(rep) is not str) # type: ignore\n\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    "sympy.sympy.polys.polytools.args": "@property\ndef args(self):\n    return (self.expr,) + self.gens",
    "sympy.sympy.polys.rootoftools.__new__": "def __new__(cls, f, x, index=None, radicals=False, expand=True):\n    \"\"\" Construct an indexed complex root of a polynomial.\n\n    See ``rootof`` for the parameters.\n\n    The default value of ``radicals`` is ``False`` to satisfy\n    ``eval(srepr(expr) == expr``.\n    \"\"\"\n    x = sympify(x)\n\n    if index is None and x.is_Integer:\n        x, index = None, x\n    else:\n        index = sympify(index)\n\n    if index is not None and index.is_Integer:\n        index = int(index)\n    else:\n        raise ValueError(\"expected an integer root index, got %s\" % index)\n\n    poly = PurePoly(f, x, greedy=False, expand=expand)\n\n    if not poly.is_univariate:\n        raise PolynomialError(\"only univariate polynomials are allowed\")\n\n    if not poly.gen.is_Symbol:\n        # PurePoly(sin(x) + 1) == PurePoly(x + 1) but the roots of\n        # x for each are not the same: issue 8617\n        raise PolynomialError(\"generator must be a Symbol\")\n\n    degree = poly.degree()\n\n    if degree <= 0:\n        raise PolynomialError(\"Cannot construct CRootOf object for %s\" % f)\n\n    if index < -degree or index >= degree:\n        raise IndexError(\"root index out of [%d, %d] range, got %d\" %\n                         (-degree, degree - 1, index))\n    elif index < 0:\n        index += degree\n\n    dom = poly.get_domain()\n\n    if not dom.is_Exact:\n        poly = poly.to_exact()\n\n    roots = cls._roots_trivial(poly, radicals)\n\n    if roots is not None:\n        return roots[index]\n\n    coeff, poly = preprocess_roots(poly)\n    dom = poly.get_domain()\n\n    if not dom.is_ZZ:\n        raise NotImplementedError(\"CRootOf is not supported over %s\" % dom)\n\n    root = cls._indexed_root(poly, index, lazy=True)\n    return coeff * cls._postprocess_root(root, radicals)",
    "sympy.sympy.polys.rootoftools.args": "@property\ndef args(self):\n    return (self.expr, Integer(self.index))",
    "sympy.sympy.sets.contains.__new__": "def __new__(cls, x, s, evaluate=None):\n    x = sympify(x)\n    s = sympify(s)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not isinstance(s, Set):\n        raise TypeError('expecting Set, not %s' % func_name(s))\n\n    if evaluate:\n        # _contains can return symbolic booleans that would be returned by\n        # s.contains(x) but here for Contains(x, s) we only evaluate to\n        # true, false or return the unevaluated Contains.\n        result = s._contains(x)\n\n        if isinstance(result, Boolean):\n            if result in (S.true, S.false):\n                return result\n        elif result is not None:\n            raise TypeError(\"_contains() should return Boolean or None\")\n\n    return super().__new__(cls, x, s)",
    "sympy.sympy.sets.fancysets.__new__": "def __new__(cls, *args):\n    if len(args) == 1:\n        if isinstance(args[0], range):\n            raise TypeError(\n                'use sympify(%s) to convert range to Range' % args[0])\n\n    # expand range\n    slc = slice(*args)\n\n    if slc.step == 0:\n        raise ValueError(\"step cannot be 0\")\n\n    start, stop, step = slc.start or 0, slc.stop, slc.step or 1\n    try:\n        ok = []\n        for w in (start, stop, step):\n            w = sympify(w)\n            if w in [S.NegativeInfinity, S.Infinity] or (\n                    w.has(Symbol) and w.is_integer != False):\n                ok.append(w)\n            elif not w.is_Integer:\n                if w.is_infinite:\n                    raise ValueError('infinite symbols not allowed')\n                raise ValueError\n            else:\n                ok.append(w)\n    except ValueError:\n        raise ValueError(filldedent('''\nFinite arguments to Range must be integers; `imageset` can define\nother cases, e.g. use `imageset(i, i/10, Range(3))` to give\n[0, 1/10, 1/5].'''))\n    start, stop, step = ok\n\n    null = False\n    if any(i.has(Symbol) for i in (start, stop, step)):\n        dif = stop - start\n        n = dif/step\n        if n.is_Rational:\n            if dif == 0:\n                null = True\n            else:  # (x, x + 5, 2) or (x, 3*x, x)\n                n = floor(n)\n                end = start + n*step\n                if dif.is_Rational:  # (x, x + 5, 2)\n                    if (end - stop).is_negative:\n                        end += step\n                else:  # (x, 3*x, x)\n                    if (end/stop - 1).is_negative:\n                        end += step\n        elif n.is_extended_negative:\n            null = True\n        else:\n            end = stop  # other methods like sup and reversed must fail\n    elif start.is_infinite:\n        span = step*(stop - start)\n        if span is S.NaN or span <= 0:\n            null = True\n        elif step.is_Integer and stop.is_infinite and abs(step) != 1:\n            raise ValueError(filldedent('''\n                Step size must be %s in this case.''' % (1 if step > 0 else -1)))\n        else:\n            end = stop\n    else:\n        oostep = step.is_infinite\n        if oostep:\n            step = S.One if step > 0 else S.NegativeOne\n        n = ceiling((stop - start)/step)\n        if n <= 0:\n            null = True\n        elif oostep:\n            step = S.One  # make it canonical\n            end = start + step\n        else:\n            end = start + n*step\n    if null:\n        start = end = S.Zero\n        step = S.One\n    return Basic.__new__(cls, start, end, step)",
    "sympy.sympy.sets.sets.__new__": "    def __new__(cls, *sets, **assumptions):\n        if len(sets) == 1 and iterable(sets[0]) and not isinstance(sets[0], (Set, set)):\n            sympy_deprecation_warning(\n                \"\"\"\nProductSet(iterable) is deprecated. Use ProductSet(*iterable) instead.\n                \"\"\",\n                deprecated_since_version=\"1.5\",\n                active_deprecations_target=\"deprecated-productset-iterable\",\n            )\n            sets = tuple(sets[0])\n\n        sets = [sympify(s) for s in sets]\n\n        if not all(isinstance(s, Set) for s in sets):\n            raise TypeError(\"Arguments to ProductSet should be of type Set\")\n\n        # Nullary product of sets is *not* the empty set\n        if len(sets) == 0:\n            return FiniteSet(())\n\n        if S.EmptySet in sets:\n            return S.EmptySet\n\n        return Basic.__new__(cls, *sets, **assumptions)",
    "sympy.sympy.stats.compound_rv.__new__": "def __new__(cls, s, distribution):\n    s = _symbol_converter(s)\n    if isinstance(distribution, ContinuousDistribution):\n        return SingleContinuousPSpace(s, distribution)\n    if isinstance(distribution, DiscreteDistribution):\n        return SingleDiscretePSpace(s, distribution)\n    if isinstance(distribution, SingleFiniteDistribution):\n        return SingleFinitePSpace(s, distribution)\n    if not isinstance(distribution, CompoundDistribution):\n        raise ValueError(\"%s should be an isinstance of \"\n                    \"CompoundDistribution\"%(distribution))\n    return Basic.__new__(cls, s, distribution)",
    "sympy.sympy.stats.crv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.crv_types.__new__": "def __new__(cls, pdf, set=Interval(-oo, oo)):\n    return Basic.__new__(cls, pdf, set)",
    "sympy.sympy.stats.drv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.drv_types.__new__": "def __new__(cls, pdf, set=S.Integers):\n    return Basic.__new__(cls, pdf, set)",
    "sympy.sympy.stats.frv.__new__": "def __new__(cls, symbol, set):\n    if not isinstance(set, FiniteSet) and \\\n        not isinstance(set, Intersection):\n        set = FiniteSet(*set)\n    return Basic.__new__(cls, symbol, set)",
    "sympy.sympy.stats.joint_rv.__new__": "def __new__(cls, sym, dist):\n    if isinstance(dist, SingleContinuousDistribution):\n        return SingleContinuousPSpace(sym, dist)\n    if isinstance(dist, SingleDiscreteDistribution):\n        return SingleDiscretePSpace(sym, dist)\n    sym = _symbol_converter(sym)\n    return Basic.__new__(cls, sym, dist)",
    "sympy.sympy.stats.matrix_distributions.__new__": "def __new__(cls, sym, distribution, dim_n, dim_m):\n    sym = _symbol_converter(sym)\n    dim_n, dim_m = _sympify(dim_n), _sympify(dim_m)\n    if not (dim_n.is_integer and dim_m.is_integer):\n        raise ValueError(\"Dimensions should be integers\")\n    return Basic.__new__(cls, sym, distribution, dim_n, dim_m)",
    "sympy.sympy.stats.random_matrix.__new__": "def __new__(cls, sym, model=None):\n    sym = _symbol_converter(sym)\n    if model:\n        return Basic.__new__(cls, sym, model)\n    else:\n        return Basic.__new__(cls, sym)",
    "sympy.sympy.stats.random_matrix_models.__new__": "def __new__(cls, sym, dim=None):\n    sym, dim = _symbol_converter(sym), _sympify(dim)\n    if dim.is_integer == False:\n        raise ValueError(\"Dimension of the random matrices must be \"\n                            \"integers, received %s instead.\"%(dim))\n    return Basic.__new__(cls, sym, dim)",
    "sympy.sympy.stats.rv.__new__": "def __new__(cls, *domains):\n    # Flatten any product of products\n    domains2 = []\n    for domain in domains:\n        if not domain.is_ProductDomain:\n            domains2.append(domain)\n        else:\n            domains2.extend(domain.domains)\n    domains2 = FiniteSet(*domains2)\n\n    if all(domain.is_Finite for domain in domains2):\n        from sympy.stats.frv import ProductFiniteDomain\n        cls = ProductFiniteDomain\n    if all(domain.is_Continuous for domain in domains2):\n        from sympy.stats.crv import ProductContinuousDomain\n        cls = ProductContinuousDomain\n    if all(domain.is_Discrete for domain in domains2):\n        from sympy.stats.drv import ProductDiscreteDomain\n        cls = ProductDiscreteDomain\n\n    return Basic.__new__(cls, *domains2)",
    "sympy.sympy.stats.stochastic_process.__new__": "def __new__(cls, sym, process, distribution=None):\n    sym = _symbol_converter(sym)\n    from sympy.stats.stochastic_process_types import StochasticProcess\n    if not isinstance(process, StochasticProcess):\n        raise TypeError(\"`process` must be an instance of StochasticProcess.\")\n    if distribution is None:\n        distribution = Distribution()\n    return Basic.__new__(cls, sym, process, distribution)",
    "sympy.sympy.stats.stochastic_process_types.__new__": "def __new__(cls, sym, state_space=None, trans_probs=None):\n    sym = _symbol_converter(sym)\n\n    state_space, trans_probs = MarkovProcess._sanity_checks(state_space, trans_probs)\n\n    obj = Basic.__new__(cls, sym, state_space, trans_probs) # type: ignore\n    indices = {}\n    if isinstance(obj.number_of_states, Integer):\n        for index, state in enumerate(obj._state_index):\n            indices[state] = index\n    obj.index_of = indices\n    return obj",
    "sympy.sympy.stats.symbolic_multivariate_probability.__new__": "def __new__(cls, arg1, arg2, condition=None):\n    arg1 = _sympify(arg1)\n    arg2 = _sympify(arg2)\n\n    if (1 not in arg1.shape) or (1 not in arg2.shape) or (arg1.shape[1] != arg2.shape[1]):\n        raise ShapeError(\"Expression is not a vector\")\n\n    shape = (arg1.shape[0], arg2.shape[0]) if arg1.shape[1] == 1 and arg2.shape[1] == 1 \\\n                else (1, 1)\n\n    if condition:\n        obj = Expr.__new__(cls, arg1, arg2, condition)\n    else:\n        obj = Expr.__new__(cls, arg1, arg2)\n\n    obj._shape = shape\n    obj._condition = condition\n    return obj",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, arg1, arg2, condition=None, **kwargs):\n    arg1 = _sympify(arg1)\n    arg2 = _sympify(arg2)\n\n    if arg1.is_Matrix or arg2.is_Matrix:\n        from sympy.stats.symbolic_multivariate_probability import CrossCovarianceMatrix\n        return CrossCovarianceMatrix(arg1, arg2, condition)\n\n    if kwargs.pop('evaluate', global_parameters.evaluate):\n        arg1, arg2 = sorted([arg1, arg2], key=default_sort_key)\n\n    if condition is None:\n        obj = Expr.__new__(cls, arg1, arg2)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, arg1, arg2, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.tensor.array.dense_ndim_array.__new__": "def __new__(cls, iterable, shape=None, **kwargs):\n    return cls._new(iterable, shape, **kwargs)",
    "sympy.sympy.tensor.array.expressions.array_expressions.__new__": "def __new__(cls, symbol, shape: typing.Iterable) -> \"ArraySymbol\":\n    if isinstance(symbol, str):\n        symbol = Symbol(symbol)\n    # symbol = _sympify(symbol)\n    shape = Tuple(*map(_sympify, shape))\n    obj = Expr.__new__(cls, symbol, shape)\n    return obj",
    "sympy.sympy.tensor.indexed.__new__": "def __new__(cls, label, range=None, **kw_args):\n\n    if isinstance(label, str):\n        label = Symbol(label, integer=True)\n    label, range = list(map(sympify, (label, range)))\n\n    if label.is_Number:\n        if not label.is_integer:\n            raise TypeError(\"Index is not an integer number.\")\n        return label\n\n    if not label.is_integer:\n        raise TypeError(\"Idx object requires an integer label.\")\n\n    elif is_sequence(range):\n        if len(range) != 2:\n            raise ValueError(filldedent(f\"\"\"\n                Idx range tuple must have length 2, but got {len(range)}\"\"\"))\n        for bound in range:\n            if (bound.is_integer is False and bound is not S.Infinity\n                    and bound is not S.NegativeInfinity):\n                raise TypeError(\"Idx object requires integer bounds.\")\n        args = label, Tuple(*range)\n    elif isinstance(range, Expr):\n        if range is not S.Infinity and fuzzy_not(range.is_integer):\n            raise TypeError(\"Idx object requires an integer dimension.\")\n        args = label, Tuple(0, range - 1)\n    elif range:\n        raise TypeError(filldedent(\"\"\"\n            The range must be an ordered iterable or\n            integer SymPy expression.\"\"\"))\n    else:\n        args = label,\n\n    obj = Expr.__new__(cls, *args, **kw_args)\n    obj._assumptions[\"finite\"] = True\n    obj._assumptions[\"real\"] = True\n    return obj"
}