{
    "sphinx.sphinx.application.add_directive": "def add_directive(\n    self, name: str, cls: type[Directive], override: bool = False\n) -> None:\n    \"\"\"Register a Docutils directive.\n\n    :param name: The name of the directive\n    :param cls: A directive class\n    :param override: If false, do not install it if another directive\n                     is already installed as the same name\n                     If true, unconditionally install the directive.\n\n    For example, a custom directive named ``my-directive`` would be added\n    like this:\n\n    .. code-block:: python\n\n       from docutils.parsers.rst import Directive, directives\n\n       class MyDirective(Directive):\n           has_content = True\n           required_arguments = 1\n           optional_arguments = 0\n           final_argument_whitespace = True\n           option_spec = {\n               'class': directives.class_option,\n               'name': directives.unchanged,\n           }\n\n           def run(self):\n               pass\n\n       def setup(app):\n           app.add_directive('my-directive', MyDirective)\n\n    For more details, see `the Docutils docs\n    <https://docutils.sourceforge.io/docs/howto/rst-directives.html>`__ .\n\n    .. versionchanged:: 0.6\n       Docutils 0.5-style directive classes are now supported.\n    .. versionchanged:: 1.8\n       Docutils 0.4-style (function based) directives support is deprecated.\n    .. versionchanged:: 1.8\n       Add *override* keyword.\n    \"\"\"\n    logger.debug('[app] adding directive: %r', (name, cls))\n    if not override and docutils.is_directive_registered(name):\n        logger.warning(\n            __('directive %r is already registered and will not be overridden'),\n            name,\n            type='app',\n            subtype='add_directive',\n        )\n\n    docutils.register_directive(name, cls)",
    "sphinx.sphinx.application.add_domain": "def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n    \"\"\"Register a domain.\n\n    :param domain: A domain class\n    :param override: If false, do not install it if another domain\n                     is already installed as the same name\n                     If true, unconditionally install the domain.\n\n    .. versionadded:: 1.0\n    .. versionchanged:: 1.8\n       Add *override* keyword.\n    \"\"\"\n    self.registry.add_domain(domain, override=override)",
    "sphinx.sphinx.application.connect": "def connect(\n    self, event: str, callback: Callable[..., Any], priority: int = 500\n) -> int:\n    \"\"\"Register *callback* to be called when *event* is emitted.\n\n    For details on available core events and the arguments of callback\n    functions, please see :ref:`events`.\n\n    :param event: The name of target event\n    :param callback: Callback function for the event\n    :param priority: The priority of the callback.  The callbacks will be invoked\n                     in order of *priority* (ascending).\n    :return: A listener ID.  It can be used for :meth:`disconnect`.\n\n    .. versionchanged:: 3.0\n\n       Support *priority*\n    \"\"\"\n    listener_id = self.events.connect(event, callback, priority)\n    logger.debug(\n        '[app] connecting event %r (%d): %r [id=%s]',\n        event,\n        priority,\n        callback,\n        listener_id,\n    )\n    return listener_id",
    "sphinx.sphinx.application.add_config_value": "def add_config_value(\n    self,\n    name: str,\n    default: Any,\n    rebuild: _ConfigRebuild,\n    types: type | Collection[type] | ENUM = (),\n    description: str = '',\n) -> None:\n    \"\"\"Register a configuration value.\n\n    This is necessary for Sphinx to recognize new values and set default\n    values accordingly.\n\n\n    :param name: The name of the configuration value.  It is recommended to be prefixed\n                 with the extension name (ex. ``html_logo``, ``epub_title``)\n    :param default: The default value of the configuration.\n    :param rebuild: The condition of rebuild.  It must be one of those values:\n\n                    * ``'env'`` if a change in the setting only takes effect when a\n                      document is parsed -- this means that the whole environment must be\n                      rebuilt.\n                    * ``'html'`` if a change in the setting needs a full rebuild of HTML\n                      documents.\n                    * ``''`` if a change in the setting will not need any special rebuild.\n    :param types: The type of configuration value.  A list of types can be specified.  For\n                  example, ``[str]`` is used to describe a configuration that takes string\n                  value.\n    :param description: A short description of the configuration value.\n\n    .. versionchanged:: 0.4\n       If the *default* value is a callable, it will be called with the\n       config object as its argument in order to get the default value.\n       This can be used to implement config values whose default depends on\n       other values.\n\n    .. versionchanged:: 0.6\n       Changed *rebuild* from a simple boolean (equivalent to ``''`` or\n       ``'env'``) to a string.  However, booleans are still accepted and\n       converted internally.\n\n    .. versionadded:: 1.4\n       The *types* parameter.\n\n    .. versionadded:: 7.4\n       The *description* parameter.\n    \"\"\"\n    logger.debug('[app] adding config value: %r', (name, default, rebuild, types))\n    self.config.add(\n        name=name,\n        default=default,\n        rebuild=rebuild,\n        types=types,\n        description=description,\n    )",
    "sphinx.sphinx.application.add_event": "def add_event(self, name: str) -> None:\n    \"\"\"Register an event called *name*.\n\n    This is needed to be able to emit it.\n\n    :param name: The name of the event\n    \"\"\"\n    logger.debug('[app] adding event: %r', name)\n    self.events.add(name)",
    "sphinx.sphinx.application.add_node": "def add_node(\n    self,\n    node: type[Element],\n    override: bool = False,\n    **kwargs: _NodeHandlerPair,\n) -> None:\n    \"\"\"Register a Docutils node class.\n\n    This is necessary for Docutils internals.  It may also be used in the\n    future to validate nodes in the parsed documents.\n\n    :param node: A node class\n    :param kwargs: Visitor functions for each builder (see below)\n    :param override: If true, install the node forcedly even if another node is already\n                     installed as the same name\n\n    Node visitor functions for the Sphinx HTML, LaTeX, text and manpage\n    writers can be given as keyword arguments: the keyword should be one or\n    more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``\n    or any other supported translators, the value a 2-tuple of ``(visit,\n    depart)`` methods.  ``depart`` can be ``None`` if the ``visit``\n    function raises :exc:`docutils.nodes.SkipNode`.  Example:\n\n    .. code-block:: python\n\n       class math(docutils.nodes.Element): ...\n\n       def visit_math_html(self, node):\n           self.body.append(self.starttag(node, 'math'))\n\n       def depart_math_html(self, node):\n           self.body.append('</math>')\n\n       app.add_node(math, html=(visit_math_html, depart_math_html))\n\n    Obviously, translators for which you don't specify visitor methods will\n    choke on the node when encountered in a document to translate.\n\n    .. versionchanged:: 0.5\n       Added the support for keyword arguments giving visit functions.\n    \"\"\"\n    logger.debug('[app] adding node: %r', (node, kwargs))\n    if not override and docutils.is_node_registered(node):\n        logger.warning(\n            __(\n                'node class %r is already registered, '\n                'its visitors will be overridden'\n            ),\n            node.__name__,\n            type='app',\n            subtype='add_node',\n        )\n    docutils.register_node(node)\n    self.registry.add_translation_handlers(node, **kwargs)"
}