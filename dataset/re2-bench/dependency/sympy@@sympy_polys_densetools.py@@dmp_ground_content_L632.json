{
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densebasic._dup": "def _dup(p, /):\n    return p",
    "sympy.sympy.polys.densetools.dup_content": "def dup_content(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Compute the GCD of coefficients of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_content(f)\n    2\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_content(f)\n    2\n\n    \"\"\"\n    from sympy.polys.domains import QQ\n\n    if not f:\n        return K.zero\n\n    cont = K.zero\n\n    if K == QQ:\n        for c in f:\n            cont = K.gcd(cont, c)\n    else:\n        for c in f:\n            cont = K.gcd(cont, c)\n\n            if K.is_one(cont):\n                break\n\n    return cont",
    "sympy.sympy.polys.densetools.dmp_ground_content": "def dmp_ground_content(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Compute the GCD of coefficients of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_content(f)\n    2\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_content(f)\n    2\n\n    \"\"\"\n    from sympy.polys.domains import QQ\n\n    if not u:\n        return dup_content(_dup(f), K)\n\n    if dmp_zero_p(f, u):\n        return K.zero\n\n    cont, v = K.zero, u - 1\n\n    if K == QQ:\n        for c in f:\n            cont = K.gcd(cont, dmp_ground_content(c, v, K))\n    else:\n        for c in f:\n            cont = K.gcd(cont, dmp_ground_content(c, v, K))\n\n            if K.is_one(cont):\n                break\n\n    return cont",
    "sympy.sympy.polys.domains.algebraicfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, AlgebraicField):\n        return self.dtype == other.dtype and self.ext == other.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.domain.is_one": "def is_one(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is one. \"\"\"\n    return a == self.one",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(self, other):\n    if isinstance(other, ExpressionDomain):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.expressiondomain.gcd": "def gcd(self, a, b):\n    return self(1)",
    "sympy.sympy.polys.domains.field.gcd": "def gcd(self, a, b) -> Ef:\n    \"\"\"\n    Returns GCD of ``a`` and ``b``.\n\n    This definition of GCD over fields allows to clear denominators\n    in `primitive()`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy import S, gcd, primitive\n    >>> from sympy.abc import x\n\n    >>> QQ.gcd(QQ(2, 3), QQ(4, 9))\n    2/9\n    >>> gcd(S(2)/3, S(4)/9)\n    2/9\n    >>> primitive(2*x/3 + S(4)/9)\n    (2/9, 3*x + 2)\n\n    \"\"\"\n    try:\n        ring = self.get_ring()\n    except DomainError:\n        return self.one\n\n    p = ring.gcd(self.numer(a), self.numer(b))\n    q = ring.lcm(self.denom(a), self.denom(b))\n\n    return self.convert(p, ring)/q",
    "sympy.sympy.polys.domains.finitefield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FiniteField) and \\\n        self.mod == other.mod and self.dom == other.dom",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, GaussianRationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.gaussiandomains.gcd": "def gcd(self, a: GaussianInteger, b: GaussianInteger) -> GaussianInteger:\n    \"\"\"Greatest common divisor of a and b over ZZ_I.\"\"\"\n    while b:\n        a, b = b, a % b\n    unit = self.canonical_unit(a)\n    return a*unit",
    "sympy.sympy.polys.domains.integerring.gcd": "def gcd(self, a, b):\n    \"\"\"Compute GCD of ``a`` and ``b``. \"\"\"\n    return gcd(a, b)",
    "sympy.sympy.polys.domains.integerring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, IntegerRing):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.gcd": "def gcd(self, a, b):\n    \"\"\"Returns GCD of `a` and `b`. \"\"\"\n    return a.gcd(b)",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.domains.polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns `True` if two domains are equivalent. \"\"\"\n    if not isinstance(other, PolynomialRing):\n        return NotImplemented\n    return self.ring == other.ring",
    "sympy.sympy.polys.domains.rationalfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, RationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.realfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, RealField) and self.precision == other.precision",
    "sympy.sympy.polys.domains.realfield.gcd": "def gcd(self, a, b):\n    \"\"\"Returns GCD of ``a`` and ``b``. \"\"\"\n    return self.one"
}