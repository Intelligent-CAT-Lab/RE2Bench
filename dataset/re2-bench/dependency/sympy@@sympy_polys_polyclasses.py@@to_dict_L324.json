{
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.polys.densebasic.dmp_to_dict": "def dmp_to_dict(f: dmp[Er], u: int, K: Domain[Er]) -> dict[tuple[int, ...], Er]:\n    \"\"\"\n    Convert a ``K[X]`` polynomial to a ``dict````.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dmp_to_dict\n\n    >>> dmp_to_dict([[1, 0], [], [2, 3]], 1, ZZ)\n    {(0, 0): 3, (0, 1): 2, (2, 1): 1}\n    >>> dmp_to_dict([], 0, ZZ)\n    {}\n\n    .. versionchanged:: 1.15.0\n        The ``zero`` parameter was removed and the ``K`` parameter is now\n        required.\n\n    \"\"\"\n    if not u:\n        return dup_to_dict(_dup(f), K)\n\n    n = dmp_degree(f, u)\n    v = u - 1\n    result: dict[monom, Er] = {}\n\n    for k in range(0, n + 1):\n        h = dmp_to_dict(f[n - k], v, K)\n\n        for exp, coeff in h.items():\n            result[(k,) + exp] = coeff\n\n    return result",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f) -> bool:\n    return not f.is_zero",
    "sympy.sympy.polys.polyclasses.to_list": "def to_list(f) -> dmp[Er]:\n    \"\"\"Convert ``f`` to a list representation with native coefficients. \"\"\"\n    return list(f._rep)",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}