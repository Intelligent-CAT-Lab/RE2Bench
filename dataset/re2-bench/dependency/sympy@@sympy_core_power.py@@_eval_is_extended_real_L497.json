{
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.coeff": "def coeff(self, x: Expr | complex, n=1, right=False, _first=True):\n    \"\"\"\n    Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n    is zero then all terms independent of ``x`` will be returned.\n\n    Explanation\n    ===========\n\n    When ``x`` is noncommutative, the coefficient to the left (default) or\n    right of ``x`` can be returned. The keyword 'right' is ignored when\n    ``x`` is commutative.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.abc import x, y, z\n\n    You can select terms that have an explicit negative in front of them:\n\n    >>> (-x + 2*y).coeff(-1)\n    x\n    >>> (x - 2*y).coeff(-1)\n    2*y\n\n    You can select terms with no Rational coefficient:\n\n    >>> (x + 2*y).coeff(1)\n    x\n    >>> (3 + 2*x + 4*x**2).coeff(1)\n    0\n\n    You can select terms independent of x by making n=0; in this case\n    expr.as_independent(x)[0] is returned (and 0 will be returned instead\n    of None):\n\n    >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n    3\n    >>> eq = ((x + 1)**3).expand() + 1\n    >>> eq\n    x**3 + 3*x**2 + 3*x + 2\n    >>> [eq.coeff(x, i) for i in reversed(range(4))]\n    [1, 3, 3, 2]\n    >>> eq -= 2\n    >>> [eq.coeff(x, i) for i in reversed(range(4))]\n    [1, 3, 3, 0]\n\n    You can select terms that have a numerical term in front of them:\n\n    >>> (-x - 2*y).coeff(2)\n    -y\n    >>> from sympy import sqrt\n    >>> (x + sqrt(2)*x).coeff(sqrt(2))\n    x\n\n    The matching is exact:\n\n    >>> (3 + 2*x + 4*x**2).coeff(x)\n    2\n    >>> (3 + 2*x + 4*x**2).coeff(x**2)\n    4\n    >>> (3 + 2*x + 4*x**2).coeff(x**3)\n    0\n    >>> (z*(x + y)**2).coeff((x + y)**2)\n    z\n    >>> (z*(x + y)**2).coeff(x + y)\n    0\n\n    In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n    from the following:\n\n    >>> (x + z*(x + x*y)).coeff(x)\n    1\n\n    If such factoring is desired, factor_terms can be used first:\n\n    >>> from sympy import factor_terms\n    >>> factor_terms(x + z*(x + x*y)).coeff(x)\n    z*(y + 1) + 1\n\n    >>> n, m, o = symbols('n m o', commutative=False)\n    >>> n.coeff(n)\n    1\n    >>> (3*n).coeff(n)\n    3\n    >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n    1 + m\n    >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n    m\n\n    If there is more than one possible coefficient 0 is returned:\n\n    >>> (n*m + m*n).coeff(n)\n    0\n\n    If there is only one possible coefficient, it is returned:\n\n    >>> (n*m + x*m*n).coeff(m*n)\n    x\n    >>> (n*m + x*m*n).coeff(m*n, right=1)\n    1\n\n    See Also\n    ========\n\n    as_coefficient: separate the expression into a coefficient and factor\n    as_coeff_Add: separate the additive constant from an expression\n    as_coeff_Mul: separate the multiplicative constant from an expression\n    as_independent: separate x-dependent terms/factors from others\n    sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n    sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used\n    \"\"\"\n    xe = sympify(x)\n    if not isinstance(xe, Basic):\n        return S.Zero\n\n    n = as_int(n)\n\n    if not xe:\n        return S.Zero\n\n    if xe == self:\n        if n == 1:\n            return S.One\n        return S.Zero\n\n    co2: list[Expr]\n\n    if xe is S.One:\n        co2 = [a for a in Add.make_args(self) if a.as_coeff_Mul()[0] is S.One]\n        if not co2:\n            return S.Zero\n        return Add(*co2)\n\n    if n == 0:\n        if xe.is_Add and self.is_Add:\n            c = self.coeff(xe, right=right)\n            if not c:\n                return S.Zero\n            if not right:\n                return self - Add(*[a*xe for a in Add.make_args(c)])\n            return self - Add(*[xe*a for a in Add.make_args(c)])\n        return self.as_independent(xe, as_Add=True)[0]\n\n    # continue with the full method, looking for this power of xe:\n    xe = xe**n\n\n    def incommon(l1, l2):\n        if not l1 or not l2:\n            return []\n        n = min(len(l1), len(l2))\n        for i in range(n):\n            if l1[i] != l2[i]:\n                return l1[:i]\n        return l1[:]\n\n    def find(l, sub, first=True):\n        \"\"\" Find where list sub appears in list l. When ``first`` is True\n        the first occurrence from the left is returned, else the last\n        occurrence is returned. Return None if sub is not in l.\n\n        Examples\n        ========\n\n        >> l = range(5)*2\n        >> find(l, [2, 3])\n        2\n        >> find(l, [2, 3], first=0)\n        7\n        >> find(l, [2, 4])\n        None\n\n        \"\"\"\n        if not sub or not l or len(sub) > len(l):\n            return None\n        n = len(sub)\n        if not first:\n            l.reverse()\n            sub.reverse()\n        for i in range(len(l) - n + 1):\n            if all(l[i + j] == sub[j] for j in range(n)):\n                break\n        else:\n            i = None\n        if not first:\n            l.reverse()\n            sub.reverse()\n        if i is not None and not first:\n            i = len(l) - (i + n)\n        return i\n\n    co2 = []\n    co: list[tuple[set[Expr], list[Expr]]] = []\n    args = Add.make_args(self)\n    self_c = self.is_commutative\n    x_c = xe.is_commutative\n    if self_c and not x_c:\n        return S.Zero\n    if _first and self.is_Add and not self_c and not x_c:\n        # get the part that depends on xe exactly\n        xargs = Mul.make_args(xe)\n        d = Add(*[i for i in Add.make_args(self.as_independent(xe)[1])\n            if all(xi in Mul.make_args(i) for xi in xargs)])\n        rv = d.coeff(xe, right=right, _first=False)\n        if not rv.is_Add or not right:\n            return rv\n        c_part, nc_part = zip(*[i.args_cnc() for i in rv.args])\n        if has_variety(c_part):\n            return rv\n        return Add(*[Mul._from_args(i) for i in nc_part])\n\n    one_c = self_c or x_c\n    xargs, nx = xe.args_cnc(cset=True, warn=bool(not x_c))\n    # find the parts that pass the commutative terms\n    for a in args:\n        margs, nc = a.args_cnc(cset=True, warn=bool(not self_c))\n        if nc is None:\n            nc = []\n        if len(xargs) > len(margs):\n            continue\n        resid = margs.difference(xargs)\n        if len(resid) + len(xargs) == len(margs):\n            if one_c:\n                co2.append(Mul(*(list(resid) + nc)))\n            else:\n                co.append((resid, nc))\n    if one_c:\n        if co2 == []:\n            return S.Zero\n        elif co2:\n            return Add(*co2)\n    else:  # both nc\n        # now check the non-comm parts\n        if not co:\n            return S.Zero\n        if all(n == co[0][1] for r, n in co):\n            ii = find(co[0][1], nx, right)\n            if ii is not None:\n                if not right:\n                    return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))\n                else:\n                    return Mul(*co[0][1][ii + len(nx):])\n        beg = reduce(incommon, (n[1] for n in co))\n        if beg:\n            ii = find(beg, nx, right)\n            if ii is not None:\n                if not right:\n                    gcdc = co[0][0]\n                    for i in range(1, len(co)):\n                        gcdc = gcdc.intersection(co[i][0])\n                        if not gcdc:\n                            break\n                    return Mul(*(list(gcdc) + beg[:ii]))\n                else:\n                    m = ii + len(nx)\n                    return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])\n        end = list(reversed(\n            reduce(incommon, (list(reversed(n[1])) for n in co))))\n        if end:\n            ii = find(end, nx, right)\n            if ii is not None:\n                if not right:\n                    return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])\n                else:\n                    return Mul(*end[ii + len(nx):])\n        # look for single match\n        hit = None\n        for i, (r, n) in enumerate(co):\n            ii = find(n, nx, right)\n            if ii is not None:\n                if not hit:\n                    hit = ii, r, n\n                else:\n                    break\n        else:\n            if hit:\n                ii, r, n = hit\n                if not right:\n                    return Mul(*(list(r) + n[:ii]))\n                else:\n                    return Mul(*n[ii + len(nx):])\n\n        return S.Zero",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.functions.elementary.exponential.exp": "@property\ndef exp(self):\n    \"\"\"\n    Returns the exponent of the function.\n    \"\"\"\n    return self.args[0]"
}