{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.logic.boolalg.__new__": "def __new__(cls, *args, remove_true=True, evaluate=None, **kwargs):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if not evaluate:\n        return super().__new__(cls, *args, evaluate=evaluate, **kwargs)\n\n    argset = set()\n    for arg in map(_sympify, args):\n        if isinstance(arg, Number) or arg in (True, False):\n            if arg:\n                arg = true\n            else:\n                continue\n        if isinstance(arg, Xor):\n            for a in arg.args:\n                argset.remove(a) if a in argset else argset.add(a)\n        elif arg in argset:\n            argset.remove(arg)\n        else:\n            argset.add(arg)\n    rel = [(r, r.canonical, r.negated.canonical)\n           for r in argset if r.is_Relational]\n    odd = False  # is number of complimentary pairs odd? start 0 -> False\n    remove = []\n    for i, (r, c, nc) in enumerate(rel):\n        for j in range(i + 1, len(rel)):\n            rj, cj = rel[j][:2]\n            if cj == nc:\n                odd = not odd\n                break\n            elif cj == c:\n                break\n        else:\n            continue\n        remove.append((r, rj))\n    if odd:\n        argset.remove(true) if true in argset else argset.add(true)\n    for a, b in remove:\n        argset.remove(a)\n        argset.remove(b)\n    if len(argset) == 0:\n        return false\n    elif len(argset) == 1:\n        return argset.pop()\n    elif True in argset and remove_true:\n        argset.remove(True)\n        return Not(Xor(*argset))\n    return super().__new__(cls, *ordered(argset))",
    "sympy.sympy.logic.boolalg._distribute": "def _distribute(info):\n    \"\"\"\n    Distributes ``info[1]`` over ``info[2]`` with respect to ``info[0]``.\n    \"\"\"\n    if isinstance(info[0], info[2]):\n        for arg in info[0].args:\n            if isinstance(arg, info[1]):\n                conj = arg\n                break\n        else:\n            return info[0]\n        rest = info[2](*[a for a in info[0].args if a is not conj])\n        return info[1](*list(map(_distribute,\n                                 [(info[2](c, rest), info[1], info[2])\n                                  for c in conj.args])), remove_true=False)\n    elif isinstance(info[0], info[1]):\n        return info[1](*list(map(_distribute,\n                                 [(x, info[1], info[2])\n                                  for x in info[0].args])),\n                       remove_true=False)\n    else:\n        return info[0]",
    "sympy.sympy.logic.boolalg.<listcomp>": "[(x, info[1], info[2])\n for x in info[0].args])),\n"
}