{
    "sympy.sympy.assumptions.wrapper.__new__": "def __new__(cls, expr, assumptions=None):\n    if assumptions is None:\n        return expr\n    obj = super().__new__(cls, expr, _sympify(assumptions))\n    obj.expr = expr\n    obj.assumptions = assumptions\n    return obj",
    "sympy.sympy.codegen.ast.__eq__": "def __eq__(self, other):\n    if not isinstance(other, self.__class__):\n        return False\n    for attr in self._fields:\n        if getattr(self, attr) != getattr(other, attr):\n            return False\n    return True",
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.expr.as_coeff_Add": "def as_coeff_Add(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return S.Zero, self",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.logic.fuzzy_and": "def fuzzy_and(args):\n    \"\"\"Return True (all True), False (any False) or None.\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import fuzzy_and\n    >>> from sympy import Dummy\n\n    If you had a list of objects to test the commutivity of\n    and you want the fuzzy_and logic applied, passing an\n    iterator will allow the commutativity to only be computed\n    as many times as necessary. With this list, False can be\n    returned after analyzing the first symbol:\n\n    >>> syms = [Dummy(commutative=False), Dummy()]\n    >>> fuzzy_and(s.is_commutative for s in syms)\n    False\n\n    That False would require less work than if a list of pre-computed\n    items was sent:\n\n    >>> fuzzy_and([s.is_commutative for s in syms])\n    False\n    \"\"\"\n\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:  # this will stop updating if a None is ever trapped\n            rv = ai\n    return rv",
    "sympy.sympy.core.logic.fuzzy_not": "def fuzzy_not(v):\n    \"\"\"\n    Not in fuzzy logic\n\n    Return None if `v` is None else `not v`.\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import fuzzy_not\n    >>> fuzzy_not(True)\n    False\n    >>> fuzzy_not(None)\n    >>> fuzzy_not(False)\n    True\n\n    \"\"\"\n    if v is None:\n        return v\n    else:\n        return not v",
    "sympy.sympy.core.logic.fuzzy_xor": "def fuzzy_xor(args):\n    \"\"\"Return None if any element of args is not True or False, else\n    True (if there are an odd number of True elements), else False.\"\"\"\n    t = 0\n    for a in args:\n        ai = fuzzy_bool(a)\n        if ai:\n            t += 1\n        elif ai is None:\n            return\n    return t % 2 == 1",
    "sympy.sympy.core.logic.fuzzy_bool": "def fuzzy_bool(x):\n    \"\"\"Return True, False or None according to x.\n\n    Whereas bool(x) returns True or False, fuzzy_bool allows\n    for the None value and non-false values (which become None), too.\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import fuzzy_bool\n    >>> from sympy.abc import x\n    >>> fuzzy_bool(x), fuzzy_bool(None)\n    (None, None)\n    >>> bool(x), bool(None)\n    (True, False)\n\n    \"\"\"\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.int_valued": "def int_valued(x):\n    \"\"\"return True only for a literal Number whose internal\n    representation as a fraction has a denominator of 1,\n    else False, i.e. integer, with no fractional part.\n    \"\"\"\n    if isinstance(x, (SYMPY_INTS, int)):\n        return True\n    if type(x) is float:\n        return x.is_integer()\n    if isinstance(x, Integer):\n        return True\n    if isinstance(x, Float):\n        # x = s*m*2**p; _mpf_ = s,m,e,p\n        return x._mpf_[2] >= 0\n    return False  # or add new types to recognize",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.core.relational._n2": "def _n2(a, b):\n    \"\"\"Return (a - b).evalf(2) if a and b are comparable, else None.\n    This should only be used when a and b are already sympified.\n    \"\"\"\n    # /!\\ it is very important (see issue 8245) not to\n    # use a re-evaluated number in the calculation of dif\n    if a.is_comparable and b.is_comparable:\n        dif = (a - b).evalf(2)\n        if dif.is_comparable:\n            return dif",
    "sympy.sympy.core.relational.is_eq": "def is_eq(lhs: Basic, rhs: Basic, assumptions=None) -> bool | None:\n    \"\"\"\n    Fuzzy bool representing mathematical equality between *lhs* and *rhs*.\n\n    Parameters\n    ==========\n\n    lhs : Expr\n        The left-hand side of the expression, must be sympified.\n\n    rhs : Expr\n        The right-hand side of the expression, must be sympified.\n\n    assumptions: Boolean, optional\n        Assumptions taken to evaluate the equality.\n\n    Returns\n    =======\n\n    ``True`` if *lhs* is equal to *rhs*, ``False`` is *lhs* is not equal to *rhs*,\n    and ``None`` if the comparison between *lhs* and *rhs* is indeterminate.\n\n    Explanation\n    ===========\n\n    This function is intended to give a relatively fast determination and\n    deliberately does not attempt slow calculations that might help in\n    obtaining a determination of True or False in more difficult cases.\n\n    :func:`~.is_neq` calls this function to return its value, so supporting\n    new type with this function will ensure correct behavior for ``is_neq``\n    as well.\n\n    Examples\n    ========\n\n    >>> from sympy import Q, S\n    >>> from sympy.core.relational import is_eq, is_neq\n    >>> from sympy.abc import x\n    >>> is_eq(S(0), S(0))\n    True\n    >>> is_neq(S(0), S(0))\n    False\n    >>> is_eq(S(0), S(2))\n    False\n    >>> is_neq(S(0), S(2))\n    True\n\n    Assumptions can be passed to evaluate the equality which is otherwise\n    indeterminate.\n\n    >>> print(is_eq(x, S(0)))\n    None\n    >>> is_eq(x, S(0), assumptions=Q.zero(x))\n    True\n\n    New types can be supported by dispatching to ``_eval_is_eq``.\n\n    >>> from sympy import Basic, sympify\n    >>> from sympy.multipledispatch import dispatch\n    >>> class MyBasic(Basic):\n    ...     def __new__(cls, arg):\n    ...         return Basic.__new__(cls, sympify(arg))\n    ...     @property\n    ...     def value(self):\n    ...         return self.args[0]\n    ...\n    >>> @dispatch(MyBasic, MyBasic)\n    ... def _eval_is_eq(a, b):\n    ...     return is_eq(a.value, b.value)\n    ...\n    >>> a = MyBasic(1)\n    >>> b = MyBasic(1)\n    >>> is_eq(a, b)\n    True\n    >>> is_neq(a, b)\n    False\n\n    \"\"\"\n    # here, _eval_Eq is only called for backwards compatibility\n    # new code should use is_eq with multiple dispatch as\n    # outlined in the docstring\n    for side1, side2 in (lhs, rhs), (rhs, lhs):\n        eval_func = getattr(side1, '_eval_Eq', None)\n        if eval_func is not None:\n            retval = eval_func(side2)\n            if retval is not None:\n                return retval\n\n    retval = _eval_is_eq(lhs, rhs)\n    if retval is not None:\n        return retval\n\n    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):\n        retval = _eval_is_eq(rhs, lhs)\n        if retval is not None:\n            return retval\n\n    # retval is still None, so go through the equality logic\n    # If expressions have the same structure, they must be equal.\n    if lhs == rhs:\n        return True  # e.g. True == True\n    elif all(isinstance(i, BooleanAtom) for i in (rhs, lhs)):\n        return False  # True != False\n    elif not (lhs.is_Symbol or rhs.is_Symbol) and (\n        isinstance(lhs, Boolean) !=\n        isinstance(rhs, Boolean)):\n        return False  # only Booleans can equal Booleans\n\n    from sympy.assumptions.wrapper import (AssumptionsWrapper,\n        is_infinite, is_extended_real)\n    from .add import Add\n\n    _lhs = AssumptionsWrapper(lhs, assumptions)\n    _rhs = AssumptionsWrapper(rhs, assumptions)\n\n    if _lhs.is_infinite or _rhs.is_infinite:\n        if fuzzy_xor([_lhs.is_infinite, _rhs.is_infinite]):\n            return False\n        if fuzzy_xor([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return False\n        if fuzzy_and([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return fuzzy_xor([_lhs.is_extended_positive, fuzzy_not(_rhs.is_extended_positive)])\n\n        # Try to split real/imaginary parts and equate them\n        I = S.ImaginaryUnit\n\n        def split_real_imag(expr):\n            real_imag = lambda t: (\n                'real' if is_extended_real(t, assumptions) else\n                'imag' if is_extended_real(I*t, assumptions) else None)\n            return sift(Add.make_args(expr), real_imag)\n\n        lhs_ri = split_real_imag(lhs)\n        if not lhs_ri[None]:\n            rhs_ri = split_real_imag(rhs)\n            if not rhs_ri[None]:\n                eq_real = is_eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']), assumptions)\n                eq_imag = is_eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']), assumptions)\n                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n\n        from sympy.functions.elementary.complexes import arg\n        # Compare e.g. zoo with 1+I*oo by comparing args\n        arglhs = arg(lhs)\n        argrhs = arg(rhs)\n        # Guard against Eq(nan, nan) -> False\n        if not (arglhs == S.NaN and argrhs == S.NaN):\n            return fuzzy_bool(is_eq(arglhs, argrhs, assumptions))\n\n    if isinstance(lhs, Expr) and isinstance(rhs, Expr):\n        # see if the difference evaluates\n        dif = lhs - rhs\n        _dif = AssumptionsWrapper(dif, assumptions)\n        z = _dif.is_zero\n        if z is not None:\n            if z is False and _dif.is_commutative:  # issue 10728\n                return False\n            if z:\n                return True\n\n        # is_zero cannot help decide integer/rational with Float\n        c, t = dif.as_coeff_Add()\n        if c.is_Float:\n            if int_valued(c):\n                if t.is_integer is False:\n                    return False\n            elif t.is_rational is False:\n                return False\n\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            return _sympify(n2 == 0)\n\n        # see if the ratio evaluates\n        n, d = dif.as_numer_denom()\n        rv = None\n        _n = AssumptionsWrapper(n, assumptions)\n        _d = AssumptionsWrapper(d, assumptions)\n        if _n.is_zero:\n            rv = _d.is_nonzero\n        elif _n.is_finite:\n            if _d.is_infinite:\n                rv = True\n            elif _n.is_zero is False:\n                rv = _d.is_infinite\n                if rv is None:\n                    # if the condition that makes the denominator\n                    # infinite does not make the original expression\n                    # True then False can be returned\n                    from sympy.simplify.simplify import clear_coefficients\n                    l, r = clear_coefficients(d, S.Infinity)\n                    lhs2 = lhs.subs(l, r)\n                    rhs2 = rhs.subs(l, r)\n                    if lhs2 != lhs or rhs2 != rhs:\n                        rv = fuzzy_bool(is_eq(lhs2, rhs2, assumptions))\n                        if rv is True:\n                            rv = None\n        elif any(is_infinite(a, assumptions) for a in Add.make_args(n)):\n            # (inf or nan)/x != 0\n            rv = False\n        if rv is not None:\n            return rv\n\n    return None",
    "sympy.sympy.core.relational.<genexpr>": "elif any(is_infinite(a, assumptions) for a in Add.make_args(n)):\n    # (inf or nan)/x != 0\n    rv = False\n",
    "sympy.sympy.core.relational.split_real_imag": "def split_real_imag(expr):\n    real_imag = lambda t: (\n        'real' if is_extended_real(t, assumptions) else\n        'imag' if is_extended_real(I*t, assumptions) else None)\n    return sift(Add.make_args(expr), real_imag)",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.matrices.expressions.matexpr.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        b = _sympify(b)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)",
    "sympy.sympy.multipledispatch.core.dispatch": "def dispatch(*types, namespace=global_namespace, on_ambiguity=ambiguity_warn):\n    \"\"\" Dispatch function on the types of the inputs\n\n    Supports dispatch on all non-keyword arguments.\n\n    Collects implementations based on the function name.  Ignores namespaces.\n\n    If ambiguous type signatures occur a warning is raised when the function is\n    defined suggesting the additional method to break the ambiguity.\n\n    Examples\n    --------\n\n    >>> from sympy.multipledispatch import dispatch\n    >>> @dispatch(int)\n    ... def f(x):\n    ...     return x + 1\n\n    >>> @dispatch(float)\n    ... def f(x): # noqa: F811\n    ...     return x - 1\n\n    >>> f(3)\n    4\n    >>> f(3.0)\n    2.0\n\n    Specify an isolated namespace with the namespace keyword argument\n\n    >>> my_namespace = dict()\n    >>> @dispatch(int, namespace=my_namespace)\n    ... def foo(x):\n    ...     return x + 1\n\n    Dispatch on instance methods within classes\n\n    >>> class MyClass(object):\n    ...     @dispatch(list)\n    ...     def __init__(self, data):\n    ...         self.data = data\n    ...     @dispatch(int)\n    ...     def __init__(self, datum): # noqa: F811\n    ...         self.data = [datum]\n    \"\"\"\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(\n                name,\n                MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _",
    "sympy.sympy.multipledispatch.dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple([type(arg) for arg in args])\n    try:\n        func = self._cache[types]\n    except KeyError:\n        func = self.dispatch(*types)\n        if not func:\n            raise NotImplementedError(\n                'Could not find signature for %s: <%s>' %\n                (self.name, str_signature(types)))\n        self._cache[types] = func\n    try:\n        return func(*args, **kwargs)\n\n    except MDNotImplementedError:\n        funcs = self.dispatch_iter(*types)\n        next(funcs)  # burn first\n        for func in funcs:\n            try:\n                return func(*args, **kwargs)\n            except MDNotImplementedError:\n                pass\n        raise NotImplementedError(\"Matching functions for \"\n                                  \"%s: <%s> found, but none completed successfully\"\n                                  % (self.name, str_signature(types)))",
    "sympy.sympy.sets.sets._eval_Eq": "def _eval_Eq(self, other):\n    if not isinstance(other, Interval):\n        if isinstance(other, FiniteSet):\n            return false\n        elif isinstance(other, Set):\n            return None\n        return false",
    "sympy.sympy.sets.sets.__eq__": "def __eq__(self, other):\n    if isinstance(other, (set, frozenset)):\n        return self._args_set == other\n    return super().__eq__(other)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.simplify.simplify.clear_coefficients": "def clear_coefficients(expr: Expr, rhs: Expr = S.Zero) -> tuple[Expr, Expr]:\n    \"\"\"Return `p, r` where `p` is the expression obtained when Rational\n    additive and multiplicative coefficients of `expr` have been stripped\n    away in a naive fashion (i.e. without simplification). The operations\n    needed to remove the coefficients will be applied to `rhs` and returned\n    as `r`.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.simplify import clear_coefficients\n    >>> from sympy.abc import x, y\n    >>> from sympy import Dummy\n    >>> expr = 4*y*(6*x + 3)\n    >>> clear_coefficients(expr - 2)\n    (y*(2*x + 1), 1/6)\n\n    When solving 2 or more expressions like `expr = a`,\n    `expr = b`, etc..., it is advantageous to provide a Dummy symbol\n    for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.\n\n    >>> rhs = Dummy('rhs')\n    >>> clear_coefficients(expr, rhs)\n    (y*(2*x + 1), _rhs/12)\n    >>> _[1].subs(rhs, 2)\n    1/6\n    \"\"\"\n    was = None\n    free = expr.free_symbols\n    if expr.is_Rational:\n        return (S.Zero, rhs - expr)\n    while expr and was != expr:\n        was = expr\n        m, expr = (\n            expr.as_content_primitive()\n            if free else\n            factor_terms(expr).as_coeff_Mul(rational=True))\n        rhs /= m\n        c, expr = expr.as_coeff_Add(rational=True)\n        rhs -= c\n    expr = signsimp(expr, evaluate = False)\n    if expr.could_extract_minus_sign():\n        expr = -expr\n        rhs = -rhs\n    return expr, rhs",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}