{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.geometry.point.<lambda>": "return m.rank(iszerofunc = lambda x:\n    abs(x.n(2)) < 1e-12 if x.is_number else x.is_zero)\n\n",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.determinant._find_reasonable_pivot": "def _find_reasonable_pivot(\n        col: Iterable[Expr],\n        iszerofunc: Callable[[Expr], bool | None] = _iszero,\n        simpfunc: Callable[[Expr], Expr] = _simplify,\n    ) -> tuple[int | None, Expr | None, bool, list[tuple[int, Expr]]]:\n    \"\"\" Find the lowest index of an item in ``col`` that is\n    suitable for a pivot.  If ``col`` consists only of\n    Floats, the pivot with the largest norm is returned.\n    Otherwise, the first element where ``iszerofunc`` returns\n    False is used.  If ``iszerofunc`` does not return false,\n    items are simplified and retested until a suitable\n    pivot is found.\n\n    Returns a 4-tuple\n        (pivot_offset, pivot_val, assumed_nonzero, newly_determined)\n    where pivot_offset is the index of the pivot, pivot_val is\n    the (possibly simplified) value of the pivot, assumed_nonzero\n    is True if an assumption that the pivot was non-zero\n    was made without being proved, and newly_determined are\n    elements that were simplified during the process of pivot\n    finding.\"\"\"\n\n    newly_determined: list[tuple[int, Expr]] = []\n    col = list(col)\n    # a column that contains a mix of floats and integers\n    # but at least one float is considered a numerical\n    # column, and so we do partial pivoting\n    if all(isinstance(x, (Float, Integer)) for x in col) and any(\n            isinstance(x, Float) for x in col):\n        col_abs = [abs(x) for x in col]\n        max_value = max(col_abs)\n        if iszerofunc(max_value):\n            # just because iszerofunc returned True, doesn't\n            # mean the value is numerically zero.  Make sure\n            # to replace all entries with numerical zeros\n            if max_value != 0:\n                newly_determined = [(i, S.Zero) for i, x in enumerate(col) if x != 0]\n            return (None, None, False, newly_determined)\n        index = col_abs.index(max_value)\n        return (index, col[index], False, newly_determined)\n\n    # PASS 1 (iszerofunc directly)\n    possible_zeros = []\n    for i, x in enumerate(col):\n        is_zero = iszerofunc(x)\n        # is someone wrote a custom iszerofunc, it may return\n        # BooleanFalse or BooleanTrue instead of True or False,\n        # so use == for comparison instead of `is`\n        if is_zero == False:\n            # we found something that is definitely not zero\n            return (i, x, False, newly_determined)\n        possible_zeros.append(is_zero)\n\n    # by this point, we've found no certain non-zeros\n    if all(possible_zeros):\n        # if everything is definitely zero, we have\n        # no pivot\n        return (None, None, False, newly_determined)\n\n    # PASS 2 (iszerofunc after simplify)\n    # we haven't found any for-sure non-zeros, so\n    # go through the elements iszerofunc couldn't\n    # make a determination about and opportunistically\n    # simplify to see if we find something\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        simped = simpfunc(x)\n        is_zero = iszerofunc(simped)\n        if is_zero in (True, False):\n            newly_determined.append((i, simped))\n        if is_zero == False:\n            return (i, simped, False, newly_determined)\n        possible_zeros[i] = is_zero\n\n    # after simplifying, some things that were recognized\n    # as zeros might be zeros\n    if all(possible_zeros):\n        # if everything is definitely zero, we have\n        # no pivot\n        return (None, None, False, newly_determined)\n\n    # PASS 3 (.equals(0))\n    # some expressions fail to simplify to zero, but\n    # ``.equals(0)`` evaluates to True.  As a last-ditch\n    # attempt, apply ``.equals`` to these expressions\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        if x.equals(S.Zero):\n            # ``.iszero`` may return False with\n            # an implicit assumption (e.g., ``x.equals(0)``\n            # when ``x`` is a symbol), so only treat it\n            # as proved when ``.equals(0)`` returns True\n            possible_zeros[i] = True\n            newly_determined.append((i, S.Zero))\n\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n\n    # at this point there is nothing that could definitely\n    # be a pivot.  To maintain compatibility with existing\n    # behavior, we'll assume that an illdetermined thing is\n    # non-zero.  We should probably raise a warning in this case\n    i = possible_zeros.index(None)\n    return (i, col[i], True, newly_determined)",
    "sympy.sympy.matrices.reductions.get_col": "def get_col(i):\n    return mat[i::cols]",
    "sympy.sympy.matrices.reductions.row_swap": "def row_swap(i, j):\n    mat[i*cols:(i + 1)*cols], mat[j*cols:(j + 1)*cols] = \\\n        mat[j*cols:(j + 1)*cols], mat[i*cols:(i + 1)*cols]",
    "sympy.sympy.matrices.reductions.cross_cancel": "def cross_cancel(a, i, b, j):\n    \"\"\"Does the row op row[i] = a*row[i] - b*row[j]\"\"\"\n    q = (j - i)*cols\n    for p in range(i*cols, (i + 1)*cols):\n        mat[p] = isimp(a*mat[p] - b*mat[p + q])",
    "sympy.sympy.matrices.utilities._dotprodsimp": "def _dotprodsimp(expr: Expr, withsimp: bool = False) -> Expr | tuple[Expr, bool]:\n    \"\"\"Wrapper for simplify.dotprodsimp to avoid circular imports.\"\"\"\n    from sympy.simplify.simplify import dotprodsimp as dps\n    return dps(expr, withsimp=withsimp)",
    "sympy.sympy.matrices.utilities._get_intermediate_simp": "def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x,\n        onfunc=_dotprodsimp, dotprodsimp=None):\n    \"\"\"Support function for controlling intermediate simplification. Returns a\n    simplification function according to the global setting of dotprodsimp\n    operation.\n\n    ``deffunc``     - Function to be used by default.\n    ``offfunc``     - Function to be used if dotprodsimp has been turned off.\n    ``onfunc``      - Function to be used if dotprodsimp has been turned on.\n    ``dotprodsimp`` - True, False or None. Will be overridden by global\n                      _dotprodsimp_state.state if that is not None.\n    \"\"\"\n\n    if dotprodsimp is False or _dotprodsimp_state.state is False:\n        return offfunc\n    if dotprodsimp is True or _dotprodsimp_state.state is True:\n        return onfunc\n\n    return deffunc # None, None",
    "sympy.sympy.matrices.utilities._iszero": "def _iszero(x: Expr) -> bool | None:\n    \"\"\"Returns True if x is zero.\"\"\"\n    return getattr(x, 'is_zero', None)"
}