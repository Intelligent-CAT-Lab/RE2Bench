{
    "matplotlib.lib.matplotlib.cbook.contiguous_regions": "def contiguous_regions(mask):\n    \"\"\"\n    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\n    True and we cover all such regions.\n    \"\"\"\n    mask = np.asarray(mask, dtype=bool)\n\n    if not mask.size:\n        return []\n\n    # Find the indices of region changes, and correct offset\n    idx, = np.nonzero(mask[:-1] != mask[1:])\n    idx += 1\n\n    # List operations are faster for moderately sized arrays\n    idx = idx.tolist()\n\n    # Add first and/or last index if needed\n    if mask[0]:\n        idx = [0] + idx\n    if mask[-1]:\n        idx.append(len(mask))\n\n    return list(zip(idx[::2], idx[1::2]))",
    "matplotlib.lib.matplotlib.collections._f_direction": "@property\ndef _f_direction(self):\n    \"\"\"The direction that is other than `self.t_direction`.\"\"\"\n    return self._f_dir_from_t(self.t_direction)",
    "matplotlib.lib.matplotlib.collections.<listcomp>": "return [\n    self._make_verts_for_region(t, f1, f2, idx0, idx1)\n    for idx0, idx1 in cbook.contiguous_regions(where)\n",
    "matplotlib.lib.matplotlib.collections._get_data_mask": "def _get_data_mask(self, t, f1, f2, where):\n    \"\"\"\n    Return a bool array, with True at all points that should eventually be rendered.\n\n    The array is True at a point if none of the data inputs\n    *t*, *f1*, *f2* is masked and if the input *where* is true at that point.\n    \"\"\"\n    if where is None:\n        where = True\n    else:\n        where = np.asarray(where, dtype=bool)\n        if where.size != t.size:\n            msg = \"where size ({}) does not match {!r} size ({})\".format(\n                where.size, self.t_direction, t.size)\n            raise ValueError(msg)\n    return where & ~functools.reduce(\n        np.logical_or, map(np.ma.getmaskarray, [t, f1, f2]))",
    "matplotlib.lib.matplotlib.collections._validate_shapes": "@staticmethod\ndef _validate_shapes(t_dir, f_dir, t, f1, f2):\n    \"\"\"Validate that t, f1 and f2 are 1-dimensional and have the same length.\"\"\"\n    names = (d + s for d, s in zip((t_dir, f_dir, f_dir), (\"\", \"1\", \"2\")))\n    for name, array in zip(names, [t, f1, f2]):\n        if array.ndim > 1:\n            raise ValueError(f\"{name!r} is not 1-dimensional\")\n        if t.size > 1 and array.size > 1 and t.size != array.size:\n            msg = \"{!r} has size {}, but {!r} has an unequal size of {}\".format(\n                t_dir, t.size, name, array.size)\n            raise ValueError(msg)",
    "matplotlib.lib.matplotlib.collections._fix_pts_xy_order": "def _fix_pts_xy_order(self, pts):\n    \"\"\"\n    Fix pts calculation results with `self.t_direction`.\n\n    In the workflow, it is assumed that `self.t_direction` is 'x'. If this\n    is not true, we need to exchange the coordinates.\n    \"\"\"\n    return pts[:, ::-1] if self.t_direction == \"y\" else pts",
    "matplotlib.lib.matplotlib.transforms.null": "@staticmethod\ndef null():\n    \"\"\"Create a new null `Bbox` from (inf, inf) to (-inf, -inf).\"\"\"\n    return Bbox([[np.inf, np.inf], [-np.inf, -np.inf]])",
    "matplotlib.lib.matplotlib.transforms.update_from_data_xy": "def update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True):\n    \"\"\"\n    Update the `Bbox` bounds based on the passed in *xy* coordinates.\n\n    After updating, the bounds will have positive *width* and *height*;\n    *x0* and *y0* will be the minimal values.\n\n    Parameters\n    ----------\n    xy : (N, 2) array-like\n        The (x, y) coordinates.\n    ignore : bool, optional\n        - When ``True``, ignore the existing bounds of the `Bbox`.\n        - When ``False``, include the existing bounds of the `Bbox`.\n        - When ``None``, use the last value passed to :meth:`ignore`.\n    updatex, updatey : bool, default: True\n         When ``True``, update the x/y values.\n    \"\"\"\n    if len(xy) == 0:\n        return\n\n    path = Path(xy)\n    self.update_from_path(path, ignore=ignore,\n                          updatex=updatex, updatey=updatey)"
}