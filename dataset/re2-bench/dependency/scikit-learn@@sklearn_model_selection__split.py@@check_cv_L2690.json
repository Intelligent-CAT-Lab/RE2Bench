{
    "scikit-learn.sklearn.model_selection._split.__init__": "def __init__(self, n_splits=5, *, shuffle=False, random_state=None):\n    super().__init__(n_splits=n_splits, shuffle=shuffle, random_state=random_state)",
    "scikit-learn.sklearn.utils.multiclass.type_of_target": "def type_of_target(y, input_name=\"\", raise_unknown=False):\n    \"\"\"Determine the type of data indicated by the target.\n\n    Note that this type is the most specific type that can be inferred.\n    For example:\n\n    * ``binary`` is more specific but compatible with ``multiclass``.\n    * ``multiclass`` of integers is more specific but compatible with ``continuous``.\n    * ``multilabel-indicator`` is more specific but compatible with\n      ``multiclass-multioutput``.\n\n    Parameters\n    ----------\n    y : {array-like, sparse matrix}\n        Target values. If a sparse matrix, `y` is expected to be a\n        CSR/CSC matrix.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message.\n\n        .. versionadded:: 1.1.0\n\n    raise_unknown : bool, default=False\n        If `True`, raise an error when the type of target returned by\n        :func:`~sklearn.utils.multiclass.type_of_target` is `\"unknown\"`.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    target_type : str\n        One of:\n\n        * 'continuous': `y` is an array-like of floats that are not all\n          integers, and is 1d or a column vector.\n        * 'continuous-multioutput': `y` is a 2d array of floats that are\n          not all integers, and both dimensions are of size > 1.\n        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n          vector.\n        * 'multiclass': `y` contains more than two discrete values, is not a\n          sequence of sequences, and is 1d or a column vector.\n        * 'multiclass-multioutput': `y` is a 2d array that contains more\n          than two discrete values, is not a sequence of sequences, and both\n          dimensions are of size > 1.\n        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n          of two dimensions with at least two columns, and at most 2 unique\n          values.\n        * 'unknown': `y` is array-like but none of the above, such as a 3d\n          array, sequence of sequences, or an array of non-sequence objects.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import type_of_target\n    >>> import numpy as np\n    >>> type_of_target([0.1, 0.6])\n    'continuous'\n    >>> type_of_target([1, -1, -1, 1])\n    'binary'\n    >>> type_of_target(['a', 'b', 'a'])\n    'binary'\n    >>> type_of_target([1.0, 2.0])\n    'binary'\n    >>> type_of_target([1, 0, 2])\n    'multiclass'\n    >>> type_of_target([1.0, 0.0, 3.0])\n    'multiclass'\n    >>> type_of_target(['a', 'b', 'c'])\n    'multiclass'\n    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n    'multiclass-multioutput'\n    >>> type_of_target([[1, 2]])\n    'multilabel-indicator'\n    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n    'continuous-multioutput'\n    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n    'multilabel-indicator'\n    \"\"\"\n    xp, is_array_api_compliant = get_namespace(y)\n\n    def _raise_or_return():\n        \"\"\"Depending on the value of raise_unknown, either raise an error or return\n        'unknown'.\n        \"\"\"\n        if raise_unknown:\n            input = input_name if input_name else \"data\"\n            raise ValueError(f\"Unknown label type for {input}: {y!r}\")\n        else:\n            return \"unknown\"\n\n    valid = (\n        (isinstance(y, Sequence) or issparse(y) or hasattr(y, \"__array__\"))\n        and not isinstance(y, str)\n    ) or is_array_api_compliant\n\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    check_y_kwargs = dict(\n        accept_sparse=True,\n        allow_nd=True,\n        ensure_all_finite=False,\n        ensure_2d=False,\n        ensure_min_samples=0,\n        ensure_min_features=0,\n    )\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                y = check_array(y, dtype=None, **check_y_kwargs)\n            except (VisibleDeprecationWarning, ValueError) as e:\n                if str(e).startswith(\"Complex data not supported\"):\n                    raise\n\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = check_array(y, dtype=object, **check_y_kwargs)\n\n    try:\n        first_row_or_val = y[[0], :] if issparse(y) else y[0]\n        # labels in bytes format\n        if isinstance(first_row_or_val, bytes):\n            raise TypeError(\n                \"Support for labels represented as bytes is not supported. Convert \"\n                \"the labels to a string or integer format.\"\n            )\n        # The old sequence of sequences format\n        if (\n            not hasattr(first_row_or_val, \"__array__\")\n            and isinstance(first_row_or_val, Sequence)\n            and not isinstance(first_row_or_val, str)\n        ):\n            raise ValueError(\n                \"You appear to be using a legacy multi-label data\"\n                \" representation. Sequence of sequences are no\"\n                \" longer supported; use a binary array or sparse\"\n                \" matrix instead - the MultiLabelBinarizer\"\n                \" transformer can convert to this format.\"\n            )\n    except IndexError:\n        pass\n\n    # Invalid inputs\n    if y.ndim not in (1, 2):\n        # Number of dimension greater than 2: [[[1, 2]]]\n        return _raise_or_return()\n    if not min(y.shape):\n        # Empty ndarray: []/[[]]\n        if y.ndim == 1:\n            # 1-D empty array: []\n            return \"binary\"  # []\n        # 2-D empty array: [[]]\n        return _raise_or_return()\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return _raise_or_return()\n\n    # Check if multioutput\n    if y.ndim == 2 and y.shape[1] > 1:\n        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n    else:\n        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n\n    # Check float and contains non-integer float values\n    if xp.isdtype(y.dtype, \"real floating\"):\n        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n        data = y.data if issparse(y) else y\n        integral_data = xp.astype(data, xp.int64)\n        # conversion back to the original float dtype of y is required to\n        # satisfy array-api-strict which does not allow a comparison between\n        # arrays having different dtypes.\n        if xp.any(data != xp.astype(integral_data, y.dtype)):\n            _assert_all_finite(data, input_name=input_name)\n            return \"continuous\" + suffix\n\n    # Check multiclass\n    if issparse(first_row_or_val):\n        first_row_or_val = first_row_or_val.data\n    if cached_unique(y).shape[0] > 2 or (y.ndim == 2 and len(first_row_or_val) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]"
}