{
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.logic.algorithms.lra_theory.<genexpr>": "assert all(abs(val) < 10 ** (-10) for val in M * X)\n\n",
    "sympy.sympy.logic.algorithms.lra_theory.<listcomp>": "X = Matrix([v.assign[0] for v in self.all_var])\n",
    "sympy.sympy.logic.algorithms.lra_theory._update": "def _update(self, xi, v):\n    \"\"\"\n    Updates all slack variables that have equations that contain\n    variable xi so that they stay satisfied given xi is equal to v.\n    \"\"\"\n    i = xi.col_idx\n    for j, b in enumerate(self.slack):\n        aji = self.A[j, i]\n        b.assign = b.assign + (v - xi.assign)*aji\n    xi.assign = v",
    "sympy.sympy.logic.algorithms.lra_theory.__init__": "def __init__(self, var, const, upper, equality, strict=None):\n    if not equality in [True, False]:\n        assert equality in [True, False]\n\n\n    self.var = var\n    if isinstance(const, tuple):\n        s = const[1] != 0\n        if strict:\n            assert s == strict\n        self.bound = const[0]\n        self.strict = s\n    else:\n        self.bound = const\n        self.strict = strict\n    self.upper = upper if not equality else None\n    self.equality = equality\n    self.strict = strict\n    assert self.strict is not None",
    "sympy.sympy.logic.algorithms.lra_theory.from_lower": "@staticmethod\ndef from_lower(var):\n    neg = -1 if var.lower_from_neg else 1\n    b = Boundary(var, var.lower[0], False, var.lower_from_eq, var.lower[1] != 0)\n    if neg < 0:\n        b = b.get_negated()\n    return b, neg",
    "sympy.sympy.logic.algorithms.lra_theory.get_negated": "def get_negated(self):\n    return Boundary(self.var, self.bound, not self.upper, self.equality, not self.strict)",
    "sympy.sympy.logic.algorithms.lra_theory.__eq__": "def __eq__(self, other):\n    if not isinstance(other, LRAVariable):\n        return False\n    return other.var == self.var",
    "sympy.sympy.logic.algorithms.lra_theory.__hash__": "def __hash__(self):\n    return hash((self.var, self.bound, self.strict, self.upper, self.equality))",
    "sympy.sympy.logic.algorithms.lra_theory.__lt__": "def __lt__(self, other):\n    return self.value < other.value",
    "sympy.sympy.logic.algorithms.lra_theory.__le__": "def __le__(self, other):\n    return self.value <= other.value",
    "sympy.sympy.logic.algorithms.lra_theory.__getitem__": "def __getitem__(self, index):\n    return self.value[index]",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.repmatrix.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)"
}