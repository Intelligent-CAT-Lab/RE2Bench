{
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e",
    "scikit-learn.sklearn.utils.extmath.svd_flip": "def svd_flip(u, v, u_based_decision=True):\n    \"\"\"Sign correction to ensure deterministic output from SVD.\n\n    Adjusts the columns of u and the rows of v such that the loadings in the\n    columns in u that are largest in absolute value are always positive.\n\n    If u_based_decision is False, then the same sign correction is applied to\n    so that the rows in v that are largest in absolute value are always\n    positive.\n\n    Parameters\n    ----------\n    u : ndarray\n        Parameters u and v are the output of `linalg.svd` or\n        :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner\n        dimensions so one can compute `np.dot(u * s, v)`.\n        u can be None if `u_based_decision` is False.\n\n    v : ndarray\n        Parameters u and v are the output of `linalg.svd` or\n        :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner\n        dimensions so one can compute `np.dot(u * s, v)`. The input v should\n        really be called vt to be consistent with scipy's output.\n        v can be None if `u_based_decision` is True.\n\n    u_based_decision : bool, default=True\n        If True, use the columns of u as the basis for sign flipping.\n        Otherwise, use the rows of v. The choice of which variable to base the\n        decision on is generally algorithm dependent.\n\n    Returns\n    -------\n    u_adjusted : ndarray\n        Array u with adjusted columns and the same dimensions as u.\n\n    v_adjusted : ndarray\n        Array v with adjusted rows and the same dimensions as v.\n    \"\"\"\n    xp, _ = get_namespace(*[a for a in [u, v] if a is not None])\n\n    if u_based_decision:\n        # columns of u, rows of v, or equivalently rows of u.T and v\n        max_abs_u_cols = xp.argmax(xp.abs(u.T), axis=1)\n        shift = xp.arange(u.T.shape[0], device=device(u))\n        indices = max_abs_u_cols + shift * u.T.shape[1]\n        signs = xp.sign(xp.take(xp.reshape(u.T, (-1,)), indices, axis=0))\n        u *= signs[np.newaxis, :]\n        if v is not None:\n            v *= signs[:, np.newaxis]\n    else:\n        # rows of v, columns of u\n        max_abs_v_rows = xp.argmax(xp.abs(v), axis=1)\n        shift = xp.arange(v.shape[0], device=device(v))\n        indices = max_abs_v_rows + shift * v.shape[1]\n        signs = xp.sign(xp.take(xp.reshape(v, (-1,)), indices, axis=0))\n        if u is not None:\n            u *= signs[np.newaxis, :]\n        v *= signs[:, np.newaxis]\n    return u, v"
}