{
    "sympy.sympy.ntheory.generate.search": "def search(self, n):\n    \"\"\"Return the indices i, j of the primes that bound n.\n\n    If n is prime then i == j.\n\n    Although n can be an expression, if ceiling cannot convert\n    it to an integer then an n error will be raised.\n\n    Examples\n    ========\n\n    >>> from sympy import sieve\n    >>> sieve.search(25)\n    (9, 10)\n    >>> sieve.search(23)\n    (9, 9)\n    \"\"\"\n    test = _as_int_ceiling(n)\n    n = as_int(n)\n    if n < 2:\n        raise ValueError(f\"n should be >= 2 but got: {n}\")\n    if n > self._list[-1]:\n        self.extend(n)\n    b = bisect(self._list, n)\n    if self._list[b - 1] == test:\n        return b, b\n    else:\n        return b, b + 1",
    "sympy.sympy.ntheory.primetest.isprime": "def isprime(n):\n    \"\"\"\n    Test if n is a prime number (True) or not (False). For n < 2^64 the\n    answer is definitive; larger n values have a small probability of actually\n    being pseudoprimes.\n\n    Negative numbers (e.g. -2) are not considered prime.\n\n    The first step is looking for trivial factors, which if found enables\n    a quick return.  Next, if the sieve is large enough, use bisection search\n    on the sieve.  For small numbers, a set of deterministic Miller-Rabin\n    tests are performed with bases that are known to have no counterexamples\n    in their range.  Finally if the number is larger than 2^64, a strong\n    BPSW test is performed.  While this is a probable prime test and we\n    believe counterexamples exist, there are no known counterexamples.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import isprime\n    >>> isprime(13)\n    True\n    >>> isprime(15)\n    False\n\n    Notes\n    =====\n\n    This routine is intended only for integer input, not numerical\n    expressions which may represent numbers. Floats are also\n    rejected as input because they represent numbers of limited\n    precision. While it is tempting to permit 7.0 to represent an\n    integer there are errors that may \"pass silently\" if this is\n    allowed:\n\n    >>> from sympy import Float, S\n    >>> int(1e3) == 1e3 == 10**3\n    True\n    >>> int(1e23) == 1e23\n    True\n    >>> int(1e23) == 10**23\n    False\n\n    >>> near_int = 1 + S(1)/10**19\n    >>> near_int == int(near_int)\n    False\n    >>> n = Float(near_int, 10)  # truncated by precision\n    >>> n % 1 == 0\n    True\n    >>> n = Float(near_int, 20)\n    >>> n % 1 == 0\n    False\n\n    See Also\n    ========\n\n    sympy.ntheory.generate.primerange : Generates all primes in a given range\n    sympy.functions.combinatorial.numbers.primepi : Return the number of primes less than or equal to n\n    sympy.ntheory.generate.prime : Return the nth prime\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Strong_pseudoprime\n    .. [2] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [3] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n    \"\"\"\n    n = as_int(n)\n\n    # Step 1, do quick composite testing via trial division.  The individual\n    # modulo tests benchmark faster than one or two primorial igcds for me.\n    # The point here is just to speedily handle small numbers and many\n    # composites.  Step 2 only requires that n <= 2 get handled here.\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or (n % 2) == 0 or (n % 3) == 0 or (n % 5) == 0:\n        return False\n    if n < 49:\n        return True\n    if (n %  7) == 0 or (n % 11) == 0 or (n % 13) == 0 or (n % 17) == 0 or \\\n       (n % 19) == 0 or (n % 23) == 0 or (n % 29) == 0 or (n % 31) == 0 or \\\n       (n % 37) == 0 or (n % 41) == 0 or (n % 43) == 0 or (n % 47) == 0:\n        return False\n    if n < 2809:\n        return True\n    if n < 65077:\n        # There are only five Euler pseudoprimes with a least prime factor greater than 47\n        return pow(2, n >> 1, n) in [1, n - 1] and n not in [8321, 31621, 42799, 49141, 49981]\n\n    # bisection search on the sieve if the sieve is large enough\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.ntheory.factor_ import factor_cache\n    if (ret := factor_cache.get(n)) is not None:\n        return ret == n\n\n    # If we have GMPY2, skip straight to step 3 and do a strong BPSW test.\n    # This should be a bit faster than our step 2, and for large values will\n    # be a lot faster than our step 3 (C+GMP vs. Python).\n    if _gmpy is not None:\n        return is_strong_bpsw_prp(n)\n\n\n    # Step 2: deterministic Miller-Rabin testing for numbers < 2^64.  See:\n    #    https://miller-rabin.appspot.com/\n    # for lists.  We have made sure the M-R routine will successfully handle\n    # bases larger than n, so we can use the minimal set.\n    # In September 2015 deterministic numbers were extended to over 2^81.\n    #    https://arxiv.org/pdf/1509.00864.pdf\n    #    https://oeis.org/A014233\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 4296595241:\n        # Michal Forisek and Jakub Jancina,\n        # Fast Primality Testing for Integers That Fit into a Machine Word\n        # https://ceur-ws.org/Vol-1326/020-Forisek.pdf\n        h = ((n >> 16) ^ n) * 0x45d9f3b\n        h = ((h >> 16) ^ h) * 0x45d9f3b\n        h = ((h >> 16) ^ h) & 255\n        return mr(n, [_MR_BASES_32[h]])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    if n < 318665857834031151167461:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37])\n    if n < 3317044064679887385961981:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])\n\n    # We could do this instead at any point:\n    #if n < 18446744073709551616:\n    #   return mr(n, [2]) and is_extra_strong_lucas_prp(n)\n\n    # Here are tests that are safe for MR routines that don't understand\n    # large bases.\n    #if n < 9080191:\n    #    return mr(n, [31, 73])\n    #if n < 19471033:\n    #    return mr(n, [2, 299417])\n    #if n < 38010307:\n    #    return mr(n, [2, 9332593])\n    #if n < 316349281:\n    #    return mr(n, [11000544, 31481107])\n    #if n < 4759123141:\n    #    return mr(n, [2, 7, 61])\n    #if n < 105936894253:\n    #    return mr(n, [2, 1005905886, 1340600841])\n    #if n < 31858317218647:\n    #    return mr(n, [2, 642735, 553174392, 3046413974])\n    #if n < 3071837692357849:\n    #    return mr(n, [2, 75088, 642735, 203659041, 3613982119])\n    #if n < 18446744073709551616:\n    #    return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n\n    # Step 3: BPSW.\n    #\n    #  Time for isprime(10**2000 + 4561), no gmpy or gmpy2 installed\n    #     44.0s   old isprime using 46 bases\n    #      5.3s   strong BPSW + one random base\n    #      4.3s   extra strong BPSW + one random base\n    #      4.1s   strong BPSW\n    #      3.2s   extra strong BPSW\n\n    # Classic BPSW from page 1401 of the paper.  See alternate ideas below.\n    return is_strong_bpsw_prp(n)",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}