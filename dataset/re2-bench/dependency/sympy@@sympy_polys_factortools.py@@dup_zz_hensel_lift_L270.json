{
    "sympy.sympy.polys.densearith.dup_mul_ground": "def dup_mul_ground(f: dup[Er], c: Er, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul_ground(x**2 + 2*x - 1, ZZ(3))\n    3*x**2 + 6*x - 3\n\n    \"\"\"\n    if not c or not f:\n        return []\n    else:\n        return [ cf * c for cf in f ]",
    "sympy.sympy.polys.densebasic.dup_LC": "def dup_LC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_LC\n\n    >>> dup_LC([1, 2, 3], ZZ)\n    1\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    "sympy.sympy.polys.densetools.dup_trunc": "def dup_trunc(f: dup[Eeuclid], p: Eeuclid, K: Domain[Eeuclid]) -> dup[Eeuclid]:\n    \"\"\"\n    Reduce a ``K[x]`` polynomial modulo a constant ``p`` in ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_trunc(2*x**3 + 3*x**2 + 5*x + 7, ZZ(3))\n    -x**3 - x + 1\n\n    \"\"\"\n    if K.is_ZZ:\n        g: list[Eeuclid] = []\n\n        for c in f:\n            c = c % p\n\n            if c > p // 2: # type: ignore\n                g.append(c - p)\n            else:\n                g.append(c)\n    elif K.is_FiniteField:\n        # XXX: python-flint's nmod does not support %\n        pi = int(p) # type: ignore\n        g = [ K(int(c) % pi) for c in f ] # type: ignore\n    else:\n        g = [ c % p for c in f ]\n\n    return dup_strip(g, K)",
    "sympy.sympy.polys.domains.integerring.gcdex": "def gcdex(self, a: MPZ, b: MPZ) -> tuple[MPZ, MPZ, MPZ]:\n    \"\"\"Compute extended GCD of ``a`` and ``b``. \"\"\"\n    h, s, t = gcdex(a, b)\n    # XXX: This conditional logic should be handled somewhere else.\n    if GROUND_TYPES == 'gmpy':\n        return s, t, h\n    else:\n        return h, s, t",
    "sympy.sympy.polys.factortools.dup_zz_hensel_step": "def dup_zz_hensel_step(m, f, g, h, s, t, K):\n    \"\"\"\n    One step in Hensel lifting in `Z[x]`.\n\n    Given positive integer `m` and `Z[x]` polynomials `f`, `g`, `h`, `s`\n    and `t` such that::\n\n        f = g*h (mod m)\n        s*g + t*h = 1 (mod m)\n\n        lc(f) is not a zero divisor (mod m)\n        lc(h) = 1\n\n        deg(f) = deg(g) + deg(h)\n        deg(s) < deg(h)\n        deg(t) < deg(g)\n\n    returns polynomials `G`, `H`, `S` and `T`, such that::\n\n        f = G*H (mod m**2)\n        S*G + T*H = 1 (mod m**2)\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    M = m**2\n\n    e = dup_sub_mul(f, g, h, K)\n    e = dup_trunc(e, M, K)\n\n    q, r = dup_div(dup_mul(s, e, K), h, K)\n\n    q = dup_trunc(q, M, K)\n    r = dup_trunc(r, M, K)\n\n    u = dup_add(dup_mul(t, e, K), dup_mul(q, g, K), K)\n    G = dup_trunc(dup_add(g, u, K), M, K)\n    H = dup_trunc(dup_add(h, r, K), M, K)\n\n    u = dup_add(dup_mul(s, G, K), dup_mul(t, H, K), K)\n    b = dup_trunc(dup_sub(u, [K.one], K), M, K)\n\n    c, d = dup_div(dup_mul(s, b, K), H, K)\n\n    c = dup_trunc(c, M, K)\n    d = dup_trunc(d, M, K)\n\n    u = dup_add(dup_mul(t, b, K), dup_mul(c, G, K), K)\n    S = dup_trunc(dup_sub(s, d, K), M, K)\n    T = dup_trunc(dup_sub(t, u, K), M, K)\n\n    return G, H, S, T",
    "sympy.sympy.polys.factortools.dup_zz_hensel_lift": "def dup_zz_hensel_lift(p, f, f_list, l, K):\n    r\"\"\"\n    Multifactor Hensel lifting in `Z[x]`.\n\n    Given a prime `p`, polynomial `f` over `Z[x]` such that `lc(f)`\n    is a unit modulo `p`, monic pair-wise coprime polynomials `f_i`\n    over `Z[x]` satisfying::\n\n        f = lc(f) f_1 ... f_r (mod p)\n\n    and a positive integer `l`, returns a list of monic polynomials\n    `F_1,\\ F_2,\\ \\dots,\\ F_r` satisfying::\n\n       f = lc(f) F_1 ... F_r (mod p**l)\n\n       F_i = f_i (mod p), i = 1..r\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    r = len(f_list)\n    lc = dup_LC(f, K)\n\n    if r == 1:\n        F = dup_mul_ground(f, K.gcdex(lc, p**l)[0], K)\n        return [ dup_trunc(F, p**l, K) ]\n\n    m = p\n    k = r // 2\n    d = int(_ceil(_log2(l)))\n\n    g = gf_from_int_poly([lc], p)\n\n    for f_i in f_list[:k]:\n        g = gf_mul(g, gf_from_int_poly(f_i, p), p, K)\n\n    h = gf_from_int_poly(f_list[k], p)\n\n    for f_i in f_list[k + 1:]:\n        h = gf_mul(h, gf_from_int_poly(f_i, p), p, K)\n\n    s, t, _ = gf_gcdex(g, h, p, K)\n\n    g = gf_to_int_poly(g, p)\n    h = gf_to_int_poly(h, p)\n    s = gf_to_int_poly(s, p)\n    t = gf_to_int_poly(t, p)\n\n    for _ in range(1, d + 1):\n        (g, h, s, t), m = dup_zz_hensel_step(m, f, g, h, s, t, K), m**2\n\n    return dup_zz_hensel_lift(p, g, f_list[:k], l, K) \\\n        + dup_zz_hensel_lift(p, h, f_list[k:], l, K)",
    "sympy.sympy.polys.galoistools.gf_gcdex": "def gf_gcdex(\n    f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]\n) -> tuple[dup[MPZ], dup[MPZ], dup[MPZ]]:\n    \"\"\"\n    Extended Euclidean Algorithm in ``GF(p)[x]``.\n\n    Given polynomials ``f`` and ``g`` in ``GF(p)[x]``, computes polynomials\n    ``s``, ``t`` and ``h``, such that ``h = gcd(f, g)`` and ``s*f + t*g = h``.\n    The typical application of EEA is solving polynomial diophantine equations.\n\n    Consider polynomials ``f = (x + 7) (x + 1)``, ``g = (x + 7) (x**2 + 1)``\n    in ``GF(11)[x]``. Application of Extended Euclidean Algorithm gives::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_gcdex, gf_mul, gf_add\n\n       >>> s, t, g = gf_gcdex(ZZ.map([1, 8, 7]), ZZ.map([1, 7, 1, 7]), 11, ZZ)\n       >>> s, t, g\n       ([5, 6], [6], [1, 7])\n\n    As result we obtained polynomials ``s = 5*x + 6`` and ``t = 6``, and\n    additionally ``gcd(f, g) = x + 7``. This is correct because::\n\n       >>> S = gf_mul(s, ZZ.map([1, 8, 7]), 11, ZZ)\n       >>> T = gf_mul(t, ZZ.map([1, 7, 1, 7]), 11, ZZ)\n\n       >>> gf_add(S, T, 11, ZZ) == [1, 7]\n       True\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    if not (f or g):\n        return [K.one], [], []\n\n    p0, r0 = gf_monic(f, p, K)\n    p1, r1 = gf_monic(g, p, K)\n\n    if not f:\n        return [], [K.invert(p1, p)], r1\n    if not g:\n        return [K.invert(p0, p)], [], r0\n\n    s0: dup[MPZ] = [K.invert(p0, p)]\n    s1: dup[MPZ] = []\n    t0: dup[MPZ] = []\n    t1: dup[MPZ] = [K.invert(p1, p)]\n\n    while True:\n        Q, R = gf_div(r0, r1, p, K)\n\n        if not R:\n            break\n\n        (lc, r1), r0 = gf_monic(R, p, K), r1\n\n        inv = K.invert(lc, p)\n\n        s = gf_sub_mul(s0, s1, Q, p, K)\n        t = gf_sub_mul(t0, t1, Q, p, K)\n\n        s1, s0 = gf_mul_ground(s, inv, p, K), s1\n        t1, t0 = gf_mul_ground(t, inv, p, K), t1\n\n    return s1, t1, r1",
    "sympy.sympy.polys.galoistools.gf_from_int_poly": "def gf_from_int_poly(f: dup[MPZ], p: MPZ) -> dup[MPZ]:\n    \"\"\"\n    Create a ``GF(p)[x]`` polynomial from ``Z[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_from_int_poly\n\n    >>> gf_from_int_poly([7, -2, 3], 5)\n    [2, 3, 3]\n\n    \"\"\"\n    return gf_trunc(f, p)",
    "sympy.sympy.polys.galoistools.gf_to_int_poly": "def gf_to_int_poly(f: dup[MPZ], p: MPZ, symmetric: bool = True) -> dup[MPZ]:\n    \"\"\"\n    Convert a ``GF(p)[x]`` polynomial to ``Z[x]``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_to_int_poly\n\n    >>> gf_to_int_poly([2, 3, 3], 5)\n    [2, -2, -2]\n    >>> gf_to_int_poly([2, 3, 3], 5, symmetric=False)\n    [2, 3, 3]\n\n    \"\"\"\n    if symmetric:\n        return [gf_int(c, p) for c in f]\n    else:\n        return f",
    "sympy.sympy.polys.galoistools.gf_mul": "def gf_mul(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Multiply polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_mul\n\n    >>> gf_mul([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [1, 0, 3, 2, 3]\n\n    \"\"\"\n    df = gf_degree(f)\n    dg = gf_degree(g)\n\n    dh = df + dg\n    h = [K.zero] * (dh + 1)\n\n    for i in range(0, dh + 1):\n        coeff = K.zero\n\n        for j in range(max(0, i - dg), min(i, df) + 1):\n            coeff += f[j] * g[i - j]\n\n        h[i] = coeff % p\n\n    return gf_strip(h)"
}