{
    "sympy.sympy.concrete.expr_with_limits.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols in the object, excluding those\n    that take on a specific value (i.e. the dummy symbols).\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.abc import x, y\n    >>> Sum(x, (x, y, 1)).free_symbols\n    {y}\n    \"\"\"\n    # don't test for any special values -- nominal free symbols\n    # should be returned, e.g. don't return set() if the\n    # function is zero -- treat it like an unevaluated expression.\n    function, limits = self.function, self.limits\n    # mask off non-symbol integration variables that have\n    # more than themself as a free symbol\n    reps = {i[0]: i[0] if i[0].free_symbols == {i[0]} else Dummy()\n        for i in self.limits}\n    function = function.xreplace(reps)\n    isyms = function.free_symbols\n    for xab in limits:\n        v = reps[xab[0]]\n        if len(xab) == 1:\n            isyms.add(v)\n            continue\n        # take out the target symbol\n        if v in isyms:\n            isyms.remove(v)\n        # add in the new symbols\n        for i in xab[1:]:\n            isyms.update(i.free_symbols)\n    reps = {v: k for k, v in reps.items()}\n    return {reps.get(_, _) for _ in isyms}",
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.function.free_symbols": "@property\ndef free_symbols(self):\n    return (self.expr.free_symbols - set(self.variables) |\n        set(self.point.free_symbols))",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.numbers.as_numer_denom": "def as_numer_denom(self):\n    return self, S.One",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.core.symbol.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    return {self}",
    "sympy.sympy.functions.elementary.exponential.as_numer_denom": "def as_numer_denom(self):\n    \"\"\"\n    Returns this with a positive exponent as a 2-tuple (a fraction).\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.abc import x\n    >>> exp(-x).as_numer_denom()\n    (1, exp(x))\n    >>> exp(x).as_numer_denom()\n    (exp(x), 1)\n    \"\"\"\n    # this should be the same as Pow.as_numer_denom wrt\n    # exponent handling\n    if not self.is_commutative:\n        return self, S.One\n    exp = self.exp\n    neg_exp = exp.is_negative\n    if not neg_exp and not (-exp).is_negative:\n        neg_exp = exp.could_extract_minus_sign()\n    if neg_exp:\n        return S.One, self.func(-exp)\n    return self, S.One",
    "sympy.sympy.integrals.integrals.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols that will exist when the\n    integral is evaluated. This is useful if one is trying to\n    determine whether an integral depends on a certain\n    symbol or not.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x, (x, y, 1)).free_symbols\n    {y}\n\n    See Also\n    ========\n\n    sympy.concrete.expr_with_limits.ExprWithLimits.function\n    sympy.concrete.expr_with_limits.ExprWithLimits.limits\n    sympy.concrete.expr_with_limits.ExprWithLimits.variables\n    \"\"\"\n    return super().free_symbols",
    "sympy.sympy.physics.units.quantities.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"Return free symbols from quantity.\"\"\"\n    return set()",
    "sympy.sympy.polys.constructor.<genexpr>": "max_prec = max(c._prec for c in float_numbers) if float_numbers else 53\n\n",
    "sympy.sympy.polys.domains.complexfield.from_sympy": "def from_sympy(self, expr):\n    \"\"\"Convert SymPy's number to ``dtype``. \"\"\"\n    number = expr.evalf(n=self.dps)\n    real, imag = number.as_real_imag()\n\n    if real.is_Number and imag.is_Number:\n        return self.dtype(real, imag)\n    else:\n        raise CoercionFailed(\"expected complex number, got %s\" % expr)",
    "sympy.sympy.polys.domains.complexfield.__init__": "def __init__(self, prec=None, dps=None, tol=None):\n    # XXX: The tolerance parameter is ignored but is kept for backward\n    # compatibility for now.\n\n    context = MPContext()\n\n    if prec is None and dps is None:\n        context.prec = self._default_precision\n    elif dps is None:\n        context.prec = prec\n    elif prec is None:\n        context.dps = dps\n    else:\n        raise TypeError(\"Cannot set both prec and dps\")\n\n    self._context = context\n\n    self._dtype = context.mpc\n    self.zero = self.dtype(0)\n    self.one = self.dtype(1)\n\n    # XXX: Neither of these is actually used anywhere.\n    self._max_denom = max(2**context.prec // 200, 99)\n    self._tolerance = self.one / self._max_denom",
    "sympy.sympy.polys.domains.domain.poly_ring": "def poly_ring(self, *symbols: str | Expr, order: str | MonomialOrder = lex) -> PolynomialRing:\n    \"\"\"Returns a polynomial ring, i.e. `K[X]`. \"\"\"\n    from sympy.polys.domains.polynomialring import PolynomialRing\n    return PolynomialRing(self, symbols, order)",
    "sympy.sympy.polys.domains.domain.frac_field": "def frac_field(self, *symbols: str | Expr, order: str | MonomialOrder = lex) -> FractionField:\n    \"\"\"Returns a fraction field, i.e. `K(X)`. \"\"\"\n    from sympy.polys.domains.fractionfield import FractionField\n    return FractionField(self, symbols, order)",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.gaussiandomains.from_sympy": "def from_sympy(self, a: Expr) -> Telem:\n    \"\"\"Convert a SymPy object to ``self.dtype``.\"\"\"\n    r, b = a.as_coeff_Add()\n    x = self.dom.from_sympy(r)  # may raise CoercionFailed\n    if not b:\n        return self.new(x, 0)\n    r, b = b.as_coeff_Mul()\n    y = self.dom.from_sympy(r)\n    if b is I:\n        return self.new(x, y)\n    else:\n        raise CoercionFailed(\"{} is not Gaussian\".format(a))",
    "sympy.sympy.polys.domains.integerring.from_sympy": "def from_sympy(self, a):\n    \"\"\"Convert SymPy's Integer to ``dtype``. \"\"\"\n    if a.is_Integer:\n        return MPZ(a.p)\n    elif int_valued(a):\n        return MPZ(int(a))\n    else:\n        raise CoercionFailed(\"expected an integer, got %s\" % a)",
    "sympy.sympy.polys.domains.rationalfield.from_sympy": "def from_sympy(self, a):\n    \"\"\"Convert SymPy's Integer to ``dtype``. \"\"\"\n    if a.is_Rational:\n        return MPQ(a.p, a.q)\n    elif a.is_Float:\n        from sympy.polys.domains import RR\n        return MPQ(*map(int, RR.to_rational(a)))\n    else:\n        raise CoercionFailed(\"expected `Rational` object, got %s\" % a)",
    "sympy.sympy.polys.domains.realfield.from_sympy": "def from_sympy(self, expr):\n    \"\"\"Convert SymPy's number to ``dtype``. \"\"\"\n    number = expr.evalf(n=self.dps)\n\n    if number.is_Number:\n        return self.dtype(number)\n    else:\n        raise CoercionFailed(\"expected real number, got %s\" % expr)",
    "sympy.sympy.polys.domains.realfield.__init__": "def __init__(self, prec=None, dps=None, tol=None):\n    # XXX: The tol parameter is ignored but is kept for now for backwards\n    # compatibility.\n\n    context = MPContext()\n\n    if prec is None and dps is None:\n        context.prec = self._default_precision\n    elif dps is None:\n        context.prec = prec\n    elif prec is None:\n        context.dps = dps\n    else:\n        raise TypeError(\"Cannot set both prec and dps\")\n\n    self._context = context\n\n    self._dtype = context.mpf\n    self.zero = self.dtype(0)\n    self.one = self.dtype(1)\n\n    # Only max_denom here is used for anything and is only used for\n    # to_rational.\n    self._max_denom = max(2**context.prec // 200, 99)\n    self._tolerance = self.one / self._max_denom",
    "sympy.sympy.polys.polyoptions.getter": "@property\ndef getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    "sympy.sympy.polys.polyutils.parallel_dict_from_expr": "def parallel_dict_from_expr(exprs, **args):\n    \"\"\"Transform expressions into a multinomial form. \"\"\"\n    reps, opt = _parallel_dict_from_expr(exprs, build_options(args))\n    return reps, opt.gens",
    "sympy.sympy.stats.rv.free_symbols": "@property\ndef free_symbols(self):\n    return {self}",
    "sympy.sympy.tensor.indexed.free_symbols": "@property\ndef free_symbols(self):\n    return {self}",
    "sympy.sympy.vector.scalar.free_symbols": "@property\ndef free_symbols(self):\n    return {self}"
}