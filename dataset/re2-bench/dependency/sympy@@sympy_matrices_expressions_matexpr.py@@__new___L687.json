{
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name, **kwargs):\n    if not isinstance(name, str):\n        raise TypeError(\"name should be a string, not %s\" % repr(type(name)))\n    obj = super().__new__(cls, **kwargs)\n    obj.name = name\n    return obj",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)",
    "sympy.sympy.matrices.expressions.matexpr._check_dim": "@classmethod\ndef _check_dim(cls, dim):\n    \"\"\"Helper function to check invalid matrix dimensions\"\"\"\n    ok = not dim.is_Float and check_assumptions(\n        dim, integer=True, nonnegative=True)\n    if ok is False:\n        raise ValueError(\n            \"The dimension specification {} should be \"\n            \"a nonnegative integer.\".format(dim))"
}