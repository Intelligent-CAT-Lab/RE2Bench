{
    "sympy.sympy.external.pythonmpq.__eq__": "def __eq__(self, other):\n    \"\"\"Compare equal with PythonMPQ, int, float, Decimal or Fraction\"\"\"\n    if isinstance(other, PythonMPQ):\n        return (self.numerator == other.numerator\n            and self.denominator == other.denominator)\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    "sympy.sympy.external.pythonmpq.__rtruediv__": "def __rtruediv__(self, other):\n    \"\"\"z / q\"\"\"\n    if isinstance(other, int):\n        x = gcd(self.numerator, other)\n        p = self.denominator*(other//x)\n        q = self.numerator//x\n        return self._new_check(p, q)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.domain.convert": "def convert(self,\n            element: Es | Expr | complex,\n            base: Domain[Es] | None = None\n            ) -> Er:\n    \"\"\"Convert ``element`` to ``self.dtype``. \"\"\"\n\n    if base is not None:\n        if _not_a_coeff(element):\n            raise CoercionFailed('%s is not in any domain' % element)\n        return self.convert_from(element, base) # type: ignore\n\n    if self.of_type(element):\n        return element\n\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ) # type: ignore\n\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n\n    if GROUND_TYPES != 'python':\n        if isinstance(element, ZZ.tp):\n            return self.convert_from(element, ZZ) # type: ignore\n        if isinstance(element, QQ.tp):\n            return self.convert_from(element, QQ) # type: ignore\n\n    if isinstance(element, float):\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if isinstance(element, complex):\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if type(element).__name__ == 'mpf':\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if type(element).__name__ == 'mpc':\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n\n    # TODO: implement this in from_ methods\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC()) # type: ignore\n\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    else: # TODO: remove this branch\n        if not is_sequence(element):\n            try:\n                element = sympify(element, strict=True) # type: ignore\n                if isinstance(element, Basic):\n                    return self.from_sympy(element) # type: ignore\n            except (TypeError, ValueError):\n                pass\n\n    raise CoercionFailed(\"Cannot convert %s of type %s to %s\" % (element, type(element), self))",
    "sympy.sympy.polys.domains.domain.of_type": "def of_type(self, element: Any) -> TypeIs[Er]:\n    \"\"\"Check if ``a`` is of type ``dtype``. \"\"\"\n    return isinstance(element, self.tp)",
    "sympy.sympy.polys.domains.domain.__contains__": "def __contains__(self, a: Any) -> bool:\n    \"\"\"Check if ``a`` belongs to this domain. \"\"\"\n    try:\n        if _not_a_coeff(a):\n            raise CoercionFailed\n        self.convert(a)  # this might raise, too\n    except CoercionFailed:\n        return False\n\n    return True",
    "sympy.sympy.polys.domains.expressiondomain.__rtruediv__": "def __rtruediv__(f, g):\n    return f.simplify(f.__class__(g).ex/f.ex)",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(f, g):\n    return f.ex == f.__class__(g).ex",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.fractionfield.one": "@property\ndef one(self):\n    return self.field.one",
    "sympy.sympy.polys.domains.gaussiandomains.__rtruediv__": "def __rtruediv__(self, other: GaussianElement | int) -> GaussianRational:\n    try:\n        other = QQ_I.convert(other)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return other.__truediv__(self)",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, self.__class__):\n        return self.x == other.x and self.y == other.y\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.fields.__eq__": "def __eq__(f, g):\n    if isinstance(g, FracElement) and f.field == g.field:\n        return f.numer == g.numer and f.denom == g.denom\n    else:\n        return f.numer == g and f.denom == f.field.ring.one",
    "sympy.sympy.polys.fields.__rtruediv__": "def __rtruediv__(f, c):\n    if not f:\n        raise ZeroDivisionError\n    elif f.field.ring.is_element(c):\n        return f.new(f.denom*c, f.numer)\n\n    op, g_numer, g_denom = f._extract_ground(c)\n\n    if op == 1:\n        return f.new(f.denom*g_numer, f.numer)\n    elif not op:\n        return NotImplemented\n    else:\n        return f.new(f.denom*g_numer, f.numer*g_denom)",
    "sympy.sympy.polys.matrices.domainmatrix.mul": "def mul(A, b):\n    r\"\"\"\n    Performs term by term multiplication for the second DomainMatrix\n    w.r.t first DomainMatrix. Returns a DomainMatrix whose rows are\n    list of DomainMatrix matrices created after term by term multiplication.\n\n    Parameters\n    ==========\n\n    A, B: DomainMatrix\n        matrices to multiply term-wise\n\n    Returns\n    =======\n\n    DomainMatrix\n        DomainMatrix after term by term multiplication\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> b = ZZ(2)\n\n    >>> A.mul(b)\n    DomainMatrix([[2, 4], [6, 8]], (2, 2), ZZ)\n\n    See Also\n    ========\n\n    matmul\n\n    \"\"\"\n    return A.from_rep(A.rep.mul(b))",
    "sympy.sympy.polys.matrices.domainmatrix.to_field": "def to_field(self):\n    r\"\"\"\n    Returns a DomainMatrix with the appropriate field\n\n    Returns\n    =======\n\n    DomainMatrix\n        DomainMatrix with the appropriate field\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n    >>> A.to_field()\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)\n\n    \"\"\"\n    K = self.domain.get_field()\n    return self.convert_to(K)",
    "sympy.sympy.polys.matrices.domainmatrix.unify": "def unify(self, *others, fmt=None):\n    \"\"\"\n    Unifies the domains and the format of self and other\n    matrices.\n\n    Parameters\n    ==========\n\n    others : DomainMatrix\n\n    fmt: string 'dense', 'sparse' or `None` (default)\n        The preferred format to convert to if self and other are not\n        already in the same format. If `None` or not specified then no\n        conversion if performed.\n\n    Returns\n    =======\n\n    Tuple[DomainMatrix]\n        Matrices with unified domain and format\n\n    Examples\n    ========\n\n    Unify the domain of DomainMatrix that have different domains:\n\n    >>> from sympy import ZZ, QQ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)\n    >>> Aq, Bq = A.unify(B)\n    >>> Aq\n    DomainMatrix([[1, 2]], (1, 2), QQ)\n    >>> Bq\n    DomainMatrix([[1/2, 2]], (1, 2), QQ)\n\n    Unify the format (dense or sparse):\n\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)\n    >>> B.rep\n    {0: {0: 1}}\n\n    >>> A2, B2 = A.unify(B, fmt='dense')\n    >>> B2.rep\n    [[1, 0], [0, 0]]\n\n    See Also\n    ========\n\n    convert_to, to_dense, to_sparse\n\n    \"\"\"\n    matrices = (self,) + others\n    matrices = DomainMatrix._unify_domain(*matrices)\n    if fmt is not None:\n        matrices = DomainMatrix._unify_fmt(*matrices, fmt=fmt)\n    return matrices",
    "sympy.sympy.polys.matrices.domainscalar.__new__": "def __new__(cls, element, domain):\n    if not isinstance(domain, Domain):\n        raise TypeError(\"domain should be of type Domain\")\n    if not domain.of_type(element):\n        raise TypeError(\"element %s should be in domain %s\" % (element, domain))\n    return cls.new(element, domain)"
}