{
    "sympy.sympy.polys.densearith.dup_div": "def dup_div(f: dup[Er], g: dup[Er], K: Domain[Er]) -> tuple[dup[Er], dup[Er]]:\n    \"\"\"\n    Polynomial division with remainder in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> R.dup_div(x**2 + 1, 2*x - 4)\n    (0, x**2 + 1)\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> R.dup_div(x**2 + 1, 2*x - 4)\n    (1/2*x + 1, 5)\n\n    \"\"\"\n    if K.is_Field:\n        return dup_ff_div(f, g, K) # type: ignore\n    else:\n        return dup_rr_div(f, g, K) # type: ignore",
    "sympy.sympy.polys.polyutils._sort_factors": "def _sort_factors(factors, **args):\n    \"\"\"Sort low-level factors in increasing 'complexity' order. \"\"\"\n\n    # XXX: GF(p) does not support comparisons so we need a key function to sort\n    # the factors if python-flint is being used. A better solution might be to\n    # add a sort key method to each domain.\n    def order_key(factor):\n        if isinstance(factor, _GF_types):\n            return int(factor)\n        elif isinstance(factor, list):\n            return [order_key(f) for f in factor]\n        else:\n            return factor\n\n    def order_if_multiple_key(factor):\n        (f, n) = factor\n        return (len(f), n, order_key(f))\n\n    def order_no_multiple_key(f):\n        return (len(f), order_key(f))\n\n    if args.get('multiple', True):\n        return sorted(factors, key=order_if_multiple_key)\n    else:\n        return sorted(factors, key=order_no_multiple_key)"
}