{
    "matplotlib.lib.matplotlib.cbook.pts_to_prestep": "def pts_to_prestep(x, *args):\n    \"\"\"\n    Convert continuous line to pre-steps.\n\n    Given a set of ``N`` points, convert to ``2N - 1`` points, which when\n    connected linearly give a step function which changes values at the\n    beginning of the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    # In all `pts_to_*step` functions, only assign once using *x* and *args*,\n    # as converting to an array may be expensive.\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 0:-2:2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 2::2]\n    return steps",
    "matplotlib.lib.matplotlib.cbook.pts_to_poststep": "def pts_to_poststep(x, *args):\n    \"\"\"\n    Convert continuous line to post-steps.\n\n    Given a set of ``N`` points convert to ``2N + 1`` points, which when\n    connected linearly give a step function which changes values at the end of\n    the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 2::2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0:-2:2]\n    return steps",
    "matplotlib.lib.matplotlib.collections._get_interpolating_points": "@classmethod\ndef _get_interpolating_points(cls, t, f1, f2, idx):\n    \"\"\"Calculate interpolating points.\"\"\"\n    im1 = max(idx - 1, 0)\n    t_values = t[im1:idx+1]\n    diff_values = f1[im1:idx+1] - f2[im1:idx+1]\n    f1_values = f1[im1:idx+1]\n\n    if len(diff_values) == 2:\n        if np.ma.is_masked(diff_values[1]):\n            return t[im1], f1[im1]\n        elif np.ma.is_masked(diff_values[0]):\n            return t[idx], f1[idx]\n\n    diff_root_t = cls._get_diff_root(0, diff_values, t_values)\n    diff_root_f = cls._get_diff_root(diff_root_t, t_values, f1_values)\n    return diff_root_t, diff_root_f",
    "matplotlib.lib.matplotlib.collections._fix_pts_xy_order": "def _fix_pts_xy_order(self, pts):\n    \"\"\"\n    Fix pts calculation results with `self.t_direction`.\n\n    In the workflow, it is assumed that `self.t_direction` is 'x'. If this\n    is not true, we need to exchange the coordinates.\n    \"\"\"\n    return pts[:, ::-1] if self.t_direction == \"y\" else pts"
}