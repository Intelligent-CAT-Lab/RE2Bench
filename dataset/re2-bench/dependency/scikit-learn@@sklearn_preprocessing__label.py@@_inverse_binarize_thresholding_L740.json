{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.externals.array_api_compat.numpy._aliases.asarray": "def asarray(\n    obj: Array | complex | NestedSequence[complex] | SupportsBufferProtocol,\n    /,\n    *,\n    dtype: DType | None = None,\n    device: Device | None = None,\n    copy: _Copy | None = None,\n    **kwargs: Any,\n) -> Array:\n    \"\"\"\n    Array API compatibility wrapper for asarray().\n\n    See the corresponding documentation in the array library and/or the array API\n    specification for more details.\n    \"\"\"\n    _helpers._check_device(np, device)\n\n    if copy is None:\n        copy = np._CopyMode.IF_NEEDED\n    elif copy is False:\n        copy = np._CopyMode.NEVER\n    elif copy is True:\n        copy = np._CopyMode.ALWAYS\n\n    return np.array(obj, copy=copy, dtype=dtype, **kwargs)  # pyright: ignore",
    "scikit-learn.sklearn.utils._array_api.get_namespace_and_device": "def get_namespace_and_device(\n    *array_list, remove_none=True, remove_types=(str,), xp=None\n):\n    \"\"\"Combination into one single function of `get_namespace` and `device`.\n\n    Parameters\n    ----------\n    *array_list : array objects\n        Array objects.\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to NumPy.\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the Array API spec.\n        Always False when array_api_dispatch=False.\n    device : device\n        `device` object (see the \"Device Support\" section of the array API spec).\n    \"\"\"\n    skip_remove_kwargs = dict(remove_none=False, remove_types=[])\n\n    array_list = _remove_non_arrays(\n        *array_list,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n    arrays_device = device(*array_list, **skip_remove_kwargs)\n\n    if xp is None:\n        xp, is_array_api = get_namespace(*array_list, **skip_remove_kwargs)\n    else:\n        xp, is_array_api = xp, True\n\n    if is_array_api:\n        return xp, is_array_api, arrays_device\n    else:\n        return xp, False, arrays_device",
    "scikit-learn.sklearn.utils._array_api._find_matching_floating_dtype": "def _find_matching_floating_dtype(*arrays, xp):\n    \"\"\"Find a suitable floating point dtype when computing with arrays.\n\n    If any of the arrays are floating point, return the dtype with the highest\n    precision by following official type promotion rules:\n\n    https://data-apis.org/array-api/latest/API_specification/type_promotion.html\n\n    If there are no floating point input arrays (all integral inputs for\n    instance), return the default floating point dtype for the namespace.\n    \"\"\"\n    dtyped_arrays = [xp.asarray(a) for a in arrays if hasattr(a, \"dtype\")]\n    floating_dtypes = [\n        a.dtype for a in dtyped_arrays if xp.isdtype(a.dtype, \"real floating\")\n    ]\n    if floating_dtypes:\n        # Return the floating dtype with the highest precision:\n        return xp.result_type(*floating_dtypes)\n\n    # If none of the input arrays have a floating point dtype, they must be all\n    # integer arrays or containers of Python scalars: return the default\n    # floating point dtype for the namespace (implementation specific).\n    return xp.asarray(0.0).dtype",
    "scikit-learn.sklearn.utils._array_api.indexing_dtype": "def indexing_dtype(xp):\n    \"\"\"Return a platform-specific integer dtype suitable for indexing.\n\n    On 32-bit platforms, this will typically return int32 and int64 otherwise.\n\n    Note: using dtype is recommended for indexing transient array\n    datastructures. For long-lived arrays, such as the fitted attributes of\n    estimators, it is instead recommended to use platform-independent int32 if\n    we do not expect to index more 2B elements. Using fixed dtypes simplifies\n    the handling of serialized models, e.g. to deploy a model fit on a 64-bit\n    platform to a target 32-bit platform such as WASM/pyodide.\n    \"\"\"\n    # Currently this is implemented with simple hack that assumes that\n    # following \"may be\" statements in the Array API spec always hold:\n    # > The default integer data type should be the same across platforms, but\n    # > the default may vary depending on whether Python is 32-bit or 64-bit.\n    # > The default array index data type may be int32 on 32-bit platforms, but\n    # > the default should be int64 otherwise.\n    # https://data-apis.org/array-api/latest/API_specification/data_types.html#default-data-types\n    # TODO: once sufficiently adopted, we might want to instead rely on the\n    # newer inspection API: https://github.com/data-apis/array-api/issues/640\n    return xp.asarray(0).dtype"
}