{
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.matrices.expressions.matadd.shape": "@property\ndef shape(self):\n    return self.args[0].shape",
    "sympy.sympy.matrices.expressions.matexpr.shape": "@property\ndef shape(self):\n    return self.args[1], self.args[2]",
    "sympy.sympy.matrices.expressions.slice.mat_slice_of_slice": "def mat_slice_of_slice(parent, rowslice, colslice):\n    \"\"\" Collapse nested matrix slices\n\n    >>> from sympy import MatrixSymbol\n    >>> X = MatrixSymbol('X', 10, 10)\n    >>> X[:, 1:5][5:8, :]\n    X[5:8, 1:5]\n    >>> X[1:9:2, 2:6][1:3, 2]\n    X[3:7:2, 4:5]\n    \"\"\"\n    row = slice_of_slice(parent.rowslice, rowslice)\n    col = slice_of_slice(parent.colslice, colslice)\n    return MatrixSlice(parent.parent, row, col)",
    "sympy.sympy.matrices.expressions.slice.normalize": "def normalize(i, parentsize):\n    if isinstance(i, slice):\n        i = (i.start, i.stop, i.step)\n    if not isinstance(i, (tuple, list, Tuple)):\n        if (i < 0) == True:\n            i += parentsize\n        i = (i, i+1, 1)\n    i = list(i)\n    if len(i) == 2:\n        i.append(1)\n    start, stop, step = i\n    start = start or 0\n    if stop is None:\n        stop = parentsize\n    if (start < 0) == True:\n        start += parentsize\n    if (stop < 0) == True:\n        stop += parentsize\n    step = step or 1\n\n    if ((stop - start) * step < 1) == True:\n        raise IndexError()\n\n    return (start, stop, step)",
    "sympy.sympy.matrices.expressions.slice.shape": "@property\ndef shape(self):\n    rows = self.rowslice[1] - self.rowslice[0]\n    rows = rows if self.rowslice[2] == 1 else floor(rows/self.rowslice[2])\n    cols = self.colslice[1] - self.colslice[0]\n    cols = cols if self.colslice[2] == 1 else floor(cols/self.colslice[2])\n    return rows, cols",
    "sympy.sympy.matrices.immutable.shape": "@property\ndef shape(self):\n    return self._rows, self._cols"
}