{
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return other is not S.NaN",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.matrices.sdm.unop_dict": "def unop_dict(A, f):\n    B = {}\n    for i, Ai in A.items():\n        Bi = {}\n        for j, Aij in Ai.items():\n            Bij = f(Aij)\n            if Bij:\n                Bi[j] = Bij\n        if Bi:\n            B[i] = Bi\n    return B",
    "sympy.sympy.polys.matrices.sdm.sdm_scalar_mul_exraw": "def sdm_scalar_mul_exraw(A, b, op, K):\n    zero = K.zero\n    zero_prod = op(zero, b)\n    m, n = A.shape\n    Csdm = {i: dict.fromkeys(range(n), zero_prod) for i in range(m)}\n    for i, Ai in A.items():\n        Ci = Csdm[i]\n        for j, Aij in Ai.items():\n            Cij = op(Aij, b)\n            if Cij == zero:\n                del Ci[j]\n            else:\n                Ci[j] = Cij\n    return Csdm",
    "sympy.sympy.polys.matrices.sdm.<lambda>": "Csdm = sdm_scalar_mul(A, b, lambda x, y: y * x, A.domain)\n"
}