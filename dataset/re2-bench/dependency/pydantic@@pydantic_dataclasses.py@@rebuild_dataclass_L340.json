{
    "pydantic.pydantic._internal._config.__init__": "def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):\n    if check:\n        self.config_dict = prepare_config(config)\n    else:\n        self.config_dict = cast(ConfigDict, config)",
    "pydantic.pydantic._internal._dataclasses.complete_dataclass": "def complete_dataclass(\n    cls: type[Any],\n    config_wrapper: _config.ConfigWrapper,\n    *,\n    raise_errors: bool = True,\n    ns_resolver: NsResolver | None = None,\n    _force_build: bool = False,\n) -> bool:\n    \"\"\"Finish building a pydantic dataclass.\n\n    This logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.\n\n    This is somewhat analogous to `pydantic._internal._model_construction.complete_model_class`.\n\n    Args:\n        cls: The class.\n        config_wrapper: The config wrapper instance.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        ns_resolver: The namespace resolver instance to use when collecting dataclass fields\n            and during schema building.\n        _force_build: Whether to force building the dataclass, no matter if\n            [`defer_build`][pydantic.config.ConfigDict.defer_build] is set.\n\n    Returns:\n        `True` if building a pydantic dataclass is successfully completed, `False` otherwise.\n\n    Raises:\n        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.\n    \"\"\"\n    original_init = cls.__init__\n\n    # dataclass.__init__ must be defined here so its `__qualname__` can be changed since functions can't be copied,\n    # and so that the mock validator is used if building was deferred:\n    def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python(ArgsKwargs(args, kwargs), self_instance=s)\n\n    __init__.__qualname__ = f'{cls.__qualname__}.__init__'\n\n    cls.__init__ = __init__  # type: ignore\n    cls.__pydantic_config__ = config_wrapper.config_dict  # type: ignore\n\n    set_dataclass_fields(cls, config_wrapper=config_wrapper, ns_resolver=ns_resolver)\n\n    if not _force_build and config_wrapper.defer_build:\n        set_dataclass_mocks(cls)\n        return False\n\n    if hasattr(cls, '__post_init_post_parse__'):\n        warnings.warn(\n            'Support for `__post_init_post_parse__` has been dropped, the method will not be called',\n            PydanticDeprecatedSince20,\n        )\n\n    typevars_map = get_standard_typevars_map(cls)\n    gen_schema = GenerateSchema(\n        config_wrapper,\n        ns_resolver=ns_resolver,\n        typevars_map=typevars_map,\n    )\n\n    # set __signature__ attr only for the class, but not for its instances\n    # (because instances can define `__call__`, and `inspect.signature` shouldn't\n    # use the `__signature__` attribute and instead generate from `__call__`).\n    cls.__signature__ = LazyClassAttribute(\n        '__signature__',\n        partial(\n            generate_pydantic_signature,\n            # It's important that we reference the `original_init` here,\n            # as it is the one synthesized by the stdlib `dataclass` module:\n            init=original_init,\n            fields=cls.__pydantic_fields__,  # type: ignore\n            validate_by_name=config_wrapper.validate_by_name,\n            extra=config_wrapper.extra,\n            is_dataclass=True,\n        ),\n    )\n\n    try:\n        schema = gen_schema.generate_schema(cls)\n    except PydanticUndefinedAnnotation as e:\n        if raise_errors:\n            raise\n        set_dataclass_mocks(cls, f'`{e.name}`')\n        return False\n\n    core_config = config_wrapper.core_config(title=cls.__name__)\n\n    try:\n        schema = gen_schema.clean_schema(schema)\n    except InvalidSchemaError:\n        set_dataclass_mocks(cls)\n        return False\n\n    # We are about to set all the remaining required properties expected for this cast;\n    # __pydantic_decorators__ and __pydantic_fields__ should already be set\n    cls = cast('type[PydanticDataclass]', cls)\n\n    cls.__pydantic_core_schema__ = schema\n    cls.__pydantic_validator__ = create_schema_validator(\n        schema, cls, cls.__module__, cls.__qualname__, 'dataclass', core_config, config_wrapper.plugin_settings\n    )\n    cls.__pydantic_serializer__ = SchemaSerializer(schema, core_config)\n    cls.__pydantic_complete__ = True\n    return True",
    "pydantic.pydantic._internal._namespace_utils.__init__": "def __init__(\n    self,\n    namespaces_tuple: NamespacesTuple | None = None,\n    parent_namespace: MappingNamespace | None = None,\n) -> None:\n    self._base_ns_tuple = namespaces_tuple or NamespacesTuple({}, {})\n    self._parent_ns = parent_namespace\n    self._types_stack: list[type[Any] | TypeAliasType] = []"
}