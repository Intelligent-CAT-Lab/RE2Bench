{
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.external.pythonmpq.__add__": "def __add__(self, other):\n    \"\"\"q1 + q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        #\n        # This is much faster than the naive method used in the stdlib\n        # fractions module. Not sure where this method comes from\n        # though...\n        #\n        # Compare timings for something like:\n        #   nums = range(1000)\n        #   rats = [PythonMPQ(n, d) for n, d in zip(nums[:-5], nums[5:])]\n        #   sum(rats) # <-- time this\n        #\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq + aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 + bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__mul__": "def __mul__(self, other):\n    \"\"\"q1 * q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = ((ap//x1)*(bp//x2), (aq//x2)*(bq//x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator*(other//x)\n        q = self.denominator//x\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__pow__": "def __pow__(self, exp):\n    \"\"\"q ** z\"\"\"\n    p, q = self.numerator, self.denominator\n\n    if exp < 0:\n        p, q, exp = q, p, -exp\n\n    return self._new_check(p**exp, q**exp)",
    "sympy.sympy.polys.agca.extensions.__pow__": "def __pow__(f, n):\n    if not isinstance(n, int):\n        raise TypeError(\"exponent of type 'int' expected\")\n    if n < 0:\n        try:\n            f, n = f.inverse(), -n\n        except NotImplementedError:\n            raise ValueError(\"negative powers are not defined\")\n\n    b = f.rep\n    m = f.ext.mod\n    r = f.ext.one.rep\n    while n > 0:\n        if n % 2:\n            r = (r*b) % m\n        b = (b*b) % m\n        n //= 2\n\n    return ExtElem(r, f.ext)",
    "sympy.sympy.polys.agca.extensions.__add__": "def __add__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem(f.rep + rep, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.agca.extensions.__mul__": "def __mul__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem((f.rep * rep) % f.ext.mod, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.densebasic.dup_strip": "def dup_strip(f: dup[Er], K: Domain[Er] | None = None) -> dup[Er]:\n    \"\"\"\n    Remove leading zeros from ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dup_strip\n\n    >>> dup_strip([0, 0, 1, 2, 3, 0], ZZ)\n    [1, 2, 3, 0]\n\n    \"\"\"\n    if not f or f[0]:\n        return f\n\n    i = 0\n\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n\n    return f[i:]",
    "sympy.sympy.polys.domains.expressiondomain.__mul__": "def __mul__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n\n    if EX.zero in (f, g):\n        return EX.zero\n    elif f.ex.is_Number and g.ex.is_Number:\n        return f.__class__(f.ex*g.ex)\n\n    return f.simplify(f.ex*g.ex)",
    "sympy.sympy.polys.domains.expressiondomain.__pow__": "def __pow__(f, n):\n    n = f._to_ex(n)\n\n    if n is not None:\n        return f.simplify(f.ex**n.ex)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.expressiondomain.__add__": "def __add__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n    elif g == EX.zero:\n        return f\n    elif f == EX.zero:\n        return g\n    else:\n        return f.simplify(f.ex + g.ex)",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.gaussiandomains.__mul__": "def __mul__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x*x - self.y*y, self.x*y + self.y*x)",
    "sympy.sympy.polys.domains.gaussiandomains.__pow__": "def __pow__(self, exp: int) -> Self:\n    if exp == 0:\n        return self.new(self.base(1), self.base(0))\n    if exp < 0:\n        self, exp = 1/self, -exp # type: ignore\n    if exp == 1:\n        return self\n    pow2 = self\n    prod = self if exp % 2 else self._parent.one\n    exp //= 2\n    while exp:\n        pow2 *= pow2\n        if exp % 2:\n            prod *= pow2\n        exp //= 2\n    return prod",
    "sympy.sympy.polys.domains.gaussiandomains.__add__": "def __add__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x + x, self.y + y)",
    "sympy.sympy.polys.domains.modularinteger.__mul__": "def __mul__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val * val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__pow__": "def __pow__(self, exp):\n    if not exp:\n        return self.__class__(self.dom.one)\n\n    if exp < 0:\n        val, exp = self.invert().val, -exp\n    else:\n        val = self.val\n\n    return self.__class__(pow(val, int(exp), self.mod))",
    "sympy.sympy.polys.domains.modularinteger.__add__": "def __add__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val + val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.fields.__add__": "def __add__(f, g):\n    \"\"\"Add rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not g:\n        return f\n    elif not f:\n        return g\n    elif field.is_element(g):\n        if f.denom == g.denom:\n            return f.new(f.numer + g.numer, f.denom)\n        else:\n            return f.new(f.numer*g.denom + f.denom*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer + f.denom*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__radd__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__radd__(f)\n\n    return f.__radd__(g)",
    "sympy.sympy.polys.fields.__mul__": "def __mul__(f, g):\n    \"\"\"Multiply rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not f or not g:\n        return field.zero\n    elif field.is_element(g):\n        return f.new(f.numer*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__rmul__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__rmul__(f)\n\n    return f.__rmul__(g)",
    "sympy.sympy.polys.fields.__pow__": "def __pow__(f, n):\n    \"\"\"Raise ``f`` to a non-negative power ``n``. \"\"\"\n    if n >= 0:\n        return f.raw_new(f.numer**n, f.denom**n)\n    elif not f:\n        raise ZeroDivisionError\n    else:\n        return f.raw_new(f.denom**-n, f.numer**-n)",
    "sympy.sympy.polys.polyclasses.__add__": "def __add__(f, g):\n    if isinstance(g, ANP):\n        return f.add(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.add_ground(g)",
    "sympy.sympy.polys.polyclasses.__mul__": "def __mul__(f, g):\n    if isinstance(g, ANP):\n        return f.mul(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.mul_ground(g)",
    "sympy.sympy.polys.polyclasses.__pow__": "def __pow__(f, n):\n    return f.pow(n)",
    "sympy.sympy.polys.rings.__pow__": "def __pow__(self, n: int) -> PolyElement[Er]:\n    \"\"\"raise polynomial to power `n`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> p = x + y**2\n    >>> p**3\n    x**3 + 3*x**2*y**2 + 3*x*y**4 + y**6\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"exponent must be an integer, got %s\" % n)\n    elif n < 0:\n        raise ValueError(\"exponent must be a non-negative integer, got %s\" % n)\n\n    if not n:\n        if self:\n            return self.ring.one\n        else:\n            raise ValueError(\"0**0\")\n\n    return self._pow_int(n)",
    "sympy.sympy.polys.rings.__add__": "def __add__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Add two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> (x + y)**2 + (x - y)**2\n    2*x**2 + 2*y**2\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._add(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._add_ground(self)\n\n    res = self._try_add_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_add_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.polys.rings.__mul__": "def __mul__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Multiply two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', QQ)\n    >>> p1 = x + y\n    >>> p2 = x - y\n    >>> p1*p2\n    x**2 - y**2\n\n    \"\"\"\n    if not self or not other:\n        return self.ring.zero\n\n    if self.ring.is_element(other):\n        return self._mul(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other).mul_ground(self)\n\n    res = self._try_mul_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_mul_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}