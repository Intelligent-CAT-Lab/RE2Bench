{
    "sympy.sympy.polys.densearith.dmp_quo": "def dmp_quo(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Returns exact polynomial quotient in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_quo(x**2 + x*y, 2*x + 2)\n    0\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_quo(x**2 + x*y, 2*x + 2)\n    1/2*x + 1/2*y - 1/2\n\n    \"\"\"\n    return dmp_div(f, g, u, K)[0]",
    "sympy.sympy.polys.densearith.dmp_neg": "def dmp_neg(f: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_neg(x**2*y - x)\n    -x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_neg(_dup(f), K))\n\n    v = u - 1\n\n    return [ dmp_neg(cf, v, K) for cf in f ]",
    "sympy.sympy.polys.densebasic.dmp_ground_LC": "def dmp_ground_LC(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the ground leading coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_LC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_LC(f, 2, ZZ)\n    1\n\n    \"\"\"\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n\n    return dup_LC(_dup(f), K)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densetools.dmp_diff_in": "def dmp_diff_in(f: dmp[Er], m: int, j: int, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    ``m``-th order derivative in ``x_j`` of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x*y**2 + 2*x*y + 3*x + 2*y**2 + 3*y + 1\n\n    >>> R.dmp_diff_in(f, 1, 0)\n    y**2 + 2*y + 3\n    >>> R.dmp_diff_in(f, 1, 1)\n    2*x*y + 2*x + 4*y + 3\n\n    \"\"\"\n    if j < 0 or j > u:\n        raise IndexError(\"0 <= j <= %s expected, got %s\" % (u, j))\n\n    return _rec_diff_in(f, m, u, 0, j, K)",
    "sympy.sympy.polys.densetools.dmp_ground_monic": "def dmp_ground_monic(f: dmp[Ef], u: int, K: Field[Ef]) -> dmp[Ef]:\n    \"\"\"\n    Divide all coefficients by ``LC(f)`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 3*x**2*y + 6*x**2 + 3*x*y + 9*y + 3\n\n    >>> R.dmp_ground_monic(f)\n    x**2*y + 2*x**2 + x*y + 3*y + 1\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 3*x**2*y + 8*x**2 + 5*x*y + 6*x + 2*y + 3\n\n    >>> R.dmp_ground_monic(f)\n    x**2*y + 8/3*x**2 + 5/3*x*y + 2*x + 2/3*y + 1\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_monic(_dup(f), K))\n\n    if dmp_zero_p(f, u):\n        return f\n\n    lc = dmp_ground_LC(f, u, K)\n\n    if K.is_one(lc):\n        return f\n    else:\n        return dmp_exquo_ground(f, lc, u, K)",
    "sympy.sympy.polys.densetools.dmp_ground_primitive": "def dmp_ground_primitive(f: dmp[Er], u: int, K: Domain[Er]) -> tuple[Er, dmp[Er]]:\n    \"\"\"\n    Compute content and the primitive form of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    \"\"\"\n    if not u:\n        cont, fu = dup_primitive(_dup(f), K)\n        return cont, _dmp(fu)\n\n    if dmp_zero_p(f, u):\n        return K.zero, f\n\n    cont = dmp_ground_content(f, u, K)\n\n    if K.is_one(cont):\n        return cont, f\n    else:\n        return cont, dmp_quo_ground(f, cont, u, K)",
    "sympy.sympy.polys.domains.algebraicfield.is_negative": "def is_negative(self, a):\n    \"\"\"Returns True if ``a`` is negative. \"\"\"\n    return self.dom.is_negative(a.LC())",
    "sympy.sympy.polys.domains.domain.is_negative": "def is_negative(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is negative. \"\"\"\n    return a < 0 # type: ignore",
    "sympy.sympy.polys.euclidtools.dmp_gcd": "def dmp_gcd(f, g, u, K):\n    \"\"\"\n    Computes polynomial GCD of `f` and `g` in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_gcd(f, g)\n    x + y\n\n    \"\"\"\n    return dmp_inner_gcd(f, g, u, K)[0]",
    "sympy.sympy.polys.sqfreetools.dup_sqf_part": "def dup_sqf_part(f, K):\n    \"\"\"\n    Returns square-free part of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sqf_part(x**3 - 3*x - 2)\n    x**2 - x - 2\n\n    See Also\n    ========\n\n    sympy.polys.polytools.Poly.sqf_part\n    \"\"\"\n    if K.is_FiniteField:\n        return dup_gf_sqf_part(f, K)\n\n    if not f:\n        return f\n\n    if K.is_negative(dup_LC(f, K)):\n        f = dup_neg(f, K)\n\n    gcd = dup_gcd(f, dup_diff(f, 1, K), K)\n    sqf = dup_quo(f, gcd, K)\n\n    if K.is_Field:\n        return dup_monic(sqf, K)\n    else:\n        return dup_primitive(sqf, K)[1]"
}