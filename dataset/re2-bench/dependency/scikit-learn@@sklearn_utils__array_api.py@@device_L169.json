{
    "scikit-learn.sklearn.utils._array_api._single_array_device": "def _single_array_device(array):\n    \"\"\"Hardware device where the array data resides on.\"\"\"\n    if (\n        not hasattr(array, \"device\")\n        # When array API dispatch is disabled, we expect the scikit-learn code\n        # to use np.asarray so that the resulting NumPy array will implicitly use the\n        # CPU. In this case, scikit-learn should stay as device neutral as possible,\n        # hence the use of `device=None` which is accepted by all libraries, before\n        # and after the expected conversion to NumPy via np.asarray.\n        or not get_config()[\"array_api_dispatch\"]\n    ):\n        return None\n    else:\n        return array.device",
    "scikit-learn.sklearn.utils._array_api._remove_non_arrays": "def _remove_non_arrays(*arrays, remove_none=True, remove_types=(str,)):\n    \"\"\"Filter arrays to exclude None and/or specific types.\n\n    Sparse arrays are always filtered out.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    Returns\n    -------\n    filtered_arrays : list\n        List of arrays filtered as requested. An empty list is returned if no input\n        passes the filters.\n    \"\"\"\n    filtered_arrays = []\n    remove_types = tuple(remove_types)\n    for array in arrays:\n        if remove_none and array is None:\n            continue\n        if isinstance(array, remove_types):\n            continue\n        if sp.issparse(array):\n            continue\n        filtered_arrays.append(array)\n\n    return filtered_arrays"
}