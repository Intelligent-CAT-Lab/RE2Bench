{
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils._array_api._average": "def _average(a, axis=None, weights=None, normalize=True, xp=None):\n    \"\"\"Partial port of np.average to support the Array API.\n\n    It does a best effort at mimicking the return dtype rule described at\n    https://numpy.org/doc/stable/reference/generated/numpy.average.html but\n    only for the common cases needed in scikit-learn.\n    \"\"\"\n    xp, _, device_ = get_namespace_and_device(a, weights, xp=xp)\n\n    if _is_numpy_namespace(xp):\n        if normalize:\n            return xp.asarray(numpy.average(a, axis=axis, weights=weights))\n        elif axis is None and weights is not None:\n            return xp.asarray(numpy.dot(a, weights))\n\n    a = xp.asarray(a, device=device_)\n    if weights is not None:\n        weights = xp.asarray(weights, device=device_)\n\n    if weights is not None and a.shape != weights.shape:\n        if axis is None:\n            raise TypeError(\n                f\"Axis must be specified when the shape of a {tuple(a.shape)} and \"\n                f\"weights {tuple(weights.shape)} differ.\"\n            )\n\n        if tuple(weights.shape) != (a.shape[axis],):\n            raise ValueError(\n                f\"Shape of weights weights.shape={tuple(weights.shape)} must be \"\n                f\"consistent with a.shape={tuple(a.shape)} and {axis=}.\"\n            )\n\n        # If weights are 1D, add singleton dimensions for broadcasting\n        shape = [1] * a.ndim\n        shape[axis] = a.shape[axis]\n        weights = xp.reshape(weights, tuple(shape))\n\n    if xp.isdtype(a.dtype, \"complex floating\"):\n        raise NotImplementedError(\n            \"Complex floating point values are not supported by average.\"\n        )\n    if weights is not None and xp.isdtype(weights.dtype, \"complex floating\"):\n        raise NotImplementedError(\n            \"Complex floating point values are not supported by average.\"\n        )\n\n    output_dtype = _find_matching_floating_dtype(a, weights, xp=xp)\n    a = xp.astype(a, output_dtype)\n\n    if weights is None:\n        return (xp.mean if normalize else xp.sum)(a, axis=axis)\n\n    weights = xp.astype(weights, output_dtype)\n\n    sum_ = xp.sum(xp.multiply(a, weights), axis=axis)\n\n    if not normalize:\n        return sum_\n\n    scale = xp.sum(weights, axis=axis)\n    if xp.any(scale == 0.0):\n        raise ZeroDivisionError(\"Weights sum to zero, can't be normalized\")\n\n    return sum_ / scale",
    "scikit-learn.sklearn.utils._array_api._xlogy": "def _xlogy(x, y, xp=None):\n    # TODO: Remove this once https://github.com/scipy/scipy/issues/21736 is fixed\n    xp, _, device_ = get_namespace_and_device(x, y, xp=xp)\n\n    with numpy.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        temp = x * xp.log(y)\n    return xp.where(x == 0.0, xp.asarray(0.0, dtype=temp.dtype, device=device_), temp)"
}