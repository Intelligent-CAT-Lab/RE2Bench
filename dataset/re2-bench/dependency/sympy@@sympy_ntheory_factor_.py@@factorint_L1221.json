{
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.mul.as_powers_dict": "def as_powers_dict(self):\n    d = defaultdict(int)\n    for term in self.args:\n        for b, e in term.as_powers_dict().items():\n            d[b] += e\n    return d",
    "sympy.sympy.external.ntheory.remove": "def remove(x, f):\n    if f < 2:\n        raise ValueError(\"factor must be > 1\")\n    if x == 0:\n        return 0, 0\n    if f == 2:\n        b = bit_scan1(x)\n        return x >> b, b\n    m = 0\n    y, rem = divmod(x, f)\n    while not rem:\n        x = y\n        m += 1\n        if m > 5:\n            pow_list = [f**2]\n            while pow_list:\n                _f = pow_list[-1]\n                y, rem = divmod(x, _f)\n                if not rem:\n                    m += 1 << len(pow_list)\n                    x = y\n                    pow_list.append(_f**2)\n                else:\n                    pow_list.pop()\n        y, rem = divmod(x, f)\n    return x, m",
    "sympy.sympy.external.ntheory.sqrt": "def sqrt(x):\n    \"\"\"Integer square root of x.\"\"\"\n    return int(mlib.isqrt(int(x)))",
    "sympy.sympy.external.ntheory.sqrtrem": "def sqrtrem(x):\n    \"\"\"Integer square root of x and remainder.\"\"\"\n    s, r = mlib.sqrtrem(int(x))\n    return (int(s), int(r))",
    "sympy.sympy.ntheory.factor_._trial": "def _trial(factors, n, candidates, verbose=False):\n    \"\"\"\n    Helper function for integer factorization. Trial factors ``n`\n    against all integers given in the sequence ``candidates``\n    and updates the dict ``factors`` in-place. Returns the reduced\n    value of ``n`` and a flag indicating whether any factors were found.\n    \"\"\"\n    if verbose:\n        factors0 = list(factors.keys())\n    nfactors = len(factors)\n    for d in candidates:\n        if n % d == 0:\n            if n != d:\n                factor_cache[n] = d\n            n, m = remove(n // d, d)\n            factors[d] = m + 1\n    if verbose:\n        for k in sorted(set(factors).difference(set(factors0))):\n            print(factor_msg % (k, factors[k]))\n    return int(n), len(factors) != nfactors",
    "sympy.sympy.ntheory.factor_._check_termination": "def _check_termination(factors, n, limit, use_trial, use_rho, use_pm1,\n                       verbose, next_p):\n    \"\"\"\n    Helper function for integer factorization. Checks if ``n``\n    is a prime or a perfect power, and in those cases updates the factorization.\n    \"\"\"\n    if verbose:\n        print('Check for termination')\n    if n == 1:\n        if verbose:\n            print(complete_msg)\n        return True\n    if n < next_p**2 or isprime(n):\n        factor_cache[n] = n\n        factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return True\n\n    # since we've already been factoring there is no need to do\n    # simultaneous factoring with the power check\n    p = _perfect_power(n, next_p)\n    if not p:\n        return False\n    base, exp = p\n    if base < next_p**2 or isprime(base):\n        factor_cache[n] = base\n        factors[base] = exp\n    else:\n        facs = factorint(base, limit, use_trial, use_rho, use_pm1,\n                         verbose=False)\n        for b, e in facs.items():\n            if verbose:\n                print(factor_msg % (b, e))\n            factors[b] = exp*e\n    if verbose:\n        print(complete_msg)\n    return True",
    "sympy.sympy.ntheory.factor_._factorint_small": "def _factorint_small(factors, n, limit, fail_max, next_p=2):\n    \"\"\"\n    Return the value of n and either a 0 (indicating that factorization up\n    to the limit was complete) or else the next near-prime that would have\n    been tested.\n\n    Factoring stops if there are fail_max unsuccessful tests in a row.\n\n    If factors of n were found they will be in the factors dictionary as\n    {factor: multiplicity} and the returned value of n will have had those\n    factors removed. The factors dictionary is modified in-place.\n\n    \"\"\"\n\n    def done(n, d):\n        \"\"\"return n, d if the sqrt(n) was not reached yet, else\n           n, 0 indicating that factoring is done.\n        \"\"\"\n        if d*d <= n:\n            return n, d\n        return n, 0\n\n    limit2 = limit**2\n    threshold2 = min(n, limit2)\n\n    if next_p < 3:\n        if not n & 1:\n            m = bit_scan1(n)\n            factors[2] = m\n            n >>= m\n            threshold2 = min(n, limit2)\n        next_p = 3\n        if threshold2 < 9: # next_p**2 = 9\n            return done(n, next_p)\n\n    if next_p < 5:\n        if not n % 3:\n            n //= 3\n            m = 1\n            while not n % 3:\n                n //= 3\n                m += 1\n                if m == 20:\n                    n, mm = remove(n, 3)\n                    m += mm\n                    break\n            factors[3] = m\n            threshold2 = min(n, limit2)\n        next_p = 5\n        if threshold2 < 25: # next_p**2 = 25\n            return done(n, next_p)\n\n    # Because of the order of checks, starting from `min_p = 6k+5`,\n    # useless checks are caused.\n    # We want to calculate\n    # next_p += [-1, -2, 3, 2, 1, 0][next_p % 6]\n    p6 = next_p % 6\n    next_p += (-1 if p6 < 2 else 5) - p6\n\n    fails = 0\n    while fails < fail_max:\n        # next_p % 6 == 5\n        if n % next_p:\n            fails += 1\n        else:\n            n //= next_p\n            m = 1\n            while not n % next_p:\n                n //= next_p\n                m += 1\n                if m == 20:\n                    n, mm = remove(n, next_p)\n                    m += mm\n                    break\n            factors[next_p] = m\n            fails = 0\n            threshold2 = min(n, limit2)\n        next_p += 2\n        if threshold2 < next_p**2:\n            return done(n, next_p)\n\n        # next_p % 6 == 1\n        if n % next_p:\n            fails += 1\n        else:\n            n //= next_p\n            m = 1\n            while not n % next_p:\n                n //= next_p\n                m += 1\n                if m == 20:\n                    n, mm = remove(n, next_p)\n                    m += mm\n                    break\n            factors[next_p] = m\n            fails = 0\n            threshold2 = min(n, limit2)\n        next_p += 4\n        if threshold2 < next_p**2:\n            return done(n, next_p)\n    return done(n, next_p)",
    "sympy.sympy.ntheory.factor_.factorint": "def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True,\n              use_ecm=True, verbose=False, visual=None, multiple=False):\n    r\"\"\"\n    Given a positive integer ``n``, ``factorint(n)`` returns a dict containing\n    the prime factors of ``n`` as keys and their respective multiplicities\n    as values. For example:\n\n    >>> from sympy.ntheory import factorint\n    >>> factorint(2000)    # 2000 = (2**4) * (5**3)\n    {2: 4, 5: 3}\n    >>> factorint(65537)   # This number is prime\n    {65537: 1}\n\n    For input less than 2, factorint behaves as follows:\n\n        - ``factorint(1)`` returns the empty factorization, ``{}``\n        - ``factorint(0)`` returns ``{0:1}``\n        - ``factorint(-n)`` adds ``-1:1`` to the factors and then factors ``n``\n\n    Partial Factorization:\n\n    If ``limit`` (> 3) is specified, the search is stopped after performing\n    trial division up to (and including) the limit (or taking a\n    corresponding number of rho/p-1 steps). This is useful if one has\n    a large number and only is interested in finding small factors (if\n    any). Note that setting a limit does not prevent larger factors\n    from being found early; it simply means that the largest factor may\n    be composite. Since checking for perfect power is relatively cheap, it is\n    done regardless of the limit setting.\n\n    This number, for example, has two small factors and a huge\n    semi-prime factor that cannot be reduced easily:\n\n    >>> from sympy.ntheory import isprime\n    >>> a = 1407633717262338957430697921446883\n    >>> f = factorint(a, limit=10000)\n    >>> f == {991: 1, int(202916782076162456022877024859): 1, 7: 1}\n    True\n    >>> isprime(max(f))\n    False\n\n    This number has a small factor and a residual perfect power whose\n    base is greater than the limit:\n\n    >>> factorint(3*101**7, limit=5)\n    {3: 1, 101: 7}\n\n    List of Factors:\n\n    If ``multiple`` is set to ``True`` then a list containing the\n    prime factors including multiplicities is returned.\n\n    >>> factorint(24, multiple=True)\n    [2, 2, 2, 3]\n\n    Visual Factorization:\n\n    If ``visual`` is set to ``True``, then it will return a visual\n    factorization of the integer.  For example:\n\n    >>> from sympy import pprint\n    >>> pprint(factorint(4200, visual=True))\n     3  1  2  1\n    2 *3 *5 *7\n\n    Note that this is achieved by using the evaluate=False flag in Mul\n    and Pow. If you do other manipulations with an expression where\n    evaluate=False, it may evaluate.  Therefore, you should use the\n    visual option only for visualization, and use the normal dictionary\n    returned by visual=False if you want to perform operations on the\n    factors.\n\n    You can easily switch between the two forms by sending them back to\n    factorint:\n\n    >>> from sympy import Mul\n    >>> regular = factorint(1764); regular\n    {2: 2, 3: 2, 7: 2}\n    >>> pprint(factorint(regular))\n     2  2  2\n    2 *3 *7\n\n    >>> visual = factorint(1764, visual=True); pprint(visual)\n     2  2  2\n    2 *3 *7\n    >>> print(factorint(visual))\n    {2: 2, 3: 2, 7: 2}\n\n    If you want to send a number to be factored in a partially factored form\n    you can do so with a dictionary or unevaluated expression:\n\n    >>> factorint(factorint({4: 2, 12: 3})) # twice to toggle to dict form\n    {2: 10, 3: 3}\n    >>> factorint(Mul(4, 12, evaluate=False))\n    {2: 4, 3: 1}\n\n    The table of the output logic is:\n\n        ====== ====== ======= =======\n                       Visual\n        ------ ----------------------\n        Input  True   False   other\n        ====== ====== ======= =======\n        dict    mul    dict    mul\n        n       mul    dict    dict\n        mul     mul    dict    dict\n        ====== ====== ======= =======\n\n    Notes\n    =====\n\n    Algorithm:\n\n    The function switches between multiple algorithms. Trial division\n    quickly finds small factors (of the order 1-5 digits), and finds\n    all large factors if given enough time. The Pollard rho and p-1\n    algorithms are used to find large factors ahead of time; they\n    will often find factors of the order of 10 digits within a few\n    seconds:\n\n    >>> factors = factorint(12345678910111213141516)\n    >>> for base, exp in sorted(factors.items()):\n    ...     print('%s %s' % (base, exp))\n    ...\n    2 2\n    2507191691 1\n    1231026625769 1\n\n    Any of these methods can optionally be disabled with the following\n    boolean parameters:\n\n        - ``use_trial``: Toggle use of trial division\n        - ``use_rho``: Toggle use of Pollard's rho method\n        - ``use_pm1``: Toggle use of Pollard's p-1 method\n\n    ``factorint`` also periodically checks if the remaining part is\n    a prime number or a perfect power, and in those cases stops.\n\n    For unevaluated factorial, it uses Legendre's formula(theorem).\n\n\n    If ``verbose`` is set to ``True``, detailed progress is printed.\n\n    See Also\n    ========\n\n    smoothness, smoothness_p, divisors\n\n    \"\"\"\n    if isinstance(n, Dict):\n        n = dict(n)\n    if multiple:\n        fac = factorint(n, limit=limit, use_trial=use_trial,\n                           use_rho=use_rho, use_pm1=use_pm1,\n                           verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One/p]*(-fac[p])\n                               for p in sorted(fac)), [])\n        return factorlist\n\n    factordict = {}\n    if visual and not isinstance(n, (Mul, dict)):\n        factordict = factorint(n, limit=limit, use_trial=use_trial,\n                               use_rho=use_rho, use_pm1=use_pm1,\n                               verbose=verbose, visual=False)\n    elif isinstance(n, Mul):\n        factordict = {int(k): int(v) for k, v in\n            n.as_powers_dict().items()}\n    elif isinstance(n, dict):\n        factordict = n\n    if factordict and isinstance(n, (Mul, dict)):\n        # check it\n        for key in list(factordict.keys()):\n            if isprime(key):\n                continue\n            e = factordict.pop(key)\n            d = factorint(key, limit=limit, use_trial=use_trial, use_rho=use_rho,\n                          use_pm1=use_pm1, verbose=verbose, visual=False)\n            for k, v in d.items():\n                if k in factordict:\n                    factordict[k] += v*e\n                else:\n                    factordict[k] = v*e\n    if visual or (type(n) is dict and\n                  visual is not True and\n                  visual is not False):\n        if factordict == {}:\n            return S.One\n        if -1 in factordict:\n            factordict.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False)\n                     for i in sorted(factordict.items())])\n        return Mul(*args, evaluate=False)\n    elif isinstance(n, (dict, Mul)):\n        return factordict\n\n    assert use_trial or use_rho or use_pm1 or use_ecm\n\n    from sympy.functions.combinatorial.factorials import factorial\n    if isinstance(n, factorial):\n        x = as_int(n.args[0])\n        if x >= 20:\n            factors = {}\n            m = 2 # to initialize the if condition below\n            for p in sieve.primerange(2, x + 1):\n                if m > 1:\n                    m, q = 0, x // p\n                    while q != 0:\n                        m += q\n                        q //= p\n                factors[p] = m\n            if factors and verbose:\n                for k in sorted(factors):\n                    print(factor_msg % (k, factors[k]))\n            if verbose:\n                print(complete_msg)\n            return factors\n        else:\n            # if n < 20!, direct computation is faster\n            # since it uses a lookup table\n            n = n.func(x)\n\n    n = as_int(n)\n    if limit:\n        limit = int(limit)\n        use_ecm = False\n\n    # special cases\n    if n < 0:\n        factors = factorint(\n            -n, limit=limit, use_trial=use_trial, use_rho=use_rho,\n            use_pm1=use_pm1, verbose=verbose, visual=False)\n        factors[-1] = 1\n        return factors\n\n    if limit and limit < 2:\n        if n == 1:\n            return {}\n        return {n: 1}\n    elif n < 10:\n        # doing this we are assured of getting a limit > 2\n        # when we have to compute it later\n        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1},\n                {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]\n\n    factors = {}\n\n    # do simplistic factorization\n    if verbose:\n        sn = str(n)\n        if len(sn) > 50:\n            print(f\"Factoring {sn[:5]}..({len(sn) - 10} other digits)..{sn[-5:]}\")\n        else:\n            print('Factoring', n)\n\n    # this is the preliminary factorization for small factors\n    # We want to guarantee that there are no small prime factors,\n    # so we run even if `use_trial` is False.\n    small = 2**15\n    fail_max = 600\n    small = min(small, limit or small)\n    if verbose:\n        print(trial_int_msg % (2, small, fail_max))\n    n, next_p = _factorint_small(factors, n, small, fail_max)\n    if factors and verbose:\n        for k in sorted(factors):\n            print(factor_msg % (k, factors[k]))\n    if next_p == 0:\n        if n > 1:\n            factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return factors\n    # Check if it exists in the cache\n    while p := factor_cache.get(n):\n        n, e = remove(n, p)\n        factors[int(p)] = int(e)\n    # first check if the simplistic run didn't finish\n    # because of the limit and check for a perfect\n    # power before exiting\n    if limit and next_p > limit:\n        if verbose:\n            print('Exceeded limit:', limit)\n        if _check_termination(factors, n, limit, use_trial,\n                              use_rho, use_pm1, verbose, next_p):\n            return factors\n        if n > 1:\n            factors[int(n)] = 1\n        return factors\n    if _check_termination(factors, n, limit, use_trial,\n                          use_rho, use_pm1, verbose, next_p):\n        return factors\n\n    # continue with more advanced factorization methods\n    # ...do a Fermat test since it's so easy and we need the\n    # square root anyway. Finding 2 factors is easy if they are\n    # \"close enough.\" This is the big root equivalent of dividing by\n    # 2, 3, 5.\n    sqrt_n = isqrt(n)\n    a = sqrt_n + 1\n    # If `n % 4 == 1`, `a` must be odd for `a**2 - n` to be a square number.\n    if (n % 4 == 1) ^ (a & 1):\n        a += 1\n    a2 = a**2\n    b2 = a2 - n\n    for _ in range(3):\n        b, fermat = sqrtrem(b2)\n        if not fermat:\n            if verbose:\n                print(fermat_msg)\n            for r in [a - b, a + b]:\n                facs = factorint(r, limit=limit, use_trial=use_trial,\n                                 use_rho=use_rho, use_pm1=use_pm1,\n                                 verbose=verbose)\n                for k, v in facs.items():\n                    factors[k] = factors.get(k, 0) + v\n            if verbose:\n                print(complete_msg)\n            return factors\n        b2 += (a + 1) << 2  # equiv to (a + 2)**2 - n\n        a += 2\n\n    # these are the limits for trial division which will\n    # be attempted in parallel with pollard methods\n    low, high = next_p, 2*next_p\n\n    # add 1 to make sure limit is reached in primerange calls\n    _limit = (limit or sqrt_n) + 1\n    iteration = 0\n    while 1:\n        high_ = min(high, _limit)\n\n        # Trial division\n        if use_trial:\n            if verbose:\n                print(trial_msg % (low, high_))\n            ps = sieve.primerange(low, high_)\n            n, found_trial = _trial(factors, n, ps, verbose)\n            next_p = high_\n            if found_trial and _check_termination(factors, n, limit, use_trial,\n                                                  use_rho, use_pm1, verbose, next_p):\n                return factors\n        else:\n            found_trial = False\n\n        if high > _limit:\n            if verbose:\n                print('Exceeded limit:', _limit)\n            if n > 1:\n                factors[int(n)] = 1\n            if verbose:\n                print(complete_msg)\n            return factors\n\n        # Only used advanced methods when no small factors were found\n        if not found_trial:\n            # Pollard p-1\n            if use_pm1:\n                if verbose:\n                    print(pm1_msg % (low, high_))\n                c = pollard_pm1(n, B=low, seed=high_)\n                if c:\n                    if c < next_p**2 or isprime(c):\n                        ps = [c]\n                    else:\n                        ps = factorint(c, limit=limit,\n                                       use_trial=use_trial,\n                                       use_rho=use_rho,\n                                       use_pm1=use_pm1,\n                                       use_ecm=use_ecm,\n                                       verbose=verbose)\n                    n, _ = _trial(factors, n, ps, verbose=False)\n                    if _check_termination(factors, n, limit, use_trial,\n                                          use_rho, use_pm1, verbose, next_p):\n                        return factors\n\n            # Pollard rho\n            if use_rho:\n                if verbose:\n                    print(rho_msg % (1, low, high_))\n                c = pollard_rho(n, retries=1, max_steps=low, seed=high_)\n                if c:\n                    if c < next_p**2 or isprime(c):\n                        ps = [c]\n                    else:\n                        ps = factorint(c, limit=limit,\n                                       use_trial=use_trial,\n                                       use_rho=use_rho,\n                                       use_pm1=use_pm1,\n                                       use_ecm=use_ecm,\n                                       verbose=verbose)\n                    n, _ = _trial(factors, n, ps, verbose=False)\n                    if _check_termination(factors, n, limit, use_trial,\n                                          use_rho, use_pm1, verbose, next_p):\n                        return factors\n        # Use subexponential algorithms if use_ecm\n        # Use pollard algorithms for finding small factors for 3 iterations\n        # if after small factors the number of digits of n >= 25 then use ecm\n        iteration += 1\n        if use_ecm and iteration >= 3 and num_digits(n) >= 24:\n            break\n        low, high = high, high*2\n\n    B1 = 10000\n    B2 = 100*B1\n    num_curves = 50\n    while(1):\n        if verbose:\n            print(ecm_msg % (B1, B2, num_curves))\n        factor = _ecm_one_factor(n, B1, B2, num_curves, seed=B1)\n        if factor:\n            if factor < next_p**2 or isprime(factor):\n                ps = [factor]\n            else:\n                ps = factorint(factor, limit=limit,\n                           use_trial=use_trial,\n                           use_rho=use_rho,\n                           use_pm1=use_pm1,\n                           use_ecm=use_ecm,\n                           verbose=verbose)\n            n, _ = _trial(factors, n, ps, verbose=False)\n            if _check_termination(factors, n, limit, use_trial,\n                                  use_rho, use_pm1, verbose, next_p):\n                return factors\n        B1 *= 5\n        B2 = 100*B1\n        num_curves *= 4",
    "sympy.sympy.ntheory.factor_.<genexpr>": "factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One/p]*(-fac[p])\n                       for p in sorted(fac)), [])\n",
    "sympy.sympy.ntheory.factor_.<dictcomp>": "factordict = {int(k): int(v) for k, v in\n    n.as_powers_dict().items()}\n",
    "sympy.sympy.ntheory.factor_.<listcomp>": "args.extend([Pow(*i, evaluate=False)\n             for i in sorted(factordict.items())])\n",
    "sympy.sympy.ntheory.factor_.get": "def get(self, n: int, default=None):\n    \"\"\" Return the prime factor of ``n``.\n    If it does not exist in the cache, return the value of ``default``.\n    \"\"\"\n    if n <= sieve._list[-1]:\n        if sieve._list[bisect_left(sieve._list, n)] == n:\n            return n\n    if n in self._cache:\n        self._cache.move_to_end(n)\n        return self._cache[n]\n    if factors := self.get_external(n):\n        self.add(n, factors)\n        return self._cache[n]\n    return default",
    "sympy.sympy.ntheory.factor_.pollard_rho": "def pollard_rho(n, s=2, a=1, retries=5, seed=1234, max_steps=None, F=None):\n    r\"\"\"\n    Use Pollard's rho method to try to extract a nontrivial factor\n    of ``n``. The returned factor may be a composite number. If no\n    factor is found, ``None`` is returned.\n\n    The algorithm generates pseudo-random values of x with a generator\n    function, replacing x with F(x). If F is not supplied then the\n    function x**2 + ``a`` is used. The first value supplied to F(x) is ``s``.\n    Upon failure (if ``retries`` is > 0) a new ``a`` and ``s`` will be\n    supplied; the ``a`` will be ignored if F was supplied.\n\n    The sequence of numbers generated by such functions generally have a\n    a lead-up to some number and then loop around back to that number and\n    begin to repeat the sequence, e.g. 1, 2, 3, 4, 5, 3, 4, 5 -- this leader\n    and loop look a bit like the Greek letter rho, and thus the name, 'rho'.\n\n    For a given function, very different leader-loop values can be obtained\n    so it is a good idea to allow for retries:\n\n    >>> from sympy.ntheory.generate import cycle_length\n    >>> n = 16843009\n    >>> F = lambda x:(2048*pow(x, 2, n) + 32767) % n\n    >>> for s in range(5):\n    ...     print('loop length = %4i; leader length = %3i' % next(cycle_length(F, s)))\n    ...\n    loop length = 2489; leader length =  43\n    loop length =   78; leader length = 121\n    loop length = 1482; leader length = 100\n    loop length = 1482; leader length = 286\n    loop length = 1482; leader length = 101\n\n    Here is an explicit example where there is a three element leadup to\n    a sequence of 3 numbers (11, 14, 4) that then repeat:\n\n    >>> x=2\n    >>> for i in range(9):\n    ...     print(x)\n    ...     x=(x**2+12)%17\n    ...\n    2\n    16\n    13\n    11\n    14\n    4\n    11\n    14\n    4\n    >>> next(cycle_length(lambda x: (x**2+12)%17, 2))\n    (3, 3)\n    >>> list(cycle_length(lambda x: (x**2+12)%17, 2, values=True))\n    [2, 16, 13, 11, 14, 4]\n\n    Instead of checking the differences of all generated values for a gcd\n    with n, only the kth and 2*kth numbers are checked, e.g. 1st and 2nd,\n    2nd and 4th, 3rd and 6th until it has been detected that the loop has been\n    traversed. Loops may be many thousands of steps long before rho finds a\n    factor or reports failure. If ``max_steps`` is specified, the iteration\n    is cancelled with a failure after the specified number of steps.\n\n    Examples\n    ========\n\n    >>> from sympy import pollard_rho\n    >>> n=16843009\n    >>> F=lambda x:(2048*pow(x,2,n) + 32767) % n\n    >>> pollard_rho(n, F=F)\n    257\n\n    Use the default setting with a bad value of ``a`` and no retries:\n\n    >>> pollard_rho(n, a=n-2, retries=0)\n\n    If retries is > 0 then perhaps the problem will correct itself when\n    new values are generated for a:\n\n    >>> pollard_rho(n, a=n-2, retries=1)\n    257\n\n    References\n    ==========\n\n    .. [1] Richard Crandall & Carl Pomerance (2005), \"Prime Numbers:\n           A Computational Perspective\", Springer, 2nd edition, 229-231\n\n    \"\"\"\n    n = int(n)\n    if n < 5:\n        raise ValueError('pollard_rho should receive n > 4')\n    randint = _randint(seed + retries)\n    V = s\n    for i in range(retries + 1):\n        U = V\n        if not F:\n            F = lambda x: (pow(x, 2, n) + a) % n\n        j = 0\n        while 1:\n            if max_steps and (j > max_steps):\n                break\n            j += 1\n            U = F(U)\n            V = F(F(V))  # V is 2x further along than U\n            g = gcd(U - V, n)\n            if g == 1:\n                continue\n            if g == n:\n                break\n            return int(g)\n        V = randint(0, n - 1)\n        a = randint(1, n - 3)  # for x**2 + a, a%n should not be 0 or -2\n        F = None\n    return None",
    "sympy.sympy.ntheory.factor_.pollard_pm1": "def pollard_pm1(n, B=10, a=2, retries=0, seed=1234):\n    \"\"\"\n    Use Pollard's p-1 method to try to extract a nontrivial factor\n    of ``n``. Either a divisor (perhaps composite) or ``None`` is returned.\n\n    The value of ``a`` is the base that is used in the test gcd(a**M - 1, n).\n    The default is 2.  If ``retries`` > 0 then if no factor is found after the\n    first attempt, a new ``a`` will be generated randomly (using the ``seed``)\n    and the process repeated.\n\n    Note: the value of M is lcm(1..B) = reduce(ilcm, range(2, B + 1)).\n\n    A search is made for factors next to even numbers having a power smoothness\n    less than ``B``. Choosing a larger B increases the likelihood of finding a\n    larger factor but takes longer. Whether a factor of n is found or not\n    depends on ``a`` and the power smoothness of the even number just less than\n    the factor p (hence the name p - 1).\n\n    Although some discussion of what constitutes a good ``a`` some\n    descriptions are hard to interpret. At the modular.math site referenced\n    below it is stated that if gcd(a**M - 1, n) = N then a**M % q**r is 1\n    for every prime power divisor of N. But consider the following:\n\n        >>> from sympy.ntheory.factor_ import smoothness_p, pollard_pm1\n        >>> n=257*1009\n        >>> smoothness_p(n)\n        (-1, [(257, (1, 2, 256)), (1009, (1, 7, 16))])\n\n    So we should (and can) find a root with B=16:\n\n        >>> pollard_pm1(n, B=16, a=3)\n        1009\n\n    If we attempt to increase B to 256 we find that it does not work:\n\n        >>> pollard_pm1(n, B=256)\n        >>>\n\n    But if the value of ``a`` is changed we find that only multiples of\n    257 work, e.g.:\n\n        >>> pollard_pm1(n, B=256, a=257)\n        1009\n\n    Checking different ``a`` values shows that all the ones that did not\n    work had a gcd value not equal to ``n`` but equal to one of the\n    factors:\n\n        >>> from sympy import ilcm, igcd, factorint, Pow\n        >>> M = 1\n        >>> for i in range(2, 256):\n        ...     M = ilcm(M, i)\n        ...\n        >>> set([igcd(pow(a, M, n) - 1, n) for a in range(2, 256) if\n        ...      igcd(pow(a, M, n) - 1, n) != n])\n        {1009}\n\n    But does aM % d for every divisor of n give 1?\n\n        >>> aM = pow(255, M, n)\n        >>> [(d, aM%Pow(*d.args)) for d in factorint(n, visual=True).args]\n        [(257**1, 1), (1009**1, 1)]\n\n    No, only one of them. So perhaps the principle is that a root will\n    be found for a given value of B provided that:\n\n    1) the power smoothness of the p - 1 value next to the root\n       does not exceed B\n    2) a**M % p != 1 for any of the divisors of n.\n\n    By trying more than one ``a`` it is possible that one of them\n    will yield a factor.\n\n    Examples\n    ========\n\n    With the default smoothness bound, this number cannot be cracked:\n\n        >>> from sympy.ntheory import pollard_pm1\n        >>> pollard_pm1(21477639576571)\n\n    Increasing the smoothness bound helps:\n\n        >>> pollard_pm1(21477639576571, B=2000)\n        4410317\n\n    Looking at the smoothness of the factors of this number we find:\n\n        >>> from sympy.ntheory.factor_ import smoothness_p, factorint\n        >>> print(smoothness_p(21477639576571, visual=1))\n        p**i=4410317**1 has p-1 B=1787, B-pow=1787\n        p**i=4869863**1 has p-1 B=2434931, B-pow=2434931\n\n    The B and B-pow are the same for the p - 1 factorizations of the divisors\n    because those factorizations had a very large prime factor:\n\n        >>> factorint(4410317 - 1)\n        {2: 2, 617: 1, 1787: 1}\n        >>> factorint(4869863-1)\n        {2: 1, 2434931: 1}\n\n    Note that until B reaches the B-pow value of 1787, the number is not cracked;\n\n        >>> pollard_pm1(21477639576571, B=1786)\n        >>> pollard_pm1(21477639576571, B=1787)\n        4410317\n\n    The B value has to do with the factors of the number next to the divisor,\n    not the divisors themselves. A worst case scenario is that the number next\n    to the factor p has a large prime divisisor or is a perfect power. If these\n    conditions apply then the power-smoothness will be about p/2 or p. The more\n    realistic is that there will be a large prime factor next to p requiring\n    a B value on the order of p/2. Although primes may have been searched for\n    up to this level, the p/2 is a factor of p - 1, something that we do not\n    know. The modular.math reference below states that 15% of numbers in the\n    range of 10**15 to 15**15 + 10**4 are 10**6 power smooth so a B of 10**6\n    will fail 85% of the time in that range. From 10**8 to 10**8 + 10**3 the\n    percentages are nearly reversed...but in that range the simple trial\n    division is quite fast.\n\n    References\n    ==========\n\n    .. [1] Richard Crandall & Carl Pomerance (2005), \"Prime Numbers:\n           A Computational Perspective\", Springer, 2nd edition, 236-238\n    .. [2] https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html\n    .. [3] https://www.cs.toronto.edu/~yuvalf/Factorization.pdf\n    \"\"\"\n\n    n = int(n)\n    if n < 4 or B < 3:\n        raise ValueError('pollard_pm1 should receive n > 3 and B > 2')\n    randint = _randint(seed + B)\n\n    # computing a**lcm(1,2,3,..B) % n for B > 2\n    # it looks weird, but it's right: primes run [2, B]\n    # and the answer's not right until the loop is done.\n    for i in range(retries + 1):\n        aM = a\n        for p in sieve.primerange(2, B + 1):\n            e = int(math.log(B, p))\n            aM = pow(aM, pow(p, e), n)\n        g = gcd(aM - 1, n)\n        if 1 < g < n:\n            return int(g)\n\n        # get a new a:\n        # since the exponent, lcm(1..B), is even, if we allow 'a' to be 'n-1'\n        # then (n - 1)**even % n will be 1 which will give a g of 0 and 1 will\n        # give a zero, too, so we set the range as [2, n-2]. Some references\n        # say 'a' should be coprime to n, but either will detect factors.\n        a = randint(2, n - 2)",
    "sympy.sympy.ntheory.primetest.isprime": "def isprime(n):\n    \"\"\"\n    Test if n is a prime number (True) or not (False). For n < 2^64 the\n    answer is definitive; larger n values have a small probability of actually\n    being pseudoprimes.\n\n    Negative numbers (e.g. -2) are not considered prime.\n\n    The first step is looking for trivial factors, which if found enables\n    a quick return.  Next, if the sieve is large enough, use bisection search\n    on the sieve.  For small numbers, a set of deterministic Miller-Rabin\n    tests are performed with bases that are known to have no counterexamples\n    in their range.  Finally if the number is larger than 2^64, a strong\n    BPSW test is performed.  While this is a probable prime test and we\n    believe counterexamples exist, there are no known counterexamples.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import isprime\n    >>> isprime(13)\n    True\n    >>> isprime(15)\n    False\n\n    Notes\n    =====\n\n    This routine is intended only for integer input, not numerical\n    expressions which may represent numbers. Floats are also\n    rejected as input because they represent numbers of limited\n    precision. While it is tempting to permit 7.0 to represent an\n    integer there are errors that may \"pass silently\" if this is\n    allowed:\n\n    >>> from sympy import Float, S\n    >>> int(1e3) == 1e3 == 10**3\n    True\n    >>> int(1e23) == 1e23\n    True\n    >>> int(1e23) == 10**23\n    False\n\n    >>> near_int = 1 + S(1)/10**19\n    >>> near_int == int(near_int)\n    False\n    >>> n = Float(near_int, 10)  # truncated by precision\n    >>> n % 1 == 0\n    True\n    >>> n = Float(near_int, 20)\n    >>> n % 1 == 0\n    False\n\n    See Also\n    ========\n\n    sympy.ntheory.generate.primerange : Generates all primes in a given range\n    sympy.functions.combinatorial.numbers.primepi : Return the number of primes less than or equal to n\n    sympy.ntheory.generate.prime : Return the nth prime\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Strong_pseudoprime\n    .. [2] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [3] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n    \"\"\"\n    n = as_int(n)\n\n    # Step 1, do quick composite testing via trial division.  The individual\n    # modulo tests benchmark faster than one or two primorial igcds for me.\n    # The point here is just to speedily handle small numbers and many\n    # composites.  Step 2 only requires that n <= 2 get handled here.\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or (n % 2) == 0 or (n % 3) == 0 or (n % 5) == 0:\n        return False\n    if n < 49:\n        return True\n    if (n %  7) == 0 or (n % 11) == 0 or (n % 13) == 0 or (n % 17) == 0 or \\\n       (n % 19) == 0 or (n % 23) == 0 or (n % 29) == 0 or (n % 31) == 0 or \\\n       (n % 37) == 0 or (n % 41) == 0 or (n % 43) == 0 or (n % 47) == 0:\n        return False\n    if n < 2809:\n        return True\n    if n < 65077:\n        # There are only five Euler pseudoprimes with a least prime factor greater than 47\n        return pow(2, n >> 1, n) in [1, n - 1] and n not in [8321, 31621, 42799, 49141, 49981]\n\n    # bisection search on the sieve if the sieve is large enough\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.ntheory.factor_ import factor_cache\n    if (ret := factor_cache.get(n)) is not None:\n        return ret == n\n\n    # If we have GMPY2, skip straight to step 3 and do a strong BPSW test.\n    # This should be a bit faster than our step 2, and for large values will\n    # be a lot faster than our step 3 (C+GMP vs. Python).\n    if _gmpy is not None:\n        return is_strong_bpsw_prp(n)\n\n\n    # Step 2: deterministic Miller-Rabin testing for numbers < 2^64.  See:\n    #    https://miller-rabin.appspot.com/\n    # for lists.  We have made sure the M-R routine will successfully handle\n    # bases larger than n, so we can use the minimal set.\n    # In September 2015 deterministic numbers were extended to over 2^81.\n    #    https://arxiv.org/pdf/1509.00864.pdf\n    #    https://oeis.org/A014233\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 4296595241:\n        # Michal Forisek and Jakub Jancina,\n        # Fast Primality Testing for Integers That Fit into a Machine Word\n        # https://ceur-ws.org/Vol-1326/020-Forisek.pdf\n        h = ((n >> 16) ^ n) * 0x45d9f3b\n        h = ((h >> 16) ^ h) * 0x45d9f3b\n        h = ((h >> 16) ^ h) & 255\n        return mr(n, [_MR_BASES_32[h]])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    if n < 318665857834031151167461:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37])\n    if n < 3317044064679887385961981:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])\n\n    # We could do this instead at any point:\n    #if n < 18446744073709551616:\n    #   return mr(n, [2]) and is_extra_strong_lucas_prp(n)\n\n    # Here are tests that are safe for MR routines that don't understand\n    # large bases.\n    #if n < 9080191:\n    #    return mr(n, [31, 73])\n    #if n < 19471033:\n    #    return mr(n, [2, 299417])\n    #if n < 38010307:\n    #    return mr(n, [2, 9332593])\n    #if n < 316349281:\n    #    return mr(n, [11000544, 31481107])\n    #if n < 4759123141:\n    #    return mr(n, [2, 7, 61])\n    #if n < 105936894253:\n    #    return mr(n, [2, 1005905886, 1340600841])\n    #if n < 31858317218647:\n    #    return mr(n, [2, 642735, 553174392, 3046413974])\n    #if n < 3071837692357849:\n    #    return mr(n, [2, 75088, 642735, 203659041, 3613982119])\n    #if n < 18446744073709551616:\n    #    return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n\n    # Step 3: BPSW.\n    #\n    #  Time for isprime(10**2000 + 4561), no gmpy or gmpy2 installed\n    #     44.0s   old isprime using 46 bases\n    #      5.3s   strong BPSW + one random base\n    #      4.3s   extra strong BPSW + one random base\n    #      4.1s   strong BPSW\n    #      3.2s   extra strong BPSW\n\n    # Classic BPSW from page 1401 of the paper.  See alternate ideas below.\n    return is_strong_bpsw_prp(n)",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}