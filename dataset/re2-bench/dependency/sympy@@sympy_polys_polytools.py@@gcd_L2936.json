{
    "sympy.sympy.polys.polyclasses.gcd": "def gcd(f, g: Self) -> Self:\n    \"\"\"Returns polynomial GCD of ``f`` and ``g``. \"\"\"\n    F, G = f.unify_DMP(g)\n    return F._gcd(G)",
    "sympy.sympy.polys.polytools._unify": "def _unify(f, g: Poly | Expr | complex) -> tuple[Domain, Callable[[DMP], Poly], DMP, DMP]:\n    gs = cast('Poly | Expr', sympify(g))\n\n    if not isinstance(gs, Poly):\n        try:\n            g_coeff = f.rep.dom.from_sympy(gs)\n        except CoercionFailed:\n            raise UnificationFailed(\"Cannot unify %s with %s\" % (f, gs))\n        else:\n            return f.rep.dom, f.per, f.rep, f.rep.ground_new(g_coeff)\n\n    if isinstance(f.rep, DMP) and isinstance(gs.rep, DMP):\n        gens = _unify_gens(f.gens, gs.gens)\n\n        dom, lev = f.rep.dom.unify(gs.rep.dom, gens), len(gens) - 1\n\n        if f.gens != gens:\n            f_monoms, f_coeffs = _dict_reorder(\n                f.rep.to_dict(), f.gens, gens)\n\n            if f.rep.dom != dom:\n                f_coeffs = [dom.convert(c, f.rep.dom) for c in f_coeffs]\n\n            F = DMP.from_dict(dict(list(zip(f_monoms, f_coeffs))), lev, dom)\n        else:\n            F = f.rep.convert(dom)\n\n        if gs.gens != gens:\n            g_monoms, g_coeffs = _dict_reorder(\n                gs.rep.to_dict(), gs.gens, gens)\n\n            if gs.rep.dom != dom:\n                g_coeffs = [dom.convert(c, gs.rep.dom) for c in g_coeffs]\n\n            G = DMP.from_dict(dict(list(zip(g_monoms, g_coeffs))), lev, dom)\n        else:\n            G = gs.rep.convert(dom)\n    else:\n        raise UnificationFailed(\"Cannot unify %s with %s\" % (f, gs))\n\n    cls = f.__class__\n\n    def per(rep, dom=dom, gens=gens, remove=None):\n        if remove is not None:\n            gens = gens[:remove] + gens[remove + 1:]\n\n            if not gens:\n                return dom.to_sympy(rep)\n\n        return cls.new(rep, *gens)\n\n    return dom, per, F, G",
    "sympy.sympy.polys.polytools.per": "def per(rep, dom=dom, gens=gens, remove=None):\n    if remove is not None:\n        gens = gens[:remove] + gens[remove + 1:]\n\n        if not gens:\n            return dom.to_sympy(rep)\n\n    return cls.new(rep, *gens)"
}