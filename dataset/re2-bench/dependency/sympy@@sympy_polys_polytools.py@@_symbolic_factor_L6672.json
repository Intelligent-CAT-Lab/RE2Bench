{
    "sympy.sympy.concrete.expr_with_limits._eval_factor": "def _eval_factor(self, **hints):\n    if 1 == len(self.limits):\n        summand = self.function.factor(**hints)\n        if summand.is_Mul:\n            out = sift(summand.args, lambda w: w.is_commutative \\\n                and not set(self.variables) & w.free_symbols)\n            return Mul(*out[True])*self.func(Mul(*out[False]), \\\n                *self.limits)\n    else:\n        summand = self.func(self.function, *self.limits[0:-1]).factor()\n        if not summand.has(self.variables[-1]):\n            return self.func(1, [self.limits[-1]]).doit()*summand\n        elif isinstance(summand, Mul):\n            return self.func(summand, self.limits[-1]).factor()\n    return self",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.core.singleton.<lambda>": "cls.__new__ = lambda cls: obj\n",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.physics.control.lti.__new__": "def __new__(cls, num, den, var, sampling_time=1):\n    if sampling_time == 0:\n        raise ValueError(filldedent(\"\"\"\n            The sampling time cannot be zero.\n            If you want to create a continuous transfer function,\n            use the TransferFunction class instead.\"\"\"))\n\n    sampling_time = sympify(sampling_time)\n    obj = super(DiscreteTransferFunction, cls).__new__(cls, num, den, var,\n                                                  sampling_time)\n    obj._sampling_time = sampling_time\n    return obj",
    "sympy.sympy.polys.polytools.__new__": "def __new__(cls, rep, *gens, **args) -> Self:\n    \"\"\"Create a new polynomial instance out of something useful. \"\"\"\n    opt = options.build_options(gens, args)\n\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n\n    if isinstance(rep, (DMP, DMF, ANP, DomainElement)):\n        return cls._from_domain_element(rep, opt)\n    elif iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep, evaluate=type(rep) is not str) # type: ignore\n\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    "sympy.sympy.polys.polytools.args": "@property\ndef args(self):\n    return (self.expr,) + self.gens",
    "sympy.sympy.polys.polytools._factors_product": "def _factors_product(factors):\n    \"\"\"Multiply a list of ``(expr, exp)`` pairs. \"\"\"\n    return Mul(*[f.as_expr()**k for f, k in factors])",
    "sympy.sympy.polys.polytools._symbolic_factor_list": "def _symbolic_factor_list(expr, opt, method):\n    \"\"\"Helper function for :func:`_symbolic_factor`. \"\"\"\n    coeff, factors = S.One, []\n\n    args = [i._eval_factor() if hasattr(i, '_eval_factor') else i\n        for i in Mul.make_args(expr)]\n    for arg in args:\n        if arg.is_Number or (isinstance(arg, Expr) and pure_complex(arg)):\n            coeff *= arg\n            continue\n        elif arg.is_Pow and arg.base != S.Exp1:\n            base, exp = arg.args\n            if base.is_Number and exp.is_Number:\n                coeff *= arg\n                continue\n            if base.is_Number:\n                factors.append((base, exp))\n                continue\n        else:\n            base, exp = arg, S.One\n\n        try:\n            poly, _ = _poly_from_expr(base, opt)\n        except PolificationFailed as exc:\n            factors.append((exc.expr, exp))\n        else:\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            if _coeff is not S.One:\n                if exp.is_Integer:\n                    coeff *= _coeff**exp\n                elif _coeff.is_positive:\n                    factors.append((_coeff, exp))\n                else:\n                    _factors.append((_coeff, S.One))\n\n            if exp is S.One:\n                factors.extend(_factors)\n            elif exp.is_integer:\n                factors.extend([(f, k*exp) for f, k in _factors])\n            else:\n                other = []\n\n                for f, k in _factors:\n                    if f.as_expr().is_positive:\n                        factors.append((f, k*exp))\n                    else:\n                        other.append((f, k))\n\n                factors.append((_factors_product(other), exp))\n    if method == 'sqf':\n        factors = [(reduce(mul, (f for f, _ in factors if _ == k)), k)\n                   for k in {i for _, i in factors}]\n    #collect duplicates\n    rv = defaultdict(int)\n    for k, v in factors:\n        rv[k] += v\n    return coeff, list(rv.items())",
    "sympy.sympy.polys.polytools.<listcomp>": "return expr.__class__([_symbolic_factor(arg, opt, method) for arg in expr])\n",
    "sympy.sympy.polys.rationaltools.together": "@public\ndef together(expr: Expr, deep: bool = False, fraction: bool = True) -> Expr:\n    \"\"\"\n    Denest and combine rational expressions using symbolic methods.\n\n    This function takes an expression or a container of expressions\n    and puts it (them) together by denesting and combining rational\n    subexpressions. No heroic measures are taken to minimize degree\n    of the resulting numerator and denominator. To obtain completely\n    reduced expression use :func:`~.cancel`. However, :func:`~.together`\n    can preserve as much as possible of the structure of the input\n    expression in the output (no expansion is performed).\n\n    A wide variety of objects can be put together including lists,\n    tuples, sets, relational objects, integrals and others. It is\n    also possible to transform interior of function applications,\n    by setting ``deep`` flag to ``True``.\n\n    By definition, :func:`~.together` is a complement to :func:`~.apart`,\n    so ``apart(together(expr))`` should return expr unchanged. Note\n    however, that :func:`~.together` uses only symbolic methods, so\n    it might be necessary to use :func:`~.cancel` to perform algebraic\n    simplification and minimize degree of the numerator and denominator.\n\n    Examples\n    ========\n\n    >>> from sympy import together, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> together(1/x + 1/y)\n    (x + y)/(x*y)\n    >>> together(1/x + 1/y + 1/z)\n    (x*y + x*z + y*z)/(x*y*z)\n\n    >>> together(1/(x*y) + 1/y**2)\n    (x + y)/(x*y**2)\n\n    >>> together(1/(1 + 1/x) + 1/(1 + 1/y))\n    (x*(y + 1) + y*(x + 1))/((x + 1)*(y + 1))\n\n    >>> together(exp(1/x + 1/y))\n    exp(1/y + 1/x)\n    >>> together(exp(1/x + 1/y), deep=True)\n    exp((x + y)/(x*y))\n\n    >>> together(1/exp(x) + 1/(x*exp(x)))\n    (x + 1)*exp(-x)/x\n\n    >>> together(1/exp(2*x) + 1/(x*exp(3*x)))\n    (x*exp(x) + 1)*exp(-3*x)/x\n\n    \"\"\"\n    def _together(expr):\n        if isinstance(expr, Basic):\n            if expr.is_Atom or (expr.is_Function and not deep):\n                return expr\n            elif expr.is_Add:\n                return gcd_terms(list(map(_together, Add.make_args(expr))), fraction=fraction)\n            elif expr.is_Pow:\n                base = _together(expr.base)\n\n                if deep:\n                    exp = _together(expr.exp)\n                else:\n                    exp = expr.exp\n\n                return expr.func(base, exp)\n            else:\n                return expr.func(*[ _together(arg) for arg in expr.args ])\n        elif iterable(expr):\n            return expr.__class__([ _together(ex) for ex in expr ])\n\n        return expr\n\n    return _together(sympify(expr))"
}