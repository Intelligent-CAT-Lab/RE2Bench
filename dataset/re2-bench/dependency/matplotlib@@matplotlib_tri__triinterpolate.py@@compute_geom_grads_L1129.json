{
    "matplotlib.lib.matplotlib.tri._triinterpolate._safe_inv22_vectorized": "def _safe_inv22_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) matrices, returns 0 for rank-deficient\n    matrices.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    _api.check_shape((None, 2, 2), M=M)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n\n    # We set delta_inv to 0. in case of a rank deficient matrix; a\n    # rank-deficient input matrix *M* will lead to a null matrix in output\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        delta_inv = 1./delta\n    else:\n        # 'Pathologic' flow.\n        delta_inv = np.zeros(M.shape[0])\n        delta_inv[rank2] = 1./delta[rank2]\n\n    M_inv[:, 0, 0] = M[:, 1, 1]*delta_inv\n    M_inv[:, 0, 1] = -M[:, 0, 1]*delta_inv\n    M_inv[:, 1, 0] = -M[:, 1, 0]*delta_inv\n    M_inv[:, 1, 1] = M[:, 0, 0]*delta_inv\n    return M_inv"
}