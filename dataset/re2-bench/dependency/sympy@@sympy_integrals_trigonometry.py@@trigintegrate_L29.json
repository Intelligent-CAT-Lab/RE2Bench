{
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.match": "def match(self, pattern, old=False):\n    \"\"\"\n    Pattern matching.\n\n    Wild symbols match all.\n\n    Return ``None`` when expression (self) does not match with pattern.\n    Otherwise return a dictionary such that::\n\n      pattern.xreplace(self.match(pattern)) == self\n\n    Examples\n    ========\n\n    >>> from sympy import Wild, Sum\n    >>> from sympy.abc import x, y\n    >>> p = Wild(\"p\")\n    >>> q = Wild(\"q\")\n    >>> r = Wild(\"r\")\n    >>> e = (x+y)**(x+y)\n    >>> e.match(p**p)\n    {p_: x + y}\n    >>> e.match(p**q)\n    {p_: x + y, q_: x + y}\n    >>> e = (2*x)**2\n    >>> e.match(p*q**r)\n    {p_: 4, q_: x, r_: 2}\n    >>> (p*q**r).xreplace(e.match(p*q**r))\n    4*x**2\n\n    Since match is purely structural expressions that are equivalent up to\n    bound symbols will not match:\n\n    >>> print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))\n    None\n\n    An expression with bound symbols can be matched if the pattern uses\n    a distinct ``Wild`` for each bound symbol:\n\n    >>> Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))\n    {p_: 2, q_: x}\n\n    The ``old`` flag will give the old-style pattern matching where\n    expressions and patterns are essentially solved to give the match. Both\n    of the following give None unless ``old=True``:\n\n    >>> (x - 2).match(p - x, old=True)\n    {p_: 2*x - 2}\n    >>> (2/x).match(p*x, old=True)\n    {p_: 2/x**2}\n\n    See Also\n    ========\n\n    matches: pattern.matches(expr) is the same as expr.match(pattern)\n    xreplace: exact structural replacement\n    replace: structural replacement with pattern matching\n    Wild: symbolic placeholders for expressions in pattern matching\n    \"\"\"\n    pattern = sympify(pattern)\n    return pattern.matches(self, old=old)",
    "sympy.sympy.core.basic.rewrite": "def rewrite(self, *args, deep=True, **hints):\n    \"\"\"\n    Rewrite *self* using a defined rule.\n\n    Rewriting transforms an expression to another, which is mathematically\n    equivalent but structurally different. For example you can rewrite\n    trigonometric functions as complex exponentials or combinatorial\n    functions as gamma function.\n\n    This method takes a *pattern* and a *rule* as positional arguments.\n    *pattern* is optional parameter which defines the types of expressions\n    that will be transformed. If it is not passed, all possible expressions\n    will be rewritten. *rule* defines how the expression will be rewritten.\n\n    Parameters\n    ==========\n\n    args : Expr\n        A *rule*, or *pattern* and *rule*.\n        - *pattern* is a type or an iterable of types.\n        - *rule* can be any object.\n\n    deep : bool, optional\n        If ``True``, subexpressions are recursively transformed. Default is\n        ``True``.\n\n    Examples\n    ========\n\n    If *pattern* is unspecified, all possible expressions are transformed.\n\n    >>> from sympy import cos, sin, exp, I\n    >>> from sympy.abc import x\n    >>> expr = cos(x) + I*sin(x)\n    >>> expr.rewrite(exp)\n    exp(I*x)\n\n    Pattern can be a type or an iterable of types.\n\n    >>> expr.rewrite(sin, exp)\n    exp(I*x)/2 + cos(x) - exp(-I*x)/2\n    >>> expr.rewrite([cos,], exp)\n    exp(I*x)/2 + I*sin(x) + exp(-I*x)/2\n    >>> expr.rewrite([cos, sin], exp)\n    exp(I*x)\n\n    Rewriting behavior can be implemented by defining ``_eval_rewrite()``\n    method.\n\n    >>> from sympy import Expr, sqrt, pi\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite(self, rule, args, **hints):\n    ...         x, = args\n    ...         if rule == cos:\n    ...             return cos(pi/2 - x, evaluate=False)\n    ...         if rule == sqrt:\n    ...             return sqrt(1 - cos(x)**2)\n    >>> MySin(MySin(x)).rewrite(cos)\n    cos(-cos(-x + pi/2) + pi/2)\n    >>> MySin(x).rewrite(sqrt)\n    sqrt(1 - cos(x)**2)\n\n    Defining ``_eval_rewrite_as_[...]()`` method is supported for backwards\n    compatibility reason. This may be removed in the future and using it is\n    discouraged.\n\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite_as_cos(self, *args, **hints):\n    ...         x, = args\n    ...         return cos(pi/2 - x, evaluate=False)\n    >>> MySin(x).rewrite(cos)\n    cos(-x + pi/2)\n\n    \"\"\"\n    if not args:\n        return self\n\n    hints.update(deep=deep)\n\n    pattern = args[:-1]\n    rule = args[-1]\n\n    # Special case: map `abs` to `Abs`\n    if rule is abs:\n        from sympy.functions.elementary.complexes import Abs\n        rule = Abs\n\n    # support old design by _eval_rewrite_as_[...] method\n    if isinstance(rule, str):\n        method = \"_eval_rewrite_as_%s\" % rule\n    elif hasattr(rule, \"__name__\"):\n        # rule is class or function\n        clsname = rule.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n    else:\n        # rule is instance\n        clsname = rule.__class__.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n\n    if pattern:\n        if iterable(pattern[0]):\n            pattern = pattern[0]\n        pattern = tuple(p for p in pattern if self.has(p))\n        if not pattern:\n            return self\n    # hereafter, empty pattern is interpreted as all pattern.\n\n    return self._rewrite(pattern, rule, method, **hints)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.NegativeOne",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__index__": "def __index__(self):\n    return self.p",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs, rhs, **options) -> Unequality | BooleanFalse | BooleanTrue: # type: ignore\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        val = is_neq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n\n    return Relational.__new__(cls, lhs, rhs, **options)",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, *args, **options):\n    if len(args) == 0:\n        raise TypeError(\"At least one (expr, cond) pair expected.\")\n    # (Try to) sympify args first\n    newargs = []\n    for ec in args:\n        # ec could be a ExprCondPair or a tuple\n        pair = ExprCondPair(*getattr(ec, 'args', ec))\n        cond = pair.cond\n        if cond is false:\n            continue\n        newargs.append(pair)\n        if cond is true:\n            break\n\n    eval = options.pop('evaluate', global_parameters.evaluate)\n    if eval:\n        r = cls.eval(*newargs)\n        if r is not None:\n            return r\n    elif len(newargs) == 1 and newargs[0].cond == True:\n        return newargs[0].expr\n\n    return Basic.__new__(cls, *newargs, **options)",
    "sympy.sympy.integrals.integrals.integrate": "def integrate(function, *symbols: SymbolLimits, meijerg=None, conds='piecewise',\n                        risch=None, heurisch=None, manual=None, **kwargs):\n    \"\"\"integrate(f, var, ...)\n\n    .. deprecated:: 1.6\n\n       Using ``integrate()`` with :class:`~.Poly` is deprecated. Use\n       :meth:`.Poly.integrate` instead. See :ref:`deprecated-integrate-poly`.\n\n    Explanation\n    ===========\n\n    Compute definite or indefinite integral of one or more variables\n    using Risch-Norman algorithm and table lookup. This procedure is\n    able to handle elementary algebraic and transcendental functions\n    and also a huge class of special functions, including Airy,\n    Bessel, Whittaker and Lambert.\n\n    var can be:\n\n    - a symbol                   -- indefinite integration\n    - a tuple (symbol, a)        -- indefinite integration with result\n                                    given with ``a`` replacing ``symbol``\n    - a tuple (symbol, a, b)     -- definite integration\n\n    Several variables can be specified, in which case the result is\n    multiple integration. (If var is omitted and the integrand is\n    univariate, the indefinite integral in that variable will be performed.)\n\n    Indefinite integrals are returned without terms that are independent\n    of the integration variables. (see examples)\n\n    Definite improper integrals often entail delicate convergence\n    conditions. Pass conds='piecewise', 'separate' or 'none' to have\n    these returned, respectively, as a Piecewise function, as a separate\n    result (i.e. result will be a tuple), or not at all (default is\n    'piecewise').\n\n    **Strategy**\n\n    SymPy uses various approaches to definite integration. One method is to\n    find an antiderivative for the integrand, and then use the fundamental\n    theorem of calculus. Various functions are implemented to integrate\n    polynomial, rational and trigonometric functions, and integrands\n    containing DiracDelta terms.\n\n    SymPy also implements the part of the Risch algorithm, which is a decision\n    procedure for integrating elementary functions, i.e., the algorithm can\n    either find an elementary antiderivative, or prove that one does not\n    exist.  There is also a (very successful, albeit somewhat slow) general\n    implementation of the heuristic Risch algorithm.  This algorithm will\n    eventually be phased out as more of the full Risch algorithm is\n    implemented. See the docstring of Integral._eval_integral() for more\n    details on computing the antiderivative using algebraic methods.\n\n    The option risch=True can be used to use only the (full) Risch algorithm.\n    This is useful if you want to know if an elementary function has an\n    elementary antiderivative.  If the indefinite Integral returned by this\n    function is an instance of NonElementaryIntegral, that means that the\n    Risch algorithm has proven that integral to be non-elementary.  Note that\n    by default, additional methods (such as the Meijer G method outlined\n    below) are tried on these integrals, as they may be expressible in terms\n    of special functions, so if you only care about elementary answers, use\n    risch=True.  Also note that an unevaluated Integral returned by this\n    function is not necessarily a NonElementaryIntegral, even with risch=True,\n    as it may just be an indication that the particular part of the Risch\n    algorithm needed to integrate that function is not yet implemented.\n\n    Another family of strategies comes from re-writing the integrand in\n    terms of so-called Meijer G-functions. Indefinite integrals of a\n    single G-function can always be computed, and the definite integral\n    of a product of two G-functions can be computed from zero to\n    infinity. Various strategies are implemented to rewrite integrands\n    as G-functions, and use this information to compute integrals (see\n    the ``meijerint`` module).\n\n    The option manual=True can be used to use only an algorithm that tries\n    to mimic integration by hand. This algorithm does not handle as many\n    integrands as the other algorithms implemented but may return results in\n    a more familiar form. The ``manualintegrate`` module has functions that\n    return the steps used (see the module docstring for more information).\n\n    In general, the algebraic methods work best for computing\n    antiderivatives of (possibly complicated) combinations of elementary\n    functions. The G-function methods work best for computing definite\n    integrals from zero to infinity of moderately complicated\n    combinations of special functions, or indefinite integrals of very\n    simple combinations of special functions.\n\n    The strategy employed by the integration code is as follows:\n\n    - If computing a definite integral, and both limits are real,\n      and at least one limit is +- oo, try the G-function method of\n      definite integration first.\n\n    - Try to find an antiderivative, using all available methods, ordered\n      by performance (that is try fastest method first, slowest last; in\n      particular polynomial integration is tried first, Meijer\n      G-functions second to last, and heuristic Risch last).\n\n    - If still not successful, try G-functions irrespective of the\n      limits.\n\n    The option meijerg=True, False, None can be used to, respectively:\n    always use G-function methods and no others, never use G-function\n    methods, or use all available methods (in order as described above).\n    It defaults to None.\n\n    Examples\n    ========\n\n    >>> from sympy import integrate, log, exp, oo\n    >>> from sympy.abc import a, x, y\n\n    >>> integrate(x*y, x)\n    x**2*y/2\n\n    >>> integrate(log(x), x)\n    x*log(x) - x\n\n    >>> integrate(log(x), (x, 1, a))\n    a*log(a) - a + 1\n\n    >>> integrate(x)\n    x**2/2\n\n    Terms that are independent of x are dropped by indefinite integration:\n\n    >>> from sympy import sqrt\n    >>> integrate(sqrt(1 + x), (x, 0, x))\n    2*(x + 1)**(3/2)/3 - 2/3\n    >>> integrate(sqrt(1 + x), x)\n    2*(x + 1)**(3/2)/3\n\n    >>> integrate(x*y)\n    Traceback (most recent call last):\n    ...\n    ValueError: specify integration variables to integrate x*y\n\n    Note that ``integrate(x)`` syntax is meant only for convenience\n    in interactive sessions and should be avoided in library code.\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'\n    Piecewise((gamma(a + 1), re(a) > -1),\n        (Integral(x**a*exp(-x), (x, 0, oo)), True))\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')\n    gamma(a + 1)\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')\n    (gamma(a + 1), re(a) > -1)\n\n    See Also\n    ========\n\n    Integral, Integral.doit\n\n    \"\"\"\n    doit_flags = {\n        'deep': False,\n        'meijerg': meijerg,\n        'conds': conds,\n        'risch': risch,\n        'heurisch': heurisch,\n        'manual': manual\n        }\n\n    integral = Integral(function, *symbols, **kwargs)\n\n    if isinstance(integral, Integral):\n        return integral.doit(**doit_flags)\n    else:\n        new_args = [a.doit(**doit_flags) if isinstance(a, Integral) else a\n            for a in integral.args]\n        return integral.func(*new_args)",
    "sympy.sympy.integrals.trigonometry._sin_pow_integrate": "def _sin_pow_integrate(n, x):\n    if n > 0:\n        if n == 1:\n            #Recursion break\n            return -cos(x)\n\n        # n > 0\n        #  /                                                 /\n        # |                                                 |\n        # |    n           -1               n-1     n - 1   |     n-2\n        # | sin (x) dx =  ______ cos (x) sin (x) + _______  |  sin (x) dx\n        # |                                                 |\n        # |                 n                         n     |\n        #/                                                 /\n        #\n        #\n\n        return (Rational(-1, n) * cos(x) * sin(x)**(n - 1) +\n                Rational(n - 1, n) * _sin_pow_integrate(n - 2, x))\n\n    if n < 0:\n        if n == -1:\n            ##Make sure this does not come back here again.\n            ##Recursion breaks here or at n==0.\n            return trigintegrate(1/sin(x), x)\n\n        # n < 0\n        #  /                                                 /\n        # |                                                 |\n        # |    n            1               n+1     n + 2   |     n+2\n        # | sin (x) dx = _______ cos (x) sin (x) + _______  |  sin (x) dx\n        # |                                                 |\n        # |               n + 1                     n + 1   |\n        #/                                                 /\n        #\n\n        return (Rational(1, n + 1) * cos(x) * sin(x)**(n + 1) +\n                Rational(n + 2, n + 1) * _sin_pow_integrate(n + 2, x))\n\n    else:\n        #n == 0\n        #Recursion break.\n        return x",
    "sympy.sympy.integrals.trigonometry._cos_pow_integrate": "def _cos_pow_integrate(n, x):\n    if n > 0:\n        if n == 1:\n            #Recursion break.\n            return sin(x)\n\n        # n > 0\n        #  /                                                 /\n        # |                                                 |\n        # |    n            1               n-1     n - 1   |     n-2\n        # | sin (x) dx =  ______ sin (x) cos (x) + _______  |  cos (x) dx\n        # |                                                 |\n        # |                 n                         n     |\n        #/                                                 /\n        #\n\n        return (Rational(1, n) * sin(x) * cos(x)**(n - 1) +\n                Rational(n - 1, n) * _cos_pow_integrate(n - 2, x))\n\n    if n < 0:\n        if n == -1:\n            ##Recursion break\n            return trigintegrate(1/cos(x), x)\n\n        # n < 0\n        #  /                                                 /\n        # |                                                 |\n        # |    n            -1              n+1     n + 2   |     n+2\n        # | cos (x) dx = _______ sin (x) cos (x) + _______  |  cos (x) dx\n        # |                                                 |\n        # |               n + 1                     n + 1   |\n        #/                                                 /\n        #\n\n        return (Rational(-1, n + 1) * sin(x) * cos(x)**(n + 1) +\n                Rational(n + 2, n + 1) * _cos_pow_integrate(n + 2, x))\n    else:\n        # n == 0\n        #Recursion Break.\n        return x",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False"
}