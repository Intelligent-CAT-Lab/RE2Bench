{
    "sympy.sympy.concrete.expr_with_limits.function": "@property\ndef function(self):\n    \"\"\"Return the function applied across limits.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x\n    >>> Integral(x**2, (x,)).function\n    x**2\n\n    See Also\n    ========\n\n    limits, variables, free_symbols\n    \"\"\"\n    return self._args[0]",
    "sympy.sympy.concrete.expr_with_limits.limits": "@property\ndef limits(self):\n    \"\"\"Return the limits of expression.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, i\n    >>> Integral(x**i, (i, 1, 3)).limits\n    ((i, 1, 3),)\n\n    See Also\n    ========\n\n    function, variables, free_symbols\n    \"\"\"\n    return self._args[1:]",
    "sympy.sympy.concrete.expr_with_limits.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols in the object, excluding those\n    that take on a specific value (i.e. the dummy symbols).\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.abc import x, y\n    >>> Sum(x, (x, y, 1)).free_symbols\n    {y}\n    \"\"\"\n    # don't test for any special values -- nominal free symbols\n    # should be returned, e.g. don't return set() if the\n    # function is zero -- treat it like an unevaluated expression.\n    function, limits = self.function, self.limits\n    # mask off non-symbol integration variables that have\n    # more than themself as a free symbol\n    reps = {i[0]: i[0] if i[0].free_symbols == {i[0]} else Dummy()\n        for i in self.limits}\n    function = function.xreplace(reps)\n    isyms = function.free_symbols\n    for xab in limits:\n        v = reps[xab[0]]\n        if len(xab) == 1:\n            isyms.add(v)\n            continue\n        # take out the target symbol\n        if v in isyms:\n            isyms.remove(v)\n        # add in the new symbols\n        for i in xab[1:]:\n            isyms.update(i.free_symbols)\n    reps = {v: k for k, v in reps.items()}\n    return {reps.get(_, _) for _ in isyms}",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.containers.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    "sympy.sympy.core.containers.__len__": "def __len__(self):\n    return len(self.args)",
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.function.free_symbols": "@property\ndef free_symbols(self):\n    ret = self.expr.free_symbols\n    # Add symbolic counts to free_symbols\n    for _, count in self.variable_count:\n        ret.update(count.free_symbols)\n    return ret",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity or other == float('-inf')",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.symbol.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    return {self}",
    "sympy.sympy.matrices.matrixbase.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Returns the free symbols within the matrix.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy import Matrix\n    >>> Matrix([[x], [1]]).free_symbols\n    {x}\n    \"\"\"\n    return self._eval_free_symbols()",
    "sympy.sympy.physics.units.quantities.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"Return free symbols from quantity.\"\"\"\n    return set()",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.polytools.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    Free symbols of a polynomial expression.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y, z\n\n    >>> Poly(x**2 + 1).free_symbols\n    {x}\n    >>> Poly(x**2 + y).free_symbols\n    {x, y}\n    >>> Poly(x**2 + y, x).free_symbols\n    {x, y}\n    >>> Poly(x**2 + y, x, z).free_symbols\n    {x, y}\n\n    \"\"\"\n    symbols = set()\n    gens = self.gens\n    for i in range(len(gens)):\n        for monom in self.monoms():\n            if monom[i]:\n                symbols |= gens[i].free_symbols\n                break\n\n    return symbols | self.free_symbols_in_domain",
    "sympy.sympy.polys.polytools.is_zero": "@property\ndef is_zero(f):\n    \"\"\"\n    Returns ``True`` if ``f`` is a zero polynomial.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x\n\n    >>> Poly(0, x).is_zero\n    True\n    >>> Poly(1, x).is_zero\n    False\n\n    \"\"\"\n    return f.rep.is_zero",
    "sympy.sympy.series.order.free_symbols": "@property\ndef free_symbols(self):\n    return self.expr.free_symbols | set(self.variables)",
    "sympy.sympy.series.series_class.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols in the object, excluding those\n    that take on a specific value (i.e. the dummy symbols).\n    \"\"\"\n    return ({j for i in self.args for j in i.free_symbols}\n            .difference(self.variables))",
    "sympy.sympy.tensor.indexed.free_symbols": "@property\ndef free_symbols(self):\n    base_free_symbols = self.base.free_symbols\n    indices_free_symbols = {\n        fs for i in self.indices for fs in i.free_symbols}\n    if base_free_symbols:\n        return {self} | base_free_symbols | indices_free_symbols\n    else:\n        return indices_free_symbols",
    "sympy.sympy.vector.scalar.free_symbols": "@property\ndef free_symbols(self):\n    return {self}"
}