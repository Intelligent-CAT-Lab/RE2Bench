{
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str,\n            exclude: Iterable[Expr | complex] = (),\n            properties: Iterable[Callable[[Expr], bool | None]] = (),\n            **assumptions: bool | None,\n        ) -> Self:\n    exclude = tuple([sympify(x) for x in exclude])\n    properties = tuple(properties)\n    cls._sanitize(assumptions, cls)\n    return Wild.__xnew__(cls, name, exclude, properties, **assumptions)",
    "sympy.sympy.core.symbol.symbols": "def symbols(names, *, cls: Any = Symbol, **args) -> Any:\n    r\"\"\"\n    Transform strings into instances of :class:`Symbol` class.\n\n    :func:`symbols` function returns a sequence of symbols with names taken\n    from ``names`` argument, which can be a comma or whitespace delimited\n    string, or a sequence of strings::\n\n        >>> from sympy import symbols, Function\n\n        >>> x, y, z = symbols('x,y,z')\n        >>> a, b, c = symbols('a b c')\n\n    The type of output is dependent on the properties of input arguments::\n\n        >>> symbols('x')\n        x\n        >>> symbols('x,')\n        (x,)\n        >>> symbols('x,y')\n        (x, y)\n        >>> symbols(('a', 'b', 'c'))\n        (a, b, c)\n        >>> symbols(['a', 'b', 'c'])\n        [a, b, c]\n        >>> symbols({'a', 'b', 'c'})\n        {a, b, c}\n\n    If an iterable container is needed for a single symbol, set the ``seq``\n    argument to ``True`` or terminate the symbol name with a comma::\n\n        >>> symbols('x', seq=True)\n        (x,)\n\n    To reduce typing, range syntax is supported to create indexed symbols.\n    Ranges are indicated by a colon and the type of range is determined by\n    the character to the right of the colon. If the character is a digit\n    then all contiguous digits to the left are taken as the nonnegative\n    starting value (or 0 if there is no digit left of the colon) and all\n    contiguous digits to the right are taken as 1 greater than the ending\n    value::\n\n        >>> symbols('x:10')\n        (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n\n        >>> symbols('x5:10')\n        (x5, x6, x7, x8, x9)\n        >>> symbols('x5(:2)')\n        (x50, x51)\n\n        >>> symbols('x5:10,y:5')\n        (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)\n\n        >>> symbols(('x5:10', 'y:5'))\n        ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))\n\n    If the character to the right of the colon is a letter, then the single\n    letter to the left (or 'a' if there is none) is taken as the start\n    and all characters in the lexicographic range *through* the letter to\n    the right are used as the range::\n\n        >>> symbols('x:z')\n        (x, y, z)\n        >>> symbols('x:c')  # null range\n        ()\n        >>> symbols('x(:c)')\n        (xa, xb, xc)\n\n        >>> symbols(':c')\n        (a, b, c)\n\n        >>> symbols('a:d, x:z')\n        (a, b, c, d, x, y, z)\n\n        >>> symbols(('a:d', 'x:z'))\n        ((a, b, c, d), (x, y, z))\n\n    Multiple ranges are supported; contiguous numerical ranges should be\n    separated by parentheses to disambiguate the ending number of one\n    range from the starting number of the next::\n\n        >>> symbols('x:2(1:3)')\n        (x01, x02, x11, x12)\n        >>> symbols(':3:2')  # parsing is from left to right\n        (00, 01, 10, 11, 20, 21)\n\n    Only one pair of parentheses surrounding ranges are removed, so to\n    include parentheses around ranges, double them. And to include spaces,\n    commas, or colons, escape them with a backslash::\n\n        >>> symbols('x((a:b))')\n        (x(a), x(b))\n        >>> symbols(r'x(:1\\,:2)')  # or r'x((:1)\\,(:2))'\n        (x(0,0), x(0,1))\n\n    All newly created symbols have assumptions set according to ``args``::\n\n        >>> a = symbols('a', integer=True)\n        >>> a.is_integer\n        True\n\n        >>> x, y, z = symbols('x,y,z', real=True)\n        >>> x.is_real and y.is_real and z.is_real\n        True\n\n    Despite its name, :func:`symbols` can create symbol-like objects like\n    instances of Function or Wild classes. To achieve this, set ``cls``\n    keyword argument to the desired type::\n\n        >>> symbols('f,g,h', cls=Function)\n        (f, g, h)\n\n        >>> type(_[0])\n        <class 'sympy.core.function.UndefinedFunction'>\n\n    \"\"\"\n    result = []\n\n    if isinstance(names, str):\n        marker = 0\n        splitters = r'\\,', r'\\:', r'\\ '\n        literals: list[tuple[str, str]] = []\n        for splitter in splitters:\n            if splitter in names:\n                while chr(marker) in names:\n                    marker += 1\n                lit_char = chr(marker)\n                marker += 1\n                names = names.replace(splitter, lit_char)\n                literals.append((lit_char, splitter[1:]))\n        def literal(s):\n            if literals:\n                for c, l in literals:\n                    s = s.replace(c, l)\n            return s\n\n        names = names.strip()\n        as_seq = names.endswith(',')\n        if as_seq:\n            names = names[:-1].rstrip()\n        if not names:\n            raise ValueError('no symbols given')\n\n        # split on commas\n        names = [n.strip() for n in names.split(',')]\n        if not all(n for n in names):\n            raise ValueError('missing symbol between commas')\n        # split on spaces\n        for i in range(len(names) - 1, -1, -1):\n            names[i: i + 1] = names[i].split()\n\n        seq = args.pop('seq', as_seq)\n\n        for name in names:\n            if not name:\n                raise ValueError('missing symbol')\n\n            if ':' not in name:\n                symbol = cls(literal(name), **args)\n                result.append(symbol)\n                continue\n\n            split: list[str] = _range.split(name)\n            split_list: list[list[str]] = []\n            # remove 1 layer of bounding parentheses around ranges\n            for i in range(len(split) - 1):\n                if i and ':' in split[i] and split[i] != ':' and \\\n                        split[i - 1].endswith('(') and \\\n                        split[i + 1].startswith(')'):\n                    split[i - 1] = split[i - 1][:-1]\n                    split[i + 1] = split[i + 1][1:]\n            for s in split:\n                if ':' in s:\n                    if s.endswith(':'):\n                        raise ValueError('missing end range')\n                    a, b = s.split(':')\n                    if b[-1] in string.digits:\n                        a_i = 0 if not a else int(a)\n                        b_i = int(b)\n                        split_list.append([str(c) for c in range(a_i, b_i)])\n                    else:\n                        a = a or 'a'\n                        split_list.append([string.ascii_letters[c] for c in range(\n                            string.ascii_letters.index(a),\n                            string.ascii_letters.index(b) + 1)])  # inclusive\n                    if not split_list[-1]:\n                        break\n                else:\n                    split_list.append([s])\n            else:\n                seq = True\n                if len(split_list) == 1:\n                    names = split_list[0]\n                else:\n                    names = [''.join(s) for s in product(*split_list)]\n                if literals:\n                    result.extend([cls(literal(s), **args) for s in names])\n                else:\n                    result.extend([cls(s, **args) for s in names])\n\n        if not seq and len(result) <= 1:\n            if not result:\n                return ()\n            return result[0]\n\n        return tuple(result)\n    else:\n        for name in names:\n            result.append(symbols(name, cls=cls, **args))\n\n        return type(names)(result)",
    "sympy.sympy.core.symbol.literal": "def literal(s):\n    if literals:\n        for c, l in literals:\n            s = s.replace(c, l)\n    return s",
    "sympy.sympy.core.symbol.<listcomp>": "result.extend([cls(s, **args) for s in names])\n\n",
    "sympy.sympy.core.symbol.<genexpr>": "if not all(n for n in names):\n    raise ValueError('missing symbol between commas')\n# split on spaces\n",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.physics.vector.frame.__init__": "def __init__(self, name, indices=None, latexs=None, variables=None):\n    \"\"\"ReferenceFrame initialization method.\n\n    A ReferenceFrame has a set of orthonormal basis vectors, along with\n    orientations relative to other ReferenceFrames and angular velocities\n    relative to other ReferenceFrames.\n\n    Parameters\n    ==========\n\n    indices : tuple of str\n        Enables the reference frame's basis unit vectors to be accessed by\n        Python's square bracket indexing notation using the provided three\n        indice strings and alters the printing of the unit vectors to\n        reflect this choice.\n    latexs : tuple of str\n        Alters the LaTeX printing of the reference frame's basis unit\n        vectors to the provided three valid LaTeX strings.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame, vlatex\n    >>> N = ReferenceFrame('N')\n    >>> N.x\n    N.x\n    >>> O = ReferenceFrame('O', indices=('1', '2', '3'))\n    >>> O.x\n    O['1']\n    >>> O['1']\n    O['1']\n    >>> P = ReferenceFrame('P', latexs=('A1', 'A2', 'A3'))\n    >>> vlatex(P.x)\n    'A1'\n\n    ``symbols()`` can be used to create multiple Reference Frames in one\n    step, for example:\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy import symbols\n    >>> A, B, C = symbols('A B C', cls=ReferenceFrame)\n    >>> D, E = symbols('D E', cls=ReferenceFrame, indices=('1', '2', '3'))\n    >>> A[0]\n    A_x\n    >>> D.x\n    D['1']\n    >>> E.y\n    E['2']\n    >>> type(A) == type(D)\n    True\n\n    Unit dyads for the ReferenceFrame can be accessed through the attributes ``xx``, ``xy``, etc. For example:\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> N = ReferenceFrame('N')\n    >>> N.yz\n    (N.y|N.z)\n    >>> N.zx\n    (N.z|N.x)\n    >>> P = ReferenceFrame('P', indices=['1', '2', '3'])\n    >>> P.xx\n    (P['1']|P['1'])\n    >>> P.zy\n    (P['3']|P['2'])\n\n    Unit dyadic is also accessible via the ``u`` attribute:\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> N = ReferenceFrame('N')\n    >>> N.u\n    (N.x|N.x) + (N.y|N.y) + (N.z|N.z)\n    >>> P = ReferenceFrame('P', indices=['1', '2', '3'])\n    >>> P.u\n    (P['1']|P['1']) + (P['2']|P['2']) + (P['3']|P['3'])\n\n    \"\"\"\n\n    if not isinstance(name, str):\n        raise TypeError('Need to supply a valid name')\n    # The if statements below are for custom printing of basis-vectors for\n    # each frame.\n    # First case, when custom indices are supplied\n    if indices is not None:\n        if not isinstance(indices, (tuple, list)):\n            raise TypeError('Supply the indices as a list')\n        if len(indices) != 3:\n            raise ValueError('Supply 3 indices')\n        for i in indices:\n            if not isinstance(i, str):\n                raise TypeError('Indices must be strings')\n        self.str_vecs = [(name + '[\\'' + indices[0] + '\\']'),\n                         (name + '[\\'' + indices[1] + '\\']'),\n                         (name + '[\\'' + indices[2] + '\\']')]\n        self.pretty_vecs = [(name.lower() + \"_\" + indices[0]),\n                            (name.lower() + \"_\" + indices[1]),\n                            (name.lower() + \"_\" + indices[2])]\n        self.latex_vecs = [(r\"\\mathbf{\\hat{%s}_{%s}}\" % (name.lower(),\n                                                         indices[0])),\n                           (r\"\\mathbf{\\hat{%s}_{%s}}\" % (name.lower(),\n                                                         indices[1])),\n                           (r\"\\mathbf{\\hat{%s}_{%s}}\" % (name.lower(),\n                                                         indices[2]))]\n        self.indices = indices\n    # Second case, when no custom indices are supplied\n    else:\n        self.str_vecs = [(name + '.x'), (name + '.y'), (name + '.z')]\n        self.pretty_vecs = [name.lower() + \"_x\",\n                            name.lower() + \"_y\",\n                            name.lower() + \"_z\"]\n        self.latex_vecs = [(r\"\\mathbf{\\hat{%s}_x}\" % name.lower()),\n                           (r\"\\mathbf{\\hat{%s}_y}\" % name.lower()),\n                           (r\"\\mathbf{\\hat{%s}_z}\" % name.lower())]\n        self.indices = ['x', 'y', 'z']\n    # Different step, for custom latex basis vectors\n    if latexs is not None:\n        if not isinstance(latexs, (tuple, list)):\n            raise TypeError('Supply the indices as a list')\n        if len(latexs) != 3:\n            raise ValueError('Supply 3 indices')\n        for i in latexs:\n            if not isinstance(i, str):\n                raise TypeError('Latex entries must be strings')\n        self.latex_vecs = latexs\n    self.name = name\n    self._var_dict = {}\n    # The _dcm_dict dictionary will only store the dcms of adjacent\n    # parent-child relationships. The _dcm_cache dictionary will store\n    # calculated dcm along with all content of _dcm_dict for faster\n    # retrieval of dcms.\n    self._dcm_dict = {}\n    self._dcm_cache = {}\n    self._ang_vel_dict = {}\n    self._ang_acc_dict = {}\n    self._dlist = [self._dcm_dict, self._ang_vel_dict, self._ang_acc_dict]\n    self._cur = 0\n    self._x = Vector([(Matrix([1, 0, 0]), self)])\n    self._y = Vector([(Matrix([0, 1, 0]), self)])\n    self._z = Vector([(Matrix([0, 0, 1]), self)])\n    # Associate coordinate symbols wrt this frame\n    if variables is not None:\n        if not isinstance(variables, (tuple, list)):\n            raise TypeError('Supply the variable names as a list/tuple')\n        if len(variables) != 3:\n            raise ValueError('Supply 3 variable names')\n        for i in variables:\n            if not isinstance(i, str):\n                raise TypeError('Variable names must be strings')\n    else:\n        variables = [name + '_x', name + '_y', name + '_z']\n    self.varlist = (CoordinateSym(variables[0], self, 0),\n                    CoordinateSym(variables[1], self, 1),\n                    CoordinateSym(variables[2], self, 2))\n    ReferenceFrame._count += 1\n    self.index = ReferenceFrame._count",
    "sympy.sympy.tensor.indexed.__new__": "def __new__(cls, label, range=None, **kw_args):\n\n    if isinstance(label, str):\n        label = Symbol(label, integer=True)\n    label, range = list(map(sympify, (label, range)))\n\n    if label.is_Number:\n        if not label.is_integer:\n            raise TypeError(\"Index is not an integer number.\")\n        return label\n\n    if not label.is_integer:\n        raise TypeError(\"Idx object requires an integer label.\")\n\n    elif is_sequence(range):\n        if len(range) != 2:\n            raise ValueError(filldedent(f\"\"\"\n                Idx range tuple must have length 2, but got {len(range)}\"\"\"))\n        for bound in range:\n            if (bound.is_integer is False and bound is not S.Infinity\n                    and bound is not S.NegativeInfinity):\n                raise TypeError(\"Idx object requires integer bounds.\")\n        args = label, Tuple(*range)\n    elif isinstance(range, Expr):\n        if range is not S.Infinity and fuzzy_not(range.is_integer):\n            raise TypeError(\"Idx object requires an integer dimension.\")\n        args = label, Tuple(0, range - 1)\n    elif range:\n        raise TypeError(filldedent(\"\"\"\n            The range must be an ordered iterable or\n            integer SymPy expression.\"\"\"))\n    else:\n        args = label,\n\n    obj = Expr.__new__(cls, *args, **kw_args)\n    obj._assumptions[\"finite\"] = True\n    obj._assumptions[\"real\"] = True\n    return obj",
    "sympy.sympy.tensor.tensor.__new__": "def __new__(cls, name, tensor_index_type, is_up=True, ignore_updown=False):\n    if isinstance(name, str):\n        name_symbol = Symbol(name)\n    elif isinstance(name, Symbol):\n        name_symbol = name\n    elif name is True:\n        name = \"_i{}\".format(len(tensor_index_type._autogenerated))\n        name_symbol = Symbol(name)\n        tensor_index_type._autogenerated.append(name_symbol)\n    else:\n        raise ValueError(\"invalid name\")\n\n    is_up = sympify(is_up)\n    ignore_updown = sympify(ignore_updown)\n    return Basic.__new__(cls, name_symbol, tensor_index_type, is_up, ignore_updown)",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}