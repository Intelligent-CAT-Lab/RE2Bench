{
    "sympy.sympy.core.basic.rewrite": "def rewrite(self, *args, deep=True, **hints):\n    \"\"\"\n    Rewrite *self* using a defined rule.\n\n    Rewriting transforms an expression to another, which is mathematically\n    equivalent but structurally different. For example you can rewrite\n    trigonometric functions as complex exponentials or combinatorial\n    functions as gamma function.\n\n    This method takes a *pattern* and a *rule* as positional arguments.\n    *pattern* is optional parameter which defines the types of expressions\n    that will be transformed. If it is not passed, all possible expressions\n    will be rewritten. *rule* defines how the expression will be rewritten.\n\n    Parameters\n    ==========\n\n    args : Expr\n        A *rule*, or *pattern* and *rule*.\n        - *pattern* is a type or an iterable of types.\n        - *rule* can be any object.\n\n    deep : bool, optional\n        If ``True``, subexpressions are recursively transformed. Default is\n        ``True``.\n\n    Examples\n    ========\n\n    If *pattern* is unspecified, all possible expressions are transformed.\n\n    >>> from sympy import cos, sin, exp, I\n    >>> from sympy.abc import x\n    >>> expr = cos(x) + I*sin(x)\n    >>> expr.rewrite(exp)\n    exp(I*x)\n\n    Pattern can be a type or an iterable of types.\n\n    >>> expr.rewrite(sin, exp)\n    exp(I*x)/2 + cos(x) - exp(-I*x)/2\n    >>> expr.rewrite([cos,], exp)\n    exp(I*x)/2 + I*sin(x) + exp(-I*x)/2\n    >>> expr.rewrite([cos, sin], exp)\n    exp(I*x)\n\n    Rewriting behavior can be implemented by defining ``_eval_rewrite()``\n    method.\n\n    >>> from sympy import Expr, sqrt, pi\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite(self, rule, args, **hints):\n    ...         x, = args\n    ...         if rule == cos:\n    ...             return cos(pi/2 - x, evaluate=False)\n    ...         if rule == sqrt:\n    ...             return sqrt(1 - cos(x)**2)\n    >>> MySin(MySin(x)).rewrite(cos)\n    cos(-cos(-x + pi/2) + pi/2)\n    >>> MySin(x).rewrite(sqrt)\n    sqrt(1 - cos(x)**2)\n\n    Defining ``_eval_rewrite_as_[...]()`` method is supported for backwards\n    compatibility reason. This may be removed in the future and using it is\n    discouraged.\n\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite_as_cos(self, *args, **hints):\n    ...         x, = args\n    ...         return cos(pi/2 - x, evaluate=False)\n    >>> MySin(x).rewrite(cos)\n    cos(-x + pi/2)\n\n    \"\"\"\n    if not args:\n        return self\n\n    hints.update(deep=deep)\n\n    pattern = args[:-1]\n    rule = args[-1]\n\n    # Special case: map `abs` to `Abs`\n    if rule is abs:\n        from sympy.functions.elementary.complexes import Abs\n        rule = Abs\n\n    # support old design by _eval_rewrite_as_[...] method\n    if isinstance(rule, str):\n        method = \"_eval_rewrite_as_%s\" % rule\n    elif hasattr(rule, \"__name__\"):\n        # rule is class or function\n        clsname = rule.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n    else:\n        # rule is instance\n        clsname = rule.__class__.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n\n    if pattern:\n        if iterable(pattern[0]):\n            pattern = pattern[0]\n        pattern = tuple(p for p in pattern if self.has(p))\n        if not pattern:\n            return self\n    # hereafter, empty pattern is interpreted as all pattern.\n\n    return self._rewrite(pattern, rule, method, **hints)",
    "sympy.sympy.core.basic.as_Basic": "def as_Basic(expr):\n    \"\"\"Return expr as a Basic instance using strict sympify\n    or raise a TypeError; this is just a wrapper to _sympify,\n    raising a TypeError instead of a SympifyError.\"\"\"\n    try:\n        return _sympify(expr)\n    except SympifyError:\n        raise TypeError(\n            'Argument must be a Basic object, not `%s`' % func_name(\n            expr))",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.functions.elementary.piecewise.piecewise_fold": "def piecewise_fold(expr, evaluate=True):\n    \"\"\"\n    Takes an expression containing a piecewise function and returns the\n    expression in piecewise form. In addition, any ITE conditions are\n    rewritten in negation normal form and simplified.\n\n    The final Piecewise is evaluated (default) but if the raw form\n    is desired, send ``evaluate=False``; if trivial evaluation is\n    desired, send ``evaluate=None`` and duplicate conditions and\n    processing of True and False will be handled.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, piecewise_fold, S\n    >>> from sympy.abc import x\n    >>> p = Piecewise((x, x < 1), (1, S(1) <= x))\n    >>> piecewise_fold(x*p)\n    Piecewise((x**2, x < 1), (x, True))\n\n    See Also\n    ========\n\n    Piecewise\n    piecewise_exclusive\n    \"\"\"\n    if not isinstance(expr, Basic) or not expr.has(Piecewise):\n        return expr\n\n    new_args = []\n    if isinstance(expr, (ExprCondPair, Piecewise)):\n        for e, c in expr.args:\n            if not isinstance(e, Piecewise):\n                e = piecewise_fold(e)\n            # we don't keep Piecewise in condition because\n            # it has to be checked to see that it's complete\n            # and we convert it to ITE at that time\n            assert not c.has(Piecewise)  # pragma: no cover\n            if isinstance(c, ITE):\n                c = c.to_nnf()\n                c = simplify_logic(c, form='cnf')\n            if isinstance(e, Piecewise):\n                new_args.extend([(piecewise_fold(ei), And(ci, c))\n                    for ei, ci in e.args])\n            else:\n                new_args.append((e, c))\n    else:\n        # Given\n        #     P1 = Piecewise((e11, c1), (e12, c2), A)\n        #     P2 = Piecewise((e21, c1), (e22, c2), B)\n        #     ...\n        # the folding of f(P1, P2) is trivially\n        # Piecewise(\n        #   (f(e11, e21), c1),\n        #   (f(e12, e22), c2),\n        #   (f(Piecewise(A), Piecewise(B)), True))\n        # Certain objects end up rewriting themselves as thus, so\n        # we do that grouping before the more generic folding.\n        # The following applies this idea when f = Add or f = Mul\n        # (and the expression is commutative).\n        if expr.is_Add or expr.is_Mul and expr.is_commutative:\n            p, args = sift(expr.args, lambda x: x.is_Piecewise, binary=True)\n            pc = sift(p, lambda x: tuple([c for e,c in x.args]))\n            for c in list(ordered(pc)):\n                if len(pc[c]) > 1:\n                    pargs = [list(i.args) for i in pc[c]]\n                    # the first one is the same; there may be more\n                    com = common_prefix(*[\n                        [i.cond for i in j] for j in pargs])\n                    n = len(com)\n                    collected = []\n                    for i in range(n):\n                        collected.append((\n                            expr.func(*[ai[i].expr for ai in pargs]),\n                            com[i]))\n                    remains = []\n                    for a in pargs:\n                        if n == len(a):  # no more args\n                            continue\n                        if a[n].cond == True:  # no longer Piecewise\n                            remains.append(a[n].expr)\n                        else:  # restore the remaining Piecewise\n                            remains.append(\n                                Piecewise(*a[n:], evaluate=False))\n                    if remains:\n                        collected.append((expr.func(*remains), True))\n                    args.append(Piecewise(*collected, evaluate=False))\n                    continue\n                args.extend(pc[c])\n        else:\n            args = expr.args\n        # fold\n        folded = list(map(piecewise_fold, args))\n        for ec in product(*[\n                (i.args if isinstance(i, Piecewise) else\n                 [(i, true)]) for i in folded]):\n            e, c = zip(*ec)\n            new_args.append((expr.func(*e), And(*c)))\n\n    if evaluate is None:\n        # don't return duplicate conditions, otherwise don't evaluate\n        new_args = list(reversed([(e, c) for c, e in {\n            c: e for e, c in reversed(new_args)}.items()]))\n    rv = Piecewise(*new_args, evaluate=evaluate)\n    if evaluate is None and len(rv.args) == 1 and rv.args[0].cond == True:\n        return rv.args[0].expr\n    if any(s.expr.has(Piecewise) for p in rv.atoms(Piecewise) for s in p.args):\n        return piecewise_fold(rv)\n    return rv",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.utilities.misc.filldedent": "def filldedent(s, w=70, **kwargs):\n    \"\"\"\n    Strips leading and trailing empty lines from a copy of ``s``, then dedents,\n    fills and returns it.\n\n    Empty line stripping serves to deal with docstrings like this one that\n    start with a newline after the initial triple quote, inserting an empty\n    line at the beginning of the string.\n\n    Additional keyword arguments will be passed to ``textwrap.fill()``.\n\n    See Also\n    ========\n    strlines, rawlines\n\n    \"\"\"\n    return '\\n' + fill(dedent(str(s)).strip('\\n'), width=w, **kwargs)",
    "sympy.sympy.utilities.misc.func_name": "def func_name(x, short=False):\n    \"\"\"Return function name of `x` (if defined) else the `type(x)`.\n    If short is True and there is a shorter alias for the result,\n    return the alias.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import func_name\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x\n    >>> func_name(Matrix.eye(3))\n    'MutableDenseMatrix'\n    >>> func_name(x < 1)\n    'StrictLessThan'\n    >>> func_name(x < 1, short=True)\n    'Lt'\n    \"\"\"\n    alias = {\n    'GreaterThan': 'Ge',\n    'StrictGreaterThan': 'Gt',\n    'LessThan': 'Le',\n    'StrictLessThan': 'Lt',\n    'Equality': 'Eq',\n    'Unequality': 'Ne',\n    }\n    typ = type(x)\n    if str(typ).startswith(\"<type '\"):\n        typ = str(typ).split(\"'\")[1].split(\"'\")[0]\n    elif str(typ).startswith(\"<class '\"):\n        typ = str(typ).split(\"'\")[1].split(\"'\")[0]\n    rv = getattr(getattr(x, 'func', x), '__name__', typ)\n    if '.' in rv:\n        rv = rv.split('.')[-1]\n    if short:\n        rv = alias.get(rv, rv)\n    return rv"
}