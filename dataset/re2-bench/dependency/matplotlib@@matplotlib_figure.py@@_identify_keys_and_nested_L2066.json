{
    "matplotlib.lib.matplotlib.cbook.__init__": "def __init__(self):\n    self._od = collections.OrderedDict()",
    "matplotlib.lib.matplotlib.cbook.__iter__": "def __iter__(self):\n    return iter(self._od)",
    "matplotlib.lib.matplotlib.cbook.__len__": "def __len__(self):\n    return len(self._od)",
    "matplotlib.lib.matplotlib.cbook.add": "def add(self, key):\n    self._od.pop(key, None)\n    self._od[key] = None",
    "matplotlib.lib.matplotlib.cbook.is_scalar_or_string": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)",
    "matplotlib.lib.matplotlib.figure._make_array": "def _make_array(inp):\n    \"\"\"\n    Convert input into 2D array\n\n    We need to have this internal function rather than\n    ``np.asarray(..., dtype=object)`` so that a list of lists\n    of lists does not get converted to an array of dimension > 2.\n\n    Returns\n    -------\n    2D object array\n    \"\"\"\n    r0, *rest = inp\n    if isinstance(r0, str):\n        raise ValueError('List mosaic specification must be 2D')\n    for j, r in enumerate(rest, start=1):\n        if isinstance(r, str):\n            raise ValueError('List mosaic specification must be 2D')\n        if len(r0) != len(r):\n            raise ValueError(\n                \"All of the rows must be the same length, however \"\n                f\"the first row ({r0!r}) has length {len(r0)} \"\n                f\"and row {j} ({r!r}) has length {len(r)}.\"\n            )\n    out = np.zeros((len(inp), len(r0)), dtype=object)\n    for j, r in enumerate(inp):\n        for k, v in enumerate(r):\n            out[j, k] = v\n    return out"
}