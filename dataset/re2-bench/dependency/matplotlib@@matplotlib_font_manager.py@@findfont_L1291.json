{
    "matplotlib.lib.matplotlib.cbook.to_exception": "def to_exception(self):\n    exc = self._cls(*self._args)\n    for note in self._notes:\n        exc.add_note(note)\n    return exc",
    "matplotlib.lib.matplotlib.font_manager.<genexpr>": "rc_params = tuple(tuple(mpl.rcParams[key]) for key in [\n    \"font.serif\", \"font.sans-serif\", \"font.cursive\", \"font.fantasy\",\n    \"font.monospace\"])\n",
    "matplotlib.lib.matplotlib.font_manager._findfont_cached": "@lru_cache(1024)\ndef _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                     rebuild_if_missing, rc_params):\n\n    prop = FontProperties._from_any(prop)\n\n    fname = prop.get_file()\n    if fname is not None:\n        return fname\n\n    if fontext == 'afm':\n        fontlist = self.afmlist\n    else:\n        fontlist = self.ttflist\n\n    best_score = 1e64\n    best_font = None\n\n    _log.debug('findfont: Matching %s.', prop)\n    for font in fontlist:\n        if (directory is not None and\n                Path(directory) not in Path(font.fname).parents):\n            continue\n        # Matching family should have top priority, so multiply it by 10.\n        score = (self.score_family(prop.get_family(), font.name) * 10\n                 + self.score_style(prop.get_style(), font.style)\n                 + self.score_variant(prop.get_variant(), font.variant)\n                 + self.score_weight(prop.get_weight(), font.weight)\n                 + self.score_stretch(prop.get_stretch(), font.stretch)\n                 + self.score_size(prop.get_size(), font.size))\n        _log.debug('findfont: score(%s) = %s', font, score)\n        if score < best_score:\n            best_score = score\n            best_font = font\n        if score == 0:\n            break\n    if best_font is not None and (_normalize_weight(prop.get_weight()) !=\n                                  _normalize_weight(best_font.weight)):\n        _log.warning('findfont: Failed to find font weight %s, now using %s.',\n                     prop.get_weight(), best_font.weight)\n\n    if best_font is None or best_score >= 10.0:\n        if fallback_to_default:\n            _log.warning(\n                'findfont: Font family %s not found. Falling back to %s.',\n                prop.get_family(), self.defaultFamily[fontext])\n            for family in map(str.lower, prop.get_family()):\n                if family in font_family_aliases:\n                    _log.warning(\n                        \"findfont: Generic family %r not found because \"\n                        \"none of the following families were found: %s\",\n                        family, \", \".join(self._expand_aliases(family)))\n            default_prop = prop.copy()\n            default_prop.set_family(self.defaultFamily[fontext])\n            return self.findfont(default_prop, fontext, directory,\n                                 fallback_to_default=False)\n        else:\n            # This return instead of raise is intentional, as we wish to\n            # cache that it was not found, which will not occur if it was\n            # actually raised.\n            return cbook._ExceptionInfo(\n                ValueError,\n                f\"Failed to find font {prop}, and fallback to the default font was \"\n                f\"disabled\"\n            )\n    else:\n        _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                   prop, best_font.name, best_font.fname, best_score)\n        result = best_font.fname\n\n    if not os.path.isfile(result):\n        if rebuild_if_missing:\n            _log.info(\n                'findfont: Found a missing font file.  Rebuilding cache.')\n            new_fm = _load_fontmanager(try_read_cache=False)\n            # Replace self by the new fontmanager, because users may have\n            # a reference to this specific instance.\n            # TODO: _load_fontmanager should really be (used by) a method\n            # modifying the instance in place.\n            vars(self).update(vars(new_fm))\n            return self.findfont(\n                prop, fontext, directory, rebuild_if_missing=False)\n        else:\n            # This return instead of raise is intentional, as we wish to\n            # cache that it was not found, which will not occur if it was\n            # actually raised.\n            return cbook._ExceptionInfo(ValueError, \"No valid font could be found\")\n\n    return _cached_realpath(result)",
    "matplotlib.lib.matplotlib.font_manager.__hash__": "def __hash__(self):\n    l = (tuple(self.get_family()),\n         self.get_slant(),\n         self.get_variant(),\n         self.get_weight(),\n         self.get_stretch(),\n         self.get_size(),\n         self.get_file(),\n         self.get_math_fontfamily())\n    return hash(l)",
    "matplotlib.lib.matplotlib.font_manager.__eq__": "def __eq__(self, other):\n    return hash(self) == hash(other)"
}