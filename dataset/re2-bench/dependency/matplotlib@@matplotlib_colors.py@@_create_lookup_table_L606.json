{
    "matplotlib.lib.matplotlib._api.__init__.check_shape": "def check_shape(shape, /, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* has the shape *shape*;\n    if not, raise an appropriate ValueError.\n\n    *None* in the shape is treated as a \"free\" size that can have any length.\n    e.g. (None, 2) -> (N, 2)\n\n    The values checked must be numpy arrays.\n\n    Examples\n    --------\n    To check for (N, 2) shaped arrays\n\n    >>> _api.check_shape((None, 2), arg=arg, other_arg=other_arg)\n    \"\"\"\n    for k, v in kwargs.items():\n        data_shape = v.shape\n\n        if (len(data_shape) != len(shape)\n                or any(s != t and t is not None for s, t in zip(data_shape, shape))):\n            dim_labels = iter(itertools.chain(\n                'NMLKJIH',\n                (f\"D{i}\" for i in itertools.count())))\n            text_shape = \", \".join([str(n) if n is not None else next(dim_labels)\n                                    for n in shape[::-1]][::-1])\n            if len(shape) == 1:\n                text_shape += \",\"\n\n            raise ValueError(\n                f\"{k!r} must be {len(shape)}D with shape ({text_shape}), \"\n                f\"but your input has shape {v.shape}\"\n            )",
    "matplotlib.lib.matplotlib._cm._gist_heat_red": "def _gist_heat_red(x): return 1.5 * x",
    "matplotlib.lib.matplotlib._cm._gist_heat_green": "def _gist_heat_green(x): return 2 * x - 1",
    "matplotlib.lib.matplotlib._cm._gist_heat_blue": "def _gist_heat_blue(x): return 4 * x - 3",
    "matplotlib.lib.matplotlib._cm._gist_yarg": "def _gist_yarg(x): return 1 - x",
    "matplotlib.lib.matplotlib._cm._g3": "def _g3(x): return x",
    "matplotlib.lib.matplotlib._cm._g5": "def _g5(x): return x ** 3",
    "matplotlib.lib.matplotlib._cm._g7": "def _g7(x): return np.sqrt(x)",
    "matplotlib.lib.matplotlib._cm._g10": "def _g10(x): return np.cos(x * np.pi / 2)",
    "matplotlib.lib.matplotlib._cm._g13": "def _g13(x): return np.sin(x * np.pi)",
    "matplotlib.lib.matplotlib._cm._g15": "def _g15(x): return np.sin(x * 2 * np.pi)",
    "matplotlib.lib.matplotlib._cm._g23": "def _g23(x): return 3 * x - 2",
    "matplotlib.lib.matplotlib._cm._g28": "def _g28(x): return np.abs((3 * x - 1) / 2)",
    "matplotlib.lib.matplotlib._cm._g30": "def _g30(x): return x / 0.32 - 0.78125",
    "matplotlib.lib.matplotlib._cm._g31": "def _g31(x): return 2 * x - 0.84",
    "matplotlib.lib.matplotlib._cm._g32": "def _g32(x):\n    ret = np.zeros(len(x))\n    m = (x < 0.25)\n    ret[m] = 4 * x[m]\n    m = (x >= 0.25) & (x < 0.92)\n    ret[m] = -2 * x[m] + 1.84\n    m = (x >= 0.92)\n    ret[m] = x[m] / 0.08 - 11.5\n    return ret",
    "matplotlib.lib.matplotlib._cm._g33": "def _g33(x): return np.abs(2 * x - 0.5)",
    "matplotlib.lib.matplotlib._cm._g34": "def _g34(x): return 2 * x",
    "matplotlib.lib.matplotlib._cm._g35": "def _g35(x): return 2 * x - 0.5",
    "matplotlib.lib.matplotlib._cm._g36": "def _g36(x): return 2 * x - 1",
    "matplotlib.lib.matplotlib._cm._flag_red": "def _flag_red(x): return 0.75 * np.sin((x * 31.5 + 0.25) * np.pi) + 0.5",
    "matplotlib.lib.matplotlib._cm._flag_green": "def _flag_green(x): return np.sin(x * 31.5 * np.pi)",
    "matplotlib.lib.matplotlib._cm._flag_blue": "def _flag_blue(x): return 0.75 * np.sin((x * 31.5 - 0.25) * np.pi) + 0.5",
    "matplotlib.lib.matplotlib._cm._prism_red": "def _prism_red(x): return 0.75 * np.sin((x * 20.9 + 0.25) * np.pi) + 0.67",
    "matplotlib.lib.matplotlib._cm._prism_green": "def _prism_green(x): return 0.75 * np.sin((x * 20.9 - 0.25) * np.pi) + 0.33",
    "matplotlib.lib.matplotlib._cm._prism_blue": "def _prism_blue(x): return -1.1 * np.sin((x * 20.9) * np.pi)",
    "matplotlib.lib.matplotlib._cm._ch_helper": "def _ch_helper(gamma, s, r, h, p0, p1, x):\n    \"\"\"Helper function for generating picklable cubehelix colormaps.\"\"\"\n    # Apply gamma factor to emphasise low or high intensity values\n    xg = x ** gamma\n    # Calculate amplitude and angle of deviation from the black to white\n    # diagonal in the plane of constant perceived intensity.\n    a = h * xg * (1 - xg) / 2\n    phi = 2 * np.pi * (s / 3 + r * x)\n    return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))",
    "matplotlib.lib.matplotlib.colors._reverser": "@staticmethod\ndef _reverser(func, x):\n    return func(1 - x)"
}