{
    "scikit-learn.sklearn.utils._indexing._determine_key_type": "def _determine_key_type(key, accept_slice=True):\n    \"\"\"Determine the data type of key.\n\n    Parameters\n    ----------\n    key : scalar, slice or array-like\n        The key from which we want to infer the data type.\n\n    accept_slice : bool, default=True\n        Whether or not to raise an error if the key is a slice.\n\n    Returns\n    -------\n    dtype : {'int', 'str', 'bool', None}\n        Returns the data type of key.\n    \"\"\"\n    err_msg = (\n        \"No valid specification of the columns. Only a scalar, list or \"\n        \"slice of all integers or all strings, or boolean mask is \"\n        \"allowed\"\n    )\n\n    dtype_to_str = {int: \"int\", str: \"str\", bool: \"bool\", np.bool_: \"bool\"}\n    array_dtype_to_str = {\n        \"i\": \"int\",\n        \"u\": \"int\",\n        \"b\": \"bool\",\n        \"O\": \"str\",\n        \"U\": \"str\",\n        \"S\": \"str\",\n    }\n\n    if key is None:\n        return None\n    if isinstance(key, tuple(dtype_to_str.keys())):\n        try:\n            return dtype_to_str[type(key)]\n        except KeyError:\n            raise ValueError(err_msg)\n    if isinstance(key, slice):\n        if not accept_slice:\n            raise TypeError(\n                \"Only array-like or scalar are supported. A Python slice was given.\"\n            )\n        if key.start is None and key.stop is None:\n            return None\n        key_start_type = _determine_key_type(key.start)\n        key_stop_type = _determine_key_type(key.stop)\n        if key_start_type is not None and key_stop_type is not None:\n            if key_start_type != key_stop_type:\n                raise ValueError(err_msg)\n        if key_start_type is not None:\n            return key_start_type\n        return key_stop_type\n    # TODO(1.9) remove UserList when the force_int_remainder_cols param\n    # of ColumnTransformer is removed\n    if isinstance(key, (list, tuple, UserList)):\n        unique_key = set(key)\n        key_type = {_determine_key_type(elt) for elt in unique_key}\n        if not key_type:\n            return None\n        if len(key_type) != 1:\n            raise ValueError(err_msg)\n        return key_type.pop()\n    if hasattr(key, \"dtype\"):\n        xp, is_array_api = get_namespace(key)\n        # NumPy arrays are special-cased in their own branch because the Array API\n        # cannot handle object/string-based dtypes that are often used to index\n        # columns of dataframes by names.\n        if is_array_api and not _is_numpy_namespace(xp):\n            if xp.isdtype(key.dtype, \"bool\"):\n                return \"bool\"\n            elif xp.isdtype(key.dtype, \"integral\"):\n                return \"int\"\n            else:\n                raise ValueError(err_msg)\n        else:\n            try:\n                return array_dtype_to_str[key.dtype.kind]\n            except KeyError:\n                raise ValueError(err_msg)\n    raise ValueError(err_msg)",
    "scikit-learn.sklearn.utils._indexing._get_column_indices_for_bool_or_int": "def _get_column_indices_for_bool_or_int(key, n_columns):\n    # Convert key into list of positive integer indexes\n    try:\n        idx = _safe_indexing(np.arange(n_columns), key)\n    except IndexError as e:\n        raise ValueError(\n            f\"all features must be in [0, {n_columns - 1}] or [-{n_columns}, 0]\"\n        ) from e\n    return np.atleast_1d(idx).tolist()",
    "scikit-learn.sklearn.utils.validation._use_interchange_protocol": "def _use_interchange_protocol(X):\n    \"\"\"Use interchange protocol for non-pandas dataframes that follow the protocol.\n\n    Note: at this point we chose not to use the interchange API on pandas dataframe\n    to ensure strict behavioral backward compatibility with older versions of\n    scikit-learn.\n    \"\"\"\n    return not _is_pandas_df(X) and hasattr(X, \"__dataframe__\")"
}