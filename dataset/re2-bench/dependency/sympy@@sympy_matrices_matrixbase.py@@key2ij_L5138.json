{
    "sympy.sympy.core.containers.__len__": "def __len__(self):\n    return len(self.args)",
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.matrices.matrixbase.shape": "@property\ndef shape(self) -> tuple[int, int]:\n    \"\"\"The shape (dimensions) of the matrix as the 2-tuple (rows, cols).\n\n    Examples\n    ========\n\n    >>> from sympy import zeros\n    >>> M = zeros(2, 3)\n    >>> M.shape\n    (2, 3)\n    >>> M.rows\n    2\n    >>> M.cols\n    3\n    \"\"\"\n    return (self.rows, self.cols)",
    "sympy.sympy.matrices.matrixbase.__len__": "def __len__(self) -> int:\n    \"\"\"Return the number of elements of ``self``.\n\n    Implemented mainly so bool(Matrix()) == False.\n    \"\"\"\n    return self.rows * self.cols",
    "sympy.sympy.matrices.matrixbase.<listcomp>": "return [a2idx(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)] # type: ignore\n",
    "sympy.sympy.matrices.matrixbase.a2idx": "def a2idx(j, n=None):\n    \"\"\"Return integer after making positive and validating against n.\"\"\"\n    if not isinstance(j, int):\n        jindex = getattr(j, '__index__', None)\n        if jindex is not None:\n            j = jindex()\n        else:\n            raise IndexError(\"Invalid index a[%r]\" % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError(\"Index out of range: a[%s]\" % (j,))\n    return int(j)",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))"
}