{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.__abs__": "def __abs__(self) -> Expr:\n    from sympy.functions.elementary.complexes import Abs\n    return Abs(self)",
    "sympy.sympy.core.intfunc.trailing": "def trailing(n):\n    \"\"\"Count the number of trailing zero digits in the binary\n    representation of n, i.e. determine the largest power of 2\n    that divides n.\n\n    Examples\n    ========\n\n    >>> from sympy import trailing\n    >>> trailing(128)\n    7\n    >>> trailing(63)\n    0\n\n    See Also\n    ========\n    sympy.ntheory.factor_.multiplicity\n\n    \"\"\"\n    if not n:\n        return 0\n    return bit_scan1(int(n))",
    "sympy.sympy.core.mul._eval_is_integer": "def _eval_is_integer(self):\n    is_rational = self._eval_is_rational()\n    if is_rational is False:\n        return False\n\n    numerators = []\n    denominators = []\n    unknown = False\n    for a in self.args:\n        hit = False\n        if a.is_integer:\n            if abs(a) is not S.One:\n                numerators.append(a)\n        elif a.is_Rational:\n            n, d = a.as_numer_denom()\n            if abs(n) is not S.One:\n                numerators.append(n)\n            if d is not S.One:\n                denominators.append(d)\n        elif a.is_Pow:\n            b, e = a.as_base_exp()\n            if not b.is_integer or not e.is_integer:\n                hit = unknown = True\n            if e.is_negative:\n                denominators.append(2 if a is S.Half else\n                    Pow(a, S.NegativeOne))\n            elif not hit:\n                # int b and pos int e: a = b**e is integer\n                assert not e.is_positive\n                # for rational self and e equal to zero: a = b**e is 1\n                assert not e.is_zero\n                return # sign of e unknown -> self.is_integer unknown\n            else:\n                # x**2, 2**x, or x**y with x and y int-unknown -> unknown\n                return\n        else:\n            return\n\n    if not denominators and not unknown:\n        return True\n\n    allodd = lambda x: all(i.is_odd for i in x)\n    alleven = lambda x: all(i.is_even for i in x)\n    anyeven = lambda x: any(i.is_even for i in x)\n\n    from .relational import is_gt\n    if not numerators and denominators and all(\n            is_gt(_, S.One) for _ in denominators):\n        return False\n    elif unknown:\n        return\n    elif allodd(numerators) and anyeven(denominators):\n        return False\n    elif anyeven(numerators) and denominators == [2]:\n        return True\n    elif alleven(numerators) and allodd(denominators\n            ) and (Mul(*denominators, evaluate=False) - 1\n            ).is_positive:\n        return False\n    if len(denominators) == 1:\n        d = denominators[0]\n        if d.is_Integer:\n            is_power_of_two = d.p & (d.p - 1) == 0\n            # if minimal power of 2 in num vs den is not\n            # negative then we have an integer\n            if is_power_of_two and (Add(*[i.as_base_exp()[1] for i in\n                    numerators if i.is_even]) - trailing(d.p)\n                    ).is_nonnegative:\n                return True\n    if len(numerators) == 1:\n        n = numerators[0]\n        if n.is_Integer and n.is_even:\n            # if minimal power of 2 in den vs num is positive\n            # then we have have a non-integer\n            if (Add(*[i.as_base_exp()[1] for i in\n                    denominators if i.is_even]) - trailing(n.p)\n                    ).is_positive:\n                return False",
    "sympy.sympy.core.mul.<listcomp>": "if (Add(*[i.as_base_exp()[1] for i in\n        Mul.make_args(n) if i.is_even]) - trailing(d.p)\n        ).is_positive:\n    return False\n",
    "sympy.sympy.core.numbers.__abs__": "@staticmethod\ndef __abs__():\n    return S.One",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.simplify.radsimp.fraction": "def fraction(expr, exact=False):\n    \"\"\"Returns a pair with expression's numerator and denominator.\n       If the given expression is not a fraction then this function\n       will return the tuple (expr, 1).\n\n       This function will not make any attempt to simplify nested\n       fractions or to do any term rewriting at all.\n\n       If only one of the numerator/denominator pair is needed then\n       use numer(expr) or denom(expr) functions respectively.\n\n       >>> from sympy import fraction, Rational, Symbol\n       >>> from sympy.abc import x, y\n\n       >>> fraction(x/y)\n       (x, y)\n       >>> fraction(x)\n       (x, 1)\n\n       >>> fraction(1/y**2)\n       (1, y**2)\n\n       >>> fraction(x*y/2)\n       (x*y, 2)\n       >>> fraction(Rational(1, 2))\n       (1, 2)\n\n       This function will also work fine with assumptions:\n\n       >>> k = Symbol('k', negative=True)\n       >>> fraction(x * y**k)\n       (x, y**(-k))\n\n       If we know nothing about sign of some exponent and ``exact``\n       flag is unset, then the exponent's structure will\n       be analyzed and pretty fraction will be returned:\n\n       >>> from sympy import exp, Mul\n       >>> fraction(2*x**(-y))\n       (2, x**y)\n\n       >>> fraction(exp(-x))\n       (1, exp(x))\n\n       >>> fraction(exp(-x), exact=True)\n       (exp(-x), 1)\n\n       The ``exact`` flag will also keep any unevaluated Muls from\n       being evaluated:\n\n       >>> u = Mul(2, x + 1, evaluate=False)\n       >>> fraction(u)\n       (2*x + 2, 1)\n       >>> fraction(u, exact=True)\n       (2*(x  + 1), 1)\n    \"\"\"\n    expr = sympify(expr)\n\n    numer, denom = [], []\n\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()  # this will cause evaluation\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and not term.is_Integer:\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact)"
}