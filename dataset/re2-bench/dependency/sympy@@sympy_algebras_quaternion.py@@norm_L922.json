{
    "sympy.sympy.algebras.quaternion.a": "@property\ndef a(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.algebras.quaternion.b": "@property\ndef b(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.algebras.quaternion.c": "@property\ndef c(self) -> Expr:\n    return self.args[2]",
    "sympy.sympy.algebras.quaternion.d": "@property\ndef d(self) -> Expr:\n    return self.args[3]",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.functions.elementary.miscellaneous.sqrt": "def sqrt(arg, evaluate=None):\n    \"\"\"Returns the principal square root.\n\n    Parameters\n    ==========\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt, Symbol, S\n    >>> x = Symbol('x')\n\n    >>> sqrt(x)\n    sqrt(x)\n\n    >>> sqrt(x)**2\n    x\n\n    Note that sqrt(x**2) does not simplify to x.\n\n    >>> sqrt(x**2)\n    sqrt(x**2)\n\n    This is because the two are not equal to each other in general.\n    For example, consider x == -1:\n\n    >>> from sympy import Eq\n    >>> Eq(sqrt(x**2), x).subs(x, -1)\n    False\n\n    This is because sqrt computes the principal square root, so the square may\n    put the argument in a different branch.  This identity does hold if x is\n    positive:\n\n    >>> y = Symbol('y', positive=True)\n    >>> sqrt(y**2)\n    y\n\n    You can force this simplification by using the powdenest() function with\n    the force option set to True:\n\n    >>> from sympy import powdenest\n    >>> sqrt(x**2)\n    sqrt(x**2)\n    >>> powdenest(sqrt(x**2), force=True)\n    x\n\n    To get both branches of the square root you can use the rootof function:\n\n    >>> from sympy import rootof\n\n    >>> [rootof(x**2-3,i) for i in (0,1)]\n    [-sqrt(3), sqrt(3)]\n\n    Although ``sqrt`` is printed, there is no ``sqrt`` function so looking for\n    ``sqrt`` in an expression will fail:\n\n    >>> from sympy.utilities.misc import func_name\n    >>> func_name(sqrt(x))\n    'Pow'\n    >>> sqrt(x).has(sqrt)\n    False\n\n    To find ``sqrt`` look for ``Pow`` with an exponent of ``1/2``:\n\n    >>> (x + 1/sqrt(x)).find(lambda i: i.is_Pow and abs(i.exp) is S.Half)\n    {1/sqrt(x)}\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof, root, real_root\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Square_root\n    .. [2] https://en.wikipedia.org/wiki/Principal_value\n    \"\"\"\n    # arg = sympify(arg) is handled by Pow\n    return Pow(arg, S.Half, evaluate=evaluate)",
    "sympy.sympy.simplify.trigsimp.trigsimp": "def trigsimp(expr, inverse=False, **opts):\n    \"\"\"Returns a reduced expression by using known trig identities.\n\n    Parameters\n    ==========\n\n    inverse : bool, optional\n        If ``inverse=True``, it will be assumed that a composition of inverse\n        functions, such as sin and asin, can be cancelled in any order.\n        For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n        x belongs to the set where this relation is true. The default is False.\n        Default : True\n\n    method : string, optional\n        Specifies the method to use. Valid choices are:\n\n        - ``'matching'``, default\n        - ``'groebner'``\n        - ``'combined'``\n        - ``'fu'``\n        - ``'old'``\n\n        If ``'matching'``, simplify the expression recursively by targeting\n        common patterns. If ``'groebner'``, apply an experimental groebner\n        basis algorithm. In this case further options are forwarded to\n        ``trigsimp_groebner``, please refer to\n        its docstring. If ``'combined'``, it first runs the groebner basis\n        algorithm with small default parameters, then runs the ``'matching'``\n        algorithm. If ``'fu'``, run the collection of trigonometric\n        transformations described by Fu, et al. (see the\n        :py:func:`~sympy.simplify.fu.fu` docstring). If ``'old'``, the original\n        SymPy trig simplification function is run.\n    opts :\n        Optional keyword arguments passed to the method. See each method's\n        function docstring for details.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using ``method='groebner'`` (or ``method='combined'``) might lead to\n    greater simplification.\n\n    The old trigsimp routine can be accessed as with method ``method='old'``.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    expr_simplified = trigsimpfunc(expr)\n    if inverse:\n        expr_simplified = _trigsimp_inverse(expr_simplified)\n\n    return expr_simplified"
}