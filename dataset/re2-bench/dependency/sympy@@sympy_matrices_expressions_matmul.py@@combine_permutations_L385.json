{
    "sympy.sympy.combinatorics.permutations.__mul__": "def __mul__(self, other):\n    \"\"\"\n    Return the product a*b as a Permutation; the ith value is b(a(i)).\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.permutations import _af_rmul, Permutation\n\n    >>> a, b = [1, 0, 2], [0, 2, 1]\n    >>> a = Permutation(a); b = Permutation(b)\n    >>> list(a*b)\n    [2, 0, 1]\n    >>> [b(a(i)) for i in range(3)]\n    [2, 0, 1]\n\n    This handles operands in reverse order compared to _af_rmul and rmul:\n\n    >>> al = list(a); bl = list(b)\n    >>> _af_rmul(al, bl)\n    [1, 2, 0]\n    >>> [al[bl[i]] for i in range(3)]\n    [1, 2, 0]\n\n    It is acceptable for the arrays to have different lengths; the shorter\n    one will be padded to match the longer one:\n\n    >>> from sympy import init_printing\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n    >>> b*Permutation([1, 0])\n    Permutation([1, 2, 0])\n    >>> Permutation([1, 0])*b\n    Permutation([2, 0, 1])\n\n    It is also acceptable to allow coercion to handle conversion of a\n    single list to the left of a Permutation:\n\n    >>> [0, 1]*a # no change: 2-element identity\n    Permutation([1, 0, 2])\n    >>> [[0, 1]]*a # exchange first two elements\n    Permutation([0, 1, 2])\n\n    You cannot use more than 1 cycle notation in a product of cycles\n    since coercion can only handle one argument to the left. To handle\n    multiple cycles it is convenient to use Cycle instead of Permutation:\n\n    >>> [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP\n    >>> from sympy.combinatorics.permutations import Cycle\n    >>> Cycle(1, 2)(2, 3)\n    (1 3 2)\n\n    \"\"\"\n    from sympy.combinatorics.perm_groups import PermutationGroup, Coset\n    if isinstance(other, PermutationGroup):\n        return Coset(self, other, dir='-')\n    a = self.array_form\n    # __rmul__ makes sure the other is a Permutation\n    b = other.array_form\n    if not b:\n        perm = a\n    else:\n        b.extend(list(range(len(b), len(a))))\n        perm = [b[i] for i in a] + b[len(a):]\n    return self._af_new(perm)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.matrices.expressions.matmul.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericIdentity().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatMul is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*matrices)\n\n    if not matrices:\n        # Should it be\n        #\n        # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n        return factor\n\n    if evaluate:\n        return cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.permutation.__new__": "def __new__(cls, perm):\n    from sympy.combinatorics.permutations import Permutation\n\n    perm = _sympify(perm)\n    if not isinstance(perm, Permutation):\n        raise ValueError(\n            \"{} must be a SymPy Permutation instance.\".format(perm))\n\n    return super().__new__(cls, perm)"
}