{
    "matplotlib.lib.matplotlib.tri._triinterpolate._scalar_vectorized": "def _scalar_vectorized(scalar, M):\n    \"\"\"\n    Scalar product between scalars and matrices.\n    \"\"\"\n    return scalar[:, np.newaxis, np.newaxis]*M",
    "matplotlib.lib.matplotlib.tri._triinterpolate._transpose_vectorized": "def _transpose_vectorized(M):\n    \"\"\"\n    Transposition of an array of matrices *M*.\n    \"\"\"\n    return np.transpose(M, [0, 2, 1])",
    "matplotlib.lib.matplotlib.tri._triinterpolate.get_d2Sidksij2": "def get_d2Sidksij2(self, alpha, ecc):\n    \"\"\"\n    Parameters\n    ----------\n    *alpha* is a (N x 3 x 1) array (array of column-matrices) of\n    barycentric coordinates\n    *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n    eccentricities\n\n    Returns\n    -------\n    Returns the arrays d2sdksi2 (N x 3 x 1) Hessian of shape functions\n    expressed in covariant coordinates in first apex basis.\n    \"\"\"\n    subtri = np.argmin(alpha, axis=1)[:, 0]\n    ksi = _roll_vectorized(alpha, -subtri, axis=0)\n    E = _roll_vectorized(ecc, -subtri, axis=0)\n    x = ksi[:, 0, 0]\n    y = ksi[:, 1, 0]\n    z = ksi[:, 2, 0]\n    d2V = _to_matrix_vectorized([\n        [     6.*x,      6.*x,      6.*x],\n        [     6.*y,        0.,        0.],\n        [       0.,      6.*z,        0.],\n        [     2.*z, 2.*z-4.*x, 2.*z-2.*x],\n        [2.*y-4.*x,      2.*y, 2.*y-2.*x],\n        [2.*x-4.*y,        0.,     -2.*y],\n        [     2.*z,        0.,      2.*y],\n        [       0.,      2.*y,      2.*z],\n        [       0., 2.*x-4.*z,     -2.*z],\n        [    -2.*z,     -2.*y,     x-y-z]])\n    # Puts back d2V in first apex basis\n    d2V = d2V @ _extract_submatrices(\n        self.rotate_d2V, subtri, block_size=3, axis=0)\n    prod = self.M @ d2V\n    prod += _scalar_vectorized(E[:, 0, 0], self.M0 @ d2V)\n    prod += _scalar_vectorized(E[:, 1, 0], self.M1 @ d2V)\n    prod += _scalar_vectorized(E[:, 2, 0], self.M2 @ d2V)\n    d2sdksi2 = _roll_vectorized(prod, 3*subtri, axis=0)\n    return d2sdksi2",
    "matplotlib.lib.matplotlib.tri._triinterpolate.get_Hrot_from_J": "def get_Hrot_from_J(self, J, return_area=False):\n    \"\"\"\n    Parameters\n    ----------\n    *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n    triangle first apex)\n\n    Returns\n    -------\n    Returns H_rot used to rotate Hessian from local basis of first apex,\n    to global coordinates.\n    if *return_area* is True, returns also the triangle area (0.5*det(J))\n    \"\"\"\n    # Here we try to deal with the simplest colinear cases; a null\n    # energy and area is imposed.\n    J_inv = _safe_inv22_vectorized(J)\n    Ji00 = J_inv[:, 0, 0]\n    Ji11 = J_inv[:, 1, 1]\n    Ji10 = J_inv[:, 1, 0]\n    Ji01 = J_inv[:, 0, 1]\n    H_rot = _to_matrix_vectorized([\n        [Ji00*Ji00, Ji10*Ji10, Ji00*Ji10],\n        [Ji01*Ji01, Ji11*Ji11, Ji01*Ji11],\n        [2*Ji00*Ji01, 2*Ji11*Ji10, Ji00*Ji11+Ji10*Ji01]])\n    if not return_area:\n        return H_rot\n    else:\n        area = 0.5 * (J[:, 0, 0]*J[:, 1, 1] - J[:, 0, 1]*J[:, 1, 0])\n        return H_rot, area"
}