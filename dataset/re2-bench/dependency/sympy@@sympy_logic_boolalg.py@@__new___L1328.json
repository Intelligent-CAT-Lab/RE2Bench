{
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.core.relational.negated": "@property\ndef negated(self):\n    \"\"\"Return the negated relationship.\n\n    Examples\n    ========\n\n    >>> from sympy import Eq\n    >>> from sympy.abc import x\n    >>> Eq(x, 1)\n    Eq(x, 1)\n    >>> _.negated\n    Ne(x, 1)\n    >>> x < 1\n    x < 1\n    >>> _.negated\n    x >= 1\n\n    Notes\n    =====\n\n    This works more or less identical to ``~``/``Not``. The difference is\n    that ``negated`` returns the relationship even if ``evaluate=False``.\n    Hence, this is useful in code when checking for e.g. negated relations\n    to existing ones as it will not be affected by the `evaluate` flag.\n\n    \"\"\"\n    ops = {Eq: Ne, Ge: Lt, Gt: Le, Le: Gt, Lt: Ge, Ne: Eq}\n    # If there ever will be new Relational subclasses, the following line\n    # will work until it is properly sorted out\n    # return ops.get(self.func, lambda a, b, evaluate=False: ~(self.func(a,\n    #      b, evaluate=evaluate)))(*self.args, evaluate=False)\n    return Relational.__new__(ops.get(self.func), *self.args)",
    "sympy.sympy.core.relational.canonical": "@property\ndef canonical(self):\n    \"\"\"Return a canonical form of the relational by putting a\n    number on the rhs, canonically removing a sign or else\n    ordering the args canonically. No other simplification is\n    attempted.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> x < 2\n    x < 2\n    >>> _.reversed.canonical\n    x < 2\n    >>> (-y < x).canonical\n    x > -y\n    >>> (-y > x).canonical\n    x < -y\n    >>> (-y < -x).canonical\n    x < y\n\n    The canonicalization is recursively applied:\n\n    >>> from sympy import Eq\n    >>> Eq(x < y, y > x).canonical\n    True\n    \"\"\"\n    args = tuple([i.canonical if isinstance(i, Relational) else i for i in self.args])\n    if args != self.args:\n        r = self.func(*args)\n        if not isinstance(r, Relational):\n            return r\n    else:\n        r = self\n    if r.rhs.is_number:\n        if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:\n            r = r.reversed\n    elif r.lhs.is_number or tuple(ordered(args)) != args:\n        r = r.reversed\n\n    LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)\n    RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)\n\n    if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):\n        return r\n\n    # Check if first value has negative sign\n    if LHS_CEMS and LHS_CEMS():\n        return r.reversedsign\n    elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():\n        # Right hand side has a minus, but not lhs.\n        # How does the expression with reversed signs behave?\n        # This is so that expressions of the type\n        # Eq(x, -y) and Eq(-x, y)\n        # have the same canonical representation\n        expr1, _ = ordered([r.lhs, -r.rhs])\n        if expr1 != r.lhs:\n            return r.reversed.reversedsign\n\n    return r",
    "sympy.sympy.core.sorting.ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    \"\"\"Return an iterator of the seq where keys are used to break ties\n    in a conservative fashion: if, after applying a key, there are no\n    ties then no other keys will be computed.\n\n    Two default keys will be applied if 1) keys are not provided or\n    2) the given keys do not resolve all ties (but only if ``default``\n    is True). The two keys are ``_nodes`` (which places smaller\n    expressions before large) and ``default_sort_key`` which (if the\n    ``sort_key`` for an object is defined properly) should resolve\n    any ties. This strategy is similar to sorting done by\n    ``Basic.compare``, but differs in that ``ordered`` never makes a\n    decision based on an objects name.\n\n    If ``warn`` is True then an error will be raised if there were no\n    keys remaining to break ties. This can be used if it was expected that\n    there should be no ties between items that are not identical.\n\n    Examples\n    ========\n\n    >>> from sympy import ordered, count_ops\n    >>> from sympy.abc import x, y\n\n    The count_ops is not sufficient to break ties in this list and the first\n    two items appear in their original order (i.e. the sorting is stable):\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n    ...    count_ops, default=False, warn=False))\n    ...\n    [y + 2, x + 2, x**2 + y + 3]\n\n    The default_sort_key allows the tie to be broken:\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n    ...\n    [x + 2, y + 2, x**2 + y + 3]\n\n    Here, sequences are sorted by length, then sum:\n\n    >>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n    ...    lambda x: len(x),\n    ...    lambda x: sum(x)]]\n    ...\n    >>> list(ordered(seq, keys, default=False, warn=False))\n    [[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]\n\n    If ``warn`` is True, an error will be raised if there were not\n    enough keys to break ties:\n\n    >>> list(ordered(seq, keys, default=False, warn=True))\n    Traceback (most recent call last):\n    ...\n    ValueError: not enough keys to break ties\n\n\n    Notes\n    =====\n\n    The decorated sort is one of the fastest ways to sort a sequence for\n    which special item comparison is desired: the sequence is decorated,\n    sorted on the basis of the decoration (e.g. making all letters lower\n    case) and then undecorated. If one wants to break ties for items that\n    have the same decorated value, a second key can be used. But if the\n    second key is expensive to compute then it is inefficient to decorate\n    all items with both keys: only those items having identical first key\n    values need to be decorated. This function applies keys successively\n    only when needed to break ties. By yielding an iterator, use of the\n    tie-breaker is delayed as long as possible.\n\n    This function is best used in cases when use of the first key is\n    expected to be a good hashing function; if there are no unique hashes\n    from application of a key, then that key should not have been used. The\n    exception, however, is that even if there are many collisions, if the\n    first group is small and one does not need to process all items in the\n    list then time will not be wasted sorting what one was not interested\n    in. For example, if one were looking for the minimum in a list and\n    there were several criteria used to define the sort order, then this\n    function would be good at returning that quickly if the first group\n    of candidates is small relative to the number of items being processed.\n\n    \"\"\"\n\n    d = defaultdict(list)\n    if keys:\n        if isinstance(keys, (list, tuple)):\n            keys = list(keys)\n            f = keys.pop(0)\n        else:\n            f = keys\n            keys = []\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n\n    for k, value in sorted(d.items()):\n        if len(value) > 1:\n            if keys:\n                value = ordered(value, keys, default, warn)\n            elif default:\n                value = ordered(value, (_nodes, default_sort_key,),\n                               default=False, warn=warn)\n            elif warn:\n                u = list(uniq(value))\n                if len(u) > 1:\n                    raise ValueError(\n                        'not enough keys to break ties: %s' % u)\n        yield from value",
    "sympy.sympy.logic.boolalg.<listcomp>": "return And(*[Not(arg) for arg in argset])\n",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.logic.boolalg.__hash__": "def __hash__(self):\n    return hash(False)",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)"
}