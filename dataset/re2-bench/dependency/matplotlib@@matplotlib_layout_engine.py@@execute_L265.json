{
    "matplotlib.lib.matplotlib._constrained_layout.do_constrained_layout": "def do_constrained_layout(fig, h_pad, w_pad,\n                          hspace=None, wspace=None, rect=(0, 0, 1, 1),\n                          compress=False):\n    \"\"\"\n    Do the constrained_layout.  Called at draw time in\n     ``figure.constrained_layout()``\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        `.Figure` instance to do the layout in.\n\n    h_pad, w_pad : float\n      Padding around the Axes elements in figure-normalized units.\n\n    hspace, wspace : float\n       Fraction of the figure to dedicate to space between the\n       Axes.  These are evenly spread between the gaps between the Axes.\n       A value of 0.2 for a three-column layout would have a space\n       of 0.1 of the figure width between each column.\n       If h/wspace < h/w_pad, then the pads are used instead.\n\n    rect : tuple of 4 floats\n        Rectangle in figure coordinates to perform constrained layout in\n        [left, bottom, width, height], each from 0-1.\n\n    compress : bool\n        Whether to shift Axes so that white space in between them is\n        removed. This is useful for simple grids of fixed-aspect Axes (e.g.\n        a grid of images).\n\n    Returns\n    -------\n    layoutgrid : private debugging structure\n    \"\"\"\n\n    renderer = fig._get_renderer()\n    # make layoutgrid tree...\n    layoutgrids = make_layoutgrids(fig, None, rect=rect)\n    if not layoutgrids['hasgrids']:\n        _api.warn_external('There are no gridspecs with layoutgrids. '\n                           'Possibly did not call parent GridSpec with the'\n                           ' \"figure\" keyword')\n        return\n\n    for _ in range(2):\n        # do the algorithm twice.  This has to be done because decorations\n        # change size after the first re-position (i.e. x/yticklabels get\n        # larger/smaller).  This second reposition tends to be much milder,\n        # so doing twice makes things work OK.\n\n        # make margins for all the Axes and subfigures in the\n        # figure.  Add margins for colorbars...\n        make_layout_margins(layoutgrids, fig, renderer, h_pad=h_pad,\n                            w_pad=w_pad, hspace=hspace, wspace=wspace)\n        make_margin_suptitles(layoutgrids, fig, renderer, h_pad=h_pad,\n                              w_pad=w_pad)\n\n        # if a layout is such that a columns (or rows) margin has no\n        # constraints, we need to make all such instances in the grid\n        # match in margin size.\n        match_submerged_margins(layoutgrids, fig)\n\n        # update all the variables in the layout.\n        layoutgrids[fig].update_variables()\n\n        warn_collapsed = ('constrained_layout not applied because '\n                          'axes sizes collapsed to zero.  Try making '\n                          'figure larger or Axes decorations smaller.')\n        if check_no_collapsed_axes(layoutgrids, fig):\n            reposition_axes(layoutgrids, fig, renderer, h_pad=h_pad,\n                            w_pad=w_pad, hspace=hspace, wspace=wspace)\n            if compress:\n                layoutgrids = compress_fixed_aspect(layoutgrids, fig)\n                layoutgrids[fig].update_variables()\n                if check_no_collapsed_axes(layoutgrids, fig):\n                    reposition_axes(layoutgrids, fig, renderer, h_pad=h_pad,\n                                    w_pad=w_pad, hspace=hspace, wspace=wspace,\n                                    compress=True)\n                else:\n                    _api.warn_external(warn_collapsed)\n\n                if ((suptitle := fig._suptitle) is not None and\n                        suptitle.get_in_layout() and suptitle._autopos):\n                    x, _ = suptitle.get_position()\n                    suptitle.set_position(\n                        (x, layoutgrids[fig].get_inner_bbox().y1 + h_pad))\n                    suptitle.set_verticalalignment('bottom')\n        else:\n            _api.warn_external(warn_collapsed)\n        reset_margins(layoutgrids, fig)\n    return layoutgrids",
    "matplotlib.lib.matplotlib.figure.get_size_inches": "def get_size_inches(self):\n    \"\"\"\n    Return the current size of the figure in inches.\n\n    Returns\n    -------\n    ndarray\n       The size (width, height) of the figure in inches.\n\n    See Also\n    --------\n    matplotlib.figure.Figure.set_size_inches\n    matplotlib.figure.Figure.get_figwidth\n    matplotlib.figure.Figure.get_figheight\n\n    Notes\n    -----\n    The size in pixels can be obtained by multiplying with `Figure.dpi`.\n    \"\"\"\n    return np.array(self.bbox_inches.p1)"
}