{
    "scikit-learn.sklearn.impute._base._transform_indicator": "def _transform_indicator(self, X):\n    \"\"\"Compute the indicator mask.'\n\n    Note that X must be the original data as passed to the imputer before\n    any imputation, since imputation may be done inplace in some cases.\n    \"\"\"\n    if self.add_indicator:\n        if not hasattr(self, \"indicator_\"):\n            raise ValueError(\n                \"Make sure to call _fit_indicator before _transform_indicator\"\n            )\n        return self.indicator_.transform(X)",
    "scikit-learn.sklearn.impute._base._concatenate_indicator": "def _concatenate_indicator(self, X_imputed, X_indicator):\n    \"\"\"Concatenate indicator mask with the imputed data.\"\"\"\n    if not self.add_indicator:\n        return X_imputed\n\n    if sp.issparse(X_imputed):\n        # sp.hstack may result in different formats between sparse arrays and\n        # matrices; specify the format to keep consistent behavior\n        hstack = partial(sp.hstack, format=X_imputed.format)\n    else:\n        hstack = np.hstack\n\n    if X_indicator is None:\n        raise ValueError(\n            \"Data from the missing indicator are not provided. Call \"\n            \"_fit_indicator and _transform_indicator in the imputer \"\n            \"implementation.\"\n        )\n\n    return hstack((X_imputed, X_indicator))",
    "scikit-learn.sklearn.metrics.pairwise.pairwise_distances_chunked": "@validate_params(\n    {\n        \"X\": [\"array-like\", \"sparse matrix\"],\n        \"Y\": [\"array-like\", \"sparse matrix\", None],\n        \"reduce_func\": [callable, None],\n        \"metric\": [StrOptions({\"precomputed\"}.union(_VALID_METRICS)), callable],\n        \"n_jobs\": [Integral, None],\n        \"working_memory\": [Interval(Real, 0, None, closed=\"left\"), None],\n    },\n    prefer_skip_nested_validation=False,  # metric is not validated yet\n)\ndef pairwise_distances_chunked(\n    X,\n    Y=None,\n    *,\n    reduce_func=None,\n    metric=\"euclidean\",\n    n_jobs=None,\n    working_memory=None,\n    **kwds,\n):\n    \"\"\"Generate a distance matrix chunk by chunk with optional reduction.\n\n    In cases where not all of a pairwise distance matrix needs to be\n    stored at once, this is used to calculate pairwise distances in\n    ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is\n    run on each chunk and its return values are concatenated into lists,\n    arrays or sparse matrices.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples_X, n_samples_X) or \\\n            (n_samples_X, n_features)\n        Array of pairwise distances between samples, or a feature array.\n        The shape the array should be (n_samples_X, n_samples_X) if\n        metric='precomputed' and (n_samples_X, n_features) otherwise.\n\n    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None\n        An optional second feature array. Only allowed if\n        metric != \"precomputed\".\n\n    reduce_func : callable, default=None\n        The function which is applied on each chunk of the distance matrix,\n        reducing it to needed values.  ``reduce_func(D_chunk, start)``\n        is called repeatedly, where ``D_chunk`` is a contiguous vertical\n        slice of the pairwise distance matrix, starting at row ``start``.\n        It should return one of: None; an array, a list, or a sparse matrix\n        of length ``D_chunk.shape[0]``; or a tuple of such objects.\n        Returning None is useful for in-place operations, rather than\n        reductions.\n\n        If None, pairwise_distances_chunked returns a generator of vertical\n        chunks of the distance matrix.\n\n    metric : str or callable, default='euclidean'\n        The metric to use when calculating distance between instances in a\n        feature array. If metric is a string, it must be one of the options\n        allowed by :func:`scipy.spatial.distance.pdist` for its metric parameter,\n        or a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\n        If metric is \"precomputed\", X is assumed to be a distance matrix.\n        Alternatively, if metric is a callable function, it is called on\n        each pair of instances (rows) and the resulting value recorded.\n        The callable should take two arrays from X as input and return a\n        value indicating the distance between them.\n\n    n_jobs : int, default=None\n        The number of jobs to use for the computation. This works by\n        breaking down the pairwise matrix into n_jobs even slices and\n        computing them in parallel.\n\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    working_memory : float, default=None\n        The sought maximum memory for temporary distance matrix chunks.\n        When None (default), the value of\n        ``sklearn.get_config()['working_memory']`` is used.\n\n    **kwds : optional keyword parameters\n        Any further parameters are passed directly to the distance function.\n        If using a :mod:`scipy.spatial.distance` metric, the parameters are still\n        metric dependent. See the scipy docs for usage examples.\n\n    Yields\n    ------\n    D_chunk : {ndarray, sparse matrix}\n        A contiguous slice of distance matrix, optionally processed by\n        ``reduce_func``.\n\n    Examples\n    --------\n    Without reduce_func:\n\n    >>> import numpy as np\n    >>> from sklearn.metrics import pairwise_distances_chunked\n    >>> X = np.random.RandomState(0).rand(5, 3)\n    >>> D_chunk = next(pairwise_distances_chunked(X))\n    >>> D_chunk\n    array([[0.   , 0.295, 0.417, 0.197, 0.572],\n           [0.295, 0.   , 0.576, 0.419, 0.764],\n           [0.417, 0.576, 0.   , 0.449, 0.903],\n           [0.197, 0.419, 0.449, 0.   , 0.512],\n           [0.572, 0.764, 0.903, 0.512, 0.   ]])\n\n    Retrieve all neighbors and average distance within radius r:\n\n    >>> r = .2\n    >>> def reduce_func(D_chunk, start):\n    ...     neigh = [np.flatnonzero(d < r) for d in D_chunk]\n    ...     avg_dist = (D_chunk * (D_chunk < r)).mean(axis=1)\n    ...     return neigh, avg_dist\n    >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func)\n    >>> neigh, avg_dist = next(gen)\n    >>> neigh\n    [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]\n    >>> avg_dist\n    array([0.039, 0.        , 0.        , 0.039, 0.        ])\n\n    Where r is defined per sample, we need to make use of ``start``:\n\n    >>> r = [.2, .4, .4, .3, .1]\n    >>> def reduce_func(D_chunk, start):\n    ...     neigh = [np.flatnonzero(d < r[i])\n    ...              for i, d in enumerate(D_chunk, start)]\n    ...     return neigh\n    >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))\n    >>> neigh\n    [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]\n\n    Force row-by-row generation by reducing ``working_memory``:\n\n    >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func,\n    ...                                  working_memory=0)\n    >>> next(gen)\n    [array([0, 3])]\n    >>> next(gen)\n    [array([0, 1])]\n    \"\"\"\n    n_samples_X = _num_samples(X)\n    if metric == \"precomputed\":\n        slices = (slice(0, n_samples_X),)\n    else:\n        if Y is None:\n            Y = X\n        # We get as many rows as possible within our working_memory budget to\n        # store len(Y) distances in each row of output.\n        #\n        # Note:\n        #  - this will get at least 1 row, even if 1 row of distances will\n        #    exceed working_memory.\n        #  - this does not account for any temporary memory usage while\n        #    calculating distances (e.g. difference of vectors in manhattan\n        #    distance.\n        chunk_n_rows = get_chunk_n_rows(\n            row_bytes=8 * _num_samples(Y),\n            max_n_rows=n_samples_X,\n            working_memory=working_memory,\n        )\n        slices = gen_batches(n_samples_X, chunk_n_rows)\n\n    # precompute data-derived metric params\n    params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n    kwds.update(**params)\n\n    for sl in slices:\n        if sl.start == 0 and sl.stop == n_samples_X:\n            X_chunk = X  # enable optimised paths for X is Y\n        else:\n            X_chunk = X[sl]\n        D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)\n        if (X is Y or Y is None) and PAIRWISE_DISTANCE_FUNCTIONS.get(\n            metric, None\n        ) is euclidean_distances:\n            # zeroing diagonal, taking care of aliases of \"euclidean\",\n            # i.e. \"l2\"\n            D_chunk.flat[sl.start :: _num_samples(X) + 1] = 0\n        if reduce_func is not None:\n            chunk_size = D_chunk.shape[0]\n            D_chunk = reduce_func(D_chunk, sl.start)\n            _check_chunk_size(D_chunk, chunk_size)\n        yield D_chunk",
    "scikit-learn.sklearn.utils._mask._get_mask": "def _get_mask(X, value_to_mask):\n    \"\"\"Compute the boolean mask X == value_to_mask.\n\n    Parameters\n    ----------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Input data, where ``n_samples`` is the number of samples and\n        ``n_features`` is the number of features.\n\n    value_to_mask : {int, float}\n        The value which is to be masked in X.\n\n    Returns\n    -------\n    X_mask : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Missing mask.\n    \"\"\"\n    if not sp.issparse(X):\n        # For all cases apart of a sparse input where we need to reconstruct\n        # a sparse output\n        return _get_dense_mask(X, value_to_mask)\n\n    Xt = _get_dense_mask(X.data, value_to_mask)\n\n    sparse_constructor = sp.csr_matrix if X.format == \"csr\" else sp.csc_matrix\n    Xt_sparse = sparse_constructor(\n        (Xt, X.indices.copy(), X.indptr.copy()), shape=X.shape, dtype=bool\n    )\n\n    return Xt_sparse",
    "scikit-learn.sklearn.utils._missing.is_scalar_nan": "def is_scalar_nan(x):\n    \"\"\"Test if x is NaN.\n\n    This function is meant to overcome the issue that np.isnan does not allow\n    non-numerical types as input, and that np.nan is not float('nan').\n\n    Parameters\n    ----------\n    x : any type\n        Any scalar value.\n\n    Returns\n    -------\n    bool\n        Returns true if x is NaN, and false otherwise.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.utils._missing import is_scalar_nan\n    >>> is_scalar_nan(np.nan)\n    True\n    >>> is_scalar_nan(float(\"nan\"))\n    True\n    >>> is_scalar_nan(None)\n    False\n    >>> is_scalar_nan(\"\")\n    False\n    >>> is_scalar_nan([np.nan])\n    False\n    \"\"\"\n    return (\n        not isinstance(x, numbers.Integral)\n        and isinstance(x, numbers.Real)\n        and math.isnan(x)\n    )",
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e",
    "scikit-learn.sklearn.utils.validation.check_is_fitted": "def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):\n    \"\"\"Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by verifying the presence of\n    fitted attributes (ending with a trailing underscore) and otherwise\n    raises a :class:`~sklearn.exceptions.NotFittedError` with the given message.\n\n    If an estimator does not set any attributes with a trailing underscore, it\n    can define a ``__sklearn_is_fitted__`` method returning a boolean to\n    specify if the estimator is fitted or not. See\n    :ref:`sphx_glr_auto_examples_developing_estimators_sklearn_is_fitted.py`\n    for an example on how to use the API.\n\n    If no `attributes` are passed, this function will pass if an estimator is stateless.\n    An estimator can indicate it's stateless by setting the `requires_fit` tag. See\n    :ref:`estimator_tags` for more information. Note that the `requires_fit` tag\n    is ignored if `attributes` are passed.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator instance for which the check is performed.\n\n    attributes : str, list or tuple of str, default=None\n        Attribute name(s) given as string or a list/tuple of strings\n        Eg.: ``[\"coef_\", \"estimator_\", ...], \"coef_\"``\n\n        If `None`, `estimator` is considered fitted if there exist an\n        attribute that ends with a underscore and does not start with double\n        underscore.\n\n    msg : str, default=None\n        The default error message is, \"This %(name)s instance is not fitted\n        yet. Call 'fit' with appropriate arguments before using this\n        estimator.\"\n\n        For custom messages if \"%(name)s\" is present in the message string,\n        it is substituted for the estimator name.\n\n        Eg. : \"Estimator, %(name)s, must be fitted before sparsifying\".\n\n    all_or_any : callable, {all, any}, default=all\n        Specify whether all or any of the given attributes must exist.\n\n    Raises\n    ------\n    TypeError\n        If the estimator is a class or not an estimator instance\n\n    NotFittedError\n        If the attributes are not found.\n\n    Examples\n    --------\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.utils.validation import check_is_fitted\n    >>> from sklearn.exceptions import NotFittedError\n    >>> lr = LogisticRegression()\n    >>> try:\n    ...     check_is_fitted(lr)\n    ... except NotFittedError as exc:\n    ...     print(f\"Model is not fitted yet.\")\n    Model is not fitted yet.\n    >>> lr.fit([[1, 2], [1, 3]], [1, 0])\n    LogisticRegression()\n    >>> check_is_fitted(lr)\n    \"\"\"\n    if isclass(estimator):\n        raise TypeError(\"{} is a class, not an instance.\".format(estimator))\n    if msg is None:\n        msg = (\n            \"This %(name)s instance is not fitted yet. Call 'fit' with \"\n            \"appropriate arguments before using this estimator.\"\n        )\n\n    if not hasattr(estimator, \"fit\"):\n        raise TypeError(\"%s is not an estimator instance.\" % (estimator))\n\n    tags = get_tags(estimator)\n\n    if not tags.requires_fit and attributes is None:\n        return\n\n    if not _is_fitted(estimator, attributes, all_or_any):\n        raise NotFittedError(msg % {\"name\": type(estimator).__name__})",
    "scikit-learn.sklearn.utils.validation.validate_data": "def validate_data(\n    _estimator,\n    /,\n    X=\"no_validation\",\n    y=\"no_validation\",\n    reset=True,\n    validate_separately=False,\n    skip_check_array=False,\n    **check_params,\n):\n    \"\"\"Validate input data and set or check feature names and counts of the input.\n\n    This helper function should be used in an estimator that requires input\n    validation. This mutates the estimator and sets the `n_features_in_` and\n    `feature_names_in_` attributes if `reset=True`.\n\n    .. versionadded:: 1.6\n\n    Parameters\n    ----------\n    _estimator : estimator instance\n        The estimator to validate the input for.\n\n    X : {array-like, sparse matrix, dataframe} of shape \\\n            (n_samples, n_features), default='no validation'\n        The input samples.\n        If `'no_validation'`, no validation is performed on `X`. This is\n        useful for meta-estimator which can delegate input validation to\n        their underlying estimator(s). In that case `y` must be passed and\n        the only accepted `check_params` are `multi_output` and\n        `y_numeric`.\n\n    y : array-like of shape (n_samples,), default='no_validation'\n        The targets.\n\n        - If `None`, :func:`~sklearn.utils.check_array` is called on `X`. If\n          the estimator's `requires_y` tag is True, then an error will be raised.\n        - If `'no_validation'`, :func:`~sklearn.utils.check_array` is called\n          on `X` and the estimator's `requires_y` tag is ignored. This is a default\n          placeholder and is never meant to be explicitly set. In that case `X` must be\n          passed.\n        - Otherwise, only `y` with `_check_y` or both `X` and `y` are checked with\n          either :func:`~sklearn.utils.check_array` or\n          :func:`~sklearn.utils.check_X_y` depending on `validate_separately`.\n\n    reset : bool, default=True\n        Whether to reset the `n_features_in_` attribute.\n        If False, the input will be checked for consistency with data\n        provided when reset was last True.\n\n        .. note::\n\n           It is recommended to call `reset=True` in `fit` and in the first\n           call to `partial_fit`. All other methods that validate `X`\n           should set `reset=False`.\n\n    validate_separately : False or tuple of dicts, default=False\n        Only used if `y` is not `None`.\n        If `False`, call :func:`~sklearn.utils.check_X_y`. Else, it must be a tuple of\n        kwargs to be used for calling :func:`~sklearn.utils.check_array` on `X` and `y`\n        respectively.\n\n        `estimator=self` is automatically added to these dicts to generate\n        more informative error message in case of invalid input data.\n\n    skip_check_array : bool, default=False\n        If `True`, `X` and `y` are unchanged and only `feature_names_in_` and\n        `n_features_in_` are checked. Otherwise, :func:`~sklearn.utils.check_array`\n        is called on `X` and `y`.\n\n    **check_params : kwargs\n        Parameters passed to :func:`~sklearn.utils.check_array` or\n        :func:`~sklearn.utils.check_X_y`. Ignored if validate_separately\n        is not False.\n\n        `estimator=self` is automatically added to these params to generate\n        more informative error message in case of invalid input data.\n\n    Returns\n    -------\n    out : {ndarray, sparse matrix} or tuple of these\n        The validated input. A tuple is returned if both `X` and `y` are\n        validated.\n    \"\"\"\n    _check_feature_names(_estimator, X, reset=reset)\n    tags = get_tags(_estimator)\n    if y is None and tags.target_tags.required:\n        raise ValueError(\n            f\"This {_estimator.__class__.__name__} estimator \"\n            \"requires y to be passed, but the target y is None.\"\n        )\n\n    no_val_X = isinstance(X, str) and X == \"no_validation\"\n    no_val_y = y is None or (isinstance(y, str) and y == \"no_validation\")\n\n    if no_val_X and no_val_y:\n        raise ValueError(\"Validation should be done on X, y or both.\")\n\n    default_check_params = {\"estimator\": _estimator}\n    check_params = {**default_check_params, **check_params}\n\n    if skip_check_array:\n        if not no_val_X and no_val_y:\n            out = X\n        elif no_val_X and not no_val_y:\n            out = y\n        else:\n            out = X, y\n    elif not no_val_X and no_val_y:\n        out = check_array(X, input_name=\"X\", **check_params)\n    elif no_val_X and not no_val_y:\n        out = _check_y(y, **check_params)\n    else:\n        if validate_separately:\n            # We need this because some estimators validate X and y\n            # separately, and in general, separately calling check_array()\n            # on X and y isn't equivalent to just calling check_X_y()\n            # :(\n            check_X_params, check_y_params = validate_separately\n            if \"estimator\" not in check_X_params:\n                check_X_params = {**default_check_params, **check_X_params}\n            X = check_array(X, input_name=\"X\", **check_X_params)\n            if \"estimator\" not in check_y_params:\n                check_y_params = {**default_check_params, **check_y_params}\n            y = check_array(y, input_name=\"y\", **check_y_params)\n        else:\n            X, y = check_X_y(X, y, **check_params)\n        out = X, y\n\n    if not no_val_X and check_params.get(\"ensure_2d\", True):\n        _check_n_features(_estimator, X, reset=reset)\n\n    return out"
}