{
    "sympy.sympy.core.add._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all(term._eval_is_polynomial(syms) for term in self.args)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return True",
    "sympy.sympy.core.mul._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all(term._eval_is_polynomial(syms) for term in self.args)",
    "sympy.sympy.core.numbers.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    if self.exp.has(*syms):\n        return False\n\n    if self.base.has(*syms):\n        return bool(self.base._eval_is_polynomial(syms) and\n            self.exp.is_Integer and (self.exp >= 0))\n    else:\n        return True",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False"
}