{
    "scikit-learn.sklearn.calibration.predict": "def predict(self, X):\n    \"\"\"Predict new data by linear interpolation.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples,) or (n_samples, n_classes)\n        Data to predict from.\n\n        This should be the output of `decision_function` or `predict_proba`.\n        If the input appears to be probabilities (i.e., values between 0 and 1\n        that sum to 1 across classes), it will be converted to logits using\n        `np.log(p + eps)`.\n\n        Binary decision function outputs (1D) will be converted to two-class\n        logits of the form (-x, x). For shapes of the form (n_samples, 1), the\n        same process applies.\n\n    Returns\n    -------\n    X_ : ndarray of shape (n_samples, n_classes)\n         The predicted data.\n    \"\"\"\n    logits = _convert_to_logits(X)\n    return softmax(self.beta_ * logits)",
    "scikit-learn.sklearn.frozen._frozen.__getattr__": "def __getattr__(self, name):\n    # `estimator`'s attributes are now accessible except `fit_predict` and\n    # `fit_transform`\n    if name in [\"fit_predict\", \"fit_transform\"]:\n        raise AttributeError(f\"{name} is not available for frozen estimators.\")\n    return getattr(self.estimator, name)",
    "scikit-learn.sklearn.isotonic.predict": "def predict(self, T):\n    \"\"\"Predict new data by linear interpolation.\n\n    Parameters\n    ----------\n    T : array-like of shape (n_samples,) or (n_samples, 1)\n        Data to transform.\n\n    Returns\n    -------\n    y_pred : ndarray of shape (n_samples,)\n        Transformed data.\n    \"\"\"\n    return self._transform(T)",
    "scikit-learn.sklearn.pipeline.classes_": "@property\ndef classes_(self):\n    \"\"\"The classes labels. Only exist if the last step is a classifier.\"\"\"\n    return self.steps[-1][1].classes_",
    "scikit-learn.sklearn.preprocessing._label.transform": "def transform(self, y):\n    \"\"\"Transform labels to normalized encoding.\n\n    Parameters\n    ----------\n    y : array-like of shape (n_samples,)\n        Target values.\n\n    Returns\n    -------\n    y : array-like of shape (n_samples,)\n        Labels as normalized encodings.\n    \"\"\"\n    check_is_fitted(self)\n    xp, _ = get_namespace(y)\n    y = column_or_1d(y, dtype=self.classes_.dtype, warn=True)\n    # transform of empty array is empty array\n    if _num_samples(y) == 0:\n        return xp.asarray([])\n\n    return _encode(y, uniques=self.classes_)",
    "scikit-learn.sklearn.preprocessing._label.fit": "def fit(self, y):\n    \"\"\"Fit label encoder.\n\n    Parameters\n    ----------\n    y : array-like of shape (n_samples,)\n        Target values.\n\n    Returns\n    -------\n    self : returns an instance of self.\n        Fitted label encoder.\n    \"\"\"\n    y = column_or_1d(y, warn=True)\n    self.classes_ = _unique(y)\n    return self",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils._response._get_response_values": "def _get_response_values(\n    estimator,\n    X,\n    response_method,\n    pos_label=None,\n    return_response_method_used=False,\n):\n    \"\"\"Compute the response values of a classifier, an outlier detector, or a regressor.\n\n    The response values are predictions such that it follows the following shape:\n\n    - for binary classification, it is a 1d array of shape `(n_samples,)`;\n    - for multiclass classification, it is a 2d array of shape `(n_samples, n_classes)`;\n    - for multilabel classification, it is a 2d array of shape `(n_samples, n_outputs)`;\n    - for outlier detection, it is a 1d array of shape `(n_samples,)`;\n    - for regression, it is a 1d array of shape `(n_samples,)`.\n\n    If `estimator` is a binary classifier, also return the label for the\n    effective positive class.\n\n    This utility is used primarily in the displays and the scikit-learn scorers.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Fitted classifier, outlier detector, or regressor or a\n        fitted :class:`~sklearn.pipeline.Pipeline` in which the last estimator is a\n        classifier, an outlier detector, or a regressor.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input values.\n\n    response_method : {\"predict_proba\", \"predict_log_proba\", \"decision_function\", \\\n            \"predict\"} or list of such str\n        Specifies the response method to use get prediction from an estimator\n        (i.e. :term:`predict_proba`, :term:`predict_log_proba`,\n        :term:`decision_function` or :term:`predict`). Possible choices are:\n\n        - if `str`, it corresponds to the name to the method to return;\n        - if a list of `str`, it provides the method names in order of\n          preference. The method returned corresponds to the first method in\n          the list and which is implemented by `estimator`.\n\n    pos_label : int, float, bool or str, default=None\n        The class considered as the positive class when computing\n        the metrics. If `None` and target is 'binary', `estimators.classes_[1]` is\n        considered as the positive class.\n\n    return_response_method_used : bool, default=False\n        Whether to return the response method used to compute the response\n        values.\n\n        .. versionadded:: 1.4\n\n    Returns\n    -------\n    y_pred : ndarray of shape (n_samples,), (n_samples, n_classes) or \\\n            (n_samples, n_outputs)\n        Target scores calculated from the provided `response_method`\n        and `pos_label`.\n\n    pos_label : int, float, bool, str or None\n        The class considered as the positive class when computing\n        the metrics. Returns `None` if `estimator` is a regressor or an outlier\n        detector.\n\n    response_method_used : str\n        The response method used to compute the response values. Only returned\n        if `return_response_method_used` is `True`.\n\n        .. versionadded:: 1.4\n\n    Raises\n    ------\n    ValueError\n        If `pos_label` is not a valid label.\n        If the shape of `y_pred` is not consistent for binary classifier.\n        If the response method can be applied to a classifier only and\n        `estimator` is a regressor.\n    \"\"\"\n    from sklearn.base import is_classifier, is_outlier_detector\n\n    if is_classifier(estimator):\n        prediction_method = _check_response_method(estimator, response_method)\n        classes = estimator.classes_\n        target_type = type_of_target(classes)\n\n        if target_type in (\"binary\", \"multiclass\"):\n            if pos_label is not None and pos_label not in classes.tolist():\n                raise ValueError(\n                    f\"pos_label={pos_label} is not a valid label: It should be \"\n                    f\"one of {classes}\"\n                )\n            elif pos_label is None and target_type == \"binary\":\n                pos_label = classes[-1]\n\n        y_pred = prediction_method(X)\n\n        if prediction_method.__name__ in (\"predict_proba\", \"predict_log_proba\"):\n            y_pred = _process_predict_proba(\n                y_pred=y_pred,\n                target_type=target_type,\n                classes=classes,\n                pos_label=pos_label,\n            )\n        elif prediction_method.__name__ == \"decision_function\":\n            y_pred = _process_decision_function(\n                y_pred=y_pred,\n                target_type=target_type,\n                classes=classes,\n                pos_label=pos_label,\n            )\n    elif is_outlier_detector(estimator):\n        prediction_method = _check_response_method(estimator, response_method)\n        y_pred, pos_label = prediction_method(X), None\n    else:  # estimator is a regressor\n        if response_method != \"predict\":\n            raise ValueError(\n                f\"{estimator.__class__.__name__} should either be a classifier to be \"\n                f\"used with response_method={response_method} or the response_method \"\n                \"should be 'predict'. Got a regressor with response_method=\"\n                f\"{response_method} instead.\"\n            )\n        prediction_method = estimator.predict\n        y_pred, pos_label = prediction_method(X), None\n\n    if return_response_method_used:\n        return y_pred, pos_label, prediction_method.__name__\n    return y_pred, pos_label",
    "scikit-learn.sklearn.utils.validation._check_response_method": "def _check_response_method(estimator, response_method):\n    \"\"\"Check if `response_method` is available in estimator and return it.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Classifier or regressor to check.\n\n    response_method : {\"predict_proba\", \"predict_log_proba\", \"decision_function\",\n            \"predict\"} or list of such str\n        Specifies the response method to use get prediction from an estimator\n        (i.e. :term:`predict_proba`, :term:`predict_log_proba`,\n        :term:`decision_function` or :term:`predict`). Possible choices are:\n        - if `str`, it corresponds to the name to the method to return;\n        - if a list of `str`, it provides the method names in order of\n          preference. The method returned corresponds to the first method in\n          the list and which is implemented by `estimator`.\n\n    Returns\n    -------\n    prediction_method : callable\n        Prediction method of estimator.\n\n    Raises\n    ------\n    AttributeError\n        If `response_method` is not available in `estimator`.\n    \"\"\"\n    if isinstance(response_method, str):\n        list_methods = [response_method]\n    else:\n        list_methods = response_method\n\n    prediction_method = [getattr(estimator, method, None) for method in list_methods]\n    prediction_method = reduce(lambda x, y: x or y, prediction_method)\n    if prediction_method is None:\n        raise AttributeError(\n            f\"{estimator.__class__.__name__} has none of the following attributes: \"\n            f\"{', '.join(list_methods)}.\"\n        )\n\n    return prediction_method",
    "scikit-learn.sklearn.utils.validation._num_samples": "def _num_samples(x):\n    \"\"\"Return number of samples in array-like x.\"\"\"\n    message = \"Expected sequence or array-like, got %s\" % type(x)\n    if hasattr(x, \"fit\") and callable(x.fit):\n        # Don't get num_samples from an ensembles length!\n        raise TypeError(message)\n\n    if _use_interchange_protocol(x):\n        return x.__dataframe__().num_rows()\n\n    if not hasattr(x, \"__len__\") and not hasattr(x, \"shape\"):\n        if hasattr(x, \"__array__\"):\n            xp, _ = get_namespace(x)\n            x = xp.asarray(x)\n        else:\n            raise TypeError(message)\n\n    if hasattr(x, \"shape\") and x.shape is not None:\n        if len(x.shape) == 0:\n            raise TypeError(\n                \"Input should have at least 1 dimension i.e. satisfy \"\n                f\"`len(x.shape) > 0`, got scalar `{x!r}` instead.\"\n            )\n        # Check that shape is returning an integer or default to len\n        # Dask dataframes may not return numeric shape[0] value\n        if isinstance(x.shape[0], numbers.Integral):\n            return x.shape[0]\n\n    try:\n        return len(x)\n    except TypeError as type_error:\n        raise TypeError(message) from type_error"
}