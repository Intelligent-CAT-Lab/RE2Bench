{
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.exprtools.factor_terms": "def factor_terms(expr: Expr | complex, radical=False, clear=False, fraction=False, sign=True) -> Expr:\n    \"\"\"Remove common factors from terms in all arguments without\n    changing the underlying structure of the expr. No expansion or\n    simplification (and no processing of non-commutatives) is performed.\n\n    Parameters\n    ==========\n\n    radical: bool, optional\n        If radical=True then a radical common to all terms will be factored\n        out of any Add sub-expressions of the expr.\n\n    clear : bool, optional\n        If clear=False (default) then coefficients will not be separated\n        from a single Add if they can be distributed to leave one or more\n        terms with integer coefficients.\n\n    fraction : bool, optional\n        If fraction=True (default is False) then a common denominator will be\n        constructed for the expression.\n\n    sign : bool, optional\n        If sign=True (default) then even if the only factor in common is a -1,\n        it will be factored out of the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_terms, Symbol\n    >>> from sympy.abc import x, y\n    >>> factor_terms(x + x*(2 + 4*y)**3)\n    x*(8*(2*y + 1)**3 + 1)\n    >>> A = Symbol('A', commutative=False)\n    >>> factor_terms(x*A + x*A + x*y*A)\n    x*(y*A + 2*A)\n\n    When ``clear`` is False, a rational will only be factored out of an\n    Add expression if all terms of the Add have coefficients that are\n    fractions:\n\n    >>> factor_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> factor_terms(x/2 + 1, clear=True)\n    (x + 2)/2\n\n    If a -1 is all that can be factored out, to *not* factor it out, the\n    flag ``sign`` must be False:\n\n    >>> factor_terms(-x - y)\n    -(x + y)\n    >>> factor_terms(-x - y, sign=False)\n    -x - y\n    >>> factor_terms(-2*x - 2*y, sign=False)\n    -2*(x + y)\n\n    See Also\n    ========\n\n    gcd_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.integrals.integrals import Integral\n        is_iterable = iterable(expr)\n\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n\n        if expr.is_Pow or expr.is_Function or \\\n                is_iterable or not hasattr(expr, 'args_cnc'):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n\n        if isinstance(expr, (Sum, Integral)):\n            return _factor_sum_int(expr,\n                radical=radical, clear=clear,\n                fraction=fraction, sign=sign)\n\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            # get a common negative (if there) which gcd_terms does not remove\n            if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None\n                       for a in list_args):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            # rebuild p not worrying about the order which gcd_terms will fix\n            p = Add._from_args(list_args)\n            p = gcd_terms(p,\n                isprimitive=True,\n                clear=clear,\n                fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(\n                *[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr2 = sympify(expr)\n    return do(expr2)",
    "sympy.sympy.core.function._mexpand": "def _mexpand(expr, recursive=False):\n    # expand multinomials and then expand products; this may not always\n    # be sufficient to give a fully expanded expression (see\n    # test_issue_8247_8354 in test_arit)\n    if expr is None:\n        return\n    was = None\n    while was != expr:\n        was, expr = expr, expand_mul(expand_multinomial(expr))\n        if not recursive:\n            break\n    return expr",
    "sympy.sympy.core.function.expand_mul": "def expand_mul(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False,\n    power_base=False, basic=False, multinomial=False, log=False)",
    "sympy.sympy.diffgeom.diffgeom.__new__": "def __new__(cls, coord_sys, index, **kwargs):\n    index = _sympify(index)\n    obj = super().__new__(cls, coord_sys, index)\n    obj._coord_sys = coord_sys\n    obj._index = index\n    return obj",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.polys.polytools.factor": "@public\ndef factor(f, *gens, deep=False, **args):\n    \"\"\"\n    Compute the factorization of expression, ``f``, into irreducibles. (To\n    factor an integer into primes, use ``factorint``.)\n\n    There two modes implemented: symbolic and formal. If ``f`` is not an\n    instance of :class:`Poly` and generators are not specified, then the\n    former mode is used. Otherwise, the formal mode is used.\n\n    In symbolic mode, :func:`factor` will traverse the expression tree and\n    factor its components without any prior expansion, unless an instance\n    of :class:`~.Add` is encountered (in this case formal factorization is\n    used). This way :func:`factor` can handle large or symbolic exponents.\n\n    By default, the factorization is computed over the rationals. To factor\n    over other domain, e.g. an algebraic or finite field, use appropriate\n    options: ``extension``, ``modulus`` or ``domain``.\n\n    Examples\n    ========\n\n    >>> from sympy import factor, sqrt, exp\n    >>> from sympy.abc import x, y\n\n    >>> factor(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)\n    2*(x + y)*(x**2 + 1)**2\n\n    >>> factor(x**2 + 1)\n    x**2 + 1\n    >>> factor(x**2 + 1, modulus=2)\n    (x + 1)**2\n    >>> factor(x**2 + 1, gaussian=True)\n    (x - I)*(x + I)\n\n    >>> factor(x**2 - 2, extension=sqrt(2))\n    (x - sqrt(2))*(x + sqrt(2))\n\n    >>> factor((x**2 - 1)/(x**2 + 4*x + 4))\n    (x - 1)*(x + 1)/(x + 2)**2\n    >>> factor((x**2 + 4*x + 4)**10000000*(x**2 + 1))\n    (x + 2)**20000000*(x**2 + 1)\n\n    By default, factor deals with an expression as a whole:\n\n    >>> eq = 2**(x**2 + 2*x + 1)\n    >>> factor(eq)\n    2**(x**2 + 2*x + 1)\n\n    If the ``deep`` flag is True then subexpressions will\n    be factored:\n\n    >>> factor(eq, deep=True)\n    2**((x + 1)**2)\n\n    If the ``fraction`` flag is False then rational expressions\n    will not be combined. By default it is True.\n\n    >>> factor(5*x + 3*exp(2 - 7*x), deep=True)\n    (5*x*exp(7*x) + 3*exp(2))*exp(-7*x)\n    >>> factor(5*x + 3*exp(2 - 7*x), deep=True, fraction=False)\n    5*x + 3*exp(2)*exp(-7*x)\n\n    See Also\n    ========\n    sympy.ntheory.factor_.factorint\n\n    \"\"\"\n    f = sympify(f)\n    if deep:\n        def _try_factor(expr):\n            \"\"\"\n            Factor, but avoid changing the expression when unable to.\n            \"\"\"\n            fac = factor(expr, *gens, **args)\n            if fac.is_Mul or fac.is_Pow:\n                return fac\n            return expr\n\n        f = bottom_up(f, _try_factor)\n        # clean up any subexpressions that may have been expanded\n        # while factoring out a larger expression\n        partials = {}\n        muladd = f.atoms(Mul, Add)\n        for p in muladd:\n            fac = factor(p, *gens, **args)\n            if (fac.is_Mul or fac.is_Pow) and fac != p:\n                partials[p] = fac\n        return f.xreplace(partials)\n\n    try:\n        return _generic_factor(f, gens, args, method='factor')\n    except PolynomialError:\n        if not f.is_commutative:\n            return factor_nc(f)\n        else:\n            raise",
    "sympy.sympy.simplify.trigsimp.<lambda>": "lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n",
    "sympy.sympy.simplify.trigsimp._is_Expr": "def _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if isinstance(e, Derivative):\n        return _is_Expr(e.expr)\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)",
    "sympy.sympy.simplify.trigsimp.<listcomp>": "return e.func(*[\n    _eapply(func, ei) if (cond is None or cond(ei)) else ei\n    for ei in e.args])\n",
    "sympy.sympy.vector.scalar.__new__": "def __new__(cls, index, system, pretty_str=None, latex_str=None):\n    from sympy.vector.coordsysrect import CoordSys3D\n    if pretty_str is None:\n        pretty_str = \"x{}\".format(index)\n    elif isinstance(pretty_str, Symbol):\n        pretty_str = pretty_str.name\n    if latex_str is None:\n        latex_str = \"x_{}\".format(index)\n    elif isinstance(latex_str, Symbol):\n        latex_str = latex_str.name\n\n    index = _sympify(index)\n    system = _sympify(system)\n    obj = super().__new__(cls, index, system)\n    if not isinstance(system, CoordSys3D):\n        raise TypeError(\"system should be a CoordSys3D\")\n    if index not in range(0, 3):\n        raise ValueError(\"Invalid index specified.\")\n    # The _id is used for equating purposes, and for hashing\n    obj._id = (index, system)\n    obj._name = obj.name = system._name + '.' + system._variable_names[index]\n    obj._pretty_form = '' + pretty_str\n    obj._latex_form = latex_str\n    obj._system = system\n\n    return obj"
}