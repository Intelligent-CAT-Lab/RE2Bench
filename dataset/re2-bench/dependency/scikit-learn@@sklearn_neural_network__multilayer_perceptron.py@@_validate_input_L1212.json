{
    "scikit-learn.sklearn.base.wrapper": "@functools.wraps(fit_method)\ndef wrapper(estimator, *args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n\n    # we don't want to validate again for each call to partial_fit\n    partial_fit_and_fitted = (\n        fit_method.__name__ == \"partial_fit\" and _is_fitted(estimator)\n    )\n\n    if not global_skip_validation and not partial_fit_and_fitted:\n        estimator._validate_params()\n\n    with config_context(\n        skip_parameter_validation=(\n            prefer_skip_nested_validation or global_skip_validation\n        )\n    ):\n        return fit_method(estimator, *args, **kwargs)",
    "scikit-learn.sklearn.preprocessing._label.__init__": "def __init__(self, *, neg_label=0, pos_label=1, sparse_output=False):\n    self.neg_label = neg_label\n    self.pos_label = pos_label\n    self.sparse_output = sparse_output",
    "scikit-learn.sklearn.preprocessing._label.transform": "def transform(self, y):\n    \"\"\"Transform multi-class labels to binary labels.\n\n    The output of transform is sometimes referred to by some authors as\n    the 1-of-K coding scheme.\n\n    Parameters\n    ----------\n    y : {array, sparse matrix} of shape (n_samples,) or \\\n            (n_samples, n_classes)\n        Target values. The 2-d matrix should only contain 0 and 1,\n        represents multilabel classification. Sparse matrix can be\n        CSR, CSC, COO, DOK, or LIL.\n\n    Returns\n    -------\n    Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n        Shape will be (n_samples, 1) for binary problems. Sparse matrix\n        will be of CSR format.\n    \"\"\"\n    check_is_fitted(self)\n\n    xp, is_array_api = get_namespace(y)\n\n    if is_array_api and self.sparse_output and not _is_numpy_namespace(xp):\n        raise ValueError(\n            \"`sparse_output=True` is not supported for array API \"\n            f\"namespace {xp.__name__}. \"\n            \"Use `sparse_output=False` to return a dense array instead.\"\n        )\n\n    y_is_multilabel = type_of_target(y).startswith(\"multilabel\")\n    if y_is_multilabel and not self.y_type_.startswith(\"multilabel\"):\n        raise ValueError(\"The object was not fitted with multilabel input.\")\n\n    return label_binarize(\n        y,\n        classes=self.classes_,\n        pos_label=self.pos_label,\n        neg_label=self.neg_label,\n        sparse_output=self.sparse_output,\n    )",
    "scikit-learn.sklearn.utils.multiclass.unique_labels": "def unique_labels(*ys):\n    \"\"\"Extract an ordered array of unique labels.\n\n    We don't allow:\n        - mix of multilabel and multiclass (single label) targets\n        - mix of label indicator matrix and anything else,\n          because there are no explicit labels)\n        - mix of label indicator matrices of different sizes\n        - mix of string and integer labels\n\n    At the moment, we also don't allow \"multiclass-multioutput\" input type.\n\n    Parameters\n    ----------\n    *ys : array-likes\n        Label values.\n\n    Returns\n    -------\n    out : ndarray of shape (n_unique_labels,)\n        An ordered array of unique labels.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import unique_labels\n    >>> unique_labels([3, 5, 5, 5, 7, 7])\n    array([3, 5, 7])\n    >>> unique_labels([1, 2, 3, 4], [2, 2, 3, 4])\n    array([1, 2, 3, 4])\n    >>> unique_labels([1, 2, 10], [5, 11])\n    array([ 1,  2,  5, 10, 11])\n    \"\"\"\n    ys = attach_unique(*ys, return_tuple=True)\n    xp, is_array_api_compliant = get_namespace(*ys)\n    if len(ys) == 0:\n        raise ValueError(\"No argument has been passed.\")\n    # Check that we don't mix label format\n\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n        raise ValueError(\"Mix type of y not allowed, got types %s\" % ys_types)\n\n    label_type = ys_types.pop()\n\n    # Check consistency for the indicator format\n    if (\n        label_type == \"multilabel-indicator\"\n        and len(\n            set(\n                check_array(y, accept_sparse=[\"csr\", \"csc\", \"coo\"]).shape[1] for y in ys\n            )\n        )\n        > 1\n    ):\n        raise ValueError(\n            \"Multi-label binary indicator input with different numbers of labels\"\n        )\n\n    # Get the unique set of labels\n    _unique_labels = _FN_UNIQUE_LABELS.get(label_type, None)\n    if not _unique_labels:\n        raise ValueError(\"Unknown label type: %s\" % repr(ys))\n\n    if is_array_api_compliant:\n        # array_api does not allow for mixed dtypes\n        unique_ys = xp.concat([_unique_labels(y, xp=xp) for y in ys])\n        return xp.unique_values(unique_ys)\n\n    ys_labels = set(\n        chain.from_iterable((i for i in _unique_labels(y, xp=xp)) for y in ys)\n    )\n    # Check that we don't mix string type with number type\n    if len(set(isinstance(label, str) for label in ys_labels)) > 1:\n        raise ValueError(\"Mix of label input types (string and number)\")\n\n    return xp.asarray(sorted(ys_labels))",
    "scikit-learn.sklearn.utils.validation.column_or_1d": "def column_or_1d(y, *, dtype=None, input_name=\"y\", warn=False, device=None):\n    \"\"\"Ravel column or 1d numpy array, else raises an error.\n\n    Parameters\n    ----------\n    y : array-like\n       Input data.\n\n    dtype : data-type, default=None\n        Data type for `y`.\n\n        .. versionadded:: 1.2\n\n    input_name : str, default=\"y\"\n        The data name used to construct the error message.\n\n        .. versionadded:: 1.8\n\n    warn : bool, default=False\n       To control display of warnings.\n\n    device : device, default=None\n        `device` object.\n        See the :ref:`Array API User Guide <array_api>` for more details.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    y : ndarray\n       Output data.\n\n    Raises\n    ------\n    ValueError\n        If `y` is not a 1D array or a 2D array with a single row or column.\n\n    Examples\n    --------\n    >>> from sklearn.utils.validation import column_or_1d\n    >>> column_or_1d([1, 1])\n    array([1, 1])\n    \"\"\"\n    xp, _ = get_namespace(y)\n    y = check_array(\n        y,\n        ensure_2d=False,\n        dtype=dtype,\n        input_name=input_name,\n        ensure_all_finite=False,\n        ensure_min_samples=0,\n    )\n\n    shape = y.shape\n    if len(shape) == 1:\n        return _asarray_with_order(\n            xp.reshape(y, (-1,)), order=\"C\", xp=xp, device=device\n        )\n    if len(shape) == 2 and shape[1] == 1:\n        if warn:\n            warnings.warn(\n                (\n                    \"A column-vector y was passed when a 1d array was\"\n                    \" expected. Please change the shape of y to \"\n                    \"(n_samples, ), for example using ravel().\"\n                ),\n                DataConversionWarning,\n                stacklevel=2,\n            )\n        return _asarray_with_order(\n            xp.reshape(y, (-1,)), order=\"C\", xp=xp, device=device\n        )\n\n    raise ValueError(\n        \"y should be a 1d array, got an array of shape {} instead.\".format(shape)\n    )",
    "scikit-learn.sklearn.utils.validation.validate_data": "def validate_data(\n    _estimator,\n    /,\n    X=\"no_validation\",\n    y=\"no_validation\",\n    reset=True,\n    validate_separately=False,\n    skip_check_array=False,\n    **check_params,\n):\n    \"\"\"Validate input data and set or check feature names and counts of the input.\n\n    This helper function should be used in an estimator that requires input\n    validation. This mutates the estimator and sets the `n_features_in_` and\n    `feature_names_in_` attributes if `reset=True`.\n\n    .. versionadded:: 1.6\n\n    Parameters\n    ----------\n    _estimator : estimator instance\n        The estimator to validate the input for.\n\n    X : {array-like, sparse matrix, dataframe} of shape \\\n            (n_samples, n_features), default='no validation'\n        The input samples.\n        If `'no_validation'`, no validation is performed on `X`. This is\n        useful for meta-estimator which can delegate input validation to\n        their underlying estimator(s). In that case `y` must be passed and\n        the only accepted `check_params` are `multi_output` and\n        `y_numeric`.\n\n    y : array-like of shape (n_samples,), default='no_validation'\n        The targets.\n\n        - If `None`, :func:`~sklearn.utils.check_array` is called on `X`. If\n          the estimator's `requires_y` tag is True, then an error will be raised.\n        - If `'no_validation'`, :func:`~sklearn.utils.check_array` is called\n          on `X` and the estimator's `requires_y` tag is ignored. This is a default\n          placeholder and is never meant to be explicitly set. In that case `X` must be\n          passed.\n        - Otherwise, only `y` with `_check_y` or both `X` and `y` are checked with\n          either :func:`~sklearn.utils.check_array` or\n          :func:`~sklearn.utils.check_X_y` depending on `validate_separately`.\n\n    reset : bool, default=True\n        Whether to reset the `n_features_in_` attribute.\n        If False, the input will be checked for consistency with data\n        provided when reset was last True.\n\n        .. note::\n\n           It is recommended to call `reset=True` in `fit` and in the first\n           call to `partial_fit`. All other methods that validate `X`\n           should set `reset=False`.\n\n    validate_separately : False or tuple of dicts, default=False\n        Only used if `y` is not `None`.\n        If `False`, call :func:`~sklearn.utils.check_X_y`. Else, it must be a tuple of\n        kwargs to be used for calling :func:`~sklearn.utils.check_array` on `X` and `y`\n        respectively.\n\n        `estimator=self` is automatically added to these dicts to generate\n        more informative error message in case of invalid input data.\n\n    skip_check_array : bool, default=False\n        If `True`, `X` and `y` are unchanged and only `feature_names_in_` and\n        `n_features_in_` are checked. Otherwise, :func:`~sklearn.utils.check_array`\n        is called on `X` and `y`.\n\n    **check_params : kwargs\n        Parameters passed to :func:`~sklearn.utils.check_array` or\n        :func:`~sklearn.utils.check_X_y`. Ignored if validate_separately\n        is not False.\n\n        `estimator=self` is automatically added to these params to generate\n        more informative error message in case of invalid input data.\n\n    Returns\n    -------\n    out : {ndarray, sparse matrix} or tuple of these\n        The validated input. A tuple is returned if both `X` and `y` are\n        validated.\n    \"\"\"\n    _check_feature_names(_estimator, X, reset=reset)\n    tags = get_tags(_estimator)\n    if y is None and tags.target_tags.required:\n        raise ValueError(\n            f\"This {_estimator.__class__.__name__} estimator \"\n            \"requires y to be passed, but the target y is None.\"\n        )\n\n    no_val_X = isinstance(X, str) and X == \"no_validation\"\n    no_val_y = y is None or (isinstance(y, str) and y == \"no_validation\")\n\n    if no_val_X and no_val_y:\n        raise ValueError(\"Validation should be done on X, y or both.\")\n\n    default_check_params = {\"estimator\": _estimator}\n    check_params = {**default_check_params, **check_params}\n\n    if skip_check_array:\n        if not no_val_X and no_val_y:\n            out = X\n        elif no_val_X and not no_val_y:\n            out = y\n        else:\n            out = X, y\n    elif not no_val_X and no_val_y:\n        out = check_array(X, input_name=\"X\", **check_params)\n    elif no_val_X and not no_val_y:\n        out = _check_y(y, **check_params)\n    else:\n        if validate_separately:\n            # We need this because some estimators validate X and y\n            # separately, and in general, separately calling check_array()\n            # on X and y isn't equivalent to just calling check_X_y()\n            # :(\n            check_X_params, check_y_params = validate_separately\n            if \"estimator\" not in check_X_params:\n                check_X_params = {**default_check_params, **check_X_params}\n            X = check_array(X, input_name=\"X\", **check_X_params)\n            if \"estimator\" not in check_y_params:\n                check_y_params = {**default_check_params, **check_y_params}\n            y = check_array(y, input_name=\"y\", **check_y_params)\n        else:\n            X, y = check_X_y(X, y, **check_params)\n        out = X, y\n\n    if not no_val_X and check_params.get(\"ensure_2d\", True):\n        _check_n_features(_estimator, X, reset=reset)\n\n    return out"
}