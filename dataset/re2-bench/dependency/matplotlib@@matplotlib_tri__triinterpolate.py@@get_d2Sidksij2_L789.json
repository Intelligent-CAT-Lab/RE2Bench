{
    "matplotlib.lib.matplotlib.tri._triinterpolate._scalar_vectorized": "def _scalar_vectorized(scalar, M):\n    \"\"\"\n    Scalar product between scalars and matrices.\n    \"\"\"\n    return scalar[:, np.newaxis, np.newaxis]*M",
    "matplotlib.lib.matplotlib.tri._triinterpolate._roll_vectorized": "def _roll_vectorized(M, roll_indices, axis):\n    \"\"\"\n    Roll an array of matrices along *axis* (0: rows, 1: columns) according to\n    an array of indices *roll_indices*.\n    \"\"\"\n    assert axis in [0, 1]\n    ndim = M.ndim\n    assert ndim == 3\n    ndim_roll = roll_indices.ndim\n    assert ndim_roll == 1\n    sh = M.shape\n    r, c = sh[-2:]\n    assert sh[0] == roll_indices.shape[0]\n    vec_indices = np.arange(sh[0], dtype=np.int32)\n\n    # Builds the rolled matrix\n    M_roll = np.empty_like(M)\n    if axis == 0:\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, (-roll_indices+ir) % r, ic]\n    else:  # 1\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, ir, (-roll_indices+ic) % c]\n    return M_roll",
    "matplotlib.lib.matplotlib.tri._triinterpolate._to_matrix_vectorized": "def _to_matrix_vectorized(M):\n    \"\"\"\n    Build an array of matrices from individuals np.arrays of identical shapes.\n\n    Parameters\n    ----------\n    M\n        ncols-list of nrows-lists of shape sh.\n\n    Returns\n    -------\n    M_res : np.array of shape (sh, nrow, ncols)\n        *M_res* satisfies ``M_res[..., i, j] = M[i][j]``.\n    \"\"\"\n    assert isinstance(M, (tuple, list))\n    assert all(isinstance(item, (tuple, list)) for item in M)\n    c_vec = np.asarray([len(item) for item in M])\n    assert np.all(c_vec-c_vec[0] == 0)\n    r = len(M)\n    c = c_vec[0]\n    M00 = np.asarray(M[0][0])\n    dt = M00.dtype\n    sh = [M00.shape[0], r, c]\n    M_ret = np.empty(sh, dtype=dt)\n    for irow in range(r):\n        for icol in range(c):\n            M_ret[:, irow, icol] = np.asarray(M[irow][icol])\n    return M_ret",
    "matplotlib.lib.matplotlib.tri._triinterpolate._extract_submatrices": "def _extract_submatrices(M, block_indices, block_size, axis):\n    \"\"\"\n    Extract selected blocks of a matrices *M* depending on parameters\n    *block_indices* and *block_size*.\n\n    Returns the array of extracted matrices *Mres* so that ::\n\n        M_res[..., ir, :] = M[(block_indices*block_size+ir), :]\n    \"\"\"\n    assert block_indices.ndim == 1\n    assert axis in [0, 1]\n\n    r, c = M.shape\n    if axis == 0:\n        sh = [block_indices.shape[0], block_size, c]\n    else:  # 1\n        sh = [block_indices.shape[0], r, block_size]\n\n    dt = M.dtype\n    M_res = np.empty(sh, dtype=dt)\n    if axis == 0:\n        for ir in range(block_size):\n            M_res[:, ir, :] = M[(block_indices*block_size+ir), :]\n    else:  # 1\n        for ic in range(block_size):\n            M_res[:, :, ic] = M[:, (block_indices*block_size+ic)]\n\n    return M_res"
}