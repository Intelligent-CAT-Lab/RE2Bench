{
    "sympy.sympy.concrete.expr_with_limits.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols in the object, excluding those\n    that take on a specific value (i.e. the dummy symbols).\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.abc import x, y\n    >>> Sum(x, (x, y, 1)).free_symbols\n    {y}\n    \"\"\"\n    # don't test for any special values -- nominal free symbols\n    # should be returned, e.g. don't return set() if the\n    # function is zero -- treat it like an unevaluated expression.\n    function, limits = self.function, self.limits\n    # mask off non-symbol integration variables that have\n    # more than themself as a free symbol\n    reps = {i[0]: i[0] if i[0].free_symbols == {i[0]} else Dummy()\n        for i in self.limits}\n    function = function.xreplace(reps)\n    isyms = function.free_symbols\n    for xab in limits:\n        v = reps[xab[0]]\n        if len(xab) == 1:\n            isyms.add(v)\n            continue\n        # take out the target symbol\n        if v in isyms:\n            isyms.remove(v)\n        # add in the new symbols\n        for i in xab[1:]:\n            isyms.update(i.free_symbols)\n    reps = {v: k for k, v in reps.items()}\n    return {reps.get(_, _) for _ in isyms}",
    "sympy.sympy.core.add._matches_simple": "def _matches_simple(self, expr, repl_dict):\n    # handle (w+3).matches('x+5') -> {w: x+2}\n    coeff, terms = self.as_coeff_add()\n    if len(terms) == 1:\n        return terms[0].matches(expr - coeff, repl_dict)\n    return",
    "sympy.sympy.core.add.matches": "def matches(self, expr, repl_dict=None, old=False):\n    return self._matches_commutative(expr, repl_dict, old)",
    "sympy.sympy.core.add._combine_inverse": "@staticmethod\ndef _combine_inverse(lhs, rhs):\n    \"\"\"\n    Returns lhs - rhs, but treats oo like a symbol so oo - oo\n    returns 0, instead of a nan.\n    \"\"\"\n    from sympy.simplify.simplify import signsimp\n    inf = (S.Infinity, S.NegativeInfinity)\n    if lhs.has(*inf) or rhs.has(*inf):\n        from .symbol import Dummy\n        oo = Dummy('oo')\n        reps = {\n            S.Infinity: oo,\n            S.NegativeInfinity: -oo}\n        ireps = {v: k for k, v in reps.items()}\n        eq = lhs.xreplace(reps) - rhs.xreplace(reps)\n        if eq.has(oo):\n            eq = eq.replace(\n                lambda x: x.is_Pow and x.base is oo,\n                lambda x: x.base)\n        rv = eq.xreplace(ireps)\n    else:\n        rv = lhs - rhs\n    srv = signsimp(rv)\n    return srv if srv.is_Number else rv",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule):\n    \"\"\"\n    Replace occurrences of objects within the expression.\n\n    Parameters\n    ==========\n\n    rule : dict-like\n        Expresses a replacement rule\n\n    Returns\n    =======\n\n    xreplace : the result of the replacement\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, pi, exp\n    >>> x, y, z = symbols('x y z')\n    >>> (1 + x*y).xreplace({x: pi})\n    pi*y + 1\n    >>> (1 + x*y).xreplace({x: pi, y: 2})\n    1 + 2*pi\n\n    Replacements occur only if an entire node in the expression tree is\n    matched:\n\n    >>> (x*y + z).xreplace({x*y: pi})\n    z + pi\n    >>> (x*y*z).xreplace({x*y: pi})\n    x*y*z\n    >>> (2*x).xreplace({2*x: y, x: z})\n    y\n    >>> (2*2*x).xreplace({2*x: y, x: z})\n    4*z\n    >>> (x + y + 2).xreplace({x + y: 2})\n    x + y + 2\n    >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n    x + exp(y) + 2\n\n    xreplace does not differentiate between free and bound symbols. In the\n    following, subs(x, y) would not change x since it is a bound symbol,\n    but xreplace does:\n\n    >>> from sympy import Integral\n    >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n    Integral(y, (y, 1, 2*y))\n\n    Trying to replace x with an expression raises an error:\n\n    >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n    ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n\n    \"\"\"\n    value, _ = self._xreplace(rule)\n    return value",
    "sympy.sympy.core.basic.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if self == expr:\n        if repl_dict is None:\n            return {}\n        return repl_dict.copy()",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.count_ops": "def count_ops(self, visual=False):\n    from .function import count_ops\n    return count_ops(self, visual)",
    "sympy.sympy.core.expr.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs) -> tuple[Expr, tuple[Expr, ...]]:\n    \"\"\"Return the tuple (c, args) where self is written as a Mul, ``m``.\n\n    c should be a Rational multiplied by any factors of the Mul that are\n    independent of deps.\n\n    args should be a tuple of all other factors of m; args is empty\n    if self is a Number or if self is independent of deps (when given).\n\n    This should be used when you do not know if self is a Mul or not but\n    you want to treat self as a Mul or if you want to process the\n    individual arguments of the tail of self as a Mul.\n\n    - if you know self is a Mul and want only the head, use self.args[0];\n    - if you do not want to process the arguments of the tail but need the\n      tail then use self.as_two_terms() which gives the head and tail;\n    - if you want to split self into an independent and dependent parts\n      use ``self.as_independent(*deps)``\n\n    >>> from sympy import S\n    >>> from sympy.abc import x, y\n    >>> (S(3)).as_coeff_mul()\n    (3, ())\n    >>> (3*x*y).as_coeff_mul()\n    (3, (x, y))\n    >>> (3*x*y).as_coeff_mul(x)\n    (3*y, (x,))\n    >>> (3*y).as_coeff_mul(x)\n    (3*y, ())\n    \"\"\"\n    if deps:\n        if not self.has(*deps):\n            return self, ()\n    return S.One, (self,)",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.function.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if not isinstance(expr, (AppliedUndef, Function)):\n        return None\n    if len(expr.args) not in self.nargs:\n        return None\n\n    if repl_dict is None:\n        repl_dict = {}\n    else:\n        repl_dict = repl_dict.copy()\n\n    repl_dict[self] = expr\n    return repl_dict",
    "sympy.sympy.core.function.free_symbols": "@property\ndef free_symbols(self):\n    return (self.expr.free_symbols - set(self.variables) |\n        set(self.point.free_symbols))",
    "sympy.sympy.core.function._coeff_isneg": "def _coeff_isneg(a):\n    \"\"\"Return True if the leading Number is negative.\n\n    Examples\n    ========\n\n    >>> from sympy.core.function import _coeff_isneg\n    >>> from sympy import S, Symbol, oo, pi\n    >>> _coeff_isneg(-3*pi)\n    True\n    >>> _coeff_isneg(S(3))\n    False\n    >>> _coeff_isneg(-oo)\n    True\n    >>> _coeff_isneg(Symbol('n', negative=True)) # coeff is 1\n    False\n\n    For matrix expressions:\n\n    >>> from sympy import MatrixSymbol, sqrt\n    >>> A = MatrixSymbol(\"A\", 3, 3)\n    >>> _coeff_isneg(-sqrt(2)*A)\n    True\n    >>> _coeff_isneg(sqrt(2)*A)\n    False\n    \"\"\"\n\n    if a.is_MatMul:\n        a = a.args[0]\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_extended_negative",
    "sympy.sympy.core.mul._matches_simple": "def _matches_simple(self, expr, repl_dict):\n    # handle (w*3).matches('x*5') -> {w: x*5/3}\n    coeff, terms = self.as_coeff_Mul()\n    terms = Mul.make_args(terms)\n    if len(terms) == 1:\n        newexpr = self.__class__._combine_inverse(expr, coeff)\n        return terms[0].matches(newexpr, repl_dict)\n    return",
    "sympy.sympy.core.mul.matches": "def matches(self, expr, repl_dict=None, old=False):\n    expr = sympify(expr)\n    if self.is_commutative and expr.is_commutative:\n        return self._matches_commutative(expr, repl_dict, old)\n    elif self.is_commutative is not expr.is_commutative:\n        return None\n\n    # Proceed only if both both expressions are non-commutative\n    c1, nc1 = self.args_cnc()\n    c2, nc2 = expr.args_cnc()\n    c1, c2 = [c or [1] for c in [c1, c2]]\n\n    # TODO: Should these be self.func?\n    comm_mul_self = Mul(*c1)\n    comm_mul_expr = Mul(*c2)\n\n    repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)\n\n    # If the commutative arguments didn't match and aren't equal, then\n    # then the expression as a whole doesn't match\n    if not repl_dict and c1 != c2:\n        return None\n\n    # Now match the non-commutative arguments, expanding powers to\n    # multiplications\n    nc1 = Mul._matches_expand_pows(nc1)\n    nc2 = Mul._matches_expand_pows(nc2)\n\n    repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)\n\n    return repl_dict or None",
    "sympy.sympy.core.mul._combine_inverse": "@staticmethod\ndef _combine_inverse(lhs, rhs):\n    \"\"\"\n    Returns lhs/rhs, but treats arguments like symbols, so things\n    like oo/oo return 1 (instead of a nan) and ``I`` behaves like\n    a symbol instead of sqrt(-1).\n    \"\"\"\n    from sympy.simplify.simplify import signsimp\n    from .symbol import Dummy\n    if lhs == rhs:\n        return S.One\n\n    def check(l, r):\n        if l.is_Float and r.is_comparable:\n            # if both objects are added to 0 they will share the same \"normalization\"\n            # and are more likely to compare the same. Since Add(foo, 0) will not allow\n            # the 0 to pass, we use __add__ directly.\n            return l.__add__(0) == r.evalf().__add__(0)\n        return False\n    if check(lhs, rhs) or check(rhs, lhs):\n        return S.One\n    if any(i.is_Pow or i.is_Mul for i in (lhs, rhs)):\n        # gruntz and limit wants a literal I to not combine\n        # with a power of -1\n        d = Dummy('I')\n        _i = {S.ImaginaryUnit: d}\n        i_ = {d: S.ImaginaryUnit}\n        a = lhs.xreplace(_i).as_powers_dict()\n        b = rhs.xreplace(_i).as_powers_dict()\n        blen = len(b)\n        for bi in tuple(b.keys()):\n            if bi in a:\n                a[bi] -= b.pop(bi)\n                if not a[bi]:\n                    a.pop(bi)\n        if len(b) != blen:\n            lhs = Mul(*[k**v for k, v in a.items()]).xreplace(i_)\n            rhs = Mul(*[k**v for k, v in b.items()]).xreplace(i_)\n    rv = lhs/rhs\n    srv = signsimp(rv)\n    return srv if srv.is_Number else rv",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__neg__": "def __neg__(self):\n    return S.Infinity",
    "sympy.sympy.core.numbers.__abs__": "def __abs__(self):\n    return S.Infinity",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.operations._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    \"\"\"Create new instance of own class with args exactly as provided by\n    caller but returning the self class identity if args is empty.\n\n    Examples\n    ========\n\n       This is handy when we want to optimize things, e.g.\n\n           >>> from sympy import Mul, S\n           >>> from sympy.abc import x, y\n           >>> e = Mul(3, x, y)\n           >>> e.args\n           (3, x, y)\n           >>> Mul(*e.args[1:])\n           x*y\n           >>> e._new_rawargs(*e.args[1:])  # the same as above, but faster\n           x*y\n\n       Note: use this with caution. There is no checking of arguments at\n       all. This is best used when you are rebuilding an Add or Mul after\n       simply removing one or more args. If, for example, modifications,\n       result in extra 1s being inserted they will show up in the result:\n\n           >>> m = (x*y)._new_rawargs(S.One, x); m\n           1*x\n           >>> m == x\n           False\n           >>> m.is_Mul\n           True\n\n       Another issue to be aware of is that the commutativity of the result\n       is based on the commutativity of self. If you are rebuilding the\n       terms that came from a commutative object then there will be no\n       problem, but if self was non-commutative then what you are\n       rebuilding may now be commutative.\n\n       Although this routine tries to do as little as possible with the\n       input, getting the commutativity right is important, so this level\n       of safety is enforced: commutativity will always be recomputed if\n       self is non-commutative and kwarg `reeval=False` has not been\n       passed.\n    \"\"\"\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    "sympy.sympy.core.operations.<lambda>": "args = tuple(sorted(args, key=lambda x:\n    x.args[0] if x.is_Mul and x.args[0].is_Number else\n    0))\n",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.core.power.matches": "def matches(self, expr, repl_dict=None, old=False):\n    expr = _sympify(expr)\n    if repl_dict is None:\n        repl_dict = {}\n\n    # special case, pattern = 1 and expr.exp can match to 0\n    if expr is S.One:\n        d = self.exp.matches(S.Zero, repl_dict)\n        if d is not None:\n            return d\n\n    # make sure the expression to be matched is an Expr\n    if not isinstance(expr, Expr):\n        return None\n\n    b, e = expr.as_base_exp()\n\n    # special case number\n    sb, se = self.as_base_exp()\n    if sb.is_Symbol and se.is_Integer and expr:\n        if e.is_rational:\n            return sb.matches(b**(e/se), repl_dict)\n        return sb.matches(expr**(1/se), repl_dict)\n\n    d = repl_dict.copy()\n    d = self.base.matches(b, d)\n    if d is None:\n        return None\n\n    d = self.exp.xreplace(d).matches(e, d)\n    if d is None:\n        return Expr.matches(self, expr, repl_dict)\n    return d",
    "sympy.sympy.core.sorting.ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    \"\"\"Return an iterator of the seq where keys are used to break ties\n    in a conservative fashion: if, after applying a key, there are no\n    ties then no other keys will be computed.\n\n    Two default keys will be applied if 1) keys are not provided or\n    2) the given keys do not resolve all ties (but only if ``default``\n    is True). The two keys are ``_nodes`` (which places smaller\n    expressions before large) and ``default_sort_key`` which (if the\n    ``sort_key`` for an object is defined properly) should resolve\n    any ties. This strategy is similar to sorting done by\n    ``Basic.compare``, but differs in that ``ordered`` never makes a\n    decision based on an objects name.\n\n    If ``warn`` is True then an error will be raised if there were no\n    keys remaining to break ties. This can be used if it was expected that\n    there should be no ties between items that are not identical.\n\n    Examples\n    ========\n\n    >>> from sympy import ordered, count_ops\n    >>> from sympy.abc import x, y\n\n    The count_ops is not sufficient to break ties in this list and the first\n    two items appear in their original order (i.e. the sorting is stable):\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n    ...    count_ops, default=False, warn=False))\n    ...\n    [y + 2, x + 2, x**2 + y + 3]\n\n    The default_sort_key allows the tie to be broken:\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n    ...\n    [x + 2, y + 2, x**2 + y + 3]\n\n    Here, sequences are sorted by length, then sum:\n\n    >>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n    ...    lambda x: len(x),\n    ...    lambda x: sum(x)]]\n    ...\n    >>> list(ordered(seq, keys, default=False, warn=False))\n    [[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]\n\n    If ``warn`` is True, an error will be raised if there were not\n    enough keys to break ties:\n\n    >>> list(ordered(seq, keys, default=False, warn=True))\n    Traceback (most recent call last):\n    ...\n    ValueError: not enough keys to break ties\n\n\n    Notes\n    =====\n\n    The decorated sort is one of the fastest ways to sort a sequence for\n    which special item comparison is desired: the sequence is decorated,\n    sorted on the basis of the decoration (e.g. making all letters lower\n    case) and then undecorated. If one wants to break ties for items that\n    have the same decorated value, a second key can be used. But if the\n    second key is expensive to compute then it is inefficient to decorate\n    all items with both keys: only those items having identical first key\n    values need to be decorated. This function applies keys successively\n    only when needed to break ties. By yielding an iterator, use of the\n    tie-breaker is delayed as long as possible.\n\n    This function is best used in cases when use of the first key is\n    expected to be a good hashing function; if there are no unique hashes\n    from application of a key, then that key should not have been used. The\n    exception, however, is that even if there are many collisions, if the\n    first group is small and one does not need to process all items in the\n    list then time will not be wasted sorting what one was not interested\n    in. For example, if one were looking for the minimum in a list and\n    there were several criteria used to define the sort order, then this\n    function would be good at returning that quickly if the first group\n    of candidates is small relative to the number of items being processed.\n\n    \"\"\"\n\n    d = defaultdict(list)\n    if keys:\n        if isinstance(keys, (list, tuple)):\n            keys = list(keys)\n            f = keys.pop(0)\n        else:\n            f = keys\n            keys = []\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n\n    for k, value in sorted(d.items()):\n        if len(value) > 1:\n            if keys:\n                value = ordered(value, keys, default, warn)\n            elif default:\n                value = ordered(value, (_nodes, default_sort_key,),\n                               default=False, warn=warn)\n            elif warn:\n                u = list(uniq(value))\n                if len(u) > 1:\n                    raise ValueError(\n                        'not enough keys to break ties: %s' % u)\n        yield from value",
    "sympy.sympy.core.symbol.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    return {self}",
    "sympy.sympy.core.symbol.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if any(expr.has(x) for x in self.exclude):\n        return None\n    if not all(f(expr) for f in self.properties):\n        return None\n    if repl_dict is None:\n        repl_dict = {}\n    else:\n        repl_dict = repl_dict.copy()\n    repl_dict[self] = expr\n    return repl_dict",
    "sympy.sympy.integrals.integrals.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols that will exist when the\n    integral is evaluated. This is useful if one is trying to\n    determine whether an integral depends on a certain\n    symbol or not.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x, (x, y, 1)).free_symbols\n    {y}\n\n    See Also\n    ========\n\n    sympy.concrete.expr_with_limits.ExprWithLimits.function\n    sympy.concrete.expr_with_limits.ExprWithLimits.limits\n    sympy.concrete.expr_with_limits.ExprWithLimits.variables\n    \"\"\"\n    return super().free_symbols",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.simplify.radsimp.collect": "def collect(expr, syms, func=None, evaluate=None, exact=False, distribute_order_term=True):\n    \"\"\"\n    Collect additive terms of an expression.\n\n    Explanation\n    ===========\n\n    This function collects additive terms of an expression with respect\n    to a list of expression up to powers with rational exponents. By the\n    term symbol here are meant arbitrary expressions, which can contain\n    powers, products, sums etc. In other words symbol is a pattern which\n    will be searched for in the expression's terms.\n\n    The input expression is not expanded by :func:`collect`, so user is\n    expected to provide an expression in an appropriate form. This makes\n    :func:`collect` more predictable as there is no magic happening behind the\n    scenes. However, it is important to note, that powers of products are\n    converted to products of powers using the :func:`~.expand_power_base`\n    function.\n\n    There are two possible types of output. First, if ``evaluate`` flag is\n    set, this function will return an expression with collected terms or\n    else it will return a dictionary with expressions up to rational powers\n    as keys and collected coefficients as values.\n\n    Examples\n    ========\n\n    >>> from sympy import S, collect, expand, factor, Wild\n    >>> from sympy.abc import a, b, c, x, y\n\n    This function can collect symbolic coefficients in polynomials or\n    rational expressions. It will manage to find all integer or rational\n    powers of collection variable::\n\n        >>> collect(a*x**2 + b*x**2 + a*x - b*x + c, x)\n        c + x**2*(a + b) + x*(a - b)\n\n    The same result can be achieved in dictionary form::\n\n        >>> d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)\n        >>> d[x**2]\n        a + b\n        >>> d[x]\n        a - b\n        >>> d[S.One]\n        c\n\n    You can also work with multivariate polynomials. However, remember that\n    this function is greedy so it will care only about a single symbol at time,\n    in specification order::\n\n        >>> collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])\n        x**2*(y + 1) + x*y + y*(a + 1)\n\n    Also more complicated expressions can be used as patterns::\n\n        >>> from sympy import sin, log\n        >>> collect(a*sin(2*x) + b*sin(2*x), sin(2*x))\n        (a + b)*sin(2*x)\n\n        >>> collect(a*x*log(x) + b*(x*log(x)), x*log(x))\n        x*(a + b)*log(x)\n\n    You can use wildcards in the pattern::\n\n        >>> w = Wild('w1')\n        >>> collect(a*x**y - b*x**y, w**y)\n        x**y*(a - b)\n\n    It is also possible to work with symbolic powers, although it has more\n    complicated behavior, because in this case power's base and symbolic part\n    of the exponent are treated as a single symbol::\n\n        >>> collect(a*x**c + b*x**c, x)\n        a*x**c + b*x**c\n        >>> collect(a*x**c + b*x**c, x**c)\n        x**c*(a + b)\n\n    However if you incorporate rationals to the exponents, then you will get\n    well known behavior::\n\n        >>> collect(a*x**(2*c) + b*x**(2*c), x**c)\n        x**(2*c)*(a + b)\n\n    Note also that all previously stated facts about :func:`collect` function\n    apply to the exponential function, so you can get::\n\n        >>> from sympy import exp\n        >>> collect(a*exp(2*x) + b*exp(2*x), exp(x))\n        (a + b)*exp(2*x)\n\n    If you are interested only in collecting specific powers of some symbols\n    then set ``exact`` flag to True::\n\n        >>> collect(a*x**7 + b*x**7, x, exact=True)\n        a*x**7 + b*x**7\n        >>> collect(a*x**7 + b*x**7, x**7, exact=True)\n        x**7*(a + b)\n\n    If you want to collect on any object containing symbols, set\n    ``exact`` to None:\n\n        >>> collect(x*exp(x) + sin(x)*y + sin(x)*2 + 3*x, x, exact=None)\n        x*exp(x) + 3*x + (y + 2)*sin(x)\n        >>> collect(a*x*y + x*y + b*x + x, [x, y], exact=None)\n        x*y*(a + 1) + x*(b + 1)\n\n    You can also apply this function to differential equations, where\n    derivatives of arbitrary order can be collected. Note that if you\n    collect with respect to a function or a derivative of a function, all\n    derivatives of that function will also be collected. Use\n    ``exact=True`` to prevent this from happening::\n\n        >>> from sympy import Derivative as D, collect, Function\n        >>> f = Function('f') (x)\n\n        >>> collect(a*D(f,x) + b*D(f,x), D(f,x))\n        (a + b)*Derivative(f(x), x)\n\n        >>> collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)\n        (a + b)*Derivative(f(x), (x, 2))\n\n        >>> collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)\n        a*Derivative(f(x), (x, 2)) + b*Derivative(f(x), (x, 2))\n\n        >>> collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)\n        (a + b)*f(x) + (a + b)*Derivative(f(x), x)\n\n    Or you can even match both derivative order and exponent at the same time::\n\n        >>> collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))\n        (a + b)*Derivative(f(x), (x, 2))**2\n\n    Finally, you can apply a function to each of the collected coefficients.\n    For example you can factorize symbolic coefficients of polynomial::\n\n        >>> f = expand((x + a + 1)**3)\n\n        >>> collect(f, x, factor)\n        x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3\n\n    .. note:: Arguments are expected to be in expanded form, so you might have\n              to call :func:`~.expand` prior to calling this function.\n\n    See Also\n    ========\n\n    collect_const, collect_sqrt, rcollect\n    \"\"\"\n    expr = sympify(expr)\n    syms = [sympify(i) for i in (syms if iterable(syms) else [syms])]\n\n    # replace syms[i] if it is not x, -x or has Wild symbols\n    cond = lambda x: x.is_Symbol or (-x).is_Symbol or bool(\n        x.atoms(Wild))\n    _, nonsyms = sift(syms, cond, binary=True)\n    if nonsyms:\n        reps = dict(zip(nonsyms, [Dummy(**assumptions(i)) for i in nonsyms]))\n        syms = [reps.get(s, s) for s in syms]\n        rv = collect(expr.subs(reps), syms,\n            func=func, evaluate=evaluate, exact=exact,\n            distribute_order_term=distribute_order_term)\n        urep = {v: k for k, v in reps.items()}\n        if not isinstance(rv, dict):\n            return rv.xreplace(urep)\n        else:\n            return {urep.get(k, k).xreplace(urep): v.xreplace(urep)\n                    for k, v in rv.items()}\n\n    # see if other expressions should be considered\n    if exact is None:\n        _syms = set()\n        for i in Add.make_args(expr):\n            if not i.has_free(*syms) or i in syms:\n                continue\n            if not i.is_Mul and i not in syms:\n                _syms.add(i)\n            else:\n                # identify compound generators\n                g = i._new_rawargs(*i.as_coeff_mul(*syms)[1])\n                if g not in syms:\n                    _syms.add(g)\n        simple = all(i.is_Pow and i.base in syms for i in _syms)\n        syms = syms + list(ordered(_syms))\n        if not simple:\n            return collect(expr, syms,\n            func=func, evaluate=evaluate, exact=False,\n            distribute_order_term=distribute_order_term)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    def make_expression(terms):\n        product = []\n\n        for term, rat, sym, deriv in terms:\n            if deriv is not None:\n                var, order = deriv\n                for _ in range(order):\n                    term = Derivative(term, var)\n\n            if sym is None:\n                if rat is S.One:\n                    product.append(term)\n                else:\n                    product.append(Pow(term, rat))\n            else:\n                product.append(Pow(term, rat*sym))\n\n        return Mul(*product)\n\n    def parse_derivative(deriv):\n        # scan derivatives tower in the input expression and return\n        # underlying function and maximal differentiation order\n        expr, sym, order = deriv.expr, deriv.variables[0], 1\n\n        for s in deriv.variables[1:]:\n            if s == sym:\n                order += 1\n            else:\n                raise NotImplementedError(\n                    'Improve MV Derivative support in collect')\n\n        while isinstance(expr, Derivative):\n            s0 = expr.variables[0]\n\n            if any(s != s0 for s in expr.variables):\n                raise NotImplementedError(\n                    'Improve MV Derivative support in collect')\n\n            if s0 == sym:\n                expr, order = expr.expr, order + len(expr.variables)\n            else:\n                break\n\n        return expr, (sym, Rational(order))\n\n    def parse_term(expr):\n        \"\"\"Parses expression expr and outputs tuple (sexpr, rat_expo,\n        sym_expo, deriv)\n        where:\n         - sexpr is the base expression\n         - rat_expo is the rational exponent that sexpr is raised to\n         - sym_expo is the symbolic exponent that sexpr is raised to\n         - deriv contains the derivatives of the expression\n\n         For example, the output of x would be (x, 1, None, None)\n         the output of 2**x would be (2, 1, x, None).\n        \"\"\"\n        rat_expo, sym_expo = S.One, None\n        sexpr, deriv = expr, None\n\n        if expr.is_Pow:\n            if isinstance(expr.base, Derivative):\n                sexpr, deriv = parse_derivative(expr.base)\n            else:\n                sexpr = expr.base\n\n            if expr.base == S.Exp1:\n                arg = expr.exp\n                if arg.is_Rational:\n                    sexpr, rat_expo = S.Exp1, arg\n                elif arg.is_Mul:\n                    coeff, tail = arg.as_coeff_Mul(rational=True)\n                    sexpr, rat_expo = exp(tail), coeff\n\n            elif expr.exp.is_Number:\n                rat_expo = expr.exp\n            else:\n                coeff, tail = expr.exp.as_coeff_Mul()\n\n                if coeff.is_Number:\n                    rat_expo, sym_expo = coeff, tail\n                else:\n                    sym_expo = expr.exp\n        elif isinstance(expr, exp):\n            arg = expr.exp\n            if arg.is_Rational:\n                sexpr, rat_expo = S.Exp1, arg\n            elif arg.is_Mul:\n                coeff, tail = arg.as_coeff_Mul(rational=True)\n                sexpr, rat_expo = exp(tail), coeff\n        elif isinstance(expr, Derivative):\n            sexpr, deriv = parse_derivative(expr)\n\n        return sexpr, rat_expo, sym_expo, deriv\n\n    def parse_expression(terms, pattern):\n        \"\"\"Parse terms searching for a pattern.\n        Terms is a list of tuples as returned by parse_terms;\n        Pattern is an expression treated as a product of factors.\n        \"\"\"\n        pattern = Mul.make_args(pattern)\n\n        if len(terms) < len(pattern):\n            # pattern is longer than matched product\n            # so no chance for positive parsing result\n            return None\n        else:\n            pattern = [parse_term(elem) for elem in pattern]\n\n            terms = terms[:]  # need a copy\n            elems, common_expo, has_deriv = [], None, False\n\n            for elem, e_rat, e_sym, e_ord in pattern:\n\n                if elem.is_Number and e_rat == 1 and e_sym is None:\n                    # a constant is a match for everything\n                    continue\n\n                for j in range(len(terms)):\n                    if terms[j] is None:\n                        continue\n\n                    term, t_rat, t_sym, t_ord = terms[j]\n\n                    # keeping track of whether one of the terms had\n                    # a derivative or not as this will require rebuilding\n                    # the expression later\n                    if t_ord is not None:\n                        has_deriv = True\n\n                    if (term.match(elem) is not None and\n                            (t_sym == e_sym or t_sym is not None and\n                            e_sym is not None and\n                            t_sym.match(e_sym) is not None)):\n                        if exact is False:\n                            # we don't have to be exact so find common exponent\n                            # for both expression's term and pattern's element\n                            expo = t_rat / e_rat\n\n                            if common_expo is None:\n                                # first time\n                                common_expo = expo\n                            else:\n                                # common exponent was negotiated before so\n                                # there is no chance for a pattern match unless\n                                # common and current exponents are equal\n                                if common_expo != expo:\n                                    common_expo = 1\n                        else:\n                            # we ought to be exact so all fields of\n                            # interest must match in every details\n                            if e_rat != t_rat or e_ord != t_ord:\n                                continue\n\n                        # found common term so remove it from the expression\n                        # and try to match next element in the pattern\n                        elems.append(terms[j])\n                        terms[j] = None\n\n                        break\n\n                else:\n                    # pattern element not found\n                    return None\n\n            return [_f for _f in terms if _f], elems, common_expo, has_deriv\n\n    if evaluate:\n        if expr.is_Add:\n            o = expr.getO() or 0\n            expr = expr.func(*[\n                    collect(a, syms, func, True, exact, distribute_order_term)\n                    for a in expr.args if a != o]) + o\n        elif expr.is_Mul:\n            return expr.func(*[\n                collect(term, syms, func, True, exact, distribute_order_term)\n                for term in expr.args])\n        elif expr.is_Pow:\n            b = collect(\n                expr.base, syms, func, True, exact, distribute_order_term)\n            return Pow(b, expr.exp)\n\n    syms = [expand_power_base(i, deep=False) for i in syms]\n\n    order_term = None\n\n    if distribute_order_term:\n        order_term = expr.getO()\n\n        if order_term is not None:\n            if order_term.has(*syms):\n                order_term = None\n            else:\n                expr = expr.removeO()\n\n    summa = [expand_power_base(i, deep=False) for i in Add.make_args(expr)]\n\n    collected, disliked = defaultdict(list), S.Zero\n    for product in summa:\n        c, nc = product.args_cnc(split_1=False)\n        args = list(ordered(c)) + nc\n        terms = [parse_term(i) for i in args]\n        small_first = True\n\n        for symbol in syms:\n            if isinstance(symbol, Derivative) and small_first:\n                terms = list(reversed(terms))\n                small_first = not small_first\n            result = parse_expression(terms, symbol)\n\n            if result is not None:\n                if not symbol.is_commutative:\n                    raise AttributeError(\"Can not collect noncommutative symbol\")\n\n                terms, elems, common_expo, has_deriv = result\n\n                # when there was derivative in current pattern we\n                # will need to rebuild its expression from scratch\n                if not has_deriv:\n                    margs = []\n                    for elem in elems:\n                        if elem[2] is None:\n                            e = elem[1]\n                        else:\n                            e = elem[1]*elem[2]\n                        margs.append(Pow(elem[0], e))\n                    index = Mul(*margs)\n                else:\n                    index = make_expression(elems)\n                terms = expand_power_base(make_expression(terms), deep=False)\n                index = expand_power_base(index, deep=False)\n                collected[index].append(terms)\n                break\n        else:\n            # none of the patterns matched\n            disliked += product\n    # add terms now for each key\n    collected = {k: Add(*v) for k, v in collected.items()}\n\n    if disliked is not S.Zero:\n        collected[S.One] = disliked\n\n    if order_term is not None:\n        for key, val in collected.items():\n            collected[key] = val + order_term\n\n    if func is not None:\n        collected = {\n            key: func(val) for key, val in collected.items()}\n\n    if evaluate:\n        return Add(*[key*val for key, val in collected.items()])\n    else:\n        return collected",
    "sympy.sympy.tensor.indexed.free_symbols": "@property\ndef free_symbols(self):\n    base_free_symbols = self.base.free_symbols\n    indices_free_symbols = {\n        fs for i in self.indices for fs in i.free_symbols}\n    if base_free_symbols:\n        return {self} | base_free_symbols | indices_free_symbols\n    else:\n        return indices_free_symbols",
    "sympy.sympy.utilities.iterables.sift": "def sift(seq, keyfunc, binary=False):\n    \"\"\"\n    Sift the sequence, ``seq`` according to ``keyfunc``.\n\n    Returns\n    =======\n\n    When ``binary`` is ``False`` (default), the output is a dictionary\n    where elements of ``seq`` are stored in a list keyed to the value\n    of keyfunc for that element. If ``binary`` is True then a tuple\n    with lists ``T`` and ``F`` are returned where ``T`` is a list\n    containing elements of seq for which ``keyfunc`` was ``True`` and\n    ``F`` containing those elements for which ``keyfunc`` was ``False``;\n    a ValueError is raised if the ``keyfunc`` is not binary.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities import sift\n    >>> from sympy.abc import x, y\n    >>> from sympy import sqrt, exp, pi, Tuple\n\n    >>> sift(range(5), lambda x: x % 2)\n    {0: [0, 2, 4], 1: [1, 3]}\n\n    sift() returns a defaultdict() object, so any key that has no matches will\n    give [].\n\n    >>> sift([x], lambda x: x.is_commutative)\n    {True: [x]}\n    >>> _[False]\n    []\n\n    Sometimes you will not know how many keys you will get:\n\n    >>> sift([sqrt(x), exp(x), (y**x)**2],\n    ...      lambda x: x.as_base_exp()[0])\n    {E: [exp(x)], x: [sqrt(x)], y: [y**(2*x)]}\n\n    Sometimes you expect the results to be binary; the\n    results can be unpacked by setting ``binary`` to True:\n\n    >>> sift(range(4), lambda x: x % 2, binary=True)\n    ([1, 3], [0, 2])\n    >>> sift(Tuple(1, pi), lambda x: x.is_rational, binary=True)\n    ([1], [pi])\n\n    A ValueError is raised if the predicate was not actually binary\n    (which is a good test for the logic where sifting is used and\n    binary results were expected):\n\n    >>> unknown = exp(1) - pi  # the rationality of this is unknown\n    >>> args = Tuple(1, pi, unknown)\n    >>> sift(args, lambda x: x.is_rational, binary=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: keyfunc gave non-binary output\n\n    The non-binary sifting shows that there were 3 keys generated:\n\n    >>> set(sift(args, lambda x: x.is_rational).keys())\n    {None, False, True}\n\n    If you need to sort the sifted items it might be better to use\n    ``ordered`` which can economically apply multiple sort keys\n    to a sequence while sorting.\n\n    See Also\n    ========\n\n    ordered\n\n    \"\"\"\n    if not binary:\n        m = defaultdict(list)\n        for i in seq:\n            m[keyfunc(i)].append(i)\n        return m\n    sift = F, T = [], []\n    for i in seq:\n        try:\n            sift[keyfunc(i)].append(i)\n        except (IndexError, TypeError):\n            raise ValueError('keyfunc gave non-binary output')\n    return T, F",
    "sympy.sympy.vector.scalar.free_symbols": "@property\ndef free_symbols(self):\n    return {self}"
}