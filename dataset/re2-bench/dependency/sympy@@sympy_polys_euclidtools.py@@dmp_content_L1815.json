{
    "sympy.sympy.polys.densearith.dmp_neg": "def dmp_neg(f: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_neg(x**2*y - x)\n    -x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_neg(_dup(f), K))\n\n    v = u - 1\n\n    return [ dmp_neg(cf, v, K) for cf in f ]",
    "sympy.sympy.polys.densebasic.dmp_LC": "def dmp_LC(f: dmp[Er], K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_LC\n\n    >>> f = ZZ.map([[1], [2, 3]])\n\n    >>> dmp_LC(f, ZZ)\n    [1]\n\n    \"\"\"\n    if not f:\n        return _ground_dmp(K.zero)\n    else:\n        return f[0]",
    "sympy.sympy.polys.densebasic.dmp_ground_LC": "def dmp_ground_LC(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the ground leading coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_LC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_LC(f, 2, ZZ)\n    1\n\n    \"\"\"\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n\n    return dup_LC(_dup(f), K)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densebasic.dmp_one_p": "def dmp_one_p(f: dmp[Er], u: int, K: Domain[Er]) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is one in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one_p\n\n    >>> dmp_one_p([[[ZZ(1)]]], 2, ZZ)\n    True\n\n    \"\"\"\n    return dmp_ground_p(f, K.one, u)",
    "sympy.sympy.polys.domains.algebraicfield.is_negative": "def is_negative(self, a):\n    \"\"\"Returns True if ``a`` is negative. \"\"\"\n    return self.dom.is_negative(a.LC())",
    "sympy.sympy.polys.domains.domain.is_negative": "def is_negative(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is negative. \"\"\"\n    return a < 0 # type: ignore",
    "sympy.sympy.polys.domains.expressiondomain.is_negative": "def is_negative(self, a):\n    \"\"\"Returns True if ``a`` is negative. \"\"\"\n    return a.ex.could_extract_minus_sign()",
    "sympy.sympy.polys.domains.gaussiandomains.is_negative": "def is_negative(self, a: Telem) -> bool:\n    \"\"\"Returns ``False`` for any ``GaussianElement``. \"\"\"\n    return False",
    "sympy.sympy.polys.domains.polynomialring.is_negative": "def is_negative(self, a):\n    \"\"\"Returns True if `LC(a)` is negative. \"\"\"\n    return self.domain.is_negative(a.LC)",
    "sympy.sympy.polys.euclidtools.dmp_gcd": "def dmp_gcd(f, g, u, K):\n    \"\"\"\n    Computes polynomial GCD of `f` and `g` in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_gcd(f, g)\n    x + y\n\n    \"\"\"\n    return dmp_inner_gcd(f, g, u, K)[0]"
}