{
    "scikit-learn.sklearn.base.get_params": "def get_params(self, deep=True):\n    \"\"\"\n    Get parameters for this estimator.\n\n    Parameters\n    ----------\n    deep : bool, default=True\n        If True, will return the parameters for this estimator and\n        contained subobjects that are estimators.\n\n    Returns\n    -------\n    params : dict\n        Parameter names mapped to their values.\n    \"\"\"\n    out = dict()\n    for key in self._get_param_names():\n        value = getattr(self, key)\n        if deep and hasattr(value, \"get_params\") and not isinstance(value, type):\n            deep_items = value.get_params().items()\n            out.update((key + \"__\" + k, val) for k, val in deep_items)\n        out[key] = value\n    return out",
    "scikit-learn.sklearn.gaussian_process.kernels.__repr__": "def __repr__(self):\n    return \"{0}(length_scale={1:.3g}, periodicity={2:.3g})\".format(\n        self.__class__.__name__, self.length_scale, self.periodicity\n    )",
    "scikit-learn.sklearn.metrics._scorer.__repr__": "def __repr__(self):\n    sign_string = \"\" if self._sign > 0 else \", greater_is_better=False\"\n    response_method_string = f\", response_method={self._response_method!r}\"\n    kwargs_string = \"\".join([f\", {k}={v}\" for k, v in self._kwargs.items()])\n\n    return (\n        f\"make_scorer({_get_func_repr_or_name(self._score_func)}{sign_string}\"\n        f\"{response_method_string}{kwargs_string})\"\n    )",
    "scikit-learn.sklearn.model_selection._split.__repr__": "def __repr__(self):\n    return _build_repr(self)",
    "scikit-learn.sklearn.pipeline.get_params": "def get_params(self, deep=True):\n    \"\"\"Get parameters for this estimator.\n\n    Returns the parameters given in the constructor as well as the\n    estimators contained within the `steps` of the `Pipeline`.\n\n    Parameters\n    ----------\n    deep : bool, default=True\n        If True, will return the parameters for this estimator and\n        contained subobjects that are estimators.\n\n    Returns\n    -------\n    params : mapping of string to any\n        Parameter names mapped to their values.\n    \"\"\"\n    return self._get_params(\"steps\", deep=deep)",
    "scikit-learn.sklearn.utils._pprint._safe_repr": "def _safe_repr(object, context, maxlevels, level, changed_only=False):\n    \"\"\"Same as the builtin _safe_repr, with added support for Estimator\n    objects.\"\"\"\n    typ = type(object)\n\n    if typ in pprint._builtin_scalars:\n        return repr(object), True, False\n\n    r = getattr(typ, \"__repr__\", None)\n    if issubclass(typ, dict) and r is dict.__repr__:\n        if not object:\n            return \"{}\", True, False\n        objid = id(object)\n        if maxlevels and level >= maxlevels:\n            return \"{...}\", False, objid in context\n        if objid in context:\n            return pprint._recursion(object), False, True\n        context[objid] = 1\n        readable = True\n        recursive = False\n        components = []\n        append = components.append\n        level += 1\n        saferepr = _safe_repr\n        items = sorted(object.items(), key=pprint._safe_tuple)\n        for k, v in items:\n            krepr, kreadable, krecur = saferepr(\n                k, context, maxlevels, level, changed_only=changed_only\n            )\n            vrepr, vreadable, vrecur = saferepr(\n                v, context, maxlevels, level, changed_only=changed_only\n            )\n            append(\"%s: %s\" % (krepr, vrepr))\n            readable = readable and kreadable and vreadable\n            if krecur or vrecur:\n                recursive = True\n        del context[objid]\n        return \"{%s}\" % \", \".join(components), readable, recursive\n\n    if (issubclass(typ, list) and r is list.__repr__) or (\n        issubclass(typ, tuple) and r is tuple.__repr__\n    ):\n        if issubclass(typ, list):\n            if not object:\n                return \"[]\", True, False\n            format = \"[%s]\"\n        elif len(object) == 1:\n            format = \"(%s,)\"\n        else:\n            if not object:\n                return \"()\", True, False\n            format = \"(%s)\"\n        objid = id(object)\n        if maxlevels and level >= maxlevels:\n            return format % \"...\", False, objid in context\n        if objid in context:\n            return pprint._recursion(object), False, True\n        context[objid] = 1\n        readable = True\n        recursive = False\n        components = []\n        append = components.append\n        level += 1\n        for o in object:\n            orepr, oreadable, orecur = _safe_repr(\n                o, context, maxlevels, level, changed_only=changed_only\n            )\n            append(orepr)\n            if not oreadable:\n                readable = False\n            if orecur:\n                recursive = True\n        del context[objid]\n        return format % \", \".join(components), readable, recursive\n\n    if issubclass(typ, BaseEstimator):\n        objid = id(object)\n        if maxlevels and level >= maxlevels:\n            return f\"{typ.__name__}(...)\", False, objid in context\n        if objid in context:\n            return pprint._recursion(object), False, True\n        context[objid] = 1\n        readable = True\n        recursive = False\n        if changed_only:\n            params = _changed_params(object)\n        else:\n            params = object.get_params(deep=False)\n        components = []\n        append = components.append\n        level += 1\n        saferepr = _safe_repr\n        items = sorted(params.items(), key=pprint._safe_tuple)\n        for k, v in items:\n            krepr, kreadable, krecur = saferepr(\n                k, context, maxlevels, level, changed_only=changed_only\n            )\n            vrepr, vreadable, vrecur = saferepr(\n                v, context, maxlevels, level, changed_only=changed_only\n            )\n            append(\"%s=%s\" % (krepr.strip(\"'\"), vrepr))\n            readable = readable and kreadable and vreadable\n            if krecur or vrecur:\n                recursive = True\n        del context[objid]\n        return (\"%s(%s)\" % (typ.__name__, \", \".join(components)), readable, recursive)\n\n    rep = repr(object)\n    return rep, (rep and not rep.startswith(\"<\")), False",
    "scikit-learn.sklearn.utils._pprint.__repr__": "def __repr__(self):\n    # needed for _dispatch[tuple.__repr__] not to be overridden\n    return super().__repr__()",
    "scikit-learn.sklearn.utils._pprint._changed_params": "def _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    init_func = getattr(estimator.__init__, \"deprecated_original\", estimator.__init__)\n    init_params = inspect.signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n\n    def has_changed(k, v):\n        if k not in init_params:  # happens if k is part of a **kwargs\n            return True\n        if init_params[k] == inspect._empty:  # k has no default value\n            return True\n        # try to avoid calling repr on nested estimators\n        if isinstance(v, BaseEstimator) and v.__class__ != init_params[k].__class__:\n            return True\n        # Use repr as a last resort. It may be expensive.\n        if repr(v) != repr(init_params[k]) and not (\n            is_scalar_nan(init_params[k]) and is_scalar_nan(v)\n        ):\n            return True\n        return False\n\n    return {k: v for k, v in params.items() if has_changed(k, v)}"
}