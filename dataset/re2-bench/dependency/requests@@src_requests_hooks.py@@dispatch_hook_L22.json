{
    "requests.src.requests.auth.handle_redirect": "def handle_redirect(self, r, **kwargs):\n    \"\"\"Reset num_401_calls counter on redirects.\"\"\"\n    if r.is_redirect:\n        self._thread_local.num_401_calls = 1",
    "requests.src.requests.auth.handle_401": "def handle_401(self, r, **kwargs):\n    \"\"\"\n    Takes the given response and tries digest-auth, if needed.\n\n    :rtype: requests.Response\n    \"\"\"\n\n    # If response is not 4xx, do not auth\n    # See https://github.com/psf/requests/issues/3772\n    if not 400 <= r.status_code < 500:\n        self._thread_local.num_401_calls = 1\n        return r\n\n    if self._thread_local.pos is not None:\n        # Rewind the file position indicator of the body to where\n        # it was to resend the request.\n        r.request.body.seek(self._thread_local.pos)\n    s_auth = r.headers.get(\"www-authenticate\", \"\")\n\n    if \"digest\" in s_auth.lower() and self._thread_local.num_401_calls < 2:\n        self._thread_local.num_401_calls += 1\n        pat = re.compile(r\"digest \", flags=re.IGNORECASE)\n        self._thread_local.chal = parse_dict_header(pat.sub(\"\", s_auth, count=1))\n\n        # Consume content and release the original connection\n        # to allow our new request to reuse the same one.\n        r.content\n        r.close()\n        prep = r.request.copy()\n        extract_cookies_to_jar(prep._cookies, r.request, r.raw)\n        prep.prepare_cookies(prep._cookies)\n\n        prep.headers[\"Authorization\"] = self.build_digest_header(\n            prep.method, prep.url\n        )\n        _r = r.connection.send(prep, **kwargs)\n        _r.history.append(r)\n        _r.request = prep\n\n        return _r\n\n    self._thread_local.num_401_calls = 1\n    return r"
}