{
    "matplotlib.lib.matplotlib._api.__init__.check_isinstance": "def check_isinstance(types, /, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is an instance\n    of one of *types*; if not, raise an appropriate TypeError.\n\n    As a special case, a ``None`` entry in *types* is treated as NoneType.\n\n    Examples\n    --------\n    >>> _api.check_isinstance((SomeClass, None), arg=arg)\n    \"\"\"\n    none_type = type(None)\n    types = ((types,) if isinstance(types, type) else\n             (none_type,) if types is None else\n             tuple(none_type if tp is None else tp for tp in types))\n\n    def type_name(tp):\n        return (\"None\" if tp is none_type\n                else tp.__qualname__ if tp.__module__ == \"builtins\"\n                else f\"{tp.__module__}.{tp.__qualname__}\")\n\n    for k, v in kwargs.items():\n        if not isinstance(v, types):\n            names = [*map(type_name, types)]\n            if \"None\" in names:  # Move it to the end for better wording.\n                names.remove(\"None\")\n                names.append(\"None\")\n            raise TypeError(\n                \"{!r} must be an instance of {}, not a {}\".format(\n                    k,\n                    \", \".join(names[:-1]) + \" or \" + names[-1]\n                    if len(names) > 1 else names[0],\n                    type_name(type(v))))",
    "matplotlib.lib.matplotlib._pylab_helpers.get_active": "@classmethod\ndef get_active(cls):\n    \"\"\"Return the active manager, or *None* if there is no manager.\"\"\"\n    return next(reversed(cls.figs.values())) if cls.figs else None",
    "matplotlib.lib.matplotlib._pylab_helpers.destroy": "@classmethod\ndef destroy(cls, num):\n    \"\"\"\n    Destroy manager *num* -- either a manager instance or a manager number.\n\n    In the interactive backends, this is bound to the window \"destroy\" and\n    \"delete\" events.\n\n    It is recommended to pass a manager instance, to avoid confusion when\n    two managers share the same number.\n    \"\"\"\n    if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n        # num is a manager-like instance (not necessarily a\n        # FigureManagerBase subclass)\n        manager = num\n        if cls.figs.get(manager.num) is manager:\n            cls.figs.pop(manager.num)\n    else:\n        try:\n            manager = cls.figs.pop(num)\n        except KeyError:\n            return\n    if hasattr(manager, \"_cidgcf\"):\n        manager.canvas.mpl_disconnect(manager._cidgcf)\n    manager.destroy()",
    "matplotlib.lib.matplotlib._pylab_helpers.destroy_fig": "@classmethod\ndef destroy_fig(cls, fig):\n    \"\"\"Destroy figure *fig*.\"\"\"\n    manager = next((manager for manager in cls.figs.values()\n                   if manager.canvas.figure == fig), None)\n    if manager is not None:\n        cls.destroy(manager)",
    "matplotlib.lib.matplotlib._pylab_helpers.destroy_all": "@classmethod\ndef destroy_all(cls):\n    \"\"\"Destroy all figures.\"\"\"\n    for manager in list(cls.figs.values()):\n        manager.canvas.mpl_disconnect(manager._cidgcf)\n        manager.destroy()\n    cls.figs.clear()",
    "matplotlib.lib.matplotlib.pyplot.get_fignums": "def get_fignums() -> list[int]:\n    \"\"\"Return a list of existing figure numbers.\"\"\"\n    return sorted(_pylab_helpers.Gcf.figs)",
    "matplotlib.lib.matplotlib.pyplot.get_figlabels": "def get_figlabels() -> list[Any]:\n    \"\"\"Return a list of existing figure labels.\"\"\"\n    managers = _pylab_helpers.Gcf.get_all_fig_managers()\n    managers.sort(key=lambda m: m.num)\n    return [m.canvas.figure.get_label() for m in managers]"
}