{
    "matplotlib.lib.matplotlib.colors.hillshade": "def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n    \"\"\"\n    Calculate the illumination intensity for a surface using the defined\n    azimuth and elevation for the light source.\n\n    This computes the normal vectors for the surface, and then passes them\n    on to `shade_normals`\n\n    Parameters\n    ----------\n    elevation : 2D array-like\n        The height values used to generate an illumination map\n    vert_exag : number, optional\n        The amount to exaggerate the elevation values by when calculating\n        illumination. This can be used either to correct for differences in\n        units between the x-y coordinate system and the elevation\n        coordinate system (e.g. decimal degrees vs. meters) or to\n        exaggerate or de-emphasize topographic effects.\n    dx : number, optional\n        The x-spacing (columns) of the input *elevation* grid.\n    dy : number, optional\n        The y-spacing (rows) of the input *elevation* grid.\n    fraction : number, optional\n        Increases or decreases the contrast of the hillshade.  Values\n        greater than one will cause intermediate values to move closer to\n        full illumination or shadow (and clipping any values that move\n        beyond 0 or 1). Note that this is not visually or mathematically\n        the same as vertical exaggeration.\n\n    Returns\n    -------\n    `~numpy.ndarray`\n        A 2D array of illumination values between 0-1, where 0 is\n        completely in shadow and 1 is completely illuminated.\n    \"\"\"\n\n    # Because most image and raster GIS data has the first row in the array\n    # as the \"top\" of the image, dy is implicitly negative.  This is\n    # consistent to what `imshow` assumes, as well.\n    dy = -dy\n\n    # compute the normal vectors from the partial derivatives\n    e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n\n    # .view is to keep subclasses\n    normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n    normal[..., 0] = -e_dx\n    normal[..., 1] = -e_dy\n    normal[..., 2] = 1\n    normal /= _vector_magnitude(normal)\n\n    return self.shade_normals(normal, fraction)",
    "matplotlib.lib.matplotlib.colors.blend_hsv": "def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n              hsv_min_val=None, hsv_min_sat=None):\n    \"\"\"\n    Take the input data array, convert to HSV values in the given colormap,\n    then adjust those color values to give the impression of a shaded\n    relief map with a specified light source.  RGBA values are returned,\n    which can then be used to plot the shaded image with imshow.\n\n    The color of the resulting image will be darkened by moving the (s, v)\n    values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the\n    shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n    hsv_max_val) in regions that are illuminated.  The default extremes are\n    chose so that completely shaded points are nearly black (s = 1, v = 0)\n    and completely illuminated points are nearly white (s = 0, v = 1).\n\n    Parameters\n    ----------\n    rgb : `~numpy.ndarray`\n        An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n    intensity : `~numpy.ndarray`\n        An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n    hsv_max_sat : number, optional\n        The maximum saturation value that the *intensity* map can shift the output\n        image to. If not provided, use the value provided upon initialization.\n    hsv_min_sat : number, optional\n        The minimum saturation value that the *intensity* map can shift the output\n        image to. If not provided, use the value provided upon initialization.\n    hsv_max_val : number, optional\n        The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n        output image to. If not provided, use the value provided upon\n        initialization.\n    hsv_min_val : number, optional\n        The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n        output image to. If not provided, use the value provided upon\n        initialization.\n\n    Returns\n    -------\n    `~numpy.ndarray`\n        An (M, N, 3) RGB array representing the combined images.\n    \"\"\"\n    # Backward compatibility...\n    if hsv_max_sat is None:\n        hsv_max_sat = self.hsv_max_sat\n    if hsv_max_val is None:\n        hsv_max_val = self.hsv_max_val\n    if hsv_min_sat is None:\n        hsv_min_sat = self.hsv_min_sat\n    if hsv_min_val is None:\n        hsv_min_val = self.hsv_min_val\n\n    # Expects a 2D intensity array scaled between -1 to 1...\n    intensity = intensity[..., 0]\n    intensity = 2 * intensity - 1\n\n    # Convert to rgb, then rgb to hsv\n    hsv = rgb_to_hsv(rgb[:, :, 0:3])\n    hue, sat, val = np.moveaxis(hsv, -1, 0)\n\n    # Modify hsv values (in place) to simulate illumination.\n    # putmask(A, mask, B) <=> A[mask] = B[mask]\n    np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n               (1 - intensity) * sat + intensity * hsv_max_sat)\n    np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n               (1 + intensity) * sat - intensity * hsv_min_sat)\n    np.putmask(val, intensity > 0,\n               (1 - intensity) * val + intensity * hsv_max_val)\n    np.putmask(val, intensity < 0,\n               (1 + intensity) * val - intensity * hsv_min_val)\n    np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n\n    # Convert modified hsv back to rgb.\n    return hsv_to_rgb(hsv)",
    "matplotlib.lib.matplotlib.colors.blend_soft_light": "def blend_soft_light(self, rgb, intensity):\n    \"\"\"\n    Combine an RGB image with an intensity map using \"soft light\" blending,\n    using the \"pegtop\" formula.\n\n    Parameters\n    ----------\n    rgb : `~numpy.ndarray`\n        An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n    intensity : `~numpy.ndarray`\n        An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n\n    Returns\n    -------\n    `~numpy.ndarray`\n        An (M, N, 3) RGB array representing the combined images.\n    \"\"\"\n    return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2",
    "matplotlib.lib.matplotlib.colors.blend_overlay": "def blend_overlay(self, rgb, intensity):\n    \"\"\"\n    Combine an RGB image with an intensity map using \"overlay\" blending.\n\n    Parameters\n    ----------\n    rgb : `~numpy.ndarray`\n        An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n    intensity : `~numpy.ndarray`\n        An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n\n    Returns\n    -------\n    ndarray\n        An (M, N, 3) RGB array representing the combined images.\n    \"\"\"\n    low = 2 * intensity * rgb\n    high = 1 - 2 * (1 - intensity) * (1 - rgb)\n    return np.where(rgb <= 0.5, low, high)"
}