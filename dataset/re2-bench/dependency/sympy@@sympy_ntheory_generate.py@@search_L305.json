{
    "sympy.sympy.ntheory.generate._as_int_ceiling": "def _as_int_ceiling(a):\n    \"\"\" Wrapping ceiling in as_int will raise an error if there was a problem\n        determining whether the expression was exactly an integer or not.\"\"\"\n    from sympy.functions.elementary.integers import ceiling\n    return as_int(ceiling(a))",
    "sympy.sympy.ntheory.generate.extend": "def extend(self, n):\n    \"\"\"Grow the sieve to cover all primes <= n.\n\n    Examples\n    ========\n\n    >>> from sympy import sieve\n    >>> sieve._reset() # this line for doctest only\n    >>> sieve.extend(30)\n    >>> sieve[10] == 29\n    True\n    \"\"\"\n    n = int(n)\n    # `num` is even at any point in the function.\n    # This satisfies the condition required by `self._primerange`.\n    num = self._list[-1] + 1\n    if n < num:\n        return\n    num2 = num**2\n    while num2 <= n:\n        self._list += _array('L', self._primerange(num, num2))\n        num, num2 = num2, num2**2\n    # Merge the sieves\n    self._list += _array('L', self._primerange(num, n + 1))",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}