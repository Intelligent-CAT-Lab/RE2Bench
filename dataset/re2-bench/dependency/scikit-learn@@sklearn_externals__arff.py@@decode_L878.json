{
    "scikit-learn.sklearn.externals._arff._decode": "def _decode(self, s, encode_nominal=False, matrix_type=DENSE):\n    '''Do the job the ``encode``.'''\n\n    # Make sure this method is idempotent\n    self._current_line = 0\n\n    # If string, convert to a list of lines\n    if isinstance(s, str):\n        s = s.strip('\\r\\n ').replace('\\r\\n', '\\n').split('\\n')\n\n    # Create the return object\n    obj: ArffContainerType = {\n        'description': '',\n        'relation': '',\n        'attributes': [],\n        'data': []\n    }\n    attribute_names = {}\n\n    # Create the data helper object\n    data = _get_data_object_for_decoding(matrix_type)\n\n    # Read all lines\n    STATE = _TK_DESCRIPTION\n    s = iter(s)\n    for row in s:\n        self._current_line += 1\n        # Ignore empty lines\n        row = row.strip(' \\r\\n')\n        if not row: continue\n\n        u_row = row.upper()\n\n        # DESCRIPTION -----------------------------------------------------\n        if u_row.startswith(_TK_DESCRIPTION) and STATE == _TK_DESCRIPTION:\n            obj['description'] += self._decode_comment(row) + '\\n'\n        # -----------------------------------------------------------------\n\n        # RELATION --------------------------------------------------------\n        elif u_row.startswith(_TK_RELATION):\n            if STATE != _TK_DESCRIPTION:\n                raise BadLayout()\n\n            STATE = _TK_RELATION\n            obj['relation'] = self._decode_relation(row)\n        # -----------------------------------------------------------------\n\n        # ATTRIBUTE -------------------------------------------------------\n        elif u_row.startswith(_TK_ATTRIBUTE):\n            if STATE != _TK_RELATION and STATE != _TK_ATTRIBUTE:\n                raise BadLayout()\n\n            STATE = _TK_ATTRIBUTE\n\n            attr = self._decode_attribute(row)\n            if attr[0] in attribute_names:\n                raise BadAttributeName(attr[0], attribute_names[attr[0]])\n            else:\n                attribute_names[attr[0]] = self._current_line\n            obj['attributes'].append(attr)\n\n            if isinstance(attr[1], (list, tuple)):\n                if encode_nominal:\n                    conversor = EncodedNominalConversor(attr[1])\n                else:\n                    conversor = NominalConversor(attr[1])\n            else:\n                CONVERSOR_MAP = {'STRING': str,\n                                 'INTEGER': lambda x: int(float(x)),\n                                 'NUMERIC': float,\n                                 'REAL': float}\n                conversor = CONVERSOR_MAP[attr[1]]\n\n            self._conversors.append(conversor)\n        # -----------------------------------------------------------------\n\n        # DATA ------------------------------------------------------------\n        elif u_row.startswith(_TK_DATA):\n            if STATE != _TK_ATTRIBUTE:\n                raise BadLayout()\n\n            break\n        # -----------------------------------------------------------------\n\n        # COMMENT ---------------------------------------------------------\n        elif u_row.startswith(_TK_COMMENT):\n            pass\n        # -----------------------------------------------------------------\n    else:\n        # Never found @DATA\n        raise BadLayout()\n\n    def stream():\n        for row in s:\n            self._current_line += 1\n            row = row.strip()\n            # Ignore empty lines and comment lines.\n            if row and not row.startswith(_TK_COMMENT):\n                yield row\n\n    # Alter the data object\n    obj['data'] = data.decode_rows(stream(), self._conversors)\n    if obj['description'].endswith('\\n'):\n        obj['description'] = obj['description'][:-1]\n\n    return obj"
}