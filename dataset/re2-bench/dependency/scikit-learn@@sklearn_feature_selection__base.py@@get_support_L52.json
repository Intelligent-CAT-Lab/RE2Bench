{
    "scikit-learn.sklearn.feature_selection._from_model._get_support_mask": "def _get_support_mask(self):\n    estimator = getattr(self, \"estimator_\", self.estimator)\n    max_features = getattr(self, \"max_features_\", self.max_features)\n\n    if self.prefit:\n        try:\n            check_is_fitted(self.estimator)\n        except NotFittedError as exc:\n            raise NotFittedError(\n                \"When `prefit=True`, `estimator` is expected to be a fitted \"\n                \"estimator.\"\n            ) from exc\n    if callable(max_features):\n        # This branch is executed when `transform` is called directly and thus\n        # `max_features_` is not set and we fallback using `self.max_features`\n        # that is not validated\n        raise NotFittedError(\n            \"When `prefit=True` and `max_features` is a callable, call `fit` \"\n            \"before calling `transform`.\"\n        )\n    elif max_features is not None and not isinstance(max_features, Integral):\n        raise ValueError(\n            f\"`max_features` must be an integer. Got `max_features={max_features}` \"\n            \"instead.\"\n        )\n\n    scores = _get_feature_importances(\n        estimator=estimator,\n        getter=self.importance_getter,\n        transform_func=\"norm\",\n        norm_order=self.norm_order,\n    )\n    threshold = _calculate_threshold(estimator, scores, self.threshold)\n    if self.max_features is not None:\n        mask = np.zeros_like(scores, dtype=bool)\n        candidate_indices = np.argsort(-scores, kind=\"mergesort\")[:max_features]\n        mask[candidate_indices] = True\n    else:\n        mask = np.ones_like(scores, dtype=bool)\n    mask[scores < threshold] = False\n    return mask",
    "scikit-learn.sklearn.feature_selection._rfe._get_support_mask": "def _get_support_mask(self):\n    check_is_fitted(self)\n    return self.support_",
    "scikit-learn.sklearn.feature_selection._sequential._get_support_mask": "def _get_support_mask(self):\n    check_is_fitted(self)\n    return self.support_",
    "scikit-learn.sklearn.feature_selection._univariate_selection._get_support_mask": "def _get_support_mask(self):\n    check_is_fitted(self)\n\n    n_features = len(self.pvalues_)\n    sv = np.sort(self.pvalues_)\n    selected = sv[\n        sv <= float(self.alpha) / n_features * np.arange(1, n_features + 1)\n    ]\n    if selected.size == 0:\n        return np.zeros_like(self.pvalues_, dtype=bool)\n    return self.pvalues_ <= selected.max()",
    "scikit-learn.sklearn.feature_selection._variance_threshold._get_support_mask": "def _get_support_mask(self):\n    check_is_fitted(self)\n\n    return self.variances_ > self.threshold"
}