{
    "matplotlib.lib.matplotlib.cbook._unpack_to_numpy": "def _unpack_to_numpy(x):\n    \"\"\"Internal helper to extract data from e.g. pandas and xarray objects.\"\"\"\n    if isinstance(x, np.ndarray):\n        # If numpy, return directly\n        return x\n    if hasattr(x, 'to_numpy'):\n        # Assume that any to_numpy() method actually returns a numpy array\n        return x.to_numpy()\n    if hasattr(x, 'values'):\n        xtmp = x.values\n        # For example a dict has a 'values' attribute, but it is not a property\n        # so in this case we do not want to return a function\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    if _is_torch_array(x) or _is_jax_array(x) or _is_tensorflow_array(x):\n        # using np.asarray() instead of explicitly __array__(), as the latter is\n        # only _one_ of many methods, and it's the last resort, see also\n        # https://numpy.org/devdocs/user/basics.interoperability.html#using-arbitrary-objects-in-numpy\n        # therefore, let arrays do better if they can\n        xtmp = np.asarray(x)\n\n        # In case np.asarray method does not return a numpy array in future\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    return x",
    "matplotlib.lib.matplotlib.dates._dt64_to_ordinalf": "def _dt64_to_ordinalf(d):\n    \"\"\"\n    Convert `numpy.datetime64` or an `numpy.ndarray` of those types to\n    Gregorian date as UTC float relative to the epoch (see `.get_epoch`).\n    Roundoff is float64 precision.  Practically: microseconds for dates\n    between 290301 BC, 294241 AD, milliseconds for larger dates\n    (see `numpy.datetime64`).\n    \"\"\"\n\n    # the \"extra\" ensures that we at least allow the dynamic range out to\n    # seconds.  That should get out to +/-2e11 years.\n    dseconds = d.astype('datetime64[s]')\n    extra = (d - dseconds).astype('timedelta64[ns]')\n    t0 = np.datetime64(get_epoch(), 's')\n    dt = (dseconds - t0).astype(np.float64)\n    dt += extra.astype(np.float64) / 1.0e9\n    dt = dt / SEC_PER_DAY\n\n    NaT_int = np.datetime64('NaT').astype(np.int64)\n    d_int = d.astype(np.int64)\n    dt[d_int == NaT_int] = np.nan\n    return dt",
    "matplotlib.lib.matplotlib.dates.<listcomp>": "d = [dt.astimezone(UTC).replace(tzinfo=None) for dt in d]\n"
}