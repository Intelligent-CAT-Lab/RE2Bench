{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.expr.coeff": "def coeff(self, x: Expr | complex, n=1, right=False, _first=True):\n    \"\"\"\n    Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n    is zero then all terms independent of ``x`` will be returned.\n\n    Explanation\n    ===========\n\n    When ``x`` is noncommutative, the coefficient to the left (default) or\n    right of ``x`` can be returned. The keyword 'right' is ignored when\n    ``x`` is commutative.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.abc import x, y, z\n\n    You can select terms that have an explicit negative in front of them:\n\n    >>> (-x + 2*y).coeff(-1)\n    x\n    >>> (x - 2*y).coeff(-1)\n    2*y\n\n    You can select terms with no Rational coefficient:\n\n    >>> (x + 2*y).coeff(1)\n    x\n    >>> (3 + 2*x + 4*x**2).coeff(1)\n    0\n\n    You can select terms independent of x by making n=0; in this case\n    expr.as_independent(x)[0] is returned (and 0 will be returned instead\n    of None):\n\n    >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n    3\n    >>> eq = ((x + 1)**3).expand() + 1\n    >>> eq\n    x**3 + 3*x**2 + 3*x + 2\n    >>> [eq.coeff(x, i) for i in reversed(range(4))]\n    [1, 3, 3, 2]\n    >>> eq -= 2\n    >>> [eq.coeff(x, i) for i in reversed(range(4))]\n    [1, 3, 3, 0]\n\n    You can select terms that have a numerical term in front of them:\n\n    >>> (-x - 2*y).coeff(2)\n    -y\n    >>> from sympy import sqrt\n    >>> (x + sqrt(2)*x).coeff(sqrt(2))\n    x\n\n    The matching is exact:\n\n    >>> (3 + 2*x + 4*x**2).coeff(x)\n    2\n    >>> (3 + 2*x + 4*x**2).coeff(x**2)\n    4\n    >>> (3 + 2*x + 4*x**2).coeff(x**3)\n    0\n    >>> (z*(x + y)**2).coeff((x + y)**2)\n    z\n    >>> (z*(x + y)**2).coeff(x + y)\n    0\n\n    In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n    from the following:\n\n    >>> (x + z*(x + x*y)).coeff(x)\n    1\n\n    If such factoring is desired, factor_terms can be used first:\n\n    >>> from sympy import factor_terms\n    >>> factor_terms(x + z*(x + x*y)).coeff(x)\n    z*(y + 1) + 1\n\n    >>> n, m, o = symbols('n m o', commutative=False)\n    >>> n.coeff(n)\n    1\n    >>> (3*n).coeff(n)\n    3\n    >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n    1 + m\n    >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n    m\n\n    If there is more than one possible coefficient 0 is returned:\n\n    >>> (n*m + m*n).coeff(n)\n    0\n\n    If there is only one possible coefficient, it is returned:\n\n    >>> (n*m + x*m*n).coeff(m*n)\n    x\n    >>> (n*m + x*m*n).coeff(m*n, right=1)\n    1\n\n    See Also\n    ========\n\n    as_coefficient: separate the expression into a coefficient and factor\n    as_coeff_Add: separate the additive constant from an expression\n    as_coeff_Mul: separate the multiplicative constant from an expression\n    as_independent: separate x-dependent terms/factors from others\n    sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n    sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used\n    \"\"\"\n    xe = sympify(x)\n    if not isinstance(xe, Basic):\n        return S.Zero\n\n    n = as_int(n)\n\n    if not xe:\n        return S.Zero\n\n    if xe == self:\n        if n == 1:\n            return S.One\n        return S.Zero\n\n    co2: list[Expr]\n\n    if xe is S.One:\n        co2 = [a for a in Add.make_args(self) if a.as_coeff_Mul()[0] is S.One]\n        if not co2:\n            return S.Zero\n        return Add(*co2)\n\n    if n == 0:\n        if xe.is_Add and self.is_Add:\n            c = self.coeff(xe, right=right)\n            if not c:\n                return S.Zero\n            if not right:\n                return self - Add(*[a*xe for a in Add.make_args(c)])\n            return self - Add(*[xe*a for a in Add.make_args(c)])\n        return self.as_independent(xe, as_Add=True)[0]\n\n    # continue with the full method, looking for this power of xe:\n    xe = xe**n\n\n    def incommon(l1, l2):\n        if not l1 or not l2:\n            return []\n        n = min(len(l1), len(l2))\n        for i in range(n):\n            if l1[i] != l2[i]:\n                return l1[:i]\n        return l1[:]\n\n    def find(l, sub, first=True):\n        \"\"\" Find where list sub appears in list l. When ``first`` is True\n        the first occurrence from the left is returned, else the last\n        occurrence is returned. Return None if sub is not in l.\n\n        Examples\n        ========\n\n        >> l = range(5)*2\n        >> find(l, [2, 3])\n        2\n        >> find(l, [2, 3], first=0)\n        7\n        >> find(l, [2, 4])\n        None\n\n        \"\"\"\n        if not sub or not l or len(sub) > len(l):\n            return None\n        n = len(sub)\n        if not first:\n            l.reverse()\n            sub.reverse()\n        for i in range(len(l) - n + 1):\n            if all(l[i + j] == sub[j] for j in range(n)):\n                break\n        else:\n            i = None\n        if not first:\n            l.reverse()\n            sub.reverse()\n        if i is not None and not first:\n            i = len(l) - (i + n)\n        return i\n\n    co2 = []\n    co: list[tuple[set[Expr], list[Expr]]] = []\n    args = Add.make_args(self)\n    self_c = self.is_commutative\n    x_c = xe.is_commutative\n    if self_c and not x_c:\n        return S.Zero\n    if _first and self.is_Add and not self_c and not x_c:\n        # get the part that depends on xe exactly\n        xargs = Mul.make_args(xe)\n        d = Add(*[i for i in Add.make_args(self.as_independent(xe)[1])\n            if all(xi in Mul.make_args(i) for xi in xargs)])\n        rv = d.coeff(xe, right=right, _first=False)\n        if not rv.is_Add or not right:\n            return rv\n        c_part, nc_part = zip(*[i.args_cnc() for i in rv.args])\n        if has_variety(c_part):\n            return rv\n        return Add(*[Mul._from_args(i) for i in nc_part])\n\n    one_c = self_c or x_c\n    xargs, nx = xe.args_cnc(cset=True, warn=bool(not x_c))\n    # find the parts that pass the commutative terms\n    for a in args:\n        margs, nc = a.args_cnc(cset=True, warn=bool(not self_c))\n        if nc is None:\n            nc = []\n        if len(xargs) > len(margs):\n            continue\n        resid = margs.difference(xargs)\n        if len(resid) + len(xargs) == len(margs):\n            if one_c:\n                co2.append(Mul(*(list(resid) + nc)))\n            else:\n                co.append((resid, nc))\n    if one_c:\n        if co2 == []:\n            return S.Zero\n        elif co2:\n            return Add(*co2)\n    else:  # both nc\n        # now check the non-comm parts\n        if not co:\n            return S.Zero\n        if all(n == co[0][1] for r, n in co):\n            ii = find(co[0][1], nx, right)\n            if ii is not None:\n                if not right:\n                    return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))\n                else:\n                    return Mul(*co[0][1][ii + len(nx):])\n        beg = reduce(incommon, (n[1] for n in co))\n        if beg:\n            ii = find(beg, nx, right)\n            if ii is not None:\n                if not right:\n                    gcdc = co[0][0]\n                    for i in range(1, len(co)):\n                        gcdc = gcdc.intersection(co[i][0])\n                        if not gcdc:\n                            break\n                    return Mul(*(list(gcdc) + beg[:ii]))\n                else:\n                    m = ii + len(nx)\n                    return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])\n        end = list(reversed(\n            reduce(incommon, (list(reversed(n[1])) for n in co))))\n        if end:\n            ii = find(end, nx, right)\n            if ii is not None:\n                if not right:\n                    return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])\n                else:\n                    return Mul(*end[ii + len(nx):])\n        # look for single match\n        hit = None\n        for i, (r, n) in enumerate(co):\n            ii = find(n, nx, right)\n            if ii is not None:\n                if not hit:\n                    hit = ii, r, n\n                else:\n                    break\n        else:\n            if hit:\n                ii, r, n = hit\n                if not right:\n                    return Mul(*(list(r) + n[:ii]))\n                else:\n                    return Mul(*n[ii + len(nx):])\n\n        return S.Zero",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.expr.round": "def round(self, n=None):\n    \"\"\"Return x rounded to the given decimal place.\n\n    If a complex number would result, apply round to the real\n    and imaginary components of the number.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, E, I, S, Number\n    >>> pi.round()\n    3\n    >>> pi.round(2)\n    3.14\n    >>> (2*pi + E*I).round()\n    6 + 3*I\n\n    The round method has a chopping effect:\n\n    >>> (2*pi + I/10).round()\n    6\n    >>> (pi/10 + 2*I).round()\n    2*I\n    >>> (pi/10 + E*I).round(2)\n    0.31 + 2.72*I\n\n    Notes\n    =====\n\n    The Python ``round`` function uses the SymPy ``round`` method so it\n    will always return a SymPy number (not a Python float or int):\n\n    >>> isinstance(round(S(123), -2), Number)\n    True\n    \"\"\"\n    x = self\n\n    if not x.is_number:\n        raise TypeError(\"Cannot round symbolic expression\")\n    if not x.is_Atom:\n        if not pure_complex(x.n(2), or_real=True):\n            raise TypeError(\n                'Expected a number but got %s:' % func_name(x))\n    elif x in _illegal:\n        return x\n    if not (xr := x.is_extended_real):\n        r, i = x.as_real_imag()\n        if xr is False:\n            return r.round(n) + S.ImaginaryUnit*i.round(n)\n        if i.equals(0):\n            return r.round(n)\n    if not x:\n        return S.Zero if n is None else x\n\n    p = as_int(n or 0)\n\n    if x.is_Integer:\n        return Integer(round(int(x), p))\n\n    digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1\n    allow = digits_to_decimal + p\n    precs = [f._prec for f in x.atoms(Float)]\n    dps = prec_to_dps(max(precs)) if precs else None\n    if dps is None:\n        # assume everything is exact so use the Python\n        # float default or whatever was requested\n        dps = max(15, allow)\n    else:\n        allow = min(allow, dps)\n    # this will shift all digits to right of decimal\n    # and give us dps to work with as an int\n    shift = -digits_to_decimal + dps\n    extra = 1  # how far we look past known digits\n    # NOTE\n    # mpmath will calculate the binary representation to\n    # an arbitrary number of digits but we must base our\n    # answer on a finite number of those digits, e.g.\n    # .575 2589569785738035/2**52 in binary.\n    # mpmath shows us that the first 18 digits are\n    #     >>> Float(.575).n(18)\n    #     0.574999999999999956\n    # The default precision is 15 digits and if we ask\n    # for 15 we get\n    #     >>> Float(.575).n(15)\n    #     0.575000000000000\n    # mpmath handles rounding at the 15th digit. But we\n    # need to be careful since the user might be asking\n    # for rounding at the last digit and our semantics\n    # are to round toward the even final digit when there\n    # is a tie. So the extra digit will be used to make\n    # that decision. In this case, the value is the same\n    # to 15 digits:\n    #     >>> Float(.575).n(16)\n    #     0.5750000000000000\n    # Now converting this to the 15 known digits gives\n    #     575000000000000.0\n    # which rounds to integer\n    #    5750000000000000\n    # And now we can round to the desired digt, e.g. at\n    # the second from the left and we get\n    #    5800000000000000\n    # and rescaling that gives\n    #    0.58\n    # as the final result.\n    # If the value is made slightly less than 0.575 we might\n    # still obtain the same value:\n    #    >>> Float(.575-1e-16).n(16)*10**15\n    #    574999999999999.8\n    # What 15 digits best represents the known digits (which are\n    # to the left of the decimal? 5750000000000000, the same as\n    # before. The only way we will round down (in this case) is\n    # if we declared that we had more than 15 digits of precision.\n    # For example, if we use 16 digits of precision, the integer\n    # we deal with is\n    #    >>> Float(.575-1e-16).n(17)*10**16\n    #    5749999999999998.4\n    # and this now rounds to 5749999999999998 and (if we round to\n    # the 2nd digit from the left) we get 5700000000000000.\n    #\n    xf = x.n(dps + extra)*Pow(10, shift)\n    if xf.is_Number and xf._prec == 1:  # xf.is_Add will raise below\n        # is x == 0?\n        if x.equals(0):\n            return Float(0)\n        raise ValueError('not computing with precision')\n    xi = Integer(xf)\n    # use the last digit to select the value of xi\n    # nearest to x before rounding at the desired digit\n    sign = 1 if x > 0 else -1\n    dif2 = sign*(xf - xi).n(extra)\n    if dif2 < 0:\n        raise NotImplementedError(\n            'not expecting int(x) to round away from 0')\n    if dif2 > .5:\n        xi += sign  # round away from 0\n    elif dif2 == .5:\n        xi += sign if xi%2 else -sign  # round toward even\n    # shift p to the new position\n    ip = p - shift\n    # let Python handle the int rounding then rescale\n    xr = round(xi.p, ip)\n    # restore scale\n    rv = Rational(xr, Pow(10, shift))\n    # return Float or Integer\n    if rv.is_Integer:\n        if n is None:  # the single-arg case\n            return rv\n        # use str or else it won't be a float\n        return Float(str(rv), dps)  # keep same precision\n    else:\n        if not allow and rv > self:\n            allow += 1\n        return Float(rv, allow)",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__abs__": "def __abs__(self):\n    return Float._new(mlib.mpf_abs(self._mpf_), self._prec)",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    "sympy.sympy.core.numbers.equal_valued": "def equal_valued(x, y):\n    \"\"\"Compare expressions treating plain floats as rationals.\n\n    Examples\n    ========\n\n    >>> from sympy import S, symbols, Rational, Float\n    >>> from sympy.core.numbers import equal_valued\n    >>> equal_valued(1, 2)\n    False\n    >>> equal_valued(1, 1)\n    True\n\n    In SymPy expressions with Floats compare unequal to corresponding\n    expressions with rationals:\n\n    >>> x = symbols('x')\n    >>> x**2 == x**2.0\n    False\n\n    However an individual Float compares equal to a Rational:\n\n    >>> Rational(1, 2) == Float(0.5)\n    False\n\n    In a future version of SymPy this might change so that Rational and Float\n    compare unequal. This function provides the behavior currently expected of\n    ``==`` so that it could still be used if the behavior of ``==`` were to\n    change in future.\n\n    >>> equal_valued(1, 1.0) # Float vs Rational\n    True\n    >>> equal_valued(S(1).n(3), S(1).n(5)) # Floats of different precision\n    True\n\n    Explanation\n    ===========\n\n    In future SymPy versions Float and Rational might compare unequal and floats\n    with different precisions might compare unequal. In that context a function\n    is needed that can check if a number is equal to 1 or 0 etc. The idea is\n    that instead of testing ``if x == 1:`` if we want to accept floats like\n    ``1.0`` as well then the test can be written as ``if equal_valued(x, 1):``\n    or ``if equal_valued(x, 2):``. Since this function is intended to be used\n    in situations where one or both operands are expected to be concrete\n    numbers like 1 or 0 the function does not recurse through the args of any\n    compound expression to compare any nested floats.\n\n    References\n    ==========\n\n    .. [1] https://github.com/sympy/sympy/pull/20033\n    \"\"\"\n    x = _sympify(x)\n    y = _sympify(y)\n\n    # Handle everything except Float/Rational first\n    if not x.is_Float and not y.is_Float:\n        return x == y\n    elif x.is_Float and y.is_Float:\n        # Compare values without regard for precision\n        return x._mpf_ == y._mpf_\n    elif x.is_Float:\n        x, y = y, x\n    if not x.is_Rational:\n        return False\n\n    # Now y is Float and x is Rational. A simple approach at this point would\n    # just be x == Rational(y) but if y has a large exponent creating a\n    # Rational could be prohibitively expensive.\n\n    sign, man, exp, _ = y._mpf_\n    p, q = x.p, x.q\n\n    if sign:\n        man = -man\n\n    if exp == 0:\n        # y odd integer\n        return q == 1 and man == p\n    elif exp > 0:\n        # y even integer\n        if q != 1:\n            return False\n        if p.bit_length() != man.bit_length() + exp:\n            return False\n        return man << exp == p\n    else:\n        # y non-integer. Need p == man and q == 2**-exp\n        if p != man:\n            return False\n        neg_exp = -exp\n        if q.bit_length() - 1 != neg_exp:\n            return False\n        return (1 << neg_exp) == q",
    "sympy.sympy.matrices.matrixbase.__len__": "def __len__(self) -> int:\n    \"\"\"Return the number of elements of ``self``.\n\n    Implemented mainly so bool(Matrix()) == False.\n    \"\"\"\n    return self.rows * self.cols"
}