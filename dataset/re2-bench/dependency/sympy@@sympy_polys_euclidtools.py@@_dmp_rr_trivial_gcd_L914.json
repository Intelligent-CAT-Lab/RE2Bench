{
    "sympy.sympy.polys.densearith.dmp_neg": "def dmp_neg(f: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_neg(x**2*y - x)\n    -x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_neg(_dup(f), K))\n\n    v = u - 1\n\n    return [ dmp_neg(cf, v, K) for cf in f ]",
    "sympy.sympy.polys.densebasic.dmp_zeros": "def dmp_zeros(n: int, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a list of multivariate zeros.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_zeros\n\n    >>> dmp_zeros(3, 2, ZZ)\n    [[[[]]], [[[]]], [[[]]]]\n    >>> dmp_zeros(3, -1, ZZ)\n    [0, 0, 0]\n\n    \"\"\"\n    if not n:\n        return []\n\n    if u < 0:\n        return _dmp([K.zero] * n)\n    else:\n        return [dmp_zero(u, K) for i in range(n)]",
    "sympy.sympy.polys.densebasic.dmp_ground_LC": "def dmp_ground_LC(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the ground leading coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_LC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_LC(f, 2, ZZ)\n    1\n\n    \"\"\"\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n\n    return dup_LC(_dup(f), K)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densebasic.dmp_zero": "def dmp_zero(u: int, K: Domain[Er] | None = None) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero\n\n    >>> dmp_zero(4)\n    [[[[[]]]]]\n\n    \"\"\"\n    r: dmp[Er] = []\n\n    for i in range(u):\n        r = [r]\n\n    return r",
    "sympy.sympy.polys.densebasic.dmp_one_p": "def dmp_one_p(f: dmp[Er], u: int, K: Domain[Er]) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is one in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one_p\n\n    >>> dmp_one_p([[[ZZ(1)]]], 2, ZZ)\n    True\n\n    \"\"\"\n    return dmp_ground_p(f, K.one, u)",
    "sympy.sympy.polys.densebasic.dmp_one": "def dmp_one(u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate one over ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one\n\n    >>> dmp_one(2, ZZ)\n    [[[1]]]\n\n    \"\"\"\n    return dmp_ground(K.one, u, K)",
    "sympy.sympy.polys.densebasic.dmp_ground": "def dmp_ground(c: Er, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate constant.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground\n\n    >>> dmp_ground(3, 5, ZZ)\n    [[[[[[3]]]]]]\n    >>> dmp_ground(1, -1, ZZ)\n    1\n\n    \"\"\"\n    if not c:\n        return dmp_zero(u, K)\n\n    if u < 0:\n        return _ground_dmp(c)\n\n    f = _dmp([c])\n\n    for i in range(u):\n        f = [f]\n\n    return f",
    "sympy.sympy.polys.domains.domain.is_nonnegative": "def is_nonnegative(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is non-negative. \"\"\"\n    return a >= 0 # type: ignore",
    "sympy.sympy.polys.domains.gaussiandomains.is_nonnegative": "def is_nonnegative(self, a: Telem) -> bool:\n    \"\"\"Returns ``False`` for any ``GaussianElement``. \"\"\"\n    return False",
    "sympy.sympy.polys.domains.gaussiandomains.__neg__": "def __neg__(self) -> Self:\n    return self.new(-self.x, -self.y)",
    "sympy.sympy.polys.domains.polynomialring.is_nonnegative": "def is_nonnegative(self, a):\n    \"\"\"Returns True if `LC(a)` is non-negative. \"\"\"\n    return self.domain.is_nonnegative(a.LC)",
    "sympy.sympy.polys.euclidtools._dmp_simplify_gcd": "def _dmp_simplify_gcd(f, g, u, K):\n    \"\"\"Try to eliminate `x_0` from GCD computation in `K[X]`. \"\"\"\n    df = dmp_degree(f, u)\n    dg = dmp_degree(g, u)\n\n    if df > 0 and dg > 0:\n        return None\n\n    if not (df or dg):\n        F = dmp_LC(f, K)\n        G = dmp_LC(g, K)\n    else:\n        if not df:\n            F = dmp_LC(f, K)\n            G = dmp_content(g, u, K)\n        else:\n            F = dmp_content(f, u, K)\n            G = dmp_LC(g, K)\n\n    v = u - 1\n    h = dmp_gcd(F, G, v, K)\n\n    cff = [ dmp_quo(cf, h, v, K) for cf in f ]\n    cfg = [ dmp_quo(cg, h, v, K) for cg in g ]\n\n    return [h], cff, cfg",
    "sympy.sympy.polys.polyconfig.query": "def query(key: str) -> bool | int | str | None:\n    \"\"\"Ask for a value of the given configuration item. \"\"\"\n    return _current_config.get(key.upper(), None)"
}