{
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.polys.domains.domain.__ne__": "def __ne__(self, other):\n    \"\"\"Returns ``False`` if two domains are equivalent. \"\"\"\n    return not self == other",
    "sympy.sympy.polys.matrices.sdm.sdm_matmul": "def sdm_matmul(A, B, K, m, o):\n    #\n    # Should be fast if A and B are very sparse.\n    # Consider e.g. A = B = eye(1000).\n    #\n    # The idea here is that we compute C = A*B in terms of the rows of C and\n    # B since the dict of dicts representation naturally stores the matrix as\n    # rows. The ith row of C (Ci) is equal to the sum of Aik * Bk where Bk is\n    # the kth row of B. The algorithm below loops over each nonzero element\n    # Aik of A and if the corresponding row Bj is nonzero then we do\n    #    Ci += Aik * Bk.\n    # To make this more efficient we don't need to loop over all elements Aik.\n    # Instead for each row Ai we compute the intersection of the nonzero\n    # columns in Ai with the nonzero rows in B. That gives the k such that\n    # Aik and Bk are both nonzero. In Python the intersection of two sets\n    # of int can be computed very efficiently.\n    #\n    if K.is_EXRAW:\n        return sdm_matmul_exraw(A, B, K, m, o)\n\n    C = {}\n    B_knz = set(B)\n    for i, Ai in A.items():\n        Ci = {}\n        Ai_knz = set(Ai)\n        for k in Ai_knz & B_knz:\n            Aik = Ai[k]\n            for j, Bkj in B[k].items():\n                Cij = Ci.get(j, None)\n                if Cij is not None:\n                    Cij = Cij + Aik * Bkj\n                    if Cij:\n                        Ci[j] = Cij\n                    else:\n                        Ci.pop(j)\n                else:\n                    Cij = Aik * Bkj\n                    if Cij:\n                        Ci[j] = Cij\n        if Ci:\n            C[i] = Ci\n    return C",
    "sympy.sympy.polys.matrices.sdm.new": "@classmethod\ndef new(cls, sdm, shape, domain):\n    \"\"\"\n\n    Parameters\n    ==========\n\n    sdm: A dict of dicts for non-zero elements in SDM\n    shape: tuple representing dimension of SDM\n    domain: Represents :py:class:`~.Domain` of SDM\n\n    Returns\n    =======\n\n    An :py:class:`~.SDM` object\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import QQ\n    >>> elemsdict = {0:{1: QQ(2)}}\n    >>> A = SDM.new(elemsdict, (2, 2), QQ)\n    >>> A\n    {0: {1: 2}}\n\n    \"\"\"\n    return cls(sdm, shape, domain)"
}