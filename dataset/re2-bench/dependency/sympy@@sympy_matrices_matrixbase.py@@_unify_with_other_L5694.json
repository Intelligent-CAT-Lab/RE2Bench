{
    "sympy.sympy.matrices.matrixbase._convert_matrix": "def _convert_matrix(typ, mat):\n    \"\"\"Convert mat to a Matrix of type typ.\"\"\"\n    from sympy.matrices.matrixbase import MatrixBase\n    if getattr(mat, \"is_Matrix\", False) and not isinstance(mat, MatrixBase):\n        # This is needed for interop between Matrix and the redundant matrix\n        # mixin types like _MinimalMatrix etc. If anyone should happen to be\n        # using those then this keeps them working. Really _MinimalMatrix etc\n        # should be deprecated and removed though.\n        return typ(*mat.shape, list(mat))\n    else:\n        return typ(mat)",
    "sympy.sympy.matrices.matrixbase._coerce_operand": "def _coerce_operand(self, other: Any\n    ) -> (tuple[None, Literal['invalid_type']]\n          | tuple[MatrixBase, Literal['is_matrix']]\n          | tuple[Expr, Literal['possible_scalar']]):\n    \"\"\"Convert other to a Matrix, or check for possible scalar.\"\"\"\n\n    # Disallow mixing Matrix and Array\n    if isinstance(other, NDimArray):\n        return None, 'invalid_type'\n\n    is_Matrix = getattr(other, 'is_Matrix', None)\n\n    # Return a Matrix as-is\n    if is_Matrix:\n        return other, 'is_matrix'\n\n    # Try to convert numpy array, mpmath matrix etc.\n    if is_Matrix is None:\n        if _has_matrix_shape(other) or _has_rows_cols(other):\n            return _convert_matrix(type(self), other), 'is_matrix'\n\n    # Could be a scalar but only if not iterable...\n    if not isinstance(other, Iterable):\n        return other, 'possible_scalar'\n\n    return None, 'invalid_type'",
    "sympy.sympy.matrices.matrixbase.classof": "def classof(A: Tmat, B: Tmat) -> type[Tmat]:\n    \"\"\"\n    Get the type of the result when combining matrices of different types.\n\n    Currently the strategy is that immutability is contagious.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, ImmutableMatrix\n    >>> from sympy.matrices.matrixbase import classof\n    >>> M = Matrix([[1, 2], [3, 4]]) # a Mutable Matrix\n    >>> IM = ImmutableMatrix([[1, 2], [3, 4]])\n    >>> classof(M, IM)\n    <class 'sympy.matrices.immutable.ImmutableDenseMatrix'>\n    \"\"\"\n    priority_A = getattr(A, '_class_priority', None)\n    priority_B = getattr(B, '_class_priority', None)\n    if None not in (priority_A, priority_B):\n        if A._class_priority > B._class_priority:\n            return A.__class__\n        else:\n            return B.__class__\n\n    try:\n        import numpy\n    except ImportError:\n        pass\n    else:\n        if isinstance(A, numpy.ndarray):\n            return B.__class__\n        if isinstance(B, numpy.ndarray):\n            return A.__class__\n\n    raise TypeError(\"Incompatible classes %s, %s\" % (A.__class__, B.__class__))"
}