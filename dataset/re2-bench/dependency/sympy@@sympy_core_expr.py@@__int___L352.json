{
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.core.basic.is_comparable": "@property\ndef is_comparable(self):\n    \"\"\"Return True if self can be computed to a real number\n    (or already is a real number) with precision, else False.\n\n    Examples\n    ========\n\n    >>> from sympy import exp_polar, pi, I\n    >>> (I*exp_polar(I*pi/2)).is_comparable\n    True\n    >>> (I*exp_polar(I*pi*2)).is_comparable\n    False\n\n    A False result does not mean that `self` cannot be rewritten\n    into a form that would be comparable. For example, the\n    difference computed below is zero but without simplification\n    it does not evaluate to a zero with precision:\n\n    >>> e = 2**pi*(1 + 2**pi)\n    >>> dif = e - e.expand()\n    >>> dif.is_comparable\n    False\n    >>> dif.n(2)._prec\n    1\n\n    \"\"\"\n    return self._eval_is_comparable()",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.round": "def round(self, n=None):\n    \"\"\"Return x rounded to the given decimal place.\n\n    If a complex number would result, apply round to the real\n    and imaginary components of the number.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, E, I, S, Number\n    >>> pi.round()\n    3\n    >>> pi.round(2)\n    3.14\n    >>> (2*pi + E*I).round()\n    6 + 3*I\n\n    The round method has a chopping effect:\n\n    >>> (2*pi + I/10).round()\n    6\n    >>> (pi/10 + 2*I).round()\n    2*I\n    >>> (pi/10 + E*I).round(2)\n    0.31 + 2.72*I\n\n    Notes\n    =====\n\n    The Python ``round`` function uses the SymPy ``round`` method so it\n    will always return a SymPy number (not a Python float or int):\n\n    >>> isinstance(round(S(123), -2), Number)\n    True\n    \"\"\"\n    x = self\n\n    if not x.is_number:\n        raise TypeError(\"Cannot round symbolic expression\")\n    if not x.is_Atom:\n        if not pure_complex(x.n(2), or_real=True):\n            raise TypeError(\n                'Expected a number but got %s:' % func_name(x))\n    elif x in _illegal:\n        return x\n    if not (xr := x.is_extended_real):\n        r, i = x.as_real_imag()\n        if xr is False:\n            return r.round(n) + S.ImaginaryUnit*i.round(n)\n        if i.equals(0):\n            return r.round(n)\n    if not x:\n        return S.Zero if n is None else x\n\n    p = as_int(n or 0)\n\n    if x.is_Integer:\n        return Integer(round(int(x), p))\n\n    digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1\n    allow = digits_to_decimal + p\n    precs = [f._prec for f in x.atoms(Float)]\n    dps = prec_to_dps(max(precs)) if precs else None\n    if dps is None:\n        # assume everything is exact so use the Python\n        # float default or whatever was requested\n        dps = max(15, allow)\n    else:\n        allow = min(allow, dps)\n    # this will shift all digits to right of decimal\n    # and give us dps to work with as an int\n    shift = -digits_to_decimal + dps\n    extra = 1  # how far we look past known digits\n    # NOTE\n    # mpmath will calculate the binary representation to\n    # an arbitrary number of digits but we must base our\n    # answer on a finite number of those digits, e.g.\n    # .575 2589569785738035/2**52 in binary.\n    # mpmath shows us that the first 18 digits are\n    #     >>> Float(.575).n(18)\n    #     0.574999999999999956\n    # The default precision is 15 digits and if we ask\n    # for 15 we get\n    #     >>> Float(.575).n(15)\n    #     0.575000000000000\n    # mpmath handles rounding at the 15th digit. But we\n    # need to be careful since the user might be asking\n    # for rounding at the last digit and our semantics\n    # are to round toward the even final digit when there\n    # is a tie. So the extra digit will be used to make\n    # that decision. In this case, the value is the same\n    # to 15 digits:\n    #     >>> Float(.575).n(16)\n    #     0.5750000000000000\n    # Now converting this to the 15 known digits gives\n    #     575000000000000.0\n    # which rounds to integer\n    #    5750000000000000\n    # And now we can round to the desired digt, e.g. at\n    # the second from the left and we get\n    #    5800000000000000\n    # and rescaling that gives\n    #    0.58\n    # as the final result.\n    # If the value is made slightly less than 0.575 we might\n    # still obtain the same value:\n    #    >>> Float(.575-1e-16).n(16)*10**15\n    #    574999999999999.8\n    # What 15 digits best represents the known digits (which are\n    # to the left of the decimal? 5750000000000000, the same as\n    # before. The only way we will round down (in this case) is\n    # if we declared that we had more than 15 digits of precision.\n    # For example, if we use 16 digits of precision, the integer\n    # we deal with is\n    #    >>> Float(.575-1e-16).n(17)*10**16\n    #    5749999999999998.4\n    # and this now rounds to 5749999999999998 and (if we round to\n    # the 2nd digit from the left) we get 5700000000000000.\n    #\n    xf = x.n(dps + extra)*Pow(10, shift)\n    if xf.is_Number and xf._prec == 1:  # xf.is_Add will raise below\n        # is x == 0?\n        if x.equals(0):\n            return Float(0)\n        raise ValueError('not computing with precision')\n    xi = Integer(xf)\n    # use the last digit to select the value of xi\n    # nearest to x before rounding at the desired digit\n    sign = 1 if x > 0 else -1\n    dif2 = sign*(xf - xi).n(extra)\n    if dif2 < 0:\n        raise NotImplementedError(\n            'not expecting int(x) to round away from 0')\n    if dif2 > .5:\n        xi += sign  # round away from 0\n    elif dif2 == .5:\n        xi += sign if xi%2 else -sign  # round toward even\n    # shift p to the new position\n    ip = p - shift\n    # let Python handle the int rounding then rescale\n    xr = round(xi.p, ip)\n    # restore scale\n    rv = Rational(xr, Pow(10, shift))\n    # return Float or Integer\n    if rv.is_Integer:\n        if n is None:  # the single-arg case\n            return rv\n        # use str or else it won't be a float\n        return Float(str(rv), dps)  # keep same precision\n    else:\n        if not allow and rv > self:\n            allow += 1\n        return Float(rv, allow)",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.expr.equals": "def equals(self, other, failing_expression=False):\n    \"\"\"Return True if self == other, False if it does not, or None. If\n    failing_expression is True then the expression which did not simplify\n    to a 0 will be returned instead of None.\n\n    Explanation\n    ===========\n\n    If ``self`` is a Number (or complex number) that is not zero, then\n    the result is False.\n\n    If ``self`` is a number and has not evaluated to zero, evalf will be\n    used to test whether the expression evaluates to zero. If it does so\n    and the result has significance (i.e. the precision is either -1, for\n    a Rational result, or is greater than 1) then the evalf value will be\n    used to return True or False.\n\n    \"\"\"\n    from sympy.simplify.simplify import nsimplify, simplify\n    from sympy.solvers.solvers import solve\n    from sympy.polys.polyerrors import NotAlgebraic\n    from sympy.polys.numberfields import minimal_polynomial\n\n    other = sympify(other)\n\n    if not isinstance(other, Expr):\n        return False\n\n    if self == other:\n        return True\n\n    # they aren't the same so see if we can make the difference 0;\n    # don't worry about doing simplification steps one at a time\n    # because if the expression ever goes to 0 then the subsequent\n    # simplification steps that are done will be very fast.\n    diff = factor_terms(simplify(self - other), radical=True)\n\n    if not diff:\n        return True\n\n    if not diff.has(Add, Mod):\n        # if there is no expanding to be done after simplifying\n        # then this can't be a zero\n        return False\n\n    factors = diff.as_coeff_mul()[1]\n    if len(factors) > 1:  # avoid infinity recursion\n        fac_zero = [fac.equals(0) for fac in factors]\n        if None not in fac_zero:  # every part can be decided\n            return any(fac_zero)\n\n    constant = diff.is_constant(simplify=False, failing_number=True)\n\n    if constant is False:\n        return False\n\n    if not diff.is_number:\n        if constant is None:\n            # e.g. unless the right simplification is done, a symbolic\n            # zero is possible (see expression of issue 6829: without\n            # simplification constant will be None).\n            return\n\n    if constant is True:\n        # this gives a number whether there are free symbols or not\n        ndiff = diff._random()\n        # is_comparable will work whether the result is real\n        # or complex; it could be None, however.\n        if ndiff and ndiff.is_comparable:\n            return False\n\n    # sometimes we can use a simplified result to give a clue as to\n    # what the expression should be; if the expression is *not* zero\n    # then we should have been able to compute that and so now\n    # we can just consider the cases where the approximation appears\n    # to be zero -- we try to prove it via minimal_polynomial.\n    #\n    # removed\n    # ns = nsimplify(diff)\n    # if diff.is_number and (not ns or ns == diff):\n    #\n    # The thought was that if it nsimplifies to 0 that's a sure sign\n    # to try the following to prove it; or if it changed but wasn't\n    # zero that might be a sign that it's not going to be easy to\n    # prove. But tests seem to be working without that logic.\n    #\n    if diff.is_number:\n        # try to prove via self-consistency\n        surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n        # it seems to work better to try big ones first\n        surds.sort(key=lambda x: -x.args[0])\n        for s in surds:\n            try:\n                # simplify is False here -- this expression has already\n                # been identified as being hard to identify as zero;\n                # we will handle the checking ourselves using nsimplify\n                # to see if we are in the right ballpark or not and if so\n                # *then* the simplification will be attempted.\n                sol = solve(diff, s, simplify=False)\n                if sol:\n                    if s in sol:\n                        # the self-consistent result is present\n                        return True\n                    if all(si.is_Integer for si in sol):\n                        # perfect powers are removed at instantiation\n                        # so surd s cannot be an integer\n                        return False\n                    if all(i.is_algebraic is False for i in sol):\n                        # a surd is algebraic\n                        return False\n                    if any(si in surds for si in sol):\n                        # it wasn't equal to s but it is in surds\n                        # and different surds are not equal\n                        return False\n                    if any(nsimplify(s - si) == 0 and\n                            simplify(s - si) == 0 for si in sol):\n                        return True\n                    if s.is_real:\n                        if any(nsimplify(si, [s]) == s and simplify(si) == s\n                                for si in sol):\n                            return True\n            except NotImplementedError:\n                pass\n\n        # try to prove with minimal_polynomial but know when\n        # *not* to use this or else it can take a long time. e.g. issue 8354\n        if True:  # change True to condition that assures non-hang\n            try:\n                mp = minimal_polynomial(diff)\n                if mp.is_Symbol:\n                    return True\n                return False\n            except (NotAlgebraic, NotImplementedError):\n                pass\n\n    # diff has not simplified to zero; constant is either None, True\n    # or the number with significance (is_comparable) that was randomly\n    # calculated twice as the same value.\n    if constant not in (True, None) and constant != 0:\n        return False\n\n    if failing_expression:\n        return diff\n    return None",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    if self._mpf_ == fzero:\n        return 0\n    return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    # NaN is structurally equal to another NaN\n    return other is S.NaN",
    "sympy.sympy.core.numbers.int_valued": "def int_valued(x):\n    \"\"\"return True only for a literal Number whose internal\n    representation as a fraction has a denominator of 1,\n    else False, i.e. integer, with no fractional part.\n    \"\"\"\n    if isinstance(x, (SYMPY_INTS, int)):\n        return True\n    if type(x) is float:\n        return x.is_integer()\n    if isinstance(x, Integer):\n        return True\n    if isinstance(x, Float):\n        # x = s*m*2**p; _mpf_ = s,m,e,p\n        return x._mpf_[2] >= 0\n    return False  # or add new types to recognize"
}