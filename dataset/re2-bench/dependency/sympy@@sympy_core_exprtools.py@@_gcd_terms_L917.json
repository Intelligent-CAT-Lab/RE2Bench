{
    "sympy.sympy.core.add.primitive": "def primitive(self):\n    \"\"\"\n    Return ``(R, self/R)`` where ``R``` is the Rational GCD of ``self```.\n\n    ``R`` is collected only from the leading coefficient of each term.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n\n    >>> (2*x + 4*y).primitive()\n    (2, x + 2*y)\n\n    >>> (2*x/3 + 4*y/9).primitive()\n    (2/9, 3*x + 2*y)\n\n    >>> (2*x/3 + 4.2*y).primitive()\n    (1/3, 2*x + 12.6*y)\n\n    No subprocessing of term factors is performed:\n\n    >>> ((2 + 2*x)*x + 2).primitive()\n    (1, x*(2*x + 2) + 2)\n\n    Recursive processing can be done with the ``as_content_primitive()``\n    method:\n\n    >>> ((2 + 2*x)*x + 2).as_content_primitive()\n    (2, x*(x + 1) + 1)\n\n    See also: primitive() function in polytools.py\n\n    \"\"\"\n\n    terms = []\n    inf = False\n    for a in self.args:\n        c, m = a.as_coeff_Mul()\n        if not c.is_Rational:\n            c = S.One\n            m = a\n        inf = inf or m is S.ComplexInfinity\n        terms.append((c.p, c.q, m))\n\n    if not inf:\n        ngcd = reduce(igcd, [t[0] for t in terms], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms], 1)\n    else:\n        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n\n    if ngcd == dlcm == 1:\n        return S.One, self\n    if not inf:\n        for i, (p, q, term) in enumerate(terms):\n            terms[i] = _keep_coeff(Rational((p//ngcd)*(dlcm//q)), term)\n    else:\n        for i, (p, q, term) in enumerate(terms):\n            if q:\n                terms[i] = _keep_coeff(Rational((p//ngcd)*(dlcm//q)), term)\n            else:\n                terms[i] = _keep_coeff(Rational(p, q), term)\n\n    # we don't need a complete re-flattening since no new terms will join\n    # so we just use the same sort as is used in Add.flatten. When the\n    # coefficient changes, the ordering of terms may change, e.g.\n    #     (3*x, 6*y) -> (2*y, x)\n    #\n    # We do need to make sure that term[0] stays in position 0, however.\n    #\n    if terms[0].is_Number or terms[0] is S.ComplexInfinity:\n        c = terms.pop(0)\n    else:\n        c = None\n    _addsort(terms)\n    if c:\n        terms.insert(0, c)\n    return Rational(ngcd, dlcm), self._new_rawargs(*terms)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.exprtools.as_expr": "def as_expr(self):  # Term\n    return self.coeff*(self.numer.as_expr()/self.denom.as_expr())",
    "sympy.sympy.core.exprtools.mul": "def mul(self, other):  # Factors\n    \"\"\"Return Factors of ``self * other``.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.mul(b)\n    Factors({x: 2, y: 3, z: -1})\n    >>> a*b\n    Factors({x: 2, y: 3, z: -1})\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n    if any(f.is_zero for f in (self, other)):\n        return Factors(S.Zero)\n    factors = dict(self.factors)\n\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = factors[factor] + exp\n\n            if not exp:\n                del factors[factor]\n                continue\n\n        factors[factor] = exp\n\n    return Factors(factors)",
    "sympy.sympy.core.exprtools.quo": "def quo(self, other):  # Term\n    return self.mul(other.inv())",
    "sympy.sympy.core.exprtools.lcm": "def lcm(self, other):  # Factors\n    \"\"\"Return Factors of ``lcm(self, other)`` which are\n    the union of factors with the maximum exponent for\n    each factor.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.lcm(b)\n    Factors({x: 1, y: 2, z: -1})\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if any(f.is_zero for f in (self, other)):\n            return Factors(S.Zero)\n\n    factors = dict(self.factors)\n\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = max(exp, factors[factor])\n\n        factors[factor] = exp\n\n    return Factors(factors)",
    "sympy.sympy.core.exprtools.__init__": "def __init__(self, term, numer=None, denom=None):  # Term\n    if numer is None and denom is None:\n        if not term.is_commutative:\n            raise NonCommutativeExpression(\n                'commutative expression expected')\n\n        coeff, factors = term.as_coeff_mul()\n        numer, denom = defaultdict(int), defaultdict(int)\n\n        for factor in factors:\n            base, exp = decompose_power(factor)\n\n            if base.is_Add:\n                cont, base = base.primitive()\n                coeff *= cont**exp\n\n            if exp > 0:\n                numer[base] += exp\n            else:\n                denom[base] += -exp\n\n        numer = Factors(numer)\n        denom = Factors(denom)\n    else:\n        coeff = term\n\n        if numer is None:\n            numer = Factors()\n\n        if denom is None:\n            denom = Factors()\n\n    self.coeff = coeff\n    self.numer = numer\n    self.denom = denom",
    "sympy.sympy.core.exprtools.gcd": "def gcd(self, other):  # Term\n    return Term(self.coeff.gcd(other.coeff),\n                self.numer.gcd(other.numer),\n                self.denom.gcd(other.denom))",
    "sympy.sympy.core.exprtools.<listcomp>": "numers = [t.as_expr() for t in terms]\n",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)"
}