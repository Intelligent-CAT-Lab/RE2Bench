{
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.__format__": "def __format__(self, format_spec: str):\n    if self.is_number:\n        mt = re.match(r'\\+?\\d*\\.(\\d+)f', format_spec)\n        if mt:\n            prec = int(mt.group(1))\n            rounded = self.round(prec)\n            if rounded.is_Integer:\n                return format(int(rounded), format_spec)\n            if rounded.is_Float:\n                return format(rounded, format_spec)\n    return super().__format__(format_spec)",
    "sympy.sympy.core.numbers.__format__": "def __format__(self, format_spec):\n    return format(fractions.Fraction(self.p, self.q), format_spec)",
    "sympy.sympy.external.ntheory.remove": "def remove(x, f):\n    if f < 2:\n        raise ValueError(\"factor must be > 1\")\n    if x == 0:\n        return 0, 0\n    if f == 2:\n        b = bit_scan1(x)\n        return x >> b, b\n    m = 0\n    y, rem = divmod(x, f)\n    while not rem:\n        x = y\n        m += 1\n        if m > 5:\n            pow_list = [f**2]\n            while pow_list:\n                _f = pow_list[-1]\n                y, rem = divmod(x, _f)\n                if not rem:\n                    m += 1 << len(pow_list)\n                    x = y\n                    pow_list.append(_f**2)\n                else:\n                    pow_list.pop()\n        y, rem = divmod(x, f)\n    return x, m",
    "sympy.sympy.ntheory.factor_.multiplicity": "def multiplicity(p, n):\n    \"\"\"\n    Find the greatest integer m such that p**m divides n.\n\n    Examples\n    ========\n\n    >>> from sympy import multiplicity, Rational\n    >>> [multiplicity(5, n) for n in [8, 5, 25, 125, 250]]\n    [0, 1, 2, 3, 3]\n    >>> multiplicity(3, Rational(1, 9))\n    -2\n\n    Note: when checking for the multiplicity of a number in a\n    large factorial it is most efficient to send it as an unevaluated\n    factorial or to call ``multiplicity_in_factorial`` directly:\n\n    >>> from sympy.ntheory import multiplicity_in_factorial\n    >>> from sympy import factorial\n    >>> p = factorial(25)\n    >>> n = 2**100\n    >>> nfac = factorial(n, evaluate=False)\n    >>> multiplicity(p, nfac)\n    52818775009509558395695966887\n    >>> _ == multiplicity_in_factorial(p, n)\n    True\n\n    See Also\n    ========\n\n    trailing\n\n    \"\"\"\n    try:\n        p, n = as_int(p), as_int(n)\n    except ValueError:\n        from sympy.functions.combinatorial.factorials import factorial\n        if all(isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n)):\n            p = Rational(p)\n            n = Rational(n)\n            if p.q == 1:\n                if n.p == 1:\n                    return -multiplicity(p.p, n.q)\n                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)\n            elif p.p == 1:\n                return multiplicity(p.q, n.q)\n            else:\n                like = min(\n                    multiplicity(p.p, n.p),\n                    multiplicity(p.q, n.q))\n                cross = min(\n                    multiplicity(p.q, n.p),\n                    multiplicity(p.p, n.q))\n                return like - cross\n        elif (isinstance(p, (SYMPY_INTS, Integer)) and\n                isinstance(n, factorial) and\n                isinstance(n.args[0], Integer) and\n                n.args[0] >= 0):\n            return multiplicity_in_factorial(p, n.args[0])\n        raise ValueError(f\"expecting ints or fractions, got {p} and {n}\")\n\n    if n == 0:\n        raise ValueError(f\"no such integer exists: multiplicity of {n} is not-defined\")\n    return remove(n, p)[1]",
    "sympy.sympy.ntheory.factor_.<genexpr>": "if all(isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n)):\n    p = Rational(p)\n    n = Rational(n)\n    if p.q == 1:\n        if n.p == 1:\n            return -multiplicity(p.p, n.q)\n        return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)\n    elif p.p == 1:\n        return multiplicity(p.q, n.q)\n    else:\n        like = min(\n            multiplicity(p.p, n.p),\n            multiplicity(p.q, n.q))\n        cross = min(\n            multiplicity(p.q, n.p),\n            multiplicity(p.p, n.q))\n        return like - cross\n",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}