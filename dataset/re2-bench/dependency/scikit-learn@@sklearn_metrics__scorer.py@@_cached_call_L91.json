{
    "scikit-learn.sklearn.utils._response._get_response_values": "def _get_response_values(\n    estimator,\n    X,\n    response_method,\n    pos_label=None,\n    return_response_method_used=False,\n):\n    \"\"\"Compute the response values of a classifier, an outlier detector, or a regressor.\n\n    The response values are predictions such that it follows the following shape:\n\n    - for binary classification, it is a 1d array of shape `(n_samples,)`;\n    - for multiclass classification, it is a 2d array of shape `(n_samples, n_classes)`;\n    - for multilabel classification, it is a 2d array of shape `(n_samples, n_outputs)`;\n    - for outlier detection, it is a 1d array of shape `(n_samples,)`;\n    - for regression, it is a 1d array of shape `(n_samples,)`.\n\n    If `estimator` is a binary classifier, also return the label for the\n    effective positive class.\n\n    This utility is used primarily in the displays and the scikit-learn scorers.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Fitted classifier, outlier detector, or regressor or a\n        fitted :class:`~sklearn.pipeline.Pipeline` in which the last estimator is a\n        classifier, an outlier detector, or a regressor.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input values.\n\n    response_method : {\"predict_proba\", \"predict_log_proba\", \"decision_function\", \\\n            \"predict\"} or list of such str\n        Specifies the response method to use get prediction from an estimator\n        (i.e. :term:`predict_proba`, :term:`predict_log_proba`,\n        :term:`decision_function` or :term:`predict`). Possible choices are:\n\n        - if `str`, it corresponds to the name to the method to return;\n        - if a list of `str`, it provides the method names in order of\n          preference. The method returned corresponds to the first method in\n          the list and which is implemented by `estimator`.\n\n    pos_label : int, float, bool or str, default=None\n        The class considered as the positive class when computing\n        the metrics. If `None` and target is 'binary', `estimators.classes_[1]` is\n        considered as the positive class.\n\n    return_response_method_used : bool, default=False\n        Whether to return the response method used to compute the response\n        values.\n\n        .. versionadded:: 1.4\n\n    Returns\n    -------\n    y_pred : ndarray of shape (n_samples,), (n_samples, n_classes) or \\\n            (n_samples, n_outputs)\n        Target scores calculated from the provided `response_method`\n        and `pos_label`.\n\n    pos_label : int, float, bool, str or None\n        The class considered as the positive class when computing\n        the metrics. Returns `None` if `estimator` is a regressor or an outlier\n        detector.\n\n    response_method_used : str\n        The response method used to compute the response values. Only returned\n        if `return_response_method_used` is `True`.\n\n        .. versionadded:: 1.4\n\n    Raises\n    ------\n    ValueError\n        If `pos_label` is not a valid label.\n        If the shape of `y_pred` is not consistent for binary classifier.\n        If the response method can be applied to a classifier only and\n        `estimator` is a regressor.\n    \"\"\"\n    from sklearn.base import is_classifier, is_outlier_detector\n\n    if is_classifier(estimator):\n        prediction_method = _check_response_method(estimator, response_method)\n        classes = estimator.classes_\n        target_type = type_of_target(classes)\n\n        if target_type in (\"binary\", \"multiclass\"):\n            if pos_label is not None and pos_label not in classes.tolist():\n                raise ValueError(\n                    f\"pos_label={pos_label} is not a valid label: It should be \"\n                    f\"one of {classes}\"\n                )\n            elif pos_label is None and target_type == \"binary\":\n                pos_label = classes[-1]\n\n        y_pred = prediction_method(X)\n\n        if prediction_method.__name__ in (\"predict_proba\", \"predict_log_proba\"):\n            y_pred = _process_predict_proba(\n                y_pred=y_pred,\n                target_type=target_type,\n                classes=classes,\n                pos_label=pos_label,\n            )\n        elif prediction_method.__name__ == \"decision_function\":\n            y_pred = _process_decision_function(\n                y_pred=y_pred,\n                target_type=target_type,\n                classes=classes,\n                pos_label=pos_label,\n            )\n    elif is_outlier_detector(estimator):\n        prediction_method = _check_response_method(estimator, response_method)\n        y_pred, pos_label = prediction_method(X), None\n    else:  # estimator is a regressor\n        if response_method != \"predict\":\n            raise ValueError(\n                f\"{estimator.__class__.__name__} should either be a classifier to be \"\n                f\"used with response_method={response_method} or the response_method \"\n                \"should be 'predict'. Got a regressor with response_method=\"\n                f\"{response_method} instead.\"\n            )\n        prediction_method = estimator.predict\n        y_pred, pos_label = prediction_method(X), None\n\n    if return_response_method_used:\n        return y_pred, pos_label, prediction_method.__name__\n    return y_pred, pos_label"
}