{
    "scikit-learn.sklearn.externals.array_api_compat.numpy._aliases.asarray": "def asarray(\n    obj: Array | complex | NestedSequence[complex] | SupportsBufferProtocol,\n    /,\n    *,\n    dtype: DType | None = None,\n    device: Device | None = None,\n    copy: _Copy | None = None,\n    **kwargs: Any,\n) -> Array:\n    \"\"\"\n    Array API compatibility wrapper for asarray().\n\n    See the corresponding documentation in the array library and/or the array API\n    specification for more details.\n    \"\"\"\n    _helpers._check_device(np, device)\n\n    if copy is None:\n        copy = np._CopyMode.IF_NEEDED\n    elif copy is False:\n        copy = np._CopyMode.NEVER\n    elif copy is True:\n        copy = np._CopyMode.ALWAYS\n\n    return np.array(obj, copy=copy, dtype=dtype, **kwargs)  # pyright: ignore",
    "scikit-learn.sklearn.utils._array_api.device": "def device(*array_list, remove_none=True, remove_types=(str,)):\n    \"\"\"Hardware device where the array data resides on.\n\n    If the hardware device is not the same for all arrays, an error is raised.\n\n    Parameters\n    ----------\n    *array_list : arrays\n        List of array instances from NumPy or an array API compatible library.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in array_list.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in array_list.\n\n    Returns\n    -------\n    out : device\n        `device` object (see the \"Device Support\" section of the array API spec).\n    \"\"\"\n    array_list = _remove_non_arrays(\n        *array_list, remove_none=remove_none, remove_types=remove_types\n    )\n\n    if not array_list:\n        return None\n\n    device_ = _single_array_device(array_list[0])\n\n    # Note: here we cannot simply use a Python `set` as it requires\n    # hashable members which is not guaranteed for Array API device\n    # objects. In particular, CuPy devices are not hashable at the\n    # time of writing.\n    for array in array_list[1:]:\n        device_other = _single_array_device(array)\n        if device_ != device_other:\n            raise ValueError(\n                f\"Input arrays use different devices: {device_}, {device_other}\"\n            )\n\n    return device_",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils._array_api._add_to_diagonal": "def _add_to_diagonal(array, value, xp):\n    \"\"\"Add `value` to diagonal of `array`.\n\n    Related to `fill_diagonal`. `value` should be a scalar or\n    1D of greater or equal length as the diagonal (i.e., `value` is never repeated\n    when shorter).\n\n    Note `array` is altered in place.\n    \"\"\"\n    value, min_rows_columns = _validate_diagonal_args(array, value, xp)\n\n    if _is_numpy_namespace(xp):\n        step = array.shape[1] + 1\n        # Ensure we do not wrap\n        end = array.shape[1] * array.shape[1]\n        array.flat[:end:step] += value\n        return\n\n    # TODO: when array libraries support `reshape(copy)`, use\n    # `reshape(array, (-1,), copy=False)`, then fill with `[:end:step]` (within\n    # `try/except`). This is faster than for loop, when no copy needs to be\n    # made within `reshape`. See #31445 for details.\n    value = xp.linalg.diagonal(array) + value\n    for i in range(min_rows_columns):\n        array[i, i] = value[i]"
}