{
    "scikit-learn.sklearn.svm._base._one_vs_one_coef": "def _one_vs_one_coef(dual_coef, n_support, support_vectors):\n    \"\"\"Generate primal coefficients from dual coefficients\n    for the one-vs-one multi class LibSVM in the case\n    of a linear kernel.\"\"\"\n\n    # get 1vs1 weights for all n*(n-1) classifiers.\n    # this is somewhat messy.\n    # shape of dual_coef_ is nSV * (n_classes -1)\n    # see docs for details\n    n_class = dual_coef.shape[0] + 1\n\n    # XXX we could do preallocation of coef but\n    # would have to take care in the sparse case\n    coef = []\n    sv_locs = np.cumsum(np.hstack([[0], n_support]))\n    for class1 in range(n_class):\n        # SVs for class1:\n        sv1 = support_vectors[sv_locs[class1] : sv_locs[class1 + 1], :]\n        for class2 in range(class1 + 1, n_class):\n            # SVs for class1:\n            sv2 = support_vectors[sv_locs[class2] : sv_locs[class2 + 1], :]\n\n            # dual coef for class1 SVs:\n            alpha1 = dual_coef[class2 - 1, sv_locs[class1] : sv_locs[class1 + 1]]\n            # dual coef for class2 SVs:\n            alpha2 = dual_coef[class1, sv_locs[class2] : sv_locs[class2 + 1]]\n            # build weight for class1 vs class2\n\n            coef.append(safe_sparse_dot(alpha1, sv1) + safe_sparse_dot(alpha2, sv2))\n    return coef",
    "scikit-learn.sklearn.utils.extmath.safe_sparse_dot": "def safe_sparse_dot(a, b, *, dense_output=False):\n    \"\"\"Dot product that handle the sparse matrix case correctly.\n\n    Parameters\n    ----------\n    a : {ndarray, sparse matrix}\n    b : {ndarray, sparse matrix}\n    dense_output : bool, default=False\n        When False, ``a`` and ``b`` both being sparse will yield sparse output.\n        When True, output will always be a dense array.\n\n    Returns\n    -------\n    dot_product : {ndarray, sparse matrix}\n        Sparse if ``a`` and ``b`` are sparse and ``dense_output=False``.\n\n    Examples\n    --------\n    >>> from scipy.sparse import csr_matrix\n    >>> from sklearn.utils.extmath import safe_sparse_dot\n    >>> X = csr_matrix([[1, 2], [3, 4], [5, 6]])\n    >>> dot_product = safe_sparse_dot(X, X.T)\n    >>> dot_product.toarray()\n    array([[ 5, 11, 17],\n           [11, 25, 39],\n           [17, 39, 61]])\n    \"\"\"\n    xp, _ = get_namespace(a, b)\n    if a.ndim > 2 or b.ndim > 2:\n        if sparse.issparse(a):\n            # sparse is always 2D. Implies b is 3D+\n            # [i, j] @ [k, ..., l, m, n] -> [i, k, ..., l, n]\n            b_ = np.rollaxis(b, -2)\n            b_2d = b_.reshape((b.shape[-2], -1))\n            ret = a @ b_2d\n            ret = ret.reshape(a.shape[0], *b_.shape[1:])\n        elif sparse.issparse(b):\n            # sparse is always 2D. Implies a is 3D+\n            # [k, ..., l, m] @ [i, j] -> [k, ..., l, j]\n            a_2d = a.reshape(-1, a.shape[-1])\n            ret = a_2d @ b\n            ret = ret.reshape(*a.shape[:-1], b.shape[1])\n        else:\n            # Alternative for `np.dot` when dealing with a or b having\n            # more than 2 dimensions, that works with the array api.\n            # If b is 1-dim then the last axis for b is taken otherwise\n            # if b is >= 2-dim then the second to last axis is taken.\n            b_axis = -1 if b.ndim == 1 else -2\n            ret = xp.tensordot(a, b, axes=[-1, b_axis])\n    elif (\n        dense_output\n        and a.ndim == 2\n        and b.ndim == 2\n        and a.dtype in (np.float32, np.float64)\n        and b.dtype in (np.float32, np.float64)\n        and (sparse.issparse(a) and a.format in (\"csc\", \"csr\"))\n        and (sparse.issparse(b) and b.format in (\"csc\", \"csr\"))\n    ):\n        # Use dedicated fast method for dense_C = sparse_A @\u00a0sparse_B\n        return sparse_matmul_to_dense(a, b)\n    else:\n        ret = a @ b\n\n    if (\n        sparse.issparse(a)\n        and sparse.issparse(b)\n        and dense_output\n        and hasattr(ret, \"toarray\")\n    ):\n        return ret.toarray()\n    return ret"
}