{
    "sympy.sympy.polys.densearith.dmp_mul_ground": "def dmp_mul_ground(f: dmp[Er], c: Er, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul_ground(2*x + 2*y, ZZ(3))\n    6*x + 6*y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_mul_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densebasic.dmp_degree": "def dmp_degree(f: dmp[Er], u: int) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``x_0`` in ``K[X]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree\n\n    >>> dmp_degree([[[]]], 2)\n    -1\n\n    >>> f = ZZ.map([[2], [1, 2, 3]])\n\n    >>> dmp_degree(f, 1)\n    1\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    if dmp_zero_p(f, u):\n        return -1\n    else:\n        return len(f) - 1",
    "sympy.sympy.polys.densebasic.dmp_strip": "def dmp_strip(f: dmp[Er], u: int, K: Domain[Er] | None = None) -> dmp[Er]:\n    \"\"\"\n    Remove leading zeros from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_strip\n\n    >>> dmp_strip([[], [0, 1, 2], [1]], 1)\n    [[0, 1, 2], [1]]\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_strip(_dup(f), K))\n\n    if dmp_zero_p(f, u):\n        return f\n\n    i, v = 0, u - 1\n\n    for c in f:\n        if not dmp_zero_p(c, v):\n            break\n        else:\n            i += 1\n\n    if i == len(f):\n        return dmp_zero(u, K)\n    else:\n        return f[i:]",
    "sympy.sympy.polys.densebasic.dmp_zero": "def dmp_zero(u: int, K: Domain[Er] | None = None) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero\n\n    >>> dmp_zero(4)\n    [[[[[]]]]]\n\n    \"\"\"\n    r: dmp[Er] = []\n\n    for i in range(u):\n        r = [r]\n\n    return r",
    "sympy.sympy.polys.densebasic._dup": "def _dup(p, /):\n    return p",
    "sympy.sympy.polys.densebasic._dmp": "def _dmp(p, /):\n    return p",
    "sympy.sympy.polys.densetools.dup_diff": "def dup_diff(f: dup[Er], m: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    ``m``-th order derivative of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_diff(x**3 + 2*x**2 + 3*x + 4, 1)\n    3*x**2 + 4*x + 3\n    >>> R.dup_diff(x**3 + 2*x**2 + 3*x + 4, 2)\n    6*x + 4\n\n    \"\"\"\n    if m <= 0:\n        return f\n\n    n = dup_degree(f)\n\n    if n < m:\n        return []\n\n    deriv: list[Er] = []\n\n    if m == 1:\n        for coeff in f[:-m]:\n            deriv.append(K(n)*coeff)\n            n -= 1\n    else:\n        for coeff in f[:-m]:\n            k = n\n\n            for i in range(n - 1, n - m, -1):\n                k *= i\n\n            deriv.append(K(k)*coeff)\n            n -= 1\n\n    return dup_strip(deriv, K)",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)"
}