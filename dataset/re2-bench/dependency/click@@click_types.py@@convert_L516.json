{
    "click.src.click.types.fail": "def fail(\n    self,\n    message: str,\n    param: Parameter | None = None,\n    ctx: Context | None = None,\n) -> t.NoReturn:\n    \"\"\"Helper method to fail with an invalid value message.\"\"\"\n    raise BadParameter(message, ctx=ctx, param=param)",
    "click.src.click.types.convert": "def convert(\n    self, value: t.Any, param: Parameter | None, ctx: Context | None\n) -> t.Any:\n    try:\n        return self._number_class(value)\n    except ValueError:\n        self.fail(\n            _(\"{value!r} is not a valid {number_type}.\").format(\n                value=value, number_type=self.name\n            ),\n            param,\n            ctx,\n        )",
    "click.src.click.types._describe_range": "def _describe_range(self) -> str:\n    \"\"\"Describe the range for use in help text.\"\"\"\n    if self.min is None:\n        op = \"<\" if self.max_open else \"<=\"\n        return f\"x{op}{self.max}\"\n\n    if self.max is None:\n        op = \">\" if self.min_open else \">=\"\n        return f\"x{op}{self.min}\"\n\n    lop = \"<\" if self.min_open else \"<=\"\n    rop = \"<\" if self.max_open else \"<=\"\n    return f\"{self.min}{lop}x{rop}{self.max}\"",
    "click.src.click.types._clamp": "def _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:\n    if not open:\n        return bound\n\n    # Could use math.nextafter here, but clamping an\n    # open float range doesn't seem to be particularly useful. It's\n    # left up to the user to write a callback to do it if needed.\n    raise RuntimeError(\"Clamping is not supported for open bounds.\")"
}