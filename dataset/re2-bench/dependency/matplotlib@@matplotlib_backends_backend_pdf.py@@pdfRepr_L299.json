{
    "matplotlib.lib.matplotlib.backends.backend_pdf._datetime_to_pdf": "def _datetime_to_pdf(d):\n    \"\"\"\n    Convert a datetime to a PDF string representing it.\n\n    Used for PDF and PGF.\n    \"\"\"\n    r = d.strftime('D:%Y%m%d%H%M%S')\n    z = d.utcoffset()\n    if z is not None:\n        z = z.seconds\n    else:\n        if time.daylight:\n            z = time.altzone\n        else:\n            z = time.timezone\n    if z == 0:\n        r += 'Z'\n    elif z < 0:\n        r += \"+%02d'%02d'\" % ((-z) // 3600, (-z) % 3600)\n    else:\n        r += \"-%02d'%02d'\" % (z // 3600, z % 3600)\n    return r",
    "matplotlib.lib.matplotlib.backends.backend_pdf.pdfRepr": "def pdfRepr(self):\n    return self.value",
    "matplotlib.lib.matplotlib.backends.backend_pdf.<listcomp>": "return _fill([pdfRepr(val) for val in obj.bounds])\n\n",
    "matplotlib.lib.matplotlib.backends.backend_pdf.<genexpr>": "self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n",
    "matplotlib.lib.matplotlib.backends.backend_pdf._fill": "def _fill(strings, linelen=75):\n    \"\"\"\n    Make one string from sequence of strings, with whitespace in between.\n\n    The whitespace is chosen to form lines of at most *linelen* characters,\n    if possible.\n    \"\"\"\n    currpos = 0\n    lasti = 0\n    result = []\n    for i, s in enumerate(strings):\n        length = len(s)\n        if currpos + length < linelen:\n            currpos += length + 1\n        else:\n            result.append(b' '.join(strings[lasti:i]))\n            lasti = i\n            currpos = length\n    result.append(b' '.join(strings[lasti:]))\n    return b'\\n'.join(result)",
    "matplotlib.lib.matplotlib.transforms.bounds": "@property\ndef bounds(self):\n    \"\"\"\n    Return (:attr:`x0`, :attr:`y0`, :attr:`~BboxBase.width`,\n    :attr:`~BboxBase.height`).\n    \"\"\"\n    (x0, y0), (x1, y1) = self.get_points()\n    return (x0, y0, x1 - x0, y1 - y0)"
}