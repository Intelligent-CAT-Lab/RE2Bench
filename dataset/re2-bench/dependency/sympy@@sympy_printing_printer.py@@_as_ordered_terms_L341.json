{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.expr.as_ordered_terms": "def as_ordered_terms(self, order=None, data: Literal[False] = False) -> list[Expr]:\n    \"\"\"\n    Transform an expression to an ordered list of terms.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos\n    >>> from sympy.abc import x\n\n    >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n    [sin(x)**2*cos(x), sin(x)**2, 1]\n\n    \"\"\"\n\n    from .numbers import Number, NumberSymbol\n\n    if order is None and self.is_Add:\n        # Spot the special case of Add(Number, Mul(Number, expr)) with the\n        # first number positive and the second number negative\n        key = lambda x:not isinstance(x, (Number, NumberSymbol))\n        add_args = sorted(Add.make_args(self), key=key)\n        if (len(add_args) == 2\n            and isinstance(add_args[0], (Number, NumberSymbol))\n            and isinstance(add_args[1], Mul)):\n            mul_args = sorted(Mul.make_args(add_args[1]), key=key)\n            if (len(mul_args) == 2\n                and isinstance(mul_args[0], Number)\n                and add_args[0].is_positive\n                and mul_args[0].is_negative):\n                return add_args\n\n    key, reverse = self._parse_order(order)\n    terms, gens = self.as_terms()\n\n    if not any(term.is_Order for term, _ in terms):\n        ordered = sorted(terms, key=key, reverse=reverse)\n    else:\n        _order, _terms = _sift_true_false(terms, lambda x: x[0].is_Order)\n        ordered = sorted(_terms, key=key, reverse=True) \\\n            + sorted(_order, key=key, reverse=True)\n\n    if data:\n        return ordered, gens\n    else:\n        return [term for term, _ in ordered]",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.polys.orderings.__eq__": "def __eq__(self, other):\n    return self.__class__ == other.__class__",
    "sympy.sympy.printing.printer.order": "@property\ndef order(self):\n    if 'order' in self._settings:\n        return self._settings['order']\n    else:\n        raise AttributeError(\"No order defined.\")",
    "sympy.sympy.printing.printer._compare_pretty": "def _compare_pretty(self, a, b):\n    \"\"\"return -1, 0, 1 if a is canonically less, equal or\n    greater than b. This is used when 'order=old' is selected\n    for printing. This puts Order last, orders Rationals\n    according to value, puts terms in order wrt the power of\n    the last power appearing in a term. Ties are broken using\n    Basic.compare.\n    \"\"\"\n    from sympy.core.numbers import Rational\n    from sympy.core.symbol import Wild\n    from sympy.series.order import Order\n    if isinstance(a, Order) and not isinstance(b, Order):\n        return 1\n    if not isinstance(a, Order) and isinstance(b, Order):\n        return -1\n\n    if isinstance(a, Rational) and isinstance(b, Rational):\n        l = a.p * b.q\n        r = b.p * a.q\n        return (l > r) - (l < r)\n    else:\n        p1, p2, p3 = Wild(\"p1\"), Wild(\"p2\"), Wild(\"p3\")\n        r_a = a.match(p1 * p2**p3)\n        if r_a and p3 in r_a:\n            a3 = r_a[p3]\n            r_b = b.match(p1 * p2**p3)\n            if r_b and p3 in r_b:\n                b3 = r_b[p3]\n                c = Basic.compare(a3, b3)\n                if c != 0:\n                    return c\n\n    # break ties\n    return Basic.compare(a, b)"
}