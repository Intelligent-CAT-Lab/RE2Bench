{
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.external.pythonmpq.__add__": "def __add__(self, other):\n    \"\"\"q1 + q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        #\n        # This is much faster than the naive method used in the stdlib\n        # fractions module. Not sure where this method comes from\n        # though...\n        #\n        # Compare timings for something like:\n        #   nums = range(1000)\n        #   rats = [PythonMPQ(n, d) for n, d in zip(nums[:-5], nums[5:])]\n        #   sum(rats) # <-- time this\n        #\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq + aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 + bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__mul__": "def __mul__(self, other):\n    \"\"\"q1 * q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = ((ap//x1)*(bp//x2), (aq//x2)*(bq//x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator*(other//x)\n        q = self.denominator//x\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.polys.domains.modularinteger.__mul__": "def __mul__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val * val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__bool__": "def __bool__(self):\n    return bool(self.val)",
    "sympy.sympy.polys.domains.modularinteger.__add__": "def __add__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val + val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.matrices.sdm.sdm_matmul_exraw": "def sdm_matmul_exraw(A, B, K, m, o):\n    #\n    # Like sdm_matmul above except that:\n    #\n    # - Handles cases like 0*oo -> nan (sdm_matmul skips multiplication by zero)\n    # - Uses K.sum (Add(*items)) for efficient addition of Expr\n    #\n    zero = K.zero\n    C = {}\n    B_knz = set(B)\n    for i, Ai in A.items():\n        Ci_list = defaultdict(list)\n        Ai_knz = set(Ai)\n\n        # Nonzero row/column pair\n        for k in Ai_knz & B_knz:\n            Aik = Ai[k]\n            if zero * Aik == zero:\n                # This is the main inner loop:\n                for j, Bkj in B[k].items():\n                    Ci_list[j].append(Aik * Bkj)\n            else:\n                for j in range(o):\n                    Ci_list[j].append(Aik * B[k].get(j, zero))\n\n        # Zero row in B, check for infinities in A\n        for k in Ai_knz - B_knz:\n            zAik = zero * Ai[k]\n            if zAik != zero:\n                for j in range(o):\n                    Ci_list[j].append(zAik)\n\n        # Add terms using K.sum (Add(*terms)) for efficiency\n        Ci = {}\n        for j, Cij_list in Ci_list.items():\n            Cij = K.sum(Cij_list)\n            if Cij:\n                Ci[j] = Cij\n        if Ci:\n            C[i] = Ci\n\n    # Find all infinities in B\n    for k, Bk in B.items():\n        for j, Bkj in Bk.items():\n            if zero * Bkj != zero:\n                for i in range(m):\n                    Aik = A.get(i, {}).get(k, zero)\n                    # If Aik is not zero then this was handled above\n                    if Aik == zero:\n                        Ci = C.get(i, {})\n                        Cij = Ci.get(j, zero) + Aik * Bkj\n                        if Cij != zero:\n                            Ci[j] = Cij\n                            C[i] = Ci\n                        else:\n                            Ci.pop(j, None)\n                            if Ci:\n                                C[i] = Ci\n                            else:\n                                C.pop(i, None)\n\n    return C",
    "sympy.sympy.polys.polyclasses.__add__": "def __add__(f, g):\n    if isinstance(g, ANP):\n        return f.add(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.add_ground(g)",
    "sympy.sympy.polys.polyclasses.__mul__": "def __mul__(f, g):\n    if isinstance(g, ANP):\n        return f.mul(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.mul_ground(g)",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)",
    "sympy.sympy.polys.rings.__add__": "def __add__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Add two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> (x + y)**2 + (x - y)**2\n    2*x**2 + 2*y**2\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._add(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._add_ground(self)\n\n    res = self._try_add_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_add_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.polys.rings.__mul__": "def __mul__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Multiply two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', QQ)\n    >>> p1 = x + y\n    >>> p2 = x - y\n    >>> p1*p2\n    x**2 - y**2\n\n    \"\"\"\n    if not self or not other:\n        return self.ring.zero\n\n    if self.ring.is_element(other):\n        return self._mul(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other).mul_ground(self)\n\n    res = self._try_mul_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_mul_ground(self)\n\n    return NotImplemented"
}