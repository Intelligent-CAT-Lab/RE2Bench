{
    "scikit-learn.sklearn.base.wrapper": "@functools.wraps(fit_method)\ndef wrapper(estimator, *args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n\n    # we don't want to validate again for each call to partial_fit\n    partial_fit_and_fitted = (\n        fit_method.__name__ == \"partial_fit\" and _is_fitted(estimator)\n    )\n\n    if not global_skip_validation and not partial_fit_and_fitted:\n        estimator._validate_params()\n\n    with config_context(\n        skip_parameter_validation=(\n            prefer_skip_nested_validation or global_skip_validation\n        )\n    ):\n        return fit_method(estimator, *args, **kwargs)",
    "scikit-learn.sklearn.cross_decomposition._pls.fit": "def fit(self, X, y):\n    \"\"\"Fit model to data.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_samples, n_features)\n        Training vectors, where `n_samples` is the number of samples and\n        `n_features` is the number of predictors.\n\n    y : array-like of shape (n_samples,) or (n_samples, n_targets)\n        Target vectors, where `n_samples` is the number of samples and\n        `n_targets` is the number of response variables.\n\n    Returns\n    -------\n    self : object\n        Fitted model.\n    \"\"\"\n    super().fit(X, y)\n    # expose the fitted attributes `x_scores_` and `y_scores_`\n    self.x_scores_ = self._x_scores\n    self.y_scores_ = self._y_scores\n    return self",
    "scikit-learn.sklearn.utils._set_output.wrapped": "@wraps(f)\ndef wrapped(self, X, *args, **kwargs):\n    data_to_wrap = f(self, X, *args, **kwargs)\n    if isinstance(data_to_wrap, tuple):\n        # only wrap the first output for cross decomposition\n        return_tuple = (\n            _wrap_data_with_container(method, data_to_wrap[0], X, self),\n            *data_to_wrap[1:],\n        )\n        # Support for namedtuples `_make` is a documented API for namedtuples:\n        # https://docs.python.org/3/library/collections.html#collections.somenamedtuple._make\n        if hasattr(type(data_to_wrap), \"_make\"):\n            return type(data_to_wrap)._make(return_tuple)\n        return return_tuple\n\n    return _wrap_data_with_container(method, data_to_wrap, X, self)"
}