{
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.domain.convert_from": "def convert_from(self, element: Es, base: Domain[Es]) -> Er:\n    \"\"\"Convert ``element`` to ``self.dtype`` given the base domain. \"\"\"\n    if base.alias is not None:\n        method = \"from_\" + base.alias\n    else:\n        method = \"from_\" + base.__class__.__name__\n\n    _convert = getattr(self, method)\n\n    if _convert is not None:\n        result = _convert(element, base)\n\n        if result is not None:\n            return result\n\n    raise CoercionFailed(\"Cannot convert %s of type %s from %s to %s\" % (element, type(element), base, self))",
    "sympy.sympy.polys.domains.rationalfield.numer": "def numer(self, a):\n    \"\"\"Returns numerator of ``a``. \"\"\"\n    return a.numerator",
    "sympy.sympy.polys.domains.rationalfield.denom": "def denom(self, a):\n    \"\"\"Returns denominator of ``a``. \"\"\"\n    return a.denominator",
    "sympy.sympy.polys.fields.__truediv__": "def __truediv__(f, g):\n    \"\"\"Computes quotient of fractions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not g:\n        raise ZeroDivisionError\n    elif field.is_element(g):\n        return f.new(f.numer*g.denom, f.denom*g.numer)\n    elif field.ring.is_element(g):\n        return f.new(f.numer, f.denom*g)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__rtruediv__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__rtruediv__(f)\n\n    op, g_numer, g_denom = f._extract_ground(g)\n\n    if op == 1:\n        return f.new(f.numer, f.denom*g_numer)\n    elif not op:\n        return NotImplemented\n    else:\n        return f.new(f.numer*g_denom, f.denom*g_numer)"
}