{
    "sympy.sympy.algebras.quaternion._generic_mul": "@staticmethod\ndef _generic_mul(q1: Quaternion | Expr, q2: Quaternion | Expr) -> Quaternion | Expr:\n    \"\"\"Generic multiplication.\n\n    Parameters\n    ==========\n\n    q1 : Quaternion or symbol\n    q2 : Quaternion or symbol\n\n    It is important to note that if neither q1 nor q2 is a Quaternion,\n    this function simply returns q1 * q2.\n\n    Returns\n    =======\n\n    Quaternion\n        The resultant quaternion after multiplying q1 and q2\n\n    Examples\n    ========\n\n    >>> from sympy import Quaternion\n    >>> from sympy import Symbol, S\n    >>> q1 = Quaternion(1, 2, 3, 4)\n    >>> q2 = Quaternion(5, 6, 7, 8)\n    >>> Quaternion._generic_mul(q1, q2)\n    (-60) + 12*i + 30*j + 24*k\n    >>> Quaternion._generic_mul(q1, S(2))\n    2 + 4*i + 6*j + 8*k\n    >>> x = Symbol('x', real = True)\n    >>> Quaternion._generic_mul(q1, x)\n    x + 2*x*i + 3*x*j + 4*x*k\n\n    Quaternions over complex fields :\n\n    >>> from sympy import I\n    >>> q3 = Quaternion(3 + 4*I, 2 + 5*I, 0, 7 + 8*I, real_field = False)\n    >>> Quaternion._generic_mul(q3, 2 + 3*I)\n    (2 + 3*I)*(3 + 4*I) + (2 + 3*I)*(2 + 5*I)*i + 0*j + (2 + 3*I)*(7 + 8*I)*k\n\n    \"\"\"\n    # None is a Quaternion:\n    if isinstance(q1, Quaternion) and isinstance(q2, Quaternion):\n        if q1._norm is None and q2._norm is None:\n            norm = None\n        else:\n            norm = q1.norm() * q2.norm()\n\n        return Quaternion(-q1.b*q2.b - q1.c*q2.c - q1.d*q2.d + q1.a*q2.a,\n                          q1.b*q2.a + q1.c*q2.d - q1.d*q2.c + q1.a*q2.b,\n                          -q1.b*q2.d + q1.c*q2.a + q1.d*q2.b + q1.a*q2.c,\n                          q1.b*q2.c - q1.c*q2.b + q1.d*q2.a + q1.a * q2.d,\n                          norm=norm)\n\n    # If q1 is a number or a SymPy expression instead of a quaternion\n    elif isinstance(q2, Quaternion):\n        if q2.real_field and q1.is_complex:\n            return Quaternion(re(q1), im(q1), 0, 0) * q2\n        elif q1.is_commutative:\n            return Quaternion(q1 * q2.a, q1 * q2.b, q1 * q2.c, q1 * q2.d)\n        else:\n            raise ValueError(\"Only commutative expressions can be multiplied with a Quaternion.\")\n\n    # If q2 is a number or a SymPy expression instead of a quaternion\n    elif isinstance(q1, Quaternion):\n        if q1.real_field and q2.is_complex:\n            return q1 * Quaternion(re(q2), im(q2), 0, 0)\n        elif q2.is_commutative:\n            return Quaternion(q2 * q1.a, q2 * q1.b, q2 * q1.c, q2 * q1.d)\n        else:\n            raise ValueError(\"Only commutative expressions can be multiplied with a Quaternion.\")\n\n    # If any of the quaternions has a fixed norm, pre-compute norm\n    else:\n        return q1 * q2",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)"
}