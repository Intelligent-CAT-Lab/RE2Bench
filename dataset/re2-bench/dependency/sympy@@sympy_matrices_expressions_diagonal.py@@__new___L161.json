{
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)",
    "sympy.sympy.matrices.expressions.applyfunc.shape": "@property\ndef shape(self):\n    return self.expr.shape",
    "sympy.sympy.matrices.expressions.hadamard.shape": "@property\ndef shape(self):\n    return self.args[0].shape",
    "sympy.sympy.matrices.expressions.matexpr.shape": "@property\ndef shape(self):\n    return self.args[1], self.args[2]",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, *args, **kwargs):\n    args = map(_sympify, args)\n    return Basic.__new__(cls, *args, **kwargs)",
    "sympy.sympy.matrices.expressions.matmul.shape": "@property\ndef shape(self):\n    matrices = [arg for arg in self.args if arg.is_Matrix]\n    return (matrices[0].rows, matrices[-1].cols)",
    "sympy.sympy.matrices.expressions.special.shape": "@property\ndef shape(self):\n    return (self.args[0], self.args[0])",
    "sympy.sympy.matrices.expressions.transpose.shape": "@property\ndef shape(self):\n    return self.arg.shape[::-1]",
    "sympy.sympy.matrices.immutable.shape": "@property\ndef shape(self):\n    return self._rows, self._cols"
}