{
    "sympy.sympy.core.basic.is_comparable": "@property\ndef is_comparable(self):\n    \"\"\"Return True if self can be computed to a real number\n    (or already is a real number) with precision, else False.\n\n    Examples\n    ========\n\n    >>> from sympy import exp_polar, pi, I\n    >>> (I*exp_polar(I*pi/2)).is_comparable\n    True\n    >>> (I*exp_polar(I*pi*2)).is_comparable\n    False\n\n    A False result does not mean that `self` cannot be rewritten\n    into a form that would be comparable. For example, the\n    difference computed below is zero but without simplification\n    it does not evaluate to a zero with precision:\n\n    >>> e = 2**pi*(1 + 2**pi)\n    >>> dif = e - e.expand()\n    >>> dif.is_comparable\n    False\n    >>> dif.n(2)._prec\n    1\n\n    \"\"\"\n    return self._eval_is_comparable()",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.evalf": "def evalf(self, prec=None, **options):\n    return self._eval_evalf(prec)"
}