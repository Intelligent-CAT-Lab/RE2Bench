{
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.exprtools.mul": "def mul(self, other):  # Factors\n    \"\"\"Return Factors of ``self * other``.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.mul(b)\n    Factors({x: 2, y: 3, z: -1})\n    >>> a*b\n    Factors({x: 2, y: 3, z: -1})\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n    if any(f.is_zero for f in (self, other)):\n        return Factors(S.Zero)\n    factors = dict(self.factors)\n\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = factors[factor] + exp\n\n            if not exp:\n                del factors[factor]\n                continue\n\n        factors[factor] = exp\n\n    return Factors(factors)",
    "sympy.sympy.core.exprtools.normal": "def normal(self, other):\n    \"\"\"Return ``self`` and ``other`` with ``gcd`` removed from each.\n    The only differences between this and method ``div`` is that this\n    is 1) optimized for the case when there are few factors in common and\n    2) this does not raise an error if ``other`` is zero.\n\n    See Also\n    ========\n    div\n\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return (Factors(), Factors(S.Zero))\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n\n    self_factors = dict(self.factors)\n    other_factors = dict(other.factors)\n\n    for factor, self_exp in self.factors.items():\n        try:\n            other_exp = other.factors[factor]\n        except KeyError:\n            continue\n\n        exp = self_exp - other_exp\n\n        if not exp:\n            del self_factors[factor]\n            del other_factors[factor]\n        elif _isnumber(exp):\n            if exp > 0:\n                self_factors[factor] = exp\n                del other_factors[factor]\n            else:\n                del self_factors[factor]\n                other_factors[factor] = -exp\n        else:\n            r = self_exp.extract_additively(other_exp)\n            if r is not None:\n                if r:\n                    self_factors[factor] = r\n                    del other_factors[factor]\n                else:  # should be handled already\n                    del self_factors[factor]\n                    del other_factors[factor]\n            else:\n                sc, sa = self_exp.as_coeff_Add()\n                if sc:\n                    oc, oa = other_exp.as_coeff_Add()\n                    diff = sc - oc\n                    if diff > 0:\n                        self_factors[factor] -= oc\n                        other_exp = oa\n                    elif diff < 0:\n                        self_factors[factor] -= sc\n                        other_factors[factor] -= sc\n                        other_exp = oa - diff\n                    else:\n                        self_factors[factor] = sa\n                        other_exp = oa\n                if other_exp:\n                    other_factors[factor] = other_exp\n                else:\n                    del other_factors[factor]\n\n    return Factors(self_factors), Factors(other_factors)",
    "sympy.sympy.core.exprtools.__init__": "def __init__(self, term, numer=None, denom=None):  # Term\n    if numer is None and denom is None:\n        if not term.is_commutative:\n            raise NonCommutativeExpression(\n                'commutative expression expected')\n\n        coeff, factors = term.as_coeff_mul()\n        numer, denom = defaultdict(int), defaultdict(int)\n\n        for factor in factors:\n            base, exp = decompose_power(factor)\n\n            if base.is_Add:\n                cont, base = base.primitive()\n                coeff *= cont**exp\n\n            if exp > 0:\n                numer[base] += exp\n            else:\n                denom[base] += -exp\n\n        numer = Factors(numer)\n        denom = Factors(denom)\n    else:\n        coeff = term\n\n        if numer is None:\n            numer = Factors()\n\n        if denom is None:\n            denom = Factors()\n\n    self.coeff = coeff\n    self.numer = numer\n    self.denom = denom",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)"
}