{
    "click.src.click.decorators.command": "def command(\n    name: str | _AnyCallable | None = None,\n    cls: type[CmdType] | None = None,\n    **attrs: t.Any,\n) -> Command | t.Callable[[_AnyCallable], Command | CmdType]:\n    r\"\"\"Creates a new :class:`Command` and uses the decorated function as\n    callback.  This will also automatically attach all decorated\n    :func:`option`\\s and :func:`argument`\\s as parameters to the command.\n\n    The name of the command defaults to the name of the function, converted to\n    lowercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes\n    ``_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,\n    ``init_data_command`` becomes ``init-data``.\n\n    All keyword arguments are forwarded to the underlying command class.\n    For the ``params`` argument, any decorated params are appended to\n    the end of the list.\n\n    Once decorated the function turns into a :class:`Command` instance\n    that can be invoked as a command line utility or be attached to a\n    command :class:`Group`.\n\n    :param name: The name of the command. Defaults to modifying the function's\n        name as described above.\n    :param cls: The command class to create. Defaults to :class:`Command`.\n\n    .. versionchanged:: 8.2\n        The suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are\n        removed when generating the name.\n\n    .. versionchanged:: 8.1\n        This decorator can be applied without parentheses.\n\n    .. versionchanged:: 8.1\n        The ``params`` argument can be used. Decorated params are\n        appended to the end of the list.\n    \"\"\"\n\n    func: t.Callable[[_AnyCallable], t.Any] | None = None\n\n    if callable(name):\n        func = name\n        name = None\n        assert cls is None, \"Use 'command(cls=cls)(callable)' to specify a class.\"\n        assert not attrs, \"Use 'command(**kwargs)(callable)' to provide arguments.\"\n\n    if cls is None:\n        cls = t.cast(\"type[CmdType]\", Command)\n\n    def decorator(f: _AnyCallable) -> CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted to convert a callback into a command twice.\")\n\n        attr_params = attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None else []\n\n        try:\n            decorator_params = f.__click_params__  # type: ignore\n        except AttributeError:\n            pass\n        else:\n            del f.__click_params__  # type: ignore\n            params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n            attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is not None\n            assert not callable(name)\n\n        if name is not None:\n            cmd_name = name\n        else:\n            cmd_name = f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", \"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = f.__doc__\n        return cmd\n\n    if func is not None:\n        return decorator(func)\n\n    return decorator",
    "click.src.click.decorators.decorator": "def decorator(f: _AnyCallable) -> CmdType:\n    if isinstance(f, Command):\n        raise TypeError(\"Attempted to convert a callback into a command twice.\")\n\n    attr_params = attrs.pop(\"params\", None)\n    params = attr_params if attr_params is not None else []\n\n    try:\n        decorator_params = f.__click_params__  # type: ignore\n    except AttributeError:\n        pass\n    else:\n        del f.__click_params__  # type: ignore\n        params.extend(reversed(decorator_params))\n\n    if attrs.get(\"help\") is None:\n        attrs[\"help\"] = f.__doc__\n\n    if t.TYPE_CHECKING:\n        assert cls is not None\n        assert not callable(name)\n\n    if name is not None:\n        cmd_name = name\n    else:\n        cmd_name = f.__name__.lower().replace(\"_\", \"-\")\n        cmd_left, sep, suffix = cmd_name.rpartition(\"-\")\n\n        if sep and suffix in {\"command\", \"cmd\", \"group\", \"grp\"}:\n            cmd_name = cmd_left\n\n    cmd = cls(name=cmd_name, callback=f, params=params, **attrs)\n    cmd.__doc__ = f.__doc__\n    return cmd"
}