{
    "sympy.sympy.concrete.expr_with_limits.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols in the object, excluding those\n    that take on a specific value (i.e. the dummy symbols).\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.abc import x, y\n    >>> Sum(x, (x, y, 1)).free_symbols\n    {y}\n    \"\"\"\n    # don't test for any special values -- nominal free symbols\n    # should be returned, e.g. don't return set() if the\n    # function is zero -- treat it like an unevaluated expression.\n    function, limits = self.function, self.limits\n    # mask off non-symbol integration variables that have\n    # more than themself as a free symbol\n    reps = {i[0]: i[0] if i[0].free_symbols == {i[0]} else Dummy()\n        for i in self.limits}\n    function = function.xreplace(reps)\n    isyms = function.free_symbols\n    for xab in limits:\n        v = reps[xab[0]]\n        if len(xab) == 1:\n            isyms.add(v)\n            continue\n        # take out the target symbol\n        if v in isyms:\n            isyms.remove(v)\n        # add in the new symbols\n        for i in xab[1:]:\n            isyms.update(i.free_symbols)\n    reps = {v: k for k, v in reps.items()}\n    return {reps.get(_, _) for _ in isyms}",
    "sympy.sympy.concrete.expr_with_limits.is_number": "@property\ndef is_number(self):\n    \"\"\"Return True if the Sum has no free symbols, else False.\"\"\"\n    return not self.free_symbols",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.simplify": "def simplify(self, **kwargs) -> Basic:\n    \"\"\"See the simplify function in sympy.simplify\"\"\"\n    from sympy.simplify.simplify import simplify\n    return simplify(self, **kwargs)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.core.expr.diff": "def diff(self, *symbols, **assumptions) -> Expr:\n    assumptions.setdefault(\"evaluate\", True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.expr._random": "def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):\n    \"\"\"Return self evaluated, if possible, replacing free symbols with\n    random complex values, if necessary.\n\n    Explanation\n    ===========\n\n    The random complex value for each free symbol is generated\n    by the random_complex_number routine giving real and imaginary\n    parts in the range given by the re_min, re_max, im_min, and im_max\n    values. The returned value is evaluated to a precision of n\n    (if given) else the maximum of 15 and the precision needed\n    to get more than 1 digit of precision. If the expression\n    could not be evaluated to a number, or could not be evaluated\n    to more than 1 digit of precision, then None is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import x, y\n    >>> x._random()                         # doctest: +SKIP\n    0.0392918155679172 + 0.916050214307199*I\n    >>> x._random(2)                        # doctest: +SKIP\n    -0.77 - 0.87*I\n    >>> (x + y/2)._random(2)                # doctest: +SKIP\n    -0.57 + 0.16*I\n    >>> sqrt(2)._random(2)\n    1.4\n\n    See Also\n    ========\n\n    sympy.core.random.random_complex_number\n    \"\"\"\n\n    free = self.free_symbols\n    prec = 1\n    if free:\n        from sympy.core.random import random_complex_number\n        a, c, b, d = re_min, re_max, im_min, im_max\n        reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)\n                       for zi in free])))\n        try:\n            nmag = abs(self.evalf(2, subs=reps))\n        except (ValueError, TypeError):\n            # if an out of range value resulted in evalf problems\n            # then return None -- XXX is there a way to know how to\n            # select a good random number for a given expression?\n            # e.g. when calculating n! negative values for n should not\n            # be used\n            return None\n    else:\n        reps = {}\n        nmag = abs(self.evalf(2))\n\n    if not hasattr(nmag, '_prec'):\n        # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True\n        return None\n\n    if nmag._prec == 1:\n        # increase the precision up to the default maximum\n        # precision to see if we can get any significance\n\n        # evaluate\n        for prec in giant_steps(2, DEFAULT_MAXPREC):\n            nmag = abs(self.evalf(prec, subs=reps))\n            if nmag._prec != 1:\n                break\n\n    if nmag._prec != 1:\n        if n is None:\n            n = max(prec, 15)\n        return self.evalf(n, subs=reps)\n\n    # never got any significance\n    return None",
    "sympy.sympy.core.expr.<setcomp>": "wrt_number = {sym for sym in wrt if sym.kind is NumberKind}\n\n# try numerical evaluation to see if we get two different values\n",
    "sympy.sympy.core.expr.equals": "def equals(self, other, failing_expression=False):\n    \"\"\"Return True if self == other, False if it does not, or None. If\n    failing_expression is True then the expression which did not simplify\n    to a 0 will be returned instead of None.\n\n    Explanation\n    ===========\n\n    If ``self`` is a Number (or complex number) that is not zero, then\n    the result is False.\n\n    If ``self`` is a number and has not evaluated to zero, evalf will be\n    used to test whether the expression evaluates to zero. If it does so\n    and the result has significance (i.e. the precision is either -1, for\n    a Rational result, or is greater than 1) then the evalf value will be\n    used to return True or False.\n\n    \"\"\"\n    from sympy.simplify.simplify import nsimplify, simplify\n    from sympy.solvers.solvers import solve\n    from sympy.polys.polyerrors import NotAlgebraic\n    from sympy.polys.numberfields import minimal_polynomial\n\n    other = sympify(other)\n\n    if not isinstance(other, Expr):\n        return False\n\n    if self == other:\n        return True\n\n    # they aren't the same so see if we can make the difference 0;\n    # don't worry about doing simplification steps one at a time\n    # because if the expression ever goes to 0 then the subsequent\n    # simplification steps that are done will be very fast.\n    diff = factor_terms(simplify(self - other), radical=True)\n\n    if not diff:\n        return True\n\n    if not diff.has(Add, Mod):\n        # if there is no expanding to be done after simplifying\n        # then this can't be a zero\n        return False\n\n    factors = diff.as_coeff_mul()[1]\n    if len(factors) > 1:  # avoid infinity recursion\n        fac_zero = [fac.equals(0) for fac in factors]\n        if None not in fac_zero:  # every part can be decided\n            return any(fac_zero)\n\n    constant = diff.is_constant(simplify=False, failing_number=True)\n\n    if constant is False:\n        return False\n\n    if not diff.is_number:\n        if constant is None:\n            # e.g. unless the right simplification is done, a symbolic\n            # zero is possible (see expression of issue 6829: without\n            # simplification constant will be None).\n            return\n\n    if constant is True:\n        # this gives a number whether there are free symbols or not\n        ndiff = diff._random()\n        # is_comparable will work whether the result is real\n        # or complex; it could be None, however.\n        if ndiff and ndiff.is_comparable:\n            return False\n\n    # sometimes we can use a simplified result to give a clue as to\n    # what the expression should be; if the expression is *not* zero\n    # then we should have been able to compute that and so now\n    # we can just consider the cases where the approximation appears\n    # to be zero -- we try to prove it via minimal_polynomial.\n    #\n    # removed\n    # ns = nsimplify(diff)\n    # if diff.is_number and (not ns or ns == diff):\n    #\n    # The thought was that if it nsimplifies to 0 that's a sure sign\n    # to try the following to prove it; or if it changed but wasn't\n    # zero that might be a sign that it's not going to be easy to\n    # prove. But tests seem to be working without that logic.\n    #\n    if diff.is_number:\n        # try to prove via self-consistency\n        surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n        # it seems to work better to try big ones first\n        surds.sort(key=lambda x: -x.args[0])\n        for s in surds:\n            try:\n                # simplify is False here -- this expression has already\n                # been identified as being hard to identify as zero;\n                # we will handle the checking ourselves using nsimplify\n                # to see if we are in the right ballpark or not and if so\n                # *then* the simplification will be attempted.\n                sol = solve(diff, s, simplify=False)\n                if sol:\n                    if s in sol:\n                        # the self-consistent result is present\n                        return True\n                    if all(si.is_Integer for si in sol):\n                        # perfect powers are removed at instantiation\n                        # so surd s cannot be an integer\n                        return False\n                    if all(i.is_algebraic is False for i in sol):\n                        # a surd is algebraic\n                        return False\n                    if any(si in surds for si in sol):\n                        # it wasn't equal to s but it is in surds\n                        # and different surds are not equal\n                        return False\n                    if any(nsimplify(s - si) == 0 and\n                            simplify(s - si) == 0 for si in sol):\n                        return True\n                    if s.is_real:\n                        if any(nsimplify(si, [s]) == s and simplify(si) == s\n                                for si in sol):\n                            return True\n            except NotImplementedError:\n                pass\n\n        # try to prove with minimal_polynomial but know when\n        # *not* to use this or else it can take a long time. e.g. issue 8354\n        if True:  # change True to condition that assures non-hang\n            try:\n                mp = minimal_polynomial(diff)\n                if mp.is_Symbol:\n                    return True\n                return False\n            except (NotAlgebraic, NotImplementedError):\n                pass\n\n    # diff has not simplified to zero; constant is either None, True\n    # or the number with significance (is_comparable) that was randomly\n    # calculated twice as the same value.\n    if constant not in (True, None) and constant != 0:\n        return False\n\n    if failing_expression:\n        return diff\n    return None",
    "sympy.sympy.core.function.free_symbols": "@property\ndef free_symbols(self):\n    ret = self.expr.free_symbols\n    # Add symbolic counts to free_symbols\n    for _, count in self.variable_count:\n        ret.update(count.free_symbols)\n    return ret",
    "sympy.sympy.core.logic.fuzzy_not": "def fuzzy_not(v):\n    \"\"\"\n    Not in fuzzy logic\n\n    Return None if `v` is None else `not v`.\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import fuzzy_not\n    >>> fuzzy_not(True)\n    False\n    >>> fuzzy_not(None)\n    >>> fuzzy_not(False)\n    True\n\n    \"\"\"\n    if v is None:\n        return v\n    else:\n        return not v",
    "sympy.sympy.core.logic.fuzzy_or": "def fuzzy_or(args):\n    \"\"\"\n    Or in fuzzy logic. Returns True (any True), False (all False), or None\n\n    See the docstrings of fuzzy_and and fuzzy_not for more info.  fuzzy_or is\n    related to the two by the standard De Morgan's law.\n\n    >>> from sympy.core.logic import fuzzy_or\n    >>> fuzzy_or([True, False])\n    True\n    >>> fuzzy_or([True, None])\n    True\n    >>> fuzzy_or([False, False])\n    False\n    >>> print(fuzzy_or([False, None]))\n    None\n\n    \"\"\"\n    rv = False\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is True:\n            return True\n        if rv is False:  # this will stop updating if a None is ever trapped\n            rv = ai\n    return rv",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return other is not S.NaN",
    "sympy.sympy.physics.units.quantities.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"Return free symbols from quantity.\"\"\"\n    return set()",
    "sympy.sympy.solvers.solvers.denoms": "def denoms(eq, *symbols):\n    \"\"\"\n    Return (recursively) set of all denominators that appear in *eq*\n    that contain any symbol in *symbols*; if *symbols* are not\n    provided then all denominators will be returned.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.solvers import denoms\n    >>> from sympy.abc import x, y, z\n\n    >>> denoms(x/y)\n    {y}\n\n    >>> denoms(x/(y*z))\n    {y, z}\n\n    >>> denoms(3/x + y/z)\n    {x, z}\n\n    >>> denoms(x/2 + y/z)\n    {2, z}\n\n    If *symbols* are provided then only denominators containing\n    those symbols will be returned:\n\n    >>> denoms(1/x + 1/y + 1/z, y, z)\n    {y, z}\n\n    \"\"\"\n\n    pot = preorder_traversal(eq)\n    dens = set()\n    for p in pot:\n        # Here p might be Tuple or Relational\n        # Expr subtrees (e.g. lhs and rhs) will be traversed after by pot\n        if not isinstance(p, Expr):\n            continue\n        den = denom(p)\n        if den is S.One:\n            continue\n        dens.update(Mul.make_args(den))\n    if not symbols:\n        return dens\n    elif len(symbols) == 1:\n        if iterable(symbols[0]):\n            symbols = symbols[0]\n    return {d for d in dens if any(s in d.free_symbols for s in symbols)}",
    "sympy.sympy.tensor.indexed.free_symbols": "@property\ndef free_symbols(self):\n    base_free_symbols = self.base.free_symbols\n    indices_free_symbols = {\n        fs for i in self.indices for fs in i.free_symbols}\n    if base_free_symbols:\n        return {self} | base_free_symbols | indices_free_symbols\n    else:\n        return indices_free_symbols"
}