{
    "sympy.sympy.codegen.ast.__eq__": "def __eq__(self, other):\n    return other is None or isinstance(other, NoneToken)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__float__": "def __float__(self):\n    return mlib.to_float(self._as_mpf_val(53))",
    "sympy.sympy.core.traversal.postorder_traversal": "def postorder_traversal(node, keys=None):\n    \"\"\"\n    Do a postorder traversal of a tree.\n\n    This generator recursively yields nodes that it has visited in a postorder\n    fashion. That is, it descends through the tree depth-first to yield all of\n    a node's children's postorder traversal before yielding the node itself.\n\n    Parameters\n    ==========\n\n    node : SymPy expression\n        The expression to traverse.\n    keys : (default None) sort key(s)\n        The key(s) used to sort args of Basic objects. When None, args of Basic\n        objects are processed in arbitrary order. If key is defined, it will\n        be passed along to ordered() as the only key(s) to use to sort the\n        arguments; if ``key`` is simply True then the default keys of\n        ``ordered`` will be used (node count and default_sort_key).\n\n    Yields\n    ======\n    subtree : SymPy expression\n        All of the subtrees in the tree.\n\n    Examples\n    ========\n\n    >>> from sympy import postorder_traversal\n    >>> from sympy.abc import w, x, y, z\n\n    The nodes are returned in the order that they are encountered unless key\n    is given; simply passing key=True will guarantee that the traversal is\n    unique.\n\n    >>> list(postorder_traversal(w + (x + y)*z)) # doctest: +SKIP\n    [z, y, x, x + y, z*(x + y), w, w + z*(x + y)]\n    >>> list(postorder_traversal(w + (x + y)*z, keys=True))\n    [w, z, x, y, x + y, z*(x + y), w + z*(x + y)]\n\n\n    \"\"\"\n    if isinstance(node, Basic):\n        args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from postorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from postorder_traversal(item, keys)\n    yield node",
    "sympy.sympy.geometry.point.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Point) or len(self.args) != len(other.args):\n        return False\n    return self.args == other.args",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)",
    "sympy.sympy.physics.vector.frame.__eq__": "def __eq__(self, other):\n    # Check if the other object is a CoordinateSym of the same frame and\n    # same index\n    if isinstance(other, CoordinateSym):\n        if other._id == self._id:\n            return True\n    return False",
    "sympy.sympy.polys.agca.modules.__eq__": "def __eq__(self, om):\n    if not isinstance(om, self.__class__) or om.module != self.module:\n        try:\n            om = self.module.convert(om)\n        except CoercionFailed:\n            return False\n    return self.eq(self.data, om.data)",
    "sympy.sympy.sets.fancysets.__eq__": "def __eq__(self, other):\n    return other == Interval(S.NegativeInfinity, S.Infinity)",
    "sympy.sympy.sets.sets.__eq__": "def __eq__(self, other):\n    if isinstance(other, (set, frozenset)):\n        return self._args_set == other\n    return super().__eq__(other)",
    "sympy.sympy.tensor.array.ndim_array.__eq__": "def __eq__(self, other):\n    \"\"\"\n    NDimArray instances can be compared to each other.\n    Instances equal if they have same shape and data.\n\n    Examples\n    ========\n\n    >>> from sympy import MutableDenseNDimArray\n    >>> a = MutableDenseNDimArray.zeros(2, 3)\n    >>> b = MutableDenseNDimArray.zeros(2, 3)\n    >>> a == b\n    True\n    >>> c = a.reshape(3, 2)\n    >>> c == b\n    False\n    >>> a[0,0] = 1\n    >>> b[0,0] = 2\n    >>> a == b\n    False\n    \"\"\"\n    from sympy.tensor.array import SparseNDimArray\n    if not isinstance(other, NDimArray):\n        return False\n\n    if not self.shape == other.shape:\n        return False\n\n    if isinstance(self, SparseNDimArray) and isinstance(other, SparseNDimArray):\n        return dict(self._sparse_array) == dict(other._sparse_array)\n\n    return list(self) == list(other)"
}