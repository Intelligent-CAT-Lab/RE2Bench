{
    "sympy.sympy.external.pythonmpq.__eq__": "def __eq__(self, other):\n    \"\"\"Compare equal with PythonMPQ, int, float, Decimal or Fraction\"\"\"\n    if isinstance(other, PythonMPQ):\n        return (self.numerator == other.numerator\n            and self.denominator == other.denominator)\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.densearith.dmp_add": "def dmp_add(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Add dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add(x**2 + y, x**2*y + x)\n    x**2*y + x**2 + x + y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_add(_dup(f), _dup(g), K))\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return g\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return f\n\n    v = u - 1\n\n    if df == dg:\n        return dmp_strip([ dmp_add(a, b, v, K) for a, b in zip(f, g) ], u, K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = g[:k], g[k:]\n\n        return h + [ dmp_add(a, b, v, K) for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densearith.dup_mul": "def dup_mul(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul(x - 2, x + 2)\n    x**2 - 4\n\n    \"\"\"\n    if f == g:\n        return dup_sqr(f, K)\n\n    if not (f and g):\n        return []\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    n = max(df, dg) + 1\n\n    if n < 100 or not K.is_Exact:\n        h: list[Er] = []\n\n        for i in range(0, df + dg + 1):\n            coeff = K.zero\n\n            for j in range(max(0, i - dg), min(df, i) + 1):\n                coeff += f[j]*g[i - j]\n\n            h.append(coeff)\n\n        return dup_strip(h, K)\n    else:\n        # Use Karatsuba's algorithm (divide and conquer), see e.g.:\n        # Joris van der Hoeven, Relax But Don't Be Too Lazy,\n        # J. Symbolic Computation, 11 (2002), section 3.1.1.\n        n2 = n//2\n\n        fl, gl = dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K)\n\n        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)\n        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)\n\n        lo, hi = dup_mul(fl, gl, K), dup_mul(fh, gh, K)\n\n        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)\n        mid = dup_sub(mid, dup_add(lo, hi, K), K)\n\n        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K),\n                       dup_lshift(hi, 2*n2, K), K)",
    "sympy.sympy.polys.densearith.dmp_mul": "def dmp_mul(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul(x*y + 1, x)\n    x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul(_dup(f), _dup(g), K))\n\n    if f == g:\n        return dmp_sqr(f, u, K)\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return f\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return g\n\n    h: list[dmp[Er]] = []\n    v = u - 1\n\n    for i in range(0, df + dg + 1):\n        coeff = dmp_zero(v, K)\n\n        for j in range(max(0, i - dg), min(df, i) + 1):\n            coeff = dmp_add(coeff, dmp_mul(f[j], g[i - j], v, K), v, K)\n\n        h.append(coeff)\n\n    return dmp_strip(h, u, K)",
    "sympy.sympy.polys.densearith.dmp_sqr": "def dmp_sqr(f: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Square dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sqr(x**2 + x*y + y**2)\n    x**4 + 2*x**3*y + 3*x**2*y**2 + 2*x*y**3 + y**4\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_sqr(_dup(f), K))\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return f\n\n    h: list[dmp[Er]] = []\n    v = u - 1\n\n    for i in range(0, 2*df + 1):\n        c = dmp_zero(v, K)\n\n        jmin = max(0, i - df)\n        jmax = min(i, df)\n\n        n = jmax - jmin + 1\n\n        jmax = jmin + n // 2 - 1\n\n        for j in range(jmin, jmax + 1):\n            c = dmp_add(c, dmp_mul(f[j], f[i - j], v, K), v, K)\n\n        c = dmp_mul_ground(c, K(2), v, K)\n\n        if n & 1:\n            elem = dmp_sqr(f[jmax + 1], v, K)\n            c = dmp_add(c, elem, v, K)\n\n        h.append(c)\n\n    return dmp_strip(h, u, K)",
    "sympy.sympy.polys.densebasic.dmp_degree": "def dmp_degree(f: dmp[Er], u: int) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``x_0`` in ``K[X]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree\n\n    >>> dmp_degree([[[]]], 2)\n    -1\n\n    >>> f = ZZ.map([[2], [1, 2, 3]])\n\n    >>> dmp_degree(f, 1)\n    1\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    if dmp_zero_p(f, u):\n        return -1\n    else:\n        return len(f) - 1",
    "sympy.sympy.polys.densebasic.dmp_strip": "def dmp_strip(f: dmp[Er], u: int, K: Domain[Er] | None = None) -> dmp[Er]:\n    \"\"\"\n    Remove leading zeros from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_strip\n\n    >>> dmp_strip([[], [0, 1, 2], [1]], 1)\n    [[0, 1, 2], [1]]\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_strip(_dup(f), K))\n\n    if dmp_zero_p(f, u):\n        return f\n\n    i, v = 0, u - 1\n\n    for c in f:\n        if not dmp_zero_p(c, v):\n            break\n        else:\n            i += 1\n\n    if i == len(f):\n        return dmp_zero(u, K)\n    else:\n        return f[i:]",
    "sympy.sympy.polys.densebasic.dmp_zero": "def dmp_zero(u: int, K: Domain[Er] | None = None) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero\n\n    >>> dmp_zero(4)\n    [[[[[]]]]]\n\n    \"\"\"\n    r: dmp[Er] = []\n\n    for i in range(u):\n        r = [r]\n\n    return r",
    "sympy.sympy.polys.densebasic._dup": "def _dup(p, /):\n    return p",
    "sympy.sympy.polys.densebasic._dmp": "def _dmp(p, /):\n    return p",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(f, g):\n    return f.ex == f.__class__(g).ex",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, self.__class__):\n        return self.x == other.x and self.y == other.y\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__eq__": "def __eq__(self, other):\n    return self._compare(other, operator.eq)",
    "sympy.sympy.polys.fields.__eq__": "def __eq__(f, g):\n    if isinstance(g, FracElement) and f.field == g.field:\n        return f.numer == g.numer and f.denom == g.denom\n    else:\n        return f.numer == g and f.denom == f.field.ring.one",
    "sympy.sympy.polys.polyclasses.__eq__": "def __eq__(f, g):\n    try:\n        F, G, _, _ = f.unify_ANP(g)\n    except UnificationFailed:\n        return NotImplemented\n    return F == G",
    "sympy.sympy.polys.rings.__eq__": "def __eq__(self, other: object) -> bool:\n    \"\"\"Equality test for polynomials.\n\n    Examples\n    ========\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> p1 = (x + y)**2 + (x - y)**2\n    >>> p1 == 4*x*y\n    False\n    >>> p1 == 2*(x**2 + y**2)\n    True\n    \"\"\"\n    if not other:\n        return not self\n    elif self.ring.is_element(other):\n        return dict.__eq__(self, other)\n    elif len(self) > 1:\n        return False\n    else:\n        return self.get(self.ring.zero_monom) == other"
}