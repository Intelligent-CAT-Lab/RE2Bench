{
    "scikit-learn.sklearn.base.__repr__": "def __repr__(self, N_CHAR_MAX=700):\n    # N_CHAR_MAX is the (approximate) maximum number of non-blank\n    # characters to render. We pass it as an optional parameter to ease\n    # the tests.\n\n    from sklearn.utils._pprint import _EstimatorPrettyPrinter\n\n    N_MAX_ELEMENTS_TO_SHOW = 30  # number of elements to show in sequences\n\n    # use ellipsis for sequences with a lot of elements\n    pp = _EstimatorPrettyPrinter(\n        compact=True,\n        indent=1,\n        indent_at_name=True,\n        n_max_elements_to_show=N_MAX_ELEMENTS_TO_SHOW,\n    )\n\n    repr_ = pp.pformat(self)\n\n    # Use bruteforce ellipsis when there are a lot of non-blank characters\n    n_nonblank = len(\"\".join(repr_.split()))\n    if n_nonblank > N_CHAR_MAX:\n        lim = N_CHAR_MAX // 2  # apprx number of chars to keep on both ends\n        regex = r\"^(\\s*\\S){%d}\" % lim\n        # The regex '^(\\s*\\S){%d}' % n\n        # matches from the start of the string until the nth non-blank\n        # character:\n        # - ^ matches the start of string\n        # - (pattern){n} matches n repetitions of pattern\n        # - \\s*\\S matches a non-blank char following zero or more blanks\n        left_lim = re.match(regex, repr_).end()\n        right_lim = re.match(regex, repr_[::-1]).end()\n\n        if \"\\n\" in repr_[left_lim:-right_lim]:\n            # The left side and right side aren't on the same line.\n            # To avoid weird cuts, e.g.:\n            # categoric...ore',\n            # we need to start the right side with an appropriate newline\n            # character so that it renders properly as:\n            # categoric...\n            # handle_unknown='ignore',\n            # so we add [^\\n]*\\n which matches until the next \\n\n            regex += r\"[^\\n]*\\n\"\n            right_lim = re.match(regex, repr_[::-1]).end()\n\n        ellipsis = \"...\"\n        if left_lim + len(ellipsis) < len(repr_) - right_lim:\n            # Only add ellipsis if it results in a shorter repr\n            repr_ = repr_[:left_lim] + \"...\" + repr_[-right_lim:]\n\n    return repr_",
    "scikit-learn.sklearn.utils._tags.get_tags": "def get_tags(estimator) -> Tags:\n    \"\"\"Get estimator tags.\n\n    :class:`~sklearn.BaseEstimator` provides the estimator tags machinery.\n\n    For scikit-learn built-in estimators, we should still rely on\n    `self.__sklearn_tags__()`. `get_tags(est)` should be used when we\n    are not sure where `est` comes from: typically\n    `get_tags(self.estimator)` where `self` is a meta-estimator, or in\n    the common checks.\n\n    .. versionadded:: 1.6\n\n    Parameters\n    ----------\n    estimator : estimator object\n        The estimator from which to get the tag.\n\n    Returns\n    -------\n    tags : :class:`~.sklearn.utils.Tags`\n        The estimator tags.\n    \"\"\"\n\n    try:\n        tags = estimator.__sklearn_tags__()\n    except AttributeError as exc:\n        if \"object has no attribute '__sklearn_tags__'\" in str(exc):\n            # Happens when `__sklearn_tags__` is implemented by calling\n            # `super().__sklearn_tags__()` but there is no `__sklearn_tags__`\n            # method in the base class. Typically happens when only inheriting\n            # from Mixins.\n\n            raise AttributeError(\n                f\"The following error was raised: {exc}. It seems that \"\n                \"there are no classes that implement `__sklearn_tags__` \"\n                \"in the MRO and/or all classes in the MRO call \"\n                \"`super().__sklearn_tags__()`. Make sure to inherit from \"\n                \"`BaseEstimator` which implements `__sklearn_tags__` (or \"\n                \"alternatively define `__sklearn_tags__` but we don't recommend \"\n                \"this approach). Note that `BaseEstimator` needs to be on the \"\n                \"right side of other Mixins in the inheritance order.\"\n            )\n        else:\n            raise\n\n    return tags",
    "scikit-learn.sklearn.utils.validation._is_fitted": "def _is_fitted(estimator, attributes=None, all_or_any=all):\n    \"\"\"Determine if an estimator is fitted\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator instance for which the check is performed.\n\n    attributes : str, list or tuple of str, default=None\n        Attribute name(s) given as string or a list/tuple of strings\n        Eg.: ``[\"coef_\", \"estimator_\", ...], \"coef_\"``\n\n        If `None`, `estimator` is considered fitted if there exist an\n        attribute that ends with a underscore and does not start with double\n        underscore.\n\n    all_or_any : callable, {all, any}, default=all\n        Specify whether all or any of the given attributes must exist.\n\n    Returns\n    -------\n    fitted : bool\n        Whether the estimator is fitted.\n    \"\"\"\n    if attributes is not None:\n        if not isinstance(attributes, (list, tuple)):\n            attributes = [attributes]\n        return all_or_any([hasattr(estimator, attr) for attr in attributes])\n\n    if hasattr(estimator, \"__sklearn_is_fitted__\"):\n        return estimator.__sklearn_is_fitted__()\n\n    fitted_attrs = [\n        v for v in vars(estimator) if v.endswith(\"_\") and not v.startswith(\"__\")\n    ]\n    return len(fitted_attrs) > 0"
}