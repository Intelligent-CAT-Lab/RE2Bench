{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.relational.expand": "def expand(self, **kwargs):\n    args = (arg.expand(**kwargs) for arg in self.args)\n    return self.func(*args)",
    "sympy.sympy.polys.polyoptions.clone": "def clone(self, updates={}):\n    \"\"\"Clone ``self`` and update specified options. \"\"\"\n    obj = dict.__new__(self.__class__)\n\n    for option, value in self.items():\n        obj[option] = value\n\n    for option, value in updates.items():\n        obj[option] = value\n\n    return obj",
    "sympy.sympy.polys.polyoptions.getter": "@property\ndef getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    "sympy.sympy.polys.polyutils._dict_from_expr_if_gens": "def _dict_from_expr_if_gens(expr, opt):\n    \"\"\"Transform an expression into a multinomial form given generators. \"\"\"\n    (poly,), gens = _parallel_dict_from_expr_if_gens((expr,), opt)\n    return poly, gens",
    "sympy.sympy.polys.polyutils._dict_from_expr_no_gens": "def _dict_from_expr_no_gens(expr, opt):\n    \"\"\"Transform an expression into a multinomial form and figure out generators. \"\"\"\n    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)\n    return poly, gens",
    "sympy.sympy.polys.polyutils.<genexpr>": "while any(i.is_Mul and any(j.is_Add for j in i.args) for i in Add.make_args(expr)):\n    expr = expand_mul(expr)\n\n",
    "sympy.sympy.stats.rv.is_commutative": "@property\ndef is_commutative(self):\n    return self.symbol.is_commutative"
}