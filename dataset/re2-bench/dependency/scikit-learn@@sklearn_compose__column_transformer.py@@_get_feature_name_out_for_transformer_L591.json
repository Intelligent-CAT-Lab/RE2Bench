{
    "scikit-learn.sklearn.base.get_feature_names_out": "def get_feature_names_out(self, input_features=None):\n    \"\"\"Get output feature names for transformation.\n\n    Parameters\n    ----------\n    input_features : array-like of str or None, default=None\n        Input features.\n\n        - If `input_features` is `None`, then `feature_names_in_` is\n          used as feature names in. If `feature_names_in_` is not defined,\n          then the following input feature names are generated:\n          `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n        - If `input_features` is an array-like, then `input_features` must\n          match `feature_names_in_` if `feature_names_in_` is defined.\n\n    Returns\n    -------\n    feature_names_out : ndarray of str objects\n        Same as input features.\n    \"\"\"\n    # Note that passing attributes=\"n_features_in_\" forces check_is_fitted\n    # to check if the attribute is present. Otherwise it will pass on\n    # stateless estimators (requires_fit=False)\n    check_is_fitted(self, attributes=\"n_features_in_\")\n    return _check_feature_names_in(self, input_features)",
    "scikit-learn.sklearn.preprocessing._encoders.get_feature_names_out": "def get_feature_names_out(self, input_features=None):\n    \"\"\"Get output feature names for transformation.\n\n    Parameters\n    ----------\n    input_features : array-like of str or None, default=None\n        Input features.\n\n        - If `input_features` is `None`, then `feature_names_in_` is\n          used as feature names in. If `feature_names_in_` is not defined,\n          then the following input feature names are generated:\n          `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n        - If `input_features` is an array-like, then `input_features` must\n          match `feature_names_in_` if `feature_names_in_` is defined.\n\n    Returns\n    -------\n    feature_names_out : ndarray of str objects\n        Transformed feature names.\n    \"\"\"\n    check_is_fitted(self)\n    input_features = _check_feature_names_in(self, input_features)\n    cats = [\n        self._compute_transformed_categories(i)\n        for i, _ in enumerate(self.categories_)\n    ]\n\n    name_combiner = self._check_get_feature_name_combiner()\n    feature_names = []\n    for i in range(len(cats)):\n        names = [name_combiner(input_features[i], t) for t in cats[i]]\n        feature_names.extend(names)\n\n    return np.array(feature_names, dtype=object)"
}