{
    "matplotlib.lib.matplotlib.path.vertices": "@property\ndef vertices(self):\n    \"\"\"The vertices of the `Path` as an (N, 2) array.\"\"\"\n    return self._vertices",
    "matplotlib.lib.matplotlib.path.codes": "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1D array.\n\n    Each code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n    `CLOSEPOLY`.  For codes that correspond to more than one vertex\n    (`CURVE3` and `CURVE4`), that code will be repeated so that the length\n    of `vertices` and `codes` is always the same.\n    \"\"\"\n    return self._codes",
    "matplotlib.lib.matplotlib.path.simplify_threshold": "@property\ndef simplify_threshold(self):\n    \"\"\"\n    The fraction of a pixel difference below which vertices will\n    be simplified out.\n    \"\"\"\n    return self._simplify_threshold",
    "matplotlib.lib.matplotlib.path.should_simplify": "@property\ndef should_simplify(self):\n    \"\"\"\n    `True` if the vertices array should be simplified.\n    \"\"\"\n    return self._should_simplify",
    "matplotlib.lib.matplotlib.transforms.__array__": "def __array__(self, *args, **kwargs):\n    # optimises the access of the transform matrix vs. the superclass\n    return self.get_matrix()",
    "matplotlib.lib.matplotlib.transforms.frozen": "def frozen(self):\n    # docstring inherited\n    self._invalid = 0\n    frozen = composite_transform_factory(\n        self._a.frozen(), self._b.frozen())\n    if not isinstance(frozen, CompositeGenericTransform):\n        return frozen.frozen()\n    return frozen",
    "matplotlib.lib.matplotlib.transforms.<lambda>": "self, lambda _, pop=child._parents.pop, k=id_self: pop(k))\n"
}