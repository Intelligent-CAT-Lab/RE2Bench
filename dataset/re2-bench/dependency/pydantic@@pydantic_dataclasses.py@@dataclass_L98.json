{
    "pydantic.pydantic.dataclasses.create_dataclass": "def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n    \"\"\"Create a Pydantic dataclass from a regular dataclass.\n\n    Args:\n        cls: The class to create the Pydantic dataclass from.\n\n    Returns:\n        A Pydantic dataclass.\n    \"\"\"\n    from ._internal._utils import is_model_class\n\n    if is_model_class(cls):\n        raise PydanticUserError(\n            f'Cannot create a Pydantic dataclass from {cls.__name__} as it is already a Pydantic model',\n            code='dataclass-on-model',\n        )\n\n    original_cls = cls\n\n    # we warn on conflicting config specifications, but only if the class doesn't have a dataclass base\n    # because a dataclass base might provide a __pydantic_config__ attribute that we don't want to warn about\n    has_dataclass_base = any(dataclasses.is_dataclass(base) for base in cls.__bases__)\n    if not has_dataclass_base and config is not None and hasattr(cls, '__pydantic_config__'):\n        warn(\n            f'`config` is set via both the `dataclass` decorator and `__pydantic_config__` for dataclass {cls.__name__}. '\n            f'The `config` specification from `dataclass` decorator will take priority.',\n            category=UserWarning,\n            stacklevel=2,\n        )\n\n    # if config is not explicitly provided, try to read it from the type\n    config_dict = config if config is not None else getattr(cls, '__pydantic_config__', None)\n    config_wrapper = _config.ConfigWrapper(config_dict)\n    decorators = _decorators.DecoratorInfos.build(cls, replace_wrapped_methods=True)\n    decorators.update_from_config(config_wrapper)\n\n    # Keep track of the original __doc__ so that we can restore it after applying the dataclasses decorator\n    # Otherwise, classes with no __doc__ will have their signature added into the JSON schema description,\n    # since dataclasses.dataclass will set this as the __doc__\n    original_doc = cls.__doc__\n\n    if _pydantic_dataclasses.is_stdlib_dataclass(cls):\n        # Vanilla dataclasses include a default docstring (representing the class signature),\n        # which we don't want to preserve.\n        original_doc = None\n\n        # We don't want to add validation to the existing std lib dataclass, so we will subclass it\n        #   If the class is generic, we need to make sure the subclass also inherits from Generic\n        #   with all the same parameters.\n        bases = (cls,)\n        if issubclass(cls, Generic):\n            generic_base = Generic[cls.__parameters__]  # type: ignore\n            bases = bases + (generic_base,)\n        cls = types.new_class(cls.__name__, bases)\n\n    # Respect frozen setting from dataclass constructor and fallback to config setting if not provided\n    if frozen is not None:\n        frozen_ = frozen\n        if config_wrapper.frozen:\n            # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n            warn(\n                f'`frozen` is set via both the `dataclass` decorator and `config` for dataclass {cls.__name__!r}.'\n                'This is not recommended. The `frozen` specification on `dataclass` will take priority.',\n                category=UserWarning,\n                stacklevel=2,\n            )\n    else:\n        frozen_ = config_wrapper.frozen or False\n\n    # Make Pydantic's `Field()` function compatible with stdlib dataclasses. As we'll decorate\n    # `cls` with the stdlib `@dataclass` decorator first, there are two attributes, `kw_only` and\n    # `repr` that need to be understood *during* the stdlib creation. We do so in two steps:\n\n    # 1. On the decorated class, wrap `Field()` assignment with `dataclass.field()`, with the\n    # two attributes set (done in `as_dataclass_field()`)\n    cls_anns = _typing_extra.safe_get_annotations(cls)\n    for field_name in cls_anns:\n        # We should look for assignments in `__dict__` instead, but for now we follow\n        # the same behavior as stdlib dataclasses (see https://github.com/python/cpython/issues/88609)\n        field_value = getattr(cls, field_name, None)\n        if isinstance(field_value, FieldInfo):\n            setattr(cls, field_name, _pydantic_dataclasses.as_dataclass_field(field_value))\n\n    # 2. For bases of `cls` that are stdlib dataclasses, we temporarily patch their fields\n    # (see the docstring of the context manager):\n    with _pydantic_dataclasses.patch_base_fields(cls):\n        cls = dataclasses.dataclass(  # pyright: ignore[reportCallIssue]\n            cls,\n            # the value of init here doesn't affect anything except that it makes it easier to generate a signature\n            init=True,\n            repr=repr,\n            eq=eq,\n            order=order,\n            unsafe_hash=unsafe_hash,\n            frozen=frozen_,\n            **kwargs,\n        )\n\n    if config_wrapper.validate_assignment:\n        original_setattr = cls.__setattr__\n\n        @functools.wraps(cls.__setattr__)\n        def validated_setattr(instance: PydanticDataclass, name: str, value: Any, /) -> None:\n            if frozen_:\n                return original_setattr(instance, name, value)  # pyright: ignore[reportCallIssue]\n            inst_cls = type(instance)\n            attr = getattr(inst_cls, name, None)\n\n            if isinstance(attr, property):\n                attr.__set__(instance, value)\n            elif isinstance(attr, functools.cached_property):\n                instance.__dict__.__setitem__(name, value)\n            else:\n                inst_cls.__pydantic_validator__.validate_assignment(instance, name, value)\n\n        cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n\n        if slots and not hasattr(cls, '__setstate__'):\n            # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n            # `__setattr__()` to reconstruct the dataclass. However, the custom\n            # `__setattr__()` set above relies on `validate_assignment()`, which\n            # in turn expects all the field values to be already present on the\n            # instance, resulting in attribute errors.\n            # As such, we make use of `object.__setattr__()` instead.\n            # Note that we do so only if `__setstate__()` isn't already set (this is the\n            # case if on top of `slots`, `frozen` is used).\n\n            # Taken from `dataclasses._dataclass_get/setstate()`:\n            def _dataclass_getstate(self: Any) -> list[Any]:\n                return [getattr(self, f.name) for f in dataclasses.fields(self)]\n\n            def _dataclass_setstate(self: Any, state: list[Any]) -> None:\n                for field, value in zip(dataclasses.fields(self), state):\n                    object.__setattr__(self, field.name, value)\n\n            cls.__getstate__ = _dataclass_getstate  # pyright: ignore[reportAttributeAccessIssue]\n            cls.__setstate__ = _dataclass_setstate  # pyright: ignore[reportAttributeAccessIssue]\n\n    # This is an undocumented attribute to distinguish stdlib/Pydantic dataclasses.\n    # It should be set as early as possible:\n    cls.__is_pydantic_dataclass__ = True\n    cls.__pydantic_decorators__ = decorators  # type: ignore\n    cls.__doc__ = original_doc\n    # Can be non-existent for dynamically created classes:\n    firstlineno = getattr(original_cls, '__firstlineno__', None)\n    cls.__module__ = original_cls.__module__\n    if sys.version_info >= (3, 13) and firstlineno is not None:\n        # As per https://docs.python.org/3/reference/datamodel.html#type.__firstlineno__:\n        # Setting the `__module__` attribute removes the `__firstlineno__` item from the type\u2019s dictionary.\n        original_cls.__firstlineno__ = firstlineno\n        cls.__firstlineno__ = firstlineno\n    cls.__qualname__ = original_cls.__qualname__\n    cls.__pydantic_fields_complete__ = classmethod(_pydantic_fields_complete)\n    cls.__pydantic_complete__ = False  # `complete_dataclass` will set it to `True` if successful.\n    # TODO `parent_namespace` is currently None, but we could do the same thing as Pydantic models:\n    # fetch the parent ns using `parent_frame_namespace` (if the dataclass was defined in a function),\n    # and possibly cache it (see the `__pydantic_parent_namespace__` logic for models).\n    _pydantic_dataclasses.complete_dataclass(cls, config_wrapper, raise_errors=False)\n    return cls"
}