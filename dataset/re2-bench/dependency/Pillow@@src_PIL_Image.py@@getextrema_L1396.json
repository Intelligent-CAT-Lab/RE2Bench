{
    "Pillow.src.PIL.Image.<genexpr>": "return tuple(self.im.getband(i).getextrema() for i in range(self.im.bands))\n",
    "Pillow.src.PIL.Image.load": "def load(self):\n    \"\"\"\n    Allocates storage for the image and loads the pixel data.  In\n    normal cases, you don't need to call this method, since the\n    Image class automatically loads an opened image when it is\n    accessed for the first time.\n\n    If the file associated with the image was opened by Pillow, then this\n    method will close it. The exception to this is if the image has\n    multiple frames, in which case the file will be left open for seek\n    operations. See :ref:`file-handling` for more information.\n\n    :returns: An image access object.\n    :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess`\n    \"\"\"\n    if self.im is not None and self.palette and self.palette.dirty:\n        # realize palette\n        mode, arr = self.palette.getdata()\n        self.im.putpalette(mode, arr)\n        self.palette.dirty = 0\n        self.palette.rawmode = None\n        if \"transparency\" in self.info and mode in (\"LA\", \"PA\"):\n            if isinstance(self.info[\"transparency\"], int):\n                self.im.putpalettealpha(self.info[\"transparency\"], 0)\n            else:\n                self.im.putpalettealphas(self.info[\"transparency\"])\n            self.palette.mode = \"RGBA\"\n        else:\n            palette_mode = \"RGBA\" if mode.startswith(\"RGBA\") else \"RGB\"\n            self.palette.mode = palette_mode\n            self.palette.palette = self.im.getpalette(palette_mode, palette_mode)\n\n    if self.im is not None:\n        if cffi and USE_CFFI_ACCESS:\n            if self.pyaccess:\n                return self.pyaccess\n            from . import PyAccess\n\n            self.pyaccess = PyAccess.new(self, self.readonly)\n            if self.pyaccess:\n                return self.pyaccess\n        return self.im.pixel_access(self.readonly)",
    "Pillow.src.PIL.ImageFile.load": "def load(self):\n    \"\"\"Load image data based on tile list\"\"\"\n\n    if self.tile is None:\n        msg = \"cannot load this image\"\n        raise OSError(msg)\n\n    pixel = Image.Image.load(self)\n    if not self.tile:\n        return pixel\n\n    self.map = None\n    use_mmap = self.filename and len(self.tile) == 1\n    # As of pypy 2.1.0, memory mapping was failing here.\n    use_mmap = use_mmap and not hasattr(sys, \"pypy_version_info\")\n\n    readonly = 0\n\n    # look for read/seek overrides\n    try:\n        read = self.load_read\n        # don't use mmap if there are custom read/seek functions\n        use_mmap = False\n    except AttributeError:\n        read = self.fp.read\n\n    try:\n        seek = self.load_seek\n        use_mmap = False\n    except AttributeError:\n        seek = self.fp.seek\n\n    if use_mmap:\n        # try memory mapping\n        decoder_name, extents, offset, args = self.tile[0]\n        if isinstance(args, str):\n            args = (args, 0, 1)\n        if (\n            decoder_name == \"raw\"\n            and len(args) >= 3\n            and args[0] == self.mode\n            and args[0] in Image._MAPMODES\n        ):\n            try:\n                # use mmap, if possible\n                import mmap\n\n                with open(self.filename) as fp:\n                    self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)\n                if offset + self.size[1] * args[1] > self.map.size():\n                    msg = \"buffer is not large enough\"\n                    raise OSError(msg)\n                self.im = Image.core.map_buffer(\n                    self.map, self.size, decoder_name, offset, args\n                )\n                readonly = 1\n                # After trashing self.im,\n                # we might need to reload the palette data.\n                if self.palette:\n                    self.palette.dirty = 1\n            except (AttributeError, OSError, ImportError):\n                self.map = None\n\n    self.load_prepare()\n    err_code = -3  # initialize to unknown error\n    if not self.map:\n        # sort tiles in file order\n        self.tile.sort(key=_tilesort)\n\n        try:\n            # FIXME: This is a hack to handle TIFF's JpegTables tag.\n            prefix = self.tile_prefix\n        except AttributeError:\n            prefix = b\"\"\n\n        # Remove consecutive duplicates that only differ by their offset\n        self.tile = [\n            list(tiles)[-1]\n            for _, tiles in itertools.groupby(\n                self.tile, lambda tile: (tile[0], tile[1], tile[3])\n            )\n        ]\n        for decoder_name, extents, offset, args in self.tile:\n            seek(offset)\n            decoder = Image._getdecoder(\n                self.mode, decoder_name, args, self.decoderconfig\n            )\n            try:\n                decoder.setimage(self.im, extents)\n                if decoder.pulls_fd:\n                    decoder.setfd(self.fp)\n                    err_code = decoder.decode(b\"\")[1]\n                else:\n                    b = prefix\n                    while True:\n                        try:\n                            s = read(self.decodermaxblock)\n                        except (IndexError, struct.error) as e:\n                            # truncated png/gif\n                            if LOAD_TRUNCATED_IMAGES:\n                                break\n                            else:\n                                msg = \"image file is truncated\"\n                                raise OSError(msg) from e\n\n                        if not s:  # truncated jpeg\n                            if LOAD_TRUNCATED_IMAGES:\n                                break\n                            else:\n                                msg = (\n                                    \"image file is truncated \"\n                                    f\"({len(b)} bytes not processed)\"\n                                )\n                                raise OSError(msg)\n\n                        b = b + s\n                        n, err_code = decoder.decode(b)\n                        if n < 0:\n                            break\n                        b = b[n:]\n            finally:\n                # Need to cleanup here to prevent leaks\n                decoder.cleanup()\n\n    self.tile = []\n    self.readonly = readonly\n\n    self.load_end()\n\n    if self._exclusive_fp and self._close_exclusive_fp_after_loading:\n        self.fp.close()\n    self.fp = None\n\n    if not self.map and not LOAD_TRUNCATED_IMAGES and err_code < 0:\n        # still raised if decoder fails to return anything\n        raise _get_oserror(err_code, encoder=False)\n\n    return Image.Image.load(self)",
    "Pillow.src.PIL.TiffImagePlugin.load": "def load(self):\n    if self.tile and self.use_load_libtiff:\n        return self._load_libtiff()\n    return super().load()"
}