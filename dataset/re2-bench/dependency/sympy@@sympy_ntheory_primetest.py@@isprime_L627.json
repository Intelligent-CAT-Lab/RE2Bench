{
    "sympy.sympy.external.ntheory.is_strong_bpsw_prp": "def is_strong_bpsw_prp(n):\n    if n < 1:\n        raise ValueError(\"is_strong_bpsw_prp() requires 'n' be greater than 0\")\n    if n == 1:\n        return False\n    if n % 2 == 0:\n        return n == 2\n    return _is_strong_prp(n, 2) and _is_strong_selfridge_prp(n)",
    "sympy.sympy.ntheory.factor_.get": "def get(self, n: int, default=None):\n    \"\"\" Return the prime factor of ``n``.\n    If it does not exist in the cache, return the value of ``default``.\n    \"\"\"\n    if n <= sieve._list[-1]:\n        if sieve._list[bisect_left(sieve._list, n)] == n:\n            return n\n    if n in self._cache:\n        self._cache.move_to_end(n)\n        return self._cache[n]\n    if factors := self.get_external(n):\n        self.add(n, factors)\n        return self._cache[n]\n    return default",
    "sympy.sympy.ntheory.generate.search": "def search(self, n):\n    \"\"\"Return the indices i, j of the primes that bound n.\n\n    If n is prime then i == j.\n\n    Although n can be an expression, if ceiling cannot convert\n    it to an integer then an n error will be raised.\n\n    Examples\n    ========\n\n    >>> from sympy import sieve\n    >>> sieve.search(25)\n    (9, 10)\n    >>> sieve.search(23)\n    (9, 9)\n    \"\"\"\n    test = _as_int_ceiling(n)\n    n = as_int(n)\n    if n < 2:\n        raise ValueError(f\"n should be >= 2 but got: {n}\")\n    if n > self._list[-1]:\n        self.extend(n)\n    b = bisect(self._list, n)\n    if self._list[b - 1] == test:\n        return b, b\n    else:\n        return b, b + 1",
    "sympy.sympy.ntheory.primetest.mr": "def mr(n, bases):\n    \"\"\"Perform a Miller-Rabin strong pseudoprime test on n using a\n    given list of bases/witnesses.\n\n    References\n    ==========\n\n    .. [1] Richard Crandall & Carl Pomerance (2005), \"Prime Numbers:\n           A Computational Perspective\", Springer, 2nd edition, 135-138\n\n    A list of thresholds and the bases they require are here:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import mr\n    >>> mr(1373651, [2, 3])\n    False\n    >>> mr(479001599, [31, 73])\n    True\n\n    \"\"\"\n    from sympy.polys.domains import ZZ\n\n    n = as_int(n)\n    if n < 2 or (n > 2 and n % 2 == 0):\n        return False\n    # remove powers of 2 from n-1 (= t * 2**s)\n    s = bit_scan1(n - 1)\n    t = n >> s\n    for base in bases:\n        # Bases >= n are wrapped, bases < 2 are invalid\n        if base >= n:\n            base %= n\n        if base >= 2:\n            base = ZZ(base)\n            if not _test(n, base, s, t):\n                return False\n    return True",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}