{
    "sympy.sympy.core.add.matches": "def matches(self, expr, repl_dict=None, old=False):\n    return self._matches_commutative(expr, repl_dict, old)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    "sympy.sympy.core.basic.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if self == expr:\n        if repl_dict is None:\n            return {}\n        return repl_dict.copy()",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_base_exp": "def as_base_exp(self) -> tuple[Expr, Expr]:\n    # a -> b ** e\n    return self, S.One",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.mul.matches": "def matches(self, expr, repl_dict=None, old=False):\n    expr = sympify(expr)\n    if self.is_commutative and expr.is_commutative:\n        return self._matches_commutative(expr, repl_dict, old)\n    elif self.is_commutative is not expr.is_commutative:\n        return None\n\n    # Proceed only if both both expressions are non-commutative\n    c1, nc1 = self.args_cnc()\n    c2, nc2 = expr.args_cnc()\n    c1, c2 = [c or [1] for c in [c1, c2]]\n\n    # TODO: Should these be self.func?\n    comm_mul_self = Mul(*c1)\n    comm_mul_expr = Mul(*c2)\n\n    repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)\n\n    # If the commutative arguments didn't match and aren't equal, then\n    # then the expression as a whole doesn't match\n    if not repl_dict and c1 != c2:\n        return None\n\n    # Now match the non-commutative arguments, expanding powers to\n    # multiplications\n    nc1 = Mul._matches_expand_pows(nc1)\n    nc2 = Mul._matches_expand_pows(nc2)\n\n    repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)\n\n    return repl_dict or None",
    "sympy.sympy.core.mul.as_base_exp": "def as_base_exp(self):\n    e1 = None\n    bases = []\n    nc = 0\n    for m in self.args:\n        b, e = m.as_base_exp()\n        if not b.is_commutative:\n            nc += 1\n        if e1 is None:\n            e1 = e\n        elif e != e1 or nc > 1 or not e.is_Integer:\n            return self, S.One\n        bases.append(b)\n    return self.func(*bases), e1",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.as_base_exp": "def as_base_exp(self):\n    return S.NegativeOne, S.Half",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.core.power.matches": "def matches(self, expr, repl_dict=None, old=False):\n    expr = _sympify(expr)\n    if repl_dict is None:\n        repl_dict = {}\n\n    # special case, pattern = 1 and expr.exp can match to 0\n    if expr is S.One:\n        d = self.exp.matches(S.Zero, repl_dict)\n        if d is not None:\n            return d\n\n    # make sure the expression to be matched is an Expr\n    if not isinstance(expr, Expr):\n        return None\n\n    b, e = expr.as_base_exp()\n\n    # special case number\n    sb, se = self.as_base_exp()\n    if sb.is_Symbol and se.is_Integer and expr:\n        if e.is_rational:\n            return sb.matches(b**(e/se), repl_dict)\n        return sb.matches(expr**(1/se), repl_dict)\n\n    d = repl_dict.copy()\n    d = self.base.matches(b, d)\n    if d is None:\n        return None\n\n    d = self.exp.xreplace(d).matches(e, d)\n    if d is None:\n        return Expr.matches(self, expr, repl_dict)\n    return d",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e",
    "sympy.sympy.core.symbol.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if any(expr.has(x) for x in self.exclude):\n        return None\n    if not all(f(expr) for f in self.properties):\n        return None\n    if repl_dict is None:\n        repl_dict = {}\n    else:\n        repl_dict = repl_dict.copy()\n    repl_dict[self] = expr\n    return repl_dict",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)",
    "sympy.sympy.functions.elementary.exponential.as_base_exp": "def as_base_exp(self):\n    \"\"\"\n    Returns the 2-tuple (base, exponent).\n    \"\"\"\n    return self.func(1), Mul(*self.args)"
}