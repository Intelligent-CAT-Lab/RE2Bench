{
    "sympy.sympy.polys.densearith.dmp_pow": "def dmp_pow(f: dmp[Er], n: int, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Raise ``f`` to the ``n``-th power in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_pow(x*y + 1, 3)\n    x**3*y**3 + 3*x**2*y**2 + 3*x*y + 1\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_pow(_dup(f), n, K))\n\n    if not n:\n        return dmp_one(u, K)\n    if n < 0:\n        raise ValueError(\"Cannot raise polynomial to a negative power\")\n    if n == 1 or dmp_zero_p(f, u) or dmp_one_p(f, u, K):\n        return f\n\n    g = dmp_one(u, K)\n\n    while True:\n        n, m = n//2, n\n\n        if m & 1:\n            g = dmp_mul(g, f, u, K)\n\n            if not n:\n                break\n\n        f = dmp_sqr(f, u, K)\n\n    return g",
    "sympy.sympy.polys.densearith.dup_mul_ground": "def dup_mul_ground(f: dup[Er], c: Er, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul_ground(x**2 + 2*x - 1, ZZ(3))\n    3*x**2 + 6*x - 3\n\n    \"\"\"\n    if not c or not f:\n        return []\n    else:\n        return [ cf * c for cf in f ]",
    "sympy.sympy.polys.densearith.dmp_mul_ground": "def dmp_mul_ground(f: dmp[Er], c: Er, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul_ground(2*x + 2*y, ZZ(3))\n    6*x + 6*y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_mul_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densearith.dmp_mul": "def dmp_mul(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul(x*y + 1, x)\n    x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul(_dup(f), _dup(g), K))\n\n    if f == g:\n        return dmp_sqr(f, u, K)\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return f\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return g\n\n    h: list[dmp[Er]] = []\n    v = u - 1\n\n    for i in range(0, df + dg + 1):\n        coeff = dmp_zero(v, K)\n\n        for j in range(max(0, i - dg), min(df, i) + 1):\n            coeff = dmp_add(coeff, dmp_mul(f[j], g[i - j], v, K), v, K)\n\n        h.append(coeff)\n\n    return dmp_strip(h, u, K)",
    "sympy.sympy.polys.densebasic.dup_LC": "def dup_LC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_LC\n\n    >>> dup_LC([1, 2, 3], ZZ)\n    1\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    "sympy.sympy.polys.densebasic.dmp_one": "def dmp_one(u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate one over ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one\n\n    >>> dmp_one(2, ZZ)\n    [[[1]]]\n\n    \"\"\"\n    return dmp_ground(K.one, u, K)",
    "sympy.sympy.polys.densetools.dmp_eval_tail": "def dmp_eval_tail(f: dmp[Er], A: list[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Evaluate a polynomial at ``x_j = a_j, ...`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 2*x*y + 3*x + y + 2\n\n    >>> R.dmp_eval_tail(f, [2])\n    7*x + 4\n    >>> R.dmp_eval_tail(f, [2, 2])\n    18\n\n    \"\"\"\n    if not A:\n        return f\n\n    if dmp_zero_p(f, u):\n        return dmp_zero(u - len(A), K)\n\n    e = _rec_eval_tail(f, 0, A, u, K)\n\n    if u == len(A) - 1:\n        return e\n    else:\n        return dmp_strip(e, u - len(A), K)",
    "sympy.sympy.polys.domains.domain.is_one": "def is_one(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is one. \"\"\"\n    return a == self.one",
    "sympy.sympy.polys.domains.integerring.gcd": "def gcd(self, a, b):\n    \"\"\"Compute GCD of ``a`` and ``b``. \"\"\"\n    return gcd(a, b)"
}