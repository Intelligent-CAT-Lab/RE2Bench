{
    "sympy.sympy.assumptions.ask.ask": "def ask(proposition, assumptions=True, context=global_assumptions):\n    \"\"\"\n    Function to evaluate the proposition with assumptions.\n\n    Explanation\n    ===========\n\n    This function evaluates the proposition to ``True`` or ``False`` if\n    the truth value can be determined. If not, it returns ``None``.\n\n    It should be discerned from :func:`~.refine` which, when applied to a\n    proposition, simplifies the argument to symbolic ``Boolean`` instead of\n    Python built-in ``True``, ``False`` or ``None``.\n\n    **Syntax**\n\n        * ask(proposition)\n            Evaluate the *proposition* in global assumption context.\n\n        * ask(proposition, assumptions)\n            Evaluate the *proposition* with respect to *assumptions* in\n            global assumption context.\n\n    Parameters\n    ==========\n\n    proposition : Boolean\n        Proposition which will be evaluated to boolean value. If this is\n        not ``AppliedPredicate``, it will be wrapped by ``Q.is_true``.\n\n    assumptions : Boolean, optional\n        Local assumptions to evaluate the *proposition*.\n\n    context : AssumptionsContext, optional\n        Default assumptions to evaluate the *proposition*. By default,\n        this is ``sympy.assumptions.global_assumptions`` variable.\n\n    Returns\n    =======\n\n    ``True``, ``False``, or ``None``\n\n    Raises\n    ======\n\n    TypeError : *proposition* or *assumptions* is not valid logical expression.\n\n    ValueError : assumptions are inconsistent.\n\n    Examples\n    ========\n\n    >>> from sympy import ask, Q, pi\n    >>> from sympy.abc import x, y\n    >>> ask(Q.rational(pi))\n    False\n    >>> ask(Q.even(x*y), Q.even(x) & Q.integer(y))\n    True\n    >>> ask(Q.prime(4*x), Q.integer(x))\n    False\n\n    If the truth value cannot be determined, ``None`` will be returned.\n\n    >>> print(ask(Q.odd(3*x))) # cannot determine unless we know x\n    None\n\n    ``ValueError`` is raised if assumptions are inconsistent.\n\n    >>> ask(Q.integer(x), Q.even(x) & Q.odd(x))\n    Traceback (most recent call last):\n      ...\n    ValueError: inconsistent assumptions Q.even(x) & Q.odd(x)\n\n    Notes\n    =====\n\n    Relations in assumptions are not implemented (yet), so the following\n    will not give a meaningful result.\n\n    >>> ask(Q.positive(x), x > 0)\n\n    It is however a work in progress.\n\n    See Also\n    ========\n\n    sympy.assumptions.refine.refine : Simplification using assumptions.\n        Proposition is not reduced to ``None`` if the truth value cannot\n        be determined.\n    \"\"\"\n    from sympy.assumptions.satask import satask\n    from sympy.assumptions.lra_satask import lra_satask\n    from sympy.logic.algorithms.lra_theory import UnhandledInput\n\n    proposition = sympify(proposition)\n    assumptions = sympify(assumptions)\n\n    if isinstance(proposition, Predicate) or proposition.kind is not BooleanKind:\n        raise TypeError(\"proposition must be a valid logical expression\")\n\n    if isinstance(assumptions, Predicate) or assumptions.kind is not BooleanKind:\n        raise TypeError(\"assumptions must be a valid logical expression\")\n\n    # Normalize both proposition and assumptions\n    proposition = _normalize_expr(proposition)\n    assumptions = _normalize_expr(assumptions)\n\n    if isinstance(proposition, AppliedPredicate):\n        key, args = proposition.function, proposition.arguments\n    else:\n        key, args = Q.is_true, (proposition,)\n\n    # convert local and global assumptions to CNF\n    assump_cnf = CNF.from_prop(assumptions)\n    assump_cnf.extend(context)\n\n    # extract the relevant facts from assumptions with respect to args\n    local_facts = _extract_all_facts(assump_cnf, args)\n\n    # convert default facts and assumed facts to encoded CNF\n    known_facts_cnf = get_all_known_facts()\n    enc_cnf = EncodedCNF()\n    enc_cnf.from_cnf(CNF(known_facts_cnf))\n    enc_cnf.add_from_cnf(local_facts)\n\n    # check the satisfiability of given assumptions\n    if local_facts.clauses and satisfiable(enc_cnf) is False:\n        raise ValueError(f\"inconsistent assumptions {assumptions}\")\n\n    # quick computation for single fact\n    res = _ask_single_fact(key, local_facts)\n    if res is not None:\n        return res\n\n    # direct resolution method, no logic\n    res = key(*args)._eval_ask(assumptions)\n    if res is not None:\n        return bool(res)\n\n    # using satask (still costly)\n    res = satask(proposition, assumptions=assumptions, context=context)\n    if res is not None:\n        return res\n\n    try:\n        res = lra_satask(proposition, assumptions=assumptions, context=context)\n    except UnhandledInput:\n        return None\n\n    return res",
    "sympy.sympy.assumptions.assume.__call__": "def __call__(self, *args):\n    return AppliedPredicate(self, *args)",
    "sympy.sympy.core.add.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return _could_extract_minus_sign(self)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.could_extract_minus_sign": "def could_extract_minus_sign(self) -> bool:\n    \"\"\"Return True if self has -1 as a leading factor or has\n    more literal negative signs than positive signs in a sum,\n    otherwise False.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> e = x - y\n    >>> {i.could_extract_minus_sign() for i in (e, -e)}\n    {False, True}\n\n    Though the ``y - x`` is considered like ``-(x - y)``, since it\n    is in a product without a leading factor of -1, the result is\n    false below:\n\n    >>> (x*(y - x)).could_extract_minus_sign()\n    False\n\n    To put something in canonical form wrt to sign, use `signsimp`:\n\n    >>> from sympy import signsimp\n    >>> signsimp(x*(y - x))\n    -x*(x - y)\n    >>> _.could_extract_minus_sign()\n    True\n    \"\"\"\n    return False",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e",
    "sympy.sympy.utilities.decorator.accessor": "@wraps(propfunc)\ndef accessor(self):\n    val = getattr(self, attrname, sentinel)\n    if val is sentinel:\n        val = propfunc(self)\n        setattr(self, attrname, val)\n    return val"
}