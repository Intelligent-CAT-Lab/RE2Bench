{
    "matplotlib.lib.matplotlib.animation.frame_size": "@property\ndef frame_size(self):\n    \"\"\"A tuple ``(width, height)`` in pixels of a movie frame.\"\"\"\n    w, h = self.fig.get_size_inches()\n    return int(w * self.dpi), int(h * self.dpi)",
    "matplotlib.lib.matplotlib.animation.bin_path": "@classmethod\ndef bin_path(cls):\n    \"\"\"\n    Return the binary path to the commandline tool used by a specific\n    subclass. This is a class method so that the tool can be looked for\n    before making a particular MovieWriter subclass available.\n    \"\"\"\n    return str(mpl.rcParams[cls._exec_key])",
    "matplotlib.lib.matplotlib.animation.output_args": "@property\ndef output_args(self):\n    args = []\n    suffix = Path(self.outfile).suffix\n    if suffix in {'.apng', '.avif', '.gif', '.webm', '.webp'}:\n        self.codec = suffix[1:]\n    else:\n        args.extend(['-vcodec', self.codec])\n    extra_args = (self.extra_args if self.extra_args is not None\n                  else mpl.rcParams[self._args_key])\n    # For h264, the default format is yuv444p, which is not compatible\n    # with quicktime (and others). Specifying yuv420p fixes playback on\n    # iOS, as well as HTML5 video in firefox and safari (on both Windows and\n    # macOS). Also fixes internet explorer. This is as of 2015/10/29.\n    if self.codec == 'h264' and '-pix_fmt' not in extra_args:\n        args.extend(['-pix_fmt', 'yuv420p'])\n    # For GIF, we're telling FFmpeg to split the video stream, to generate\n    # a palette, and then use it for encoding.\n    elif self.codec == 'gif' and '-filter_complex' not in extra_args:\n        args.extend(['-filter_complex',\n                     'split [a][b];[a] palettegen [p];[b][p] paletteuse'])\n    # For AVIF, we're telling FFmpeg to split the video stream, extract the alpha,\n    # in order to place it in a secondary stream, as needed by AVIF-in-FFmpeg.\n    elif self.codec == 'avif' and '-filter_complex' not in extra_args:\n        args.extend(['-filter_complex',\n                     'split [rgb][rgba]; [rgba] alphaextract [alpha]',\n                     '-map', '[rgb]', '-map', '[alpha]'])\n    if self.bitrate > 0:\n        args.extend(['-b', '%dk' % self.bitrate])  # %dk: bitrate in kbps.\n    for k, v in self.metadata.items():\n        args.extend(['-metadata', f'{k}={v}'])\n    args.extend(extra_args)\n\n    return args + ['-y', self.outfile]"
}