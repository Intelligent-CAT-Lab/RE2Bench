{
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.polys.densebasic.dmp_from_dict": "def dmp_from_dict(f: dict[tuple[int, ...], Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Create a ``K[X]`` polynomial from a ``dict``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_from_dict\n\n    >>> dmp_from_dict({(0, 0): ZZ(3), (0, 1): ZZ(2), (2, 1): ZZ(1)}, 1, ZZ)\n    [[1, 0], [], [2, 3]]\n    >>> dmp_from_dict({}, 0, ZZ)\n    []\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_from_dict(f, K))\n    if not f:\n        return dmp_zero(u, K)\n\n    coeffs: dict[int, dict[monom, Er]] = {}\n\n    for monom, coeff in f.items():\n        head, tail = monom[0], monom[1:]\n\n        if head in coeffs:\n            coeffs[head][tail] = coeff\n        else:\n            coeffs[head] = {tail: coeff}\n\n    n = max(coeffs.keys())\n    v = u - 1\n    h: dmp[Er] = []\n\n    for k in range(n, -1, -1):\n        dcoeff = coeffs.get(k)\n\n        if dcoeff is not None:\n            h.append(dmp_from_dict(dcoeff, v, K))\n        else:\n            h.append(dmp_zero(v, K))\n\n    return dmp_strip(h, u, K)",
    "sympy.sympy.polys.densebasic.dmp_to_dict": "def dmp_to_dict(f: dmp[Er], u: int, K: Domain[Er]) -> dict[tuple[int, ...], Er]:\n    \"\"\"\n    Convert a ``K[X]`` polynomial to a ``dict````.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dmp_to_dict\n\n    >>> dmp_to_dict([[1, 0], [], [2, 3]], 1, ZZ)\n    {(0, 0): 3, (0, 1): 2, (2, 1): 1}\n    >>> dmp_to_dict([], 0, ZZ)\n    {}\n\n    .. versionchanged:: 1.15.0\n        The ``zero`` parameter was removed and the ``K`` parameter is now\n        required.\n\n    \"\"\"\n    if not u:\n        return dup_to_dict(_dup(f), K)\n\n    n = dmp_degree(f, u)\n    v = u - 1\n    result: dict[monom, Er] = {}\n\n    for k in range(0, n + 1):\n        h = dmp_to_dict(f[n - k], v, K)\n\n        for exp, coeff in h.items():\n            result[(k,) + exp] = coeff\n\n    return result",
    "sympy.sympy.polys.densebasic.<genexpr>": "if all(g == 0 for g in G):\n    return G, f\n\n",
    "sympy.sympy.polys.densebasic.dmp_ground_TC": "def dmp_ground_TC(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the ground trailing coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_TC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_TC(f, 2, ZZ)\n    3\n\n    \"\"\"\n    while u:\n        f = dmp_TC(f, K)\n        u -= 1\n\n    return dup_TC(_dup(f), K)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.domains.expressiondomain.__bool__": "def __bool__(f):\n    return not f.ex.is_zero",
    "sympy.sympy.polys.domains.gaussiandomains.__bool__": "def __bool__(self) -> bool:\n    return bool(self.x) or bool(self.y)",
    "sympy.sympy.polys.domains.modularinteger.__bool__": "def __bool__(self):\n    return bool(self.val)",
    "sympy.sympy.polys.fields.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    "sympy.sympy.polys.monomials.monomial_ldiv": "def monomial_ldiv(A: monom, B: monom) -> monom:\n    \"\"\"\n    Division of tuples representing monomials.\n\n    Examples\n    ========\n\n    Lets divide `x**3*y**4*z` by `x*y**2`::\n\n        >>> from sympy.polys.monomials import monomial_ldiv\n\n        >>> monomial_ldiv((3, 4, 1), (1, 2, 0))\n        (2, 2, 1)\n\n    which gives `x**2*y**2*z`.\n\n        >>> monomial_ldiv((3, 4, 1), (1, 2, 2))\n        (2, 2, -1)\n\n    which gives `x**2*y**2*z**-1`.\n\n    \"\"\"\n    return tuple([ a - b for a, b in zip(A, B) ])",
    "sympy.sympy.polys.monomials.monomial_min": "def monomial_min(*monoms: monom) -> monom:\n    \"\"\"\n    Returns minimal degree for each variable in a set of monomials.\n\n    Examples\n    ========\n\n    Consider monomials `x**3*y**4*z**5`, `y**5*z` and `x**6*y**3*z**9`.\n    We wish to find out what is the minimal degree for each of `x`, `y`\n    and `z` variables::\n\n        >>> from sympy.polys.monomials import monomial_min\n\n        >>> monomial_min((3,4,5), (0,5,1), (6,3,9))\n        (0, 3, 1)\n\n    \"\"\"\n    M = list(monoms[0])\n\n    for N in monoms[1:]:\n        for i, n in enumerate(N):\n            M[i] = min(M[i], n)\n\n    return tuple(M)",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)"
}