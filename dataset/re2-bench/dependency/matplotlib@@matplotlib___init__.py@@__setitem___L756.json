{
    "matplotlib.lib.matplotlib.__init__._set": "def _set(self, key, val):\n    \"\"\"\n    Directly write data bypassing deprecation and validation logic.\n\n    Notes\n    -----\n    As end user or downstream library you almost always should use\n    ``rcParams[key] = val`` and not ``_set()``.\n\n    There are only very few special cases that need direct data access.\n    These cases previously used ``dict.__setitem__(rcParams, key, val)``,\n    which is now deprecated and replaced by ``rcParams._set(key, val)``.\n\n    Even though private, we guarantee API stability for ``rcParams._set``,\n    i.e. it is subject to Matplotlib's API and deprecation policy.\n\n    :meta public:\n    \"\"\"\n    dict.__setitem__(self, key, val)",
    "matplotlib.lib.matplotlib._api.__init__.check_getitem": "def check_getitem(mapping, /, _error_cls=ValueError, **kwargs):\n    \"\"\"\n    *kwargs* must consist of a single *key, value* pair.  If *key* is in\n    *mapping*, return ``mapping[value]``; else, raise an appropriate\n    ValueError.\n\n    Parameters\n    ----------\n    _error_cls :\n        Class of error to raise.\n\n    Examples\n    --------\n    >>> _api.check_getitem({\"foo\": \"bar\"}, arg=arg)\n    \"\"\"\n    if len(kwargs) != 1:\n        raise ValueError(\"check_getitem takes a single keyword argument\")\n    (k, v), = kwargs.items()\n    try:\n        return mapping[v]\n    except KeyError:\n        if len(mapping) > 5:\n            if len(best := difflib.get_close_matches(v, mapping.keys(), cutoff=0.5)):\n                suggestion = f\"Did you mean one of {best}?\"\n            else:\n                suggestion = \"\"\n        else:\n            suggestion = f\"Supported values are {', '.join(map(repr, mapping))}\"\n        raise _error_cls(f\"{v!r} is not a valid value for {k}. {suggestion}\") from None",
    "matplotlib.lib.matplotlib.rcsetup._validate_date": "def _validate_date(s):\n    try:\n        np.datetime64(s)\n        return s\n    except ValueError:\n        raise ValueError(\n            f'{s!r} should be a string that can be parsed by numpy.datetime64')",
    "matplotlib.lib.matplotlib.rcsetup.validate_bool": "def validate_bool(b):\n    \"\"\"Convert b to ``bool`` or raise.\"\"\"\n    if isinstance(b, str):\n        b = b.lower()\n    if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):\n        return True\n    elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):\n        return False\n    else:\n        raise ValueError(f'Cannot convert {b!r} to bool')",
    "matplotlib.lib.matplotlib.rcsetup.validate_axisbelow": "def validate_axisbelow(s):\n    try:\n        return validate_bool(s)\n    except ValueError:\n        if isinstance(s, str):\n            if s == 'line':\n                return 'line'\n    raise ValueError(f'{s!r} cannot be interpreted as'\n                     ' True, False, or \"line\"')",
    "matplotlib.lib.matplotlib.rcsetup.validate_dpi": "def validate_dpi(s):\n    \"\"\"Confirm s is string 'figure' or convert s to float or raise.\"\"\"\n    if s == 'figure':\n        return s\n    try:\n        return float(s)\n    except ValueError as e:\n        raise ValueError(f'{s!r} is not string \"figure\" and '\n                         f'could not convert {s!r} to float') from e",
    "matplotlib.lib.matplotlib.rcsetup.validator": "def validator(s):\n    if (allow_none and\n            (s is None or cbook._str_lower_equal(s, \"none\"))):\n        if cbook._str_lower_equal(s, \"none\") and s != \"None\":\n            _api.warn_deprecated(\n                \"3.11\",\n                message=f\"Using the capitalization {s!r} in matplotlibrc for \"\n                        \"*None* is deprecated in %(removal)s and will lead to an \"\n                        \"error from version 3.13 onward. Please use 'None' \"\n                        \"instead.\"\n            )\n        return None\n    if cls is str and not isinstance(s, str):\n        raise ValueError(f'Could not convert {s!r} to str')\n    try:\n        return cls(s)\n    except (TypeError, ValueError) as e:\n        raise ValueError(\n            f'Could not convert {s!r} to {cls.__name__}') from e",
    "matplotlib.lib.matplotlib.rcsetup._validate_marker": "def _validate_marker(s):\n    try:\n        return validate_int(s)\n    except ValueError as e:\n        try:\n            return validate_string(s)\n        except ValueError as e:\n            raise ValueError('Supported markers are [string, int]') from e",
    "matplotlib.lib.matplotlib.rcsetup._validate_pathlike": "def _validate_pathlike(s):\n    if isinstance(s, (str, os.PathLike)):\n        # Store value as str because savefig.directory needs to distinguish\n        # between \"\" (cwd) and \".\" (cwd, but gets updated by user selections).\n        return os.fsdecode(s)\n    else:\n        return validate_string(s)",
    "matplotlib.lib.matplotlib.rcsetup.validate_fonttype": "def validate_fonttype(s):\n    \"\"\"\n    Confirm that this is a Postscript or PDF font type that we know how to\n    convert to.\n    \"\"\"\n    fonttypes = {'type3':    3,\n                 'truetype': 42}\n    try:\n        fonttype = validate_int(s)\n    except ValueError:\n        try:\n            return fonttypes[s.lower()]\n        except KeyError as e:\n            raise ValueError('Supported Postscript/PDF font types are %s'\n                             % list(fonttypes)) from e\n    else:\n        if fonttype not in fonttypes.values():\n            raise ValueError(\n                'Supported Postscript/PDF font types are %s' %\n                list(fonttypes.values()))\n        return fonttype",
    "matplotlib.lib.matplotlib.rcsetup.validate_backend": "def validate_backend(s):\n    if s is _auto_backend_sentinel or backend_registry.is_valid_backend(s):\n        return s\n    else:\n        msg = (f\"'{s}' is not a valid value for backend; supported values are \"\n               f\"{backend_registry.list_all()}\")\n        raise ValueError(msg)",
    "matplotlib.lib.matplotlib.rcsetup._validate_toolbar": "def _validate_toolbar(s):\n    s = ValidateInStrings(\n        'toolbar', ['None', 'toolbar2', 'toolmanager'], ignorecase=True)(s)\n    if s == 'toolmanager':\n        _api.warn_external(\n            \"Treat the new Tool classes introduced in v1.5 as experimental \"\n            \"for now; the API and rcParam may change in future versions.\")\n    return s",
    "matplotlib.lib.matplotlib.rcsetup.validate_color_or_inherit": "def validate_color_or_inherit(s):\n    \"\"\"Return a valid color arg.\"\"\"\n    if cbook._str_equal(s, 'inherit'):\n        return s\n    return validate_color(s)",
    "matplotlib.lib.matplotlib.rcsetup.validate_color_or_auto": "def validate_color_or_auto(s):\n    if cbook._str_equal(s, 'auto'):\n        return s\n    return validate_color(s)",
    "matplotlib.lib.matplotlib.rcsetup._validate_color_or_edge": "def _validate_color_or_edge(s):\n    if cbook._str_equal(s, 'edge'):\n        return s\n    return validate_color(s)",
    "matplotlib.lib.matplotlib.rcsetup._validate_color_or_linecolor": "def _validate_color_or_linecolor(s):\n    if cbook._str_equal(s, 'linecolor'):\n        return s\n    elif cbook._str_equal(s, 'mfc') or cbook._str_equal(s, 'markerfacecolor'):\n        return 'markerfacecolor'\n    elif cbook._str_equal(s, 'mec') or cbook._str_equal(s, 'markeredgecolor'):\n        return 'markeredgecolor'\n    elif s is None:\n        return None\n    elif isinstance(s, str) and len(s) == 6 or len(s) == 8:\n        stmp = '#' + s\n        if is_color_like(stmp):\n            return stmp\n        if s.lower() == 'none':\n            return None\n    elif is_color_like(s):\n        return s\n\n    raise ValueError(f'{s!r} does not look like a color arg')",
    "matplotlib.lib.matplotlib.rcsetup.validate_color": "def validate_color(s):\n    \"\"\"Return a valid color arg.\"\"\"\n    if isinstance(s, str):\n        if s.lower() == 'none':\n            return 'none'\n        if len(s) == 6 or len(s) == 8:\n            stmp = '#' + s\n            if is_color_like(stmp):\n                return stmp\n\n    if is_color_like(s):\n        return s\n\n    # If it is still valid, it must be a tuple (as a string from matplotlibrc).\n    try:\n        color = ast.literal_eval(s)\n    except (SyntaxError, ValueError):\n        pass\n    else:\n        if is_color_like(color):\n            return color\n\n    raise ValueError(f'{s!r} does not look like a color arg')",
    "matplotlib.lib.matplotlib.rcsetup._validate_color_or_None": "def _validate_color_or_None(s):\n    if s is None or cbook._str_equal(s, \"None\"):\n        return None\n    return validate_color(s)",
    "matplotlib.lib.matplotlib.rcsetup._validate_cmap": "def _validate_cmap(s):\n    _api.check_isinstance((str, Colormap), cmap=s)\n    return s",
    "matplotlib.lib.matplotlib.rcsetup.validate_aspect": "def validate_aspect(s):\n    if s in ('auto', 'equal'):\n        return s\n    try:\n        return float(s)\n    except ValueError as e:\n        raise ValueError('not a valid aspect specification') from e",
    "matplotlib.lib.matplotlib.rcsetup.validate_fontsize_None": "def validate_fontsize_None(s):\n    if s is None or s == 'None':\n        return None\n    else:\n        return validate_fontsize(s)",
    "matplotlib.lib.matplotlib.rcsetup.validate_fontsize": "def validate_fontsize(s):\n    fontsizes = ['xx-small', 'x-small', 'small', 'medium', 'large',\n                 'x-large', 'xx-large', 'smaller', 'larger']\n    if isinstance(s, str):\n        s = s.lower()\n    if s in fontsizes:\n        return s\n    try:\n        return float(s)\n    except ValueError as e:\n        raise ValueError(\"%s is not a valid font size. Valid font sizes \"\n                         \"are %s.\" % (s, \", \".join(fontsizes))) from e",
    "matplotlib.lib.matplotlib.rcsetup.validate_fontweight": "def validate_fontweight(s):\n    weights = [\n        'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman',\n        'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black']\n    # Note: Historically, weights have been case-sensitive in Matplotlib\n    if s in weights:\n        return s\n    try:\n        return int(s)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f'{s} is not a valid font weight.') from e",
    "matplotlib.lib.matplotlib.rcsetup.validate_fontstretch": "def validate_fontstretch(s):\n    stretchvalues = [\n        'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed',\n        'normal', 'semi-expanded', 'expanded', 'extra-expanded',\n        'ultra-expanded']\n    # Note: Historically, stretchvalues have been case-sensitive in Matplotlib\n    if s in stretchvalues:\n        return s\n    try:\n        return int(s)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f'{s} is not a valid font stretch.') from e",
    "matplotlib.lib.matplotlib.rcsetup.validate_font_properties": "def validate_font_properties(s):\n    parse_fontconfig_pattern(s)\n    return s",
    "matplotlib.lib.matplotlib.rcsetup._validate_mathtext_fallback": "def _validate_mathtext_fallback(s):\n    _fallback_fonts = ['cm', 'stix', 'stixsans']\n    if isinstance(s, str):\n        s = s.lower()\n    if s is None or s == 'none':\n        return None\n    elif s.lower() in _fallback_fonts:\n        return s\n    else:\n        raise ValueError(\n            f\"{s} is not a valid fallback font name. Valid fallback font \"\n            f\"names are {','.join(_fallback_fonts)}. Passing 'None' will turn \"\n            \"fallback off.\")",
    "matplotlib.lib.matplotlib.rcsetup.validate_whiskers": "def validate_whiskers(s):\n    try:\n        return _listify_validator(validate_float, n=2)(s)\n    except (TypeError, ValueError):\n        try:\n            return float(s)\n        except ValueError as e:\n            raise ValueError(\"Not a valid whisker value [float, \"\n                             \"(float, float)]\") from e",
    "matplotlib.lib.matplotlib.rcsetup.validate_ps_distiller": "def validate_ps_distiller(s):\n    if isinstance(s, str):\n        s = s.lower()\n    if s in ('none', None, 'false', False):\n        return None\n    else:\n        return ValidateInStrings('ps.usedistiller', ['ghostscript', 'xpdf'])(s)",
    "matplotlib.lib.matplotlib.rcsetup._validate_linestyle": "def _validate_linestyle(ls):\n    \"\"\"\n    A validator for all possible line styles, the named ones *and*\n    the on-off ink sequences.\n    \"\"\"\n    if isinstance(ls, str):\n        try:  # Look first for a valid named line style, like '--' or 'solid'.\n            return _validate_named_linestyle(ls)\n        except ValueError:\n            pass\n        try:\n            ls = ast.literal_eval(ls)  # Parsing matplotlibrc.\n        except (SyntaxError, ValueError):\n            pass  # Will error with the ValueError at the end.\n\n    def _is_iterable_not_string_like(x):\n        # Explicitly exclude bytes/bytearrays so that they are not\n        # nonsensically interpreted as sequences of numbers (codepoints).\n        return np.iterable(x) and not isinstance(x, (str, bytes, bytearray))\n\n    if _is_iterable_not_string_like(ls):\n        if len(ls) == 2 and _is_iterable_not_string_like(ls[1]):\n            # (offset, (on, off, on, off, ...))\n            offset, onoff = ls\n        else:\n            # For backcompat: (on, off, on, off, ...); the offset is implicit.\n            offset = 0\n            onoff = ls\n\n        if (isinstance(offset, Real)\n                and len(onoff) % 2 == 0\n                and all(isinstance(elem, Real) for elem in onoff)):\n            return (offset, onoff)\n\n    raise ValueError(f\"linestyle {ls!r} is not a valid on-off ink sequence.\")",
    "matplotlib.lib.matplotlib.rcsetup._validate_linestyle_or_None": "def _validate_linestyle_or_None(s):\n    if s is None or cbook._str_equal(s, \"None\"):\n        return None\n\n    return _validate_linestyle(s)",
    "matplotlib.lib.matplotlib.rcsetup.__call__": "def __call__(self, s):\n    if self._deprecated_since:\n        name, = (k for k, v in globals().items() if v is self)\n        _api.warn_deprecated(\n            self._deprecated_since, name=name, obj_type=\"function\")\n    if self.ignorecase and isinstance(s, str):\n        s = s.lower()\n    if s in self.valid:\n        return self.valid[s]\n    msg = (f\"{s!r} is not a valid value for {self.key}; supported values \"\n           f\"are {[*self.valid.values()]}\")\n    if (isinstance(s, str)\n            and (s.startswith('\"') and s.endswith('\"')\n                 or s.startswith(\"'\") and s.endswith(\"'\"))\n            and s[1:-1] in self.valid):\n        msg += \"; remove quotes surrounding your string\"\n    raise ValueError(msg)",
    "matplotlib.lib.matplotlib.rcsetup.validate_bbox": "def validate_bbox(s):\n    if isinstance(s, str):\n        s = s.lower()\n        if s == 'tight':\n            return s\n        if s == 'standard':\n            return None\n        raise ValueError(\"bbox should be 'tight' or 'standard'\")\n    elif s is not None:\n        # Backwards compatibility. None is equivalent to 'standard'.\n        raise ValueError(\"bbox should be 'tight' or 'standard'\")\n    return s",
    "matplotlib.lib.matplotlib.rcsetup.validate_sketch": "def validate_sketch(s):\n\n    if isinstance(s, str):\n        s = s.lower().strip()\n        if s.startswith(\"(\") and s.endswith(\")\"):\n            s = s[1:-1]\n    if s == 'none' or s is None:\n        return None\n    try:\n        return tuple(_listify_validator(validate_float, n=3)(s))\n    except ValueError as exc:\n        raise ValueError(\"Expected a (scale, length, randomness) tuple\") from exc",
    "matplotlib.lib.matplotlib.rcsetup._validate_greaterthan_minushalf": "def _validate_greaterthan_minushalf(s):\n    s = validate_float(s)\n    if s > -0.5:\n        return s\n    else:\n        raise RuntimeError(f'Value must be >-0.5; got {s}')",
    "matplotlib.lib.matplotlib.rcsetup._validate_greaterequal0_lessequal1": "def _validate_greaterequal0_lessequal1(s):\n    s = validate_float(s)\n    if 0 <= s <= 1:\n        return s\n    else:\n        raise RuntimeError(f'Value must be >=0 and <=1; got {s}')",
    "matplotlib.lib.matplotlib.rcsetup._validate_minor_tick_ndivs": "def _validate_minor_tick_ndivs(n):\n    \"\"\"\n    Validate ndiv parameter related to the minor ticks.\n    It controls the number of minor ticks to be placed between\n    two major ticks.\n    \"\"\"\n\n    if cbook._str_lower_equal(n, 'auto'):\n        return n\n    try:\n        n = _validate_int_greaterequal0(n)\n        return n\n    except (RuntimeError, ValueError):\n        pass\n\n    raise ValueError(\"'tick.minor.ndivs' must be 'auto' or non-negative int\")",
    "matplotlib.lib.matplotlib.rcsetup._validate_legend_loc": "def _validate_legend_loc(loc):\n    \"\"\"\n    Confirm that loc is a type which rc.Params[\"legend.loc\"] supports.\n\n    .. versionadded:: 3.8\n\n    Parameters\n    ----------\n    loc : str | int | (float, float) | str((float, float))\n        The location of the legend.\n\n    Returns\n    -------\n    loc : str | int | (float, float) or raise ValueError exception\n        The location of the legend.\n    \"\"\"\n    if isinstance(loc, str):\n        try:\n            return _validate_named_legend_loc(loc)\n        except ValueError:\n            pass\n        try:\n            loc = ast.literal_eval(loc)\n        except (SyntaxError, ValueError):\n            pass\n    if isinstance(loc, int):\n        if 0 <= loc <= 10:\n            return loc\n    if isinstance(loc, tuple):\n        if len(loc) == 2 and all(isinstance(e, Real) for e in loc):\n            return loc\n    raise ValueError(f\"{loc} is not a valid legend location.\")",
    "matplotlib.lib.matplotlib.rcsetup.validate_cycler": "def validate_cycler(s):\n    \"\"\"Return a Cycler object from a string repr or the object itself.\"\"\"\n    if isinstance(s, str):\n        # TODO: We might want to rethink this...\n        # While I think I have it quite locked down, it is execution of\n        # arbitrary code without sanitation.\n        # Combine this with the possibility that rcparams might come from the\n        # internet (future plans), this could be downright dangerous.\n        # I locked it down by only having the 'cycler()' function available.\n        # UPDATE: Partly plugging a security hole.\n        # I really should have read this:\n        # https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html\n        # We should replace this eval with a combo of PyParsing and\n        # ast.literal_eval()\n        try:\n            _DunderChecker().visit(ast.parse(s))\n            s = eval(s, {'cycler': cycler, '__builtins__': {}})\n        except BaseException as e:\n            raise ValueError(f\"{s!r} is not a valid cycler construction: {e}\"\n                             ) from e\n    # Should make sure what comes from the above eval()\n    # is a Cycler object.\n    if isinstance(s, Cycler):\n        cycler_inst = s\n    else:\n        raise ValueError(f\"Object is not a string or Cycler instance: {s!r}\")\n\n    unknowns = cycler_inst.keys - (set(_prop_validators) | set(_prop_aliases))\n    if unknowns:\n        raise ValueError(\"Unknown artist properties: %s\" % unknowns)\n\n    # Not a full validation, but it'll at least normalize property names\n    # A fuller validation would require v0.10 of cycler.\n    checker = set()\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        if norm_prop != prop and norm_prop in cycler_inst.keys:\n            raise ValueError(f\"Cannot specify both {norm_prop!r} and alias \"\n                             f\"{prop!r} in the same prop_cycle\")\n        if norm_prop in checker:\n            raise ValueError(f\"Another property was already aliased to \"\n                             f\"{norm_prop!r}. Collision normalizing {prop!r}.\")\n        checker.update([norm_prop])\n\n    # This is just an extra-careful check, just in case there is some\n    # edge-case I haven't thought of.\n    assert len(checker) == len(cycler_inst.keys)\n\n    # Now, it should be safe to mutate this cycler\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        cycler_inst.change_key(prop, norm_prop)\n\n    for key, vals in cycler_inst.by_key().items():\n        _prop_validators[key](vals)\n\n    return cycler_inst",
    "matplotlib.lib.matplotlib.rcsetup.validate_hist_bins": "def validate_hist_bins(s):\n    valid_strs = [\"auto\", \"sturges\", \"fd\", \"doane\", \"scott\", \"rice\", \"sqrt\"]\n    if isinstance(s, str) and s in valid_strs:\n        return s\n    try:\n        return int(s)\n    except (TypeError, ValueError):\n        pass\n    try:\n        return validate_floatlist(s)\n    except ValueError:\n        pass\n    raise ValueError(f\"'hist.bins' must be one of {valid_strs}, an int or\"\n                     \" a sequence of floats\")",
    "matplotlib.lib.matplotlib.rcsetup.f": "def f(s):\n    if isinstance(s, str):\n        try:\n            val = [scalar_validator(v.strip()) for v in s.split(',')\n                   if v.strip()]\n        except Exception:\n            if allow_stringlist:\n                # Special handling for colors\n                val = _single_string_color_list(s, scalar_validator)\n            else:\n                raise\n    # Allow any ordered sequence type -- generators, np.ndarray, pd.Series\n    # -- but not sets, whose iteration order is non-deterministic.\n    elif np.iterable(s) and not isinstance(s, (set, frozenset)):\n        # The condition on this list comprehension will preserve the\n        # behavior of filtering out any empty strings (behavior was\n        # from the original validate_stringlist()), while allowing\n        # any non-string/text scalar values such as numbers and arrays.\n        val = [scalar_validator(v) for v in s\n               if not isinstance(v, str) or v]\n    else:\n        raise ValueError(\n            f\"Expected str or other non-set iterable, but got {s}\")\n    if n is not None and len(val) != n:\n        raise ValueError(\n            f\"Expected {n} values, but there are {len(val)} values in {s}\")\n    return val"
}