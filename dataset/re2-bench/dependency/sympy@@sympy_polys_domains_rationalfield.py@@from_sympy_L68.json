{
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.external.pythonmpq.__new__": "def __new__(cls, numerator, denominator=None):\n    \"\"\"Construct PythonMPQ with gcd computation and checks\"\"\"\n    if denominator is not None:\n        #\n        # PythonMPQ(n, d): require n and d to be int and d != 0\n        #\n        if isinstance(numerator, int) and isinstance(denominator, int):\n            # This is the slow part:\n            divisor = gcd(numerator, denominator)\n            numerator //= divisor\n            denominator //= divisor\n            return cls._new_check(numerator, denominator)\n    else:\n        #\n        # PythonMPQ(q)\n        #\n        # Here q can be PythonMPQ, int, Decimal, float, Fraction or str\n        #\n        if isinstance(numerator, int):\n            return cls._new(numerator, 1)\n        elif isinstance(numerator, PythonMPQ):\n            return cls._new(numerator.numerator, numerator.denominator)\n\n        # Let Fraction handle Decimal/float conversion and str parsing\n        if isinstance(numerator, (Decimal, float, str)):\n            numerator = Fraction(numerator)\n        if isinstance(numerator, Fraction):\n            return cls._new(numerator.numerator, numerator.denominator)\n    #\n    # Reject everything else. This is more strict than mpq which allows\n    # things like mpq(Fraction, Fraction) or mpq(Decimal, any). The mpq\n    # behaviour is somewhat inconsistent so we choose to accept only a\n    # more strict subset of what mpq allows.\n    #\n    raise TypeError(\"PythonMPQ() requires numeric or string argument\")",
    "sympy.sympy.polys.domains.realfield.to_rational": "def to_rational(self, element, limit=True):\n    \"\"\"Convert a real number to rational number. \"\"\"\n    return to_rational(element, self._max_denom, limit=limit)"
}