{
    "sympy.sympy.assumptions.cnf.all_predicates": "def all_predicates(self):\n    predicates = set()\n    for c in self.clauses:\n        predicates |= {arg.lit for arg in c}\n    return predicates",
    "sympy.sympy.assumptions.satask.find_symbols": "def find_symbols(pred):\n    \"\"\"\n    Find every :obj:`~.Symbol` in *pred*.\n\n    Parameters\n    ==========\n\n    pred : sympy.assumptions.cnf.CNF, or any Expr.\n\n    \"\"\"\n    if isinstance(pred, CNF):\n        symbols = set()\n        for a in pred.all_predicates():\n            symbols |= find_symbols(a)\n        return symbols\n    return pred.atoms(Symbol)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}"
}