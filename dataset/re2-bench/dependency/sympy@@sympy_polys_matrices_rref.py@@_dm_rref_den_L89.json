{
    "sympy.sympy.polys.domains.domain.__ne__": "def __ne__(self, other):\n    \"\"\"Returns ``False`` if two domains are equivalent. \"\"\"\n    return not self == other",
    "sympy.sympy.polys.matrices.domainmatrix.__truediv__": "def __truediv__(A, lamda):\n    \"\"\" Method for Scalar Division\"\"\"\n    if isinstance(lamda, int) or ZZ.of_type(lamda):\n        lamda = DomainScalar(ZZ(lamda), ZZ)\n    elif A.domain.is_Field and lamda in A.domain:\n        K = A.domain\n        lamda = DomainScalar(K.convert(lamda), K)\n\n    if not isinstance(lamda, DomainScalar):\n        return NotImplemented\n\n    A, lamda = A.to_field().unify(lamda)\n    if lamda.element == lamda.domain.zero:\n        raise ZeroDivisionError\n    if lamda.element == lamda.domain.one:\n        return A\n\n    return A.mul(1 / lamda.element)",
    "sympy.sympy.polys.matrices.domainmatrix.clear_denoms": "def clear_denoms(self, convert=False):\n    \"\"\"\n    Clear denominators, but keep the domain unchanged.\n\n    Examples\n    ========\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.matrices import DM\n    >>> A = DM([[(1,2), (1,3)], [(1,4), (1,5)]], QQ)\n    >>> den, Anum = A.clear_denoms()\n    >>> den.to_sympy()\n    60\n    >>> Anum.to_Matrix()\n    Matrix([\n    [30, 20],\n    [15, 12]])\n    >>> den * A == Anum\n    True\n\n    The numerator matrix will be in the same domain as the original matrix\n    unless ``convert`` is set to ``True``:\n\n    >>> A.clear_denoms()[1].domain\n    QQ\n    >>> A.clear_denoms(convert=True)[1].domain\n    ZZ\n\n    The denominator is always in the associated ring:\n\n    >>> A.clear_denoms()[0].domain\n    ZZ\n    >>> A.domain.get_ring()\n    ZZ\n\n    See Also\n    ========\n\n    sympy.polys.polytools.Poly.clear_denoms\n    clear_denoms_rowwise\n    \"\"\"\n    elems0, data = self.to_flat_nz()\n\n    K0 = self.domain\n    K1 = K0.get_ring() if K0.has_assoc_Ring else K0\n\n    den, elems1 = dup_clear_denoms(elems0, K0, K1, convert=convert)\n\n    if convert:\n        Kden, Knum = K1, K1\n    else:\n        Kden, Knum = K1, K0\n\n    den = DomainScalar(den, Kden)\n    num = self.from_flat_nz(elems1, data, Knum)\n\n    return den, num",
    "sympy.sympy.polys.matrices.domainmatrix.clear_denoms_rowwise": "def clear_denoms_rowwise(self, convert=False):\n    \"\"\"\n    Clear denominators from each row of the matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.matrices import DM\n    >>> A = DM([[(1,2), (1,3), (1,4)], [(1,5), (1,6), (1,7)]], QQ)\n    >>> den, Anum = A.clear_denoms_rowwise()\n    >>> den.to_Matrix()\n    Matrix([\n    [12,   0],\n    [ 0, 210]])\n    >>> Anum.to_Matrix()\n    Matrix([\n    [ 6,  4,  3],\n    [42, 35, 30]])\n\n    The denominator matrix is a diagonal matrix with the denominators of\n    each row on the diagonal. The invariants are:\n\n    >>> den * A == Anum\n    True\n    >>> A == den.to_field().inv() * Anum\n    True\n\n    The numerator matrix will be in the same domain as the original matrix\n    unless ``convert`` is set to ``True``:\n\n    >>> A.clear_denoms_rowwise()[1].domain\n    QQ\n    >>> A.clear_denoms_rowwise(convert=True)[1].domain\n    ZZ\n\n    The domain of the denominator matrix is the associated ring:\n\n    >>> A.clear_denoms_rowwise()[0].domain\n    ZZ\n\n    See Also\n    ========\n\n    sympy.polys.polytools.Poly.clear_denoms\n    clear_denoms\n    \"\"\"\n    dod = self.to_dod()\n\n    K0 = self.domain\n    K1 = K0.get_ring() if K0.has_assoc_Ring else K0\n\n    diagonals = [K0.one] * self.shape[0]\n    dod_num = {}\n    for i, rowi in dod.items():\n        indices, elems = zip(*rowi.items())\n        den, elems_num = dup_clear_denoms(elems, K0, K1, convert=convert)\n        rowi_num = dict(zip(indices, elems_num))\n        diagonals[i] = den\n        dod_num[i] = rowi_num\n\n    if convert:\n        Kden, Knum = K1, K1\n    else:\n        Kden, Knum = K1, K0\n\n    den = self.diag(diagonals, Kden)\n    num = self.from_dod_like(dod_num, Knum)\n\n    return den, num",
    "sympy.sympy.polys.matrices.domainmatrix.__getitem__": "def __getitem__(self, key: tuple[slice | int, slice | int]) -> DomainMatrix | DomainScalar:\n    i, j = key\n    m, n = self.shape\n    if not (isinstance(i, slice) or isinstance(j, slice)):\n        return DomainScalar(self.rep.getitem(i, j), self.domain)\n\n    if not isinstance(i, slice):\n        if not -m <= i < m:\n            raise IndexError(\"Row index out of range\")\n        i = i % m\n        i = slice(i, i+1)\n    if not isinstance(j, slice):\n        if not -n <= j < n:\n            raise IndexError(\"Column index out of range\")\n        j = j % n\n        j = slice(j, j+1)\n\n    return self.from_rep(self.rep.extract_slice(i, j))",
    "sympy.sympy.polys.matrices.rref._dm_to_fmt": "def _dm_to_fmt(M, fmt):\n    \"\"\"Convert a matrix to the given format and return the old format.\"\"\"\n    old_fmt = M.rep.fmt\n    if old_fmt == fmt:\n        pass\n    elif fmt == 'dense':\n        M = M.to_dense()\n    elif fmt == 'sparse':\n        M = M.to_sparse()\n    else:\n        raise ValueError(f'Unknown format: {fmt}') # pragma: no cover\n    return M, old_fmt",
    "sympy.sympy.polys.matrices.rref._dm_rref_GJ": "def _dm_rref_GJ(M):\n    \"\"\"Compute RREF using Gauss-Jordan elimination with division.\"\"\"\n    if M.rep.fmt == 'sparse':\n        return _dm_rref_GJ_sparse(M)\n    else:\n        return _dm_rref_GJ_dense(M)",
    "sympy.sympy.polys.matrices.rref._dm_rref_den_FF": "def _dm_rref_den_FF(M):\n    \"\"\"Compute RREF using fraction-free Gauss-Jordan elimination.\"\"\"\n    if M.rep.fmt == 'sparse':\n        return _dm_rref_den_FF_sparse(M)\n    else:\n        return _dm_rref_den_FF_dense(M)",
    "sympy.sympy.polys.matrices.rref._dm_rref_choose_method": "def _dm_rref_choose_method(M, method, *, denominator=False):\n    \"\"\"Choose the fastest method for computing RREF for M.\"\"\"\n\n    if method != 'auto':\n        if method.endswith('_dense'):\n            method = method[:-len('_dense')]\n            use_fmt = 'dense'\n        else:\n            use_fmt = 'sparse'\n\n    else:\n        # The sparse implementations are always faster\n        use_fmt = 'sparse'\n\n        K = M.domain\n\n        if K.is_ZZ:\n            method = _dm_rref_choose_method_ZZ(M, denominator=denominator)\n        elif K.is_QQ:\n            method = _dm_rref_choose_method_QQ(M, denominator=denominator)\n        elif K.is_RR or K.is_CC:\n            # TODO: Add partial pivot support to the sparse implementations.\n            method = 'GJ'\n            use_fmt = 'dense'\n        elif K.is_EX and M.rep.fmt == 'dense' and not denominator:\n            # Do not switch to the sparse implementation for EX because the\n            # domain does not have proper canonicalization and the sparse\n            # implementation gives equivalent but non-identical results over EX\n            # from performing arithmetic in a different order. Specifically\n            # test_issue_23718 ends up getting a more complicated expression\n            # when using the sparse implementation. Probably the best fix for\n            # this is something else but for now we stick with the dense\n            # implementation for EX if the matrix is already dense.\n            method = 'GJ'\n            use_fmt = 'dense'\n        else:\n            # This is definitely suboptimal. More work is needed to determine\n            # the best method for computing RREF over different domains.\n            if denominator:\n                method = 'FF'\n            else:\n                method = 'GJ'\n\n    return method, use_fmt",
    "sympy.sympy.polys.matrices.rref._to_field": "def _to_field(M):\n    \"\"\"Convert a DomainMatrix to a field if possible.\"\"\"\n    K = M.domain\n    if K.has_assoc_Field:\n        return M.to_field()\n    else:\n        return M"
}