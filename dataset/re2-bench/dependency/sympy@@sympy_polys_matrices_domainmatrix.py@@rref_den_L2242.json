{
    "sympy.sympy.polys.matrices.rref._dm_rref_den": "def _dm_rref_den(M, *, keep_domain=True, method='auto'):\n    \"\"\"\n    Compute the reduced row echelon form of a ``DomainMatrix`` with denominator.\n\n    This function is the implementation of :meth:`DomainMatrix.rref_den`.\n\n    Chooses the best algorithm depending on the domain, shape, and sparsity of\n    the matrix as well as things like the bit count in the case of :ref:`ZZ` or\n    :ref:`QQ`. The result is returned over the same domain as the input matrix\n    unless ``keep_domain=False`` in which case the result might be over an\n    associated ring or field domain.\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den\n        The ``DomainMatrix`` method that calls this function.\n    sympy.polys.matrices.rref._dm_rref\n        Alternative function for computing RREF without denominator.\n    \"\"\"\n    method, use_fmt = _dm_rref_choose_method(M, method, denominator=True)\n\n    M, old_fmt = _dm_to_fmt(M, use_fmt)\n\n    if method == 'FF':\n        # Use fraction-free GJ over the current domain.\n        M_rref, den, pivots = _dm_rref_den_FF(M)\n\n    elif method == 'GJ':\n        # Use Gauss-Jordan with division over the associated field.\n        M_rref_f, pivots = _dm_rref_GJ(_to_field(M))\n\n        # Convert back to the ring?\n        if keep_domain and M_rref_f.domain != M.domain:\n            _, M_rref = M_rref_f.clear_denoms(convert=True)\n\n            if pivots:\n                den = M_rref[0, pivots[0]].element\n            else:\n                den = M_rref.domain.one\n        else:\n            # Possibly an associated field\n            M_rref = M_rref_f\n            den = M_rref.domain.one\n\n    elif method == 'CD':\n        # Clear denominators and use fraction-free GJ in the associated ring.\n        _, Mr = M.clear_denoms_rowwise(convert=True)\n\n        M_rref_r, den, pivots = _dm_rref_den_FF(Mr)\n\n        if keep_domain and M_rref_r.domain != M.domain:\n            # Convert back to the field\n            M_rref = _to_field(M_rref_r) / den\n            den = M.domain.one\n        else:\n            # Possibly an associated ring\n            M_rref = M_rref_r\n\n            if pivots:\n                den = M_rref[0, pivots[0]].element\n            else:\n                den = M_rref.domain.one\n    else:\n        raise ValueError(f\"Unknown method for rref: {method}\")\n\n    M_rref, _ = _dm_to_fmt(M_rref, old_fmt)\n\n    # Invariants:\n    #   - M_rref is in the same format (sparse or dense) as the input matrix.\n    #   - If keep_domain=True then M_rref and den are in the same domain as the\n    #     input matrix\n    #   - If keep_domain=False then M_rref might be in an associated ring or\n    #     field domain but den is always in the same domain as M_rref.\n\n    return M_rref, den, pivots"
}