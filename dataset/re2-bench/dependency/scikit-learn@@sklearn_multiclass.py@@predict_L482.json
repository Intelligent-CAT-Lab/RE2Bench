{
    "scikit-learn.sklearn.multiclass._predict_binary": "def _predict_binary(estimator, X):\n    \"\"\"Make predictions using a single binary estimator.\"\"\"\n    if is_regressor(estimator):\n        return estimator.predict(X)\n    try:\n        score = np.ravel(estimator.decision_function(X))\n    except (AttributeError, NotImplementedError):\n        # probabilities of the positive class\n        score = estimator.predict_proba(X)[:, 1]\n    return score",
    "scikit-learn.sklearn.multiclass._threshold_for_binary_predict": "def _threshold_for_binary_predict(estimator):\n    \"\"\"Threshold for predictions from binary estimator.\"\"\"\n    if hasattr(estimator, \"decision_function\") and is_classifier(estimator):\n        return 0.0\n    else:\n        # predict_proba threshold\n        return 0.5",
    "scikit-learn.sklearn.preprocessing._label.inverse_transform": "def inverse_transform(self, Y, threshold=None):\n    \"\"\"Transform binary labels back to multi-class labels.\n\n    Parameters\n    ----------\n    Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n        Target values. All sparse matrices are converted to CSR before\n        inverse transformation.\n\n    threshold : float, default=None\n        Threshold used in the binary and multi-label cases.\n\n        Use 0 when ``Y`` contains the output of :term:`decision_function`\n        (classifier).\n        Use 0.5 when ``Y`` contains the output of :term:`predict_proba`.\n\n        If None, the threshold is assumed to be half way between\n        neg_label and pos_label.\n\n    Returns\n    -------\n    y_original : {ndarray, sparse matrix} of shape (n_samples,)\n        Target values. Sparse matrix will be of CSR format.\n\n    Notes\n    -----\n    In the case when the binary labels are fractional\n    (probabilistic), :meth:`inverse_transform` chooses the class with the\n    greatest value. Typically, this allows to use the output of a\n    linear model's :term:`decision_function` method directly as the input\n    of :meth:`inverse_transform`.\n    \"\"\"\n    check_is_fitted(self)\n\n    xp, is_array_api = get_namespace(Y)\n\n    if is_array_api and self.sparse_input_ and not _is_numpy_namespace(xp):\n        raise ValueError(\n            \"`LabelBinarizer` was fitted on a sparse matrix, and therefore cannot \"\n            f\"inverse transform a {xp.__name__} array back to a sparse matrix.\"\n        )\n\n    if threshold is None:\n        threshold = (self.pos_label + self.neg_label) / 2.0\n\n    if self.y_type_ == \"multiclass\":\n        y_inv = _inverse_binarize_multiclass(Y, self.classes_, xp=xp)\n    else:\n        y_inv = _inverse_binarize_thresholding(\n            Y, self.y_type_, self.classes_, threshold, xp=xp\n        )\n\n    if self.sparse_input_:\n        y_inv = sp.csr_matrix(y_inv)\n    elif sp.issparse(y_inv):\n        y_inv = y_inv.toarray()\n\n    return y_inv",
    "scikit-learn.sklearn.utils.validation.check_is_fitted": "def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):\n    \"\"\"Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by verifying the presence of\n    fitted attributes (ending with a trailing underscore) and otherwise\n    raises a :class:`~sklearn.exceptions.NotFittedError` with the given message.\n\n    If an estimator does not set any attributes with a trailing underscore, it\n    can define a ``__sklearn_is_fitted__`` method returning a boolean to\n    specify if the estimator is fitted or not. See\n    :ref:`sphx_glr_auto_examples_developing_estimators_sklearn_is_fitted.py`\n    for an example on how to use the API.\n\n    If no `attributes` are passed, this function will pass if an estimator is stateless.\n    An estimator can indicate it's stateless by setting the `requires_fit` tag. See\n    :ref:`estimator_tags` for more information. Note that the `requires_fit` tag\n    is ignored if `attributes` are passed.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator instance for which the check is performed.\n\n    attributes : str, list or tuple of str, default=None\n        Attribute name(s) given as string or a list/tuple of strings\n        Eg.: ``[\"coef_\", \"estimator_\", ...], \"coef_\"``\n\n        If `None`, `estimator` is considered fitted if there exist an\n        attribute that ends with a underscore and does not start with double\n        underscore.\n\n    msg : str, default=None\n        The default error message is, \"This %(name)s instance is not fitted\n        yet. Call 'fit' with appropriate arguments before using this\n        estimator.\"\n\n        For custom messages if \"%(name)s\" is present in the message string,\n        it is substituted for the estimator name.\n\n        Eg. : \"Estimator, %(name)s, must be fitted before sparsifying\".\n\n    all_or_any : callable, {all, any}, default=all\n        Specify whether all or any of the given attributes must exist.\n\n    Raises\n    ------\n    TypeError\n        If the estimator is a class or not an estimator instance\n\n    NotFittedError\n        If the attributes are not found.\n\n    Examples\n    --------\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.utils.validation import check_is_fitted\n    >>> from sklearn.exceptions import NotFittedError\n    >>> lr = LogisticRegression()\n    >>> try:\n    ...     check_is_fitted(lr)\n    ... except NotFittedError as exc:\n    ...     print(f\"Model is not fitted yet.\")\n    Model is not fitted yet.\n    >>> lr.fit([[1, 2], [1, 3]], [1, 0])\n    LogisticRegression()\n    >>> check_is_fitted(lr)\n    \"\"\"\n    if isclass(estimator):\n        raise TypeError(\"{} is a class, not an instance.\".format(estimator))\n    if msg is None:\n        msg = (\n            \"This %(name)s instance is not fitted yet. Call 'fit' with \"\n            \"appropriate arguments before using this estimator.\"\n        )\n\n    if not hasattr(estimator, \"fit\"):\n        raise TypeError(\"%s is not an estimator instance.\" % (estimator))\n\n    tags = get_tags(estimator)\n\n    if not tags.requires_fit and attributes is None:\n        return\n\n    if not _is_fitted(estimator, attributes, all_or_any):\n        raise NotFittedError(msg % {\"name\": type(estimator).__name__})",
    "scikit-learn.sklearn.utils.validation._num_samples": "def _num_samples(x):\n    \"\"\"Return number of samples in array-like x.\"\"\"\n    message = \"Expected sequence or array-like, got %s\" % type(x)\n    if hasattr(x, \"fit\") and callable(x.fit):\n        # Don't get num_samples from an ensembles length!\n        raise TypeError(message)\n\n    if _use_interchange_protocol(x):\n        return x.__dataframe__().num_rows()\n\n    if not hasattr(x, \"__len__\") and not hasattr(x, \"shape\"):\n        if hasattr(x, \"__array__\"):\n            xp, _ = get_namespace(x)\n            x = xp.asarray(x)\n        else:\n            raise TypeError(message)\n\n    if hasattr(x, \"shape\") and x.shape is not None:\n        if len(x.shape) == 0:\n            raise TypeError(\n                \"Input should have at least 1 dimension i.e. satisfy \"\n                f\"`len(x.shape) > 0`, got scalar `{x!r}` instead.\"\n            )\n        # Check that shape is returning an integer or default to len\n        # Dask dataframes may not return numeric shape[0] value\n        if isinstance(x.shape[0], numbers.Integral):\n            return x.shape[0]\n\n    try:\n        return len(x)\n    except TypeError as type_error:\n        raise TypeError(message) from type_error"
}