{
    "sympy.sympy.algebras.quaternion._eval_evalf": "def _eval_evalf(self, prec: int) -> Quaternion:\n    \"\"\"Returns the floating point approximations (decimal numbers) of the quaternion.\n\n    Returns\n    =======\n\n    Quaternion\n        Floating point approximations of quaternion(self)\n\n    Examples\n    ========\n\n    >>> from sympy import Quaternion\n    >>> from sympy import sqrt\n    >>> q = Quaternion(1/sqrt(1), 1/sqrt(2), 1/sqrt(3), 1/sqrt(4))\n    >>> q.evalf()\n    1.00000000000000\n    + 0.707106781186547*i\n    + 0.577350269189626*j\n    + 0.500000000000000*k\n\n    \"\"\"\n    nprec = prec_to_dps(prec)\n    a, b, c, d = [arg.evalf(n=nprec) for arg in self.args]\n    return Quaternion(a, b, c, d)",
    "sympy.sympy.codegen.cfunctions._eval_evalf": "def _eval_evalf(self, *args, **kwargs):\n    return self.rewrite(log).evalf(*args, **kwargs)",
    "sympy.sympy.codegen.numpy_nodes._eval_evalf": "def _eval_evalf(self, *args, **kwargs):\n    return self.rewrite(log).evalf(*args, **kwargs)",
    "sympy.sympy.codegen.scipy_nodes._eval_evalf": "def _eval_evalf(self, *args, **kwargs):\n    return self.rewrite(cos).evalf(*args, **kwargs)",
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.evalf.evalf_atan": "def evalf_atan(v: 'atan', prec: int, options: OPT_DICT) -> TMP_RES:\n    arg = v.args[0]\n    result = evalf(arg, prec + 5, options)\n    if result is S.ComplexInfinity:\n        return result\n    xre, xim, reacc, imacc = result\n    if xre is xim is None:\n        return (None,)*4\n    if xim:\n        raise NotImplementedError\n    return mpf_atan(xre, prec, rnd), None, prec, None",
    "sympy.sympy.core.evalf.evalf_subs": "def evalf_subs(prec: int, subs: dict) -> dict:\n    \"\"\" Change all Float entries in `subs` to have precision prec. \"\"\"\n    newsubs = {}\n    for a, b in subs.items():\n        b = S(b)\n        if b.is_Float:\n            b = b._eval_evalf(prec)\n        newsubs[a] = b\n    return newsubs",
    "sympy.sympy.core.evalf.evalf_piecewise": "def evalf_piecewise(expr: Expr, prec: int, options: OPT_DICT) -> TMP_RES:\n    from .numbers import Float, Integer\n    if 'subs' in options:\n        expr = expr.subs(evalf_subs(prec, options['subs']))\n        newopts = options.copy()\n        del newopts['subs']\n        if hasattr(expr, 'func'):\n            return evalf(expr, prec, newopts)\n        if isinstance(expr, float):\n            return evalf(Float(expr), prec, newopts)\n        if isinstance(expr, int):\n            return evalf(Integer(expr), prec, newopts)\n\n    # We still have undefined symbols\n    raise NotImplementedError",
    "sympy.sympy.core.evalf.evalf_alg_num": "def evalf_alg_num(a: 'AlgebraicNumber', prec: int, options: OPT_DICT) -> TMP_RES:\n    return evalf(a.to_root(), prec, options)",
    "sympy.sympy.core.evalf.evalf_integral": "def evalf_integral(expr: 'Integral', prec: int, options: OPT_DICT) -> TMP_RES:\n    limits = expr.limits\n    if len(limits) != 1 or len(limits[0]) != 3:\n        raise NotImplementedError\n    workprec = prec\n    i = 0\n    maxprec = options.get('maxprec', INF)\n    while 1:\n        result = do_integral(expr, workprec, options)\n        accuracy = complex_accuracy(result)\n        if accuracy >= prec:  # achieved desired precision\n            break\n        if workprec >= maxprec:  # can't increase accuracy any more\n            break\n        if accuracy == -1:\n            # maybe the answer really is zero and maybe we just haven't increased\n            # the precision enough. So increase by doubling to not take too long\n            # to get to maxprec.\n            workprec *= 2\n        else:\n            workprec += max(prec, 2**i)\n        workprec = min(workprec, maxprec)\n        i += 1\n    return result",
    "sympy.sympy.core.evalf.evalf_prod": "def evalf_prod(expr: 'Product', prec: int, options: OPT_DICT) -> TMP_RES:\n    if all((l[1] - l[2]).is_Integer for l in expr.limits):\n        result = evalf(expr.doit(), prec=prec, options=options)\n    else:\n        from sympy.concrete.summations import Sum\n        result = evalf(expr.rewrite(Sum), prec=prec, options=options)\n    return result",
    "sympy.sympy.core.evalf.evalf_sum": "def evalf_sum(expr: 'Sum', prec: int, options: OPT_DICT) -> TMP_RES:\n    from .numbers import Float\n    if 'subs' in options:\n        expr = expr.subs(options['subs']) # type: ignore\n    func = expr.function\n    limits = expr.limits\n    if len(limits) != 1 or len(limits[0]) != 3:\n        raise NotImplementedError\n    if func.is_zero:\n        return None, None, prec, None\n    prec2 = prec + 10\n    try:\n        n, a, b = limits[0]\n        if b is not S.Infinity or a is S.NegativeInfinity or a != int(a):\n            raise NotImplementedError\n        # Use fast hypergeometric summation if possible\n        v = hypsum(func, n, int(a), prec2)\n        delta = prec - fastlog(v)\n        if fastlog(v) < -10:\n            v = hypsum(func, n, int(a), delta)\n        return v, None, min(prec, delta), None\n    except NotImplementedError:\n        # Euler-Maclaurin summation for general series\n        eps = Float(2.0)**(-prec)\n        for i in range(1, 5):\n            m = n = 2**i * prec\n            s, err = expr.euler_maclaurin(m=m, n=n, eps=eps,\n                eval_integral=False)\n            err = err.evalf()\n            if err is S.NaN:\n                raise NotImplementedError\n            if err <= eps:\n                break\n        err = fastlog(evalf(abs(err), 20, options)[0])\n        re, im, re_acc, im_acc = evalf(s, prec2, options)\n        if re_acc is None:\n            re_acc = -err\n        if im_acc is None:\n            im_acc = -err\n        return re, im, re_acc, im_acc",
    "sympy.sympy.core.evalf.evalf_symbol": "def evalf_symbol(x: Expr, prec: int, options: OPT_DICT) -> TMP_RES:\n    val = options['subs'][x]\n    if isinstance(val, mpf):\n        if not val:\n            return None, None, None, None\n        return val._mpf_, None, prec, None\n    else:\n        if '_cache' not in options:\n            options['_cache'] = {}\n        cache = options['_cache']\n        cached, cached_prec = cache.get(x, (None, MINUS_INF))\n        if cached_prec >= prec:\n            return cached\n        v = evalf(sympify(val), prec, options)\n        cache[x] = (v, prec)\n        return v",
    "sympy.sympy.core.evalf.<lambda>": "NaN: lambda x, prec, options: (fnan, None, prec, None),\n\n",
    "sympy.sympy.core.evalf._eval_evalf": "def _eval_evalf(self, prec: int) -> Expr | None:\n    return None",
    "sympy.sympy.core.evalf._to_mpmath": "def _to_mpmath(self, prec, allow_ints=True):\n    # mpmath functions accept ints as input\n    errmsg = \"cannot convert to mpmath number\"\n    if allow_ints and self.is_Integer:\n        return self.p\n    if hasattr(self, '_as_mpf_val'):\n        return make_mpf(self._as_mpf_val(prec))\n    try:\n        result = evalf(self, prec, {})\n        return quad_to_mpmath(result)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            raise ValueError(errmsg)\n        if v.is_Float:\n            return make_mpf(v._mpf_)\n        # Number + Number*I is also fine\n        re, im = v.as_real_imag()\n        if allow_ints and re.is_Integer:\n            re = from_int(re.p)\n        elif re.is_Float:\n            re = re._mpf_\n        else:\n            raise ValueError(errmsg)\n        if allow_ints and im.is_Integer:\n            im = from_int(im.p)\n        elif im.is_Float:\n            im = im._mpf_\n        else:\n            raise ValueError(errmsg)\n        return make_mpc((re, im))",
    "sympy.sympy.core.evalf.evalf_abs": "def evalf_abs(expr: 'Abs', prec: int, options: OPT_DICT) -> TMP_RES:\n    return get_abs(expr.args[0], prec, options)",
    "sympy.sympy.core.evalf.evalf_re": "def evalf_re(expr: 're', prec: int, options: OPT_DICT) -> TMP_RES:\n    return get_complex_part(expr.args[0], 0, prec, options)",
    "sympy.sympy.core.evalf.evalf_im": "def evalf_im(expr: 'im', prec: int, options: OPT_DICT) -> TMP_RES:\n    return get_complex_part(expr.args[0], 1, prec, options)",
    "sympy.sympy.core.evalf.chop_parts": "def chop_parts(value: TMP_RES, prec: int) -> TMP_RES:\n    \"\"\"\n    Chop off tiny real or complex parts.\n    \"\"\"\n    if value is S.ComplexInfinity:\n        return value\n    re, im, re_acc, im_acc = value\n    # Method 1: chop based on absolute value\n    if re and re not in _infs_nan and (fastlog(re) < -prec + 4):\n        re, re_acc = None, None\n    if im and im not in _infs_nan and (fastlog(im) < -prec + 4):\n        im, im_acc = None, None\n    # Method 2: chop if inaccurate and relatively small\n    if re and im:\n        delta = fastlog(re) - fastlog(im)\n        if re_acc < 2 and (delta - re_acc <= -prec + 4):\n            re, re_acc = None, None\n        if im_acc < 2 and (delta - im_acc >= prec - 4):\n            im, im_acc = None, None\n    return re, im, re_acc, im_acc",
    "sympy.sympy.core.evalf.check_target": "def check_target(expr: Expr, result: TMP_RES, prec: int):\n    a = complex_accuracy(result)\n    if a < prec:\n        raise PrecisionExhausted(\"Failed to distinguish the expression: \\n\\n%s\\n\\n\"\n            \"from zero. Try simplifying the input, using chop=True, or providing \"\n            \"a higher maxn for evalf\" % (expr))",
    "sympy.sympy.core.evalf.evalf_ceiling": "def evalf_ceiling(expr: 'ceiling', prec: int, options: OPT_DICT) -> TMP_RES:\n    return get_integer_part(expr.args[0], 1, options)",
    "sympy.sympy.core.evalf.evalf_floor": "def evalf_floor(expr: 'floor', prec: int, options: OPT_DICT) -> TMP_RES:\n    return get_integer_part(expr.args[0], -1, options)",
    "sympy.sympy.core.evalf.evalf_float": "def evalf_float(expr: 'Float', prec: int, options: OPT_DICT) -> TMP_RES:\n    return expr._mpf_, None, prec, None",
    "sympy.sympy.core.evalf.evalf_rational": "def evalf_rational(expr: 'Rational', prec: int, options: OPT_DICT) -> TMP_RES:\n    return from_rational(expr.p, expr.q, prec), None, prec, None",
    "sympy.sympy.core.evalf.evalf_integer": "def evalf_integer(expr: 'Integer', prec: int, options: OPT_DICT) -> TMP_RES:\n    return from_int(expr.p, prec), None, prec, None",
    "sympy.sympy.core.evalf.evalf_add": "def evalf_add(v: 'Add', prec: int, options: OPT_DICT) -> TMP_RES:\n    res = pure_complex(v)\n    if res:\n        h, c = res\n        re, _, re_acc, _ = evalf(h, prec, options)\n        im, _, im_acc, _ = evalf(c, prec, options)\n        return re, im, re_acc, im_acc\n\n    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n\n    i = 0\n    target_prec = prec\n    while 1:\n        options['maxprec'] = min(oldmaxprec, 2*prec)\n\n        terms = [evalf(arg, prec + 10, options) for arg in v.args]\n        n = terms.count(S.ComplexInfinity)\n        if n >= 2:\n            return fnan, None, prec, None\n        re, re_acc = add_terms(\n            [a[0::2] for a in terms if isinstance(a, tuple) and a[0]], prec, target_prec)\n        im, im_acc = add_terms(\n            [a[1::2] for a in terms if isinstance(a, tuple) and a[1]], prec, target_prec)\n        if n == 1:\n            if re in (finf, fninf, fnan) or im in (finf, fninf, fnan):\n                return fnan, None, prec, None\n            return S.ComplexInfinity\n        acc = complex_accuracy((re, im, re_acc, im_acc))\n        if acc >= target_prec:\n            if options.get('verbose'):\n                print(\"ADD: wanted\", target_prec, \"accurate bits, got\", re_acc, im_acc)\n            break\n        else:\n            if (prec - target_prec) > options['maxprec']:\n                break\n\n            prec = prec + max(10 + 2**i, target_prec - acc)\n            i += 1\n            if options.get('verbose'):\n                print(\"ADD: restarting with prec\", prec)\n\n    options['maxprec'] = oldmaxprec\n    if iszero(re, scaled=True):\n        re = scaled_zero(re) # type: ignore\n    if iszero(im, scaled=True):\n        im = scaled_zero(im) # type: ignore\n    return re, im, re_acc, im_acc",
    "sympy.sympy.core.evalf.evalf_mul": "def evalf_mul(v: 'Mul', prec: int, options: OPT_DICT) -> TMP_RES:\n    res = pure_complex(v)\n    if res:\n        # the only pure complex that is a mul is h*I\n        _, h = res\n        im, _, im_acc, _ = evalf(h, prec, options)\n        return None, im, None, im_acc\n    args = list(v.args)\n\n    # see if any argument is NaN or oo and thus warrants a special return\n    has_zero = False\n    special = []\n    from .numbers import Float\n    for arg in args:\n        result = evalf(arg, prec, options)\n        if result is S.ComplexInfinity:\n            special.append(result)\n            continue\n        if result[0] is None:\n            if result[1] is None:\n                has_zero = True\n            continue\n        num = Float._new(result[0], 1)\n        if num is S.NaN:\n            return fnan, None, prec, None\n        if num.is_infinite:\n            special.append(num)\n    if special:\n        if has_zero:\n            return fnan, None, prec, None\n        from .mul import Mul\n        return evalf(Mul(*special), prec + 4, {})\n    if has_zero:\n        return None, None, None, None\n\n    # With guard digits, multiplication in the real case does not destroy\n    # accuracy. This is also true in the complex case when considering the\n    # total accuracy; however accuracy for the real or imaginary parts\n    # separately may be lower.\n    acc = prec\n\n    # XXX: big overestimate\n    working_prec = prec + len(args) + 5\n\n    # Empty product is 1\n    start = man, exp, bc = MPZ(1), 0, 1\n\n    # First, we multiply all pure real or pure imaginary numbers.\n    # direction tells us that the result should be multiplied by\n    # I**direction; all other numbers get put into complex_factors\n    # to be multiplied out after the first phase.\n    last = len(args)\n    direction = 0\n    args.append(S.One)\n    complex_factors = []\n\n    for i, arg in enumerate(args):\n        if i != last and pure_complex(arg):\n            args[-1] = (args[-1]*arg).expand()\n            continue\n        elif i == last and arg is S.One:\n            continue\n        re, im, re_acc, im_acc = evalf(arg, working_prec, options)\n        if re and im:\n            complex_factors.append((re, im, re_acc, im_acc))\n            continue\n        elif re:\n            (s, m, e, b), w_acc = re, re_acc\n        elif im:\n            (s, m, e, b), w_acc = im, im_acc\n            direction += 1\n        else:\n            return None, None, None, None\n        direction += 2*s\n        man *= m\n        exp += e\n        bc += b\n        while bc > 3*working_prec:\n            man >>= working_prec\n            exp += working_prec\n            bc -= working_prec\n        acc = min(acc, w_acc)\n    sign = (direction & 2) >> 1\n    if not complex_factors:\n        v = normalize(sign, man, exp, man.bit_length(), prec, rnd)\n        # multiply by i\n        if direction & 1:\n            return None, v, None, acc\n        else:\n            return v, None, acc, None\n    else:\n        # initialize with the first term\n        if (man, exp, bc) != start:\n            # there was a real part; give it an imaginary part\n            re, im = (sign, man, exp, man.bit_length()), (0, MPZ(0), 0, 0)\n            i0 = 0\n        else:\n            # there is no real part to start (other than the starting 1)\n            wre, wim, wre_acc, wim_acc = complex_factors[0]\n            acc = min(acc,\n                      complex_accuracy((wre, wim, wre_acc, wim_acc)))\n            re = wre\n            im = wim\n            i0 = 1\n\n        for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:\n            # acc is the overall accuracy of the product; we aren't\n            # computing exact accuracies of the product.\n            acc = min(acc,\n                      complex_accuracy((wre, wim, wre_acc, wim_acc)))\n\n            use_prec = working_prec\n            A = mpf_mul(re, wre, use_prec)\n            B = mpf_mul(mpf_neg(im), wim, use_prec)\n            C = mpf_mul(re, wim, use_prec)\n            D = mpf_mul(im, wre, use_prec)\n            re = mpf_add(A, B, use_prec)\n            im = mpf_add(C, D, use_prec)\n        if options.get('verbose'):\n            print(\"MUL: wanted\", prec, \"accurate bits, got\", acc)\n        # multiply by I\n        if direction & 1:\n            re, im = mpf_neg(im), re\n        return re, im, acc, acc",
    "sympy.sympy.core.evalf.evalf_pow": "def evalf_pow(v: 'Pow', prec: int, options) -> TMP_RES:\n\n    target_prec = prec\n    base, exp = v.args\n\n    # We handle x**n separately. This has two purposes: 1) it is much\n    # faster, because we avoid calling evalf on the exponent, and 2) it\n    # allows better handling of real/imaginary parts that are exactly zero\n    if exp.is_Integer:\n        p: int = exp.p  # type: ignore\n        # Exact\n        if not p:\n            return fone, None, prec, None\n        # Exponentiation by p magnifies relative error by |p|, so the\n        # base must be evaluated with increased precision if p is large\n        prec += int(math.log2(abs(p)))\n        result = evalf(base, prec + 5, options)\n        if result is S.ComplexInfinity:\n            if p < 0:\n                return None, None, None, None\n            return result\n        re, im, re_acc, im_acc = result\n        # Real to integer power\n        if re and not im:\n            return mpf_pow_int(re, p, target_prec), None, target_prec, None\n        # (x*I)**n = I**n * x**n\n        if im and not re:\n            z = mpf_pow_int(im, p, target_prec)\n            case = p % 4\n            if case == 0:\n                return z, None, target_prec, None\n            if case == 1:\n                return None, z, None, target_prec\n            if case == 2:\n                return mpf_neg(z), None, target_prec, None\n            if case == 3:\n                return None, mpf_neg(z), None, target_prec\n        # Zero raised to an integer power\n        if not re:\n            if p < 0:\n                return S.ComplexInfinity\n            return None, None, None, None\n        # General complex number to arbitrary integer power\n        re, im = libmp.mpc_pow_int((re, im), p, prec)\n        # Assumes full accuracy in input\n        return finalize_complex(re, im, target_prec)\n\n    result = evalf(base, prec + 5, options)\n    if result is S.ComplexInfinity:\n        if exp.is_Rational:\n            if exp < 0:\n                return None, None, None, None\n            return result\n        raise NotImplementedError\n\n    # Pure square root\n    if exp is S.Half:\n        xre, xim, _, _ = result\n        # General complex square root\n        if xim:\n            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)\n            return finalize_complex(re, im, prec)\n        if not xre:\n            return None, None, None, None\n        # Square root of a negative real number\n        if mpf_lt(xre, fzero):\n            return None, mpf_sqrt(mpf_neg(xre), prec), None, prec\n        # Positive square root\n        return mpf_sqrt(xre, prec), None, prec, None\n\n    # We first evaluate the exponent to find its magnitude\n    # This determines the working precision that must be used\n    prec += 10\n    result = evalf(exp, prec, options)\n    if result is S.ComplexInfinity:\n        return fnan, None, prec, None\n    yre, yim, _, _ = result\n    # Special cases: x**0\n    if not (yre or yim):\n        return fone, None, prec, None\n\n    ysize = fastlog(yre)\n    # Restart if too big\n    # XXX: prec + ysize might exceed maxprec\n    if ysize > 5:\n        prec += ysize\n        yre, yim, _, _ = evalf(exp, prec, options)\n\n    # Pure exponential function; no need to evalf the base\n    if base is S.Exp1:\n        if yim:\n            re, im = libmp.mpc_exp((yre or fzero, yim), prec)\n            return finalize_complex(re, im, target_prec)\n        return mpf_exp(yre, target_prec), None, target_prec, None\n\n    xre, xim, _, _ = evalf(base, prec + 5, options)\n    # 0**y\n    if not (xre or xim):\n        if yim:\n            return fnan, None, prec, None\n        if yre[0] == 1:  # y < 0\n            return S.ComplexInfinity\n        return None, None, None, None\n\n    # (real ** complex) or (complex ** complex)\n    if yim:\n        re, im = libmp.mpc_pow(\n            (xre or fzero, xim or fzero), (yre or fzero, yim),\n            target_prec)\n        return finalize_complex(re, im, target_prec)\n    # complex ** real\n    if xim:\n        re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)\n        return finalize_complex(re, im, target_prec)\n    # negative ** real\n    elif mpf_lt(xre, fzero):\n        re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)\n        return finalize_complex(re, im, target_prec)\n    # positive ** real\n    else:\n        return mpf_pow(xre, yre, target_prec), None, target_prec, None",
    "sympy.sympy.core.evalf.evalf_exp": "def evalf_exp(expr: 'exp', prec: int, options: OPT_DICT) -> TMP_RES:\n    from .power import Pow\n    return evalf_pow(Pow(S.Exp1, expr.exp, evaluate=False), prec, options)",
    "sympy.sympy.core.evalf.evalf_trig": "def evalf_trig(v: Expr, prec: int, options: OPT_DICT) -> TMP_RES:\n    \"\"\"\n    This function handles sin , cos and tan of complex arguments.\n\n    \"\"\"\n    from sympy.functions.elementary.trigonometric import cos, sin, tan\n    if isinstance(v, cos):\n        func = mpf_cos\n    elif isinstance(v, sin):\n        func = mpf_sin\n    elif isinstance(v,tan):\n        func = mpf_tan\n    else:\n        raise NotImplementedError\n    arg = v.args[0]\n    # 20 extra bits is possibly overkill. It does make the need\n    # to restart very unlikely\n    xprec = prec + 20\n    re, im, re_acc, im_acc = evalf(arg, xprec, options)\n    if im:\n        if 'subs' in options:\n            v = v.subs(options['subs'])\n        return evalf(v._eval_evalf(prec), prec, options) # type: ignore\n    if not re:\n        if isinstance(v, cos):\n            return fone, None, prec, None\n        # Since the type of v has already been checked,\n        # only sin or tan can reach this point.\n        return None, None, None, None\n\n    # For trigonometric functions, we are interested in the\n    # fixed-point (absolute) accuracy of the argument.\n    xsize = fastlog(re)\n    # Magnitude <= 1.0. OK to compute directly, because there is no\n    # danger of hitting the first root of cos (with sin, magnitude\n    # <= 2.0 would actually be ok)\n    if xsize < 1:\n        return func(re, prec, rnd), None, prec, None\n    # Very large\n    if xsize >= 10:\n        xprec = prec + xsize\n        re, im, re_acc, im_acc = evalf(arg, xprec, options)\n    # Need to repeat in case the argument is very close to a\n    # multiple of pi (or pi/2), hitting close to a root\n    while 1:\n        y = func(re, prec, rnd)\n        ysize = fastlog(y)\n        gap = -ysize\n        accuracy = (xprec - xsize) - gap\n        if accuracy < prec:\n            if options.get('verbose'):\n                print(\"SIN/COS/TAN\", accuracy, \"wanted\", prec, \"gap\", gap)\n                print(to_str(y, 10))\n            if xprec > options.get('maxprec', DEFAULT_MAXPREC):\n                return y, None, accuracy, None\n            xprec += gap\n            re, im, re_acc, im_acc = evalf(arg, xprec, options)\n            continue\n        else:\n            return y, None, prec, None",
    "sympy.sympy.core.evalf.evalf_log": "def evalf_log(expr: 'log', prec: int, options: OPT_DICT) -> TMP_RES:\n    if len(expr.args)>1:\n        expr = expr.doit()\n        return evalf(expr, prec, options)\n    arg = expr.args[0]\n    workprec = prec + 10\n    result = evalf(arg, workprec, options)\n    if result is S.ComplexInfinity:\n        return result\n    xre, xim, xacc, _ = result\n\n    # evalf can return NoneTypes if chop=True\n    # issue 18516, 19623\n    if xre is xim is None:\n        # Dear reviewer, I do not know what -inf is;\n        # it looks to be (1, 0, -789, -3)\n        # but I'm not sure in general,\n        # so we just let mpmath figure\n        # it out by taking log of 0 directly.\n        # It would be better to return -inf instead.\n        xre = fzero\n\n    if xim:\n        from sympy.functions.elementary.complexes import Abs\n        from sympy.functions.elementary.exponential import log\n\n        # XXX: use get_abs etc instead\n        re = evalf_log(\n            log(Abs(arg, evaluate=False), evaluate=False), prec, options)\n        im = mpf_atan2(xim, xre or fzero, prec)\n        return re[0], im, re[2], prec\n\n    imaginary_term = (mpf_cmp(xre, fzero) < 0)\n\n    re = mpf_log(mpf_abs(xre), prec, rnd)\n    size = fastlog(re)\n    if prec - size > workprec and re != fzero:\n        from .add import Add\n        # We actually need to compute 1+x accurately, not x\n        add = Add(S.NegativeOne, arg, evaluate=False)\n        xre, xim, _, _ = evalf_add(add, prec, options)\n        prec2 = workprec - fastlog(xre)\n        # xre is now x - 1 so we add 1 back here to calculate x\n        re = mpf_log(mpf_abs(mpf_add(xre, fone, prec2)), prec, rnd)\n\n    re_acc = prec\n\n    if imaginary_term:\n        return re, mpf_pi(prec), re_acc, prec\n    else:\n        return re, None, re_acc, None",
    "sympy.sympy.core.expr.as_real_imag": "def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:\n    \"\"\"Performs complex expansion on 'self' and returns a tuple\n       containing collected both real and imaginary parts. This\n       method cannot be confused with re() and im() functions,\n       which does not perform complex expansion at evaluation.\n\n       However it is possible to expand both re() and im()\n       functions and get exactly the same results as with\n       a single call to this function.\n\n       >>> from sympy import symbols, I\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> (x + y*I).as_real_imag()\n       (x, y)\n\n       >>> from sympy.abc import z, w\n\n       >>> (z + w*I).as_real_imag()\n       (re(z) - im(w), re(w) + im(z))\n\n    \"\"\"\n    if hints.get('ignore') == self:\n        return None  # type: ignore\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.function._eval_evalf": "def _eval_evalf(self, prec):\n\n    def _get_mpmath_func(fname):\n        \"\"\"Lookup mpmath function based on name\"\"\"\n        if isinstance(self, AppliedUndef):\n            # Shouldn't lookup in mpmath but might have ._imp_\n            return None\n\n        if not hasattr(mpmath, fname):\n            fname = MPMATH_TRANSLATIONS.get(fname, None)\n            if fname is None:\n                return None\n        return getattr(mpmath, fname)\n\n    _eval_mpmath = getattr(self, '_eval_mpmath', None)\n    if _eval_mpmath is None:\n        func = _get_mpmath_func(self.func.__name__)\n        args = self.args\n    else:\n        func, args = _eval_mpmath()\n\n    # Fall-back evaluation\n    if func is None:\n        imp = getattr(self, '_imp_', None)\n        if imp is None:\n            return None\n        try:\n            return Float(imp(*[i.evalf(prec) for i in self.args]), prec)\n        except (TypeError, ValueError):\n            return None\n\n    # Convert all args to mpf or mpc\n    # Convert the arguments to *higher* precision than requested for the\n    # final result.\n    # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should\n    #     we be more intelligent about it?\n    try:\n        args = [arg._to_mpmath(prec + 5) for arg in args]\n        def bad(m):\n            from mpmath import mpf, mpc\n            # the precision of an mpf value is the last element\n            # if that is 1 (and m[1] is not 1 which would indicate a\n            # power of 2), then the eval failed; so check that none of\n            # the arguments failed to compute to a finite precision.\n            # Note: An mpc value has two parts, the re and imag tuple;\n            # check each of those parts, too. Anything else is allowed to\n            # pass\n            if isinstance(m, mpf):\n                m = m._mpf_\n                return m[1] !=1 and m[-1] == 1\n            elif isinstance(m, mpc):\n                m, n = m._mpc_\n                return m[1] !=1 and m[-1] == 1 and \\\n                    n[1] !=1 and n[-1] == 1\n            else:\n                return False\n        if any(bad(a) for a in args):\n            raise ValueError  # one or more args failed to compute with significance\n    except ValueError:\n        return\n\n    with mpmath.workprec(prec):\n        v = func(*args)\n\n    return Expr._from_mpmath(v, prec)",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return hash((self.class_key(), frozenset(self._kwargs.items())))",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    "sympy.sympy.core.operations._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\"\n    Evaluate the parts of self that are numbers; if the whole thing\n    was a number with no functions it would have been evaluated, but\n    it wasn't so we must judiciously extract the numbers and reconstruct\n    the object. This is *not* simply replacing numbers with evaluated\n    numbers. Numbers should be handled in the largest pure-number\n    expression as possible. So the code below separates ``self`` into\n    number and non-number parts and evaluates the number parts and\n    walks the args of the non-number part recursively (doing the same\n    thing).\n    \"\"\"\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        # if x is an AssocOp Function then the _evalf below will\n        # call _eval_evalf (here) so we must break the recursion\n        if not (tail is self.identity or\n                isinstance(x, AssocOp) and x.is_Function or\n                x is self.identity and isinstance(tail, AssocOp)):\n            # here, we have a number so we just call to _evalf with prec;\n            # prec is not the same as n, it is the binary precision so\n            # that's why we don't call to evalf.\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                # here we call to _eval_evalf since we don't know what we\n                # are dealing with and all other _eval_evalf routines should\n                # be doing the same thing (i.e. taking binary prec and\n                # finding the evalf-able args)\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n\n    # this is the same as above, but there were no pure-number args to\n    # deal with\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    "sympy.sympy.core.relational._eval_evalf": "def _eval_evalf(self, prec):\n    return self.func(*[s._evalf(prec) for s in self.args])",
    "sympy.sympy.functions.combinatorial.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    if not all(x.is_number for x in self.args):\n        return\n    n = self.args[0]._to_mpmath(prec)\n    x = (self.args[1] if len(self.args) > 1 else S.One)._to_mpmath(prec)\n    with workprec(prec):\n        if n == 0:\n            res = mp.mpf(1)\n        elif n == 1:\n            res = x - mp.mpf(0.5)\n        elif mp.isint(n) and n >= 0:\n            res = mp.bernoulli(n) if x == 1 else mp.bernpoly(n, x)\n        else:\n            res = -n * mp.zeta(1-n, x)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.elementary.complexes._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    return self.args[0]._eval_evalf(prec)",
    "sympy.sympy.functions.elementary.exponential._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    i = im(self.args[0])\n    try:\n        bad = (i <= -pi or i > pi)\n    except TypeError:\n        bad = True\n    if bad:\n        return self  # cannot evalf for this argument\n    res = exp(self.args[0])._eval_evalf(prec)\n    if i > 0 and im(res) < 0:\n        # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi\n        return re(res)\n    return res",
    "sympy.sympy.functions.elementary.trigonometric._eval_evalf": "def _eval_evalf(self, prec):\n    y, x = self.args\n    if x.is_extended_real and y.is_extended_real:\n        return super()._eval_evalf(prec)",
    "sympy.sympy.functions.special.bessel._eval_evalf": "def _eval_evalf(self, prec):\n    if self.order.is_Integer:\n        return self.rewrite(besselj)._eval_evalf(prec)",
    "sympy.sympy.functions.special.error_functions._eval_evalf": "def _eval_evalf(self, prec):\n    return self.rewrite(erfinv)._eval_evalf(prec)",
    "sympy.sympy.functions.special.gamma_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if not all(i.is_number for i in self.args):\n        return\n    s = self.args[0]._to_mpmath(prec+12)\n    z = self.args[1]._to_mpmath(prec+12)\n    if mp.isint(z) and z <= 0:\n        return S.ComplexInfinity\n    with workprec(prec+12):\n        if mp.isint(s) and s >= 0:\n            res = mp.polygamma(s, z)\n        else:\n            zt = mp.zeta(s+1, z)\n            dzt = mp.zeta(s+1, z, 1)\n            res = (dzt + (mp.euler + mp.digamma(-s)) * zt) * mp.rgamma(-s)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.special.hyper._eval_evalf": "def _eval_evalf(self, prec):\n    # The default code is insufficient for polar arguments.\n    # mpmath provides an optional argument \"r\", which evaluates\n    # G(z**(1/r)). I am not sure what its intended use is, but we hijack it\n    # here in the following way: to evaluate at a number z of |argument|\n    # less than (say) n*pi, we put r=1/n, compute z' = root(z, n)\n    # (carefully so as not to loose the branch information), and evaluate\n    # G(z'**(1/r)) = G(z'**n) = G(z).\n    import mpmath\n    znum = self.argument._eval_evalf(prec)\n    if znum.has(exp_polar):\n        znum, branch = znum.as_coeff_mul(exp_polar)\n        if len(branch) != 1:\n            return\n        branch = branch[0].args[0]/I\n    else:\n        branch = S.Zero\n    n = ceiling(abs(branch/pi)) + 1\n    znum = znum**(S.One/n)*exp(I*branch / n)\n\n    # Convert all args to mpf or mpc\n    try:\n        [z, r, ap, bq] = [arg._to_mpmath(prec)\n                for arg in [znum, 1/n, self.args[0], self.args[1]]]\n    except ValueError:\n        return\n\n    with mpmath.workprec(prec):\n        v = mpmath.meijerg(ap, bq, z, r)\n\n    return Expr._from_mpmath(v, prec)",
    "sympy.sympy.functions.special.spherical_harmonics._eval_evalf": "def _eval_evalf(self, prec):\n    # Note: works without this function by just calling\n    #       mpmath for Legendre polynomials. But using\n    #       the dedicated function directly is cleaner.\n    from mpmath import mp, workprec\n    n = self.args[0]._to_mpmath(prec)\n    m = self.args[1]._to_mpmath(prec)\n    theta = self.args[2]._to_mpmath(prec)\n    phi = self.args[3]._to_mpmath(prec)\n    with workprec(prec):\n        res = mp.spherharm(n, m, theta, phi)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.special.zeta_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if all(i.is_number for i in self.args):\n        return self.rewrite(zeta)._eval_evalf(prec)",
    "sympy.sympy.geometry.curve._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    f, (t, a, b) = self.args\n    dps = prec_to_dps(prec)\n    f = tuple([i.evalf(n=dps, **options) for i in f])\n    a, b = [i.evalf(n=dps, **options) for i in (a, b)]\n    return self.func(f, (t, a, b))",
    "sympy.sympy.geometry.ellipse._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    pt, r = self.args\n    dps = prec_to_dps(prec)\n    pt = pt.evalf(n=dps, **options)\n    r = r.evalf(n=dps, **options)\n    return self.func(pt, r, evaluate=False)",
    "sympy.sympy.geometry.plane._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    pt, tup = self.args\n    dps = prec_to_dps(prec)\n    pt = pt.evalf(n=dps, **options)\n    tup = tuple([i.evalf(n=dps, **options) for i in tup])\n    return self.func(pt, normal_vector=tup, evaluate=False)",
    "sympy.sympy.geometry.point._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    \"\"\"Evaluate the coordinates of the point.\n\n    This method will, where possible, create and return a new Point\n    where the coordinates are evaluated as floating point numbers to\n    the precision indicated (default=15).\n\n    Parameters\n    ==========\n\n    prec : int\n\n    Returns\n    =======\n\n    point : Point\n\n    Examples\n    ========\n\n    >>> from sympy import Point, Rational\n    >>> p1 = Point(Rational(1, 2), Rational(3, 2))\n    >>> p1\n    Point2D(1/2, 3/2)\n    >>> p1.evalf()\n    Point2D(0.5, 1.5)\n\n    \"\"\"\n    dps = prec_to_dps(prec)\n    coords = [x.evalf(n=dps, **options) for x in self.args]\n    return Point(*coords, evaluate=False)",
    "sympy.sympy.geometry.polygon._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    c, r, n, a = self.args\n    dps = prec_to_dps(prec)\n    c, r, a = [i.evalf(n=dps, **options) for i in (c, r, a)]\n    return self.func(c, r, n, a)",
    "sympy.sympy.physics.control.lti._eval_evalf": "def _eval_evalf(self, prec):\n    return create_transfer_function(\n        self.num._eval_evalf(prec),\n        self.den._eval_evalf(prec),\n        self.var, self.sampling_time)",
    "sympy.sympy.physics.vector.dyadic.subs": "def subs(self, *args, **kwargs):\n    \"\"\"Substitution on the Dyadic.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy import Symbol\n    >>> N = ReferenceFrame('N')\n    >>> s = Symbol('s')\n    >>> a = s*(N.x|N.x)\n    >>> a.subs({s: 2})\n    2*(N.x|N.x)\n\n    \"\"\"\n\n    return sum([Dyadic([(v[0].subs(*args, **kwargs), v[1], v[2])])\n                for v in self.args], Dyadic(0))",
    "sympy.sympy.physics.vector.dyadic._eval_evalf": "def _eval_evalf(self, prec):\n    if not self.args:\n        return self\n    new_args = []\n    dps = prec_to_dps(prec)\n    for inlist in self.args:\n        new_inlist = list(inlist)\n        new_inlist[0] = inlist[0].evalf(n=dps)\n        new_args.append(tuple(new_inlist))\n    return Dyadic(new_args)",
    "sympy.sympy.physics.vector.vector.subs": "def subs(self, *args, **kwargs):\n    \"\"\"Substitution on the Vector.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy import Symbol\n    >>> N = ReferenceFrame('N')\n    >>> s = Symbol('s')\n    >>> a = N.x * s\n    >>> a.subs({s: 2})\n    2*N.x\n\n    \"\"\"\n\n    d = {}\n    for v in self.args:\n        d[v[1]] = v[0].subs(*args, **kwargs)\n    return Vector(d)",
    "sympy.sympy.physics.vector.vector._eval_evalf": "def _eval_evalf(self, prec):\n    if not self.args:\n        return self\n    new_args = []\n    dps = prec_to_dps(prec)\n    for mat, frame in self.args:\n        new_args.append([mat.evalf(n=dps), frame])\n    return Vector(new_args)",
    "sympy.sympy.polys.rootoftools._eval_evalf": "def _eval_evalf(self, prec, **kwargs):\n    \"\"\"Evaluate this complex root to the given precision.\"\"\"\n    # all kwargs are ignored\n    return self.eval_rational(n=prec_to_dps(prec))._evalf(prec)",
    "sympy.sympy.sets.sets._eval_evalf": "def _eval_evalf(self, prec):\n    dps = prec_to_dps(prec)\n    return self.func(*[arg.evalf(n=dps) for arg in self.args])"
}