{
    "sympy.sympy.core.basic.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if self == expr:\n        if repl_dict is None:\n            return {}\n        return repl_dict.copy()",
    "sympy.sympy.core.mul._combine_inverse": "@staticmethod\ndef _combine_inverse(lhs, rhs):\n    \"\"\"\n    Returns lhs/rhs, but treats arguments like symbols, so things\n    like oo/oo return 1 (instead of a nan) and ``I`` behaves like\n    a symbol instead of sqrt(-1).\n    \"\"\"\n    from sympy.simplify.simplify import signsimp\n    from .symbol import Dummy\n    if lhs == rhs:\n        return S.One\n\n    def check(l, r):\n        if l.is_Float and r.is_comparable:\n            # if both objects are added to 0 they will share the same \"normalization\"\n            # and are more likely to compare the same. Since Add(foo, 0) will not allow\n            # the 0 to pass, we use __add__ directly.\n            return l.__add__(0) == r.evalf().__add__(0)\n        return False\n    if check(lhs, rhs) or check(rhs, lhs):\n        return S.One\n    if any(i.is_Pow or i.is_Mul for i in (lhs, rhs)):\n        # gruntz and limit wants a literal I to not combine\n        # with a power of -1\n        d = Dummy('I')\n        _i = {S.ImaginaryUnit: d}\n        i_ = {d: S.ImaginaryUnit}\n        a = lhs.xreplace(_i).as_powers_dict()\n        b = rhs.xreplace(_i).as_powers_dict()\n        blen = len(b)\n        for bi in tuple(b.keys()):\n            if bi in a:\n                a[bi] -= b.pop(bi)\n                if not a[bi]:\n                    a.pop(bi)\n        if len(b) != blen:\n            lhs = Mul(*[k**v for k, v in a.items()]).xreplace(i_)\n            rhs = Mul(*[k**v for k, v in b.items()]).xreplace(i_)\n    rv = lhs/rhs\n    srv = signsimp(rv)\n    return srv if srv.is_Number else rv",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.matches": "def matches(self, expr, repl_dict=None, old=False):\n    expr = _sympify(expr)\n    if repl_dict is None:\n        repl_dict = {}\n\n    # special case, pattern = 1 and expr.exp can match to 0\n    if expr is S.One:\n        d = self.exp.matches(S.Zero, repl_dict)\n        if d is not None:\n            return d\n\n    # make sure the expression to be matched is an Expr\n    if not isinstance(expr, Expr):\n        return None\n\n    b, e = expr.as_base_exp()\n\n    # special case number\n    sb, se = self.as_base_exp()\n    if sb.is_Symbol and se.is_Integer and expr:\n        if e.is_rational:\n            return sb.matches(b**(e/se), repl_dict)\n        return sb.matches(expr**(1/se), repl_dict)\n\n    d = repl_dict.copy()\n    d = self.base.matches(b, d)\n    if d is None:\n        return None\n\n    d = self.exp.xreplace(d).matches(e, d)\n    if d is None:\n        return Expr.matches(self, expr, repl_dict)\n    return d",
    "sympy.sympy.core.symbol.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if any(expr.has(x) for x in self.exclude):\n        return None\n    if not all(f(expr) for f in self.properties):\n        return None\n    if repl_dict is None:\n        repl_dict = {}\n    else:\n        repl_dict = repl_dict.copy()\n    repl_dict[self] = expr\n    return repl_dict"
}