{
    "scikit-learn.sklearn.utils._array_api._is_numpy_namespace": "def _is_numpy_namespace(xp):\n    \"\"\"Return True if xp is backed by NumPy.\"\"\"\n    return xp.__name__ in _NUMPY_NAMESPACE_NAMES",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils.sparsefuncs.count_nonzero": "def count_nonzero(X, axis=None, sample_weight=None):\n    \"\"\"A variant of X.getnnz() with extension to weighting on axis 0.\n\n    Useful in efficiently calculating multilabel metrics.\n\n    Parameters\n    ----------\n    X : sparse matrix of shape (n_samples, n_labels)\n        Input data. It should be of CSR format.\n\n    axis : {0, 1}, default=None\n        The axis on which the data is aggregated.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Weight for each row of X.\n\n    Returns\n    -------\n    nnz : int, float, ndarray of shape (n_samples,) or ndarray of shape (n_features,)\n        Number of non-zero values in the array along a given axis. Otherwise,\n        the total number of non-zero values in the array is returned.\n    \"\"\"\n    if axis == -1:\n        axis = 1\n    elif axis == -2:\n        axis = 0\n    elif X.format != \"csr\":\n        raise TypeError(\"Expected CSR sparse format, got {0}\".format(X.format))\n\n    # We rely here on the fact that np.diff(Y.indptr) for a CSR\n    # will return the number of nonzero entries in each row.\n    # A bincount over Y.indices will return the number of nonzeros\n    # in each column. See ``csr_matrix.getnnz`` in scipy >= 0.14.\n    if axis is None:\n        if sample_weight is None:\n            return X.nnz\n        else:\n            return np.dot(np.diff(X.indptr), sample_weight)\n    elif axis == 1:\n        out = np.diff(X.indptr)\n        if sample_weight is None:\n            # astype here is for consistency with axis=0 dtype\n            return out.astype(\"intp\")\n        return out * sample_weight\n    elif axis == 0:\n        if sample_weight is None:\n            return np.bincount(X.indices, minlength=X.shape[1])\n        else:\n            weights = np.repeat(sample_weight, np.diff(X.indptr))\n            return np.bincount(X.indices, minlength=X.shape[1], weights=weights)\n    else:\n        raise ValueError(\"Unsupported axis: {0}\".format(axis))"
}