{
    "scikit-learn.sklearn.decomposition._base._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._dict_learning._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._factor_analysis._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._fastica._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._kernel_pca._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.eigenvalues_.shape[0]",
    "scikit-learn.sklearn.decomposition._lda._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._nmf._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._sparse_pca._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.decomposition._truncated_svd._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.manifold._t_sne._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.embedding_.shape[1]",
    "scikit-learn.sklearn.neighbors._nca._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    return self.components_.shape[0]",
    "scikit-learn.sklearn.preprocessing._data._n_features_out": "@property\ndef _n_features_out(self):\n    \"\"\"Number of transformed output features.\"\"\"\n    # Used by ClassNamePrefixFeaturesOutMixin. This model preserves the\n    # number of input features but this is not a one-to-one mapping in the\n    # usual sense. Hence the choice not to use OneToOneFeatureMixin to\n    # implement get_feature_names_out for this class.\n    return self.n_features_in_",
    "scikit-learn.sklearn.utils.validation.check_is_fitted": "def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):\n    \"\"\"Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by verifying the presence of\n    fitted attributes (ending with a trailing underscore) and otherwise\n    raises a :class:`~sklearn.exceptions.NotFittedError` with the given message.\n\n    If an estimator does not set any attributes with a trailing underscore, it\n    can define a ``__sklearn_is_fitted__`` method returning a boolean to\n    specify if the estimator is fitted or not. See\n    :ref:`sphx_glr_auto_examples_developing_estimators_sklearn_is_fitted.py`\n    for an example on how to use the API.\n\n    If no `attributes` are passed, this function will pass if an estimator is stateless.\n    An estimator can indicate it's stateless by setting the `requires_fit` tag. See\n    :ref:`estimator_tags` for more information. Note that the `requires_fit` tag\n    is ignored if `attributes` are passed.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator instance for which the check is performed.\n\n    attributes : str, list or tuple of str, default=None\n        Attribute name(s) given as string or a list/tuple of strings\n        Eg.: ``[\"coef_\", \"estimator_\", ...], \"coef_\"``\n\n        If `None`, `estimator` is considered fitted if there exist an\n        attribute that ends with a underscore and does not start with double\n        underscore.\n\n    msg : str, default=None\n        The default error message is, \"This %(name)s instance is not fitted\n        yet. Call 'fit' with appropriate arguments before using this\n        estimator.\"\n\n        For custom messages if \"%(name)s\" is present in the message string,\n        it is substituted for the estimator name.\n\n        Eg. : \"Estimator, %(name)s, must be fitted before sparsifying\".\n\n    all_or_any : callable, {all, any}, default=all\n        Specify whether all or any of the given attributes must exist.\n\n    Raises\n    ------\n    TypeError\n        If the estimator is a class or not an estimator instance\n\n    NotFittedError\n        If the attributes are not found.\n\n    Examples\n    --------\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.utils.validation import check_is_fitted\n    >>> from sklearn.exceptions import NotFittedError\n    >>> lr = LogisticRegression()\n    >>> try:\n    ...     check_is_fitted(lr)\n    ... except NotFittedError as exc:\n    ...     print(f\"Model is not fitted yet.\")\n    Model is not fitted yet.\n    >>> lr.fit([[1, 2], [1, 3]], [1, 0])\n    LogisticRegression()\n    >>> check_is_fitted(lr)\n    \"\"\"\n    if isclass(estimator):\n        raise TypeError(\"{} is a class, not an instance.\".format(estimator))\n    if msg is None:\n        msg = (\n            \"This %(name)s instance is not fitted yet. Call 'fit' with \"\n            \"appropriate arguments before using this estimator.\"\n        )\n\n    if not hasattr(estimator, \"fit\"):\n        raise TypeError(\"%s is not an estimator instance.\" % (estimator))\n\n    tags = get_tags(estimator)\n\n    if not tags.requires_fit and attributes is None:\n        return\n\n    if not _is_fitted(estimator, attributes, all_or_any):\n        raise NotFittedError(msg % {\"name\": type(estimator).__name__})",
    "scikit-learn.sklearn.utils.validation._generate_get_feature_names_out": "def _generate_get_feature_names_out(estimator, n_features_out, input_features=None):\n    \"\"\"Generate feature names out for estimator using the estimator name as the prefix.\n\n    The input_feature names are validated but not used. This function is useful\n    for estimators that generate their own names based on `n_features_out`, i.e. PCA.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator producing output feature names.\n\n    n_feature_out : int\n        Number of feature names out.\n\n    input_features : array-like of str or None, default=None\n        Only used to validate feature names with `estimator.feature_names_in_`.\n\n    Returns\n    -------\n    feature_names_in : ndarray of str or `None`\n        Feature names in.\n    \"\"\"\n    _check_feature_names_in(estimator, input_features, generate_names=False)\n    estimator_name = estimator.__class__.__name__.lower()\n    return np.asarray(\n        [f\"{estimator_name}{i}\" for i in range(n_features_out)], dtype=object\n    )"
}