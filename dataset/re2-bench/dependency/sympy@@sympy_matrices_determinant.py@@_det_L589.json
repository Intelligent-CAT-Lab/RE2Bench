{
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.matrices.determinant._det_DOM": "def _det_DOM(M):\n    DOM = DomainMatrix.from_Matrix(M, field=True, extension=True)\n    K = DOM.domain\n    return K.to_sympy(DOM.det())",
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.matrixbase._eval_det_bareiss": "def _eval_det_bareiss(self, iszerofunc=_is_zero_after_expand_mul) -> Expr:\n    return _det_bareiss(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase._eval_det_berkowitz": "def _eval_det_berkowitz(self) -> Expr:\n    return _det_berkowitz(self)",
    "sympy.sympy.matrices.matrixbase._eval_det_lu": "def _eval_det_lu(self, iszerofunc=_iszero, simpfunc=None) -> Expr:\n    return _det_LU(self, iszerofunc=iszerofunc, simpfunc=simpfunc)",
    "sympy.sympy.matrices.matrixbase._eval_det_bird": "def _eval_det_bird(self) -> Expr:\n    return _det_bird(self)",
    "sympy.sympy.matrices.matrixbase._eval_det_laplace": "def _eval_det_laplace(self) -> Expr:\n    return _det_laplace(self)",
    "sympy.sympy.matrices.matrixbase.strongly_connected_components": "def strongly_connected_components(self) -> list[list[int]]:\n    return _strongly_connected_components(self)",
    "sympy.sympy.matrices.repmatrix.__getitem__": "def __getitem__(self, key: tuple[int | Slice, int | Slice] | int | slice, /\n                ) -> Expr | Self | list[Expr]:\n    return _getitem_RepMatrix(self, key)",
    "sympy.sympy.matrices.utilities._dotprodsimp": "def _dotprodsimp(expr: Expr, withsimp: bool = False) -> Expr | tuple[Expr, bool]:\n    \"\"\"Wrapper for simplify.dotprodsimp to avoid circular imports.\"\"\"\n    from sympy.simplify.simplify import dotprodsimp as dps\n    return dps(expr, withsimp=withsimp)",
    "sympy.sympy.matrices.utilities._get_intermediate_simp": "def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x,\n        onfunc=_dotprodsimp, dotprodsimp=None):\n    \"\"\"Support function for controlling intermediate simplification. Returns a\n    simplification function according to the global setting of dotprodsimp\n    operation.\n\n    ``deffunc``     - Function to be used by default.\n    ``offfunc``     - Function to be used if dotprodsimp has been turned off.\n    ``onfunc``      - Function to be used if dotprodsimp has been turned on.\n    ``dotprodsimp`` - True, False or None. Will be overridden by global\n                      _dotprodsimp_state.state if that is not None.\n    \"\"\"\n\n    if dotprodsimp is False or _dotprodsimp_state.state is False:\n        return offfunc\n    if dotprodsimp is True or _dotprodsimp_state.state is True:\n        return onfunc\n\n    return deffunc # None, None"
}