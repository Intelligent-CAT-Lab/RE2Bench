{
    "sympy.sympy.polys.rings.__eq__": "def __eq__(self, other):\n    return isinstance(other, PolyRing) and self._ring_equality(other)",
    "sympy.sympy.polys.rings.ground_new": "def ground_new(self, coeff) -> PolyElement[Er]:\n    \"\"\"Create a constant polynomial with given coefficient.\"\"\"\n    return self.term_new(self.zero_monom, coeff)",
    "sympy.sympy.polys.rings.from_dict": "def from_dict(\n    self,\n    element: Mapping[Mon, int | Er | Expr] | PolyElement[Er],\n    orig_domain: Domain[Er] | None = None,\n) -> PolyElement[Er]:\n    \"\"\"Create polynomial from dictionary of monomials to coefficients.\"\"\"\n    if not isinstance(element, dict):\n        raise TypeError(\n            \"Input must be a dictionary mapping monomials to coefficients\"\n        )\n    return self._from_dict_ground(element, orig_domain)",
    "sympy.sympy.polys.rings.from_terms": "def from_terms(\n    self, element: Iterable[tuple[Mon, Er]], orig_domain: Domain[Er] | None = None\n) -> PolyElement[Er]:\n    \"\"\"Create polynomial from sequence of (monomial, coefficient) pairs.\"\"\"\n    return self.from_dict(dict(element), orig_domain)",
    "sympy.sympy.polys.rings.from_list": "def from_list(self, element: dmp[Er]) -> PolyElement[Er]:\n    \"\"\"Create polynomial from list(dense) representation.\"\"\"\n    poly_dict = dmp_to_dict(element, self.ngens - 1, self.domain)\n    return self.from_dict(poly_dict)",
    "sympy.sympy.polys.rings.from_expr": "def from_expr(self, expr) -> PolyElement[Er]:\n    \"\"\"Create polynomial from SymPy expression.\"\"\"\n    mapping = dict(zip(self.symbols, self.gens))\n\n    try:\n        poly = self._rebuild_expr(expr, mapping)\n    except CoercionFailed:\n        raise ValueError(\n            f\"expected an expression convertible to a polynomial in {self}, \"\n            f\"got {expr}\"\n        )\n    else:\n        return self.ring_new(poly)"
}