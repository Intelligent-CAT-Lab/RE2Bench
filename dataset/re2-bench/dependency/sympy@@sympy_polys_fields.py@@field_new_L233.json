{
    "sympy.sympy.polys.fields.__eq__": "def __eq__(self, other):\n    return isinstance(other, FracField) and \\\n        (self.symbols, self.ngens, self.domain, self.order) == \\\n        (other.symbols, other.ngens, other.domain, other.order)",
    "sympy.sympy.polys.fields.raw_new": "def raw_new(self,\n        numer: PolyElement[Er],\n        denom: PolyElement[Er] | None = None) -> FracElement[Er]:\n    return self.dtype(numer, denom)",
    "sympy.sympy.polys.fields.new": "def new(self,\n        numer: PolyElement[Er],\n        denom: PolyElement[Er] | None = None) -> FracElement[Er]:\n    if denom is None:\n        denom = self.ring.one\n    numer, denom = numer.cancel(denom)\n    return self.raw_new(numer, denom)",
    "sympy.sympy.polys.fields.ground_new": "def ground_new(self, element) -> FracElement[Er]:\n    try:\n        return self.new(self.ring.ground_new(element))\n    except CoercionFailed:\n        domain = self.domain\n\n        if not domain.is_Field and domain.has_assoc_Field:\n            ring = self.ring\n            ground_field: Field = domain.get_field()\n            element = ground_field.convert(element)\n            numer = ring.ground_new(ground_field.numer(element))\n            denom = ring.ground_new(ground_field.denom(element))\n            return self.raw_new(numer, denom)\n        else:\n            raise",
    "sympy.sympy.polys.fields.from_expr": "def from_expr(self, expr: Expr) -> FracElement[Er]:\n    mapping = dict(list(zip(self.symbols, self.gens)))\n\n    try:\n        frac = self._rebuild_expr(sympify(expr), mapping)\n    except CoercionFailed:\n        raise ValueError(\"expected an expression convertible to a rational function in %s, got %s\" % (self, expr))\n    else:\n        return self.field_new(frac)",
    "sympy.sympy.polys.fields.to_ring": "def to_ring(self) -> PolyRing[Er]:\n    return PolyRing(self.symbols, self.domain, self.order)",
    "sympy.sympy.polys.rings.set_ring": "def set_ring(self, new_ring: PolyRing[Es]) -> PolyElement[Es]:\n    \"\"\"Change the ring of this polynomial.\"\"\"\n    if self.ring == new_ring:\n        return cast(\"PolyElement[Es]\", self)\n    return self._change_ring(new_ring)",
    "sympy.sympy.polys.rings.clear_denoms": "def clear_denoms(self) -> tuple[Er, PolyElement[Er]]:\n    \"\"\"Clear denominators from polynomial coefficients.\"\"\"\n    domain = self.ring.domain\n\n    if not domain.is_Field or not domain.has_assoc_Ring:\n        return domain.one, self\n\n    ground_ring = domain.get_ring()\n    common = ground_ring.one\n    lcm = ground_ring.lcm\n    denom = domain.denom\n\n    for coeff in self.values():\n        common = lcm(common, denom(coeff))\n\n    poly = self.new([(monom, coeff * common) for monom, coeff in self.items()])\n    return common, poly",
    "sympy.sympy.polys.rings.__eq__": "def __eq__(self, other):\n    return isinstance(other, PolyRing) and self._ring_equality(other)",
    "sympy.sympy.polys.rings.to_field": "def to_field(self) -> FracField[Er]:\n    \"\"\"Convert to a field of fractions.\"\"\"\n    from sympy.polys.fields import FracField\n\n    return FracField(self.symbols, self.domain, self.order)",
    "sympy.sympy.polys.rings.ground_new": "def ground_new(self, coeff) -> PolyElement[Er]:\n    \"\"\"Create a constant polynomial with given coefficient.\"\"\"\n    return self.term_new(self.zero_monom, coeff)",
    "sympy.sympy.polys.rings.ring_new": "def ring_new(self, element) -> PolyElement[Er]:\n    \"\"\"Create a ring element from various input types.\"\"\"\n    if isinstance(element, PolyElement):\n        if self == element.ring:\n            return element\n        elif (\n            isinstance(self.domain, PolynomialRing)\n            and self.domain.ring == element.ring\n        ):\n            return self.ground_new(element)\n        else:\n            raise NotImplementedError(\"conversion\")\n    elif isinstance(element, str):\n        raise NotImplementedError(\"parsing\")\n    elif isinstance(element, dict):\n        return self.from_dict(element)\n    elif isinstance(element, list):\n        try:\n            return self.from_terms(element)\n        except ValueError:\n            return self.from_list(element)\n    elif isinstance(element, Expr):\n        return self.from_expr(element)\n    else:\n        return self.ground_new(element)"
}