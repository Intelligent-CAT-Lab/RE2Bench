{
    "sympy.sympy.polys.matrices.domainmatrix.from_rep": "@classmethod\ndef from_rep(cls, rep):\n    \"\"\"Create a new DomainMatrix efficiently from DDM/SDM.\n\n    Examples\n    ========\n\n    Create a :py:class:`~.DomainMatrix` with an dense internal\n    representation as :py:class:`~.DDM`:\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.ddm import DDM\n    >>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n    Create a :py:class:`~.DomainMatrix` with a sparse internal\n    representation as :py:class:`~.SDM`:\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import ZZ\n    >>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)\n\n    Parameters\n    ==========\n\n    rep: SDM or DDM\n        The internal sparse or dense representation of the matrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        A :py:class:`~.DomainMatrix` wrapping *rep*.\n\n    Notes\n    =====\n\n    This takes ownership of rep as its internal representation. If rep is\n    being mutated elsewhere then a copy should be provided to\n    ``from_rep``. Only minimal verification or checking is done on *rep*\n    as this is supposed to be an efficient internal routine.\n\n    \"\"\"\n    if not (isinstance(rep, (DDM, SDM)) or (DFM is not None and isinstance(rep, DFM))):\n        raise TypeError(\"rep should be of type DDM or SDM\")\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    "sympy.sympy.polys.matrices.sdm.sdm_rref_den": "def sdm_rref_den(A, K):\n    \"\"\"\n    Return the reduced row echelon form (RREF) of A with denominator.\n\n    The RREF is computed using fraction-free Gauss-Jordan elimination.\n\n    Explanation\n    ===========\n\n    The algorithm used is the fraction-free version of Gauss-Jordan elimination\n    described as FFGJ in [1]_. Here it is modified to handle zero or missing\n    pivots and to avoid redundant arithmetic. This implementation is also\n    optimized for sparse matrices.\n\n    The domain $K$ must support exact division (``K.exquo``) but does not need\n    to be a field. This method is suitable for most exact rings and fields like\n    :ref:`ZZ`, :ref:`QQ` and :ref:`QQ(a)`. In the case of :ref:`QQ` or\n    :ref:`K(x)` it might be more efficient to clear denominators and use\n    :ref:`ZZ` or :ref:`K[x]` instead.\n\n    For inexact domains like :ref:`RR` and :ref:`CC` use ``ddm_irref`` instead.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.sdm import sdm_rref_den\n    >>> from sympy.polys.domains import ZZ\n    >>> A = {0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}\n    >>> A_rref, den, pivots = sdm_rref_den(A, ZZ)\n    >>> A_rref\n    {0: {0: -2}, 1: {1: -2}}\n    >>> den\n    -2\n    >>> pivots\n    [0, 1]\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den\n        Higher-level interface to ``sdm_rref_den`` that would usually be used\n        instead of calling this function directly.\n    sympy.polys.matrices.sdm.sdm_rref_den\n        The ``SDM`` method that uses this function.\n    sdm_irref\n        Computes RREF using field division.\n    ddm_irref_den\n        The dense version of this algorithm.\n\n    References\n    ==========\n\n    .. [1] Fraction-free algorithms for linear and polynomial equations.\n        George C. Nakos , Peter R. Turner , Robert M. Williams.\n        https://dl.acm.org/doi/10.1145/271130.271133\n    \"\"\"\n    #\n    # We represent each row of the matrix as a dict mapping column indices to\n    # nonzero elements. We will build the RREF matrix starting from an empty\n    # matrix and appending one row at a time. At each step we will have the\n    # RREF of the rows we have processed so far.\n    #\n    # Our representation of the RREF divides it into three parts:\n    #\n    # 1. Fully reduced rows having only a single nonzero element (the pivot).\n    # 2. Partially reduced rows having nonzeros after the pivot.\n    # 3. The current denominator and divisor.\n    #\n    # For example if the incremental RREF might be:\n    #\n    #   [2, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    #   [0, 0, 2, 0, 0, 0, 7, 0, 0, 0]\n    #   [0, 0, 0, 0, 0, 2, 0, 0, 0, 0]\n    #   [0, 0, 0, 0, 0, 0, 0, 2, 0, 0]\n    #   [0, 0, 0, 0, 0, 0, 0, 0, 2, 0]\n    #\n    # Here the second row is partially reduced and the other rows are fully\n    # reduced. The denominator would be 2 in this case. We distinguish the\n    # fully reduced rows because we can handle them more efficiently when\n    # adding a new row.\n    #\n    # When adding a new row we need to multiply it by the current denominator.\n    # Then we reduce the new row by cross cancellation with the previous rows.\n    # Then if it is not reduced to zero we take its leading entry as the new\n    # pivot, cross cancel the new row from the previous rows and update the\n    # denominator. In the fraction-free version this last step requires\n    # multiplying and dividing the whole matrix by the new pivot and the\n    # current divisor. The advantage of building the RREF one row at a time is\n    # that in the sparse case we only need to work with the relatively sparse\n    # upper rows of the matrix. The simple version of FFGJ in [1] would\n    # multiply and divide all the dense lower rows at each step.\n\n    # Handle the trivial cases.\n    if not A:\n        return ({}, K.one, [])\n    elif len(A) == 1:\n        Ai, = A.values()\n        j = min(Ai)\n        Aij = Ai[j]\n        return ({0: Ai.copy()}, Aij, [j])\n\n    # For inexact domains like RR[x] we use quo and discard the remainder.\n    # Maybe it would be better for K.exquo to do this automatically.\n    if K.is_Exact:\n        exquo = K.exquo\n    else:\n        exquo = K.quo\n\n    # Make sure we have the rows in order to make this deterministic from the\n    # outset.\n    _, rows_in_order = zip(*sorted(A.items()))\n\n    col_to_row_reduced = {}\n    col_to_row_unreduced = {}\n    reduced = col_to_row_reduced.keys()\n    unreduced = col_to_row_unreduced.keys()\n\n    # Our representation of the RREF so far.\n    A_rref_rows = []\n    denom = None\n    divisor = None\n\n    # The rows that remain to be added to the RREF. These are sorted by the\n    # column index of their leading entry. Note that sorted() is stable so the\n    # previous sort by unique row index is still needed to make this\n    # deterministic (there may be multiple rows with the same leading column).\n    A_rows = sorted(rows_in_order, key=min)\n\n    for Ai in A_rows:\n\n        # All fully reduced columns can be immediately discarded.\n        Ai = {j: Aij for j, Aij in Ai.items() if j not in reduced}\n\n        # We need to multiply the new row by the current denominator to bring\n        # it into the same scale as the previous rows and then cross-cancel to\n        # reduce it wrt the previous unreduced rows. All pivots in the previous\n        # rows are equal to denom so the coefficients we need to make a linear\n        # combination of the previous rows to cancel into the new row are just\n        # the ones that are already in the new row *before* we multiply by\n        # denom. We compute that linear combination first and then multiply the\n        # new row by denom before subtraction.\n        Ai_cancel = {}\n\n        for j in unreduced & Ai.keys():\n            # Remove the pivot column from the new row since it would become\n            # zero anyway.\n            Aij = Ai.pop(j)\n\n            Aj = A_rref_rows[col_to_row_unreduced[j]]\n\n            for k, Ajk in Aj.items():\n                Aik_cancel = Ai_cancel.get(k)\n                if Aik_cancel is None:\n                    Ai_cancel[k] = Aij * Ajk\n                else:\n                    Aik_cancel = Aik_cancel + Aij * Ajk\n                    if Aik_cancel:\n                        Ai_cancel[k] = Aik_cancel\n                    else:\n                        Ai_cancel.pop(k)\n\n        # Multiply the new row by the current denominator and subtract.\n        Ai_nz = set(Ai)\n        Ai_cancel_nz = set(Ai_cancel)\n\n        d = denom or K.one\n\n        for k in Ai_cancel_nz - Ai_nz:\n            Ai[k] = -Ai_cancel[k]\n\n        for k in Ai_nz - Ai_cancel_nz:\n            Ai[k] = Ai[k] * d\n\n        for k in Ai_cancel_nz & Ai_nz:\n            Aik = Ai[k] * d - Ai_cancel[k]\n            if Aik:\n                Ai[k] = Aik\n            else:\n                Ai.pop(k)\n\n        # Now Ai has the same scale as the other rows and is reduced wrt the\n        # unreduced rows.\n\n        # If the row is reduced to zero then discard it.\n        if not Ai:\n            continue\n\n        # Choose a pivot for this row.\n        j = min(Ai)\n        Aij = Ai.pop(j)\n\n        # Cross cancel the unreduced rows by the new row.\n        #     a[k][l] = (a[i][j]*a[k][l] - a[k][j]*a[i][l]) / divisor\n        for pk, k in list(col_to_row_unreduced.items()):\n\n            Ak = A_rref_rows[k]\n\n            if j not in Ak:\n                # This row is already reduced wrt the new row but we need to\n                # bring it to the same scale as the new denominator. This step\n                # is not needed in sdm_irref.\n                for l, Akl in Ak.items():\n                    Akl = Akl * Aij\n                    if divisor is not None:\n                        Akl = exquo(Akl, divisor)\n                    Ak[l] = Akl\n                continue\n\n            Akj = Ak.pop(j)\n            Ai_nz = set(Ai)\n            Ak_nz = set(Ak)\n\n            for l in Ai_nz - Ak_nz:\n                Ak[l] = - Akj * Ai[l]\n                if divisor is not None:\n                    Ak[l] = exquo(Ak[l], divisor)\n\n            # This loop also not needed in sdm_irref.\n            for l in Ak_nz - Ai_nz:\n                Ak[l] = Aij * Ak[l]\n                if divisor is not None:\n                    Ak[l] = exquo(Ak[l], divisor)\n\n            for l in Ai_nz & Ak_nz:\n                Akl = Aij * Ak[l] - Akj * Ai[l]\n                if Akl:\n                    if divisor is not None:\n                        Akl = exquo(Akl, divisor)\n                    Ak[l] = Akl\n                else:\n                    Ak.pop(l)\n\n            if not Ak:\n                col_to_row_unreduced.pop(pk)\n                col_to_row_reduced[pk] = k\n\n        i = len(A_rref_rows)\n        A_rref_rows.append(Ai)\n        if Ai:\n            col_to_row_unreduced[j] = i\n        else:\n            col_to_row_reduced[j] = i\n\n        # Update the denominator.\n        if not K.is_one(Aij):\n            if denom is None:\n                denom = Aij\n            else:\n                denom *= Aij\n\n        if divisor is not None:\n            denom = exquo(denom, divisor)\n\n        # Update the divisor.\n        divisor = denom\n\n    if denom is None:\n        denom = K.one\n\n    # Sort the rows by their leading column index.\n    col_to_row = {**col_to_row_reduced, **col_to_row_unreduced}\n    row_to_col = {i: j for j, i in col_to_row.items()}\n    A_rref_rows_col = [(row_to_col[i], Ai) for i, Ai in enumerate(A_rref_rows)]\n    pivots, A_rref = zip(*sorted(A_rref_rows_col))\n    pivots = list(pivots)\n\n    # Insert the pivot values\n    for i, Ai in enumerate(A_rref):\n        Ai[pivots[i]] = denom\n\n    A_rref_sdm = dict(enumerate(A_rref))\n\n    return A_rref_sdm, denom, pivots",
    "sympy.sympy.polys.matrices.sdm.__init__": "def __init__(self, elemsdict, shape, domain):\n    super().__init__(elemsdict)\n    self.shape = self.rows, self.cols = m, n = shape\n    self.domain = domain\n\n    if not all(0 <= r < m for r in self):\n        raise DMBadInputError(\"Row out of range\")\n    if not all(0 <= c < n for row in self.values() for c in row):\n        raise DMBadInputError(\"Column out of range\")"
}