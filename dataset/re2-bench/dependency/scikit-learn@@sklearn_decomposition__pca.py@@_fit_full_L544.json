{
    "scikit-learn.sklearn.decomposition._pca._infer_dimension": "def _infer_dimension(spectrum, n_samples):\n    \"\"\"Infers the dimension of a dataset with a given spectrum.\n\n    The returned value will be in [1, n_features - 1].\n    \"\"\"\n    xp, _ = get_namespace(spectrum)\n\n    ll = xp.empty_like(spectrum)\n    ll[0] = -xp.inf  # we don't want to return n_components = 0\n    for rank in range(1, spectrum.shape[0]):\n        ll[rank] = _assess_dimension(spectrum, rank, n_samples)\n    return xp.argmax(ll)",
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.externals.array_api_compat.numpy._aliases.asarray": "def asarray(\n    obj: Array | complex | NestedSequence[complex] | SupportsBufferProtocol,\n    /,\n    *,\n    dtype: DType | None = None,\n    device: Device | None = None,\n    copy: _Copy | None = None,\n    **kwargs: Any,\n) -> Array:\n    \"\"\"\n    Array API compatibility wrapper for asarray().\n\n    See the corresponding documentation in the array library and/or the array API\n    specification for more details.\n    \"\"\"\n    _helpers._check_device(np, device)\n\n    if copy is None:\n        copy = np._CopyMode.IF_NEEDED\n    elif copy is False:\n        copy = np._CopyMode.NEVER\n    elif copy is True:\n        copy = np._CopyMode.ALWAYS\n\n    return np.array(obj, copy=copy, dtype=dtype, **kwargs)  # pyright: ignore",
    "scikit-learn.sklearn.utils._array_api.device": "def device(*array_list, remove_none=True, remove_types=(str,)):\n    \"\"\"Hardware device where the array data resides on.\n\n    If the hardware device is not the same for all arrays, an error is raised.\n\n    Parameters\n    ----------\n    *array_list : arrays\n        List of array instances from NumPy or an array API compatible library.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in array_list.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in array_list.\n\n    Returns\n    -------\n    out : device\n        `device` object (see the \"Device Support\" section of the array API spec).\n    \"\"\"\n    array_list = _remove_non_arrays(\n        *array_list, remove_none=remove_none, remove_types=remove_types\n    )\n\n    if not array_list:\n        return None\n\n    device_ = _single_array_device(array_list[0])\n\n    # Note: here we cannot simply use a Python `set` as it requires\n    # hashable members which is not guaranteed for Array API device\n    # objects. In particular, CuPy devices are not hashable at the\n    # time of writing.\n    for array in array_list[1:]:\n        device_other = _single_array_device(array)\n        if device_ != device_other:\n            raise ValueError(\n                f\"Input arrays use different devices: {device_}, {device_other}\"\n            )\n\n    return device_",
    "scikit-learn.sklearn.utils.extmath.svd_flip": "def svd_flip(u, v, u_based_decision=True):\n    \"\"\"Sign correction to ensure deterministic output from SVD.\n\n    Adjusts the columns of u and the rows of v such that the loadings in the\n    columns in u that are largest in absolute value are always positive.\n\n    If u_based_decision is False, then the same sign correction is applied to\n    so that the rows in v that are largest in absolute value are always\n    positive.\n\n    Parameters\n    ----------\n    u : ndarray\n        Parameters u and v are the output of `linalg.svd` or\n        :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner\n        dimensions so one can compute `np.dot(u * s, v)`.\n        u can be None if `u_based_decision` is False.\n\n    v : ndarray\n        Parameters u and v are the output of `linalg.svd` or\n        :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner\n        dimensions so one can compute `np.dot(u * s, v)`. The input v should\n        really be called vt to be consistent with scipy's output.\n        v can be None if `u_based_decision` is True.\n\n    u_based_decision : bool, default=True\n        If True, use the columns of u as the basis for sign flipping.\n        Otherwise, use the rows of v. The choice of which variable to base the\n        decision on is generally algorithm dependent.\n\n    Returns\n    -------\n    u_adjusted : ndarray\n        Array u with adjusted columns and the same dimensions as u.\n\n    v_adjusted : ndarray\n        Array v with adjusted rows and the same dimensions as v.\n    \"\"\"\n    xp, _ = get_namespace(*[a for a in [u, v] if a is not None])\n\n    if u_based_decision:\n        # columns of u, rows of v, or equivalently rows of u.T and v\n        max_abs_u_cols = xp.argmax(xp.abs(u.T), axis=1)\n        shift = xp.arange(u.T.shape[0], device=device(u))\n        indices = max_abs_u_cols + shift * u.T.shape[1]\n        signs = xp.sign(xp.take(xp.reshape(u.T, (-1,)), indices, axis=0))\n        u *= signs[np.newaxis, :]\n        if v is not None:\n            v *= signs[:, np.newaxis]\n    else:\n        # rows of v, columns of u\n        max_abs_v_rows = xp.argmax(xp.abs(v), axis=1)\n        shift = xp.arange(v.shape[0], device=device(v))\n        indices = max_abs_v_rows + shift * v.shape[1]\n        signs = xp.sign(xp.take(xp.reshape(v, (-1,)), indices, axis=0))\n        if u is not None:\n            u *= signs[np.newaxis, :]\n        v *= signs[:, np.newaxis]\n    return u, v"
}