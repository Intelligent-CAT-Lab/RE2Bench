{
    "sympy.sympy.assumptions.assume.function": "@property\ndef function(self):\n    \"\"\"\n    Return the predicate.\n    \"\"\"\n    # Will be changed to self.args[0] after args overriding is removed\n    return self._args[0]",
    "sympy.sympy.assumptions.assume.arguments": "@property\ndef arguments(self):\n    \"\"\"\n    Return the arguments which are applied to the predicate.\n    \"\"\"\n    # Will be changed to self.args[1:] after args overriding is removed\n    return self._args[1:]",
    "sympy.sympy.assumptions.cnf.__init__": "def __init__(self, *args):\n    self._args = args",
    "sympy.sympy.assumptions.cnf.__invert__": "def __invert__(self):\n    return AND(*[~arg for arg in self._args])",
    "sympy.sympy.assumptions.cnf.to_NNF": "def to_NNF(expr, composite_map=None):\n    \"\"\"\n    Generates the Negation Normal Form of any boolean expression in terms\n    of AND, OR, and Literal objects.\n\n    Examples\n    ========\n\n    >>> from sympy import Q, Eq\n    >>> from sympy.assumptions.cnf import to_NNF\n    >>> from sympy.abc import x, y\n    >>> expr = Q.even(x) & ~Q.positive(x)\n    >>> to_NNF(expr)\n    (Literal(Q.even(x), False) & Literal(Q.positive(x), True))\n\n    Supported boolean objects are converted to corresponding predicates.\n\n    >>> to_NNF(Eq(x, y))\n    Literal(Q.eq(x, y), False)\n\n    If ``composite_map`` argument is given, ``to_NNF`` decomposes the\n    specified predicate into a combination of primitive predicates.\n\n    >>> cmap = {Q.nonpositive: Q.negative | Q.zero}\n    >>> to_NNF(Q.nonpositive, cmap)\n    (Literal(Q.negative, False) | Literal(Q.zero, False))\n    >>> to_NNF(Q.nonpositive(x), cmap)\n    (Literal(Q.negative(x), False) | Literal(Q.zero(x), False))\n    \"\"\"\n    from sympy.assumptions.ask import Q\n\n    if composite_map is None:\n        composite_map = {}\n\n\n    binrelpreds = {Eq: Q.eq, Ne: Q.ne, Gt: Q.gt, Lt: Q.lt, Ge: Q.ge, Le: Q.le}\n    if type(expr) in binrelpreds:\n        pred = binrelpreds[type(expr)]\n        expr = pred(*expr.args)\n\n    if isinstance(expr, Not):\n        arg = expr.args[0]\n        tmp = to_NNF(arg, composite_map)  # Strategy: negate the NNF of expr\n        return ~tmp\n\n    if isinstance(expr, Or):\n        return OR(*[to_NNF(x, composite_map) for x in Or.make_args(expr)])\n\n    if isinstance(expr, And):\n        return AND(*[to_NNF(x, composite_map) for x in And.make_args(expr)])\n\n    if isinstance(expr, Nand):\n        tmp = AND(*[to_NNF(x, composite_map) for x in expr.args])\n        return ~tmp\n\n    if isinstance(expr, Nor):\n        tmp = OR(*[to_NNF(x, composite_map) for x in expr.args])\n        return ~tmp\n\n    if isinstance(expr, Xor):\n        cnfs = []\n        for i in range(0, len(expr.args) + 1, 2):\n            for neg in combinations(expr.args, i):\n                clause = [~to_NNF(s, composite_map) if s in neg else to_NNF(s, composite_map)\n                          for s in expr.args]\n                cnfs.append(OR(*clause))\n        return AND(*cnfs)\n\n    if isinstance(expr, Xnor):\n        cnfs = []\n        for i in range(0, len(expr.args) + 1, 2):\n            for neg in combinations(expr.args, i):\n                clause = [~to_NNF(s, composite_map) if s in neg else to_NNF(s, composite_map)\n                          for s in expr.args]\n                cnfs.append(OR(*clause))\n        return ~AND(*cnfs)\n\n    if isinstance(expr, Implies):\n        L, R = to_NNF(expr.args[0], composite_map), to_NNF(expr.args[1], composite_map)\n        return OR(~L, R)\n\n    if isinstance(expr, Equivalent):\n        cnfs = []\n        for a, b in zip_longest(expr.args, expr.args[1:], fillvalue=expr.args[0]):\n            a = to_NNF(a, composite_map)\n            b = to_NNF(b, composite_map)\n            cnfs.append(OR(~a, b))\n        return AND(*cnfs)\n\n    if isinstance(expr, ITE):\n        L = to_NNF(expr.args[0], composite_map)\n        M = to_NNF(expr.args[1], composite_map)\n        R = to_NNF(expr.args[2], composite_map)\n        return AND(OR(~L, M), OR(L, R))\n\n    if isinstance(expr, AppliedPredicate):\n        pred, args = expr.function, expr.arguments\n        newpred = composite_map.get(pred, None)\n        if newpred is not None:\n            return to_NNF(newpred.rcall(*args), composite_map)\n\n    if isinstance(expr, Predicate):\n        newpred = composite_map.get(expr, None)\n        if newpred is not None:\n            return to_NNF(newpred, composite_map)\n\n    return Literal(expr)",
    "sympy.sympy.assumptions.cnf.<listcomp>": "clause = [~to_NNF(s, composite_map) if s in neg else to_NNF(s, composite_map)\n          for s in expr.args]\n",
    "sympy.sympy.assumptions.cnf.__new__": "def __new__(cls, lit, is_Not=False):\n    if isinstance(lit, Not):\n        lit = lit.args[0]\n        is_Not = True\n    elif isinstance(lit, (AND, OR, Literal)):\n        return ~lit if is_Not else lit\n    obj = super().__new__(cls)\n    obj.lit = lit\n    obj.is_Not = is_Not\n    return obj",
    "sympy.sympy.assumptions.relation.binrel.__call__": "def __call__(self, *args):\n    if not len(args) == 2:\n        raise TypeError(f\"Q.{self.name} takes two arguments, but got {len(args)}.\")\n    return AppliedBinaryRelation(self, *args)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls, expr):\n    \"\"\"\n    Return a set of args such that cls(*arg_set) == expr.\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr._argset\n    else:\n        return frozenset([sympify(expr)])",
    "sympy.sympy.utilities.decorator.accessor": "@wraps(propfunc)\ndef accessor(self):\n    val = getattr(self, attrname, sentinel)\n    if val is sentinel:\n        val = propfunc(self)\n        setattr(self, attrname, val)\n    return val"
}