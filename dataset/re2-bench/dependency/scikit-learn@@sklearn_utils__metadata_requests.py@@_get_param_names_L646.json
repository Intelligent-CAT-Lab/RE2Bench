{
    "scikit-learn.sklearn.utils._metadata_requests._get_param_names": "def _get_param_names(self, return_alias):\n    \"\"\"Get names of all metadata that can be consumed or routed by this method.\n\n    This method returns the names of all metadata, even the ``False``\n    ones.\n\n    Parameters\n    ----------\n    return_alias : bool\n        Controls whether original or aliased names should be returned. If\n        ``False``, aliases are ignored and original names are returned.\n\n    Returns\n    -------\n    names : set of str\n        A set of strings with the names of all metadata.\n    \"\"\"\n    return set(\n        alias if return_alias and not request_is_valid(alias) else prop\n        for prop, alias in self._requests.items()\n        if not request_is_valid(alias) or alias is not False\n    )",
    "scikit-learn.sklearn.utils._metadata_requests.__getattr__": "def __getattr__(self, name):\n    # Called when the default attribute access fails with an AttributeError\n    # (either __getattribute__() raises an AttributeError because name is\n    # not an instance attribute or an attribute in the class tree for self;\n    # or __get__() of a name property raises AttributeError). This method\n    # should either return the (computed) attribute value or raise an\n    # AttributeError exception.\n    # https://docs.python.org/3/reference/datamodel.html#object.__getattr__\n    if name not in COMPOSITE_METHODS:\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n        )\n\n    requests = {}\n    for method in COMPOSITE_METHODS[name]:\n        mmr = getattr(self, method)\n        existing = set(requests.keys())\n        upcoming = set(mmr.requests.keys())\n        common = existing & upcoming\n        conflicts = [key for key in common if requests[key] != mmr._requests[key]]\n        if conflicts:\n            raise ValueError(\n                f\"Conflicting metadata requests for {', '.join(conflicts)} while\"\n                f\" composing the requests for {name}. Metadata with the same name\"\n                f\" for methods {', '.join(COMPOSITE_METHODS[name])} should have the\"\n                \" same request value.\"\n            )\n        requests.update(mmr._requests)\n    return MethodMetadataRequest(owner=self.owner, method=name, requests=requests)"
}