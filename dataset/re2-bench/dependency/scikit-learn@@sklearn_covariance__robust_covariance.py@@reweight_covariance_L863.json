{
    "scikit-learn.sklearn.covariance._empirical_covariance._set_covariance": "def _set_covariance(self, covariance):\n    \"\"\"Saves the covariance and precision estimates\n\n    Storage is done accordingly to `self.store_precision`.\n    Precision stored only if invertible.\n\n    Parameters\n    ----------\n    covariance : array-like of shape (n_features, n_features)\n        Estimated covariance matrix to be stored, and from which precision\n        is computed.\n    \"\"\"\n    covariance = check_array(covariance)\n    # set covariance\n    self.covariance_ = covariance\n    # set precision\n    if self.store_precision:\n        self.precision_ = linalg.pinvh(covariance, check_finite=False)\n    else:\n        self.precision_ = None",
    "scikit-learn.sklearn.covariance._empirical_covariance.get_precision": "def get_precision(self):\n    \"\"\"Getter for the precision matrix.\n\n    Returns\n    -------\n    precision_ : array-like of shape (n_features, n_features)\n        The precision matrix associated to the current covariance object.\n    \"\"\"\n    if self.store_precision:\n        precision = self.precision_\n    else:\n        precision = linalg.pinvh(self.covariance_, check_finite=False)\n    return precision",
    "scikit-learn.sklearn.covariance._robust_covariance._consistency_factor": "def _consistency_factor(n_features, alpha):\n    \"\"\"Multiplicative factor to make covariance estimate consistent\n    at the normal distribution, as described in [Pison2002]_.\n\n    Parameters\n    ----------\n    n_features : int\n        Number of features.\n\n    alpha : float\n        Parameter related to the proportion of discarded points.\n        This parameter must be in the range (0, 1).\n\n    Returns\n    -------\n    c_alpha : float\n        Scaling factor to make covariance matrix consistent.\n\n    References\n    ----------\n    .. [Butler1993] R. W. Butler. P. L. Davies. M. Jhun. \"Asymptotics for the\n        Minimum Covariance Determinant Estimator.\" Ann. Statist. 21 (3)\n        1385 - 1400, September, 1993. https://doi.org/10.1214/aos/1176349264]\n\n    .. [Croux1999] Croux, C., Haesbroeck, G. \"Influence Function and\n        Efficiency of the Minimum Covariance Determinant Scatter Matrix\n        Estimator\" Journal of Multivariate Analysis 71(2) (1999) 161-190\n\n    .. [Pison2002] Pison, G., Van Aelst, S., Willems, G., \"Small sample\n        corrections for LTS and MCD\" Metrika 55(1) (2002) 111-123\n    \"\"\"\n    # Formulas as in Sec 3 of Pison 2002, derived from Eq 4.2 in Croux 1999\n    q_alpha = chi2.ppf(alpha, df=n_features)\n    c_alpha = alpha / chi2.cdf(q_alpha, n_features + 2)\n    return c_alpha",
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e"
}