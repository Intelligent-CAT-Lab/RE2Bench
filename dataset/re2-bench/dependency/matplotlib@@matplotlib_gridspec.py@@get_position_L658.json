{
    "matplotlib.lib.matplotlib.gridspec.get_grid_positions": "def get_grid_positions(self, fig):\n    \"\"\"\n    Return the positions of the grid cells in figure coordinates.\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        The figure the grid should be applied to. The subplot parameters\n        (margins and spacing between subplots) are taken from *fig*.\n\n    Returns\n    -------\n    bottoms, tops, lefts, rights : array\n        The bottom, top, left, right positions of the grid cells in\n        figure coordinates.\n    \"\"\"\n    nrows, ncols = self.get_geometry()\n    subplot_params = self.get_subplot_params(fig)\n    left = subplot_params.left\n    right = subplot_params.right\n    bottom = subplot_params.bottom\n    top = subplot_params.top\n    wspace = subplot_params.wspace\n    hspace = subplot_params.hspace\n    tot_width = right - left\n    tot_height = top - bottom\n\n    # calculate accumulated heights of columns\n    cell_h = tot_height / (nrows + hspace*(nrows-1))\n    sep_h = hspace * cell_h\n    norm = cell_h * nrows / sum(self._row_height_ratios)\n    cell_heights = [r * norm for r in self._row_height_ratios]\n    sep_heights = [0] + ([sep_h] * (nrows-1))\n    cell_hs = np.cumsum(np.column_stack([sep_heights, cell_heights]).flat)\n\n    # calculate accumulated widths of rows\n    cell_w = tot_width / (ncols + wspace*(ncols-1))\n    sep_w = wspace * cell_w\n    norm = cell_w * ncols / sum(self._col_width_ratios)\n    cell_widths = [r * norm for r in self._col_width_ratios]\n    sep_widths = [0] + ([sep_w] * (ncols-1))\n    cell_ws = np.cumsum(np.column_stack([sep_widths, cell_widths]).flat)\n\n    fig_tops, fig_bottoms = (top - cell_hs).reshape((-1, 2)).T\n    fig_lefts, fig_rights = (left + cell_ws).reshape((-1, 2)).T\n    return fig_bottoms, fig_tops, fig_lefts, fig_rights",
    "matplotlib.lib.matplotlib.gridspec.num2": "@property\ndef num2(self):\n    return self.num1 if self._num2 is None else self._num2",
    "matplotlib.lib.matplotlib.gridspec.get_gridspec": "def get_gridspec(self):\n    return self._gridspec",
    "matplotlib.lib.matplotlib.gridspec.get_geometry": "def get_geometry(self):\n    \"\"\"\n    Return a tuple containing the number of rows and columns in the grid.\n    \"\"\"\n    return self._nrows, self._ncols",
    "matplotlib.lib.matplotlib.transforms.from_extents": "@staticmethod\ndef from_extents(*args, minpos=None):\n    \"\"\"\n    Create a new Bbox from *left*, *bottom*, *right* and *top*.\n\n    The *y*-axis increases upwards.\n\n    Parameters\n    ----------\n    left, bottom, right, top : float\n        The four extents of the bounding box.\n    minpos : float or None\n        If this is supplied, the Bbox will have a minimum positive value\n        set. This is useful when dealing with logarithmic scales and other\n        scales where negative bounds result in floating point errors.\n    \"\"\"\n    bbox = Bbox(np.reshape(args, (2, 2)))\n    if minpos is not None:\n        bbox._minpos[:] = minpos\n    return bbox"
}