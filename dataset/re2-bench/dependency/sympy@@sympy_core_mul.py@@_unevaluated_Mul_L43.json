{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    \"\"\"Return [commutative factors, non-commutative factors] of self.\n\n    Explanation\n    ===========\n\n    self is treated as a Mul and the ordering of the factors is maintained.\n    If ``cset`` is True the commutative factors will be returned in a set.\n    If there were repeated factors (as may happen with an unevaluated Mul)\n    then an error will be raised unless it is explicitly suppressed by\n    setting ``warn`` to False.\n\n    Note: -1 is always separated from a Number unless split_1 is False.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, oo\n    >>> A, B = symbols('A B', commutative=0)\n    >>> x, y = symbols('x y')\n    >>> (-2*x*y).args_cnc()\n    [[-1, 2, x, y], []]\n    >>> (-2.5*x).args_cnc()\n    [[-1, 2.5, x], []]\n    >>> (-2*x*A*B*y).args_cnc()\n    [[-1, 2, x, y], [A, B]]\n    >>> (-2*x*A*B*y).args_cnc(split_1=False)\n    [[-2, x, y], [A, B]]\n    >>> (-2*x*y).args_cnc(cset=True)\n    [{-1, 2, x, y}, []]\n\n    The arg is always treated as a Mul:\n\n    >>> (-2 + x + A).args_cnc()\n    [[], [x - 2 + A]]\n    >>> (-oo).args_cnc() # -oo is a singleton\n    [[-1, oo], []]\n    \"\"\"\n    args = list(Mul.make_args(self))\n\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n\n    if c and split_1 and (\n        c[0].is_Number and\n        c[0].is_extended_negative and\n            c[0] is not S.NegativeOne):\n        c[:1] = [S.NegativeOne, -c[0]]\n\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and len(c) != clen:\n            raise ValueError('repeated commutative arguments: %s' %\n                             [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    "sympy.sympy.core.mul._mulsort": "def _mulsort(args):\n    # in-place sorting of args\n    args.sort(key=_args_sortkey)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.operations._from_args": "@classmethod\ndef _from_args(cls, args, is_commutative=None):\n    \"\"\"Create new instance with already-processed args.\n    If the args are not in canonical order, then a non-canonical\n    result will be returned, so use with caution. The order of\n    args may change if the sign of the args is changed.\"\"\"\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and(a.is_commutative for a in args)\n    obj.is_commutative = is_commutative\n    return obj",
    "sympy.sympy.polys.rootoftools.is_commutative": "@property\ndef is_commutative(self):\n    return True"
}