{
    "matplotlib.lib.matplotlib.path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : (N, 2) array-like\n        The path vertices, as an array, masked array or sequence of pairs.\n        Masked values, if any, will be converted to NaNs, which are then\n        handled correctly by the Agg PathIterator and other consumers of\n        path data, such as :meth:`iter_segments`.\n    codes : array-like or None, optional\n        N-length array of integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        `CLOSEPOLY`).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n\n    if codes is not None and len(vertices):\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'. \"\n                             f\"Your vertices have shape {vertices.shape} \"\n                             f\"but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             f\"to 'MOVETO' ({self.MOVETO}).  \"\n                             f\"Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False",
    "matplotlib.lib.matplotlib.transforms.update_from_path": "def update_from_path(self, path, ignore=None, updatex=True, updatey=True):\n    \"\"\"\n    Update the bounds of the `Bbox` to contain the vertices of the\n    provided path. After updating, the bounds will have positive *width*\n    and *height*; *x0* and *y0* will be the minimal values.\n\n    Parameters\n    ----------\n    path : `~matplotlib.path.Path`\n    ignore : bool, optional\n       - When ``True``, ignore the existing bounds of the `Bbox`.\n       - When ``False``, include the existing bounds of the `Bbox`.\n       - When ``None``, use the last value passed to :meth:`ignore`.\n    updatex, updatey : bool, default: True\n        When ``True``, update the x/y values.\n    \"\"\"\n    if ignore is None:\n        ignore = self._ignore\n\n    if path.vertices.size == 0 or not (updatex or updatey):\n        return\n\n    if ignore:\n        points = np.array([[np.inf, np.inf], [-np.inf, -np.inf]])\n        minpos = np.array([np.inf, np.inf])\n    else:\n        points = self._points.copy()\n        minpos = self._minpos.copy()\n\n    valid_points = (np.isfinite(path.vertices[..., 0])\n                    & np.isfinite(path.vertices[..., 1]))\n\n    if updatex:\n        x = path.vertices[..., 0][valid_points]\n        points[0, 0] = min(points[0, 0], np.min(x, initial=np.inf))\n        points[1, 0] = max(points[1, 0], np.max(x, initial=-np.inf))\n        minpos[0] = min(minpos[0], np.min(x[x > 0], initial=np.inf))\n    if updatey:\n        y = path.vertices[..., 1][valid_points]\n        points[0, 1] = min(points[0, 1], np.min(y, initial=np.inf))\n        points[1, 1] = max(points[1, 1], np.max(y, initial=-np.inf))\n        minpos[1] = min(minpos[1], np.min(y[y > 0], initial=np.inf))\n\n    if np.any(points != self._points) or np.any(minpos != self._minpos):\n        self.invalidate()\n        if updatex:\n            self._points[:, 0] = points[:, 0]\n            self._minpos[0] = minpos[0]\n        if updatey:\n            self._points[:, 1] = points[:, 1]\n            self._minpos[1] = minpos[1]"
}