{
    "scikit-learn.sklearn.externals.array_api_compat.numpy._info.dtypes": "def dtypes(\n    self,\n    *,\n    device: Device | None = None,\n    kind: str | tuple[str, ...] | None = None,\n) -> dict[str, DType]:\n    \"\"\"\n    The array API data types supported by NumPy.\n\n    Note that this function only returns data types that are defined by\n    the array API.\n\n    Parameters\n    ----------\n    device : str, optional\n        The device to get the data types for. For NumPy, only ``'cpu'`` is\n        allowed.\n    kind : str or tuple of str, optional\n        The kind of data types to return. If ``None``, all data types are\n        returned. If a string, only data types of that kind are returned.\n        If a tuple, a dictionary containing the union of the given kinds\n        is returned. The following kinds are supported:\n\n        - ``'bool'``: boolean data types (i.e., ``bool``).\n        - ``'signed integer'``: signed integer data types (i.e., ``int8``,\n          ``int16``, ``int32``, ``int64``).\n        - ``'unsigned integer'``: unsigned integer data types (i.e.,\n          ``uint8``, ``uint16``, ``uint32``, ``uint64``).\n        - ``'integral'``: integer data types. Shorthand for ``('signed\n          integer', 'unsigned integer')``.\n        - ``'real floating'``: real-valued floating-point data types\n          (i.e., ``float32``, ``float64``).\n        - ``'complex floating'``: complex floating-point data types (i.e.,\n          ``complex64``, ``complex128``).\n        - ``'numeric'``: numeric data types. Shorthand for ``('integral',\n          'real floating', 'complex floating')``.\n\n    Returns\n    -------\n    dtypes : dict\n        A dictionary mapping the names of data types to the corresponding\n        NumPy data types.\n\n    See Also\n    --------\n    __array_namespace_info__.capabilities,\n    __array_namespace_info__.default_device,\n    __array_namespace_info__.default_dtypes,\n    __array_namespace_info__.devices\n\n    Examples\n    --------\n    >>> info = np.__array_namespace_info__()\n    >>> info.dtypes(kind='signed integer')\n    {'int8': numpy.int8,\n     'int16': numpy.int16,\n     'int32': numpy.int32,\n     'int64': numpy.int64}\n\n    \"\"\"\n    if device not in [\"cpu\", None]:\n        raise ValueError(\n            'Device not understood. Only \"cpu\" is allowed, but received:'\n            f' {device}'\n        )\n    if kind is None:\n        return {\n            \"bool\": dtype(bool),\n            \"int8\": dtype(int8),\n            \"int16\": dtype(int16),\n            \"int32\": dtype(int32),\n            \"int64\": dtype(int64),\n            \"uint8\": dtype(uint8),\n            \"uint16\": dtype(uint16),\n            \"uint32\": dtype(uint32),\n            \"uint64\": dtype(uint64),\n            \"float32\": dtype(float32),\n            \"float64\": dtype(float64),\n            \"complex64\": dtype(complex64),\n            \"complex128\": dtype(complex128),\n        }\n    if kind == \"bool\":\n        return {\"bool\": dtype(bool)}\n    if kind == \"signed integer\":\n        return {\n            \"int8\": dtype(int8),\n            \"int16\": dtype(int16),\n            \"int32\": dtype(int32),\n            \"int64\": dtype(int64),\n        }\n    if kind == \"unsigned integer\":\n        return {\n            \"uint8\": dtype(uint8),\n            \"uint16\": dtype(uint16),\n            \"uint32\": dtype(uint32),\n            \"uint64\": dtype(uint64),\n        }\n    if kind == \"integral\":\n        return {\n            \"int8\": dtype(int8),\n            \"int16\": dtype(int16),\n            \"int32\": dtype(int32),\n            \"int64\": dtype(int64),\n            \"uint8\": dtype(uint8),\n            \"uint16\": dtype(uint16),\n            \"uint32\": dtype(uint32),\n            \"uint64\": dtype(uint64),\n        }\n    if kind == \"real floating\":\n        return {\n            \"float32\": dtype(float32),\n            \"float64\": dtype(float64),\n        }\n    if kind == \"complex floating\":\n        return {\n            \"complex64\": dtype(complex64),\n            \"complex128\": dtype(complex128),\n        }\n    if kind == \"numeric\":\n        return {\n            \"int8\": dtype(int8),\n            \"int16\": dtype(int16),\n            \"int32\": dtype(int32),\n            \"int64\": dtype(int64),\n            \"uint8\": dtype(uint8),\n            \"uint16\": dtype(uint16),\n            \"uint32\": dtype(uint32),\n            \"uint64\": dtype(uint64),\n            \"float32\": dtype(float32),\n            \"float64\": dtype(float64),\n            \"complex64\": dtype(complex64),\n            \"complex128\": dtype(complex128),\n        }\n    if isinstance(kind, tuple):\n        res: dict[str, DType] = {}\n        for k in kind:\n            res.update(self.dtypes(kind=k))\n        return res\n    raise ValueError(f\"unsupported kind: {kind!r}\")"
}