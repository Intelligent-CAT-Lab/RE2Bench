{
    "sympy.sympy.external.ntheory.bit_scan1": "def bit_scan1(x, n=0):\n    if not x:\n        return\n    x = abs(x >> n)\n    low_byte = x & 0xFF\n    if low_byte:\n        return _small_trailing[low_byte] + n\n\n    t = 8 + n\n    x >>= 8\n    # 2**m is quick for z up through 2**30\n    z = x.bit_length() - 1\n    if x == 1 << z:\n        return z + t\n\n    if z < 300:\n        # fixed 8-byte reduction\n        while not x & 0xFF:\n            x >>= 8\n            t += 8\n    else:\n        # binary reduction important when there might be a large\n        # number of trailing 0s\n        p = z >> 1\n        while not x & 0xFF:\n            while x & ((1 << p) - 1):\n                p >>= 1\n            x >>= p\n            t += p\n    return t + _small_trailing[x & 0xFF]",
    "sympy.sympy.ntheory.primetest._test": "def _test(n, base, s, t):\n    \"\"\"Miller-Rabin strong pseudoprime test for one base.\n    Return False if n is definitely composite, True if n is\n    probably prime, with a probability greater than 3/4.\n\n    \"\"\"\n    # do the Fermat test\n    b = pow(base, t, n)\n    if b == 1 or b == n - 1:\n        return True\n    for _ in range(s - 1):\n        b = pow(b, 2, n)\n        if b == n - 1:\n            return True\n        # see I. Niven et al. \"An Introduction to Theory of Numbers\", page 78\n        if b == 1:\n            return False\n    return False",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}