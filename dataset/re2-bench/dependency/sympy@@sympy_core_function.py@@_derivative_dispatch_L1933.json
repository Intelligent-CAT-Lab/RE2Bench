{
    "sympy.sympy.core.function.__new__": "def __new__(cls, expr, *variables, **kwargs):\n    expr = sympify(expr)\n    if not isinstance(expr, Basic):\n        raise TypeError(f\"Cannot represent derivative of {type(expr)}\")\n    symbols_or_none = getattr(expr, \"free_symbols\", None)\n    has_symbol_set = isinstance(symbols_or_none, set)\n\n    if not has_symbol_set:\n        raise ValueError(filldedent('''\n            Since there are no variables in the expression %s,\n            it cannot be differentiated.''' % expr))\n\n    # determine value for variables if it wasn't given\n    if not variables:\n        variables = expr.free_symbols\n        if len(variables) != 1:\n            if expr.is_number:\n                return S.Zero\n            if len(variables) == 0:\n                raise ValueError(filldedent('''\n                    Since there are no variables in the expression,\n                    the variable(s) of differentiation must be supplied\n                    to differentiate %s''' % expr))\n            else:\n                raise ValueError(filldedent('''\n                    Since there is more than one variable in the\n                    expression, the variable(s) of differentiation\n                    must be supplied to differentiate %s''' % expr))\n\n    # Split the list of variables into a list of the variables we are diff\n    # wrt, where each element of the list has the form (s, count) where\n    # s is the entity to diff wrt and count is the order of the\n    # derivative.\n    variable_count = []\n    array_likes = (tuple, list, Tuple)\n\n    from sympy.tensor.array import Array, NDimArray\n\n    for i, v in enumerate(variables):\n        if isinstance(v, UndefinedFunction):\n            raise TypeError(\n                \"cannot differentiate wrt \"\n                \"UndefinedFunction: %s\" % v)\n\n        if isinstance(v, array_likes):\n            if len(v) == 0:\n                # Ignore empty tuples: Derivative(expr, ... , (), ... )\n                continue\n            if isinstance(v[0], array_likes):\n                # Derive by array: Derivative(expr, ... , [[x, y, z]], ... )\n                if len(v) == 1:\n                    v = Array(v[0])\n                    count = 1\n                else:\n                    v, count = v\n                    v = Array(v)\n            else:\n                v, count = v\n            if count == 0:\n                continue\n            variable_count.append(Tuple(v, count))\n            continue\n\n        v = sympify(v)\n        if isinstance(v, Integer):\n            if i == 0:\n                raise ValueError(\"First variable cannot be a number: %i\" % v)\n            count = v\n            prev, prevcount = variable_count[-1]\n            if prevcount != 1:\n                raise TypeError(\"tuple {} followed by number {}\".format((prev, prevcount), v))\n            if count == 0:\n                variable_count.pop()\n            else:\n                variable_count[-1] = Tuple(prev, count)\n        else:\n            count = 1\n            variable_count.append(Tuple(v, count))\n\n    # light evaluation of contiguous, identical\n    # items: (x, 1), (x, 1) -> (x, 2)\n    merged = []\n    for t in variable_count:\n        v, c = t\n        if c.is_negative:\n            raise ValueError(\n                'order of differentiation must be nonnegative')\n        if merged and merged[-1][0] == v:\n            c += merged[-1][1]\n            if not c:\n                merged.pop()\n            else:\n                merged[-1] = Tuple(v, c)\n        else:\n            merged.append(t)\n    variable_count = merged\n\n    # sanity check of variables of differentation; we waited\n    # until the counts were computed since some variables may\n    # have been removed because the count was 0\n    for v, c in variable_count:\n        # v must have _diff_wrt True\n        if not v._diff_wrt:\n            __ = ''  # filler to make error message neater\n            raise ValueError(filldedent('''\n                Can't calculate derivative wrt %s.%s''' % (v,\n                __)))\n\n    # We make a special case for 0th derivative, because there is no\n    # good way to unambiguously print this.\n    if len(variable_count) == 0:\n        return expr\n\n    evaluate = kwargs.get('evaluate', False)\n\n    if evaluate:\n        if isinstance(expr, Derivative):\n            expr = expr.canonical\n        variable_count = [\n            (v.canonical if isinstance(v, Derivative) else v, c)\n            for v, c in variable_count]\n\n        # Look for a quick exit if there are symbols that don't appear in\n        # expression at all. Note, this cannot check non-symbols like\n        # Derivatives as those can be created by intermediate\n        # derivatives.\n        zero = False\n        free = expr.free_symbols\n        from sympy.matrices.expressions.matexpr import MatrixExpr, MatrixElement\n\n        for v, c in variable_count:\n            vfree = v.free_symbols\n            if c.is_positive and vfree:\n                if isinstance(v, AppliedUndef):\n                    # these match exactly since\n                    # x.diff(f(x)) == g(x).diff(f(x)) == 0\n                    # and are not created by differentiation\n                    D = Dummy()\n                    if not expr.xreplace({v: D}).has(D):\n                        zero = True\n                        break\n                elif isinstance(v, MatrixExpr):\n                    zero = False\n                    break\n                elif isinstance(v, MatrixElement):\n                    zero = False\n                    break\n                elif isinstance(v, Symbol) and v not in free:\n                    zero = True\n                    break\n                else:\n                    if not free & vfree:\n                        # e.g. v is IndexedBase or Matrix\n                        zero = True\n                        break\n        if zero:\n            return cls._get_zero_with_shape_like(expr)\n\n        # make the order of symbols canonical\n        #TODO: check if assumption of discontinuous derivatives exist\n        variable_count = cls._sort_variable_count(variable_count)\n\n    # denest\n    if isinstance(expr, Derivative):\n        variable_count = list(expr.variable_count) + variable_count\n        expr = expr.expr\n        return _derivative_dispatch(expr, *variable_count, **kwargs)\n\n    # we return here if evaluate is False or if there is no\n    # _eval_derivative method\n    if not evaluate or not hasattr(expr, '_eval_derivative'):\n        # return an unevaluated Derivative\n        if evaluate and variable_count == [(expr, 1)] and expr.is_scalar:\n            # special hack providing evaluation for classes\n            # that have defined is_scalar=True but have no\n            # _eval_derivative defined\n            return S.One\n        return Expr.__new__(cls, expr, *variable_count)\n\n    # evaluate the derivative by calling _eval_derivative method\n    # of expr for each variable\n    # -------------------------------------------------------------\n    nderivs = 0  # how many derivatives were performed\n    unhandled = []\n    from sympy.matrices.matrixbase import MatrixBase\n    for i, (v, count) in enumerate(variable_count):\n\n        old_expr = expr\n        old_v = None\n\n        is_symbol = v.is_symbol or isinstance(v,\n            (Iterable, Tuple, MatrixBase, NDimArray))\n\n        if not is_symbol:\n            old_v = v\n            v = Dummy('xi')\n            expr = expr.xreplace({old_v: v})\n            # Derivatives and UndefinedFunctions are independent\n            # of all others\n            clashing = not (isinstance(old_v, (Derivative, AppliedUndef)))\n            if v not in expr.free_symbols and not clashing:\n                return expr.diff(v)  # expr's version of 0\n            if not old_v.is_scalar and not hasattr(\n                    old_v, '_eval_derivative'):\n                # special hack providing evaluation for classes\n                # that have defined is_scalar=True but have no\n                # _eval_derivative defined\n                expr *= old_v.diff(old_v)\n\n        obj = cls._dispatch_eval_derivative_n_times(expr, v, count)\n        if obj is not None and obj.is_zero:\n            return obj\n\n        nderivs += count\n\n        if old_v is not None:\n            if obj is not None:\n                # remove the dummy that was used\n                obj = obj.subs(v, old_v)\n            # restore expr\n            expr = old_expr\n\n        if obj is None:\n            # we've already checked for quick-exit conditions\n            # that give 0 so the remaining variables\n            # are contained in the expression but the expression\n            # did not compute a derivative so we stop taking\n            # derivatives\n            unhandled = variable_count[i:]\n            break\n\n        expr = obj\n\n    # what we have so far can be made canonical\n    expr = expr.replace(\n        lambda x: isinstance(x, Derivative),\n        lambda x: x.canonical)\n\n    if unhandled:\n        if isinstance(expr, Derivative):\n            unhandled = list(expr.variable_count) + unhandled\n            expr = expr.expr\n        expr = Expr.__new__(cls, expr, *unhandled)\n\n    if (nderivs > 1) == True and kwargs.get('simplify', True):\n        from .exprtools import factor_terms\n        from sympy.simplify.simplify import signsimp\n        expr = factor_terms(signsimp(expr))\n    return expr",
    "sympy.sympy.core.function.<genexpr>": "if isinstance(expr, array_types) or any(isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables):\n    from sympy.tensor.array.array_derivatives import ArrayDerivative\n    return ArrayDerivative(expr, *variables, **kwargs)\n",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.tensor.array.array_derivatives.__new__": "def __new__(cls, expr, *variables, **kwargs):\n    obj = super().__new__(cls, expr, *variables, **kwargs)\n    if isinstance(obj, ArrayDerivative):\n        obj._shape = obj._get_shape()\n    return obj",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}