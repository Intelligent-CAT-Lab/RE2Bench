{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.operations._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    \"\"\"Create new instance of own class with args exactly as provided by\n    caller but returning the self class identity if args is empty.\n\n    Examples\n    ========\n\n       This is handy when we want to optimize things, e.g.\n\n           >>> from sympy import Mul, S\n           >>> from sympy.abc import x, y\n           >>> e = Mul(3, x, y)\n           >>> e.args\n           (3, x, y)\n           >>> Mul(*e.args[1:])\n           x*y\n           >>> e._new_rawargs(*e.args[1:])  # the same as above, but faster\n           x*y\n\n       Note: use this with caution. There is no checking of arguments at\n       all. This is best used when you are rebuilding an Add or Mul after\n       simply removing one or more args. If, for example, modifications,\n       result in extra 1s being inserted they will show up in the result:\n\n           >>> m = (x*y)._new_rawargs(S.One, x); m\n           1*x\n           >>> m == x\n           False\n           >>> m.is_Mul\n           True\n\n       Another issue to be aware of is that the commutativity of the result\n       is based on the commutativity of self. If you are rebuilding the\n       terms that came from a commutative object then there will be no\n       problem, but if self was non-commutative then what you are\n       rebuilding may now be commutative.\n\n       Although this routine tries to do as little as possible with the\n       input, getting the commutativity right is important, so this level\n       of safety is enforced: commutativity will always be recomputed if\n       self is non-commutative and kwarg `reeval=False` has not been\n       passed.\n    \"\"\"\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}