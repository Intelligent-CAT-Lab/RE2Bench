{
    "sympy.sympy.polys.densearith.dup_sub": "def dup_sub(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Subtract dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sub(x**2 - 1, x - 2)\n    x**2 - x + 1\n\n    \"\"\"\n    if not f:\n        return dup_neg(g, K)\n    if not g:\n        return f\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    if df == dg:\n        return dup_strip([ a - b for a, b in zip(f, g) ], K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = dup_neg(g[:k], K), g[k:]\n\n        return h + [ a - b for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densearith.dup_mul": "def dup_mul(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul(x - 2, x + 2)\n    x**2 - 4\n\n    \"\"\"\n    if f == g:\n        return dup_sqr(f, K)\n\n    if not (f and g):\n        return []\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    n = max(df, dg) + 1\n\n    if n < 100 or not K.is_Exact:\n        h: list[Er] = []\n\n        for i in range(0, df + dg + 1):\n            coeff = K.zero\n\n            for j in range(max(0, i - dg), min(df, i) + 1):\n                coeff += f[j]*g[i - j]\n\n            h.append(coeff)\n\n        return dup_strip(h, K)\n    else:\n        # Use Karatsuba's algorithm (divide and conquer), see e.g.:\n        # Joris van der Hoeven, Relax But Don't Be Too Lazy,\n        # J. Symbolic Computation, 11 (2002), section 3.1.1.\n        n2 = n//2\n\n        fl, gl = dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K)\n\n        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)\n        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)\n\n        lo, hi = dup_mul(fl, gl, K), dup_mul(fh, gh, K)\n\n        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)\n        mid = dup_sub(mid, dup_add(lo, hi, K), K)\n\n        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K),\n                       dup_lshift(hi, 2*n2, K), K)"
}