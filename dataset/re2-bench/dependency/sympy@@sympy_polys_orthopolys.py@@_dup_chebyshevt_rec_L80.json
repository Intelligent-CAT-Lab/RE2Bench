{
    "sympy.sympy.polys.densearith.dup_mul_ground": "def dup_mul_ground(f: dup[Er], c: Er, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul_ground(x**2 + 2*x - 1, ZZ(3))\n    3*x**2 + 6*x - 3\n\n    \"\"\"\n    if not c or not f:\n        return []\n    else:\n        return [ cf * c for cf in f ]",
    "sympy.sympy.polys.densearith.dup_lshift": "def dup_lshift(f: dup[Er], n: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Efficiently multiply ``f`` by ``x**n`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_lshift(x**2 + 1, 2)\n    x**4 + x**2\n\n    \"\"\"\n    if not f:\n        return f\n    else:\n        return f + [K.zero]*n",
    "sympy.sympy.polys.densearith.dup_sub": "def dup_sub(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Subtract dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sub(x**2 - 1, x - 2)\n    x**2 - x + 1\n\n    \"\"\"\n    if not f:\n        return dup_neg(g, K)\n    if not g:\n        return f\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    if df == dg:\n        return dup_strip([ a - b for a, b in zip(f, g) ], K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = dup_neg(g[:k], K), g[k:]\n\n        return h + [ a - b for a, b in zip(f, g) ]",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)"
}