{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.exprtools.as_expr": "def as_expr(self):  # Factors\n    \"\"\"Return the underlying expression.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y\n    >>> Factors((x*y**2).as_powers_dict()).as_expr()\n    x*y**2\n\n    \"\"\"\n\n    args = []\n    for factor, exp in self.factors.items():\n        if exp != 1:\n            if isinstance(exp, Integer):\n                b, e = factor.as_base_exp()\n                e = _keep_coeff(exp, e)\n                args.append(b**e)\n            else:\n                args.append(factor**exp)\n        else:\n            args.append(factor)\n    return Mul(*args)",
    "sympy.sympy.core.exprtools.normal": "def normal(self, other):\n    \"\"\"Return ``self`` and ``other`` with ``gcd`` removed from each.\n    The only differences between this and method ``div`` is that this\n    is 1) optimized for the case when there are few factors in common and\n    2) this does not raise an error if ``other`` is zero.\n\n    See Also\n    ========\n    div\n\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return (Factors(), Factors(S.Zero))\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n\n    self_factors = dict(self.factors)\n    other_factors = dict(other.factors)\n\n    for factor, self_exp in self.factors.items():\n        try:\n            other_exp = other.factors[factor]\n        except KeyError:\n            continue\n\n        exp = self_exp - other_exp\n\n        if not exp:\n            del self_factors[factor]\n            del other_factors[factor]\n        elif _isnumber(exp):\n            if exp > 0:\n                self_factors[factor] = exp\n                del other_factors[factor]\n            else:\n                del self_factors[factor]\n                other_factors[factor] = -exp\n        else:\n            r = self_exp.extract_additively(other_exp)\n            if r is not None:\n                if r:\n                    self_factors[factor] = r\n                    del other_factors[factor]\n                else:  # should be handled already\n                    del self_factors[factor]\n                    del other_factors[factor]\n            else:\n                sc, sa = self_exp.as_coeff_Add()\n                if sc:\n                    oc, oa = other_exp.as_coeff_Add()\n                    diff = sc - oc\n                    if diff > 0:\n                        self_factors[factor] -= oc\n                        other_exp = oa\n                    elif diff < 0:\n                        self_factors[factor] -= sc\n                        other_factors[factor] -= sc\n                        other_exp = oa - diff\n                    else:\n                        self_factors[factor] = sa\n                        other_exp = oa\n                if other_exp:\n                    other_factors[factor] = other_exp\n                else:\n                    del other_factors[factor]\n\n    return Factors(self_factors), Factors(other_factors)",
    "sympy.sympy.core.exprtools.quo": "def quo(self, other):  # Factors\n    \"\"\"Return numerator Factor of ``self / other``.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.quo(b)  # same as a/b\n    Factors({y: 1})\n    \"\"\"\n    return self.div(other)[0]",
    "sympy.sympy.core.exprtools.gcd": "def gcd(self, other):  # Factors\n    \"\"\"Return Factors of ``gcd(self, other)``. The keys are\n    the intersection of factors with the minimum exponent for\n    each factor.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.gcd(b)\n    Factors({x: 1, y: 1})\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return Factors(self.factors)\n\n    factors = {}\n\n    for factor, exp in self.factors.items():\n        factor, exp = sympify(factor), sympify(exp)\n        if factor in other.factors:\n            lt = (exp - other.factors[factor]).is_negative\n            if lt == True:\n                factors[factor] = exp\n            elif lt == False:\n                factors[factor] = other.factors[factor]\n\n    return Factors(factors)",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.simplify.fu.<listcomp>": "a, b = [i.as_expr() for i in (ua, ub)]\n"
}