{
    "matplotlib.lib.matplotlib.bezier.get_cos_sin": "def get_cos_sin(x0, y0, x1, y1):\n    dx, dy = x1 - x0, y1 - y0\n    d = (dx * dx + dy * dy) ** .5\n    # Account for divide by zero\n    if d == 0:\n        return 0.0, 0.0\n    return dx / d, dy / d",
    "matplotlib.lib.matplotlib.bezier.get_normal_points": "def get_normal_points(cx, cy, cos_t, sin_t, length):\n    \"\"\"\n    For a line passing through (*cx*, *cy*) and having an angle *t*, return\n    locations of the two points located along its perpendicular line at the\n    distance of *length*.\n    \"\"\"\n\n    if length == 0.:\n        return cx, cy, cx, cy\n\n    cos_t1, sin_t1 = sin_t, -cos_t\n    cos_t2, sin_t2 = -sin_t, cos_t\n\n    x1, y1 = length * cos_t1 + cx, length * sin_t1 + cy\n    x2, y2 = length * cos_t2 + cx, length * sin_t2 + cy\n\n    return x1, y1, x2, y2",
    "matplotlib.lib.matplotlib.transforms.transform": "def transform(self, values):\n    # docstring inherited\n    return self.transform_affine(values)",
    "matplotlib.lib.matplotlib.transforms.__init__": "def __init__(self, matrix=None, **kwargs):\n    \"\"\"\n    Initialize an Affine transform from a 3x3 numpy float array::\n\n      a c e\n      b d f\n      0 0 1\n\n    If *matrix* is None, initialize with the identity transform.\n    \"\"\"\n    super().__init__(**kwargs)\n    if matrix is None:\n        # A bit faster than np.identity(3).\n        matrix = IdentityTransform._mtx\n    self._mtx = matrix.copy()\n    self._invalid = 0",
    "matplotlib.lib.matplotlib.transforms.rotate_deg_around": "def rotate_deg_around(self, x, y, degrees):\n    \"\"\"\n    Add a rotation (in degrees) around the point (x, y) in place.\n\n    Returns *self*, so this method can easily be chained with more\n    calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n    and :meth:`scale`.\n    \"\"\"\n    # Cast to float to avoid wraparound issues with uint8's\n    x, y = float(x), float(y)\n    return self.translate(-x, -y).rotate_deg(degrees).translate(x, y)"
}