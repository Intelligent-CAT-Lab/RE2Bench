{
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.external.ntheory.bit_scan1": "def bit_scan1(x, n=0):\n    if not x:\n        return\n    x = abs(x >> n)\n    low_byte = x & 0xFF\n    if low_byte:\n        return _small_trailing[low_byte] + n\n\n    t = 8 + n\n    x >>= 8\n    # 2**m is quick for z up through 2**30\n    z = x.bit_length() - 1\n    if x == 1 << z:\n        return z + t\n\n    if z < 300:\n        # fixed 8-byte reduction\n        while not x & 0xFF:\n            x >>= 8\n            t += 8\n    else:\n        # binary reduction important when there might be a large\n        # number of trailing 0s\n        p = z >> 1\n        while not x & 0xFF:\n            while x & ((1 << p) - 1):\n                p >>= 1\n            x >>= p\n            t += p\n    return t + _small_trailing[x & 0xFF]",
    "sympy.sympy.external.ntheory.remove": "def remove(x, f):\n    if f < 2:\n        raise ValueError(\"factor must be > 1\")\n    if x == 0:\n        return 0, 0\n    if f == 2:\n        b = bit_scan1(x)\n        return x >> b, b\n    m = 0\n    y, rem = divmod(x, f)\n    while not rem:\n        x = y\n        m += 1\n        if m > 5:\n            pow_list = [f**2]\n            while pow_list:\n                _f = pow_list[-1]\n                y, rem = divmod(x, _f)\n                if not rem:\n                    m += 1 << len(pow_list)\n                    x = y\n                    pow_list.append(_f**2)\n                else:\n                    pow_list.pop()\n        y, rem = divmod(x, f)\n    return x, m",
    "sympy.sympy.ntheory.factor_.done": "def done(n, d):\n    \"\"\"return n, d if the sqrt(n) was not reached yet, else\n       n, 0 indicating that factoring is done.\n    \"\"\"\n    if d*d <= n:\n        return n, d\n    return n, 0"
}