{
    "sympy.sympy.core.add.<listcomp>": "l = [f for f in self.args if not (f.is_even is True)]\n",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.operations._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    \"\"\"Create new instance of own class with args exactly as provided by\n    caller but returning the self class identity if args is empty.\n\n    Examples\n    ========\n\n       This is handy when we want to optimize things, e.g.\n\n           >>> from sympy import Mul, S\n           >>> from sympy.abc import x, y\n           >>> e = Mul(3, x, y)\n           >>> e.args\n           (3, x, y)\n           >>> Mul(*e.args[1:])\n           x*y\n           >>> e._new_rawargs(*e.args[1:])  # the same as above, but faster\n           x*y\n\n       Note: use this with caution. There is no checking of arguments at\n       all. This is best used when you are rebuilding an Add or Mul after\n       simply removing one or more args. If, for example, modifications,\n       result in extra 1s being inserted they will show up in the result:\n\n           >>> m = (x*y)._new_rawargs(S.One, x); m\n           1*x\n           >>> m == x\n           False\n           >>> m.is_Mul\n           True\n\n       Another issue to be aware of is that the commutativity of the result\n       is based on the commutativity of self. If you are rebuilding the\n       terms that came from a commutative object then there will be no\n       problem, but if self was non-commutative then what you are\n       rebuilding may now be commutative.\n\n       Although this routine tries to do as little as possible with the\n       input, getting the commutativity right is important, so this level\n       of safety is enforced: commutativity will always be recomputed if\n       self is non-commutative and kwarg `reeval=False` has not been\n       passed.\n    \"\"\"\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)"
}