{
    "sympy.sympy.assumptions.wrapper.__new__": "def __new__(cls, expr, assumptions=None):\n    if assumptions is None:\n        return expr\n    obj = super().__new__(cls, expr, _sympify(assumptions))\n    obj.expr = expr\n    obj.assumptions = assumptions\n    return obj",
    "sympy.sympy.assumptions.wrapper.is_extended_nonnegative": "def is_extended_nonnegative(obj, assumptions=None):\n    if assumptions is None:\n        return obj.is_extended_nonnegative\n    return ask(Q.extended_nonnegative(obj), assumptions)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity or other == float('-inf')",
    "sympy.sympy.core.numbers.__float__": "def __float__(self):\n    return mlib.to_float(self._as_mpf_val(53))",
    "sympy.sympy.core.relational._n2": "def _n2(a, b):\n    \"\"\"Return (a - b).evalf(2) if a and b are comparable, else None.\n    This should only be used when a and b are already sympified.\n    \"\"\"\n    # /!\\ it is very important (see issue 8245) not to\n    # use a re-evaluated number in the calculation of dif\n    if a.is_comparable and b.is_comparable:\n        dif = (a - b).evalf(2)\n        if dif.is_comparable:\n            return dif",
    "sympy.sympy.multipledispatch.dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple([type(arg) for arg in args])\n    try:\n        func = self._cache[types]\n    except KeyError:\n        func = self.dispatch(*types)\n        if not func:\n            raise NotImplementedError(\n                'Could not find signature for %s: <%s>' %\n                (self.name, str_signature(types)))\n        self._cache[types] = func\n    try:\n        return func(*args, **kwargs)\n\n    except MDNotImplementedError:\n        funcs = self.dispatch_iter(*types)\n        next(funcs)  # burn first\n        for func in funcs:\n            try:\n                return func(*args, **kwargs)\n            except MDNotImplementedError:\n                pass\n        raise NotImplementedError(\"Matching functions for \"\n                                  \"%s: <%s> found, but none completed successfully\"\n                                  % (self.name, str_signature(types)))"
}