{
    "sympy.sympy.assumptions.sathandlers.__getitem__": "def __getitem__(self, key):\n    ret1 = self.singlefacts[key]\n    for k in self.singlefacts:\n        if issubclass(key, k):\n            ret1 |= self.singlefacts[k]\n\n    ret2 = self.multifacts[key]\n    for k in self.multifacts:\n        if issubclass(key, k):\n            ret2 |= self.multifacts[k]\n\n    return ret1, ret2",
    "sympy.sympy.assumptions.sathandlers.<genexpr>": "ret.update(h(expr) for h in handlers1)\n",
    "sympy.sympy.assumptions.sathandlers._": "@class_fact_registry.multiregister(Number, NumberSymbol, ImaginaryUnit)\ndef _(expr):\n    ret = []\n    for p, getter in _old_assump_getters.items():\n        pred = p(expr)\n        prop = getter(expr)\n        if prop is not None:\n            ret.append(Equivalent(pred, prop))\n    return ret",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h"
}