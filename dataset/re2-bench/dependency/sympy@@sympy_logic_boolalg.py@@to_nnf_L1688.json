{
    "sympy.sympy.logic.boolalg.to_nnf": "def to_nnf(self, simplify=True, form=None):\n    if is_literal(self):\n        return self\n\n    expr = self.args[0]\n\n    func, args = expr.func, expr.args\n\n    if func == And:\n        return Or._to_nnf(*[Not(arg) for arg in args], simplify=simplify, form=form)\n\n    if func == Or:\n        return And._to_nnf(*[Not(arg) for arg in args], simplify=simplify, form=form)\n\n    if func == Implies:\n        a, b = args\n        return And._to_nnf(a, Not(b), simplify=simplify, form=form)\n\n    if func == Equivalent:\n        return And._to_nnf(Or(*args), Or(*[Not(arg) for arg in args]),\n                           simplify=simplify, form=form)\n\n    if func == Xor:\n        result = []\n        for i in range(1, len(args)+1, 2):\n            for neg in combinations(args, i):\n                clause = [Not(s) if s in neg else s for s in args]\n                result.append(Or(*clause))\n        return And._to_nnf(*result, simplify=simplify, form=form)\n\n    if func == ITE:\n        a, b, c = args\n        return And._to_nnf(Or(a, Not(c)), Or(Not(a), Not(b)), simplify=simplify, form=form)\n\n    raise ValueError(\"Illegal operator %s in expression\" % func)",
    "sympy.sympy.logic.boolalg.is_nnf": "def is_nnf(expr, simplified=True):\n    \"\"\"\n    Checks if ``expr`` is in Negation Normal Form (NNF).\n\n    A logical expression is in NNF if it\n    contains only :py:class:`~.And`, :py:class:`~.Or` and :py:class:`~.Not`,\n    and :py:class:`~.Not` is applied only to literals.\n    If ``simplified`` is ``True``, checks if result contains no redundant clauses.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import A, B, C\n    >>> from sympy.logic.boolalg import Not, is_nnf\n    >>> is_nnf(A & B | ~C)\n    True\n    >>> is_nnf((A | ~A) & (B | C))\n    False\n    >>> is_nnf((A | ~A) & (B | C), False)\n    True\n    >>> is_nnf(Not(A & B) | C)\n    False\n    >>> is_nnf((A >> B) & (B >> A))\n    False\n\n    \"\"\"\n\n    expr = sympify(expr)\n    if is_literal(expr):\n        return True\n\n    stack = [expr]\n\n    while stack:\n        expr = stack.pop()\n        if expr.func in (And, Or):\n            if simplified:\n                args = expr.args\n                for arg in args:\n                    if Not(arg) in args:\n                        return False\n            stack.extend(expr.args)\n\n        elif not is_literal(expr):\n            return False\n\n    return True"
}