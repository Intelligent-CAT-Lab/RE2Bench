{
    "matplotlib.lib.matplotlib.bezier.find_bezier_t_intersecting_with_closedpath": "def find_bezier_t_intersecting_with_closedpath(\n        bezier_point_at_t, inside_closedpath, t0=0., t1=1., tolerance=0.01):\n    \"\"\"\n    Find the intersection of the B\u00e9zier curve with a closed path.\n\n    The intersection point *t* is approximated by two parameters *t0*, *t1*\n    such that *t0* <= *t* <= *t1*.\n\n    Search starts from *t0* and *t1* and uses a simple bisecting algorithm\n    therefore one of the end points must be inside the path while the other\n    doesn't. The search stops when the distance of the points parametrized by\n    *t0* and *t1* gets smaller than the given *tolerance*.\n\n    Parameters\n    ----------\n    bezier_point_at_t : callable\n        A function returning x, y coordinates of the B\u00e9zier at parameter *t*.\n        It must have the signature::\n\n            bezier_point_at_t(t: float) -> tuple[float, float]\n\n    inside_closedpath : callable\n        A function returning True if a given point (x, y) is inside the\n        closed path. It must have the signature::\n\n            inside_closedpath(point: tuple[float, float]) -> bool\n\n    t0, t1 : float\n        Start parameters for the search.\n\n    tolerance : float\n        Maximal allowed distance between the final points.\n\n    Returns\n    -------\n    t0, t1 : float\n        The B\u00e9zier path parameters.\n    \"\"\"\n    start = bezier_point_at_t(t0)\n    end = bezier_point_at_t(t1)\n\n    start_inside = inside_closedpath(start)\n    end_inside = inside_closedpath(end)\n\n    if start_inside == end_inside and start != end:\n        raise NonIntersectingPathException(\n            \"Both points are on the same side of the closed path\")\n\n    while True:\n\n        # return if the distance is smaller than the tolerance\n        if np.hypot(start[0] - end[0], start[1] - end[1]) < tolerance:\n            return t0, t1\n\n        # calculate the middle point\n        middle_t = 0.5 * (t0 + t1)\n        middle = bezier_point_at_t(middle_t)\n        middle_inside = inside_closedpath(middle)\n\n        if start_inside ^ middle_inside:\n            t1 = middle_t\n            if end == middle:\n                # Edge case where infinite loop is possible\n                # Caused by large numbers relative to tolerance\n                return t0, t1\n            end = middle\n        else:\n            t0 = middle_t\n            if start == middle:\n                # Edge case where infinite loop is possible\n                # Caused by large numbers relative to tolerance\n                return t0, t1\n            start = middle\n            start_inside = middle_inside",
    "matplotlib.lib.matplotlib.bezier.__init__": "def __init__(self, control_points):\n    self._cpoints = np.asarray(control_points)\n    self._N, self._d = self._cpoints.shape\n    self._orders = np.arange(self._N)\n    coeff = [math.factorial(self._N - 1)\n             // (math.factorial(i) * math.factorial(self._N - 1 - i))\n             for i in range(self._N)]\n    self._px = (self._cpoints.T * coeff).T",
    "matplotlib.lib.matplotlib.bezier.split_de_casteljau": "def split_de_casteljau(beta, t):\n    \"\"\"\n    Split a B\u00e9zier segment defined by its control points *beta* into two\n    separate segments divided at *t* and return their control points.\n    \"\"\"\n    beta = np.asarray(beta)\n    beta_list = [beta]\n    while True:\n        beta = _de_casteljau1(beta, t)\n        beta_list.append(beta)\n        if len(beta) == 1:\n            break\n    left_beta = [beta[0] for beta in beta_list]\n    right_beta = [beta[-1] for beta in reversed(beta_list)]\n\n    return left_beta, right_beta"
}