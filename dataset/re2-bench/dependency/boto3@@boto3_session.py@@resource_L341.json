{
    "boto3.boto3.dynamodb.transform.__init__": "def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    # Apply handler that creates a copy of the user provided dynamodb\n    # item such that it can be modified.\n    self.meta.client.meta.events.register(\n        'provide-client-params.dynamodb',\n        copy_dynamodb_params,\n        unique_id='dynamodb-create-params-copy',\n    )\n\n    self._injector = TransformationInjector()\n    # Apply the handler that generates condition expressions including\n    # placeholders.\n    self.meta.client.meta.events.register(\n        'before-parameter-build.dynamodb',\n        self._injector.inject_condition_expressions,\n        unique_id='dynamodb-condition-expression',\n    )\n\n    # Apply the handler that serializes the request from python\n    # types to dynamodb types.\n    self.meta.client.meta.events.register(\n        'before-parameter-build.dynamodb',\n        self._injector.inject_attribute_value_input,\n        unique_id='dynamodb-attr-value-input',\n    )\n\n    # Apply the handler that deserializes the response from dynamodb\n    # types to python types.\n    self.meta.client.meta.events.register(\n        'after-call.dynamodb',\n        self._injector.inject_attribute_value_output,\n        unique_id='dynamodb-attr-value-output',\n    )\n\n    # Apply the documentation customizations to account for\n    # the transformations.\n    attr_value_shape_docs = DocumentModifiedShape(\n        'AttributeValue',\n        new_type='valid DynamoDB type',\n        new_description=(\n            '- The value of the attribute. The valid value types are '\n            'listed in the '\n            ':ref:`DynamoDB Reference Guide<ref_valid_dynamodb_types>`.'\n        ),\n        new_example_value=(\n            '\\'string\\'|123|Binary(b\\'bytes\\')|True|None|set([\\'string\\'])'\n            '|set([123])|set([Binary(b\\'bytes\\')])|[]|{}'\n        ),\n    )\n\n    key_expression_shape_docs = DocumentModifiedShape(\n        'KeyExpression',\n        new_type=(\n            'condition from :py:class:`boto3.dynamodb.conditions.Key` '\n            'method'\n        ),\n        new_description=(\n            'The condition(s) a key(s) must meet. Valid conditions are '\n            'listed in the '\n            ':ref:`DynamoDB Reference Guide<ref_dynamodb_conditions>`.'\n        ),\n        new_example_value='Key(\\'mykey\\').eq(\\'myvalue\\')',\n    )\n\n    con_expression_shape_docs = DocumentModifiedShape(\n        'ConditionExpression',\n        new_type=(\n            'condition from :py:class:`boto3.dynamodb.conditions.Attr` '\n            'method'\n        ),\n        new_description=(\n            'The condition(s) an attribute(s) must meet. Valid conditions '\n            'are listed in the '\n            ':ref:`DynamoDB Reference Guide<ref_dynamodb_conditions>`.'\n        ),\n        new_example_value='Attr(\\'myattribute\\').eq(\\'myvalue\\')',\n    )\n\n    self.meta.client.meta.events.register(\n        'docs.*.dynamodb.*.complete-section',\n        attr_value_shape_docs.replace_documentation_for_matching_shape,\n        unique_id='dynamodb-attr-value-docs',\n    )\n\n    self.meta.client.meta.events.register(\n        'docs.*.dynamodb.*.complete-section',\n        key_expression_shape_docs.replace_documentation_for_matching_shape,\n        unique_id='dynamodb-key-expression-docs',\n    )\n\n    self.meta.client.meta.events.register(\n        'docs.*.dynamodb.*.complete-section',\n        con_expression_shape_docs.replace_documentation_for_matching_shape,\n        unique_id='dynamodb-cond-expression-docs',\n    )",
    "boto3.boto3.exceptions.__init__": "def __init__(self, service_name, available_services, has_low_level_client):\n    msg = (\n        \"The '{}' resource does not exist.\\n\"\n        \"The available resources are:\\n\"\n        \"   - {}\\n\".format(\n            service_name, '\\n   - '.join(available_services)\n        )\n    )\n    if has_low_level_client:\n        msg = (\n            f\"{msg}\\nConsider using a boto3.client('{service_name}') \"\n            f\"instead of a resource for '{service_name}'\"\n        )\n    # Not using super because we don't want the DataNotFoundError\n    # to be called, it has a different __init__ signature.\n    Boto3Error.__init__(self, msg)",
    "boto3.boto3.resources.base.__init__": "def __init__(self, *args, **kwargs):\n    # Always work on a copy of meta, otherwise we would affect other\n    # instances of the same subclass.\n    self.meta = self.meta.copy()\n\n    # Create a default client if none was passed\n    if kwargs.get('client') is not None:\n        self.meta.client = kwargs.get('client')\n    else:\n        self.meta.client = boto3.client(self.meta.service_name)\n\n    # Allow setting identifiers as positional arguments in the order\n    # in which they were defined in the ResourceJSON.\n    for i, value in enumerate(args):\n        setattr(self, '_' + self.meta.identifiers[i], value)\n\n    # Allow setting identifiers via keyword arguments. Here we need\n    # extra logic to ignore other keyword arguments like ``client``.\n    for name, value in kwargs.items():\n        if name == 'client':\n            continue\n\n        if name not in self.meta.identifiers:\n            raise ValueError(f'Unknown keyword argument: {name}')\n\n        setattr(self, '_' + name, value)\n\n    # Validate that all identifiers have been set.\n    for identifier in self.meta.identifiers:\n        if getattr(self, identifier) is None:\n            raise ValueError(f'Required parameter {identifier} not set')",
    "boto3.boto3.resources.factory.load_from_definition": "def load_from_definition(\n    self, resource_name, single_resource_json_definition, service_context\n):\n    \"\"\"\n    Loads a resource from a model, creating a new\n    :py:class:`~boto3.resources.base.ServiceResource` subclass\n    with the correct properties and methods, named based on the service\n    and resource name, e.g. EC2.Instance.\n\n    :type resource_name: string\n    :param resource_name: Name of the resource to look up. For services,\n                          this should match the ``service_name``.\n\n    :type single_resource_json_definition: dict\n    :param single_resource_json_definition:\n        The loaded json of a single service resource or resource\n        definition.\n\n    :type service_context: :py:class:`~boto3.utils.ServiceContext`\n    :param service_context: Context about the AWS service\n\n    :rtype: Subclass of :py:class:`~boto3.resources.base.ServiceResource`\n    :return: The service or resource class.\n    \"\"\"\n    logger.debug(\n        'Loading %s:%s', service_context.service_name, resource_name\n    )\n\n    # Using the loaded JSON create a ResourceModel object.\n    resource_model = ResourceModel(\n        resource_name,\n        single_resource_json_definition,\n        service_context.resource_json_definitions,\n    )\n\n    # Do some renaming of the shape if there was a naming collision\n    # that needed to be accounted for.\n    shape = None\n    if resource_model.shape:\n        shape = service_context.service_model.shape_for(\n            resource_model.shape\n        )\n    resource_model.load_rename_map(shape)\n\n    # Set some basic info\n    meta = ResourceMeta(\n        service_context.service_name, resource_model=resource_model\n    )\n    attrs = {\n        'meta': meta,\n    }\n\n    # Create and load all of attributes of the resource class based\n    # on the models.\n\n    # Identifiers\n    self._load_identifiers(\n        attrs=attrs,\n        meta=meta,\n        resource_name=resource_name,\n        resource_model=resource_model,\n    )\n\n    # Load/Reload actions\n    self._load_actions(\n        attrs=attrs,\n        resource_name=resource_name,\n        resource_model=resource_model,\n        service_context=service_context,\n    )\n\n    # Attributes that get auto-loaded\n    self._load_attributes(\n        attrs=attrs,\n        meta=meta,\n        resource_name=resource_name,\n        resource_model=resource_model,\n        service_context=service_context,\n    )\n\n    # Collections and their corresponding methods\n    self._load_collections(\n        attrs=attrs,\n        resource_model=resource_model,\n        service_context=service_context,\n    )\n\n    # References and Subresources\n    self._load_has_relations(\n        attrs=attrs,\n        resource_name=resource_name,\n        resource_model=resource_model,\n        service_context=service_context,\n    )\n\n    # Waiter resource actions\n    self._load_waiters(\n        attrs=attrs,\n        resource_name=resource_name,\n        resource_model=resource_model,\n        service_context=service_context,\n    )\n\n    # Create the name based on the requested service and resource\n    cls_name = resource_name\n    if service_context.service_name == resource_name:\n        cls_name = 'ServiceResource'\n    cls_name = service_context.service_name + '.' + cls_name\n\n    base_classes = [ServiceResource]\n    if self._emitter is not None:\n        self._emitter.emit(\n            f'creating-resource-class.{cls_name}',\n            class_attributes=attrs,\n            base_classes=base_classes,\n            service_context=service_context,\n        )\n    return type(str(cls_name), tuple(base_classes), attrs)",
    "boto3.boto3.session.get_available_services": "def get_available_services(self):\n    \"\"\"\n    Get a list of available services that can be loaded as low-level\n    clients via :py:meth:`Session.client`.\n\n    :rtype: list\n    :return: List of service names\n    \"\"\"\n    return self._session.get_available_services()",
    "boto3.boto3.session.get_available_resources": "def get_available_resources(self):\n    \"\"\"\n    Get a list of available services that can be loaded as resource\n    clients via :py:meth:`Session.resource`.\n\n    :rtype: list\n    :return: List of service names\n    \"\"\"\n    return self._loader.list_available_services(type_name='resources-1')",
    "boto3.boto3.session.client": "def client(\n    self,\n    service_name,\n    region_name=None,\n    api_version=None,\n    use_ssl=True,\n    verify=None,\n    endpoint_url=None,\n    aws_access_key_id=None,\n    aws_secret_access_key=None,\n    aws_session_token=None,\n    config=None,\n    aws_account_id=None,\n):\n    \"\"\"\n    Create a low-level service client by name.\n\n    :type service_name: string\n    :param service_name: The name of a service, e.g. 's3' or 'ec2'. You\n        can get a list of available services via\n        :py:meth:`get_available_services`.\n\n    :type region_name: string\n    :param region_name: The name of the region associated with the client.\n        A client is associated with a single region.\n\n    :type api_version: string\n    :param api_version: The API version to use.  By default, botocore will\n        use the latest API version when creating a client.  You only need\n        to specify this parameter if you want to use a previous API version\n        of the client.\n\n    :type use_ssl: boolean\n    :param use_ssl: Whether or not to use SSL.  By default, SSL is used.\n        Note that not all services support non-ssl connections.\n\n    :type verify: boolean/string\n    :param verify: Whether or not to verify SSL certificates.  By default\n        SSL certificates are verified.  You can provide the following\n        values:\n\n        * False - do not validate SSL certificates.  SSL will still be\n          used (unless use_ssl is False), but SSL certificates\n          will not be verified.\n        * path/to/cert/bundle.pem - A filename of the CA cert bundle to\n          uses.  You can specify this argument if you want to use a\n          different CA cert bundle than the one used by botocore.\n\n    :type endpoint_url: string\n    :param endpoint_url: The complete URL to use for the constructed\n        client. Normally, botocore will automatically construct the\n        appropriate URL to use when communicating with a service.  You\n        can specify a complete URL (including the \"http/https\" scheme)\n        to override this behavior.  If this value is provided,\n        then ``use_ssl`` is ignored.\n\n    :type aws_access_key_id: string\n    :param aws_access_key_id: The access key to use when creating\n        the client.  This is entirely optional, and if not provided,\n        the credentials configured for the session will automatically\n        be used.  You only need to provide this argument if you want\n        to override the credentials used for this specific client.\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: The secret key to use when creating\n        the client.  Same semantics as aws_access_key_id above.\n\n    :type aws_session_token: string\n    :param aws_session_token: The session token to use when creating\n        the client.  Same semantics as aws_access_key_id above.\n\n    :type config: botocore.client.Config\n    :param config: Advanced client configuration options. If region_name\n        is specified in the client config, its value will take precedence\n        over environment variables and configuration values, but not over\n        a region_name value passed explicitly to the method. See\n        `botocore config documentation\n        <https://botocore.amazonaws.com/v1/documentation/api/latest/reference/config.html>`_\n        for more details.\n\n    :type aws_account_id: string\n    :param aws_account_id: The account id to use when creating\n        the client.  Same semantics as aws_access_key_id above.\n\n    :return: Service client instance\n\n    \"\"\"\n    create_client_kwargs = {\n        'region_name': region_name,\n        'api_version': api_version,\n        'use_ssl': use_ssl,\n        'verify': verify,\n        'endpoint_url': endpoint_url,\n        'aws_access_key_id': aws_access_key_id,\n        'aws_secret_access_key': aws_secret_access_key,\n        'aws_session_token': aws_session_token,\n        'config': config,\n        'aws_account_id': aws_account_id,\n    }\n    if aws_account_id is None:\n        # Remove aws_account_id for arbitrary\n        # botocore version mismatches in AWS Lambda.\n        del create_client_kwargs['aws_account_id']\n\n    return self._session.create_client(\n        service_name, **create_client_kwargs\n    )",
    "boto3.boto3.utils.__init__": "def __init__(self, bc_session, service_name, api_version):\n    self._session = bc_session\n    self._service_name = service_name\n    self._api_version = api_version"
}