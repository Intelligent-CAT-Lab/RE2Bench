{
    "sympy.sympy.matrices.immutable._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    if len(args) == 1 and isinstance(args[0], ImmutableDenseMatrix):\n        return args[0]\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.matrixbase._eval_pow_by_recursion_dotprodsimp": "def _eval_pow_by_recursion_dotprodsimp(self,\n        num: int,\n        prevsimp: list[bool] | None = None\n    ) -> Self:\n\n    if prevsimp is None:\n        prevsimp = [True]*len(self)\n\n    if num == 1:\n        return self\n\n    if num % 2 == 1:\n        a, b = self, self._eval_pow_by_recursion_dotprodsimp(num - 1,\n                prevsimp=prevsimp)\n    else:\n        a = b = self._eval_pow_by_recursion_dotprodsimp(num // 2,\n                prevsimp=prevsimp)\n\n    m     = a.multiply(b, dotprodsimp=False)\n    lenm  = len(m)\n    elems: list[Expr] = []\n\n    for i in range(lenm):\n        if prevsimp[i]:\n            ei, prevsimp[i] = _dotprodsimp(m[i], withsimp=True)\n        else:\n            ei = m[i]\n        elems.append(ei)\n\n    return self._new(m.rows, m.cols, elems)",
    "sympy.sympy.matrices.matrixbase.multiply": "def multiply(self,\n             other: MatrixBase | Expr,\n             dotprodsimp: bool | None = None\n         ) -> MatrixBase | Expr:\n    \"\"\"Same as __mul__() but with optional simplification.\n\n    Parameters\n    ==========\n\n    dotprodsimp : bool, optional\n        Specifies whether intermediate term algebraic simplification is used\n        during matrix multiplications to control expression blowup and thus\n        speed up calculation. Default is off.\n    \"\"\"\n\n    isimpbool = _get_intermediate_simp_bool(False, dotprodsimp)\n\n    self, other, T = _unify_with_other(self, other)\n\n    if isinstance(other, MatrixBase):\n\n        if self.shape[1] != other.shape[0]:\n            raise ShapeError(f\"Matrix size mismatch: {self.shape} * {other.shape}.\")\n\n        m = self._eval_matrix_mul(other)\n\n        if isimpbool:\n            m = m._new(m.rows, m.cols, [_dotprodsimp(e) for e in m.flat()])\n\n        return m\n\n    elif T == \"possible_scalar\":\n        try:\n            return self._eval_scalar_mul(other)\n        except TypeError:\n            return NotImplemented\n\n    else:\n        return NotImplemented",
    "sympy.sympy.matrices.matrixbase.__len__": "def __len__(self) -> int:\n    \"\"\"Return the number of elements of ``self``.\n\n    Implemented mainly so bool(Matrix()) == False.\n    \"\"\"\n    return self.rows * self.cols",
    "sympy.sympy.matrices.repmatrix.__getitem__": "def __getitem__(self, key: tuple[int | Slice, int | Slice] | int | slice, /\n                ) -> Expr | Self | list[Expr]:\n    return _getitem_RepMatrix(self, key)",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.sparse._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.utilities._dotprodsimp": "def _dotprodsimp(expr: Expr, withsimp: bool = False) -> Expr | tuple[Expr, bool]:\n    \"\"\"Wrapper for simplify.dotprodsimp to avoid circular imports.\"\"\"\n    from sympy.simplify.simplify import dotprodsimp as dps\n    return dps(expr, withsimp=withsimp)"
}