{
    "sympy.sympy.assumptions.assume._hashable_content": "def _hashable_content(self):\n    return (self.name,)",
    "sympy.sympy.codegen.ast.__eq__": "def __eq__(self, other):\n    if not isinstance(other, self.__class__):\n        return False\n    for attr in self._fields:\n        if getattr(self, attr) != getattr(other, attr):\n            return False\n    return True",
    "sympy.sympy.combinatorics.permutations._hashable_content": "def _hashable_content(self):\n    # the array_form (a list) is the Permutation arg, so we need to\n    # return a tuple, instead\n    return tuple(self.array_form)",
    "sympy.sympy.core.basic._hashable_content": "def _hashable_content(self) -> tuple[Hashable, ...]:\n    \"\"\"Return a tuple of information about self that can be used to\n    compute the hash. If a class defines additional attributes,\n    like ``name`` in Symbol, then this method should be updated\n    accordingly to return such relevant attributes.\n\n    Defining more than _hashable_content is necessary if __eq__ has\n    been defined by a class. See note about this in Basic.__eq__.\"\"\"\n    return self._args",
    "sympy.sympy.core.basic._do_eq_sympify": "def _do_eq_sympify(self, other):\n    \"\"\"Returns a boolean indicating whether a == b when either a\n    or b is not a Basic. This is only done for types that were either\n    added to `converter` by a 3rd party or when the object has `_sympy_`\n    defined. This essentially reuses the code in `_sympify` that is\n    specific for this use case. Non-user defined types that are meant\n    to work with SymPy should be handled directly in the __eq__ methods\n    of the `Basic` classes it could equate to and not be converted. Note\n    that after conversion, `==`  is used again since it is not\n    necessarily clear whether `self` or `other`'s __eq__ method needs\n    to be used.\"\"\"\n    for superclass in type(other).__mro__:\n        conv = _external_converter.get(superclass)\n        if conv is not None:\n            return self == conv(other)\n    if hasattr(other, '_sympy_'):\n        return self == other._sympy_()\n    return NotImplemented",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr._hashable_content": "def _hashable_content(self) -> tuple[Basic, ...] | tuple[Hashable, ...]:\n    \"\"\"Return a tuple of information about self that can be used to\n    compute the hash. If a class defines additional attributes,\n    like ``name`` in Symbol, then this method should be updated\n    accordingly to return such relevant attributes.\n    Defining more than _hashable_content is necessary if __eq__ has\n    been defined by a class. See note about this in Basic.__eq__.\"\"\"\n    return self._args",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    "sympy.sympy.core.symbol._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + (self.exclude, self.properties)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.diffgeom.diffgeom._hashable_content": "def _hashable_content(self):\n    return (\n        self.coord_sys, self.index\n    ) + tuple(sorted(self.assumptions0.items()))",
    "sympy.sympy.geometry.point.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Point) or len(self.args) != len(other.args):\n        return False\n    return self.args == other.args",
    "sympy.sympy.geometry.polygon._hashable_content": "def _hashable_content(self):\n\n    D = {}\n    def ref_list(point_list):\n        kee = {}\n        for i, p in enumerate(ordered(set(point_list))):\n            kee[p] = i\n            D[i] = p\n        return [kee[p] for p in point_list]\n\n    S1 = ref_list(self.args)\n    r_nor = rotate_left(S1, least_rotation(S1))\n    S2 = ref_list(list(reversed(self.args)))\n    r_rev = rotate_left(S2, least_rotation(S2))\n    if r_nor < r_rev:\n        r = r_nor\n    else:\n        r = r_rev\n    canonical_args = [ D[order] for order in r ]\n    return tuple(canonical_args)",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)",
    "sympy.sympy.physics.paulialgebra._hashable_content": "def _hashable_content(self):\n    return (self.i, self.label)",
    "sympy.sympy.physics.quantum.grover._hashable_content": "def _hashable_content(self):\n    return type(self), self.function",
    "sympy.sympy.physics.quantum.trace._hashable_content": "def _hashable_content(self):\n    if isinstance(self.args[0], Mul):\n        args = _cycle_permute(_rearrange_args(self.args[0].args))\n    else:\n        args = [self.args[0]]\n\n    return tuple(args) + (self.args[1], )",
    "sympy.sympy.physics.vector.frame.__eq__": "def __eq__(self, other):\n    # Check if the other object is a CoordinateSym of the same frame and\n    # same index\n    if isinstance(other, CoordinateSym):\n        if other._id == self._id:\n            return True\n    return False",
    "sympy.sympy.polys.rootoftools._hashable_content": "def _hashable_content(self):\n    return (self.poly, self.index)",
    "sympy.sympy.sets.fancysets.__eq__": "def __eq__(self, other):\n    return other == Interval(S.NegativeInfinity, S.Infinity)",
    "sympy.sympy.sets.sets.__eq__": "def __eq__(self, other):\n    if isinstance(other, (set, frozenset)):\n        return self._args_set == other\n    return super().__eq__(other)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.simplify.hyperexpand._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + self.args",
    "sympy.sympy.tensor.array.ndim_array.__eq__": "def __eq__(self, other):\n    \"\"\"\n    NDimArray instances can be compared to each other.\n    Instances equal if they have same shape and data.\n\n    Examples\n    ========\n\n    >>> from sympy import MutableDenseNDimArray\n    >>> a = MutableDenseNDimArray.zeros(2, 3)\n    >>> b = MutableDenseNDimArray.zeros(2, 3)\n    >>> a == b\n    True\n    >>> c = a.reshape(3, 2)\n    >>> c == b\n    False\n    >>> a[0,0] = 1\n    >>> b[0,0] = 2\n    >>> a == b\n    False\n    \"\"\"\n    from sympy.tensor.array import SparseNDimArray\n    if not isinstance(other, NDimArray):\n        return False\n\n    if not self.shape == other.shape:\n        return False\n\n    if isinstance(self, SparseNDimArray) and isinstance(other, SparseNDimArray):\n        return dict(self._sparse_array) == dict(other._sparse_array)\n\n    return list(self) == list(other)",
    "sympy.sympy.tensor.indexed._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + tuple(sorted(self.assumptions0.items()))",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}