{
    "sympy.sympy.polys.domains.algebraicfield.to_sympy": "def to_sympy(self, a):\n    \"\"\"Convert ``a`` of ``dtype`` to a SymPy object. \"\"\"\n    # Precompute a converter to be reused:\n    if not hasattr(self, '_converter'):\n        self._converter = _make_converter(self)\n\n    return self._converter(a)",
    "sympy.sympy.polys.domains.finitefield.to_sympy": "def to_sympy(self, a):\n    \"\"\"Convert ``a`` to a SymPy object. \"\"\"\n    return SymPyInteger(self.to_int(a))",
    "sympy.sympy.polys.domains.fractionfield.to_sympy": "def to_sympy(self, a):\n    \"\"\"Convert ``a`` to a SymPy object. \"\"\"\n    return a.as_expr()",
    "sympy.sympy.polys.domains.gaussiandomains.to_sympy": "def to_sympy(self, a: Telem) -> Expr:\n    \"\"\"Convert ``a`` to a SymPy object. \"\"\"\n    conv = self.dom.to_sympy\n    return conv(a.x) + I*conv(a.y)",
    "sympy.sympy.polys.domains.integerring.to_sympy": "def to_sympy(self, a):\n    \"\"\"Convert ``a`` to a SymPy object. \"\"\"\n    return SymPyInteger(int(a))",
    "sympy.sympy.polys.domains.polynomialring.to_sympy": "def to_sympy(self, a: PolyElement[Er]) -> Expr:\n    \"\"\"Convert `a` to a SymPy object. \"\"\"\n    return a.as_expr()",
    "sympy.sympy.polys.domains.rationalfield.to_sympy": "def to_sympy(self, a):\n    \"\"\"Convert ``a`` to a SymPy object. \"\"\"\n    return SymPyRational(int(a.numerator), int(a.denominator))",
    "sympy.sympy.polys.domains.realfield.to_sympy": "def to_sympy(self, element):\n    \"\"\"Convert ``element`` to SymPy number. \"\"\"\n    return Float(element, self.dps)",
    "sympy.sympy.polys.polyclasses.factor_list": "def factor_list(f) -> tuple[Er, list[tuple[Self, int]]]:\n    \"\"\"Returns a list of irreducible factors of ``f``. \"\"\"\n    coeff, factors = dmp_factor_list(f._rep, f.lev, f.dom)\n    return coeff, [ (f.per(g), k) for g, k in factors ]",
    "sympy.sympy.polys.polytools.as_expr": "def as_expr(f, *gens):\n    \"\"\"\n    Convert a Poly instance to an Expr instance.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n    >>> f.as_expr()\n    x**2 + 2*x*y**2 - y\n    >>> f.as_expr({x: 5})\n    10*y**2 - y + 25\n    >>> f.as_expr(5, 6)\n    379\n\n    \"\"\"\n    if not gens:\n        return f.expr\n\n    if len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\n                    \"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    "sympy.sympy.polys.polytools.degree": "def degree(f, gen: int = 0) -> int | NegativeInfinity:\n    \"\"\"\n    Returns degree of ``f`` in ``x_j``.\n\n    The degree of 0 is negative infinity.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> Poly(x**2 + y*x + 1, x, y).degree()\n    2\n    >>> Poly(x**2 + y*x + y, x, y).degree(y)\n    1\n    >>> Poly(0, x).degree()\n    -oo\n\n    \"\"\"\n    j = f._gen_to_level(gen)\n\n    if hasattr(f.rep, 'degree'):\n        d = f.rep.degree(j)\n        if d < 0:\n            return S.NegativeInfinity\n        return d\n    else:  # pragma: no cover\n        raise OperationNotSupported(f, 'degree')",
    "sympy.sympy.polys.polytools.<listcomp>": "return f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors]\n\n"
}