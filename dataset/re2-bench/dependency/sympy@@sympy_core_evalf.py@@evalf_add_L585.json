{
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.evalf.evalf": "def evalf(x: Expr, prec: int, options: OPT_DICT) -> TMP_RES:\n    \"\"\"\n    Evaluate the ``Expr`` instance, ``x``\n    to a binary precision of ``prec``. This\n    function is supposed to be used internally.\n\n    Parameters\n    ==========\n\n    x : Expr\n        The formula to evaluate to a float.\n    prec : int\n        The binary precision that the output should have.\n    options : dict\n        A dictionary with the same entries as\n        ``EvalfMixin.evalf`` and in addition,\n        ``maxprec`` which is the maximum working precision.\n\n    Returns\n    =======\n\n    An optional tuple, ``(re, im, re_acc, im_acc)``\n    which are the real, imaginary, real accuracy\n    and imaginary accuracy respectively. ``re`` is\n    an mpf value tuple and so is ``im``. ``re_acc``\n    and ``im_acc`` are ints.\n\n    NB: all these return values can be ``None``.\n    If all values are ``None``, then that represents 0.\n    Note that 0 is also represented as ``fzero = (0, 0, 0, 0)``.\n    \"\"\"\n    from sympy.functions.elementary.complexes import re as re_, im as im_\n    try:\n        rf = evalf_table[type(x)]\n        r = rf(x, prec, options)\n    except KeyError:\n        # Fall back to ordinary evalf if possible\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, \"as_real_imag\", None)\n        if as_real_imag is None:\n            raise NotImplementedError # e.g. FiniteSet(-1.0, 1.0).evalf()\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if not re:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if not im:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = re, im, reprec, imprec\n\n    if options.get(\"verbose\"):\n        print(\"### input\", x)\n        print(\"### output\", to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)\n        print(\"### raw\", r) # r[0], r[2]\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            # convert (approximately) from given tolerance;\n            # the formula here will will make 1e-i rounds to 0 for\n            # i in the range +/-27 while 2e-i will not be chopped\n            chop_prec = int(round(-3.321*math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get(\"strict\"):\n        check_target(x, r, prec)\n    return r",
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.core.evalf.scaled_zero": "def scaled_zero(mag: SCALED_ZERO_TUP | int, sign=1) -> \\\n        MPF_TUP | tuple[SCALED_ZERO_TUP, int]:\n    \"\"\"Return an mpf representing a power of two with magnitude ``mag``\n    and -1 for precision. Or, if ``mag`` is a scaled_zero tuple, then just\n    remove the sign from within the list that it was initially wrapped\n    in.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import scaled_zero\n    >>> from sympy import Float\n    >>> z, p = scaled_zero(100)\n    >>> z, p\n    (([0], 1, 100, 1), -1)\n    >>> ok = scaled_zero(z)\n    >>> ok\n    (0, 1, 100, 1)\n    >>> Float(ok)\n    1.26765060022823e+30\n    >>> Float(ok, p)\n    0.e+30\n    >>> ok, p = scaled_zero(100, -1)\n    >>> Float(scaled_zero(ok), p)\n    -0.e+30\n    \"\"\"\n    if isinstance(mag, tuple) and len(mag) == 4 and iszero(mag, scaled=True):\n        return (mag[0][0],) + mag[1:]\n    elif isinstance(mag, SYMPY_INTS):\n        if sign not in [-1, 1]:\n            raise ValueError('sign must be +/-1')\n        rv, p = mpf_shift(fone, mag), -1\n        s = 0 if sign == 1 else 1\n        rv = ([s],) + rv[1:]\n        return rv, p\n    else:\n        raise ValueError('scaled zero expects int or scaled_zero tuple.')",
    "sympy.sympy.core.evalf.iszero": "def iszero(mpf: MPF_TUP | SCALED_ZERO_TUP | None, scaled=False) -> bool | None:\n    if not scaled:\n        return not mpf or not mpf[1] and not mpf[-1]\n    return mpf and isinstance(mpf[0], list) and mpf[1] == mpf[-1] == 1",
    "sympy.sympy.core.evalf.complex_accuracy": "def complex_accuracy(result: TMP_RES) -> int | Any:\n    \"\"\"\n    Returns relative accuracy of a complex number with given accuracies\n    for the real and imaginary parts. The relative accuracy is defined\n    in the complex norm sense as ||z|+|error|| / |z| where error\n    is equal to (real absolute error) + (imag absolute error)*i.\n\n    The full expression for the (logarithmic) error can be approximated\n    easily by using the max norm to approximate the complex norm.\n\n    In the worst case (re and im equal), this is wrong by a factor\n    sqrt(2), or by log2(sqrt(2)) = 0.5 bit.\n    \"\"\"\n    if result is S.ComplexInfinity:\n        return INF\n    re, im, re_acc, im_acc = result\n    if not im:\n        if not re:\n            return INF\n        return re_acc\n    if not re:\n        return im_acc\n    re_size = fastlog(re)\n    im_size = fastlog(im)\n    absolute_error = max(re_size - re_acc, im_size - im_acc)\n    relative_error = absolute_error - max(re_size, im_size)\n    return -relative_error",
    "sympy.sympy.core.evalf.add_terms": "def add_terms(terms: list, prec: int, target_prec: int) -> \\\n        tuple[MPF_TUP | SCALED_ZERO_TUP | None, int | None]:\n    \"\"\"\n    Helper for evalf_add. Adds a list of (mpfval, accuracy) terms.\n\n    Returns\n    =======\n\n    - None, None if there are no non-zero terms;\n    - terms[0] if there is only 1 term;\n    - scaled_zero if the sum of the terms produces a zero by cancellation\n      e.g. mpfs representing 1 and -1 would produce a scaled zero which need\n      special handling since they are not actually zero and they are purposely\n      malformed to ensure that they cannot be used in anything but accuracy\n      calculations;\n    - a tuple that is scaled to target_prec that corresponds to the\n      sum of the terms.\n\n    The returned mpf tuple will be normalized to target_prec; the input\n    prec is used to define the working precision.\n\n    XXX explain why this is needed and why one cannot just loop using mpf_add\n    \"\"\"\n\n    terms = [t for t in terms if not iszero(t[0])]\n    if not terms:\n        return None, None\n    elif len(terms) == 1:\n        return terms[0]\n\n    # see if any argument is NaN or oo and thus warrants a special return\n    special = []\n    from .numbers import Float\n    for t in terms:\n        arg = Float._new(t[0], 1)\n        if arg is S.NaN or arg.is_infinite:\n            special.append(arg)\n    if special:\n        from .add import Add\n        rv = evalf(Add(*special), prec + 4, {})\n        return rv[0], rv[2]\n\n    working_prec = 2*prec\n    sum_man, sum_exp = 0, 0\n    absolute_err: list[int] = []\n\n    for x, accuracy in terms:\n        sign, man, exp, bc = x\n        if sign:\n            man = -man\n        absolute_err.append(bc + exp - accuracy)\n        delta = exp - sum_exp\n        if exp >= sum_exp:\n            # x much larger than existing sum?\n            # first: quick test\n            if ((delta > working_prec) and\n                ((not sum_man) or\n                 delta - sum_man.bit_length() > working_prec)):\n                sum_man = man\n                sum_exp = exp\n            else:\n                sum_man += (man << delta)\n        else:\n            delta = -delta\n            # x much smaller than existing sum?\n            if delta - bc > working_prec:\n                if not sum_man:\n                    sum_man, sum_exp = man, exp\n            else:\n                sum_man = (sum_man << delta) + man\n                sum_exp = exp\n    absolute_error = max(absolute_err)\n    if not sum_man:\n        return scaled_zero(absolute_error)\n    if sum_man < 0:\n        sum_sign = 1\n        sum_man = -sum_man\n    else:\n        sum_sign = 0\n    sum_bc = sum_man.bit_length()\n    sum_accuracy = sum_exp + sum_bc - absolute_error\n    r = normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec,\n        rnd), sum_accuracy\n    return r",
    "sympy.sympy.core.evalf.<listcomp>": "[a[1::2] for a in terms if isinstance(a, tuple) and a[1]], prec, target_prec)\n"
}