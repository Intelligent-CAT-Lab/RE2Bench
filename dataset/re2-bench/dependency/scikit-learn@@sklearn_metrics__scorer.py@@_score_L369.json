{
    "scikit-learn.sklearn.base.is_regressor": "def is_regressor(estimator):\n    \"\"\"Return True if the given estimator is (probably) a regressor.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator object to test.\n\n    Returns\n    -------\n    out : bool\n        True if estimator is a regressor and False otherwise.\n\n    Examples\n    --------\n    >>> from sklearn.base import is_regressor\n    >>> from sklearn.cluster import KMeans\n    >>> from sklearn.svm import SVC, SVR\n    >>> classifier = SVC()\n    >>> regressor = SVR()\n    >>> kmeans = KMeans()\n    >>> is_regressor(classifier)\n    False\n    >>> is_regressor(regressor)\n    True\n    >>> is_regressor(kmeans)\n    False\n    \"\"\"\n    return get_tags(estimator).estimator_type == \"regressor\"",
    "scikit-learn.sklearn.metrics._scorer._get_pos_label": "def _get_pos_label(self):\n    if \"pos_label\" in self._kwargs:\n        return self._kwargs[\"pos_label\"]\n    score_func_params = signature(self._score_func).parameters\n    if \"pos_label\" in score_func_params:\n        return score_func_params[\"pos_label\"].default\n    return None",
    "scikit-learn.sklearn.metrics._scorer._warn_overlap": "def _warn_overlap(self, message, kwargs):\n    \"\"\"Warn if there is any overlap between ``self._kwargs`` and ``kwargs``.\n\n    This method is intended to be used to check for overlap between\n    ``self._kwargs`` and ``kwargs`` passed as metadata.\n    \"\"\"\n    _kwargs = set() if self._kwargs is None else set(self._kwargs.keys())\n    overlap = _kwargs.intersection(kwargs.keys())\n    if overlap:\n        warnings.warn(\n            f\"{message} Overlapping parameters are: {overlap}\", UserWarning\n        )",
    "scikit-learn.sklearn.metrics._scorer._get_response_method_name": "def _get_response_method_name(response_method):\n    try:\n        return response_method.__name__\n    except AttributeError:\n        return _get_response_method_name(response_method.func)",
    "scikit-learn.sklearn.metrics._scorer.positive_likelihood_ratio": "def positive_likelihood_ratio(y_true, y_pred):\n    return class_likelihood_ratios(y_true, y_pred, replace_undefined_by=1.0)[0]",
    "scikit-learn.sklearn.metrics._scorer.negative_likelihood_ratio": "def negative_likelihood_ratio(y_true, y_pred):\n    return class_likelihood_ratios(y_true, y_pred, replace_undefined_by=1.0)[1]",
    "scikit-learn.sklearn.metrics._scorer._cached_call": "def _cached_call(cache, estimator, response_method, *args, **kwargs):\n    \"\"\"Call estimator with method and args and kwargs.\"\"\"\n    if cache is not None and response_method in cache:\n        return cache[response_method]\n\n    result, _ = _get_response_values(\n        estimator, *args, response_method=response_method, **kwargs\n    )\n\n    if cache is not None:\n        cache[response_method] = result\n\n    return result",
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e",
    "scikit-learn.sklearn.utils.validation._check_response_method": "def _check_response_method(estimator, response_method):\n    \"\"\"Check if `response_method` is available in estimator and return it.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Classifier or regressor to check.\n\n    response_method : {\"predict_proba\", \"predict_log_proba\", \"decision_function\",\n            \"predict\"} or list of such str\n        Specifies the response method to use get prediction from an estimator\n        (i.e. :term:`predict_proba`, :term:`predict_log_proba`,\n        :term:`decision_function` or :term:`predict`). Possible choices are:\n        - if `str`, it corresponds to the name to the method to return;\n        - if a list of `str`, it provides the method names in order of\n          preference. The method returned corresponds to the first method in\n          the list and which is implemented by `estimator`.\n\n    Returns\n    -------\n    prediction_method : callable\n        Prediction method of estimator.\n\n    Raises\n    ------\n    AttributeError\n        If `response_method` is not available in `estimator`.\n    \"\"\"\n    if isinstance(response_method, str):\n        list_methods = [response_method]\n    else:\n        list_methods = response_method\n\n    prediction_method = [getattr(estimator, method, None) for method in list_methods]\n    prediction_method = reduce(lambda x, y: x or y, prediction_method)\n    if prediction_method is None:\n        raise AttributeError(\n            f\"{estimator.__class__.__name__} has none of the following attributes: \"\n            f\"{', '.join(list_methods)}.\"\n        )\n\n    return prediction_method"
}