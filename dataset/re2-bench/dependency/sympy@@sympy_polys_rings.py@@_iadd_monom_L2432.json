{
    "sympy.sympy.polys.rings.copy": "def copy(self) -> PolyElement[Er]:\n    \"\"\"Return a copy of polynomial self.\n\n    Polynomials are mutable; if one is interested in preserving\n    a polynomial, and one plans to use inplace operations, one\n    can copy the polynomial. This method makes a shallow copy.\n\n    Examples\n    ========\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> R, x, y = ring('x, y', ZZ)\n    >>> p = (x + y)**2\n    >>> p1 = p.copy()\n    >>> p2 = p\n    >>> p[R.zero_monom] = 3\n    >>> p\n    x**2 + 2*x*y + y**2 + 3\n    >>> p1\n    x**2 + 2*x*y + y**2\n    >>> p2\n    x**2 + 2*x*y + y**2 + 3\n    \"\"\"\n    return self.new(self)",
    "sympy.sympy.polys.rings.__hash__": "def __hash__(self) -> int:  # type: ignore\n    # XXX: This computes a hash of a dictionary, but currently we don't\n    # protect dictionary from being changed so any use site modifications\n    # will make hashing go wrong. Use this feature with caution until we\n    # figure out how to make a safe API without compromising speed of this\n    # low-level class.\n    _hash = self._hash\n    if _hash is None:\n        self._hash = _hash = hash((self.ring, frozenset(self.items())))\n    return _hash"
}