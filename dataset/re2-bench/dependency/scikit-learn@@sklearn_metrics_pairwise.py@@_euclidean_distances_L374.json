{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.externals.array_api_compat.numpy._aliases.asarray": "def asarray(\n    obj: Array | complex | NestedSequence[complex] | SupportsBufferProtocol,\n    /,\n    *,\n    dtype: DType | None = None,\n    device: Device | None = None,\n    copy: _Copy | None = None,\n    **kwargs: Any,\n) -> Array:\n    \"\"\"\n    Array API compatibility wrapper for asarray().\n\n    See the corresponding documentation in the array library and/or the array API\n    specification for more details.\n    \"\"\"\n    _helpers._check_device(np, device)\n\n    if copy is None:\n        copy = np._CopyMode.IF_NEEDED\n    elif copy is False:\n        copy = np._CopyMode.NEVER\n    elif copy is True:\n        copy = np._CopyMode.ALWAYS\n\n    return np.array(obj, copy=copy, dtype=dtype, **kwargs)  # pyright: ignore",
    "scikit-learn.sklearn.metrics.pairwise._euclidean_distances_upcast": "def _euclidean_distances_upcast(X, XX=None, Y=None, YY=None, batch_size=None):\n    \"\"\"Euclidean distances between X and Y.\n\n    Assumes X and Y have float32 dtype.\n    Assumes XX and YY have float64 dtype or are None.\n\n    X and Y are upcast to float64 by chunks, which size is chosen to limit\n    memory increase by approximately 10% (at least 10MiB).\n    \"\"\"\n    xp, _, device_ = get_namespace_and_device(X, Y)\n    n_samples_X = X.shape[0]\n    n_samples_Y = Y.shape[0]\n    n_features = X.shape[1]\n\n    distances = xp.empty((n_samples_X, n_samples_Y), dtype=xp.float32, device=device_)\n\n    if batch_size is None:\n        x_density = X.nnz / np.prod(X.shape) if issparse(X) else 1\n        y_density = Y.nnz / np.prod(Y.shape) if issparse(Y) else 1\n\n        # Allow 10% more memory than X, Y and the distance matrix take (at\n        # least 10MiB)\n        maxmem = max(\n            (\n                (x_density * n_samples_X + y_density * n_samples_Y) * n_features\n                + (x_density * n_samples_X * y_density * n_samples_Y)\n            )\n            / 10,\n            10 * 2**17,\n        )\n\n        # The increase amount of memory in 8-byte blocks is:\n        # - x_density * batch_size * n_features (copy of chunk of X)\n        # - y_density * batch_size * n_features (copy of chunk of Y)\n        # - batch_size * batch_size (chunk of distance matrix)\n        # Hence x\u00b2 + (xd+yd)kx = M, where x=batch_size, k=n_features, M=maxmem\n        #                                 xd=x_density and yd=y_density\n        tmp = (x_density + y_density) * n_features\n        batch_size = (-tmp + math.sqrt(tmp**2 + 4 * maxmem)) / 2\n        batch_size = max(int(batch_size), 1)\n\n    x_batches = gen_batches(n_samples_X, batch_size)\n    xp_max_float = _max_precision_float_dtype(xp=xp, device=device_)\n    for i, x_slice in enumerate(x_batches):\n        X_chunk = xp.astype(X[x_slice, :], xp_max_float)\n        if XX is None:\n            XX_chunk = row_norms(X_chunk, squared=True)[:, None]\n        else:\n            XX_chunk = XX[x_slice]\n\n        y_batches = gen_batches(n_samples_Y, batch_size)\n\n        for j, y_slice in enumerate(y_batches):\n            if X is Y and j < i:\n                # when X is Y the distance matrix is symmetric so we only need\n                # to compute half of it.\n                d = distances[y_slice, x_slice].T\n\n            else:\n                Y_chunk = xp.astype(Y[y_slice, :], xp_max_float)\n                if YY is None:\n                    YY_chunk = row_norms(Y_chunk, squared=True)[None, :]\n                else:\n                    YY_chunk = YY[:, y_slice]\n\n                d = -2 * safe_sparse_dot(X_chunk, Y_chunk.T, dense_output=True)\n                d += XX_chunk\n                d += YY_chunk\n\n            distances[x_slice, y_slice] = xp.astype(d, xp.float32, copy=False)\n\n    return distances",
    "scikit-learn.sklearn.utils._array_api._modify_in_place_if_numpy": "def _modify_in_place_if_numpy(xp, func, *args, out=None, **kwargs):\n    if _is_numpy_namespace(xp):\n        func(*args, out=out, **kwargs)\n    else:\n        out = func(*args, **kwargs)\n    return out",
    "scikit-learn.sklearn.utils._array_api.get_namespace_and_device": "def get_namespace_and_device(\n    *array_list, remove_none=True, remove_types=(str,), xp=None\n):\n    \"\"\"Combination into one single function of `get_namespace` and `device`.\n\n    Parameters\n    ----------\n    *array_list : array objects\n        Array objects.\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to NumPy.\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the Array API spec.\n        Always False when array_api_dispatch=False.\n    device : device\n        `device` object (see the \"Device Support\" section of the array API spec).\n    \"\"\"\n    skip_remove_kwargs = dict(remove_none=False, remove_types=[])\n\n    array_list = _remove_non_arrays(\n        *array_list,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n    arrays_device = device(*array_list, **skip_remove_kwargs)\n\n    if xp is None:\n        xp, is_array_api = get_namespace(*array_list, **skip_remove_kwargs)\n    else:\n        xp, is_array_api = xp, True\n\n    if is_array_api:\n        return xp, is_array_api, arrays_device\n    else:\n        return xp, False, arrays_device",
    "scikit-learn.sklearn.utils._array_api._fill_diagonal": "def _fill_diagonal(array, value, xp):\n    \"\"\"Minimal implementation of `numpy.fill_diagonal`.\n\n    `wrap` is not supported (i.e. always False). `value` should be a scalar or\n    1D of greater or equal length as the diagonal (i.e., `value` is never repeated\n    when shorter).\n\n    Note `array` is altered in place.\n    \"\"\"\n    value, min_rows_columns = _validate_diagonal_args(array, value, xp)\n\n    if _is_numpy_namespace(xp):\n        xp.fill_diagonal(array, value, wrap=False)\n    else:\n        # TODO: when array libraries support `reshape(copy)`, use\n        # `reshape(array, (-1,), copy=False)`, then fill with `[:end:step]` (within\n        # `try/except`). This is faster than for loop, when no copy needs to be\n        # made within `reshape`. See #31445 for details.\n        if value.ndim == 0:\n            for i in range(min_rows_columns):\n                array[i, i] = value\n        else:\n            for i in range(min_rows_columns):\n                array[i, i] = value[i]",
    "scikit-learn.sklearn.utils.extmath.safe_sparse_dot": "def safe_sparse_dot(a, b, *, dense_output=False):\n    \"\"\"Dot product that handle the sparse matrix case correctly.\n\n    Parameters\n    ----------\n    a : {ndarray, sparse matrix}\n    b : {ndarray, sparse matrix}\n    dense_output : bool, default=False\n        When False, ``a`` and ``b`` both being sparse will yield sparse output.\n        When True, output will always be a dense array.\n\n    Returns\n    -------\n    dot_product : {ndarray, sparse matrix}\n        Sparse if ``a`` and ``b`` are sparse and ``dense_output=False``.\n\n    Examples\n    --------\n    >>> from scipy.sparse import csr_matrix\n    >>> from sklearn.utils.extmath import safe_sparse_dot\n    >>> X = csr_matrix([[1, 2], [3, 4], [5, 6]])\n    >>> dot_product = safe_sparse_dot(X, X.T)\n    >>> dot_product.toarray()\n    array([[ 5, 11, 17],\n           [11, 25, 39],\n           [17, 39, 61]])\n    \"\"\"\n    xp, _ = get_namespace(a, b)\n    if a.ndim > 2 or b.ndim > 2:\n        if sparse.issparse(a):\n            # sparse is always 2D. Implies b is 3D+\n            # [i, j] @ [k, ..., l, m, n] -> [i, k, ..., l, n]\n            b_ = np.rollaxis(b, -2)\n            b_2d = b_.reshape((b.shape[-2], -1))\n            ret = a @ b_2d\n            ret = ret.reshape(a.shape[0], *b_.shape[1:])\n        elif sparse.issparse(b):\n            # sparse is always 2D. Implies a is 3D+\n            # [k, ..., l, m] @ [i, j] -> [k, ..., l, j]\n            a_2d = a.reshape(-1, a.shape[-1])\n            ret = a_2d @ b\n            ret = ret.reshape(*a.shape[:-1], b.shape[1])\n        else:\n            # Alternative for `np.dot` when dealing with a or b having\n            # more than 2 dimensions, that works with the array api.\n            # If b is 1-dim then the last axis for b is taken otherwise\n            # if b is >= 2-dim then the second to last axis is taken.\n            b_axis = -1 if b.ndim == 1 else -2\n            ret = xp.tensordot(a, b, axes=[-1, b_axis])\n    elif (\n        dense_output\n        and a.ndim == 2\n        and b.ndim == 2\n        and a.dtype in (np.float32, np.float64)\n        and b.dtype in (np.float32, np.float64)\n        and (sparse.issparse(a) and a.format in (\"csc\", \"csr\"))\n        and (sparse.issparse(b) and b.format in (\"csc\", \"csr\"))\n    ):\n        # Use dedicated fast method for dense_C = sparse_A @\u00a0sparse_B\n        return sparse_matmul_to_dense(a, b)\n    else:\n        ret = a @ b\n\n    if (\n        sparse.issparse(a)\n        and sparse.issparse(b)\n        and dense_output\n        and hasattr(ret, \"toarray\")\n    ):\n        return ret.toarray()\n    return ret",
    "scikit-learn.sklearn.utils.extmath.row_norms": "def row_norms(X, squared=False):\n    \"\"\"Row-wise (squared) Euclidean norm of X.\n\n    Equivalent to np.sqrt((X * X).sum(axis=1)), but also supports sparse\n    matrices and does not create an X.shape-sized temporary.\n\n    Performs no input validation.\n\n    Parameters\n    ----------\n    X : array-like\n        The input array.\n    squared : bool, default=False\n        If True, return squared norms.\n\n    Returns\n    -------\n    array-like\n        The row-wise (squared) Euclidean norm of X.\n    \"\"\"\n    if sparse.issparse(X):\n        X = X.tocsr()\n        norms = csr_row_norms(X)\n        if not squared:\n            norms = np.sqrt(norms)\n    else:\n        xp, _ = get_namespace(X)\n        if _is_numpy_namespace(xp):\n            X = np.asarray(X)\n            norms = np.einsum(\"ij,ij->i\", X, X)\n            norms = xp.asarray(norms)\n        else:\n            norms = xp.sum(xp.multiply(X, X), axis=1)\n        if not squared:\n            norms = xp.sqrt(norms)\n    return norms"
}