{
    "matplotlib.lib.matplotlib.colors._vector_magnitude": "def _vector_magnitude(arr):\n    # things that don't work here:\n    #  * np.linalg.norm: drops mask from ma.array\n    #  * np.sum: drops mask from ma.array unless entire vector is masked\n    sum_sq = 0\n    for i in range(arr.shape[-1]):\n        sum_sq += arr[..., i, np.newaxis] ** 2\n    return np.sqrt(sum_sq)",
    "matplotlib.lib.matplotlib.colors.shade_normals": "def shade_normals(self, normals, fraction=1.):\n    \"\"\"\n    Calculate the illumination intensity for the normal vectors of a\n    surface using the defined azimuth and elevation for the light source.\n\n    Imagine an artificial sun placed at infinity in some azimuth and\n    elevation position illuminating our surface. The parts of the surface\n    that slope toward the sun should brighten while those sides facing away\n    should become darker.\n\n    Parameters\n    ----------\n    fraction : number, optional\n        Increases or decreases the contrast of the hillshade.  Values\n        greater than one will cause intermediate values to move closer to\n        full illumination or shadow (and clipping any values that move\n        beyond 0 or 1). Note that this is not visually or mathematically\n        the same as vertical exaggeration.\n\n    Returns\n    -------\n    `~numpy.ndarray`\n        A 2D array of illumination values between 0-1, where 0 is\n        completely in shadow and 1 is completely illuminated.\n    \"\"\"\n\n    intensity = normals.dot(self.direction)\n\n    # Apply contrast stretch\n    imin, imax = intensity.min(), intensity.max()\n    intensity *= fraction\n\n    # Rescale to 0-1, keeping range before contrast stretch\n    # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n    # fully occluded 0, etc.)\n    if (imax - imin) > 1e-6:\n        # Strictly speaking, this is incorrect. Negative values should be\n        # clipped to 0 because they're fully occluded. However, rescaling\n        # in this manner is consistent with the previous implementation and\n        # visually appears better than a \"hard\" clip.\n        intensity -= imin\n        intensity /= (imax - imin)\n    intensity = np.clip(intensity, 0, 1)\n\n    return intensity"
}