{
    "sympy.sympy.assumptions.assume.__new__": "def __new__(cls, predicate, *args):\n    if not isinstance(predicate, Predicate):\n        raise TypeError(f\"{predicate} is not a Predicate.\")\n    args = map(_sympify, args)\n    return super().__new__(cls, predicate, *args)",
    "sympy.sympy.calculus.accumulationbounds.__new__": "def __new__(cls, min, max) -> Expr: # type: ignore\n\n    min = _sympify(min)\n    max = _sympify(max)\n\n    # Only allow real intervals (use symbols with 'is_extended_real=True').\n    if not min.is_extended_real or not max.is_extended_real:\n        raise ValueError(\"Only real AccumulationBounds are supported\")\n\n    if max == min:\n        return max\n\n    # Make sure that the created AccumBounds object will be valid.\n    if max.is_number and min.is_number:\n        bad = max.is_comparable and min.is_comparable and max < min\n    else:\n        bad = (max - min).is_extended_negative\n    if bad:\n        raise ValueError(\n            \"Lower limit should be smaller than upper limit\")\n\n    return Basic.__new__(cls, min, max)",
    "sympy.sympy.combinatorics.permutations.__new__": "def __new__(cls, perm, x, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    perm = _sympify(perm)\n    x = _sympify(x)\n\n    if not isinstance(perm, Permutation):\n        raise ValueError(\"{} must be a Permutation instance.\"\n            .format(perm))\n\n    if evaluate:\n        if x.is_Integer:\n            return perm.apply(x)\n\n    obj = super().__new__(cls, perm, x)\n    return obj",
    "sympy.sympy.concrete.products.__new__": "def __new__(cls, function, *symbols, **assumptions):\n    obj = ExprWithIntLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.core.basic._xreplace": "def _xreplace(self, rule):\n    \"\"\"\n    Helper for xreplace. Tracks whether a replacement actually occurred.\n    \"\"\"\n    if self in rule:\n        return rule[self], True\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            _xreplace = getattr(a, '_xreplace', None)\n            if _xreplace is not None:\n                a_xr = _xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            else:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return self.func(*args), True\n    return self, False",
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.core.rules.__contains__": "def __contains__(self, item):\n    return self._filter(item)",
    "sympy.sympy.core.rules.__getitem__": "def __getitem__(self, key):\n    if self._filter(key):\n        return self._transform(key)\n    else:\n        raise KeyError(key)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.diffgeom.diffgeom.__new__": "def __new__(cls, name, dim, **kwargs):\n    if not isinstance(name, Str):\n        name = Str(name)\n    dim = _sympify(dim)\n    obj = super().__new__(cls, name, dim)\n\n    obj.patches = _deprecated_list(\n        \"\"\"\n        Manifold.patches is deprecated. The Manifold object is now\n        immutable. Instead use a separate list to keep track of the\n        patches.\n        \"\"\", [])\n    return obj",
    "sympy.sympy.functions.elementary.miscellaneous.__new__": "def __new__(cls, *args, **assumptions):\n    from sympy.core.parameters import global_parameters\n    evaluate = assumptions.pop('evaluate', global_parameters.evaluate)\n    args = (sympify(arg) for arg in args)\n\n    # first standard filter, for cls.zero and cls.identity\n    # also reshape Max(a, Max(b, c)) to Max(a, b, c)\n\n    if evaluate:\n        try:\n            args = frozenset(cls._new_args_filter(args))\n        except ShortCircuit:\n            return cls.zero\n        # remove redundant args that are easily identified\n        args = cls._collapse_arguments(args, **assumptions)\n        # find local zeros\n        args = cls._find_localzeros(args, **assumptions)\n    args = frozenset(args)\n\n    if not args:\n        return cls.identity\n\n    if len(args) == 1:\n        return list(args).pop()\n\n    # base creation\n    obj = Expr.__new__(cls, *ordered(args), **assumptions)\n    obj._argset = args\n    return obj",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.functions.special.hyper.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 5:\n        args = [(args[0], args[1]), (args[2], args[3]), args[4]]\n    if len(args) != 3:\n        raise TypeError(\"args must be either as, as', bs, bs', z or \"\n                        \"as, bs, z\")\n\n    def tr(p):\n        if len(p) != 2:\n            raise TypeError(\"wrong argument\")\n        p = [list(ordered(i)) for i in p]\n        return TupleArg(_prep_tuple(p[0]), _prep_tuple(p[1]))\n\n    arg0, arg1 = tr(args[0]), tr(args[1])\n    if Tuple(arg0, arg1).has(oo, zoo, -oo):\n        raise ValueError(\"G-function parameters must be finite\")\n    if any((a - b).is_Integer and a - b > 0\n           for a in arg0[0] for b in arg1[0]):\n        raise ValueError(\"no parameter a1, ..., an may differ from \"\n                     \"any b1, ..., bm by a positive integer\")\n\n    # TODO should we check convergence conditions?\n    return super().__new__(cls, arg0, arg1, args[2], **kwargs)",
    "sympy.sympy.geometry.ellipse.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.geometry.ellipse.__new__": "def __new__(\n    cls, center=None, hradius=None, vradius=None, eccentricity=None, **kwargs):\n\n    hradius = sympify(hradius)\n    vradius = sympify(vradius)\n\n    if center is None:\n        center = Point(0, 0)\n    else:\n        if len(center) != 2:\n            raise ValueError('The center of \"{}\" must be a two dimensional point'.format(cls))\n        center = Point(center, dim=2)\n\n    if len(list(filter(lambda x: x is not None, (hradius, vradius, eccentricity)))) != 2:\n        raise ValueError(filldedent('''\n            Exactly two arguments of \"hradius\", \"vradius\", and\n            \"eccentricity\" must not be None.'''))\n\n    if eccentricity is not None:\n        eccentricity = sympify(eccentricity)\n        if eccentricity.is_negative:\n            raise GeometryError(\"Eccentricity of ellipse/circle should lie between [0, 1)\")\n        elif hradius is None:\n            hradius = vradius / sqrt(1 - eccentricity**2)\n        elif vradius is None:\n            vradius = hradius * sqrt(1 - eccentricity**2)\n\n    if hradius == vradius:\n        return Circle(center, hradius, **kwargs)\n\n    if S.Zero in (hradius, vradius):\n        return Segment(Point(center[0] - hradius, center[1] - vradius), Point(center[0] + hradius, center[1] + vradius))\n\n    if hradius.is_real is False or vradius.is_real is False:\n        raise GeometryError(\"Invalid value encountered when computing hradius / vradius.\")\n\n    return GeometryEntity.__new__(cls, center, hradius, vradius, **kwargs)",
    "sympy.sympy.geometry.point.__hash__": "def __hash__(self):\n    return hash(self.args)",
    "sympy.sympy.geometry.point.__new__": "def __new__(cls, *args, _nocheck=False, **kwargs):\n    if not _nocheck:\n        kwargs['dim'] = 2\n        args = Point(*args, **kwargs)\n    return GeometryEntity.__new__(cls, *args)",
    "sympy.sympy.geometry.polygon.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) != 3:\n        if 'sss' in kwargs:\n            return _sss(*[simplify(a) for a in kwargs['sss']])\n        if 'asa' in kwargs:\n            return _asa(*[simplify(a) for a in kwargs['asa']])\n        if 'sas' in kwargs:\n            return _sas(*[simplify(a) for a in kwargs['sas']])\n        msg = \"Triangle instantiates with three points or a valid keyword.\"\n        raise GeometryError(msg)\n\n    vertices = [Point(a, dim=2, **kwargs) for a in args]\n\n    # remove consecutive duplicates\n    nodup = []\n    for p in vertices:\n        if nodup and p == nodup[-1]:\n            continue\n        nodup.append(p)\n    if len(nodup) > 1 and nodup[-1] == nodup[0]:\n        nodup.pop()  # last point was same as first\n\n    # remove collinear points\n    i = -3\n    while i < len(nodup) - 3 and len(nodup) > 2:\n        a, b, c = sorted(\n            [nodup[i], nodup[i + 1], nodup[i + 2]], key=default_sort_key)\n        if Point.is_collinear(a, b, c):\n            nodup[i] = a\n            nodup[i + 1] = None\n            nodup.pop(i + 1)\n        i += 1\n\n    vertices = list(filter(lambda x: x is not None, nodup))\n\n    if len(vertices) == 3:\n        return GeometryEntity.__new__(cls, *vertices, **kwargs)\n    elif len(vertices) == 2:\n        return Segment(*vertices, **kwargs)\n    else:\n        return Point(*vertices, **kwargs)",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.logic.boolalg.__new__": "def __new__(cls, *args, **kwargs):\n    from sympy.core.relational import Eq, Ne\n    if len(args) != 3:\n        raise ValueError('expecting exactly 3 args')\n    a, b, c = args\n    # check use of binary symbols\n    if isinstance(a, (Eq, Ne)):\n        # in this context, we can evaluate the Eq/Ne\n        # if one arg is a binary symbol and the other\n        # is true/false\n        b, c = map(as_Boolean, (b, c))\n        bin_syms = set().union(*[i.binary_symbols for i in (b, c)])\n        if len(set(a.args) - bin_syms) == 1:\n            # one arg is a binary_symbols\n            _a = a\n            if a.lhs is true:\n                a = a.rhs\n            elif a.rhs is true:\n                a = a.lhs\n            elif a.lhs is false:\n                a = Not(a.rhs)\n            elif a.rhs is false:\n                a = Not(a.lhs)\n            else:\n                # binary can only equal True or False\n                a = false\n            if isinstance(_a, Ne):\n                a = Not(a)\n    else:\n        a, b, c = BooleanFunction.binary_check_and_simplify(\n            a, b, c)\n    rv = None\n    if kwargs.get('evaluate', True):\n        rv = cls.eval(a, b, c)\n    if rv is None:\n        rv = BooleanFunction.__new__(cls, a, b, c, evaluate=False)\n    return rv",
    "sympy.sympy.logic.boolalg.__hash__": "def __hash__(self):\n    return hash(False)",
    "sympy.sympy.matrices.expressions.matadd.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericZeroMatrix().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n\n    if not all(isinstance(arg, MatrixExpr) for arg in args):\n        raise TypeError(\"Mix of Matrix and Scalar symbols\")\n\n    obj = Basic.__new__(cls, *args)\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatAdd is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*args)\n\n    if evaluate:\n        obj = cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, *args, **kwargs):\n    args = map(_sympify, args)\n    return Basic.__new__(cls, *args, **kwargs)",
    "sympy.sympy.matrices.expressions.matmul.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericIdentity().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatMul is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*matrices)\n\n    if not matrices:\n        # Should it be\n        #\n        # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n        return factor\n\n    if evaluate:\n        return cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.matpow.__new__": "def __new__(cls, base, exp, evaluate=False, **options) -> MatrixExpr: # type: ignore\n    base = _sympify(base)\n    if not base.is_Matrix:\n        raise TypeError(\"MatPow base should be a matrix\")\n\n    if base.is_square is False:\n        raise NonSquareMatrixError(\"Power of non-square matrix %s\" % base)\n\n    exp = _sympify(exp)\n    obj = super().__new__(cls, base, exp)\n\n    if evaluate:\n        obj = obj.doit(deep=False)\n\n    return obj",
    "sympy.sympy.matrices.expressions.special.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.matrices.expressions.trace.__new__": "def __new__(cls, mat):\n    mat = sympify(mat)\n\n    if not mat.is_Matrix:\n        raise TypeError(\"input to Trace, %s, is not a matrix\" % str(mat))\n\n    if mat.is_square is False:\n        raise NonSquareMatrixError(\"Trace of a non-square matrix\")\n\n    return Basic.__new__(cls, mat)",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.matrices.immutable.__hash__": "def __hash__(self):\n    return MatrixExpr.__hash__(self)",
    "sympy.sympy.physics.control.lti.__new__": "def __new__(cls, A=None, B=None, C=None, D=None, sampling_time=1):\n    if sampling_time == 0:\n        raise ValueError(filldedent(\"\"\"\n            The sampling time cannot be zero.\n            If you want to create a continuous state space,\n            use the StateSpace class instead.\"\"\"))\n\n    sampling_time = sympify(sampling_time)\n    obj = super(DiscreteStateSpace, cls).__new__(cls, A, B, C, D, sampling_time)\n    obj._sampling_time = sampling_time\n\n    return obj",
    "sympy.sympy.physics.quantum.cg.__new__": "def __new__(cls, j1, m1, j2, m2, j3, m3):\n    args = map(sympify, (j1, m1, j2, m2, j3, m3))\n    return Expr.__new__(cls, *args)",
    "sympy.sympy.physics.quantum.dagger.__new__": "def __new__(cls, arg, evaluate=True):\n    if hasattr(arg, 'adjoint') and evaluate:\n        return arg.adjoint()\n    elif hasattr(arg, 'conjugate') and hasattr(arg, 'transpose') and evaluate:\n        return arg.conjugate().transpose()\n    return Expr.__new__(cls, sympify(arg))",
    "sympy.sympy.physics.quantum.operator.__new__": "def __new__(cls, *args, **old_assumptions):\n    from sympy.physics.quantum.state import KetBase, BraBase\n\n    if len(args) != 2:\n        raise ValueError('2 parameters expected, got %d' % len(args))\n\n    ket_expr = expand(args[0])\n    bra_expr = expand(args[1])\n\n    if (isinstance(ket_expr, (KetBase, Mul)) and\n            isinstance(bra_expr, (BraBase, Mul))):\n        ket_c, kets = ket_expr.args_cnc()\n        bra_c, bras = bra_expr.args_cnc()\n\n        if len(kets) != 1 or not isinstance(kets[0], KetBase):\n            raise TypeError('KetBase subclass expected'\n                            ', got: %r' % Mul(*kets))\n\n        if len(bras) != 1 or not isinstance(bras[0], BraBase):\n            raise TypeError('BraBase subclass expected'\n                            ', got: %r' % Mul(*bras))\n\n        if not kets[0].dual_class() == bras[0].__class__:\n            raise TypeError(\n                'ket and bra are not dual classes: %r, %r' %\n                (kets[0].__class__, bras[0].__class__)\n                )\n\n        # TODO: make sure the hilbert spaces of the bra and ket are\n        # compatible\n        obj = Expr.__new__(cls, *(kets[0], bras[0]), **old_assumptions)\n        obj.hilbert_space = kets[0].hilbert_space\n        return Mul(*(ket_c + bra_c)) * obj\n\n    op_terms = []\n    if isinstance(ket_expr, Add) and isinstance(bra_expr, Add):\n        for ket_term in ket_expr.args:\n            for bra_term in bra_expr.args:\n                op_terms.append(OuterProduct(ket_term, bra_term,\n                                             **old_assumptions))\n    elif isinstance(ket_expr, Add):\n        for ket_term in ket_expr.args:\n            op_terms.append(OuterProduct(ket_term, bra_expr,\n                                         **old_assumptions))\n    elif isinstance(bra_expr, Add):\n        for bra_term in bra_expr.args:\n            op_terms.append(OuterProduct(ket_expr, bra_term,\n                                         **old_assumptions))\n    else:\n        raise TypeError(\n            'Expected ket and bra expression, got: %r, %r' %\n            (ket_expr, bra_expr)\n            )\n\n    return Add(*op_terms)",
    "sympy.sympy.physics.quantum.qexpr.__new__": "def __new__(cls, *args, **kwargs):\n    \"\"\"Construct a new quantum object.\n\n    Parameters\n    ==========\n\n    args : tuple\n        The list of numbers or parameters that uniquely specify the\n        quantum object. For a state, this will be its symbol or its\n        set of quantum numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.qexpr import QExpr\n    >>> q = QExpr(0)\n    >>> q\n    0\n    >>> q.label\n    (0,)\n    >>> q.hilbert_space\n    H\n    >>> q.args\n    (0,)\n    >>> q.is_commutative\n    False\n    \"\"\"\n\n    # First compute args and call Expr.__new__ to create the instance\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    # Now set the slots on the instance\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    "sympy.sympy.physics.quantum.spin.__new__": "def __new__(cls, j, m):\n    j = sympify(j)\n    m = sympify(m)\n    if j.is_number:\n        if 2*j != int(2*j):\n            raise ValueError(\n                'j must be integer or half-integer, got: %s' % j)\n        if j < 0:\n            raise ValueError('j must be >= 0, got: %s' % j)\n    if m.is_number:\n        if 2*m != int(2*m):\n            raise ValueError(\n                'm must be integer or half-integer, got: %s' % m)\n    if j.is_number and m.is_number:\n        if abs(m) > j:\n            raise ValueError('Allowed values for m are -j <= m <= j, got j, m: %s, %s' % (j, m))\n        if int(j - m) != j - m:\n            raise ValueError('Both j and m must be integer or half-integer, got j, m: %s, %s' % (j, m))\n    return State.__new__(cls, j, m)",
    "sympy.sympy.physics.quantum.tensorproduct.__new__": "def __new__(cls, *args):\n    if isinstance(args[0], (Matrix, ImmutableMatrix, numpy_ndarray,\n                                                scipy_sparse_matrix)):\n        return matrix_tensor_product(*args)\n    c_part, new_args = cls.flatten(sympify(args))\n    c_part = Mul(*c_part)\n    if len(new_args) == 0:\n        return c_part\n    elif len(new_args) == 1:\n        return c_part * new_args[0]\n    else:\n        tp = Expr.__new__(cls, *new_args)\n        return c_part * tp",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.polytools.__new__": "def __new__(cls, rep, *gens, **args) -> Self:\n    \"\"\"Create a new polynomial instance out of something useful. \"\"\"\n    opt = options.build_options(gens, args)\n\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n\n    if isinstance(rep, (DMP, DMF, ANP, DomainElement)):\n        return cls._from_domain_element(rep, opt)\n    elif iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep, evaluate=type(rep) is not str) # type: ignore\n\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    "sympy.sympy.polys.polytools.args": "@property\ndef args(self):\n    return (self.expr,) + self.gens",
    "sympy.sympy.polys.polytools.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.polys.rootoftools.args": "@property\ndef args(self):\n    return (self.expr, Integer(self.index))",
    "sympy.sympy.series.formal.__new__": "def __new__(cls, *args):\n    args = map(sympify, args)\n    return Expr.__new__(cls, *args)",
    "sympy.sympy.series.formal.__init__": "def __init__(self, *args):\n    ak = args[4][0]\n    k = ak.variables[0]\n    self.ak_seq = sequence(ak.formula, (k, 1, oo))\n    self.fact_seq = sequence(factorial(k), (k, 1, oo))\n    self.bell_coeff_seq = self.ak_seq * self.fact_seq\n    self.sign_seq = sequence((-1, 1), (k, 1, oo))",
    "sympy.sympy.series.sequences.__new__": "def __new__(cls, formula, limits=None):\n    formula = sympify(formula)\n\n    def _find_x(formula):\n        free = formula.free_symbols\n        if len(free) == 1:\n            return free.pop()\n        elif not free:\n            return Dummy('k')\n        else:\n            raise ValueError(\n                \" specify dummy variables for %s. If the formula contains\"\n                \" more than one free symbol, a dummy variable should be\"\n                \" supplied explicitly e.g., SeqFormula(m*n**2, (n, 0, 5))\"\n                % formula)\n\n    x, start, stop = None, None, None\n    if limits is None:\n        x, start, stop = _find_x(formula), 0, S.Infinity\n    if is_sequence(limits, Tuple):\n        if len(limits) == 3:\n            x, start, stop = limits\n        elif len(limits) == 2:\n            x = _find_x(formula)\n            start, stop = limits\n\n    if not isinstance(x, (Symbol, Idx)) or start is None or stop is None:\n        raise ValueError('Invalid limits given: %s' % str(limits))\n\n    if start is S.NegativeInfinity and stop is S.Infinity:\n            raise ValueError(\"Both the start and end value \"\n                             \"cannot be unbounded\")\n    limits = sympify((x, start, stop))\n\n    if Interval(limits[1], limits[2]) is S.EmptySet:\n        return S.EmptySequence\n\n    return Basic.__new__(cls, formula, limits)",
    "sympy.sympy.sets.conditionset.__new__": "    def __new__(cls, sym, condition, base_set=S.UniversalSet):\n        sym = _sympify(sym)\n        flat = flatten([sym])\n        if has_dups(flat):\n            raise BadSignatureError(\"Duplicate symbols detected\")\n        base_set = _sympify(base_set)\n        if not isinstance(base_set, Set):\n            raise TypeError(\n                'base set should be a Set object, not %s' % base_set)\n        condition = _sympify(condition)\n\n        if isinstance(condition, FiniteSet):\n            condition_orig = condition\n            temp = (Eq(lhs, 0) for lhs in condition)\n            condition = And(*temp)\n            sympy_deprecation_warning(\n                f\"\"\"\nUsing a set for the condition in ConditionSet is deprecated. Use a boolean\ninstead.\n\nIn this case, replace\n\n    {condition_orig}\n\nwith\n\n    {condition}\n\"\"\",\n                deprecated_since_version='1.5',\n                active_deprecations_target=\"deprecated-conditionset-set\",\n                )\n\n        condition = as_Boolean(condition)\n\n        if condition is S.true:\n            return base_set\n\n        if condition is S.false:\n            return S.EmptySet\n\n        if base_set is S.EmptySet:\n            return S.EmptySet\n\n        # no simple answers, so now check syms\n        for i in flat:\n            if not getattr(i, '_diff_wrt', False):\n                raise ValueError('`%s` is not symbol-like' % i)\n\n        if base_set.contains(sym) is S.false:\n            raise TypeError('sym `%s` is not in base_set `%s`' % (sym, base_set))\n\n        know = None\n        if isinstance(base_set, FiniteSet):\n            sifted = sift(\n                base_set, lambda _: fuzzy_bool(condition.subs(sym, _)))\n            if sifted[None]:\n                know = FiniteSet(*sifted[True])\n                base_set = FiniteSet(*sifted[None])\n            else:\n                return FiniteSet(*sifted[True])\n\n        if isinstance(base_set, cls):\n            s, c, b = base_set.args\n            def sig(s):\n                return cls(s, Eq(adummy, 0)).as_dummy().sym\n            sa, sb = map(sig, (sym, s))\n            if sa != sb:\n                raise BadSignatureError('sym does not match sym of base set')\n            reps = dict(zip(flatten([sym]), flatten([s])))\n            if s == sym:\n                condition = And(condition, c)\n                base_set = b\n            elif not c.free_symbols & sym.free_symbols:\n                reps = {v: k for k, v in reps.items()}\n                condition = And(condition, c.xreplace(reps))\n                base_set = b\n            elif not condition.free_symbols & s.free_symbols:\n                sym = sym.xreplace(reps)\n                condition = And(condition.xreplace(reps), c)\n                base_set = b\n\n        # flatten ConditionSet(Contains(ConditionSet())) expressions\n        if isinstance(condition, Contains) and (sym == condition.args[0]):\n            if isinstance(condition.args[1], Set):\n                return condition.args[1].intersect(base_set)\n\n        rv = Basic.__new__(cls, sym, condition, base_set)\n        return rv if know is None else Union(know, rv)",
    "sympy.sympy.sets.contains.__new__": "def __new__(cls, x, s, evaluate=None):\n    x = sympify(x)\n    s = sympify(s)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not isinstance(s, Set):\n        raise TypeError('expecting Set, not %s' % func_name(s))\n\n    if evaluate:\n        # _contains can return symbolic booleans that would be returned by\n        # s.contains(x) but here for Contains(x, s) we only evaluate to\n        # true, false or return the unevaluated Contains.\n        result = s._contains(x)\n\n        if isinstance(result, Boolean):\n            if result in (S.true, S.false):\n                return result\n        elif result is not None:\n            raise TypeError(\"_contains() should return Boolean or None\")\n\n    return super().__new__(cls, x, s)",
    "sympy.sympy.sets.fancysets.__hash__": "def __hash__(self):\n    return hash(Interval(S.NegativeInfinity, S.Infinity))",
    "sympy.sympy.sets.fancysets.__new__": "def __new__(cls, flambda, *sets):\n    if not isinstance(flambda, Lambda):\n        raise ValueError('First argument must be a Lambda')\n\n    signature = flambda.signature\n\n    if len(signature) != len(sets):\n        raise ValueError('Incompatible signature')\n\n    sets = [_sympify(s) for s in sets]\n\n    if not all(isinstance(s, Set) for s in sets):\n        raise TypeError(\"Set arguments to ImageSet should of type Set\")\n\n    if not all(cls._check_sig(sg, st) for sg, st in zip(signature, sets)):\n        raise ValueError(\"Signature %s does not match sets %s\" % (signature, sets))\n\n    if flambda is S.IdentityFunction and len(sets) == 1:\n        return sets[0]\n\n    if not set(flambda.variables) & flambda.expr.free_symbols:\n        is_empty = fuzzy_or(s.is_empty for s in sets)\n        if is_empty == True:\n            return S.EmptySet\n        elif is_empty == False:\n            return FiniteSet(flambda.expr)\n\n    return Basic.__new__(cls, flambda, *sets)",
    "sympy.sympy.sets.sets.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n\n    # keep the form of the first canonical arg\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                # e.g. i = class without args like `Interval`\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    "sympy.sympy.sets.sets.args": "@property\ndef args(self):\n    return self._args",
    "sympy.sympy.sets.sets.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.simplify.hyperexpand.__new__": "def __new__(cls, ap, bq):\n    obj = super().__new__(cls)\n    obj.ap = Tuple(*list(map(expand, ap)))\n    obj.bq = Tuple(*list(map(expand, bq)))\n    return obj",
    "sympy.sympy.simplify.hyperexpand.args": "@property\ndef args(self):\n    return (self.ap, self.bq)",
    "sympy.sympy.stats.compound_rv.__new__": "def __new__(cls, s, distribution):\n    s = _symbol_converter(s)\n    if isinstance(distribution, ContinuousDistribution):\n        return SingleContinuousPSpace(s, distribution)\n    if isinstance(distribution, DiscreteDistribution):\n        return SingleDiscretePSpace(s, distribution)\n    if isinstance(distribution, SingleFiniteDistribution):\n        return SingleFinitePSpace(s, distribution)\n    if not isinstance(distribution, CompoundDistribution):\n        raise ValueError(\"%s should be an isinstance of \"\n                    \"CompoundDistribution\"%(distribution))\n    return Basic.__new__(cls, s, distribution)",
    "sympy.sympy.stats.drv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.random_matrix.__new__": "def __new__(cls, sym, model=None):\n    sym = _symbol_converter(sym)\n    if model:\n        return Basic.__new__(cls, sym, model)\n    else:\n        return Basic.__new__(cls, sym)",
    "sympy.sympy.stats.random_matrix_models.__new__": "def __new__(cls, sym, dim=None):\n    sym, dim = _symbol_converter(sym), _sympify(dim)\n    if dim.is_integer == False:\n        raise ValueError(\"Dimension of the random matrices must be \"\n                            \"integers, received %s instead.\"%(dim))\n    return Basic.__new__(cls, sym, dim)",
    "sympy.sympy.stats.rv.__new__": "def __new__(cls, symbol, n, m, pspace=None):\n    n, m = _sympify(n), _sympify(m)\n    symbol = _symbol_converter(symbol)\n    if pspace is None:\n        # Allow single arg, representing pspace == PSpace()\n        pspace = PSpace()\n    return Basic.__new__(cls, symbol, n, m, pspace)",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, prob, condition=None, **kwargs):\n    prob = _sympify(prob)\n    if condition is None:\n        obj = Expr.__new__(cls, prob)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, prob, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.tensor.array.expressions.array_expressions.__new__": "def __new__(cls, name, indices):\n    if isinstance(name, str):\n        name = Symbol(name)\n    name = _sympify(name)\n    if not isinstance(indices, collections.abc.Iterable):\n        indices = (indices,)\n    indices = _sympify(tuple(indices))\n    cls._check_shape(name, indices)\n    obj = Expr.__new__(cls, name, indices)\n    return obj",
    "sympy.sympy.tensor.indexed.__new__": "def __new__(cls, base, *args, **kw_args):\n    from sympy.tensor.array.ndim_array import NDimArray\n    from sympy.matrices.matrixbase import MatrixBase\n\n    if not args:\n        raise IndexException(\"Indexed needs at least one index.\")\n    if isinstance(base, (str, Symbol)):\n        base = IndexedBase(base)\n    elif not hasattr(base, '__getitem__') and not isinstance(base, IndexedBase):\n        raise TypeError(filldedent(\"\"\"\n            The base can only be replaced with a string, Symbol,\n            IndexedBase or an object with a method for getting\n            items (i.e. an object with a `__getitem__` method).\n            \"\"\"))\n    args = list(map(sympify, args))\n    if isinstance(base, (NDimArray, Iterable, Tuple, MatrixBase)) and all(i.is_number for i in args):\n        if len(args) == 1:\n            return base[args[0]]\n        else:\n            return base[args]\n\n    base = _sympify(base)\n\n    obj = Expr.__new__(cls, base, *args, **kw_args)\n\n    IndexedBase._set_assumptions(obj, base.assumptions0)\n\n    return obj",
    "sympy.sympy.tensor.tensor.__new__": "def __new__(cls, tensor_head, indices, **kw_args):\n    is_canon_bp = kw_args.pop(\"is_canon_bp\", False)\n\n    if tensor_head.func == TensorHead:\n        \"\"\"\n        If someone tried to call WildTensor by supplying a TensorHead (not a WildTensorHead), return a normal tensor instead. This is helpful when using subs on an expression to replace occurrences of a WildTensorHead with a TensorHead.\n        \"\"\"\n        return Tensor(tensor_head, indices, is_canon_bp=is_canon_bp, **kw_args)\n    elif tensor_head.func == _WildTensExpr:\n        return tensor_head(*indices)\n\n    indices = cls._parse_indices(tensor_head, indices)\n    index_types = [ind.tensor_index_type for ind in indices]\n    tensor_head = tensor_head.func(\n        tensor_head.name,\n        index_types,\n        symmetry=None,\n        comm=tensor_head.comm,\n        unordered_indices=tensor_head.unordered_indices,\n        )\n\n    obj = Basic.__new__(cls, tensor_head, Tuple(*indices))\n    obj.name = tensor_head.name\n    obj._index_structure = _IndexStructure.from_indices(*indices)\n    obj._free = obj._index_structure.free[:]\n    obj._dum = obj._index_structure.dum[:]\n    obj._ext_rank = obj._index_structure._ext_rank\n    obj._coeff = S.One\n    obj._nocoeff = obj\n    obj._component = tensor_head\n    obj._components = [tensor_head]\n    if tensor_head.rank != len(indices):\n        raise ValueError(\"wrong number of indices\")\n    obj.is_canon_bp = is_canon_bp\n    obj._index_map = obj._build_index_map(indices, obj._index_structure)\n\n    return obj",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1",
    "sympy.sympy.vector.basisdependent.__hash__": "def __hash__(self):\n    return self._hash",
    "sympy.sympy.vector.coordsysrect.__init__": "def __init__(self, name, location=None, rotation_matrix=None,\n             parent=None, vector_names=None, variable_names=None,\n             latex_vects=None, pretty_vects=None, latex_scalars=None,\n             pretty_scalars=None, transformation=None):\n    # Dummy initializer for setting docstring\n    pass",
    "sympy.sympy.vector.coordsysrect.__new__": "def __new__(cls, name, transformation=None, parent=None, location=None,\n            rotation_matrix=None, vector_names=None, variable_names=None):\n    \"\"\"\n    The orientation/location parameters are necessary if this system\n    is being defined at a certain orientation or location wrt another.\n\n    Parameters\n    ==========\n\n    name : str\n        The name of the new CoordSys3D instance.\n\n    transformation : Lambda, Tuple, str\n        Transformation defined by transformation equations or chosen\n        from predefined ones.\n\n    location : Vector\n        The position vector of the new system's origin wrt the parent\n        instance.\n\n    rotation_matrix : SymPy ImmutableMatrix\n        The rotation matrix of the new coordinate system with respect\n        to the parent. In other words, the output of\n        new_system.rotation_matrix(parent).\n\n    parent : CoordSys3D\n        The coordinate system wrt which the orientation/location\n        (or both) is being defined.\n\n    vector_names, variable_names : iterable(optional)\n        Iterables of 3 strings each, with custom names for base\n        vectors and base scalars of the new system respectively.\n        Used for simple str printing.\n\n    \"\"\"\n\n    name = str(name)\n    Vector = sympy.vector.Vector\n    Point = sympy.vector.Point\n\n    if not isinstance(name, str):\n        raise TypeError(\"name should be a string\")\n\n    if transformation is not None:\n        if (location is not None) or (rotation_matrix is not None):\n            raise ValueError(\"specify either `transformation` or \"\n                             \"`location`/`rotation_matrix`\")\n        if isinstance(transformation, (Tuple, tuple, list)):\n            if isinstance(transformation[0], MatrixBase):\n                rotation_matrix = transformation[0]\n                location = transformation[1]\n            else:\n                transformation = Lambda(transformation[0],\n                                        transformation[1])\n        elif isinstance(transformation, Callable):\n            x1, x2, x3 = symbols('x1 x2 x3', cls=Dummy)\n            transformation = Lambda((x1, x2, x3),\n                                    transformation(x1, x2, x3))\n        elif isinstance(transformation, str):\n            transformation = Str(transformation)\n        elif isinstance(transformation, (Str, Lambda)):\n            pass\n        else:\n            raise TypeError(\"transformation: \"\n                            \"wrong type {}\".format(type(transformation)))\n\n    # If orientation information has been provided, store\n    # the rotation matrix accordingly\n    if rotation_matrix is None:\n        rotation_matrix = ImmutableDenseMatrix(eye(3))\n    else:\n        if not isinstance(rotation_matrix, MatrixBase):\n            raise TypeError(\"rotation_matrix should be an Immutable\" +\n                            \"Matrix instance\")\n        rotation_matrix = rotation_matrix.as_immutable()\n\n    # If location information is not given, adjust the default\n    # location as Vector.zero\n    if parent is not None:\n        if not isinstance(parent, CoordSys3D):\n            raise TypeError(\"parent should be a \" +\n                            \"CoordSys3D/None\")\n        if location is None:\n            location = Vector.zero\n        else:\n            if not isinstance(location, Vector):\n                raise TypeError(\"location should be a Vector\")\n            # Check that location does not contain base\n            # scalars\n            for x in location.free_symbols:\n                if isinstance(x, BaseScalar):\n                    raise ValueError(\"location should not contain\" +\n                                     \" BaseScalars\")\n        origin = parent.origin.locate_new(name + '.origin',\n                                          location)\n    else:\n        location = Vector.zero\n        origin = Point(name + '.origin')\n\n    if transformation is None:\n        transformation = Tuple(rotation_matrix, location)\n\n    if isinstance(transformation, Tuple):\n        lambda_transformation = CoordSys3D._compose_rotation_and_translation(\n            transformation[0],\n            transformation[1],\n            parent\n        )\n        r, l = transformation\n        l = l._projections\n        lambda_lame = CoordSys3D._get_lame_coeff('cartesian')\n        lambda_inverse = lambda x, y, z: r.inv()*Matrix(\n            [x-l[0], y-l[1], z-l[2]])\n    elif isinstance(transformation, Str):\n        trname = transformation.name\n        lambda_transformation = CoordSys3D._get_transformation_lambdas(trname)\n        if parent is not None:\n            if parent.lame_coefficients() != (S.One, S.One, S.One):\n                raise ValueError('Parent for pre-defined coordinate '\n                             'system should be Cartesian.')\n        lambda_lame = CoordSys3D._get_lame_coeff(trname)\n        lambda_inverse = CoordSys3D._set_inv_trans_equations(trname)\n    elif isinstance(transformation, Lambda):\n        if not CoordSys3D._check_orthogonality(transformation):\n            raise ValueError(\"The transformation equation does not \"\n                             \"create orthogonal coordinate system\")\n        lambda_transformation = transformation\n        lambda_lame = CoordSys3D._calculate_lame_coeff(lambda_transformation)\n        lambda_inverse = None\n    else:\n        lambda_transformation = lambda x, y, z: transformation(x, y, z)\n        lambda_lame = CoordSys3D._get_lame_coeff(transformation)\n        lambda_inverse = None\n\n    if variable_names is None:\n        if isinstance(transformation, Lambda):\n            variable_names = [\"x1\", \"x2\", \"x3\"]\n        elif isinstance(transformation, Str):\n            if transformation.name == 'spherical':\n                variable_names = [\"r\", \"theta\", \"phi\"]\n            elif transformation.name == 'cylindrical':\n                variable_names = [\"r\", \"theta\", \"z\"]\n            else:\n                variable_names = [\"x\", \"y\", \"z\"]\n        else:\n            variable_names = [\"x\", \"y\", \"z\"]\n    if vector_names is None:\n        vector_names = [\"i\", \"j\", \"k\"]\n\n    # All systems that are defined as 'roots' are unequal, unless\n    # they have the same name.\n    # Systems defined at same orientation/position wrt the same\n    # 'parent' are equal, irrespective of the name.\n    # This is true even if the same orientation is provided via\n    # different methods like Axis/Body/Space/Quaternion.\n    # However, coincident systems may be seen as unequal if\n    # positioned/oriented wrt different parents, even though\n    # they may actually be 'coincident' wrt the root system.\n    if parent is not None:\n        obj = super().__new__(\n            cls, Str(name), transformation, parent)\n    else:\n        obj = super().__new__(\n            cls, Str(name), transformation)\n    obj._name = name\n    # Initialize the base vectors\n\n    _check_strings('vector_names', vector_names)\n    vector_names = list(vector_names)\n    latex_vects = [(r'\\mathbf{\\hat{%s}_{%s}}' % (x, name)) for\n                       x in vector_names]\n    pretty_vects = ['%s_%s' % (x, name) for x in vector_names]\n\n    obj._vector_names = vector_names\n\n    v1 = BaseVector(0, obj, pretty_vects[0], latex_vects[0])\n    v2 = BaseVector(1, obj, pretty_vects[1], latex_vects[1])\n    v3 = BaseVector(2, obj, pretty_vects[2], latex_vects[2])\n\n    obj._base_vectors = (v1, v2, v3)\n\n    # Initialize the base scalars\n\n    _check_strings('variable_names', vector_names)\n    variable_names = list(variable_names)\n    latex_scalars = [(r\"\\mathbf{{%s}_{%s}}\" % (x, name)) for\n                     x in variable_names]\n    pretty_scalars = ['%s_%s' % (x, name) for x in variable_names]\n\n    obj._variable_names = variable_names\n    obj._vector_names = vector_names\n\n    x1 = BaseScalar(0, obj, pretty_scalars[0], latex_scalars[0])\n    x2 = BaseScalar(1, obj, pretty_scalars[1], latex_scalars[1])\n    x3 = BaseScalar(2, obj, pretty_scalars[2], latex_scalars[2])\n\n    obj._base_scalars = (x1, x2, x3)\n\n    obj._transformation = transformation\n    obj._transformation_lambda = lambda_transformation\n    obj._lame_coefficients = lambda_lame(x1, x2, x3)\n    obj._transformation_from_parent_lambda = lambda_inverse\n\n    setattr(obj, variable_names[0], x1)\n    setattr(obj, variable_names[1], x2)\n    setattr(obj, variable_names[2], x3)\n\n    setattr(obj, vector_names[0], v1)\n    setattr(obj, vector_names[1], v2)\n    setattr(obj, vector_names[2], v3)\n\n    # Assign params\n    obj._parent = parent\n    if obj._parent is not None:\n        obj._root = obj._parent._root\n    else:\n        obj._root = obj\n\n    obj._parent_rotation_matrix = rotation_matrix\n    obj._origin = origin\n\n    # Return the instance\n    return obj",
    "sympy.sympy.vector.scalar.__new__": "def __new__(cls, index, system, pretty_str=None, latex_str=None):\n    from sympy.vector.coordsysrect import CoordSys3D\n    if pretty_str is None:\n        pretty_str = \"x{}\".format(index)\n    elif isinstance(pretty_str, Symbol):\n        pretty_str = pretty_str.name\n    if latex_str is None:\n        latex_str = \"x_{}\".format(index)\n    elif isinstance(latex_str, Symbol):\n        latex_str = latex_str.name\n\n    index = _sympify(index)\n    system = _sympify(system)\n    obj = super().__new__(cls, index, system)\n    if not isinstance(system, CoordSys3D):\n        raise TypeError(\"system should be a CoordSys3D\")\n    if index not in range(0, 3):\n        raise ValueError(\"Invalid index specified.\")\n    # The _id is used for equating purposes, and for hashing\n    obj._id = (index, system)\n    obj._name = obj.name = system._name + '.' + system._variable_names[index]\n    obj._pretty_form = '' + pretty_str\n    obj._latex_form = latex_str\n    obj._system = system\n\n    return obj"
}