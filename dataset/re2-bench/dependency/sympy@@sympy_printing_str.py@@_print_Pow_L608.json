{
    "sympy.sympy.calculus.accumulationbounds.__neg__": "def __neg__(self):\n    return AccumBounds(-self.max, -self.min)",
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.printing.precedence.precedence": "def precedence(item):\n    \"\"\"Returns the precedence of a given object.\n\n    This is the precedence for StrPrinter.\n    \"\"\"\n    if hasattr(item, \"precedence\"):\n        return item.precedence\n    if not isinstance(item, type):\n        for i in type(item).mro():\n            n = i.__name__\n            if n in PRECEDENCE_FUNCTIONS:\n                return PRECEDENCE_FUNCTIONS[n](item)\n            elif n in PRECEDENCE_VALUES:\n                return PRECEDENCE_VALUES[n]\n    return PRECEDENCE[\"Atom\"]",
    "sympy.sympy.printing.printer._print": "def _print(self, expr, **kwargs) -> str:\n    \"\"\"Internal dispatcher\n\n    Tries the following concepts to print an expression:\n        1. Let the object print itself if it knows how.\n        2. Take the best fitting method defined in the printer.\n        3. As fall-back use the emptyPrinter method for the printer.\n    \"\"\"\n    self._print_level += 1\n    try:\n        # If the printer defines a name for a printing method\n        # (Printer.printmethod) and the object knows for itself how it\n        # should be printed, use that method.\n        if self.printmethod and hasattr(expr, self.printmethod):\n            if not (isinstance(expr, type) and issubclass(expr, Basic)):\n                return getattr(expr, self.printmethod)(self, **kwargs)\n\n        # See if the class of expr is known, or if one of its super\n        # classes is known, and use that print function\n        # Exception: ignore the subclasses of Undefined, so that, e.g.,\n        # Function('gamma') does not get dispatched to _print_gamma\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        # Another exception: if someone subclasses a known function, e.g.,\n        # gamma, and changes the name, then ignore _print_gamma\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple(c for c in classes[:i] if \\\n                c.__name__ == classes[0].__name__ or \\\n                c.__name__.endswith(\"Base\")) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        # Unknown object, fall back to the emptyPrinter.\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    "sympy.sympy.printing.str.parenthesize": "def parenthesize(self, item, level, strict=False):\n    if (precedence(item) < level) or ((not strict) and precedence(item) <= level):\n        return \"(%s)\" % self._print(item)\n    else:\n        return self._print(item)",
    "sympy.sympy.printing.str.<genexpr>": "return \"%s/sqrt(%s)\" % tuple((self._print(arg) for arg in (S.One, expr.base)))\n"
}