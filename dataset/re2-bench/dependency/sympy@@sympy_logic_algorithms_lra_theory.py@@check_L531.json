{
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.logic.algorithms.lra_theory.<dictcomp>": "return True, {var: var.assign for var in self.all_var}\n\n",
    "sympy.sympy.logic.algorithms.lra_theory.<genexpr>": "assert all(x.lower[1] >= 0 for x in self.all_var)\n\n",
    "sympy.sympy.logic.algorithms.lra_theory.<listcomp>": "conflict = [-neg*self.boundary_to_enc[c] for c, neg in conflict]\n",
    "sympy.sympy.logic.algorithms.lra_theory.<lambda>": "xj = min(cand, key=lambda v: v.col_idx)\n",
    "sympy.sympy.logic.algorithms.lra_theory._pivot_and_update": "def _pivot_and_update(self, M, basic, nonbasic, xi, xj, v):\n    \"\"\"\n    Pivots basic variable xi with nonbasic variable xj,\n    and sets value of xi to v and adjusts the values of all basic variables\n    to keep equations satisfied.\n    \"\"\"\n    i, j = basic[xi], xj.col_idx\n    assert M[i, j] != 0\n    theta = (v - xi.assign)*(1/M[i, j])\n    xi.assign = v\n    xj.assign = xj.assign + theta\n    for xk in basic:\n        if xk != xi:\n            k = basic[xk]\n            akj = M[k, j]\n            xk.assign = xk.assign + theta*akj\n    # pivot\n    basic[xj] = basic[xi]\n    del basic[xi]\n    nonbasic.add(xi)\n    nonbasic.remove(xj)\n    return self._pivot(M, i, j)",
    "sympy.sympy.logic.algorithms.lra_theory.from_upper": "@staticmethod\ndef from_upper(var):\n    neg = -1 if var.upper_from_neg else 1\n    b = Boundary(var, var.upper[0], True, var.upper_from_eq, var.upper[1] != 0)\n    if neg < 0:\n        b = b.get_negated()\n    return b, neg",
    "sympy.sympy.logic.algorithms.lra_theory.from_lower": "@staticmethod\ndef from_lower(var):\n    neg = -1 if var.lower_from_neg else 1\n    b = Boundary(var, var.lower[0], False, var.lower_from_eq, var.lower[1] != 0)\n    if neg < 0:\n        b = b.get_negated()\n    return b, neg",
    "sympy.sympy.logic.algorithms.lra_theory.__lt__": "def __lt__(self, other):\n    return self.value < other.value",
    "sympy.sympy.logic.algorithms.lra_theory.__repr__": "def __repr__(self):\n    return repr(self.var)",
    "sympy.sympy.logic.algorithms.lra_theory.__hash__": "def __hash__(self):\n    return hash(self.var)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.repmatrix.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.matrices.repmatrix.copy": "def copy(self):\n    return self._fromrep(self._rep.copy())"
}