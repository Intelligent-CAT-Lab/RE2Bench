{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils.sparsefuncs.sparse_matmul_to_dense": "def sparse_matmul_to_dense(A, B, out=None):\n    \"\"\"Compute A @ B for sparse and 2-dim A and B while returning an ndarray.\n\n    Parameters\n    ----------\n    A : sparse matrix of shape (n1, n2) and format CSC or CSR\n        Left-side input matrix.\n    B : sparse matrix of shape (n2, n3) and format CSC or CSR\n        Right-side input matrix.\n    out : ndarray of shape (n1, n3) or None\n        Optional ndarray into which the result is written.\n\n    Returns\n    -------\n    out\n        An ndarray, new created if out=None.\n    \"\"\"\n    if not (sp.issparse(A) and A.format in (\"csc\", \"csr\") and A.ndim == 2):\n        raise ValueError(\"Input 'A' must be a sparse 2-dim CSC or CSR array.\")\n    if not (sp.issparse(B) and B.format in (\"csc\", \"csr\") and B.ndim == 2):\n        raise ValueError(\"Input 'B' must be a sparse 2-dim CSC or CSR array.\")\n    if A.shape[1] != B.shape[0]:\n        msg = (\n            \"Shapes must fulfil A.shape[1] == B.shape[0], \"\n            f\"got {A.shape[1]} == {B.shape[0]}.\"\n        )\n        raise ValueError(msg)\n    n1, n2 = A.shape\n    n3 = B.shape[1]\n    if A.dtype != B.dtype or A.dtype not in (np.float32, np.float64):\n        msg = \"Dtype of A and B must be the same, either both float32 or float64.\"\n        raise ValueError(msg)\n    if out is None:\n        out = np.empty((n1, n3), dtype=A.data.dtype)\n    else:\n        if out.shape[0] != n1 or out.shape[1] != n3:\n            raise ValueError(\"Shape of out must be ({n1}, {n3}), got {out.shape}.\")\n        if out.dtype != A.data.dtype:\n            raise ValueError(\"Dtype of out must match that of input A..\")\n\n    transpose_out = False\n    if A.format == \"csc\":\n        if B.format == \"csc\":\n            # out.T = (A @ B).T = B.T @ A.T, note that A.T and B.T are csr\n            transpose_out = True\n            A, B, out = B.T, A.T, out.T\n            n1, n3 = n3, n1\n        else:\n            # It seems best to just convert to csr.\n            A = A.tocsr()\n    elif B.format == \"csc\":\n        # It seems best to just convert to csr.\n        B = B.tocsr()\n\n    csr_matmul_csr_to_dense(\n        A.data, A.indices, A.indptr, B.data, B.indices, B.indptr, out, n1, n2, n3\n    )\n    if transpose_out:\n        out = out.T\n\n    return out"
}