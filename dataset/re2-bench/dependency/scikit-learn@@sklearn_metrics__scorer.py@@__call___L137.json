{
    "scikit-learn.sklearn.metrics._scorer.<dictcomp>": "**{name: Bunch(score=common_kwargs.copy()) for name in self._scorers}\n",
    "scikit-learn.sklearn.metrics._scorer._use_cache": "def _use_cache(self, estimator):\n    \"\"\"Return True if using a cache is beneficial, thus when a response method will\n    be called several time.\n    \"\"\"\n    if len(self._scorers) == 1:  # Only one scorer\n        return False\n\n    counter = Counter(\n        [\n            _check_response_method(estimator, scorer._response_method).__name__\n            for scorer in self._scorers.values()\n            if isinstance(scorer, _BaseScorer)\n        ]\n    )\n    if any(val > 1 for val in counter.values()):\n        # The exact same response method or iterable of response methods\n        # will be called more than once.\n        return True\n\n    return False",
    "scikit-learn.sklearn.metrics._scorer._accept_sample_weight": "def _accept_sample_weight(self):\n    # TODO(slep006): remove when metadata routing is the only way\n    return \"sample_weight\" in signature(self._score_func).parameters",
    "scikit-learn.sklearn.metrics._scorer._score": "def _score(self, method_caller, estimator, X, y_true, **kwargs):\n    \"\"\"Evaluate the response method of `estimator` on `X` and `y_true`.\n\n    Parameters\n    ----------\n    method_caller : callable\n        Returns predictions given an estimator, method name, and other\n        arguments, potentially caching results.\n\n    estimator : object\n        Trained estimator to use for scoring.\n\n    X : {array-like, sparse matrix}\n        Test data that will be fed to clf.decision_function or\n        clf.predict_proba.\n\n    y_true : array-like\n        Gold standard target values for X. These must be class labels,\n        not decision function values.\n\n    **kwargs : dict\n        Other parameters passed to the scorer. Refer to\n        :func:`set_score_request` for more details.\n\n    Returns\n    -------\n    score : float\n        Score function applied to prediction of estimator on X.\n    \"\"\"\n    self._warn_overlap(\n        message=(\n            \"There is an overlap between set kwargs of this scorer instance and\"\n            \" passed metadata. Please pass them either as kwargs to `make_scorer`\"\n            \" or metadata, but not both.\"\n        ),\n        kwargs=kwargs,\n    )\n\n    pos_label = None if is_regressor(estimator) else self._get_pos_label()\n    response_method = _check_response_method(estimator, self._response_method)\n    y_pred = method_caller(\n        estimator,\n        _get_response_method_name(response_method),\n        X,\n        pos_label=pos_label,\n    )\n\n    scoring_kwargs = {**self._kwargs, **kwargs}\n    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)",
    "scikit-learn.sklearn.metrics._scorer.__call__": "def __call__(self, estimator, *args, **kwargs):\n    \"\"\"Method that wraps estimator.score\"\"\"\n    return estimator.score(*args, **kwargs)",
    "scikit-learn.sklearn.utils._bunch.__init__": "def __init__(self, **kwargs):\n    super().__init__(kwargs)\n\n    # Map from deprecated key to warning message\n    self.__dict__[\"_deprecated_key_to_warnings\"] = {}",
    "scikit-learn.sklearn.utils._bunch.__getitem__": "def __getitem__(self, key):\n    if key in self.__dict__.get(\"_deprecated_key_to_warnings\", {}):\n        warnings.warn(\n            self._deprecated_key_to_warnings[key],\n            FutureWarning,\n        )\n    return super().__getitem__(key)",
    "scikit-learn.sklearn.utils._bunch.__getattr__": "def __getattr__(self, key):\n    try:\n        return self[key]\n    except KeyError:\n        raise AttributeError(key)",
    "scikit-learn.sklearn.utils._metadata_requests.process_routing": "def process_routing(_obj, _method, /, **kwargs):\n    \"\"\"Validate and route metadata.\n\n    This function is used inside a :term:`router`'s method, e.g. :term:`fit`,\n    to validate the metadata and handle the routing.\n\n    Assuming this signature of a router's fit method:\n    ``fit(self, X, y, sample_weight=None, **fit_params)``,\n    a call to this function would be:\n    ``process_routing(self, \"fit\", sample_weight=sample_weight, **fit_params)``.\n\n    Note that if routing is not enabled and ``kwargs`` is empty, then it\n    returns an empty routing where ``process_routing(...).ANYTHING.ANY_METHOD``\n    is always an empty dictionary.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    _obj : object\n        An object implementing ``get_metadata_routing``. Typically a\n        :term:`meta-estimator`.\n\n    _method : str\n        The name of the router's method in which this function is called.\n\n    **kwargs : dict\n        Metadata to be routed.\n\n    Returns\n    -------\n    routed_params : Bunch\n        A :class:`~utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        A :class:`~sklearn.utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        corresponding methods or corresponding child objects. The object names\n        are those defined in `obj.get_metadata_routing()`.\n    \"\"\"\n    if not kwargs:\n        # If routing is not enabled and kwargs are empty, then we don't have to\n        # try doing any routing, we can simply return a structure which returns\n        # an empty dict on routed_params.ANYTHING.ANY_METHOD.\n        class EmptyRequest:\n            def get(self, name, default=None):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getitem__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getattr__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n        return EmptyRequest()\n\n    if not (hasattr(_obj, \"get_metadata_routing\") or isinstance(_obj, MetadataRouter)):\n        raise AttributeError(\n            f\"The given object ({_routing_repr(_obj)}) needs to either\"\n            \" implement the routing method `get_metadata_routing` or be a\"\n            \" `MetadataRouter` instance.\"\n        )\n    if _method not in METHODS:\n        raise TypeError(\n            f\"Can only route and process input on these methods: {METHODS}, \"\n            f\"while the passed method is: {_method}.\"\n        )\n\n    request_routing = get_routing_for_object(_obj)\n    request_routing.validate_metadata(params=kwargs, method=_method)\n    routed_params = request_routing.route_params(params=kwargs, caller=_method)\n\n    return routed_params",
    "scikit-learn.sklearn.utils._metadata_requests._routing_enabled": "def _routing_enabled():\n    \"\"\"Return whether metadata routing is enabled.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    enabled : bool\n        Whether metadata routing is enabled. If the config is not set, it\n        defaults to False.\n    \"\"\"\n    return get_config().get(\"enable_metadata_routing\", False)",
    "scikit-learn.sklearn.utils._metadata_requests.get": "def get(self, name, default=None):\n    return Bunch(**{method: dict() for method in METHODS})"
}