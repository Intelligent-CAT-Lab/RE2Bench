{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if self == expr:\n        if repl_dict is None:\n            return {}\n        return repl_dict.copy()",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    \"\"\"Return [commutative factors, non-commutative factors] of self.\n\n    Explanation\n    ===========\n\n    self is treated as a Mul and the ordering of the factors is maintained.\n    If ``cset`` is True the commutative factors will be returned in a set.\n    If there were repeated factors (as may happen with an unevaluated Mul)\n    then an error will be raised unless it is explicitly suppressed by\n    setting ``warn`` to False.\n\n    Note: -1 is always separated from a Number unless split_1 is False.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, oo\n    >>> A, B = symbols('A B', commutative=0)\n    >>> x, y = symbols('x y')\n    >>> (-2*x*y).args_cnc()\n    [[-1, 2, x, y], []]\n    >>> (-2.5*x).args_cnc()\n    [[-1, 2.5, x], []]\n    >>> (-2*x*A*B*y).args_cnc()\n    [[-1, 2, x, y], [A, B]]\n    >>> (-2*x*A*B*y).args_cnc(split_1=False)\n    [[-2, x, y], [A, B]]\n    >>> (-2*x*y).args_cnc(cset=True)\n    [{-1, 2, x, y}, []]\n\n    The arg is always treated as a Mul:\n\n    >>> (-2 + x + A).args_cnc()\n    [[], [x - 2 + A]]\n    >>> (-oo).args_cnc() # -oo is a singleton\n    [[-1, oo], []]\n    \"\"\"\n    args = list(Mul.make_args(self))\n\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n\n    if c and split_1 and (\n        c[0].is_Number and\n        c[0].is_extended_negative and\n            c[0] is not S.NegativeOne):\n        c[:1] = [S.NegativeOne, -c[0]]\n\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and len(c) != clen:\n            raise ValueError('repeated commutative arguments: %s' %\n                             [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    "sympy.sympy.core.mul.matches": "def matches(self, expr, repl_dict=None, old=False):\n    expr = sympify(expr)\n    if self.is_commutative and expr.is_commutative:\n        return self._matches_commutative(expr, repl_dict, old)\n    elif self.is_commutative is not expr.is_commutative:\n        return None\n\n    # Proceed only if both both expressions are non-commutative\n    c1, nc1 = self.args_cnc()\n    c2, nc2 = expr.args_cnc()\n    c1, c2 = [c or [1] for c in [c1, c2]]\n\n    # TODO: Should these be self.func?\n    comm_mul_self = Mul(*c1)\n    comm_mul_expr = Mul(*c2)\n\n    repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)\n\n    # If the commutative arguments didn't match and aren't equal, then\n    # then the expression as a whole doesn't match\n    if not repl_dict and c1 != c2:\n        return None\n\n    # Now match the non-commutative arguments, expanding powers to\n    # multiplications\n    nc1 = Mul._matches_expand_pows(nc1)\n    nc2 = Mul._matches_expand_pows(nc2)\n\n    repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)\n\n    return repl_dict or None",
    "sympy.sympy.core.mul.<listcomp>": "c1, c2 = [c or [1] for c in [c1, c2]]\n\n# TODO: Should these be self.func?\n",
    "sympy.sympy.core.mul._matches_expand_pows": "@staticmethod\ndef _matches_expand_pows(arg_list):\n    new_args = []\n    for arg in arg_list:\n        if arg.is_Pow and arg.exp > 0:\n            new_args.extend([arg.base] * arg.exp)\n        else:\n            new_args.append(arg)\n    return new_args",
    "sympy.sympy.core.mul._matches_noncomm": "@staticmethod\ndef _matches_noncomm(nodes, targets, repl_dict=None):\n    \"\"\"Non-commutative multiplication matcher.\n\n    `nodes` is a list of symbols within the matcher multiplication\n    expression, while `targets` is a list of arguments in the\n    multiplication expression being matched against.\n    \"\"\"\n    if repl_dict is None:\n        repl_dict = {}\n    else:\n        repl_dict = repl_dict.copy()\n\n    # List of possible future states to be considered\n    agenda = []\n    # The current matching state, storing index in nodes and targets\n    state = (0, 0)\n    node_ind, target_ind = state\n    # Mapping between wildcard indices and the index ranges they match\n    wildcard_dict = {}\n\n    while target_ind < len(targets) and node_ind < len(nodes):\n        node = nodes[node_ind]\n\n        if node.is_Wild:\n            Mul._matches_add_wildcard(wildcard_dict, state)\n\n        states_matches = Mul._matches_new_states(wildcard_dict, state,\n                                                 nodes, targets)\n        if states_matches:\n            new_states, new_matches = states_matches\n            agenda.extend(new_states)\n            if new_matches:\n                for match in new_matches:\n                    repl_dict[match] = new_matches[match]\n        if not agenda:\n            return None\n        else:\n            state = agenda.pop()\n            node_ind, target_ind = state\n\n    return repl_dict",
    "sympy.sympy.core.operations._matches_commutative": "def _matches_commutative(self, expr, repl_dict=None, old=False):\n    \"\"\"\n    Matches Add/Mul \"pattern\" to an expression \"expr\".\n\n    repl_dict ... a dictionary of (wild: expression) pairs, that get\n                  returned with the results\n\n    This function is the main workhorse for Add/Mul.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Wild, sin\n    >>> a = Wild(\"a\")\n    >>> b = Wild(\"b\")\n    >>> c = Wild(\"c\")\n    >>> x, y, z = symbols(\"x y z\")\n    >>> (a+sin(b)*c)._matches_commutative(x+sin(y)*z)\n    {a_: x, b_: y, c_: z}\n\n    In the example above, \"a+sin(b)*c\" is the pattern, and \"x+sin(y)*z\" is\n    the expression.\n\n    The repl_dict contains parts that were already matched. For example\n    here:\n\n    >>> (x+sin(b)*c)._matches_commutative(x+sin(y)*z, repl_dict={a: x})\n    {a_: x, b_: y, c_: z}\n\n    the only function of the repl_dict is to return it in the\n    result, e.g. if you omit it:\n\n    >>> (x+sin(b)*c)._matches_commutative(x+sin(y)*z)\n    {b_: y, c_: z}\n\n    the \"a: x\" is not returned in the result, but otherwise it is\n    equivalent.\n\n    \"\"\"\n    from .function import _coeff_isneg\n    # make sure expr is Expr if pattern is Expr\n    from .expr import Expr\n    if isinstance(self, Expr) and not isinstance(expr, Expr):\n        return None\n\n    if repl_dict is None:\n        repl_dict = {}\n\n    # handle simple patterns\n    if self == expr:\n        return repl_dict\n\n    d = self._matches_simple(expr, repl_dict)\n    if d is not None:\n        return d\n\n    # eliminate exact part from pattern: (2+a+w1+w2).matches(expr) -> (w1+w2).matches(expr-a-2)\n    from .function import WildFunction\n    from .symbol import Wild\n    wild_part, exact_part = sift(self.args, lambda p:\n        p.has(Wild, WildFunction) and not expr.has(p),\n        binary=True)\n    if not exact_part:\n        wild_part = list(ordered(wild_part))\n        if self.is_Add:\n            # in addition to normal ordered keys, impose\n            # sorting on Muls with leading Number to put\n            # them in order\n            wild_part = sorted(wild_part, key=lambda x:\n                x.args[0] if x.is_Mul and x.args[0].is_Number else\n                0)\n    else:\n        exact = self._new_rawargs(*exact_part)\n        free = expr.free_symbols\n        if free and (exact.free_symbols - free):\n            # there are symbols in the exact part that are not\n            # in the expr; but if there are no free symbols, let\n            # the matching continue\n            return None\n        newexpr = self._combine_inverse(expr, exact)\n        if not old and (expr.is_Add or expr.is_Mul):\n            check = newexpr\n            if _coeff_isneg(check):\n                check = -check\n            if check.count_ops() > expr.count_ops():\n                return None\n        newpattern = self._new_rawargs(*wild_part)\n        return newpattern.matches(newexpr, repl_dict)\n\n    # now to real work ;)\n    i = 0\n    saw = set()\n    while expr not in saw:\n        saw.add(expr)\n        args = tuple(ordered(self.make_args(expr)))\n        if self.is_Add and expr.is_Add:\n            # in addition to normal ordered keys, impose\n            # sorting on Muls with leading Number to put\n            # them in order\n            args = tuple(sorted(args, key=lambda x:\n                x.args[0] if x.is_Mul and x.args[0].is_Number else\n                0))\n        expr_list = (self.identity,) + args\n        for last_op in reversed(expr_list):\n            for w in reversed(wild_part):\n                d1 = w.matches(last_op, repl_dict)\n                if d1 is not None:\n                    d2 = self.xreplace(d1).matches(expr, d1)\n                    if d2 is not None:\n                        return d2\n\n        if i == 0:\n            if self.is_Mul:\n                # make e**i look like Mul\n                if expr.is_Pow and expr.exp.is_Integer:\n                    from .mul import Mul\n                    if expr.exp > 0:\n                        expr = Mul(*[expr.base, expr.base**(expr.exp - 1)], evaluate=False)\n                    else:\n                        expr = Mul(*[1/expr.base, expr.base**(expr.exp + 1)], evaluate=False)\n                    i += 1\n                    continue\n\n            elif self.is_Add:\n                # make i*e look like Add\n                c, e = expr.as_coeff_Mul()\n                if abs(c) > 1:\n                    from .add import Add\n                    if c > 0:\n                        expr = Add(*[e, (c - 1)*e], evaluate=False)\n                    else:\n                        expr = Add(*[-e, (c + 1)*e], evaluate=False)\n                    i += 1\n                    continue\n\n                # try collection on non-Wild symbols\n                from sympy.simplify.radsimp import collect\n                was = expr\n                did = set()\n                for w in reversed(wild_part):\n                    c, w = w.as_coeff_mul(Wild)\n                    free = c.free_symbols - did\n                    if free:\n                        did.update(free)\n                        expr = collect(expr, free)\n                if expr != was:\n                    i += 0\n                    continue\n\n            break  # if we didn't continue, there is nothing more to do\n\n    return",
    "sympy.sympy.core.symbol.matches": "def matches(self, expr, repl_dict=None, old=False):\n    if any(expr.has(x) for x in self.exclude):\n        return None\n    if not all(f(expr) for f in self.properties):\n        return None\n    if repl_dict is None:\n        repl_dict = {}\n    else:\n        repl_dict = repl_dict.copy()\n    repl_dict[self] = expr\n    return repl_dict",
    "sympy.sympy.core.sympify.sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    \"\"\"\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n\n    Explanation\n    ===========\n\n    It will convert Python ints into instances of :class:`~.Integer`, floats\n    into instances of :class:`~.Float`, etc. It is also able to coerce\n    symbolic expressions which inherit from :class:`~.Basic`. This can be\n    useful in cooperation with SAGE.\n\n    .. warning::\n        Note that this function uses ``eval``, and thus shouldn't be used on\n        unsanitized input.\n\n    If the argument is already a type that SymPy understands, it will do\n    nothing but return that value. This can be used at the beginning of a\n    function to ensure you are working with the correct type.\n\n    Examples\n    ========\n\n    >>> from sympy import sympify\n\n    >>> sympify(2).is_integer\n    True\n    >>> sympify(2).is_real\n    True\n\n    >>> sympify(2.0).is_real\n    True\n    >>> sympify(\"2.0\").is_real\n    True\n    >>> sympify(\"2e-45\").is_real\n    True\n\n    If the expression could not be converted, a SympifyError is raised.\n\n    >>> sympify(\"x***2\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: \"could not parse 'x***2'\"\n\n    When attempting to parse non-Python syntax using ``sympify``, it raises a\n    ``SympifyError``:\n\n    >>> sympify(\"2x+1\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: Sympify of expression 'could not parse '2x+1'' failed\n\n    To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"2x+1\", transformations=\"all\")\n    2*x + 1\n\n    For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`\n\n    Locals\n    ------\n\n    The sympification happens with access to everything that is loaded\n    by ``from sympy import *``; anything used in a string that is not\n    defined by that import will be converted to a symbol. In the following,\n    the ``bitcount`` function is treated as a symbol and the ``O`` is\n    interpreted as the :class:`~.Order` object (used with series) and it raises\n    an error when used improperly:\n\n    >>> s = 'bitcount(42)'\n    >>> sympify(s)\n    bitcount(42)\n    >>> sympify(\"O(x)\")\n    O(x)\n    >>> sympify(\"O + 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: unbound method...\n\n    In order to have ``bitcount`` be recognized it can be defined in a\n    namespace dictionary and passed as locals:\n\n    >>> ns = {}\n    >>> exec('bitcount = lambda n: int(n).bit_length()', ns)\n    >>> sympify(s, locals=ns)\n    6\n\n    In order to have the ``O`` interpreted as a Symbol, identify it as such\n    in the namespace dictionary. This can be done in a variety of ways; all\n    three of the following are possibilities:\n\n    >>> from sympy import Symbol\n    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n    >>> exec('from sympy.abc import O', ns)  # method 2\n    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n    >>> sympify(\"O + 1\", locals=ns)\n    O + 1\n\n    If you want *all* single-letter and Greek-letter variables to be symbols\n    then you can use the clashing-symbols dictionaries that have been defined\n    there as private variables: ``_clash1`` (single-letter variables),\n    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n    multi-letter names that are defined in ``abc``).\n\n    >>> from sympy.abc import _clash1\n    >>> set(_clash1)  # if this fails, see issue #23903\n    {'E', 'I', 'N', 'O', 'Q', 'S'}\n    >>> sympify('I & Q', _clash1)\n    I & Q\n\n    Strict\n    ------\n\n    If the option ``strict`` is set to ``True``, only the types for which an\n    explicit conversion has been defined are converted. In the other\n    cases, a SympifyError is raised.\n\n    >>> print(sympify(None))\n    None\n    >>> sympify(None, strict=True)\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: None\n\n    .. deprecated:: 1.6\n\n       ``sympify(obj)`` automatically falls back to ``str(obj)`` when all\n       other conversion methods fail, but this is deprecated. ``strict=True``\n       will disable this deprecated behavior. See\n       :ref:`deprecated-sympify-string-fallback`.\n\n    Evaluation\n    ----------\n\n    If the option ``evaluate`` is set to ``False``, then arithmetic and\n    operators will be converted into their SymPy equivalents and the\n    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n    be denested first. This is done via an AST transformation that replaces\n    operators with their SymPy equivalents, so if an operand redefines any\n    of those operations, the redefined operators will not be used. If\n    argument a is not a string, the mathematical expression is evaluated\n    before being passed to sympify, so adding ``evaluate=False`` will still\n    return the evaluated result of expression.\n\n    >>> sympify('2**2 / 3 + 5')\n    19/3\n    >>> sympify('2**2 / 3 + 5', evaluate=False)\n    2**2/3 + 5\n    >>> sympify('4/2+7', evaluate=True)\n    9\n    >>> sympify('4/2+7', evaluate=False)\n    4/2 + 7\n    >>> sympify(4/2+7, evaluate=False)\n    9.00000000000000\n\n    Extending\n    ---------\n\n    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n    just define a ``_sympy_`` method to your class. You can do that even to\n    classes that you do not own by subclassing or adding the method at runtime.\n\n    >>> from sympy import Matrix\n    >>> class MyList1(object):\n    ...     def __iter__(self):\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    ...     def _sympy_(self): return Matrix(self)\n    >>> sympify(MyList1())\n    Matrix([\n    [1],\n    [2]])\n\n    If you do not have control over the class definition you could also use the\n    ``converter`` global dictionary. The key is the class and the value is a\n    function that takes a single argument and returns the desired SymPy\n    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n\n    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n    ...     def __iter__(self):  #     Use _sympy_!\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    >>> from sympy.core.sympify import converter\n    >>> converter[MyList2] = lambda x: Matrix(x)\n    >>> sympify(MyList2())\n    Matrix([\n    [1],\n    [2]])\n\n    Notes\n    =====\n\n    The keywords ``rational`` and ``convert_xor`` are only used\n    when the input is a string.\n\n    convert_xor\n    -----------\n\n    >>> sympify('x^y',convert_xor=True)\n    x**y\n    >>> sympify('x^y',convert_xor=False)\n    x ^ y\n\n    rational\n    --------\n\n    >>> sympify('0.1',rational=False)\n    0.1\n    >>> sympify('0.1',rational=True)\n    1/10\n\n    Sometimes autosimplification during sympification results in expressions\n    that are very different in structure than what was entered. Until such\n    autosimplification is no longer done, the ``kernS`` function might be of\n    some use. In the example below you can see how an expression reduces to\n    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n\n    >>> from sympy.core.sympify import kernS\n    >>> from sympy.abc import x\n    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n    -1\n    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n    >>> sympify(s)\n    -1\n    >>> kernS(s)\n    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n\n    Parameters\n    ==========\n\n    a :\n        - any object defined in SymPy\n        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n        - booleans, including ``None`` (will leave ``None`` unchanged)\n        - dicts, lists, sets or tuples containing any of the above\n\n    convert_xor : bool, optional\n        If true, treats ``^`` as exponentiation.\n        If False, treats ``^`` as XOR itself.\n        Used only when input is a string.\n\n    locals : any object defined in SymPy, optional\n        In order to have strings be recognized it can be imported\n        into a namespace dictionary and passed as locals.\n\n    strict : bool, optional\n        If the option strict is set to ``True``, only the types for which\n        an explicit conversion has been defined are converted. In the\n        other cases, a SympifyError is raised.\n\n    rational : bool, optional\n        If ``True``, converts floats into :class:`~.Rational`.\n        If ``False``, it lets floats remain as it is.\n        Used only when input is a string.\n\n    evaluate : bool, optional\n        If False, then arithmetic and operators will be converted into\n        their SymPy equivalents. If True the expression will be evaluated\n        and the result will be returned.\n\n    \"\"\"\n    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n    # was used for a long time we allow it to pass. However if strict=True as\n    # is the case in internal calls to _sympify then we only allow\n    # is_sympy=True.\n    #\n    # https://github.com/sympy/sympy/issues/20124\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n\n    cls = getattr(a, \"__class__\", None)\n\n    #Check if there exists a converter for any of the types in the mro\n    for superclass in getmro(cls):\n        #First check for user defined converters\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            #if none exists, check for SymPy defined converters\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    # Support for basic numpy datatypes\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals,\n                convert_xor=convert_xor, strict=strict, rational=rational,\n                evaluate=evaluate)\n\n    _sympy_ = getattr(a, \"_sympy_\", None)\n    if _sympy_ is not None:\n        return a._sympy_()\n\n    if not strict:\n        # Put numpy array conversion _before_ float/int, see\n        # <https://github.com/sympy/sympy/issues/13924>.\n        flat = getattr(a, \"flat\", None)\n        if flat is not None:\n            shape = getattr(a, \"shape\", None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                # Scalar arrays (those with zero dimensions) have sympify\n                # called on the scalar element.\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(),\n                                       locals=locals,\n                                       convert_xor=convert_xor,\n                                       strict=strict,\n                                       rational=rational,\n                                       evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        elif hasattr(a, '__float__'):\n            # float and int can coerce size-one numpy arrays to their lone\n            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n            return sympify(float(a))\n        elif hasattr(a, '__int__'):\n            return sympify(int(a))\n\n    if strict:\n        raise SympifyError(a)\n\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n                rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            # Not all iterables are rebuildable with their type.\n            pass\n\n    if not isinstance(a, str):\n        raise SympifyError('cannot sympify object of type %r' % type(a))\n\n    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n                                            standard_transformations)\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n\n    transformations = standard_transformations\n\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n\n    return expr"
}