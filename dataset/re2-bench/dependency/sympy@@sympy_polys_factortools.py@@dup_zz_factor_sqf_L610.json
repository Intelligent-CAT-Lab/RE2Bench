{
    "sympy.sympy.polys.densearith.dup_neg": "def dup_neg(f: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_neg(x**2 - 1)\n    -x**2 + 1\n\n    \"\"\"\n    return [ -coeff for coeff in f ]",
    "sympy.sympy.polys.densebasic.dup_LC": "def dup_LC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_LC\n\n    >>> dup_LC([1, 2, 3], ZZ)\n    1\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    "sympy.sympy.polys.densebasic.dup_degree": "def dup_degree(f: dup[Er]) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``K[x]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_degree\n\n    >>> f = ZZ.map([1, 2, 0, 3])\n\n    >>> dup_degree(f)\n    3\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.densetools.dup_primitive": "def dup_primitive(f: dup[Er], K: Domain[Er]) -> tuple[Er, dup[Er]]:\n    \"\"\"\n    Compute content and the primitive form of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    \"\"\"\n    if not f:\n        return K.zero, f\n\n    cont = dup_content(f, K)\n\n    if K.is_one(cont):\n        return cont, f\n    else:\n        return cont, dup_quo_ground(f, cont, K)",
    "sympy.sympy.polys.factortools.dup_zz_zassenhaus": "def dup_zz_zassenhaus(f, K):\n    \"\"\"Factor primitive square-free polynomials in `Z[x]`. \"\"\"\n    n = dup_degree(f)\n\n    if n == 1:\n        return [f]\n\n    from sympy.ntheory import isprime\n\n    fc = f[-1]\n    A = dup_max_norm(f, K)\n    b = dup_LC(f, K)\n    B = int(abs(K.sqrt(K(n + 1))*2**n*A*b))\n    C = int((n + 1)**(2*n)*A**(2*n - 1))\n    gamma = int(_ceil(2*_log2(C)))\n    bound = int(2*gamma*_log(gamma))\n    a = []\n    # choose a prime number `p` such that `f` be square free in Z_p\n    # if there are many factors in Z_p, choose among a few different `p`\n    # the one with fewer factors\n    for px in range(3, bound + 1):\n        if not isprime(px) or b % px == 0:\n            continue\n\n        px = K.convert(px)\n\n        F = gf_from_int_poly(f, px)\n\n        if not gf_sqf_p(F, px, K):\n            continue\n        fsqfx = gf_factor_sqf(F, px, K)[1]\n        a.append((px, fsqfx))\n        if len(fsqfx) < 15 or len(a) > 4:\n            break\n    p, fsqf = min(a, key=lambda x: len(x[1]))\n\n    l = int(_ceil(_log(2*B + 1, p)))\n\n    modular = [gf_to_int_poly(ff, p) for ff in fsqf]\n\n    g = dup_zz_hensel_lift(p, f, modular, l, K)\n\n    sorted_T = range(len(g))\n    T = set(sorted_T)\n    factors, s = [], 1\n    pl = p**l\n\n    while 2*s <= len(T):\n        for S in subsets(sorted_T, s):\n            # lift the constant coefficient of the product `G` of the factors\n            # in the subset `S`; if it is does not divide `fc`, `G` does\n            # not divide the input polynomial\n\n            if b == 1:\n                q = 1\n                for i in S:\n                    q = q*g[i][-1]\n                q = q % pl\n                if not _test_pl(fc, q, pl):\n                    continue\n            else:\n                G = [b]\n                for i in S:\n                    G = dup_mul(G, g[i], K)\n                G = dup_trunc(G, pl, K)\n                G = dup_primitive(G, K)[1]\n                q = G[-1]\n                if q and fc % q != 0:\n                    continue\n\n            H = [b]\n            S = set(S)\n            T_S = T - S\n\n            if b == 1:\n                G = [b]\n                for i in S:\n                    G = dup_mul(G, g[i], K)\n                G = dup_trunc(G, pl, K)\n\n            for i in T_S:\n                H = dup_mul(H, g[i], K)\n\n            H = dup_trunc(H, pl, K)\n\n            G_norm = dup_l1_norm(G, K)\n            H_norm = dup_l1_norm(H, K)\n\n            if G_norm*H_norm <= B:\n                T = T_S\n                sorted_T = [i for i in sorted_T if i not in S]\n\n                G = dup_primitive(G, K)[1]\n                f = dup_primitive(H, K)[1]\n\n                factors.append(G)\n                b = dup_LC(f, K)\n\n                break\n        else:\n            s += 1\n\n    return factors + [f]",
    "sympy.sympy.polys.factortools.dup_zz_cyclotomic_factor": "def dup_zz_cyclotomic_factor(f, K):\n    \"\"\"\n    Efficiently factor polynomials `x**n - 1` and `x**n + 1` in `Z[x]`.\n\n    Given a univariate polynomial `f` in `Z[x]` returns a list of factors\n    of `f`, provided that `f` is in the form `x**n - 1` or `x**n + 1` for\n    `n >= 1`. Otherwise returns None.\n\n    Factorization is performed using cyclotomic decomposition of `f`,\n    which makes this method much faster that any other direct factorization\n    approach (e.g. Zassenhaus's).\n\n    References\n    ==========\n\n    .. [1] [Weisstein09]_\n\n    \"\"\"\n    lc_f, tc_f = dup_LC(f, K), dup_TC(f, K)\n\n    if dup_degree(f) <= 0:\n        return None\n\n    if lc_f != 1 or tc_f not in [-1, 1]:\n        return None\n\n    if any(bool(cf) for cf in f[1:-1]):\n        return None\n\n    n = dup_degree(f)\n    F = _dup_cyclotomic_decompose(n, K)\n\n    if not K.is_one(tc_f):\n        return F\n    else:\n        H = []\n\n        for h in _dup_cyclotomic_decompose(2*n, K):\n            if h not in F:\n                H.append(h)\n\n        return H",
    "sympy.sympy.polys.polyconfig.query": "def query(key: str) -> bool | int | str | None:\n    \"\"\"Ask for a value of the given configuration item. \"\"\"\n    return _current_config.get(key.upper(), None)",
    "sympy.sympy.polys.polyutils._sort_factors": "def _sort_factors(factors, **args):\n    \"\"\"Sort low-level factors in increasing 'complexity' order. \"\"\"\n\n    # XXX: GF(p) does not support comparisons so we need a key function to sort\n    # the factors if python-flint is being used. A better solution might be to\n    # add a sort key method to each domain.\n    def order_key(factor):\n        if isinstance(factor, _GF_types):\n            return int(factor)\n        elif isinstance(factor, list):\n            return [order_key(f) for f in factor]\n        else:\n            return factor\n\n    def order_if_multiple_key(factor):\n        (f, n) = factor\n        return (len(f), n, order_key(f))\n\n    def order_no_multiple_key(f):\n        return (len(f), order_key(f))\n\n    if args.get('multiple', True):\n        return sorted(factors, key=order_if_multiple_key)\n    else:\n        return sorted(factors, key=order_no_multiple_key)"
}