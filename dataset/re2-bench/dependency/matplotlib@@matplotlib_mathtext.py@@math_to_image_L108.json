{
    "matplotlib.lib.matplotlib.figure.text": "@_docstring.interpd\ndef text(self, x, y, s, fontdict=None, **kwargs):\n    \"\"\"\n    Add text to figure.\n\n    Parameters\n    ----------\n    x, y : float\n        The position to place the text. By default, this is in figure\n        coordinates, floats in [0, 1]. The coordinate system can be changed\n        using the *transform* keyword.\n\n    s : str\n        The text string.\n\n    fontdict : dict, optional\n        A dictionary to override the default text properties. If not given,\n        the defaults are determined by :rc:`font.*`. Properties passed as\n        *kwargs* override the corresponding ones given in *fontdict*.\n\n    Returns\n    -------\n    `~.text.Text`\n\n    Other Parameters\n    ----------------\n    **kwargs : `~matplotlib.text.Text` properties\n        Other miscellaneous text parameters.\n\n        %(Text:kwdoc)s\n\n    See Also\n    --------\n    .Axes.text\n    .pyplot.text\n    \"\"\"\n    effective_kwargs = {\n        'transform': self.transSubfigure,\n        **(fontdict if fontdict is not None else {}),\n        **kwargs,\n    }\n    text = Text(x=x, y=y, text=s, **effective_kwargs)\n    text.set_figure(self)\n    text.stale_callback = _stale_figure_callback\n\n    self.texts.append(text)\n    text._remove_method = self.texts.remove\n    self.stale = True\n    return text",
    "matplotlib.lib.matplotlib.figure.__init__": "    def __init__(self,\n                 figsize=None,\n                 dpi=None,\n                 *,\n                 facecolor=None,\n                 edgecolor=None,\n                 linewidth=0.0,\n                 frameon=None,\n                 subplotpars=None,  # rc figure.subplot.*\n                 tight_layout=None,  # rc figure.autolayout\n                 constrained_layout=None,  # rc figure.constrained_layout.use\n                 layout=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        figsize : (float, float) or (float, float, str), default: :rc:`figure.figsize`\n            The figure dimensions. This can be\n\n            - a tuple ``(width, height, unit)``, where *unit* is one of \"in\" (inch),\n              \"cm\" (centimenter), \"px\" (pixel).\n            - a tuple ``(width, height)``, which is interpreted in inches, i.e. as\n              ``(width, height, \"in\")``.\n\n        dpi : float, default: :rc:`figure.dpi`\n            Dots per inch.\n\n        facecolor : default: :rc:`figure.facecolor`\n            The figure patch facecolor.\n\n        edgecolor : default: :rc:`figure.edgecolor`\n            The figure patch edge color.\n\n        linewidth : float\n            The linewidth of the frame (i.e. the edge linewidth of the figure\n            patch).\n\n        frameon : bool, default: :rc:`figure.frameon`\n            If ``False``, suppress drawing the figure background patch.\n\n        subplotpars : `~matplotlib.gridspec.SubplotParams`\n            Subplot parameters. If not given, the default subplot\n            parameters :rc:`figure.subplot.*` are used.\n\n        tight_layout : bool or dict, default: :rc:`figure.autolayout`\n            Whether to use the tight layout mechanism. See `.set_tight_layout`.\n\n            .. admonition:: Discouraged\n\n                The use of this parameter is discouraged. Please use\n                ``layout='tight'`` instead for the common case of\n                ``tight_layout=True`` and use `.set_tight_layout` otherwise.\n\n        constrained_layout : bool, default: :rc:`figure.constrained_layout.use`\n            This is equal to ``layout='constrained'``.\n\n            .. admonition:: Discouraged\n\n                The use of this parameter is discouraged. Please use\n                ``layout='constrained'`` instead.\n\n        layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \\\nNone}, default: None\n            The layout mechanism for positioning of plot elements to avoid\n            overlapping Axes decorations (labels, ticks, etc). Note that\n            layout managers can have significant performance penalties.\n\n            - 'constrained': The constrained layout solver adjusts Axes sizes\n              to avoid overlapping Axes decorations.  Can handle complex plot\n              layouts and colorbars, and is thus recommended.\n\n              See :ref:`constrainedlayout_guide` for examples.\n\n            - 'compressed': uses the same algorithm as 'constrained', but\n              removes extra space between fixed-aspect-ratio Axes.  Best for\n              simple grids of Axes.\n\n            - 'tight': Use the tight layout mechanism. This is a relatively\n              simple algorithm that adjusts the subplot parameters so that\n              decorations do not overlap.\n\n              See :ref:`tight_layout_guide` for examples.\n\n            - 'none': Do not use a layout engine.\n\n            - A `.LayoutEngine` instance. Builtin layout classes are\n              `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily\n              accessible by 'constrained' and 'tight'.  Passing an instance\n              allows third parties to provide their own layout engine.\n\n            If not given, fall back to using the parameters *tight_layout* and\n            *constrained_layout*, including their config defaults\n            :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Figure` properties, optional\n\n            %(Figure:kwdoc)s\n        \"\"\"\n        super().__init__(**kwargs)\n        self._root_figure = self\n        self._layout_engine = None\n\n        if layout is not None:\n            if (tight_layout is not None):\n                _api.warn_external(\n                    \"The Figure parameters 'layout' and 'tight_layout' cannot \"\n                    \"be used together. Please use 'layout' only.\")\n            if (constrained_layout is not None):\n                _api.warn_external(\n                    \"The Figure parameters 'layout' and 'constrained_layout' \"\n                    \"cannot be used together. Please use 'layout' only.\")\n            self.set_layout_engine(layout=layout)\n        elif tight_layout is not None:\n            if constrained_layout is not None:\n                _api.warn_external(\n                    \"The Figure parameters 'tight_layout' and \"\n                    \"'constrained_layout' cannot be used together. Please use \"\n                    \"'layout' parameter\")\n            self.set_layout_engine(layout='tight')\n            if isinstance(tight_layout, dict):\n                self.get_layout_engine().set(**tight_layout)\n        elif constrained_layout is not None:\n            if isinstance(constrained_layout, dict):\n                self.set_layout_engine(layout='constrained')\n                self.get_layout_engine().set(**constrained_layout)\n            elif constrained_layout:\n                self.set_layout_engine(layout='constrained')\n\n        else:\n            # everything is None, so use default:\n            self.set_layout_engine(layout=layout)\n\n        # Callbacks traditionally associated with the canvas (and exposed with\n        # a proxy property), but that actually need to be on the figure for\n        # pickling.\n        self._canvas_callbacks = cbook.CallbackRegistry(\n            signals=FigureCanvasBase.events)\n        connect = self._canvas_callbacks._connect_picklable\n        self._mouse_key_ids = [\n            connect('key_press_event', backend_bases._key_handler),\n            connect('key_release_event', backend_bases._key_handler),\n            connect('key_release_event', backend_bases._key_handler),\n            connect('button_press_event', backend_bases._mouse_handler),\n            connect('button_release_event', backend_bases._mouse_handler),\n            connect('scroll_event', backend_bases._mouse_handler),\n            connect('motion_notify_event', backend_bases._mouse_handler),\n        ]\n        self._button_pick_id = connect('button_press_event', self.pick)\n        self._scroll_pick_id = connect('scroll_event', self.pick)\n\n        figsize = mpl._val_or_rc(figsize, 'figure.figsize')\n        dpi = mpl._val_or_rc(dpi, 'figure.dpi')\n        facecolor = mpl._val_or_rc(facecolor, 'figure.facecolor')\n        edgecolor = mpl._val_or_rc(edgecolor, 'figure.edgecolor')\n        frameon = mpl._val_or_rc(frameon, 'figure.frameon')\n\n        figsize = _parse_figsize(figsize, dpi)\n\n        if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():\n            raise ValueError('figure size must be positive finite not '\n                             f'{figsize}')\n        self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n\n        self.dpi_scale_trans = Affine2D().scale(dpi)\n        # do not use property as it will trigger\n        self._dpi = dpi\n        self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n        self.figbbox = self.bbox\n        self.transFigure = BboxTransformTo(self.bbox)\n        self.transSubfigure = self.transFigure\n\n        self.patch = Rectangle(\n            xy=(0, 0), width=1, height=1, visible=frameon,\n            facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n            # Don't let the figure patch influence bbox calculation.\n            in_layout=False)\n        self._set_artist_props(self.patch)\n        self.patch.set_antialiased(False)\n\n        self._set_base_canvas()\n\n        if subplotpars is None:\n            subplotpars = SubplotParams()\n\n        self.subplotpars = subplotpars\n\n        self._axstack = _AxesStack()  # track all figure Axes and current Axes\n        self.clear()",
    "matplotlib.lib.matplotlib.figure.savefig": "def savefig(self, fname, *, transparent=None, **kwargs):\n    \"\"\"\n    Save the current figure as an image or vector graphic to a file.\n\n    Call signature::\n\n      savefig(fname, *, transparent=None, dpi='figure', format=None,\n              metadata=None, bbox_inches=None, pad_inches=0.1,\n              facecolor='auto', edgecolor='auto', backend=None,\n              **kwargs\n             )\n\n    The available output formats depend on the backend being used.\n\n    Parameters\n    ----------\n    fname : str or path-like or binary file-like\n        A path, or a Python file-like object, or\n        possibly some backend-dependent object such as\n        `matplotlib.backends.backend_pdf.PdfPages`.\n\n        If *format* is set, it determines the output format, and the file\n        is saved as *fname*.  Note that *fname* is used verbatim, and there\n        is no attempt to make the extension, if any, of *fname* match\n        *format*, and no extension is appended.\n\n        If *format* is not set, then the format is inferred from the\n        extension of *fname*, if there is one.  If *format* is not\n        set and *fname* has no extension, then the file is saved with\n        :rc:`savefig.format` and the appropriate extension is appended to\n        *fname*.\n\n    Other Parameters\n    ----------------\n    transparent : bool, default: :rc:`savefig.transparent`\n        If *True*, the Axes patches will all be transparent; the\n        Figure patch will also be transparent unless *facecolor*\n        and/or *edgecolor* are specified via kwargs.\n\n        If *False* has no effect and the color of the Axes and\n        Figure patches are unchanged (unless the Figure patch\n        is specified via the *facecolor* and/or *edgecolor* keyword\n        arguments in which case those colors are used).\n\n        The transparency of these patches will be restored to their\n        original values upon exit of this function.\n\n        This is useful, for example, for displaying\n        a plot on top of a colored background on a web page.\n\n    dpi : float or 'figure', default: :rc:`savefig.dpi`\n        The resolution in dots per inch.  If 'figure', use the figure's\n        dpi value.\n\n    format : str\n        The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n        this is unset is documented under *fname*.\n\n    metadata : dict, optional\n        Key/value pairs to store in the image metadata. The supported keys\n        and defaults depend on the image format and backend:\n\n        - 'png' with Agg backend: See the parameter ``metadata`` of\n          `~.FigureCanvasAgg.print_png`.\n        - 'pdf' with pdf backend: See the parameter ``metadata`` of\n          `~.backend_pdf.PdfPages`.\n        - 'svg' with svg backend: See the parameter ``metadata`` of\n          `~.FigureCanvasSVG.print_svg`.\n        - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n\n        Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support\n        embedding metadata.\n        Does not currently support 'jpg', 'tiff', or 'webp', but may include\n        embedding EXIF metadata in the future.\n\n    bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`\n        Bounding box in inches: only the given portion of the figure is\n        saved.  If 'tight', try to figure out the tight bbox of the figure.\n\n    pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`\n        Amount of padding in inches around the figure when bbox_inches is\n        'tight'. If 'layout' use the padding from the constrained or\n        compressed layout engine; ignored if one of those engines is not in\n        use.\n\n    facecolor : :mpltype:`color` or 'auto', default: :rc:`savefig.facecolor`\n        The facecolor of the figure.  If 'auto', use the current figure\n        facecolor.\n\n    edgecolor : :mpltype:`color` or 'auto', default: :rc:`savefig.edgecolor`\n        The edgecolor of the figure.  If 'auto', use the current figure\n        edgecolor.\n\n    backend : str, optional\n        Use a non-default backend to render the file, e.g. to render a\n        png file with the \"cairo\" backend rather than the default \"agg\",\n        or a pdf file with the \"pgf\" backend rather than the default\n        \"pdf\".  Note that the default backend is normally sufficient.  See\n        :ref:`the-builtin-backends` for a list of valid backends for each\n        file format.  Custom backends can be referenced as \"module://...\".\n\n    orientation : {'landscape', 'portrait'}\n        Currently only supported by the postscript backend.\n\n    papertype : str\n        One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n        'a10', 'b0' through 'b10'. Only supported for postscript\n        output.\n\n    bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n        A list of extra artists that will be considered when the\n        tight bbox is calculated.\n\n    pil_kwargs : dict, optional\n        Additional keyword arguments that are passed to\n        `PIL.Image.Image.save` when saving the figure.\n\n    \"\"\"\n\n    kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])\n    transparent = mpl._val_or_rc(transparent, 'savefig.transparent')\n\n    with ExitStack() as stack:\n        if transparent:\n            def _recursively_make_subfig_transparent(exit_stack, subfig):\n                exit_stack.enter_context(\n                    subfig.patch._cm_set(\n                        facecolor=\"none\", edgecolor=\"none\"))\n                for ax in subfig.axes:\n                    exit_stack.enter_context(\n                        ax.patch._cm_set(\n                            facecolor=\"none\", edgecolor=\"none\"))\n                for sub_subfig in subfig.subfigs:\n                    _recursively_make_subfig_transparent(\n                        exit_stack, sub_subfig)\n\n            def _recursively_make_axes_transparent(exit_stack, ax):\n                exit_stack.enter_context(\n                    ax.patch._cm_set(facecolor=\"none\", edgecolor=\"none\"))\n                for child_ax in ax.child_axes:\n                    exit_stack.enter_context(\n                        child_ax.patch._cm_set(\n                            facecolor=\"none\", edgecolor=\"none\"))\n                for child_childax in ax.child_axes:\n                    _recursively_make_axes_transparent(\n                        exit_stack, child_childax)\n\n            kwargs.setdefault('facecolor', 'none')\n            kwargs.setdefault('edgecolor', 'none')\n            # set subfigure to appear transparent in printed image\n            for subfig in self.subfigs:\n                _recursively_make_subfig_transparent(stack, subfig)\n            # set Axes to be transparent\n            for ax in self.axes:\n                _recursively_make_axes_transparent(stack, ax)\n        self.canvas.print_figure(fname, **kwargs)",
    "matplotlib.lib.matplotlib.mathtext.__init__": "def __init__(self, output):\n    \"\"\"\n    Create a MathTextParser for the given backend *output*.\n\n    Parameters\n    ----------\n    output : {\"path\", \"agg\"}\n        Whether to return a `VectorParse` (\"path\") or a\n        `RasterParse` (\"agg\", or its synonym \"macosx\").\n    \"\"\"\n    self._output_type = _api.check_getitem(\n        {\"path\": \"vector\", \"agg\": \"raster\", \"macosx\": \"raster\"},\n        output=output.lower())",
    "matplotlib.lib.matplotlib.mathtext.parse": "def parse(self, s, dpi=72, prop=None, *, antialiased=None):\n    \"\"\"\n    Parse the given math expression *s* at the given *dpi*.  If *prop* is\n    provided, it is a `.FontProperties` object specifying the \"default\"\n    font to use in the math expression, used for all non-math text.\n\n    The results are cached, so multiple calls to `parse`\n    with the same expression should be fast.\n\n    Depending on the *output* type, this returns either a `VectorParse` or\n    a `RasterParse`.\n    \"\"\"\n    # lru_cache can't decorate parse() directly because prop is\n    # mutable, so we key the cache using an internal copy (see\n    # Text._get_text_metrics_with_cache for a similar case); likewise,\n    # we need to check the mutable state of the text.antialiased and\n    # text.hinting rcParams.\n    prop = prop.copy() if prop is not None else None\n    antialiased = mpl._val_or_rc(antialiased, 'text.antialiased')\n    from matplotlib.backends import backend_agg\n    load_glyph_flags = {\n        \"vector\": LoadFlags.NO_HINTING,\n        \"raster\": backend_agg.get_hinting_flag(),\n    }[self._output_type]\n    return self._parse_cached(s, dpi, prop, antialiased, load_glyph_flags)"
}