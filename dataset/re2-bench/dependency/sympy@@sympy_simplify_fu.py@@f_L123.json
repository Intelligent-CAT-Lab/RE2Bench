{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_powers_dict": "def as_powers_dict(self):\n    \"\"\"Return self as a dictionary of factors with each factor being\n    treated as a power. The keys are the bases of the factors and the\n    values, the corresponding exponents. The resulting dictionary should\n    be used with caution if the expression is a Mul and contains non-\n    commutative factors since the order that they appeared will be lost in\n    the dictionary.\n\n    See Also\n    ========\n    as_ordered_factors: An alternative for noncommutative applications,\n                        returning an ordered list of factors.\n    args_cnc: Similar to as_ordered_factors, but guarantees separation\n              of commutative and noncommutative factors.\n    \"\"\"\n    d = defaultdict(int)\n    d.update([self.as_base_exp()])\n    return d",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.mul.as_powers_dict": "def as_powers_dict(self):\n    d = defaultdict(int)\n    for term in self.args:\n        for b, e in term.as_powers_dict().items():\n            d[b] += e\n    return d",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.NegativeOne",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.simplify.fu.<listcomp>": "rv *= Mul(*[b**e for b, e in ndone])/Mul(*[b**e for b, e in ddone])\n\n",
    "sympy.sympy.simplify.fu.factorize": "def factorize(d, ddone):\n    newk = []\n    for k in d:\n        if k.is_Add and len(k.args) > 1:\n            knew = factor(k) if half else factor_terms(k)\n            if knew != k:\n                newk.append((k, knew))\n    if newk:\n        for i, (k, knew) in enumerate(newk):\n            del d[k]\n            newk[i] = knew\n        newk = Mul(*newk).as_powers_dict()\n        for k in newk:\n            v = d[k] + newk[k]\n            if ok(k, v):\n                d[k] = v\n            else:\n                ddone.append((k, v))\n        del newk",
    "sympy.sympy.vector.basisdependent.as_numer_denom": "def as_numer_denom(self):\n    \"\"\"\n    Returns the expression as a tuple wrt the following\n    transformation -\n\n    expression -> a/b -> a, b\n\n    \"\"\"\n    return self, S.One"
}