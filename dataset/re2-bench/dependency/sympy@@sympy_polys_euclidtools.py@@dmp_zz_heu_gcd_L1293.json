{
    "sympy.sympy.polys.densearith.dmp_div": "def dmp_div(\n    f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]\n) -> tuple[dmp[Er], dmp[Er]]:\n    \"\"\"\n    Polynomial division with remainder in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_div(x**2 + x*y, 2*x + 2)\n    (0, x**2 + x*y)\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_div(x**2 + x*y, 2*x + 2)\n    (1/2*x + 1/2*y - 1/2, -y + 1)\n\n    \"\"\"\n    if K.is_Field:\n        return dmp_ff_div(f, g, u, K) # type: ignore\n    else:\n        return dmp_rr_div(f, g, u, K) # type: ignore",
    "sympy.sympy.polys.densearith.dmp_max_norm": "def dmp_max_norm(f: dmp[Eordered], u: int, K: Domain[Eordered]) -> Eordered:\n    \"\"\"\n    Returns maximum norm of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_max_norm(2*x*y - x - 3)\n    3\n\n    \"\"\"\n    if not u:\n        return dup_max_norm(_dup(f), K)\n\n    v = u - 1\n\n    return max(dmp_max_norm(c, v, K) for c in f)",
    "sympy.sympy.polys.densearith.dmp_mul_ground": "def dmp_mul_ground(f: dmp[Er], c: Er, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul_ground(2*x + 2*y, ZZ(3))\n    6*x + 6*y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_mul_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densebasic.dmp_ground_LC": "def dmp_ground_LC(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the ground leading coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_LC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_LC(f, 2, ZZ)\n    1\n\n    \"\"\"\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n\n    return dup_LC(_dup(f), K)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densetools.dmp_eval": "def dmp_eval(f: dmp[Er], a: Er, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Evaluate a polynomial at ``x_0 = a`` in ``K[X]`` using the Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_eval(2*x*y + 3*x + y + 2, 2)\n    5*y + 8\n\n    \"\"\"\n    if not u:\n        return _ground_dmp(dup_eval(_dup(f), a, K))\n\n    if not a:\n        return dmp_TC(f, K)\n\n    result, v = dmp_LC(f, K), u - 1\n\n    for coeff in f[1:]:\n        result = dmp_mul_ground(result, a, v, K)\n        result = dmp_add(result, coeff, v, K)\n\n    return result",
    "sympy.sympy.polys.densetools.dmp_ground_primitive": "def dmp_ground_primitive(f: dmp[Er], u: int, K: Domain[Er]) -> tuple[Er, dmp[Er]]:\n    \"\"\"\n    Compute content and the primitive form of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    \"\"\"\n    if not u:\n        cont, fu = dup_primitive(_dup(f), K)\n        return cont, _dmp(fu)\n\n    if dmp_zero_p(f, u):\n        return K.zero, f\n\n    cont = dmp_ground_content(f, u, K)\n\n    if K.is_one(cont):\n        return cont, f\n    else:\n        return cont, dmp_quo_ground(f, cont, u, K)",
    "sympy.sympy.polys.densetools.dmp_ground_extract": "def dmp_ground_extract(\n    f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]\n) -> tuple[Er, dmp[Er], dmp[Er]]:\n    \"\"\"\n    Extract common content from a pair of polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_ground_extract(6*x*y + 12*x + 18, 4*x*y + 8*x + 12)\n    (2, 3*x*y + 6*x + 9, 2*x*y + 4*x + 6)\n\n    \"\"\"\n    fc = dmp_ground_content(f, u, K)\n    gc = dmp_ground_content(g, u, K)\n\n    gcd = K.gcd(fc, gc)\n\n    if not K.is_one(gcd):\n        f = dmp_quo_ground(f, gcd, u, K)\n        g = dmp_quo_ground(g, gcd, u, K)\n\n    return gcd, f, g",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.integerring.sqrt": "def sqrt(self, a):\n    \"\"\"Compute square root of ``a``. \"\"\"\n    return sqrt(a)",
    "sympy.sympy.polys.euclidtools.dup_zz_heu_gcd": "def dup_zz_heu_gcd(f, g, K):\n    \"\"\"\n    Heuristic polynomial GCD in `Z[x]`.\n\n    Given univariate polynomials `f` and `g` in `Z[x]`, returns\n    their GCD and cofactors, i.e. polynomials ``h``, ``cff`` and ``cfg``\n    such that::\n\n          h = gcd(f, g), cff = quo(f, h) and cfg = quo(g, h)\n\n    The algorithm is purely heuristic which means it may fail to compute\n    the GCD. This will be signaled by raising an exception. In this case\n    you will need to switch to another GCD method.\n\n    The algorithm computes the polynomial GCD by evaluating polynomials\n    f and g at certain points and computing (fast) integer GCD of those\n    evaluations. The polynomial GCD is recovered from the integer image\n    by interpolation.  The final step is to verify if the result is the\n    correct GCD. This gives cofactors as a side effect.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_zz_heu_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    References\n    ==========\n\n    .. [1] [Liao95]_\n\n    \"\"\"\n    result = _dup_rr_trivial_gcd(f, g, K)\n\n    if result is not None:\n        return result\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    gcd, f, g = dup_extract(f, g, K)\n\n    if df == 0 or dg == 0:\n        return [gcd], f, g\n\n    f_norm = dup_max_norm(f, K)\n    g_norm = dup_max_norm(g, K)\n\n    B = K(2*min(f_norm, g_norm) + 29)\n\n    x = max(min(B, 99*K.sqrt(B)),\n            2*min(f_norm // abs(dup_LC(f, K)),\n                  g_norm // abs(dup_LC(g, K))) + 4)\n\n    for i in range(0, HEU_GCD_MAX):\n        ff = dup_eval(f, x, K)\n        gg = dup_eval(g, x, K)\n\n        if ff and gg:\n            h = K.gcd(ff, gg)\n\n            cff = ff // h\n            cfg = gg // h\n\n            h = _dup_zz_gcd_interpolate(h, x, K)\n            h = dup_primitive(h, K)[1]\n\n            cff_, r = dup_div(f, h, K)\n\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return h, cff_, cfg_\n\n            cff = _dup_zz_gcd_interpolate(cff, x, K)\n\n            h, r = dup_div(f, cff, K)\n\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return h, cff, cfg_\n\n            cfg = _dup_zz_gcd_interpolate(cfg, x, K)\n\n            h, r = dup_div(g, cfg, K)\n\n            if not r:\n                cff_, r = dup_div(f, h, K)\n\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return h, cff_, cfg\n\n        x = 73794*x * K.sqrt(K.sqrt(x)) // 27011\n\n    raise HeuristicGCDFailed('no luck')",
    "sympy.sympy.polys.euclidtools._dmp_zz_gcd_interpolate": "def _dmp_zz_gcd_interpolate(h, x, v, K):\n    \"\"\"Interpolate polynomial GCD from integer GCD. \"\"\"\n    f = []\n\n    while not dmp_zero_p(h, v):\n        g = dmp_ground_trunc(h, x, v, K)\n        f.insert(0, g)\n\n        h = dmp_sub(h, g, v, K)\n        h = dmp_quo_ground(h, x, v, K)\n\n    if K.is_negative(dmp_ground_LC(f, v + 1, K)):\n        return dmp_neg(f, v + 1, K)\n    else:\n        return f",
    "sympy.sympy.polys.euclidtools.dmp_zz_heu_gcd": "def dmp_zz_heu_gcd(f, g, u, K):\n    \"\"\"\n    Heuristic polynomial GCD in `Z[X]`.\n\n    Given univariate polynomials `f` and `g` in `Z[X]`, returns\n    their GCD and cofactors, i.e. polynomials ``h``, ``cff`` and ``cfg``\n    such that::\n\n          h = gcd(f, g), cff = quo(f, h) and cfg = quo(g, h)\n\n    The algorithm is purely heuristic which means it may fail to compute\n    the GCD. This will be signaled by raising an exception. In this case\n    you will need to switch to another GCD method.\n\n    The algorithm computes the polynomial GCD by evaluating polynomials\n    f and g at certain points and computing (fast) integer GCD of those\n    evaluations. The polynomial GCD is recovered from the integer image\n    by interpolation. The evaluation process reduces f and g variable by\n    variable into a large integer.  The final step is to verify if the\n    interpolated polynomial is the correct GCD. This gives cofactors of\n    the input polynomials as a side effect.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_zz_heu_gcd(f, g)\n    (x + y, x + y, x)\n\n    References\n    ==========\n\n    .. [1] [Liao95]_\n\n    \"\"\"\n    if not u:\n        return dup_zz_heu_gcd(f, g, K)\n\n    result = _dmp_rr_trivial_gcd(f, g, u, K)\n\n    if result is not None:\n        return result\n\n    gcd, f, g = dmp_ground_extract(f, g, u, K)\n\n    f_norm = dmp_max_norm(f, u, K)\n    g_norm = dmp_max_norm(g, u, K)\n\n    B = K(2*min(f_norm, g_norm) + 29)\n\n    x = max(min(B, 99*K.sqrt(B)),\n            2*min(f_norm // abs(dmp_ground_LC(f, u, K)),\n                  g_norm // abs(dmp_ground_LC(g, u, K))) + 4)\n\n    for i in range(0, HEU_GCD_MAX):\n        ff = dmp_eval(f, x, u, K)\n        gg = dmp_eval(g, x, u, K)\n\n        v = u - 1\n\n        if not (dmp_zero_p(ff, v) or dmp_zero_p(gg, v)):\n            h, cff, cfg = dmp_zz_heu_gcd(ff, gg, v, K)\n\n            h = _dmp_zz_gcd_interpolate(h, x, v, K)\n            h = dmp_ground_primitive(h, u, K)[1]\n\n            cff_, r = dmp_div(f, h, u, K)\n\n            if dmp_zero_p(r, u):\n                cfg_, r = dmp_div(g, h, u, K)\n\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return h, cff_, cfg_\n\n            cff = _dmp_zz_gcd_interpolate(cff, x, v, K)\n\n            h, r = dmp_div(f, cff, u, K)\n\n            if dmp_zero_p(r, u):\n                cfg_, r = dmp_div(g, h, u, K)\n\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return h, cff, cfg_\n\n            cfg = _dmp_zz_gcd_interpolate(cfg, x, v, K)\n\n            h, r = dmp_div(g, cfg, u, K)\n\n            if dmp_zero_p(r, u):\n                cff_, r = dmp_div(f, h, u, K)\n\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return h, cff_, cfg\n\n        x = 73794*x * K.sqrt(K.sqrt(x)) // 27011\n\n    raise HeuristicGCDFailed('no luck')",
    "sympy.sympy.polys.euclidtools._dmp_rr_trivial_gcd": "def _dmp_rr_trivial_gcd(f, g, u, K):\n    \"\"\"Handle trivial cases in GCD algorithm over a ring. \"\"\"\n    zero_f = dmp_zero_p(f, u)\n    zero_g = dmp_zero_p(g, u)\n    if_contain_one = dmp_one_p(f, u, K) or dmp_one_p(g, u, K)\n\n    if zero_f and zero_g:\n        return tuple(dmp_zeros(3, u, K))\n    elif zero_f:\n        if K.is_nonnegative(dmp_ground_LC(g, u, K)):\n            return g, dmp_zero(u, K), dmp_one(u, K)\n        else:\n            return dmp_neg(g, u, K), dmp_zero(u, K), dmp_ground(-K.one, u, K)\n    elif zero_g:\n        if K.is_nonnegative(dmp_ground_LC(f, u, K)):\n            return f, dmp_one(u, K), dmp_zero(u, K)\n        else:\n            return dmp_neg(f, u, K), dmp_ground(-K.one, u, K), dmp_zero(u, K)\n    elif if_contain_one:\n        return dmp_one(u, K), f, g\n    elif query('USE_SIMPLIFY_GCD'):\n        return _dmp_simplify_gcd(f, g, u, K)\n    else:\n        return None"
}