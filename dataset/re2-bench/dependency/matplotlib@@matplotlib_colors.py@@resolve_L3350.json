{
    "matplotlib.lib.matplotlib._api.__init__.check_getitem": "def check_getitem(mapping, /, _error_cls=ValueError, **kwargs):\n    \"\"\"\n    *kwargs* must consist of a single *key, value* pair.  If *key* is in\n    *mapping*, return ``mapping[value]``; else, raise an appropriate\n    ValueError.\n\n    Parameters\n    ----------\n    _error_cls :\n        Class of error to raise.\n\n    Examples\n    --------\n    >>> _api.check_getitem({\"foo\": \"bar\"}, arg=arg)\n    \"\"\"\n    if len(kwargs) != 1:\n        raise ValueError(\"check_getitem takes a single keyword argument\")\n    (k, v), = kwargs.items()\n    try:\n        return mapping[v]\n    except KeyError:\n        if len(mapping) > 5:\n            if len(best := difflib.get_close_matches(v, mapping.keys(), cutoff=0.5)):\n                suggestion = f\"Did you mean one of {best}?\"\n            else:\n                suggestion = \"\"\n        else:\n            suggestion = f\"Supported values are {', '.join(map(repr, mapping))}\"\n        raise _error_cls(f\"{v!r} is not a valid value for {k}. {suggestion}\") from None",
    "matplotlib.lib.matplotlib.colorizer._auto_norm_from_scale": "def _auto_norm_from_scale(scale_cls):\n    \"\"\"\n    Automatically generate a norm class from *scale_cls*.\n\n    This differs from `.colors.make_norm_from_scale` in the following points:\n\n    - This function is not a class decorator, but directly returns a norm class\n      (as if decorating `.Normalize`).\n    - The scale is automatically constructed with ``nonpositive=\"mask\"``, if it\n      supports such a parameter, to work around the difference in defaults\n      between standard scales (which use \"clip\") and norms (which use \"mask\").\n\n    Note that ``make_norm_from_scale`` caches the generated norm classes\n    (not the instances) and reuses them for later calls.  For example,\n    ``type(_auto_norm_from_scale(\"log\")) == LogNorm``.\n    \"\"\"\n    # Actually try to construct an instance, to verify whether\n    # ``nonpositive=\"mask\"`` is supported.\n    try:\n        norm = colors.make_norm_from_scale(\n            functools.partial(scale_cls, nonpositive=\"mask\"))(\n            colors.Normalize)()\n    except TypeError:\n        norm = colors.make_norm_from_scale(scale_cls)(\n            colors.Normalize)()\n    return type(norm)",
    "matplotlib.lib.matplotlib.colors.__init__": "def __init__(self, *args, **kwargs):\n    ba = bound_init_signature.bind(*args, **kwargs)\n    ba.apply_defaults()\n    super().__init__(\n        **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n    self._scale = functools.partial(\n        scale_cls, *scale_args, **dict(scale_kwargs_items))(\n            axis=None, **ba.arguments)\n    self._trf = self._scale.get_transform()"
}