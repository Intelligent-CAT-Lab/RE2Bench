{
    "matplotlib.lib.matplotlib._api.__init__.check_in_list": "def check_in_list(values, /, *, _print_supported_values=True, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is in *values*;\n    if not, raise an appropriate ValueError.\n\n    Parameters\n    ----------\n    values : iterable\n        Sequence of values to check on.\n\n        Note: All values must support == comparisons.\n        This means in particular the entries must not be numpy arrays.\n    _print_supported_values : bool, default: True\n        Whether to print *values* when raising ValueError.\n    **kwargs : dict\n        *key, value* pairs as keyword arguments to find in *values*.\n\n    Raises\n    ------\n    ValueError\n        If any *value* in *kwargs* is not found in *values*.\n\n    Examples\n    --------\n    >>> _api.check_in_list([\"foo\", \"bar\"], arg=arg, other_arg=other_arg)\n    \"\"\"\n    if not kwargs:\n        raise TypeError(\"No argument to check!\")\n    for key, val in kwargs.items():\n        try:\n            exists = val in values\n        except ValueError:\n            # `in` internally uses `val == values[i]`. There are some objects\n            # that do not support == to arbitrary other objects, in particular\n            # numpy arrays.\n            # Since such objects are not allowed in values, we can gracefully\n            # handle the case that val (typically provided by users) is of such\n            # type and directly state it's not in the list instead of letting\n            # the individual `val == values[i]` ValueError surface.\n            exists = False\n        if not exists:\n            msg = f\"{val!r} is not a valid value for {key}\"\n            if _print_supported_values:\n                msg += f\"; supported values are {', '.join(map(repr, values))}\"\n            raise ValueError(msg)",
    "matplotlib.lib.matplotlib.axes._base._label_outer_xaxis": "def _label_outer_xaxis(self, *, skip_non_rectangular_axes,\n                       remove_inner_ticks=False):\n    # see documentation in label_outer.\n    if skip_non_rectangular_axes and not isinstance(self.patch,\n                                                    mpl.patches.Rectangle):\n        return\n    ss = self._get_subplotspec_with_optional_colorbar()\n    if ss is None:\n        return\n    label_position = self.xaxis.get_label_position()\n    if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.\n        if label_position == \"top\":\n            self.set_xlabel(\"\")\n        top_kw = {'top': False} if remove_inner_ticks else {}\n        self.xaxis.set_tick_params(\n            which=\"both\", labeltop=False, **top_kw)\n        if self.xaxis.offsetText.get_position()[1] == 1:\n            self.xaxis.offsetText.set_visible(False)\n    if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.\n        if label_position == \"bottom\":\n            self.set_xlabel(\"\")\n        bottom_kw = {'bottom': False} if remove_inner_ticks else {}\n        self.xaxis.set_tick_params(\n            which=\"both\", labelbottom=False, **bottom_kw)\n        if self.xaxis.offsetText.get_position()[1] == 0:\n            self.xaxis.offsetText.set_visible(False)",
    "matplotlib.lib.matplotlib.axes._base._label_outer_yaxis": "def _label_outer_yaxis(self, *, skip_non_rectangular_axes,\n                       remove_inner_ticks=False):\n    # see documentation in label_outer.\n    if skip_non_rectangular_axes and not isinstance(self.patch,\n                                                    mpl.patches.Rectangle):\n        return\n    ss = self._get_subplotspec_with_optional_colorbar()\n    if ss is None:\n        return\n    label_position = self.yaxis.get_label_position()\n    if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.\n        if label_position == \"left\":\n            self.set_ylabel(\"\")\n        left_kw = {'left': False} if remove_inner_ticks else {}\n        self.yaxis.set_tick_params(\n            which=\"both\", labelleft=False, **left_kw)\n        if self.yaxis.offsetText.get_position()[0] == 0:\n            self.yaxis.offsetText.set_visible(False)\n    if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.\n        if label_position == \"right\":\n            self.set_ylabel(\"\")\n        right_kw = {'right': False} if remove_inner_ticks else {}\n        self.yaxis.set_tick_params(\n            which=\"both\", labelright=False, **right_kw)\n        if self.yaxis.offsetText.get_position()[0] == 1:\n            self.yaxis.offsetText.set_visible(False)",
    "matplotlib.lib.matplotlib.figure.add_subplot": "    @_docstring.interpd\n    def add_subplot(self, *args, **kwargs):\n        \"\"\"\n        Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n\n        Call signatures::\n\n           add_subplot(nrows, ncols, index, **kwargs)\n           add_subplot(pos, **kwargs)\n           add_subplot(ax)\n           add_subplot()\n\n        Parameters\n        ----------\n        *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n            The position of the subplot described by one of\n\n            - Three integers (*nrows*, *ncols*, *index*). The subplot will\n              take the *index* position on a grid with *nrows* rows and\n              *ncols* columns. *index* starts at 1 in the upper left corner\n              and increases to the right.  *index* can also be a two-tuple\n              specifying the (*first*, *last*) indices (1-based, and including\n              *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``\n              makes a subplot that spans the upper 2/3 of the figure.\n            - A 3-digit integer. The digits are interpreted as if given\n              separately as three single-digit integers, i.e.\n              ``fig.add_subplot(235)`` is the same as\n              ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n              if there are no more than 9 subplots.\n            - A `.SubplotSpec`.\n\n            In rare circumstances, `.add_subplot` may be called with a single\n            argument, a subplot Axes instance already created in the\n            present figure but not in the figure's list of Axes.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the subplot (`~.axes.Axes`). *str* is the\n            name of a custom projection, see `~matplotlib.projections`. The\n            default None results in a 'rectilinear' projection.\n\n        polar : bool, default: False\n            If True, equivalent to projection='polar'.\n\n        axes_class : subclass type of `~.axes.Axes`, optional\n            The `.axes.Axes` subclass that is instantiated.  This parameter\n            is incompatible with *projection* and *polar*.  See\n            :ref:`axisartist_users-guide-index` for examples.\n\n        sharex, sharey : `~matplotlib.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared Axes.\n\n        label : str\n            A label for the returned Axes.\n\n        Returns\n        -------\n        `~.axes.Axes`\n\n            The Axes of the subplot. The returned Axes can actually be an\n            instance of a subclass, such as `.projections.polar.PolarAxes` for\n            polar projections.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for the returned Axes\n            base class; except for the *figure* argument. The keyword arguments\n            for the rectilinear base class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used.\n\n            %(Axes:kwdoc)s\n\n        See Also\n        --------\n        .Figure.add_axes\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        ::\n\n            fig = plt.figure()\n\n            fig.add_subplot(231)\n            ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general\n\n            fig.add_subplot(232, frameon=False)  # subplot with no frame\n            fig.add_subplot(233, projection='polar')  # polar subplot\n            fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1\n            fig.add_subplot(235, facecolor=\"red\")  # red subplot\n\n            ax1.remove()  # delete ax1 from the figure\n            fig.add_subplot(ax1)  # add ax1 back to the figure\n        \"\"\"\n        if 'figure' in kwargs:\n            # Axes itself allows for a 'figure' kwarg, but since we want to\n            # bind the created Axes to self, it is not allowed here.\n            raise _api.kwarg_error(\"add_subplot\", \"figure\")\n\n        if (len(args) == 1\n                and isinstance(args[0], mpl.axes._base._AxesBase)\n                and args[0].get_subplotspec()):\n            ax = args[0]\n            key = ax._projection_init\n            if ax.get_figure(root=False) is not self:\n                raise ValueError(\"The Axes must have been created in \"\n                                 \"the present figure\")\n        else:\n            if not args:\n                args = (1, 1, 1)\n            # Normalize correct ijk values to (i, j, k) here so that\n            # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will\n            # trigger errors later (via SubplotSpec._from_subplot_args).\n            if (len(args) == 1 and isinstance(args[0], Integral)\n                    and 100 <= args[0] <= 999):\n                args = tuple(map(int, str(args[0])))\n            projection_class, pkw = self._process_projection_requirements(**kwargs)\n            ax = projection_class(self, *args, **pkw)\n            key = (projection_class, pkw)\n        return self._add_axes_internal(ax, key)",
    "matplotlib.lib.matplotlib.gridspec.__getitem__": "def __getitem__(self, key):\n    \"\"\"Create and return a `.SubplotSpec` instance.\"\"\"\n    nrows, ncols = self.get_geometry()\n\n    def _normalize(key, size, axis):  # Includes last index.\n        orig_key = key\n        if isinstance(key, slice):\n            start, stop, _ = key.indices(size)\n            if stop > start:\n                return start, stop - 1\n            raise IndexError(\"GridSpec slice would result in no space \"\n                             \"allocated for subplot\")\n        else:\n            if key < 0:\n                key = key + size\n            if 0 <= key < size:\n                return key, key\n            elif axis is not None:\n                raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                 f\"axis {axis} with size {size}\")\n            else:  # flat index\n                raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                 f\"GridSpec with size {size}\")\n\n    if isinstance(key, tuple):\n        try:\n            k1, k2 = key\n        except ValueError as err:\n            raise ValueError(\"Unrecognized subplot spec\") from err\n        num1, num2 = np.ravel_multi_index(\n            [_normalize(k1, nrows, 0), _normalize(k2, ncols, 1)],\n            (nrows, ncols))\n    else:  # Single key\n        num1, num2 = _normalize(key, nrows * ncols, None)\n\n    return SubplotSpec(self, num1, num2)"
}