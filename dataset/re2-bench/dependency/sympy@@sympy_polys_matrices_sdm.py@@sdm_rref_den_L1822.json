{
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.external.pythonmpq.__add__": "def __add__(self, other):\n    \"\"\"q1 + q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        #\n        # This is much faster than the naive method used in the stdlib\n        # fractions module. Not sure where this method comes from\n        # though...\n        #\n        # Compare timings for something like:\n        #   nums = range(1000)\n        #   rats = [PythonMPQ(n, d) for n, d in zip(nums[:-5], nums[5:])]\n        #   sum(rats) # <-- time this\n        #\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq + aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 + bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__sub__": "def __sub__(self ,other):\n    \"\"\"q1 - q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq - aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 - bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n    elif isinstance(other, int):\n        p = self.numerator - self.denominator*other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__mul__": "def __mul__(self, other):\n    \"\"\"q1 * q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = ((ap//x1)*(bp//x2), (aq//x2)*(bq//x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator*(other//x)\n        q = self.denominator//x\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.polys.agca.extensions.exquo": "def exquo(self, f, g):\n    ring = self.ring\n    try:\n        rep = ring.exquo(f.rep, g.rep)\n    except ExactQuotientFailed:\n        if not ring.domain.is_Field:\n            raise\n        ginv = ring.invert(g.rep, self.mod)\n        rep = ring.mul(f.rep, ginv)\n    return ExtElem(rep % self.mod, self)",
    "sympy.sympy.polys.agca.extensions.__bool__": "def __bool__(f):\n    return bool(f.rep)",
    "sympy.sympy.polys.agca.extensions.__add__": "def __add__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem(f.rep + rep, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.agca.extensions.__sub__": "def __sub__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem(f.rep - rep, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.agca.extensions.__mul__": "def __mul__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem((f.rep * rep) % f.ext.mod, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.compositedomain.is_Exact": "@property\ndef is_Exact(self):\n    \"\"\"Returns ``True`` if this domain is exact. \"\"\"\n    return self.domain.is_Exact",
    "sympy.sympy.polys.domains.domain.is_one": "def is_one(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is one. \"\"\"\n    return a == self.one",
    "sympy.sympy.polys.domains.expressiondomain.__mul__": "def __mul__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n\n    if EX.zero in (f, g):\n        return EX.zero\n    elif f.ex.is_Number and g.ex.is_Number:\n        return f.__class__(f.ex*g.ex)\n\n    return f.simplify(f.ex*g.ex)",
    "sympy.sympy.polys.domains.expressiondomain.__bool__": "def __bool__(f):\n    return not f.ex.is_zero",
    "sympy.sympy.polys.domains.expressiondomain.__sub__": "def __sub__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n    elif g == EX.zero:\n        return f\n    elif f == EX.zero:\n        return -g\n    else:\n        return f.simplify(f.ex - g.ex)",
    "sympy.sympy.polys.domains.field.exquo": "def exquo(self, a: Ef, b: Ef) -> Ef:\n    \"\"\"Exact quotient of ``a`` and ``b``, implies ``__truediv__``.  \"\"\"\n    return a / b",
    "sympy.sympy.polys.domains.fractionfield.one": "@property\ndef one(self):\n    return self.field.one",
    "sympy.sympy.polys.domains.gaussiandomains.__sub__": "def __sub__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x - x, self.y - y)",
    "sympy.sympy.polys.domains.gaussiandomains.__mul__": "def __mul__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x*x - self.y*y, self.x*y + self.y*x)",
    "sympy.sympy.polys.domains.gaussiandomains.__bool__": "def __bool__(self) -> bool:\n    return bool(self.x) or bool(self.y)",
    "sympy.sympy.polys.domains.gaussiandomains.__neg__": "def __neg__(self) -> Self:\n    return self.new(-self.x, -self.y)",
    "sympy.sympy.polys.domains.modularinteger.__mul__": "def __mul__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val * val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__bool__": "def __bool__(self):\n    return bool(self.val)",
    "sympy.sympy.polys.domains.modularinteger.__neg__": "def __neg__(self):\n    return self.__class__(-self.val)",
    "sympy.sympy.polys.domains.modularinteger.__add__": "def __add__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val + val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__sub__": "def __sub__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val - val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.one": "@property\ndef one(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.one",
    "sympy.sympy.polys.domains.rationalfield.exquo": "def exquo(self, a, b):\n    \"\"\"Exact quotient of ``a`` and ``b``, implies ``__truediv__``.  \"\"\"\n    return MPQ(a) / MPQ(b)",
    "sympy.sympy.polys.domains.ring.exquo": "def exquo(self, a, b):\n    \"\"\"Exact quotient of ``a`` and ``b``, implies ``__floordiv__``.  \"\"\"\n    if a % b:\n        raise ExactQuotientFailed(a, b, self)\n    else:\n        return a // b",
    "sympy.sympy.polys.domains.ring.quo": "def quo(self, a, b):\n    \"\"\"Quotient of ``a`` and ``b``, implies ``__floordiv__``. \"\"\"\n    return a // b",
    "sympy.sympy.polys.fields.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    "sympy.sympy.polys.fields.__neg__": "def __neg__(f):\n    \"\"\"Negate all coefficients in ``f``. \"\"\"\n    return f.raw_new(-f.numer, f.denom)",
    "sympy.sympy.polys.fields.__sub__": "def __sub__(f, g):\n    \"\"\"Subtract rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not g:\n        return f\n    elif not f:\n        return -g\n    elif field.is_element(g):\n        if f.denom == g.denom:\n            return f.new(f.numer - g.numer, f.denom)\n        else:\n            return f.new(f.numer*g.denom - f.denom*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer - f.denom*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__rsub__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__rsub__(f)\n\n    op, g_numer, g_denom = f._extract_ground(g)\n\n    if op == 1:\n        return f.new(f.numer - f.denom*g_numer, f.denom)\n    elif not op:\n        return NotImplemented\n    else:\n        return f.new(f.numer*g_denom - f.denom*g_numer, f.denom*g_denom)",
    "sympy.sympy.polys.fields.__mul__": "def __mul__(f, g):\n    \"\"\"Multiply rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not f or not g:\n        return field.zero\n    elif field.is_element(g):\n        return f.new(f.numer*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__rmul__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__rmul__(f)\n\n    return f.__rmul__(g)",
    "sympy.sympy.polys.matrices.sdm.<dictcomp>": "row_to_col = {i: j for j, i in col_to_row.items()}\n",
    "sympy.sympy.polys.matrices.sdm.<listcomp>": "A_rref_rows_col = [(row_to_col[i], Ai) for i, Ai in enumerate(A_rref_rows)]\n",
    "sympy.sympy.polys.polyclasses.__neg__": "def __neg__(f):\n    return f.neg()",
    "sympy.sympy.polys.polyclasses.__add__": "def __add__(f, g):\n    if isinstance(g, ANP):\n        return f.add(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.add_ground(g)",
    "sympy.sympy.polys.polyclasses.__sub__": "def __sub__(f, g):\n    if isinstance(g, ANP):\n        return f.sub(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.sub_ground(g)",
    "sympy.sympy.polys.polyclasses.__mul__": "def __mul__(f, g):\n    if isinstance(g, ANP):\n        return f.mul(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.mul_ground(g)",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)",
    "sympy.sympy.polys.rings.__neg__": "def __neg__(self) -> PolyElement[Er]:\n    # Return (-1) * self in case of python-flint\n    return self.new([(monom, -coeff) for monom, coeff in self.iterterms()])",
    "sympy.sympy.polys.rings.__add__": "def __add__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Add two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> (x + y)**2 + (x - y)**2\n    2*x**2 + 2*y**2\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._add(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._add_ground(self)\n\n    res = self._try_add_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_add_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.polys.rings.__sub__": "def __sub__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Subtract polynomial p2 from p1.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> p1 = x + y**2\n    >>> p2 = x*y + y**2\n    >>> p1 - p2\n    -x*y + x\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._sub(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._sub_ground(self)\n\n    res = self._try_sub_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_rsub_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.polys.rings.__mul__": "def __mul__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Multiply two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', QQ)\n    >>> p1 = x + y\n    >>> p2 = x - y\n    >>> p1*p2\n    x**2 - y**2\n\n    \"\"\"\n    if not self or not other:\n        return self.ring.zero\n\n    if self.ring.is_element(other):\n        return self._mul(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other).mul_ground(self)\n\n    res = self._try_mul_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_mul_ground(self)\n\n    return NotImplemented"
}