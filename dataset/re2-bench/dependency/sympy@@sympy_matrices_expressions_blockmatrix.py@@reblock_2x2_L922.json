{
    "sympy.sympy.matrices.expressions.blockmatrix.blockshape": "@property\ndef blockshape(self):\n    return self.blocks.shape",
    "sympy.sympy.matrices.expressions.blockmatrix.blocks": "@property\ndef blocks(self):\n    return self.args[0]",
    "sympy.sympy.matrices.expressions.blockmatrix.bc_unpack": "def bc_unpack(expr):\n    if expr.blockshape == (1, 1):\n        return expr.blocks[0, 0]\n    return expr",
    "sympy.sympy.matrices.expressions.blockmatrix.__new__": "def __new__(cls, *args, **kwargs):\n    from sympy.matrices.immutable import ImmutableDenseMatrix\n    isMat = lambda i: getattr(i, 'is_Matrix', False)\n    if len(args) != 1 or \\\n            not is_sequence(args[0]) or \\\n            len({isMat(r) for r in args[0]}) != 1:\n        raise ValueError(filldedent('''\n            expecting a sequence of 1 or more rows\n            containing Matrices.'''))\n    rows = args[0] if args else []\n    if not isMat(rows):\n        if rows and isMat(rows[0]):\n            rows = [rows]  # rows is not list of lists or []\n        # regularity check\n        # same number of matrices in each row\n        blocky = ok = len({len(r) for r in rows}) == 1\n        if ok:\n            # same number of rows for each matrix in a row\n            for r in rows:\n                ok = len({i.rows for i in r}) == 1\n                if not ok:\n                    break\n            blocky = ok\n            if ok:\n                # same number of cols for each matrix in each col\n                for c in range(len(rows[0])):\n                    ok = len({rows[i][c].cols\n                        for i in range(len(rows))}) == 1\n                    if not ok:\n                        break\n        if not ok:\n            # same total cols in each row\n            ok = len({\n                sum(i.cols for i in r) for r in rows}) == 1\n            if blocky and ok:\n                raise ValueError(filldedent('''\n                    Although this matrix is comprised of blocks,\n                    the blocks do not fill the matrix in a\n                    size-symmetric fashion. To create a full matrix\n                    from these arguments, pass them directly to\n                    Matrix.'''))\n            raise ValueError(filldedent('''\n                When there are not the same number of rows in each\n                row's matrices or there are not the same number of\n                total columns in each row, the matrix is not a\n                block matrix. If this matrix is known to consist of\n                blocks fully filling a 2-D space then see\n                Matrix.irregular.'''))\n    mat = ImmutableDenseMatrix(rows, evaluate=False)\n    obj = Basic.__new__(cls, mat)\n    return obj",
    "sympy.sympy.matrices.expressions.blockmatrix._choose_2x2_inversion_formula": "def _choose_2x2_inversion_formula(A, B, C, D):\n    \"\"\"\n    Assuming [[A, B], [C, D]] would form a valid square block matrix, find\n    which of the classical 2x2 block matrix inversion formulas would be\n    best suited.\n\n    Returns 'A', 'B', 'C', 'D' to represent the algorithm involving inversion\n    of the given argument or None if the matrix cannot be inverted using\n    any of those formulas.\n    \"\"\"\n    # Try to find a known invertible matrix.  Note that the Schur complement\n    # is currently not being considered for this\n    A_inv = ask(Q.invertible(A))\n    if A_inv == True:\n        return 'A'\n    B_inv = ask(Q.invertible(B))\n    if B_inv == True:\n        return 'B'\n    C_inv = ask(Q.invertible(C))\n    if C_inv == True:\n        return 'C'\n    D_inv = ask(Q.invertible(D))\n    if D_inv == True:\n        return 'D'\n    # Otherwise try to find a matrix that isn't known to be non-invertible\n    if A_inv != False:\n        return 'A'\n    if B_inv != False:\n        return 'B'\n    if C_inv != False:\n        return 'C'\n    if D_inv != False:\n        return 'D'\n    return None",
    "sympy.sympy.matrices.expressions.blockmatrix.<genexpr>": "if not isinstance(expr, BlockMatrix) or not all(d > 2 for d in expr.blockshape):\n    return expr\n\n",
    "sympy.sympy.matrices.repmatrix.__getitem__": "def __getitem__(self, key: tuple[int | Slice, int | Slice] | int | slice, /\n                ) -> Expr | Self | list[Expr]:\n    return _getitem_RepMatrix(self, key)"
}