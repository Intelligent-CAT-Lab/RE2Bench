{
    "matplotlib.lib.matplotlib.cbook.simple_linear_interpolation": "def simple_linear_interpolation(a, steps):\n    \"\"\"\n    Resample an array with ``steps - 1`` points between original point pairs.\n\n    Along each column of *a*, ``(steps - 1)`` points are introduced between\n    each original values; the values are linearly interpolated.\n\n    Parameters\n    ----------\n    a : array, shape (n, ...)\n    steps : int\n\n    Returns\n    -------\n    array\n        shape ``((n - 1) * steps + 1, ...)``\n    \"\"\"\n    fps = a.reshape((len(a), -1))\n    xp = np.arange(len(a)) * steps\n    x = np.arange((len(a) - 1) * steps + 1)\n    return (np.column_stack([np.interp(x, xp, fp) for fp in fps.T])\n            .reshape((len(x),) + a.shape[1:]))",
    "matplotlib.lib.matplotlib.path.vertices": "@property\ndef vertices(self):\n    \"\"\"The vertices of the `Path` as an (N, 2) array.\"\"\"\n    return self._vertices",
    "matplotlib.lib.matplotlib.path.codes": "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1D array.\n\n    Each code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n    `CLOSEPOLY`.  For codes that correspond to more than one vertex\n    (`CURVE3` and `CURVE4`), that code will be repeated so that the length\n    of `vertices` and `codes` is always the same.\n    \"\"\"\n    return self._codes",
    "matplotlib.lib.matplotlib.path.make_compound_path": "@classmethod\ndef make_compound_path(cls, *args):\n    r\"\"\"\n    Concatenate a list of `Path`\\s into a single `Path`, removing all `STOP`\\s.\n    \"\"\"\n    if not args:\n        return Path(np.empty([0, 2], dtype=np.float32))\n    vertices = np.concatenate([path.vertices for path in args])\n    codes = np.empty(len(vertices), dtype=cls.code_type)\n    i = 0\n    for path in args:\n        size = len(path.vertices)\n        if path.codes is None:\n            if size:\n                codes[i] = cls.MOVETO\n                codes[i+1:i+size] = cls.LINETO\n        else:\n            codes[i:i+size] = path.codes\n        i += size\n    not_stop_mask = codes != cls.STOP  # Remove STOPs, as internal STOPs are a bug.\n    return cls(vertices[not_stop_mask], codes[not_stop_mask])",
    "matplotlib.lib.matplotlib.path.__len__": "def __len__(self):\n    return len(self.vertices)",
    "matplotlib.lib.matplotlib.path.<genexpr>": "*(p.interpolated(steps) for p in self._iter_connected_components()))\n\n",
    "matplotlib.lib.matplotlib.path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : (N, 2) array-like\n        The path vertices, as an array, masked array or sequence of pairs.\n        Masked values, if any, will be converted to NaNs, which are then\n        handled correctly by the Agg PathIterator and other consumers of\n        path data, such as :meth:`iter_segments`.\n    codes : array-like or None, optional\n        N-length array of integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        `CLOSEPOLY`).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n\n    if codes is not None and len(vertices):\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'. \"\n                             f\"Your vertices have shape {vertices.shape} \"\n                             f\"but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             f\"to 'MOVETO' ({self.MOVETO}).  \"\n                             f\"Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False"
}