{
    "scikit-learn.sklearn.utils._encode._unique_python": "def _unique_python(values, *, return_inverse, return_counts):\n    # Only used in `_uniques`, see docstring there for details\n    try:\n        uniques_set = set(values)\n        uniques_set, missing_values = _extract_missing(uniques_set)\n\n        uniques = sorted(uniques_set)\n        uniques.extend(missing_values.to_list())\n        uniques = np.array(uniques, dtype=values.dtype)\n    except TypeError:\n        types = sorted(t.__qualname__ for t in set(type(v) for v in values))\n        raise TypeError(\n            \"Encoders require their input argument must be uniformly \"\n            f\"strings or numbers. Got {types}\"\n        )\n    ret = (uniques,)\n\n    if return_inverse:\n        ret += (_map_to_integer(values, uniques),)\n\n    if return_counts:\n        ret += (_get_counts(values, uniques),)\n\n    return ret[0] if len(ret) == 1 else ret",
    "scikit-learn.sklearn.utils._encode._unique_np": "def _unique_np(values, return_inverse=False, return_counts=False):\n    \"\"\"Helper function to find unique values for numpy arrays that correctly\n    accounts for nans. See `_unique` documentation for details.\"\"\"\n    xp, _ = get_namespace(values)\n\n    inverse, counts = None, None\n\n    if return_inverse and return_counts:\n        uniques, _, inverse, counts = xp.unique_all(values)\n    elif return_inverse:\n        uniques, inverse = xp.unique_inverse(values)\n    elif return_counts:\n        uniques, counts = xp.unique_counts(values)\n    else:\n        uniques = xp.unique_values(values)\n\n    # np.unique will have duplicate missing values at the end of `uniques`\n    # here we clip the nans and remove it from uniques\n    if uniques.size and is_scalar_nan(uniques[-1]):\n        nan_idx = xp.searchsorted(uniques, xp.nan)\n        uniques = uniques[: nan_idx + 1]\n        if return_inverse:\n            inverse[inverse > nan_idx] = nan_idx\n\n        if return_counts:\n            counts[nan_idx] = xp.sum(counts[nan_idx:])\n            counts = counts[: nan_idx + 1]\n\n    ret = (uniques,)\n\n    if return_inverse:\n        ret += (inverse,)\n\n    if return_counts:\n        ret += (counts,)\n\n    return ret[0] if len(ret) == 1 else ret"
}