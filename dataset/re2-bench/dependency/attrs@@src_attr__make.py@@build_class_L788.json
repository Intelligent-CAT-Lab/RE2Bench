{
    "attrs.src.attr._make._eval_snippets": "def _eval_snippets(self) -> None:\n    \"\"\"\n    Evaluate any registered snippets in one go.\n    \"\"\"\n    script = \"\\n\".join([snippet[0] for snippet in self._script_snippets])\n    globs = {}\n    for _, snippet_globs, _ in self._script_snippets:\n        globs.update(snippet_globs)\n\n    locs = _linecache_and_compile(\n        script,\n        _generate_unique_filename(self._cls, \"methods\"),\n        globs,\n    )\n\n    for _, _, hook in self._script_snippets:\n        hook(self._cls_dict, locs)",
    "attrs.src.attr._make._patch_original_class": "def _patch_original_class(self):\n    \"\"\"\n    Apply accumulated methods and return the class.\n    \"\"\"\n    cls = self._cls\n    base_names = self._base_names\n\n    # Clean class of attribute definitions (`attr.ib()`s).\n    if self._delete_attribs:\n        for name in self._attr_names:\n            if (\n                name not in base_names\n                and getattr(cls, name, _SENTINEL) is not _SENTINEL\n            ):\n                # An AttributeError can happen if a base class defines a\n                # class variable and we want to set an attribute with the\n                # same name by using only a type annotation.\n                with contextlib.suppress(AttributeError):\n                    delattr(cls, name)\n\n    # Attach our dunder methods.\n    for name, value in self._cls_dict.items():\n        setattr(cls, name, value)\n\n    # If we've inherited an attrs __setattr__ and don't write our own,\n    # reset it to object's.\n    if not self._wrote_own_setattr and getattr(\n        cls, \"__attrs_own_setattr__\", False\n    ):\n        cls.__attrs_own_setattr__ = False\n\n        if not self._has_custom_setattr:\n            cls.__setattr__ = _OBJ_SETATTR\n\n    return cls",
    "attrs.src.attr._make._create_slots_class": "def _create_slots_class(self):\n    \"\"\"\n    Build and return a new class with a `__slots__` attribute.\n    \"\"\"\n    cd = {\n        k: v\n        for k, v in self._cls_dict.items()\n        if k not in (*tuple(self._attr_names), \"__dict__\", \"__weakref__\")\n    }\n\n    # 3.14.0rc2+\n    if hasattr(sys, \"_clear_type_descriptors\"):\n        sys._clear_type_descriptors(self._cls)\n\n    # If our class doesn't have its own implementation of __setattr__\n    # (either from the user or by us), check the bases, if one of them has\n    # an attrs-made __setattr__, that needs to be reset. We don't walk the\n    # MRO because we only care about our immediate base classes.\n    # XXX: This can be confused by subclassing a slotted attrs class with\n    # XXX: a non-attrs class and subclass the resulting class with an attrs\n    # XXX: class.  See `test_slotted_confused` for details.  For now that's\n    # XXX: OK with us.\n    if not self._wrote_own_setattr:\n        cd[\"__attrs_own_setattr__\"] = False\n\n        if not self._has_custom_setattr:\n            for base_cls in self._cls.__bases__:\n                if base_cls.__dict__.get(\"__attrs_own_setattr__\", False):\n                    cd[\"__setattr__\"] = _OBJ_SETATTR\n                    break\n\n    # Traverse the MRO to collect existing slots\n    # and check for an existing __weakref__.\n    existing_slots = {}\n    weakref_inherited = False\n    for base_cls in self._cls.__mro__[1:-1]:\n        if base_cls.__dict__.get(\"__weakref__\", None) is not None:\n            weakref_inherited = True\n        existing_slots.update(\n            {\n                name: getattr(base_cls, name)\n                for name in getattr(base_cls, \"__slots__\", [])\n            }\n        )\n\n    base_names = set(self._base_names)\n\n    names = self._attr_names\n    if (\n        self._weakref_slot\n        and \"__weakref__\" not in getattr(self._cls, \"__slots__\", ())\n        and \"__weakref__\" not in names\n        and not weakref_inherited\n    ):\n        names += (\"__weakref__\",)\n\n    cached_properties = {\n        name: cached_prop.func\n        for name, cached_prop in cd.items()\n        if isinstance(cached_prop, cached_property)\n    }\n\n    # Collect methods with a `__class__` reference that are shadowed in the new class.\n    # To know to update them.\n    additional_closure_functions_to_update = []\n    if cached_properties:\n        class_annotations = _get_annotations(self._cls)\n        for name, func in cached_properties.items():\n            # Add cached properties to names for slotting.\n            names += (name,)\n            # Clear out function from class to avoid clashing.\n            del cd[name]\n            additional_closure_functions_to_update.append(func)\n            annotation = inspect.signature(func).return_annotation\n            if annotation is not inspect.Parameter.empty:\n                class_annotations[name] = annotation\n\n        original_getattr = cd.get(\"__getattr__\")\n        if original_getattr is not None:\n            additional_closure_functions_to_update.append(original_getattr)\n\n        cd[\"__getattr__\"] = _make_cached_property_getattr(\n            cached_properties, original_getattr, self._cls\n        )\n\n    # We only add the names of attributes that aren't inherited.\n    # Setting __slots__ to inherited attributes wastes memory.\n    slot_names = [name for name in names if name not in base_names]\n\n    # There are slots for attributes from current class\n    # that are defined in parent classes.\n    # As their descriptors may be overridden by a child class,\n    # we collect them here and update the class dict\n    reused_slots = {\n        slot: slot_descriptor\n        for slot, slot_descriptor in existing_slots.items()\n        if slot in slot_names\n    }\n    slot_names = [name for name in slot_names if name not in reused_slots]\n    cd.update(reused_slots)\n    if self._cache_hash:\n        slot_names.append(_HASH_CACHE_FIELD)\n\n    cd[\"__slots__\"] = tuple(slot_names)\n\n    cd[\"__qualname__\"] = self._cls.__qualname__\n\n    # Create new class based on old class and our methods.\n    cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)\n\n    # The following is a fix for\n    # <https://github.com/python-attrs/attrs/issues/102>.\n    # If a method mentions `__class__` or uses the no-arg super(), the\n    # compiler will bake a reference to the class in the method itself\n    # as `method.__closure__`.  Since we replace the class with a\n    # clone, we rewrite these references so it keeps working.\n    for item in itertools.chain(\n        cls.__dict__.values(), additional_closure_functions_to_update\n    ):\n        if isinstance(item, (classmethod, staticmethod)):\n            # Class- and staticmethods hide their functions inside.\n            # These might need to be rewritten as well.\n            closure_cells = getattr(item.__func__, \"__closure__\", None)\n        elif isinstance(item, property):\n            # Workaround for property `super()` shortcut (PY3-only).\n            # There is no universal way for other descriptors.\n            closure_cells = getattr(item.fget, \"__closure__\", None)\n        else:\n            closure_cells = getattr(item, \"__closure__\", None)\n\n        if not closure_cells:  # Catch None or the empty list.\n            continue\n        for cell in closure_cells:\n            try:\n                match = cell.cell_contents is self._cls\n            except ValueError:  # noqa: PERF203\n                # ValueError: Cell is empty\n                pass\n            else:\n                if match:\n                    cell.cell_contents = cls\n    return cls"
}