{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.relational.rhs": "@property\ndef rhs(self) -> Basic:\n    \"\"\"The right-hand side of the relation.\"\"\"\n    return self._args[1]",
    "sympy.sympy.core.relational.canonical": "@property\ndef canonical(self):\n    \"\"\"Return a canonical form of the relational by putting a\n    number on the rhs, canonically removing a sign or else\n    ordering the args canonically. No other simplification is\n    attempted.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> x < 2\n    x < 2\n    >>> _.reversed.canonical\n    x < 2\n    >>> (-y < x).canonical\n    x > -y\n    >>> (-y > x).canonical\n    x < -y\n    >>> (-y < -x).canonical\n    x < y\n\n    The canonicalization is recursively applied:\n\n    >>> from sympy import Eq\n    >>> Eq(x < y, y > x).canonical\n    True\n    \"\"\"\n    args = tuple([i.canonical if isinstance(i, Relational) else i for i in self.args])\n    if args != self.args:\n        r = self.func(*args)\n        if not isinstance(r, Relational):\n            return r\n    else:\n        r = self\n    if r.rhs.is_number:\n        if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:\n            r = r.reversed\n    elif r.lhs.is_number or tuple(ordered(args)) != args:\n        r = r.reversed\n\n    LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)\n    RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)\n\n    if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):\n        return r\n\n    # Check if first value has negative sign\n    if LHS_CEMS and LHS_CEMS():\n        return r.reversedsign\n    elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():\n        # Right hand side has a minus, but not lhs.\n        # How does the expression with reversed signs behave?\n        # This is so that expressions of the type\n        # Eq(x, -y) and Eq(-x, y)\n        # have the same canonical representation\n        expr1, _ = ordered([r.lhs, -r.rhs])\n        if expr1 != r.lhs:\n            return r.reversed.reversedsign\n\n    return r",
    "sympy.sympy.printing.str.stringify": "def stringify(self, args, sep, level=0):\n    return sep.join([self.parenthesize(item, level) for item in args])"
}