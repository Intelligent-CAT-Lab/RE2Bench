{
    "sympy.sympy.core.expr.equals": "def equals(self, other, failing_expression=False):\n    \"\"\"Return True if self == other, False if it does not, or None. If\n    failing_expression is True then the expression which did not simplify\n    to a 0 will be returned instead of None.\n\n    Explanation\n    ===========\n\n    If ``self`` is a Number (or complex number) that is not zero, then\n    the result is False.\n\n    If ``self`` is a number and has not evaluated to zero, evalf will be\n    used to test whether the expression evaluates to zero. If it does so\n    and the result has significance (i.e. the precision is either -1, for\n    a Rational result, or is greater than 1) then the evalf value will be\n    used to return True or False.\n\n    \"\"\"\n    from sympy.simplify.simplify import nsimplify, simplify\n    from sympy.solvers.solvers import solve\n    from sympy.polys.polyerrors import NotAlgebraic\n    from sympy.polys.numberfields import minimal_polynomial\n\n    other = sympify(other)\n\n    if not isinstance(other, Expr):\n        return False\n\n    if self == other:\n        return True\n\n    # they aren't the same so see if we can make the difference 0;\n    # don't worry about doing simplification steps one at a time\n    # because if the expression ever goes to 0 then the subsequent\n    # simplification steps that are done will be very fast.\n    diff = factor_terms(simplify(self - other), radical=True)\n\n    if not diff:\n        return True\n\n    if not diff.has(Add, Mod):\n        # if there is no expanding to be done after simplifying\n        # then this can't be a zero\n        return False\n\n    factors = diff.as_coeff_mul()[1]\n    if len(factors) > 1:  # avoid infinity recursion\n        fac_zero = [fac.equals(0) for fac in factors]\n        if None not in fac_zero:  # every part can be decided\n            return any(fac_zero)\n\n    constant = diff.is_constant(simplify=False, failing_number=True)\n\n    if constant is False:\n        return False\n\n    if not diff.is_number:\n        if constant is None:\n            # e.g. unless the right simplification is done, a symbolic\n            # zero is possible (see expression of issue 6829: without\n            # simplification constant will be None).\n            return\n\n    if constant is True:\n        # this gives a number whether there are free symbols or not\n        ndiff = diff._random()\n        # is_comparable will work whether the result is real\n        # or complex; it could be None, however.\n        if ndiff and ndiff.is_comparable:\n            return False\n\n    # sometimes we can use a simplified result to give a clue as to\n    # what the expression should be; if the expression is *not* zero\n    # then we should have been able to compute that and so now\n    # we can just consider the cases where the approximation appears\n    # to be zero -- we try to prove it via minimal_polynomial.\n    #\n    # removed\n    # ns = nsimplify(diff)\n    # if diff.is_number and (not ns or ns == diff):\n    #\n    # The thought was that if it nsimplifies to 0 that's a sure sign\n    # to try the following to prove it; or if it changed but wasn't\n    # zero that might be a sign that it's not going to be easy to\n    # prove. But tests seem to be working without that logic.\n    #\n    if diff.is_number:\n        # try to prove via self-consistency\n        surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n        # it seems to work better to try big ones first\n        surds.sort(key=lambda x: -x.args[0])\n        for s in surds:\n            try:\n                # simplify is False here -- this expression has already\n                # been identified as being hard to identify as zero;\n                # we will handle the checking ourselves using nsimplify\n                # to see if we are in the right ballpark or not and if so\n                # *then* the simplification will be attempted.\n                sol = solve(diff, s, simplify=False)\n                if sol:\n                    if s in sol:\n                        # the self-consistent result is present\n                        return True\n                    if all(si.is_Integer for si in sol):\n                        # perfect powers are removed at instantiation\n                        # so surd s cannot be an integer\n                        return False\n                    if all(i.is_algebraic is False for i in sol):\n                        # a surd is algebraic\n                        return False\n                    if any(si in surds for si in sol):\n                        # it wasn't equal to s but it is in surds\n                        # and different surds are not equal\n                        return False\n                    if any(nsimplify(s - si) == 0 and\n                            simplify(s - si) == 0 for si in sol):\n                        return True\n                    if s.is_real:\n                        if any(nsimplify(si, [s]) == s and simplify(si) == s\n                                for si in sol):\n                            return True\n            except NotImplementedError:\n                pass\n\n        # try to prove with minimal_polynomial but know when\n        # *not* to use this or else it can take a long time. e.g. issue 8354\n        if True:  # change True to condition that assures non-hang\n            try:\n                mp = minimal_polynomial(diff)\n                if mp.is_Symbol:\n                    return True\n                return False\n            except (NotAlgebraic, NotImplementedError):\n                pass\n\n    # diff has not simplified to zero; constant is either None, True\n    # or the number with significance (is_comparable) that was randomly\n    # calculated twice as the same value.\n    if constant not in (True, None) and constant != 0:\n        return False\n\n    if failing_expression:\n        return diff\n    return None",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    eq = self.__eq__(other)\n    if eq is NotImplemented:\n        return eq\n    else:\n        return not eq",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.geometry.point.<lambda>": "return m.rank(iszerofunc = lambda x:\n    abs(x.n(2)) < 1e-12 if x.is_number else x.is_zero)\n\n",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.matrices.determinant.<genexpr>": "if all(isinstance(x, (Float, Integer)) for x in col) and any(\n        isinstance(x, Float) for x in col):\n    col_abs = [abs(x) for x in col]\n    max_value = max(col_abs)\n    if iszerofunc(max_value):\n        # just because iszerofunc returned True, doesn't\n        # mean the value is numerically zero.  Make sure\n        # to replace all entries with numerical zeros\n        if max_value != 0:\n            newly_determined = [(i, S.Zero) for i, x in enumerate(col) if x != 0]\n        return (None, None, False, newly_determined)\n    index = col_abs.index(max_value)\n    return (index, col[index], False, newly_determined)\n\n# PASS 1 (iszerofunc directly)\n",
    "sympy.sympy.matrices.determinant.<listcomp>": "newly_determined = [(i, S.Zero) for i, x in enumerate(col) if x != 0]\n",
    "sympy.sympy.matrices.utilities._iszero": "def _iszero(x: Expr) -> bool | None:\n    \"\"\"Returns True if x is zero.\"\"\"\n    return getattr(x, 'is_zero', None)",
    "sympy.sympy.matrices.utilities._is_zero_after_expand_mul": "def _is_zero_after_expand_mul(x):\n    \"\"\"Tests by expand_mul only, suitable for polynomials and rational\n    functions.\"\"\"\n    return expand_mul(x) == 0",
    "sympy.sympy.matrices.utilities._simplify": "def _simplify(expr):\n    \"\"\" Wrapper to avoid circular imports. \"\"\"\n    from sympy.simplify.simplify import simplify\n    return simplify(expr)",
    "sympy.sympy.simplify.simplify.signsimp": "def signsimp(expr, evaluate=None):\n    \"\"\"Make all Add sub-expressions canonical wrt sign.\n\n    Explanation\n    ===========\n\n    If an Add subexpression, ``a``, can have a sign extracted,\n    as determined by could_extract_minus_sign, it is replaced\n    with Mul(-1, a, evaluate=False). This allows signs to be\n    extracted from powers and products.\n\n    Examples\n    ========\n\n    >>> from sympy import signsimp, exp, symbols\n    >>> from sympy.abc import x, y\n    >>> i = symbols('i', odd=True)\n    >>> n = -1 + 1/x\n    >>> n/x/(-n)**2 - 1/n/x\n    (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))\n    >>> signsimp(_)\n    0\n    >>> x*n + x*-n\n    x*(-1 + 1/x) + x*(1 - 1/x)\n    >>> signsimp(_)\n    0\n\n    Since powers automatically handle leading signs\n\n    >>> (-2)**i\n    -2**i\n\n    signsimp can be used to put the base of a power with an integer\n    exponent into canonical form:\n\n    >>> n**i\n    (-1 + 1/x)**i\n\n    By default, signsimp does not leave behind any hollow simplification:\n    if making an Add canonical wrt sign didn't change the expression, the\n    original Add is restored. If this is not desired then the keyword\n    ``evaluate`` can be set to False:\n\n    >>> e = exp(y - x)\n    >>> signsimp(e) == e\n    True\n    >>> signsimp(e, evaluate=False)\n    exp(-(x - y))\n\n    \"\"\"\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    expr = sympify(expr)\n    if not isinstance(expr, (Expr, Relational)) or expr.is_Atom:\n        return expr\n    # get rid of an pre-existing unevaluation regarding sign\n    e = expr.replace(lambda x: x.is_Mul and -(-x) != x, lambda x: -(-x))\n    e = sub_post(sub_pre(e))\n    if not isinstance(e, (Expr, Relational)) or e.is_Atom:\n        return e\n    if e.is_Add:\n        rv = e.func(*[signsimp(a) for a in e.args])\n        if not evaluate and isinstance(rv, Add\n                ) and rv.could_extract_minus_sign():\n            return Mul(S.NegativeOne, -rv, evaluate=False)\n        return rv\n    if evaluate:\n        e = e.replace(lambda x: x.is_Mul and -(-x) != x, lambda x: -(-x))\n    return e"
}