{
    "matplotlib.lib.matplotlib.bezier.inside_circle": "def inside_circle(cx, cy, r):\n    \"\"\"\n    Return a function that checks whether a point is in a circle with center\n    (*cx*, *cy*) and radius *r*.\n\n    The returned function has the signature::\n\n        f(xy: tuple[float, float]) -> bool\n    \"\"\"\n    r2 = r ** 2\n\n    def _f(xy):\n        x, y = xy\n        return (x - cx) ** 2 + (y - cy) ** 2 < r2\n    return _f",
    "matplotlib.lib.matplotlib.patches._in_patch": "def _in_patch(self, patch):\n    \"\"\"\n    Return a predicate function testing whether a point *xy* is\n    contained in *patch*.\n    \"\"\"\n    return lambda xy: patch.contains(\n        SimpleNamespace(x=xy[0], y=xy[1]))[0]",
    "matplotlib.lib.matplotlib.patches._clip": "def _clip(self, path, in_start, in_stop):\n    \"\"\"\n    Clip *path* at its start by the region where *in_start* returns\n    True, and at its stop by the region where *in_stop* returns True.\n\n    The original path is assumed to start in the *in_start* region and\n    to stop in the *in_stop* region.\n    \"\"\"\n    if in_start:\n        try:\n            _, path = split_path_inout(path, in_start)\n        except ValueError:\n            pass\n    if in_stop:\n        try:\n            path, _ = split_path_inout(path, in_stop)\n        except ValueError:\n            pass\n    return path",
    "matplotlib.lib.matplotlib.patches.connect": "def connect(self, posA, posB):\n    x1, y1 = posA\n    x20, y20 = x2, y2 = posB\n\n    theta1 = math.atan2(y2 - y1, x2 - x1)\n    dx, dy = x2 - x1, y2 - y1\n    dd = (dx * dx + dy * dy) ** .5\n    ddx, ddy = dx / dd, dy / dd\n\n    armA, armB = self.armA, self.armB\n\n    if self.angle is not None:\n        theta0 = np.deg2rad(self.angle)\n        dtheta = theta1 - theta0\n        dl = dd * math.sin(dtheta)\n        dL = dd * math.cos(dtheta)\n        x2, y2 = x1 + dL * math.cos(theta0), y1 + dL * math.sin(theta0)\n        armB = armB - dl\n\n        # update\n        dx, dy = x2 - x1, y2 - y1\n        dd2 = (dx * dx + dy * dy) ** .5\n        ddx, ddy = dx / dd2, dy / dd2\n\n    arm = max(armA, armB)\n    f = self.fraction * dd + arm\n\n    cx1, cy1 = x1 + f * ddy, y1 - f * ddx\n    cx2, cy2 = x2 + f * ddy, y2 - f * ddx\n\n    vertices = [(x1, y1),\n                (cx1, cy1),\n                (cx2, cy2),\n                (x20, y20)]\n    codes = [Path.MOVETO,\n             Path.LINETO,\n             Path.LINETO,\n             Path.LINETO]\n\n    return Path(vertices, codes)",
    "matplotlib.lib.matplotlib.path.vertices": "@property\ndef vertices(self):\n    \"\"\"The vertices of the `Path` as an (N, 2) array.\"\"\"\n    return self._vertices"
}