{
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.polys.agca.extensions.__bool__": "def __bool__(f):\n    return bool(f.rep)",
    "sympy.sympy.polys.domains.expressiondomain.__bool__": "def __bool__(f):\n    return not f.ex.is_zero",
    "sympy.sympy.polys.domains.gaussiandomains.__bool__": "def __bool__(self) -> bool:\n    return bool(self.x) or bool(self.y)",
    "sympy.sympy.polys.domains.modularinteger.__bool__": "def __bool__(self):\n    return bool(self.val)",
    "sympy.sympy.polys.fields.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    "sympy.sympy.polys.matrices.sdm.<lambda>": "Ak = unop_dict(A, lambda e: K.convert_from(e, Kold))\n",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)",
    "sympy.sympy.polys.polytools.__bool__": "def __bool__(f):\n    return not f.is_zero",
    "sympy.sympy.polys.rings.__neg__": "def __neg__(self) -> PolyElement[Er]:\n    # Return (-1) * self in case of python-flint\n    return self.new([(monom, -coeff) for monom, coeff in self.iterterms()])"
}