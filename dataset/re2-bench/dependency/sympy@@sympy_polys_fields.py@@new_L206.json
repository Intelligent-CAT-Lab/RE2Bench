{
    "sympy.sympy.polys.fields.raw_new": "def raw_new(self,\n        numer: PolyElement[Er],\n        denom: PolyElement[Er] | None = None) -> FracElement[Er]:\n    return self.dtype(numer, denom)",
    "sympy.sympy.polys.rings.cancel": "def cancel(self, g: PolyElement[Er]) -> tuple[PolyElement[Er], PolyElement[Er]]:\n    \"\"\"\n    Cancel common factors in a rational function ``f/g``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> (2*x**2 - 2).cancel(x**2 - 2*x + 1)\n    (2*x + 2, x - 1)\n\n    \"\"\"\n    f = self\n    ring = f.ring\n\n    if not f:\n        return f, ring.one\n\n    domain = ring.domain\n\n    if not (domain.is_Field and domain.has_assoc_Ring):\n        _, p, q = f.cofactors(g)\n    else:\n        new_ring = ring.clone(domain=domain.get_ring())\n\n        cq, f = f.clear_denoms()\n        cp, g = g.clear_denoms()\n\n        f = f.set_ring(new_ring)\n        g = g.set_ring(new_ring)\n\n        _, p, q = f.cofactors(g)\n        _, cp, cq = new_ring.domain.cofactors(cp, cq)\n\n        p = p.set_ring(ring)\n        q = q.set_ring(ring)\n\n        p = p.mul_ground(cp)\n        q = q.mul_ground(cq)\n\n    # Make canonical with respect to sign or quadrant in the case of ZZ_I\n    # or QQ_I. This ensures that the LC of the denominator is canonical by\n    # multiplying top and bottom by a unit of the ring.\n    u = q.canonical_unit()\n    if u == domain.one:\n        pass\n    elif u == -domain.one:\n        p, q = -p, -q\n    else:\n        p = p.mul_ground(u)\n        q = q.mul_ground(u)\n\n    return p, q",
    "sympy.sympy.polys.rings.one": "@property\ndef one(self) -> PolyElement[Er]:\n    \"\"\"The unit polynomial.\"\"\"\n    return self.dtype(self._one)"
}