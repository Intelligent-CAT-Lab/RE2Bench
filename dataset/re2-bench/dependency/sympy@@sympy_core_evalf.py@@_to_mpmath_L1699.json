{
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.evalf.evalf": "def evalf(x: Expr, prec: int, options: OPT_DICT) -> TMP_RES:\n    \"\"\"\n    Evaluate the ``Expr`` instance, ``x``\n    to a binary precision of ``prec``. This\n    function is supposed to be used internally.\n\n    Parameters\n    ==========\n\n    x : Expr\n        The formula to evaluate to a float.\n    prec : int\n        The binary precision that the output should have.\n    options : dict\n        A dictionary with the same entries as\n        ``EvalfMixin.evalf`` and in addition,\n        ``maxprec`` which is the maximum working precision.\n\n    Returns\n    =======\n\n    An optional tuple, ``(re, im, re_acc, im_acc)``\n    which are the real, imaginary, real accuracy\n    and imaginary accuracy respectively. ``re`` is\n    an mpf value tuple and so is ``im``. ``re_acc``\n    and ``im_acc`` are ints.\n\n    NB: all these return values can be ``None``.\n    If all values are ``None``, then that represents 0.\n    Note that 0 is also represented as ``fzero = (0, 0, 0, 0)``.\n    \"\"\"\n    from sympy.functions.elementary.complexes import re as re_, im as im_\n    try:\n        rf = evalf_table[type(x)]\n        r = rf(x, prec, options)\n    except KeyError:\n        # Fall back to ordinary evalf if possible\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, \"as_real_imag\", None)\n        if as_real_imag is None:\n            raise NotImplementedError # e.g. FiniteSet(-1.0, 1.0).evalf()\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if not re:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if not im:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = re, im, reprec, imprec\n\n    if options.get(\"verbose\"):\n        print(\"### input\", x)\n        print(\"### output\", to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)\n        print(\"### raw\", r) # r[0], r[2]\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            # convert (approximately) from given tolerance;\n            # the formula here will will make 1e-i rounds to 0 for\n            # i in the range +/-27 while 2e-i will not be chopped\n            chop_prec = int(round(-3.321*math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get(\"strict\"):\n        check_target(x, r, prec)\n    return r",
    "sympy.sympy.core.evalf.quad_to_mpmath": "def quad_to_mpmath(q, ctx=None):\n    \"\"\"Turn the quad returned by ``evalf`` into an ``mpf`` or ``mpc``. \"\"\"\n    mpc = make_mpc if ctx is None else ctx.make_mpc\n    mpf = make_mpf if ctx is None else ctx.make_mpf\n    if q is S.ComplexInfinity:\n        raise NotImplementedError\n    re, im, _, _ = q\n    if im:\n        if not re:\n            re = fzero\n        return mpc((re, im))\n    elif re:\n        return mpf(re)\n    else:\n        return mpf(fzero)",
    "sympy.sympy.core.evalf._eval_evalf": "def _eval_evalf(self, prec: int) -> Expr | None:\n    return None",
    "sympy.sympy.core.expr.as_real_imag": "def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:\n    \"\"\"Performs complex expansion on 'self' and returns a tuple\n       containing collected both real and imaginary parts. This\n       method cannot be confused with re() and im() functions,\n       which does not perform complex expansion at evaluation.\n\n       However it is possible to expand both re() and im()\n       functions and get exactly the same results as with\n       a single call to this function.\n\n       >>> from sympy import symbols, I\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> (x + y*I).as_real_imag()\n       (x, y)\n\n       >>> from sympy.abc import z, w\n\n       >>> (z + w*I).as_real_imag()\n       (re(z) - im(w), re(w) + im(z))\n\n    \"\"\"\n    if hints.get('ignore') == self:\n        return None  # type: ignore\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    "sympy.sympy.core.function._eval_evalf": "def _eval_evalf(self, prec):\n\n    def _get_mpmath_func(fname):\n        \"\"\"Lookup mpmath function based on name\"\"\"\n        if isinstance(self, AppliedUndef):\n            # Shouldn't lookup in mpmath but might have ._imp_\n            return None\n\n        if not hasattr(mpmath, fname):\n            fname = MPMATH_TRANSLATIONS.get(fname, None)\n            if fname is None:\n                return None\n        return getattr(mpmath, fname)\n\n    _eval_mpmath = getattr(self, '_eval_mpmath', None)\n    if _eval_mpmath is None:\n        func = _get_mpmath_func(self.func.__name__)\n        args = self.args\n    else:\n        func, args = _eval_mpmath()\n\n    # Fall-back evaluation\n    if func is None:\n        imp = getattr(self, '_imp_', None)\n        if imp is None:\n            return None\n        try:\n            return Float(imp(*[i.evalf(prec) for i in self.args]), prec)\n        except (TypeError, ValueError):\n            return None\n\n    # Convert all args to mpf or mpc\n    # Convert the arguments to *higher* precision than requested for the\n    # final result.\n    # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should\n    #     we be more intelligent about it?\n    try:\n        args = [arg._to_mpmath(prec + 5) for arg in args]\n        def bad(m):\n            from mpmath import mpf, mpc\n            # the precision of an mpf value is the last element\n            # if that is 1 (and m[1] is not 1 which would indicate a\n            # power of 2), then the eval failed; so check that none of\n            # the arguments failed to compute to a finite precision.\n            # Note: An mpc value has two parts, the re and imag tuple;\n            # check each of those parts, too. Anything else is allowed to\n            # pass\n            if isinstance(m, mpf):\n                m = m._mpf_\n                return m[1] !=1 and m[-1] == 1\n            elif isinstance(m, mpc):\n                m, n = m._mpc_\n                return m[1] !=1 and m[-1] == 1 and \\\n                    n[1] !=1 and n[-1] == 1\n            else:\n                return False\n        if any(bad(a) for a in args):\n            raise ValueError  # one or more args failed to compute with significance\n    except ValueError:\n        return\n\n    with mpmath.workprec(prec):\n        v = func(*args)\n\n    return Expr._from_mpmath(v, prec)",
    "sympy.sympy.core.mul._eval_evalf": "def _eval_evalf(self, prec):\n    c, m = self.as_coeff_Mul()\n    if c is S.NegativeOne:\n        if m.is_Mul:\n            rv = -AssocOp._eval_evalf(m, prec)\n        else:\n            mnew = m._eval_evalf(prec)\n            if mnew is not None:\n                m = mnew\n            rv = -m\n    else:\n        rv = AssocOp._eval_evalf(self, prec)\n    if rv.is_number:\n        return rv.expand()\n    return rv",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers._as_mpf_val": "def _as_mpf_val(self, prec):\n    rv = mpf_norm(self._mpf_, prec)\n    if rv != self._mpf_ and self._prec == prec:\n        debug(self._mpf_, rv)\n    return rv",
    "sympy.sympy.core.operations._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\"\n    Evaluate the parts of self that are numbers; if the whole thing\n    was a number with no functions it would have been evaluated, but\n    it wasn't so we must judiciously extract the numbers and reconstruct\n    the object. This is *not* simply replacing numbers with evaluated\n    numbers. Numbers should be handled in the largest pure-number\n    expression as possible. So the code below separates ``self`` into\n    number and non-number parts and evaluates the number parts and\n    walks the args of the non-number part recursively (doing the same\n    thing).\n    \"\"\"\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        # if x is an AssocOp Function then the _evalf below will\n        # call _eval_evalf (here) so we must break the recursion\n        if not (tail is self.identity or\n                isinstance(x, AssocOp) and x.is_Function or\n                x is self.identity and isinstance(tail, AssocOp)):\n            # here, we have a number so we just call to _evalf with prec;\n            # prec is not the same as n, it is the binary precision so\n            # that's why we don't call to evalf.\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                # here we call to _eval_evalf since we don't know what we\n                # are dealing with and all other _eval_evalf routines should\n                # be doing the same thing (i.e. taking binary prec and\n                # finding the evalf-able args)\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n\n    # this is the same as above, but there were no pure-number args to\n    # deal with\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    "sympy.sympy.core.power.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if self.exp.is_Integer:\n        from sympy.polys.polytools import poly\n\n        exp = self.exp\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n        if not im_e:\n            return self, S.Zero\n        a, b = symbols('a b', cls=Dummy)\n        if exp >= 0:\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial(self.base**exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly(\n                (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp\n        else:\n            mag = re_e**2 + im_e**2\n            re_e, im_e = re_e/mag, -im_e/mag\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial((re_e + im_e*S.ImaginaryUnit)**-exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly((a + b)**-exp)\n\n        # Terms with even b powers will be real\n        r = [i for i in expr.terms() if not i[0][1] % 2]\n        re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        # Terms with odd b powers will be imaginary\n        r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n        im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n        im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n\n        return (re_part.subs({a: re_e, b: S.ImaginaryUnit*im_e}),\n        im_part1.subs({a: re_e, b: im_e}) + im_part3.subs({a: re_e, b: -im_e}))\n\n    from sympy.functions.elementary.trigonometric import atan2, cos, sin\n\n    if self.exp.is_Rational:\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n\n        if im_e.is_zero and self.exp is S.Half:\n            if re_e.is_extended_nonnegative:\n                return self, S.Zero\n            if re_e.is_extended_nonpositive:\n                return S.Zero, (-self.base)**self.exp\n\n        # XXX: This is not totally correct since for x**(p/q) with\n        #      x being imaginary there are actually q roots, but\n        #      only a single one is returned from here.\n        r = self.func(self.func(re_e, 2) + self.func(im_e, 2), S.Half)\n\n        t = atan2(im_e, re_e)\n\n        rp, tp = self.func(r, self.exp), t*self.exp\n\n        return rp*cos(tp), rp*sin(tp)\n    elif self.base is S.Exp1:\n        from sympy.functions.elementary.exponential import exp\n        re_e, im_e = self.exp.as_real_imag()\n        if deep:\n            re_e = re_e.expand(deep, **hints)\n            im_e = im_e.expand(deep, **hints)\n        c, s = cos(im_e), sin(im_e)\n        return exp(re_e)*c, exp(re_e)*s\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        if deep:\n            hints['complex'] = False\n\n            expanded = self.expand(deep, **hints)\n            if hints.get('ignore') == expanded:\n                return None\n            else:\n                return (re(expanded), im(expanded))\n        else:\n            return re(self), im(self)",
    "sympy.sympy.core.power._eval_evalf": "def _eval_evalf(self, prec):\n    base, exp = self.as_base_exp()\n    if base == S.Exp1:\n        # Use mpmath function associated to class \"exp\":\n        from sympy.functions.elementary.exponential import exp as exp_function\n        return exp_function(self.exp, evaluate=False)._eval_evalf(prec)\n    base = base._evalf(prec)\n    if not exp.is_Integer:\n        exp = exp._evalf(prec)\n    if exp.is_negative and base.is_number and base.is_extended_real is False:\n        base = base.conjugate() / (base * base.conjugate())._evalf(prec)\n        exp = -exp\n        return self.func(base, exp).expand()\n    return self.func(base, exp)",
    "sympy.sympy.functions.elementary.exponential._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    i = im(self.args[0])\n    try:\n        bad = (i <= -pi or i > pi)\n    except TypeError:\n        bad = True\n    if bad:\n        return self  # cannot evalf for this argument\n    res = exp(self.args[0])._eval_evalf(prec)\n    if i > 0 and im(res) < 0:\n        # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi\n        return re(res)\n    return res"
}