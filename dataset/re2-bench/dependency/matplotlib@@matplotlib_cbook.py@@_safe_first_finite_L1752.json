{
    "matplotlib.lib.matplotlib.cbook.safe_first_element": "def safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is a type-independent way of obtaining the first element,\n    supporting both index access and the iterator protocol.\n    \"\"\"\n    if isinstance(obj, collections.abc.Iterator):\n        # needed to accept `array.flat` as input.\n        # np.flatiter reports as an instance of collections.Iterator but can still be\n        # indexed via []. This has the side effect of re-setting the iterator, but\n        # that is acceptable.\n        try:\n            return obj[0]\n        except TypeError:\n            pass\n        raise RuntimeError(\"matplotlib does not support generators as input\")\n    return next(iter(obj))",
    "matplotlib.lib.matplotlib.cbook.safe_isfinite": "def safe_isfinite(val):\n    if val is None:\n        return False\n    try:\n        return math.isfinite(val)\n    except (TypeError, ValueError):\n        # if the outer object is 2d, then val is a 1d array, and\n        # - math.isfinite(numpy.zeros(3)) raises TypeError\n        # - math.isfinite(torch.zeros(3)) raises ValueError\n        pass\n    try:\n        return np.isfinite(val) if np.isscalar(val) else True\n    except TypeError:\n        # This is something that NumPy cannot make heads or tails of,\n        # assume \"finite\"\n        return True"
}