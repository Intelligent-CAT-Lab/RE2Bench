{
    "sympy.sympy.assumptions.cnf.__init__": "def __init__(self, clauses=None):\n    if not clauses:\n        clauses = set()\n    self.clauses = clauses",
    "sympy.sympy.assumptions.cnf.extend": "def extend(self, props):\n    for p in props:\n        self.add(p)\n    return self",
    "sympy.sympy.assumptions.cnf.from_prop": "@classmethod\ndef from_prop(cls, prop):\n    res = cls()\n    res.add(prop)\n    return res",
    "sympy.sympy.assumptions.cnf.add_from_cnf": "def add_from_cnf(self, cnf):\n    clauses = [self.encode(clause) for clause in cnf.clauses]\n    self.data += clauses",
    "sympy.sympy.assumptions.satask.get_all_relevant_facts": "def get_all_relevant_facts(proposition, assumptions, context,\n        use_known_facts=True, iterations=oo):\n    \"\"\"\n    Extract all relevant facts from *proposition* and *assumptions*.\n\n    This function extracts the facts by recursively calling\n    ``get_relevant_clsfacts()``. Extracted facts are converted to\n    ``EncodedCNF`` and returned.\n\n    Parameters\n    ==========\n\n    proposition : sympy.assumptions.cnf.CNF\n        CNF generated from proposition expression.\n\n    assumptions : sympy.assumptions.cnf.CNF\n        CNF generated from assumption expression.\n\n    context : sympy.assumptions.cnf.CNF\n        CNF generated from assumptions context.\n\n    use_known_facts : bool, optional.\n        If ``True``, facts from ``sympy.assumptions.ask_generated``\n        module are encoded as well.\n\n    iterations : int, optional.\n        Number of times that relevant facts are recursively extracted.\n        Default is infinite times until no new fact is found.\n\n    Returns\n    =======\n\n    sympy.assumptions.cnf.EncodedCNF\n\n    Examples\n    ========\n\n    >>> from sympy import Q\n    >>> from sympy.assumptions.cnf import CNF\n    >>> from sympy.assumptions.satask import get_all_relevant_facts\n    >>> from sympy.abc import x, y\n    >>> props = CNF.from_prop(Q.nonzero(x*y))\n    >>> assump = CNF.from_prop(Q.nonzero(x))\n    >>> context = CNF.from_prop(Q.nonzero(y))\n    >>> get_all_relevant_facts(props, assump, context) #doctest: +SKIP\n    <sympy.assumptions.cnf.EncodedCNF at 0x7f09faa6ccd0>\n\n    \"\"\"\n    # The relevant facts might introduce new keys, e.g., Q.zero(x*y) will\n    # introduce the keys Q.zero(x) and Q.zero(y), so we need to run it until\n    # we stop getting new things. Hopefully this strategy won't lead to an\n    # infinite loop in the future.\n    i = 0\n    relevant_facts = CNF()\n    all_exprs = set()\n    while True:\n        if i == 0:\n            exprs = extract_predargs(proposition, assumptions, context)\n        all_exprs |= exprs\n        exprs, relevant_facts = get_relevant_clsfacts(exprs, relevant_facts)\n        i += 1\n        if i >= iterations:\n            break\n        if not exprs:\n            break\n\n    if use_known_facts:\n        known_facts_CNF = CNF()\n\n        if any(expr.kind == MatrixKind(NumberKind) for expr in all_exprs):\n            known_facts_CNF.add_clauses(get_all_known_matrix_facts())\n        # check for undefinedKind since kind system isn't fully implemented\n        if any(((expr.kind == NumberKind) or (expr.kind == UndefinedKind)) for expr in all_exprs):\n            known_facts_CNF.add_clauses(get_all_known_number_facts())\n\n        kf_encoded = EncodedCNF()\n        kf_encoded.from_cnf(known_facts_CNF)\n\n        def translate_literal(lit, delta):\n            if lit > 0:\n                return lit + delta\n            else:\n                return lit - delta\n\n        def translate_data(data, delta):\n            return [{translate_literal(i, delta) for i in clause} for clause in data]\n        data = []\n        symbols = []\n        n_lit = len(kf_encoded.symbols)\n        for i, expr in enumerate(all_exprs):\n            symbols += [pred(expr) for pred in kf_encoded.symbols]\n            data += translate_data(kf_encoded.data, i * n_lit)\n\n        encoding = dict(list(zip(symbols, range(1, len(symbols)+1))))\n        ctx = EncodedCNF(data, encoding)\n    else:\n        ctx = EncodedCNF()\n\n    ctx.add_from_cnf(relevant_facts)\n\n    return ctx",
    "sympy.sympy.assumptions.satask.check_satisfiability": "def check_satisfiability(prop, _prop, factbase):\n    sat_true = factbase.copy()\n    sat_false = factbase.copy()\n    sat_true.add_from_cnf(prop)\n    sat_false.add_from_cnf(_prop)\n    can_be_true = satisfiable(sat_true)\n    can_be_false = satisfiable(sat_false)\n\n    if can_be_true and can_be_false:\n        return None\n\n    if can_be_true and not can_be_false:\n        return True\n\n    if not can_be_true and can_be_false:\n        return False\n\n    if not can_be_true and not can_be_false:\n        # TODO: Run additional checks to see which combination of the\n        # assumptions, global_assumptions, and relevant_facts are\n        # inconsistent.\n        raise ValueError(\"Inconsistent assumptions\")",
    "sympy.sympy.logic.boolalg.__invert__": "def __invert__(self):\n    \"\"\"Overloading for ~\"\"\"\n    return Not(self)"
}