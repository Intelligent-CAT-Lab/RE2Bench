{
    "matplotlib.lib.matplotlib.tri._triinterpolate._safe_inv22_vectorized": "def _safe_inv22_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) matrices, returns 0 for rank-deficient\n    matrices.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    _api.check_shape((None, 2, 2), M=M)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n\n    # We set delta_inv to 0. in case of a rank deficient matrix; a\n    # rank-deficient input matrix *M* will lead to a null matrix in output\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        delta_inv = 1./delta\n    else:\n        # 'Pathologic' flow.\n        delta_inv = np.zeros(M.shape[0])\n        delta_inv[rank2] = 1./delta[rank2]\n\n    M_inv[:, 0, 0] = M[:, 1, 1]*delta_inv\n    M_inv[:, 0, 1] = -M[:, 0, 1]*delta_inv\n    M_inv[:, 1, 0] = -M[:, 1, 0]*delta_inv\n    M_inv[:, 1, 1] = M[:, 0, 0]*delta_inv\n    return M_inv",
    "matplotlib.lib.matplotlib.tri._triinterpolate._scalar_vectorized": "def _scalar_vectorized(scalar, M):\n    \"\"\"\n    Scalar product between scalars and matrices.\n    \"\"\"\n    return scalar[:, np.newaxis, np.newaxis]*M",
    "matplotlib.lib.matplotlib.tri._triinterpolate._transpose_vectorized": "def _transpose_vectorized(M):\n    \"\"\"\n    Transposition of an array of matrices *M*.\n    \"\"\"\n    return np.transpose(M, [0, 2, 1])",
    "matplotlib.lib.matplotlib.tri._triinterpolate._roll_vectorized": "def _roll_vectorized(M, roll_indices, axis):\n    \"\"\"\n    Roll an array of matrices along *axis* (0: rows, 1: columns) according to\n    an array of indices *roll_indices*.\n    \"\"\"\n    assert axis in [0, 1]\n    ndim = M.ndim\n    assert ndim == 3\n    ndim_roll = roll_indices.ndim\n    assert ndim_roll == 1\n    sh = M.shape\n    r, c = sh[-2:]\n    assert sh[0] == roll_indices.shape[0]\n    vec_indices = np.arange(sh[0], dtype=np.int32)\n\n    # Builds the rolled matrix\n    M_roll = np.empty_like(M)\n    if axis == 0:\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, (-roll_indices+ir) % r, ic]\n    else:  # 1\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, ir, (-roll_indices+ic) % c]\n    return M_roll",
    "matplotlib.lib.matplotlib.tri._triinterpolate._to_matrix_vectorized": "def _to_matrix_vectorized(M):\n    \"\"\"\n    Build an array of matrices from individuals np.arrays of identical shapes.\n\n    Parameters\n    ----------\n    M\n        ncols-list of nrows-lists of shape sh.\n\n    Returns\n    -------\n    M_res : np.array of shape (sh, nrow, ncols)\n        *M_res* satisfies ``M_res[..., i, j] = M[i][j]``.\n    \"\"\"\n    assert isinstance(M, (tuple, list))\n    assert all(isinstance(item, (tuple, list)) for item in M)\n    c_vec = np.asarray([len(item) for item in M])\n    assert np.all(c_vec-c_vec[0] == 0)\n    r = len(M)\n    c = c_vec[0]\n    M00 = np.asarray(M[0][0])\n    dt = M00.dtype\n    sh = [M00.shape[0], r, c]\n    M_ret = np.empty(sh, dtype=dt)\n    for irow in range(r):\n        for icol in range(c):\n            M_ret[:, irow, icol] = np.asarray(M[irow][icol])\n    return M_ret",
    "matplotlib.lib.matplotlib.tri._triinterpolate._extract_submatrices": "def _extract_submatrices(M, block_indices, block_size, axis):\n    \"\"\"\n    Extract selected blocks of a matrices *M* depending on parameters\n    *block_indices* and *block_size*.\n\n    Returns the array of extracted matrices *Mres* so that ::\n\n        M_res[..., ir, :] = M[(block_indices*block_size+ir), :]\n    \"\"\"\n    assert block_indices.ndim == 1\n    assert axis in [0, 1]\n\n    r, c = M.shape\n    if axis == 0:\n        sh = [block_indices.shape[0], block_size, c]\n    else:  # 1\n        sh = [block_indices.shape[0], r, block_size]\n\n    dt = M.dtype\n    M_res = np.empty(sh, dtype=dt)\n    if axis == 0:\n        for ir in range(block_size):\n            M_res[:, ir, :] = M[(block_indices*block_size+ir), :]\n    else:  # 1\n        for ic in range(block_size):\n            M_res[:, :, ic] = M[:, (block_indices*block_size+ic)]\n\n    return M_res"
}