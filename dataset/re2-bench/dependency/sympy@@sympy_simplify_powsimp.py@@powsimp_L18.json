{
    "sympy.sympy.calculus.accumulationbounds.__new__": "def __new__(cls, min, max) -> Expr: # type: ignore\n\n    min = _sympify(min)\n    max = _sympify(max)\n\n    # Only allow real intervals (use symbols with 'is_extended_real=True').\n    if not min.is_extended_real or not max.is_extended_real:\n        raise ValueError(\"Only real AccumulationBounds are supported\")\n\n    if max == min:\n        return max\n\n    # Make sure that the created AccumBounds object will be valid.\n    if max.is_number and min.is_number:\n        bad = max.is_comparable and min.is_comparable and max < min\n    else:\n        bad = (max - min).is_extended_negative\n    if bad:\n        raise ValueError(\n            \"Lower limit should be smaller than upper limit\")\n\n    return Basic.__new__(cls, min, max)",
    "sympy.sympy.concrete.products.__new__": "def __new__(cls, function, *symbols, **assumptions):\n    obj = ExprWithIntLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_base_exp": "def as_base_exp(self) -> tuple[Expr, Expr]:\n    # a -> b ** e\n    return self, S.One",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.exprtools.factor_terms": "def factor_terms(expr: Expr | complex, radical=False, clear=False, fraction=False, sign=True) -> Expr:\n    \"\"\"Remove common factors from terms in all arguments without\n    changing the underlying structure of the expr. No expansion or\n    simplification (and no processing of non-commutatives) is performed.\n\n    Parameters\n    ==========\n\n    radical: bool, optional\n        If radical=True then a radical common to all terms will be factored\n        out of any Add sub-expressions of the expr.\n\n    clear : bool, optional\n        If clear=False (default) then coefficients will not be separated\n        from a single Add if they can be distributed to leave one or more\n        terms with integer coefficients.\n\n    fraction : bool, optional\n        If fraction=True (default is False) then a common denominator will be\n        constructed for the expression.\n\n    sign : bool, optional\n        If sign=True (default) then even if the only factor in common is a -1,\n        it will be factored out of the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_terms, Symbol\n    >>> from sympy.abc import x, y\n    >>> factor_terms(x + x*(2 + 4*y)**3)\n    x*(8*(2*y + 1)**3 + 1)\n    >>> A = Symbol('A', commutative=False)\n    >>> factor_terms(x*A + x*A + x*y*A)\n    x*(y*A + 2*A)\n\n    When ``clear`` is False, a rational will only be factored out of an\n    Add expression if all terms of the Add have coefficients that are\n    fractions:\n\n    >>> factor_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> factor_terms(x/2 + 1, clear=True)\n    (x + 2)/2\n\n    If a -1 is all that can be factored out, to *not* factor it out, the\n    flag ``sign`` must be False:\n\n    >>> factor_terms(-x - y)\n    -(x + y)\n    >>> factor_terms(-x - y, sign=False)\n    -x - y\n    >>> factor_terms(-2*x - 2*y, sign=False)\n    -2*(x + y)\n\n    See Also\n    ========\n\n    gcd_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.integrals.integrals import Integral\n        is_iterable = iterable(expr)\n\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n\n        if expr.is_Pow or expr.is_Function or \\\n                is_iterable or not hasattr(expr, 'args_cnc'):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n\n        if isinstance(expr, (Sum, Integral)):\n            return _factor_sum_int(expr,\n                radical=radical, clear=clear,\n                fraction=fraction, sign=sign)\n\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            # get a common negative (if there) which gcd_terms does not remove\n            if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None\n                       for a in list_args):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            # rebuild p not worrying about the order which gcd_terms will fix\n            p = Add._from_args(list_args)\n            p = gcd_terms(p,\n                isprimitive=True,\n                clear=clear,\n                fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(\n                *[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr2 = sympify(expr)\n    return do(expr2)",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.function.expand_mul": "def expand_mul(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False,\n    power_base=False, basic=False, multinomial=False, log=False)",
    "sympy.sympy.core.function.count_ops": "def count_ops(expr, visual=False):\n    \"\"\"\n    Return a representation (integer or expression) of the operations in expr.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        If expr is an iterable, the sum of the op counts of the\n        items will be returned.\n\n    visual : bool, optional\n        If ``False`` (default) then the sum of the coefficients of the\n        visual expression will be returned.\n        If ``True`` then the number of each type of operation is shown\n        with the core class types (or their virtual equivalent) multiplied by the\n        number of times they occur.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import a, b, x, y\n    >>> from sympy import sin, count_ops\n\n    Although there is not a SUB object, minus signs are interpreted as\n    either negations or subtractions:\n\n    >>> (x - y).count_ops(visual=True)\n    SUB\n    >>> (-x).count_ops(visual=True)\n    NEG\n\n    Here, there are two Adds and a Pow:\n\n    >>> (1 + a + b**2).count_ops(visual=True)\n    2*ADD + POW\n\n    In the following, an Add, Mul, Pow and two functions:\n\n    >>> (sin(x)*x + sin(x)**2).count_ops(visual=True)\n    ADD + MUL + POW + 2*SIN\n\n    for a total of 5:\n\n    >>> (sin(x)*x + sin(x)**2).count_ops(visual=False)\n    5\n\n    Note that \"what you type\" is not always what you get. The expression\n    1/x/y is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather\n    than two DIVs:\n\n    >>> (1/x/y).count_ops(visual=True)\n    DIV + MUL\n\n    The visual option can be used to demonstrate the difference in\n    operations for expressions in different forms. Here, the Horner\n    representation is compared with the expanded form of a polynomial:\n\n    >>> eq=x*(1 + x*(2 + x*(3 + x)))\n    >>> count_ops(eq.expand(), visual=True) - count_ops(eq, visual=True)\n    -MUL + 3*POW\n\n    The count_ops function also handles iterables:\n\n    >>> count_ops([x, sin(x), None, True, x + 2], visual=False)\n    2\n    >>> count_ops([x, sin(x), None, True, x + 2], visual=True)\n    ADD + SIN\n    >>> count_ops({x: sin(x), x + 2: y + 1}, visual=True)\n    2*ADD + SIN\n\n    \"\"\"\n    from .relational import Relational\n    from sympy.concrete.summations import Sum\n    from sympy.integrals.integrals import Integral\n    from sympy.logic.boolalg import BooleanFunction\n    from sympy.simplify.radsimp import fraction\n\n    expr = sympify(expr)\n    if isinstance(expr, Expr) and not expr.is_Relational:\n\n        ops = []\n        args = [expr]\n        NEG = Symbol('NEG')\n        DIV = Symbol('DIV')\n        SUB = Symbol('SUB')\n        ADD = Symbol('ADD')\n        EXP = Symbol('EXP')\n        while args:\n            a = args.pop()\n\n            # if the following fails because the object is\n            # not Basic type, then the object should be fixed\n            # since it is the intention that all args of Basic\n            # should themselves be Basic\n            if a.is_Rational:\n                #-1/3 = NEG + DIV\n                if a is not S.One:\n                    if a.p < 0:\n                        ops.append(NEG)\n                    if a.q != 1:\n                        ops.append(DIV)\n                    continue\n            elif a.is_Mul or a.is_MatMul:\n                if _coeff_isneg(a):\n                    ops.append(NEG)\n                    if a.args[0] is S.NegativeOne:\n                        a = a.as_two_terms()[1]\n                    else:\n                        a = -a\n                n, d = fraction(a)\n                if n.is_Integer:\n                    ops.append(DIV)\n                    if n < 0:\n                        ops.append(NEG)\n                    args.append(d)\n                    continue  # won't be -Mul but could be Add\n                elif d is not S.One:\n                    if not d.is_Integer:\n                        args.append(d)\n                    ops.append(DIV)\n                    args.append(n)\n                    continue  # could be -Mul\n            elif a.is_Add or a.is_MatAdd:\n                aargs = list(a.args)\n                negs = 0\n                for i, ai in enumerate(aargs):\n                    if _coeff_isneg(ai):\n                        negs += 1\n                        args.append(-ai)\n                        if i > 0:\n                            ops.append(SUB)\n                    else:\n                        args.append(ai)\n                        if i > 0:\n                            ops.append(ADD)\n                if negs == len(aargs):  # -x - y = NEG + SUB\n                    ops.append(NEG)\n                elif _coeff_isneg(aargs[0]):  # -x + y = SUB, but already recorded ADD\n                    ops.append(SUB - ADD)\n                continue\n            if a.is_Pow and a.exp is S.NegativeOne:\n                ops.append(DIV)\n                args.append(a.base)  # won't be -Mul but could be Add\n                continue\n            if a == S.Exp1:\n                ops.append(EXP)\n                continue\n            if a.is_Pow and a.base == S.Exp1:\n                ops.append(EXP)\n                args.append(a.exp)\n                continue\n            if a.is_Mul or isinstance(a, LatticeOp):\n                o = Symbol(a.func.__name__.upper())\n                # count the args\n                ops.append(o*(len(a.args) - 1))\n            elif a.args and (\n                    a.is_Pow or a.is_Function or isinstance(a, (Derivative, Integral, Sum))):\n                # if it's not in the list above we don't\n                # consider a.func something to count, e.g.\n                # Tuple, MatrixSymbol, etc...\n                if isinstance(a.func, UndefinedFunction):\n                    o = Symbol(\"FUNC_\" + a.func.__name__.upper())\n                else:\n                    o = Symbol(a.func.__name__.upper())\n                ops.append(o)\n\n            if not a.is_Symbol:\n                args.extend(a.args)\n\n    elif isinstance(expr, Dict):\n        ops = [count_ops(k, visual=visual) +\n               count_ops(v, visual=visual) for k, v in expr.items()]\n    elif iterable(expr):\n        ops = [count_ops(i, visual=visual) for i in expr]\n    elif isinstance(expr, (Relational, BooleanFunction)):\n        ops = []\n        for arg in expr.args:\n            ops.append(count_ops(arg, visual=True))\n        o = Symbol(func_name(expr, short=True).upper())\n        ops.append(o)\n    elif not isinstance(expr, Basic):\n        ops = []\n    else:  # it's Basic not isinstance(expr, Expr):\n        if not isinstance(expr, Basic):\n            raise TypeError(\"Invalid type of expr\")\n        else:\n            ops = []\n            args = [expr]\n            while args:\n                a = args.pop()\n\n                if a.args:\n                    o = Symbol(type(a).__name__.upper())\n                    if a.is_Boolean:\n                        ops.append(o*(len(a.args)-1))\n                    else:\n                        ops.append(o)\n                    args.extend(a.args)\n\n    if not ops:\n        if visual:\n            return S.Zero\n        return 0\n\n    ops = Add(*ops)\n\n    if visual:\n        return ops\n\n    if ops.is_Number:\n        return int(ops)\n\n    return sum(int((a.args or [1])[0]) for a in Add.make_args(ops))",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.function._coeff_isneg": "def _coeff_isneg(a):\n    \"\"\"Return True if the leading Number is negative.\n\n    Examples\n    ========\n\n    >>> from sympy.core.function import _coeff_isneg\n    >>> from sympy import S, Symbol, oo, pi\n    >>> _coeff_isneg(-3*pi)\n    True\n    >>> _coeff_isneg(S(3))\n    False\n    >>> _coeff_isneg(-oo)\n    True\n    >>> _coeff_isneg(Symbol('n', negative=True)) # coeff is 1\n    False\n\n    For matrix expressions:\n\n    >>> from sympy import MatrixSymbol, sqrt\n    >>> A = MatrixSymbol(\"A\", 3, 3)\n    >>> _coeff_isneg(-sqrt(2)*A)\n    True\n    >>> _coeff_isneg(sqrt(2)*A)\n    False\n    \"\"\"\n\n    if a.is_MatMul:\n        a = a.args[0]\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_extended_negative",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.mul.as_base_exp": "def as_base_exp(self):\n    e1 = None\n    bases = []\n    nc = 0\n    for m in self.args:\n        b, e = m.as_base_exp()\n        if not b.is_commutative:\n            nc += 1\n        if e1 is None:\n            e1 = e\n        elif e != e1 or nc > 1 or not e.is_Integer:\n            return self, S.One\n        bases.append(b)\n    return self.func(*bases), e1",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.numbers.__abs__": "@staticmethod\ndef __abs__():\n    return S.Half",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.as_numer_denom": "def as_numer_denom(self):\n    return self, S.One",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p + self.p*other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.as_base_exp": "def as_base_exp(self):\n    return S.NegativeOne, S.Half",
    "sympy.sympy.core.numbers.equal_valued": "def equal_valued(x, y):\n    \"\"\"Compare expressions treating plain floats as rationals.\n\n    Examples\n    ========\n\n    >>> from sympy import S, symbols, Rational, Float\n    >>> from sympy.core.numbers import equal_valued\n    >>> equal_valued(1, 2)\n    False\n    >>> equal_valued(1, 1)\n    True\n\n    In SymPy expressions with Floats compare unequal to corresponding\n    expressions with rationals:\n\n    >>> x = symbols('x')\n    >>> x**2 == x**2.0\n    False\n\n    However an individual Float compares equal to a Rational:\n\n    >>> Rational(1, 2) == Float(0.5)\n    False\n\n    In a future version of SymPy this might change so that Rational and Float\n    compare unequal. This function provides the behavior currently expected of\n    ``==`` so that it could still be used if the behavior of ``==`` were to\n    change in future.\n\n    >>> equal_valued(1, 1.0) # Float vs Rational\n    True\n    >>> equal_valued(S(1).n(3), S(1).n(5)) # Floats of different precision\n    True\n\n    Explanation\n    ===========\n\n    In future SymPy versions Float and Rational might compare unequal and floats\n    with different precisions might compare unequal. In that context a function\n    is needed that can check if a number is equal to 1 or 0 etc. The idea is\n    that instead of testing ``if x == 1:`` if we want to accept floats like\n    ``1.0`` as well then the test can be written as ``if equal_valued(x, 1):``\n    or ``if equal_valued(x, 2):``. Since this function is intended to be used\n    in situations where one or both operands are expected to be concrete\n    numbers like 1 or 0 the function does not recurse through the args of any\n    compound expression to compare any nested floats.\n\n    References\n    ==========\n\n    .. [1] https://github.com/sympy/sympy/pull/20033\n    \"\"\"\n    x = _sympify(x)\n    y = _sympify(y)\n\n    # Handle everything except Float/Rational first\n    if not x.is_Float and not y.is_Float:\n        return x == y\n    elif x.is_Float and y.is_Float:\n        # Compare values without regard for precision\n        return x._mpf_ == y._mpf_\n    elif x.is_Float:\n        x, y = y, x\n    if not x.is_Rational:\n        return False\n\n    # Now y is Float and x is Rational. A simple approach at this point would\n    # just be x == Rational(y) but if y has a large exponent creating a\n    # Rational could be prohibitively expensive.\n\n    sign, man, exp, _ = y._mpf_\n    p, q = x.p, x.q\n\n    if sign:\n        man = -man\n\n    if exp == 0:\n        # y odd integer\n        return q == 1 and man == p\n    elif exp > 0:\n        # y even integer\n        if q != 1:\n            return False\n        if p.bit_length() != man.bit_length() + exp:\n            return False\n        return man << exp == p\n    else:\n        # y non-integer. Need p == man and q == 2**-exp\n        if p != man:\n            return False\n        neg_exp = -exp\n        if q.bit_length() - 1 != neg_exp:\n            return False\n        return (1 << neg_exp) == q",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e",
    "sympy.sympy.core.sorting.default_sort_key": "def default_sort_key(item, order=None):\n    \"\"\"Return a key that can be used for sorting.\n\n    The key has the structure:\n\n    (class_key, (len(args), args), exponent.sort_key(), coefficient)\n\n    This key is supplied by the sort_key routine of Basic objects when\n    ``item`` is a Basic object or an object (other than a string) that\n    sympifies to a Basic object. Otherwise, this function produces the\n    key.\n\n    The ``order`` argument is passed along to the sort_key routine and is\n    used to determine how the terms *within* an expression are ordered.\n    (See examples below) ``order`` options are: 'lex', 'grlex', 'grevlex',\n    and reversed values of the same (e.g. 'rev-lex'). The default order\n    value is None (which translates to 'lex').\n\n    Examples\n    ========\n\n    >>> from sympy import S, I, default_sort_key, sin, cos, sqrt\n    >>> from sympy.core.function import UndefinedFunction\n    >>> from sympy.abc import x\n\n    The following are equivalent ways of getting the key for an object:\n\n    >>> x.sort_key() == default_sort_key(x)\n    True\n\n    Here are some examples of the key that is produced:\n\n    >>> default_sort_key(UndefinedFunction('f'))\n    ((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),\n        (0, ()), (), 1), 1)\n    >>> default_sort_key('1')\n    ((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)\n    >>> default_sort_key(S.One)\n    ((1, 0, 'Number'), (0, ()), (), 1)\n    >>> default_sort_key(2)\n    ((1, 0, 'Number'), (0, ()), (), 2)\n\n    While sort_key is a method only defined for SymPy objects,\n    default_sort_key will accept anything as an argument so it is\n    more robust as a sorting key. For the following, using key=\n    lambda i: i.sort_key() would fail because 2 does not have a sort_key\n    method; that's why default_sort_key is used. Note, that it also\n    handles sympification of non-string items likes ints:\n\n    >>> a = [2, I, -I]\n    >>> sorted(a, key=default_sort_key)\n    [2, -I, I]\n\n    The returned key can be used anywhere that a key can be specified for\n    a function, e.g. sort, min, max, etc...:\n\n    >>> a.sort(key=default_sort_key); a[0]\n    2\n    >>> min(a, key=default_sort_key)\n    2\n\n    Notes\n    =====\n\n    The key returned is useful for getting items into a canonical order\n    that will be the same across platforms. It is not directly useful for\n    sorting lists of expressions:\n\n    >>> a, b = x, 1/x\n\n    Since ``a`` has only 1 term, its value of sort_key is unaffected by\n    ``order``:\n\n    >>> a.sort_key() == a.sort_key('rev-lex')\n    True\n\n    If ``a`` and ``b`` are combined then the key will differ because there\n    are terms that can be ordered:\n\n    >>> eq = a + b\n    >>> eq.sort_key() == eq.sort_key('rev-lex')\n    False\n    >>> eq.as_ordered_terms()\n    [x, 1/x]\n    >>> eq.as_ordered_terms('rev-lex')\n    [1/x, x]\n\n    But since the keys for each of these terms are independent of ``order``'s\n    value, they do not sort differently when they appear separately in a list:\n\n    >>> sorted(eq.args, key=default_sort_key)\n    [1/x, x]\n    >>> sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))\n    [1/x, x]\n\n    The order of terms obtained when using these keys is the order that would\n    be obtained if those terms were *factors* in a product.\n\n    Although it is useful for quickly putting expressions in canonical order,\n    it does not sort expressions based on their complexity defined by the\n    number of operations, power of variables and others:\n\n    >>> sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)\n    [sin(x)*cos(x), sin(x)]\n    >>> sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)\n    [sqrt(x), x, x**2, x**3]\n\n    See Also\n    ========\n\n    ordered, sympy.core.expr.Expr.as_ordered_factors, sympy.core.expr.Expr.as_ordered_terms\n\n    \"\"\"\n    from .basic import Basic\n    from .singleton import S\n\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            # e.g. tuple, list\n            args = list(item)\n            unordered = False\n\n        args = [default_sort_key(arg, order=order) for arg in args]\n\n        if unordered:\n            # e.g. dict, set\n            args = sorted(args)\n\n        cls_index, args = 10, (len(args), tuple(args))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                # e.g. lambda x: x\n                pass\n            else:\n                if isinstance(item, Basic):\n                    # e.g int -> Integer\n                    return default_sort_key(item)\n                # e.g. UndefinedFunction\n\n        # e.g. str\n        cls_index, args = 0, (1, (str(item),))\n\n    return (cls_index, 0, item.__class__.__name__\n            ), args, S.One.sort_key(), S.One",
    "sympy.sympy.core.sorting.ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    \"\"\"Return an iterator of the seq where keys are used to break ties\n    in a conservative fashion: if, after applying a key, there are no\n    ties then no other keys will be computed.\n\n    Two default keys will be applied if 1) keys are not provided or\n    2) the given keys do not resolve all ties (but only if ``default``\n    is True). The two keys are ``_nodes`` (which places smaller\n    expressions before large) and ``default_sort_key`` which (if the\n    ``sort_key`` for an object is defined properly) should resolve\n    any ties. This strategy is similar to sorting done by\n    ``Basic.compare``, but differs in that ``ordered`` never makes a\n    decision based on an objects name.\n\n    If ``warn`` is True then an error will be raised if there were no\n    keys remaining to break ties. This can be used if it was expected that\n    there should be no ties between items that are not identical.\n\n    Examples\n    ========\n\n    >>> from sympy import ordered, count_ops\n    >>> from sympy.abc import x, y\n\n    The count_ops is not sufficient to break ties in this list and the first\n    two items appear in their original order (i.e. the sorting is stable):\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n    ...    count_ops, default=False, warn=False))\n    ...\n    [y + 2, x + 2, x**2 + y + 3]\n\n    The default_sort_key allows the tie to be broken:\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n    ...\n    [x + 2, y + 2, x**2 + y + 3]\n\n    Here, sequences are sorted by length, then sum:\n\n    >>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n    ...    lambda x: len(x),\n    ...    lambda x: sum(x)]]\n    ...\n    >>> list(ordered(seq, keys, default=False, warn=False))\n    [[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]\n\n    If ``warn`` is True, an error will be raised if there were not\n    enough keys to break ties:\n\n    >>> list(ordered(seq, keys, default=False, warn=True))\n    Traceback (most recent call last):\n    ...\n    ValueError: not enough keys to break ties\n\n\n    Notes\n    =====\n\n    The decorated sort is one of the fastest ways to sort a sequence for\n    which special item comparison is desired: the sequence is decorated,\n    sorted on the basis of the decoration (e.g. making all letters lower\n    case) and then undecorated. If one wants to break ties for items that\n    have the same decorated value, a second key can be used. But if the\n    second key is expensive to compute then it is inefficient to decorate\n    all items with both keys: only those items having identical first key\n    values need to be decorated. This function applies keys successively\n    only when needed to break ties. By yielding an iterator, use of the\n    tie-breaker is delayed as long as possible.\n\n    This function is best used in cases when use of the first key is\n    expected to be a good hashing function; if there are no unique hashes\n    from application of a key, then that key should not have been used. The\n    exception, however, is that even if there are many collisions, if the\n    first group is small and one does not need to process all items in the\n    list then time will not be wasted sorting what one was not interested\n    in. For example, if one were looking for the minimum in a list and\n    there were several criteria used to define the sort order, then this\n    function would be good at returning that quickly if the first group\n    of candidates is small relative to the number of items being processed.\n\n    \"\"\"\n\n    d = defaultdict(list)\n    if keys:\n        if isinstance(keys, (list, tuple)):\n            keys = list(keys)\n            f = keys.pop(0)\n        else:\n            f = keys\n            keys = []\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n\n    for k, value in sorted(d.items()):\n        if len(value) > 1:\n            if keys:\n                value = ordered(value, keys, default, warn)\n            elif default:\n                value = ordered(value, (_nodes, default_sort_key,),\n                               default=False, warn=warn)\n            elif warn:\n                u = list(uniq(value))\n                if len(u) > 1:\n                    raise ValueError(\n                        'not enough keys to break ties: %s' % u)\n        yield from value",
    "sympy.sympy.core.sympify.sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    \"\"\"\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n\n    Explanation\n    ===========\n\n    It will convert Python ints into instances of :class:`~.Integer`, floats\n    into instances of :class:`~.Float`, etc. It is also able to coerce\n    symbolic expressions which inherit from :class:`~.Basic`. This can be\n    useful in cooperation with SAGE.\n\n    .. warning::\n        Note that this function uses ``eval``, and thus shouldn't be used on\n        unsanitized input.\n\n    If the argument is already a type that SymPy understands, it will do\n    nothing but return that value. This can be used at the beginning of a\n    function to ensure you are working with the correct type.\n\n    Examples\n    ========\n\n    >>> from sympy import sympify\n\n    >>> sympify(2).is_integer\n    True\n    >>> sympify(2).is_real\n    True\n\n    >>> sympify(2.0).is_real\n    True\n    >>> sympify(\"2.0\").is_real\n    True\n    >>> sympify(\"2e-45\").is_real\n    True\n\n    If the expression could not be converted, a SympifyError is raised.\n\n    >>> sympify(\"x***2\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: \"could not parse 'x***2'\"\n\n    When attempting to parse non-Python syntax using ``sympify``, it raises a\n    ``SympifyError``:\n\n    >>> sympify(\"2x+1\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: Sympify of expression 'could not parse '2x+1'' failed\n\n    To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"2x+1\", transformations=\"all\")\n    2*x + 1\n\n    For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`\n\n    Locals\n    ------\n\n    The sympification happens with access to everything that is loaded\n    by ``from sympy import *``; anything used in a string that is not\n    defined by that import will be converted to a symbol. In the following,\n    the ``bitcount`` function is treated as a symbol and the ``O`` is\n    interpreted as the :class:`~.Order` object (used with series) and it raises\n    an error when used improperly:\n\n    >>> s = 'bitcount(42)'\n    >>> sympify(s)\n    bitcount(42)\n    >>> sympify(\"O(x)\")\n    O(x)\n    >>> sympify(\"O + 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: unbound method...\n\n    In order to have ``bitcount`` be recognized it can be defined in a\n    namespace dictionary and passed as locals:\n\n    >>> ns = {}\n    >>> exec('bitcount = lambda n: int(n).bit_length()', ns)\n    >>> sympify(s, locals=ns)\n    6\n\n    In order to have the ``O`` interpreted as a Symbol, identify it as such\n    in the namespace dictionary. This can be done in a variety of ways; all\n    three of the following are possibilities:\n\n    >>> from sympy import Symbol\n    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n    >>> exec('from sympy.abc import O', ns)  # method 2\n    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n    >>> sympify(\"O + 1\", locals=ns)\n    O + 1\n\n    If you want *all* single-letter and Greek-letter variables to be symbols\n    then you can use the clashing-symbols dictionaries that have been defined\n    there as private variables: ``_clash1`` (single-letter variables),\n    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n    multi-letter names that are defined in ``abc``).\n\n    >>> from sympy.abc import _clash1\n    >>> set(_clash1)  # if this fails, see issue #23903\n    {'E', 'I', 'N', 'O', 'Q', 'S'}\n    >>> sympify('I & Q', _clash1)\n    I & Q\n\n    Strict\n    ------\n\n    If the option ``strict`` is set to ``True``, only the types for which an\n    explicit conversion has been defined are converted. In the other\n    cases, a SympifyError is raised.\n\n    >>> print(sympify(None))\n    None\n    >>> sympify(None, strict=True)\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: None\n\n    .. deprecated:: 1.6\n\n       ``sympify(obj)`` automatically falls back to ``str(obj)`` when all\n       other conversion methods fail, but this is deprecated. ``strict=True``\n       will disable this deprecated behavior. See\n       :ref:`deprecated-sympify-string-fallback`.\n\n    Evaluation\n    ----------\n\n    If the option ``evaluate`` is set to ``False``, then arithmetic and\n    operators will be converted into their SymPy equivalents and the\n    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n    be denested first. This is done via an AST transformation that replaces\n    operators with their SymPy equivalents, so if an operand redefines any\n    of those operations, the redefined operators will not be used. If\n    argument a is not a string, the mathematical expression is evaluated\n    before being passed to sympify, so adding ``evaluate=False`` will still\n    return the evaluated result of expression.\n\n    >>> sympify('2**2 / 3 + 5')\n    19/3\n    >>> sympify('2**2 / 3 + 5', evaluate=False)\n    2**2/3 + 5\n    >>> sympify('4/2+7', evaluate=True)\n    9\n    >>> sympify('4/2+7', evaluate=False)\n    4/2 + 7\n    >>> sympify(4/2+7, evaluate=False)\n    9.00000000000000\n\n    Extending\n    ---------\n\n    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n    just define a ``_sympy_`` method to your class. You can do that even to\n    classes that you do not own by subclassing or adding the method at runtime.\n\n    >>> from sympy import Matrix\n    >>> class MyList1(object):\n    ...     def __iter__(self):\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    ...     def _sympy_(self): return Matrix(self)\n    >>> sympify(MyList1())\n    Matrix([\n    [1],\n    [2]])\n\n    If you do not have control over the class definition you could also use the\n    ``converter`` global dictionary. The key is the class and the value is a\n    function that takes a single argument and returns the desired SymPy\n    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n\n    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n    ...     def __iter__(self):  #     Use _sympy_!\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    >>> from sympy.core.sympify import converter\n    >>> converter[MyList2] = lambda x: Matrix(x)\n    >>> sympify(MyList2())\n    Matrix([\n    [1],\n    [2]])\n\n    Notes\n    =====\n\n    The keywords ``rational`` and ``convert_xor`` are only used\n    when the input is a string.\n\n    convert_xor\n    -----------\n\n    >>> sympify('x^y',convert_xor=True)\n    x**y\n    >>> sympify('x^y',convert_xor=False)\n    x ^ y\n\n    rational\n    --------\n\n    >>> sympify('0.1',rational=False)\n    0.1\n    >>> sympify('0.1',rational=True)\n    1/10\n\n    Sometimes autosimplification during sympification results in expressions\n    that are very different in structure than what was entered. Until such\n    autosimplification is no longer done, the ``kernS`` function might be of\n    some use. In the example below you can see how an expression reduces to\n    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n\n    >>> from sympy.core.sympify import kernS\n    >>> from sympy.abc import x\n    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n    -1\n    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n    >>> sympify(s)\n    -1\n    >>> kernS(s)\n    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n\n    Parameters\n    ==========\n\n    a :\n        - any object defined in SymPy\n        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n        - booleans, including ``None`` (will leave ``None`` unchanged)\n        - dicts, lists, sets or tuples containing any of the above\n\n    convert_xor : bool, optional\n        If true, treats ``^`` as exponentiation.\n        If False, treats ``^`` as XOR itself.\n        Used only when input is a string.\n\n    locals : any object defined in SymPy, optional\n        In order to have strings be recognized it can be imported\n        into a namespace dictionary and passed as locals.\n\n    strict : bool, optional\n        If the option strict is set to ``True``, only the types for which\n        an explicit conversion has been defined are converted. In the\n        other cases, a SympifyError is raised.\n\n    rational : bool, optional\n        If ``True``, converts floats into :class:`~.Rational`.\n        If ``False``, it lets floats remain as it is.\n        Used only when input is a string.\n\n    evaluate : bool, optional\n        If False, then arithmetic and operators will be converted into\n        their SymPy equivalents. If True the expression will be evaluated\n        and the result will be returned.\n\n    \"\"\"\n    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n    # was used for a long time we allow it to pass. However if strict=True as\n    # is the case in internal calls to _sympify then we only allow\n    # is_sympy=True.\n    #\n    # https://github.com/sympy/sympy/issues/20124\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n\n    cls = getattr(a, \"__class__\", None)\n\n    #Check if there exists a converter for any of the types in the mro\n    for superclass in getmro(cls):\n        #First check for user defined converters\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            #if none exists, check for SymPy defined converters\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    # Support for basic numpy datatypes\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals,\n                convert_xor=convert_xor, strict=strict, rational=rational,\n                evaluate=evaluate)\n\n    _sympy_ = getattr(a, \"_sympy_\", None)\n    if _sympy_ is not None:\n        return a._sympy_()\n\n    if not strict:\n        # Put numpy array conversion _before_ float/int, see\n        # <https://github.com/sympy/sympy/issues/13924>.\n        flat = getattr(a, \"flat\", None)\n        if flat is not None:\n            shape = getattr(a, \"shape\", None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                # Scalar arrays (those with zero dimensions) have sympify\n                # called on the scalar element.\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(),\n                                       locals=locals,\n                                       convert_xor=convert_xor,\n                                       strict=strict,\n                                       rational=rational,\n                                       evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        elif hasattr(a, '__float__'):\n            # float and int can coerce size-one numpy arrays to their lone\n            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n            return sympify(float(a))\n        elif hasattr(a, '__int__'):\n            return sympify(int(a))\n\n    if strict:\n        raise SympifyError(a)\n\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n                rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            # Not all iterables are rebuildable with their type.\n            pass\n\n    if not isinstance(a, str):\n        raise SympifyError('cannot sympify object of type %r' % type(a))\n\n    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n                                            standard_transformations)\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n\n    transformations = standard_transformations\n\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n\n    return expr",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.diffgeom.diffgeom.__new__": "def __new__(cls, coord_sys, index, **kwargs):\n    index = _sympify(index)\n    obj = super().__new__(cls, coord_sys, index)\n    obj._coord_sys = coord_sys\n    obj._index = index\n    return obj",
    "sympy.sympy.functions.elementary.exponential.as_base_exp": "def as_base_exp(self):\n    \"\"\"\n    Returns the 2-tuple (base, exponent).\n    \"\"\"\n    return self.func(1), Mul(*self.args)",
    "sympy.sympy.functions.elementary.exponential.__instancecheck__": "def __instancecheck__(cls, instance):\n    if exp in instance.__class__.__mro__:\n        return True\n    return isinstance(instance, Pow) and instance.base is S.Exp1",
    "sympy.sympy.functions.elementary.exponential.as_numer_denom": "def as_numer_denom(self):\n    \"\"\"\n    Returns this with a positive exponent as a 2-tuple (a fraction).\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.abc import x\n    >>> exp(-x).as_numer_denom()\n    (1, exp(x))\n    >>> exp(x).as_numer_denom()\n    (exp(x), 1)\n    \"\"\"\n    # this should be the same as Pow.as_numer_denom wrt\n    # exponent handling\n    if not self.is_commutative:\n        return self, S.One\n    exp = self.exp\n    neg_exp = exp.is_negative\n    if not neg_exp and not (-exp).is_negative:\n        neg_exp = exp.could_extract_minus_sign()\n    if neg_exp:\n        return S.One, self.func(-exp)\n    return self, S.One",
    "sympy.sympy.functions.elementary.exponential.exp": "@property\ndef exp(self):\n    \"\"\"\n    Returns the exponent of the function.\n    \"\"\"\n    return self.args[0]",
    "sympy.sympy.functions.elementary.miscellaneous.root": "def root(arg, n, k=0, evaluate=None):\n    r\"\"\"Returns the *k*-th *n*-th root of ``arg``.\n\n    Parameters\n    ==========\n\n    k : int, optional\n        Should be an integer in $\\{0, 1, ..., n-1\\}$.\n        Defaults to the principal root if $0$.\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import root, Rational\n    >>> from sympy.abc import x, n\n\n    >>> root(x, 2)\n    sqrt(x)\n\n    >>> root(x, 3)\n    x**(1/3)\n\n    >>> root(x, n)\n    x**(1/n)\n\n    >>> root(x, -Rational(2, 3))\n    x**(-3/2)\n\n    To get the k-th n-th root, specify k:\n\n    >>> root(-2, 3, 2)\n    -(-1)**(2/3)*2**(1/3)\n\n    To get all n n-th roots you can use the rootof function.\n    The following examples show the roots of unity for n\n    equal 2, 3 and 4:\n\n    >>> from sympy import rootof\n\n    >>> [rootof(x**2 - 1, i) for i in range(2)]\n    [-1, 1]\n\n    >>> [rootof(x**3 - 1,i) for i in range(3)]\n    [1, -1/2 - sqrt(3)*I/2, -1/2 + sqrt(3)*I/2]\n\n    >>> [rootof(x**4 - 1,i) for i in range(4)]\n    [-1, 1, -I, I]\n\n    SymPy, like other symbolic algebra systems, returns the\n    complex root of negative numbers. This is the principal\n    root and differs from the text-book result that one might\n    be expecting. For example, the cube root of -8 does not\n    come back as -2:\n\n    >>> root(-8, 3)\n    2*(-1)**(1/3)\n\n    The real_root function can be used to either make the principal\n    result real (or simply to return the real root directly):\n\n    >>> from sympy import real_root\n    >>> real_root(_)\n    -2\n    >>> real_root(-32, 5)\n    -2\n\n    Alternatively, the n//2-th n-th root of a negative number can be\n    computed with root:\n\n    >>> root(-32, 5, 5//2)\n    -2\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof\n    sympy.core.intfunc.integer_nthroot\n    sqrt, real_root\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Square_root\n    .. [2] https://en.wikipedia.org/wiki/Real_root\n    .. [3] https://en.wikipedia.org/wiki/Root_of_unity\n    .. [4] https://en.wikipedia.org/wiki/Principal_value\n    .. [5] https://mathworld.wolfram.com/CubeRoot.html\n\n    \"\"\"\n    n = sympify(n)\n    if k:\n        return Mul(Pow(arg, S.One/n, evaluate=evaluate), S.NegativeOne**(2*k/n), evaluate=evaluate)\n    return Pow(arg, 1/n, evaluate=evaluate)",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.functions.special.hyper.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 5:\n        args = [(args[0], args[1]), (args[2], args[3]), args[4]]\n    if len(args) != 3:\n        raise TypeError(\"args must be either as, as', bs, bs', z or \"\n                        \"as, bs, z\")\n\n    def tr(p):\n        if len(p) != 2:\n            raise TypeError(\"wrong argument\")\n        p = [list(ordered(i)) for i in p]\n        return TupleArg(_prep_tuple(p[0]), _prep_tuple(p[1]))\n\n    arg0, arg1 = tr(args[0]), tr(args[1])\n    if Tuple(arg0, arg1).has(oo, zoo, -oo):\n        raise ValueError(\"G-function parameters must be finite\")\n    if any((a - b).is_Integer and a - b > 0\n           for a in arg0[0] for b in arg1[0]):\n        raise ValueError(\"no parameter a1, ..., an may differ from \"\n                     \"any b1, ..., bm by a positive integer\")\n\n    # TODO should we check convergence conditions?\n    return super().__new__(cls, arg0, arg1, args[2], **kwargs)",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.expressions.matexpr.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        b = _sympify(b)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, name, n, m):\n    n, m = map(_sympify, (n, m))\n    if isinstance(name, str):\n        name = Symbol(name)\n    else:\n        if isinstance(name, MatrixBase):\n            if n.is_Integer and m.is_Integer:\n                return name[n, m]\n            name = _sympify(name)  # change mutable into immutable\n        else:\n            name = _sympify(name)\n            if not isinstance(name.kind, MatrixKind):\n                raise TypeError(\"First argument of MatrixElement should be a matrix\")\n        if not getattr(name, 'valid_index', lambda n, m: True)(n, m):\n            raise IndexError('indices out of range')\n    obj = Expr.__new__(cls, name, n, m)\n    return obj",
    "sympy.sympy.matrices.expressions.matmul.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericIdentity().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatMul is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*matrices)\n\n    if not matrices:\n        # Should it be\n        #\n        # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n        return factor\n\n    if evaluate:\n        return cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, n):\n    n = _sympify(n)\n    cls._check_dim(n)\n\n    return super().__new__(cls, n)",
    "sympy.sympy.ntheory.factor_.multiplicity": "def multiplicity(p, n):\n    \"\"\"\n    Find the greatest integer m such that p**m divides n.\n\n    Examples\n    ========\n\n    >>> from sympy import multiplicity, Rational\n    >>> [multiplicity(5, n) for n in [8, 5, 25, 125, 250]]\n    [0, 1, 2, 3, 3]\n    >>> multiplicity(3, Rational(1, 9))\n    -2\n\n    Note: when checking for the multiplicity of a number in a\n    large factorial it is most efficient to send it as an unevaluated\n    factorial or to call ``multiplicity_in_factorial`` directly:\n\n    >>> from sympy.ntheory import multiplicity_in_factorial\n    >>> from sympy import factorial\n    >>> p = factorial(25)\n    >>> n = 2**100\n    >>> nfac = factorial(n, evaluate=False)\n    >>> multiplicity(p, nfac)\n    52818775009509558395695966887\n    >>> _ == multiplicity_in_factorial(p, n)\n    True\n\n    See Also\n    ========\n\n    trailing\n\n    \"\"\"\n    try:\n        p, n = as_int(p), as_int(n)\n    except ValueError:\n        from sympy.functions.combinatorial.factorials import factorial\n        if all(isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n)):\n            p = Rational(p)\n            n = Rational(n)\n            if p.q == 1:\n                if n.p == 1:\n                    return -multiplicity(p.p, n.q)\n                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)\n            elif p.p == 1:\n                return multiplicity(p.q, n.q)\n            else:\n                like = min(\n                    multiplicity(p.p, n.p),\n                    multiplicity(p.q, n.q))\n                cross = min(\n                    multiplicity(p.q, n.p),\n                    multiplicity(p.p, n.q))\n                return like - cross\n        elif (isinstance(p, (SYMPY_INTS, Integer)) and\n                isinstance(n, factorial) and\n                isinstance(n.args[0], Integer) and\n                n.args[0] >= 0):\n            return multiplicity_in_factorial(p, n.args[0])\n        raise ValueError(f\"expecting ints or fractions, got {p} and {n}\")\n\n    if n == 0:\n        raise ValueError(f\"no such integer exists: multiplicity of {n} is not-defined\")\n    return remove(n, p)[1]",
    "sympy.sympy.physics.quantum.dagger.__new__": "def __new__(cls, arg, evaluate=True):\n    if hasattr(arg, 'adjoint') and evaluate:\n        return arg.adjoint()\n    elif hasattr(arg, 'conjugate') and hasattr(arg, 'transpose') and evaluate:\n        return arg.conjugate().transpose()\n    return Expr.__new__(cls, sympify(arg))",
    "sympy.sympy.physics.quantum.qexpr.__new__": "def __new__(cls, *args, **kwargs):\n    \"\"\"Construct a new quantum object.\n\n    Parameters\n    ==========\n\n    args : tuple\n        The list of numbers or parameters that uniquely specify the\n        quantum object. For a state, this will be its symbol or its\n        set of quantum numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.qexpr import QExpr\n    >>> q = QExpr(0)\n    >>> q\n    0\n    >>> q.label\n    (0,)\n    >>> q.hilbert_space\n    H\n    >>> q.args\n    (0,)\n    >>> q.is_commutative\n    False\n    \"\"\"\n\n    # First compute args and call Expr.__new__ to create the instance\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    # Now set the slots on the instance\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    "sympy.sympy.physics.quantum.spin.__new__": "def __new__(cls, j, m):\n    j = sympify(j)\n    m = sympify(m)\n    if j.is_number:\n        if 2*j != int(2*j):\n            raise ValueError(\n                'j must be integer or half-integer, got: %s' % j)\n        if j < 0:\n            raise ValueError('j must be >= 0, got: %s' % j)\n    if m.is_number:\n        if 2*m != int(2*m):\n            raise ValueError(\n                'm must be integer or half-integer, got: %s' % m)\n    if j.is_number and m.is_number:\n        if abs(m) > j:\n            raise ValueError('Allowed values for m are -j <= m <= j, got j, m: %s, %s' % (j, m))\n        if int(j - m) != j - m:\n            raise ValueError('Both j and m must be integer or half-integer, got j, m: %s, %s' % (j, m))\n    return State.__new__(cls, j, m)",
    "sympy.sympy.physics.quantum.tensorproduct.__new__": "def __new__(cls, *args):\n    if isinstance(args[0], (Matrix, ImmutableMatrix, numpy_ndarray,\n                                                scipy_sparse_matrix)):\n        return matrix_tensor_product(*args)\n    c_part, new_args = cls.flatten(sympify(args))\n    c_part = Mul(*c_part)\n    if len(new_args) == 0:\n        return c_part\n    elif len(new_args) == 1:\n        return c_part * new_args[0]\n    else:\n        tp = Expr.__new__(cls, *new_args)\n        return c_part * tp",
    "sympy.sympy.physics.vector.frame.__eq__": "def __eq__(self, other):\n    # Check if the other object is a CoordinateSym of the same frame and\n    # same index\n    if isinstance(other, CoordinateSym):\n        if other._id == self._id:\n            return True\n    return False",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.polytools.lcm": "@public\ndef lcm(f, g=None, *gens, **args):\n    \"\"\"\n    Compute LCM of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import lcm\n    >>> from sympy.abc import x\n\n    >>> lcm(x**2 - 1, x**2 - 3*x + 2)\n    x**3 - 2*x**2 - x + 2\n\n    \"\"\"\n    if hasattr(f, '__iter__'):\n        if g is not None:\n            gens = (g,) + gens\n\n        return lcm_list(f, *gens, **args)\n    elif g is None:\n        raise TypeError(\"lcm() takes 2 arguments or a sequence of arguments\")\n\n    options.allowed_flags(args, ['polys'])\n\n    try:\n        (F, G), opt = parallel_poly_from_expr((f, g), *gens, **args)\n\n        # lcm for domain Q[irrational] (purely algebraic irrational)\n        a, b = map(sympify, (f, g))\n        if a.is_algebraic and a.is_irrational and b.is_algebraic and b.is_irrational:\n            frc = (a/b).ratsimp()\n            if frc.is_rational:\n                return a*frc.as_numer_denom()[1]\n\n    except PolificationFailed as exc:\n        domain, (a, b) = construct_domain(exc.exprs)\n\n        try:\n            return domain.to_sympy(domain.lcm(a, b))\n        except NotImplementedError:\n            raise ComputationFailed('lcm', 2, exc)\n\n    result = F.lcm(G)\n\n    if not opt.polys:\n        return result.as_expr()\n    else:\n        return result",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.simplify.powsimp.recurse": "def recurse(arg, **kwargs):\n    _deep = kwargs.get('deep', deep)\n    _combine = kwargs.get('combine', combine)\n    _force = kwargs.get('force', force)\n    _measure = kwargs.get('measure', measure)\n    return powsimp(arg, _deep, _combine, _force, _measure)",
    "sympy.sympy.simplify.powsimp.<listcomp>": "c_part = [Pow(b, ei) for b, e in c_powers.items() for ei in e]\n\n# we're done\n",
    "sympy.sympy.simplify.powsimp.<genexpr>": "if not (all(x.is_nonnegative for x in b.as_numer_denom()) or e.is_integer or force or b.is_polar):\n    continue\n",
    "sympy.sympy.simplify.powsimp.bkey": "def bkey(b, e=None):\n    '''Return (b**s, c.q), c.p where e -> c*s. If e is not given then\n    it will be taken by using as_base_exp() on the input b.\n    e.g.\n        x**3/2 -> (x, 2), 3\n        x**y -> (x**y, 1), 1\n        x**(2*y/3) -> (x**y, 3), 2\n        exp(x/2) -> (exp(a), 2), 1\n\n    '''\n    if e is not None:  # coming from c_powers or from below\n        if e.is_Integer:\n            return (b, S.One), e\n        elif e.is_Rational:\n            return (b, Integer(e.q)), Integer(e.p)\n        else:\n            c, m = e.as_coeff_Mul(rational=True)\n            if c is not S.One:\n                if m.is_integer:\n                    return (b, Integer(c.q)), m*Integer(c.p)\n                return (b**m, Integer(c.q)), Integer(c.p)\n            else:\n                return (b**e, S.One), S.One\n    else:\n        return bkey(*b.as_base_exp())",
    "sympy.sympy.simplify.powsimp.update": "def update(b):\n    '''Decide what to do with base, b. If its exponent is now an\n    integer multiple of the Rational denominator, then remove it\n    and put the factors of its base in the common_b dictionary or\n    update the existing bases if necessary. If it has been zeroed\n    out, simply remove the base.\n    '''\n    newe, r = divmod(common_b[b], b[1])\n    if not r:\n        common_b.pop(b)\n        if newe:\n            for m in Mul.make_args(b[0]**newe):\n                b, e = bkey(m)\n                if b not in common_b:\n                    common_b[b] = 0\n                common_b[b] += e\n                if b[1] != 1:\n                    bases.append(b)",
    "sympy.sympy.simplify.powsimp._terms": "def _terms(e):\n    # return the number of terms of this expression\n    # when multiplied out -- assuming no joining of terms\n    if e.is_Add:\n        return sum(_terms(ai) for ai in e.args)\n    if e.is_Mul:\n        return prod([_terms(mi) for mi in e.args])\n    return 1",
    "sympy.sympy.simplify.powsimp._denest_pow": "def _denest_pow(eq):\n    \"\"\"\n    Denest powers.\n\n    This is a helper function for powdenest that performs the actual\n    transformation.\n    \"\"\"\n    from sympy.simplify.simplify import logcombine\n\n    b, e = eq.as_base_exp()\n    if b.is_Pow or isinstance(b, exp) and e != 1:\n        new = b._eval_power(e)\n        if new is not None:\n            eq = new\n            b, e = new.as_base_exp()\n\n    # denest exp with log terms in exponent\n    if b is S.Exp1 and e.is_Mul:\n        logs = []\n        other = []\n        for ei in e.args:\n            if any(isinstance(ai, log) for ai in Add.make_args(ei)):\n                logs.append(ei)\n            else:\n                other.append(ei)\n        logs = logcombine(Mul(*logs))\n        return Pow(exp(logs), Mul(*other))\n\n    _, be = b.as_base_exp()\n    if be is S.One and not (b.is_Mul or\n                            b.is_Rational and b.q != 1 or\n                            b.is_positive):\n        return eq\n\n    # denest eq which is either pos**e or Pow**e or Mul**e or\n    # Mul(b1**e1, b2**e2)\n\n    # handle polar numbers specially\n    polars, nonpolars = [], []\n    for bb in Mul.make_args(b):\n        if bb.is_polar:\n            polars.append(bb.as_base_exp())\n        else:\n            nonpolars.append(bb)\n    if len(polars) == 1 and not polars[0][0].is_Mul:\n        return Pow(polars[0][0], polars[0][1]*e)*powdenest(Mul(*nonpolars)**e)\n    elif polars:\n        return Mul(*[powdenest(bb**(ee*e)) for (bb, ee) in polars]) \\\n            *powdenest(Mul(*nonpolars)**e)\n\n    if b.is_Integer:\n        # use log to see if there is a power here\n        logb = expand_log(log(b))\n        if logb.is_Mul:\n            c, logb = logb.args\n            e *= c\n            base = logb.args[0]\n            return Pow(base, e)\n\n    # if b is not a Mul or any factor is an atom then there is nothing to do\n    if not b.is_Mul or any(s.is_Atom for s in Mul.make_args(b)):\n        return eq\n\n    # let log handle the case of the base of the argument being a Mul, e.g.\n    # sqrt(x**(2*i)*y**(6*i)) -> x**i*y**(3**i) if x and y are positive; we\n    # will take the log, expand it, and then factor out the common powers that\n    # now appear as coefficient. We do this manually since terms_gcd pulls out\n    # fractions, terms_gcd(x+x*y/2) -> x*(y + 2)/2 and we don't want the 1/2;\n    # gcd won't pull out numerators from a fraction: gcd(3*x, 9*x/2) -> x but\n    # we want 3*x. Neither work with noncommutatives.\n\n    def nc_gcd(aa, bb):\n        a, b = [i.as_coeff_Mul() for i in [aa, bb]]\n        c = gcd(a[0], b[0]).as_numer_denom()[0]\n        g = Mul(*(a[1].args_cnc(cset=True)[0] & b[1].args_cnc(cset=True)[0]))\n        return _keep_coeff(c, g)\n\n    glogb = expand_log(log(b))\n    if glogb.is_Add:\n        args = glogb.args\n        g = reduce(nc_gcd, args)\n        if g != 1:\n            cg, rg = g.as_coeff_Mul()\n            glogb = _keep_coeff(cg, rg*Add(*[a/g for a in args]))\n\n    # now put the log back together again\n    if isinstance(glogb, log) or not glogb.is_Mul:\n        if glogb.args[0].is_Pow or isinstance(glogb.args[0], exp):\n            glogb = _denest_pow(glogb.args[0])\n            if (abs(glogb.exp) < 1) == True:\n                return Pow(glogb.base, glogb.exp*e)\n        return eq\n\n    # the log(b) was a Mul so join any adds with logcombine\n    add = []\n    other = []\n    for a in glogb.args:\n        if a.is_Add:\n            add.append(a)\n        else:\n            other.append(a)\n    return Pow(exp(logcombine(Mul(*add))), e*Mul(*other))",
    "sympy.sympy.stats.rv.is_commutative": "@property\ndef is_commutative(self):\n    return self.symbol.is_commutative",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, arg, condition=None, **kwargs):\n    arg = _sympify(arg)\n\n    if arg.is_Matrix:\n        from sympy.stats.symbolic_multivariate_probability import VarianceMatrix\n        return VarianceMatrix(arg, condition)\n    if condition is None:\n        obj = Expr.__new__(cls, arg)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, arg, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}