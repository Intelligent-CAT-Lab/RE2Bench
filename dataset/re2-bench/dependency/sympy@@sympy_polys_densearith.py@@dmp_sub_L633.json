{
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.polys.densearith.dmp_neg": "def dmp_neg(f: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_neg(x**2*y - x)\n    -x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_neg(_dup(f), K))\n\n    v = u - 1\n\n    return [ dmp_neg(cf, v, K) for cf in f ]",
    "sympy.sympy.polys.densearith.dup_sub": "def dup_sub(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Subtract dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sub(x**2 - 1, x - 2)\n    x**2 - x + 1\n\n    \"\"\"\n    if not f:\n        return dup_neg(g, K)\n    if not g:\n        return f\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    if df == dg:\n        return dup_strip([ a - b for a, b in zip(f, g) ], K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = dup_neg(g[:k], K), g[k:]\n\n        return h + [ a - b for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densearith.<listcomp>": "return h + [ dmp_sub(a, b, v, K) for a, b in zip(f, g) ]\n\n\n",
    "sympy.sympy.polys.densebasic.dmp_degree": "def dmp_degree(f: dmp[Er], u: int) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``x_0`` in ``K[X]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree\n\n    >>> dmp_degree([[[]]], 2)\n    -1\n\n    >>> f = ZZ.map([[2], [1, 2, 3]])\n\n    >>> dmp_degree(f, 1)\n    1\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    if dmp_zero_p(f, u):\n        return -1\n    else:\n        return len(f) - 1",
    "sympy.sympy.polys.densebasic.dmp_strip": "def dmp_strip(f: dmp[Er], u: int, K: Domain[Er] | None = None) -> dmp[Er]:\n    \"\"\"\n    Remove leading zeros from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_strip\n\n    >>> dmp_strip([[], [0, 1, 2], [1]], 1)\n    [[0, 1, 2], [1]]\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_strip(_dup(f), K))\n\n    if dmp_zero_p(f, u):\n        return f\n\n    i, v = 0, u - 1\n\n    for c in f:\n        if not dmp_zero_p(c, v):\n            break\n        else:\n            i += 1\n\n    if i == len(f):\n        return dmp_zero(u, K)\n    else:\n        return f[i:]",
    "sympy.sympy.polys.densebasic._dup": "def _dup(p, /):\n    return p",
    "sympy.sympy.polys.densebasic._dmp": "def _dmp(p, /):\n    return p",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}