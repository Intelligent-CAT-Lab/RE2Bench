{
    "sympy.sympy.core.add.primitive": "def primitive(self):\n    \"\"\"\n    Return ``(R, self/R)`` where ``R``` is the Rational GCD of ``self```.\n\n    ``R`` is collected only from the leading coefficient of each term.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n\n    >>> (2*x + 4*y).primitive()\n    (2, x + 2*y)\n\n    >>> (2*x/3 + 4*y/9).primitive()\n    (2/9, 3*x + 2*y)\n\n    >>> (2*x/3 + 4.2*y).primitive()\n    (1/3, 2*x + 12.6*y)\n\n    No subprocessing of term factors is performed:\n\n    >>> ((2 + 2*x)*x + 2).primitive()\n    (1, x*(2*x + 2) + 2)\n\n    Recursive processing can be done with the ``as_content_primitive()``\n    method:\n\n    >>> ((2 + 2*x)*x + 2).as_content_primitive()\n    (2, x*(x + 1) + 1)\n\n    See also: primitive() function in polytools.py\n\n    \"\"\"\n\n    terms = []\n    inf = False\n    for a in self.args:\n        c, m = a.as_coeff_Mul()\n        if not c.is_Rational:\n            c = S.One\n            m = a\n        inf = inf or m is S.ComplexInfinity\n        terms.append((c.p, c.q, m))\n\n    if not inf:\n        ngcd = reduce(igcd, [t[0] for t in terms], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms], 1)\n    else:\n        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n\n    if ngcd == dlcm == 1:\n        return S.One, self\n    if not inf:\n        for i, (p, q, term) in enumerate(terms):\n            terms[i] = _keep_coeff(Rational((p//ngcd)*(dlcm//q)), term)\n    else:\n        for i, (p, q, term) in enumerate(terms):\n            if q:\n                terms[i] = _keep_coeff(Rational((p//ngcd)*(dlcm//q)), term)\n            else:\n                terms[i] = _keep_coeff(Rational(p, q), term)\n\n    # we don't need a complete re-flattening since no new terms will join\n    # so we just use the same sort as is used in Add.flatten. When the\n    # coefficient changes, the ordering of terms may change, e.g.\n    #     (3*x, 6*y) -> (2*y, x)\n    #\n    # We do need to make sure that term[0] stays in position 0, however.\n    #\n    if terms[0].is_Number or terms[0] is S.ComplexInfinity:\n        c = terms.pop(0)\n    else:\n        c = None\n    _addsort(terms)\n    if c:\n        terms.insert(0, c)\n    return Rational(ngcd, dlcm), self._new_rawargs(*terms)",
    "sympy.sympy.core.add.<listcomp>": "args = [ai/G for ai in args]\n",
    "sympy.sympy.core.add.<genexpr>": "if any(a.as_coeff_Mul()[0].is_Integer for a in _p.args):\n    prim = _p\n",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.primitive": "def primitive(self) -> tuple[Number, Expr]:\n    \"\"\"Return the positive Rational that can be extracted non-recursively\n    from every term of self (i.e., self is treated like an Add). This is\n    like the as_coeff_Mul() method but primitive always extracts a positive\n    Rational (never a negative or a Float).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> (3*(x + 1)**2).primitive()\n    (3, (x + 1)**2)\n    >>> a = (6*x + 2); a.primitive()\n    (2, 3*x + 1)\n    >>> b = (x/2 + 3); b.primitive()\n    (1/2, x + 6)\n    >>> (a*b).primitive() == (1, a*b)\n    True\n    \"\"\"\n    if not self:\n        return S.One, S.Zero\n    c, r = self.as_coeff_Mul(rational=True)\n    if c.is_negative:\n        c, r = -c, -r\n    return c, r",
    "sympy.sympy.core.intfunc.igcd": "@lru_cache(1024)\ndef igcd(*args):\n    \"\"\"Computes nonnegative integer greatest common divisor.\n\n    Explanation\n    ===========\n\n    The algorithm is based on the well known Euclid's algorithm [1]_. To\n    improve speed, ``igcd()`` has its own caching mechanism.\n    If you do not need the cache mechanism, using ``sympy.external.gmpy.gcd``.\n\n    Examples\n    ========\n\n    >>> from sympy import igcd\n    >>> igcd(2, 4)\n    2\n    >>> igcd(5, 10, 15)\n    5\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euclidean_algorithm\n\n    \"\"\"\n    if len(args) < 2:\n        raise TypeError(\"igcd() takes at least 2 arguments (%s given)\" % len(args))\n    return int(number_gcd(*map(as_int, args)))",
    "sympy.sympy.core.numbers.as_numer_denom": "def as_numer_denom(self):\n    return Integer(self.p), Integer(self.q)",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e"
}