{
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.extract_multiplicatively": "def extract_multiplicatively(self, c: Expr | complex) -> Expr | None:\n    \"\"\"Return None if it's not possible to make self in the form\n       c * something in a nice way, i.e. preserving the properties\n       of arguments of self.\n\n       Examples\n       ========\n\n       >>> from sympy import symbols, Rational\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n       x*y**2\n\n       >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n\n       >>> (2*x).extract_multiplicatively(2)\n       x\n\n       >>> (2*x).extract_multiplicatively(3)\n\n       >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n       x/6\n\n    \"\"\"\n    from sympy.functions.elementary.exponential import exp\n    from .add import _unevaluated_Add\n    c = sympify(c)\n    if self is S.NaN:\n        return None\n    if c is S.One:\n        return self\n    elif c == self:\n        return S.One\n\n    if c.is_Add:\n        cc, pc = c.primitive()\n        if cc is not S.One:\n            c = Mul(cc, pc, evaluate=False)\n\n    if c.is_Mul:\n        a, b = c.as_two_terms() # type: ignore\n        x = self.extract_multiplicatively(a)\n        if x is not None:\n            return x.extract_multiplicatively(b)\n        else:\n            return x\n\n    quotient = self / c\n    if self.is_Number:\n        if self is S.Infinity:\n            if c.is_positive:\n                return S.Infinity\n        elif self is S.NegativeInfinity:\n            if c.is_negative:\n                return S.Infinity\n            elif c.is_positive:\n                return S.NegativeInfinity\n        elif self is S.ComplexInfinity:\n            if not c.is_zero:\n                return S.ComplexInfinity\n        elif self.is_Integer:\n            if not quotient.is_Integer:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Rational:\n            if not quotient.is_Rational:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Float:\n            if not quotient.is_Float:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n        if quotient.is_Mul and len(quotient.args) == 2:\n            if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n                return quotient\n        elif quotient.is_Integer and c.is_Number:\n            return quotient\n    elif self.is_Add:\n        cs, ps = self.primitive()\n        # assert cs >= 1\n        if c.is_Number and c is not S.NegativeOne:\n            # assert c != 1 (handled at top)\n            if cs is not S.One:\n                if c.is_negative:\n                    xc = cs.extract_multiplicatively(-c)\n                    if xc is not None:\n                        xc = -xc\n                else:\n                    xc = cs.extract_multiplicatively(c)\n                if xc is not None:\n                    return xc*ps  # rely on 2-arg Mul to restore Add\n            return None # |c| != 1 can only be extracted from cs\n        if c == ps:\n            return cs\n        # check args of ps\n        newargs = []\n        arg: Expr\n        for arg in ps.args: # type: ignore\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is None:\n                return None # all or nothing\n            newargs.append(newarg)\n        if cs is not S.One:\n            args = [cs*t for t in newargs]\n            # args may be in different order\n            return _unevaluated_Add(*args)\n        else:\n            return Add._from_args(newargs)\n    elif self.is_Mul:\n        args: list[Expr] = list(self.args) # type: ignore\n        for i, arg in enumerate(args):\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is not None:\n                args[i] = newarg\n                return Mul(*args)\n    elif self.is_Pow or isinstance(self, exp):\n        sb, se = self.as_base_exp()\n        cb, ce = c.as_base_exp()\n        if cb == sb:\n            new_exp = se.extract_additively(ce)\n            if new_exp is not None:\n                return Pow(sb, new_exp)\n        elif c == sb:\n            new_exp = se.extract_additively(1)\n            if new_exp is not None:\n                return Pow(sb, new_exp)\n\n    return None",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False"
}