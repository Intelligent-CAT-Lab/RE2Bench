{
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__int__": "def __int__(self) -> int:\n    if not self.is_number:\n        raise TypeError(\"Cannot convert symbols to int\")\n    if not self.is_comparable:\n        raise TypeError(\"Cannot convert non-comparable expression to int\")\n    r = self.round(2)\n    if not r.is_Number:\n        raise TypeError(\"Cannot convert complex to int\")\n    if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n        raise TypeError(\"Cannot convert %s to int\" % r)\n    i = int(r)\n    if not i:\n        return i\n    if int_valued(r):\n        r = self.round(15)\n        i = int(r)\n    if int_valued(r):\n        # non-integer self should pass one of these tests\n        if (self > i) is S.true:\n            return i\n        if (self < i) is S.true:\n            return i - 1\n        ok = self.equals(i)\n        if ok is None:\n            raise TypeError('cannot compute int value accurately')\n        if ok:\n            return i\n        # off by one\n        return i - (1 if i > 0 else -1)\n    return i",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return 3",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    "sympy.sympy.core.numbers.__rmod__": "def __rmod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other % self.p)\n        elif isinstance(other, Integer):\n            return Integer(other.p % self.p)\n        return Rational.__rmod__(self, other)\n    return Rational.__rmod__(self, other)",
    "sympy.sympy.core.power._eval_Mod": "def _eval_Mod(self, q):\n    r\"\"\"A dispatched function to compute `b^e \\bmod q`, dispatched\n    by ``Mod``.\n\n    Notes\n    =====\n\n    Algorithms:\n\n    1. For unevaluated integer power, use built-in ``pow`` function\n    with 3 arguments, if powers are not too large wrt base.\n\n    2. For very large powers, use totient reduction if $e \\ge \\log(m)$.\n    Bound on m, is for safe factorization memory wise i.e. $m^{1/4}$.\n    For pollard-rho to be faster than built-in pow $\\log(e) > m^{1/4}$\n    check is added.\n\n    3. For any unevaluated power found in `b` or `e`, the step 2\n    will be recursed down to the base and the exponent\n    such that the $b \\bmod q$ becomes the new base and\n    $\\phi(q) + e \\bmod \\phi(q)$ becomes the new exponent, and then\n    the computation for the reduced expression can be done.\n    \"\"\"\n\n    base, exp = self.base, self.exp\n\n    if exp.is_integer and exp.is_positive:\n        if q.is_integer and base % q == 0:\n            return S.Zero\n\n        from sympy.functions.combinatorial.numbers import totient\n\n        if base.is_Integer and exp.is_Integer and q.is_Integer:\n            b, e, m = int(base), int(exp), int(q)\n            mb = m.bit_length()\n            if mb <= 80 and e >= mb and e.bit_length()**4 >= m:\n                phi = int(totient(m))\n                return Integer(pow(b, phi + e%phi, m))\n            return Integer(pow(b, e, m))\n\n        from .mod import Mod\n\n        if isinstance(base, Pow) and base.is_integer and base.is_number:\n            base = Mod(base, q)\n            return Mod(Pow(base, exp, evaluate=False), q)\n\n        if isinstance(exp, Pow) and exp.is_integer and exp.is_number:\n            bit_length = int(q).bit_length()\n            # XXX Mod-Pow actually attempts to do a hanging evaluation\n            # if this dispatched function returns None.\n            # May need some fixes in the dispatcher itself.\n            if bit_length <= 80:\n                phi = totient(q)\n                exp = phi + Mod(exp, phi)\n                return Mod(Pow(base, exp, evaluate=False), q)",
    "sympy.sympy.core.relational.is_lt": "def is_lt(lhs, rhs, assumptions=None):\n    \"\"\"Fuzzy bool for lhs is strictly less than rhs.\n\n    See the docstring for :func:`~.is_ge` for more.\n    \"\"\"\n    return fuzzy_not(is_ge(lhs, rhs, assumptions))",
    "sympy.sympy.core.relational.is_gt": "def is_gt(lhs, rhs, assumptions=None):\n    \"\"\"Fuzzy bool for lhs is strictly greater than rhs.\n\n    See the docstring for :func:`~.is_ge` for more.\n    \"\"\"\n    return fuzzy_not(is_le(lhs, rhs, assumptions))",
    "sympy.sympy.core.relational.is_le": "def is_le(lhs, rhs, assumptions=None):\n    \"\"\"Fuzzy bool for lhs is less than or equal to rhs.\n\n    See the docstring for :func:`~.is_ge` for more.\n    \"\"\"\n    return is_ge(rhs, lhs, assumptions)",
    "sympy.sympy.core.relational.is_ge": "def is_ge(lhs, rhs, assumptions=None):\n    \"\"\"\n    Fuzzy bool for *lhs* is greater than or equal to *rhs*.\n\n    Parameters\n    ==========\n\n    lhs : Expr\n        The left-hand side of the expression, must be sympified,\n        and an instance of expression. Throws an exception if\n        lhs is not an instance of expression.\n\n    rhs : Expr\n        The right-hand side of the expression, must be sympified\n        and an instance of expression. Throws an exception if\n        lhs is not an instance of expression.\n\n    assumptions: Boolean, optional\n        Assumptions taken to evaluate the inequality.\n\n    Returns\n    =======\n\n    ``True`` if *lhs* is greater than or equal to *rhs*, ``False`` if *lhs*\n    is less than *rhs*, and ``None`` if the comparison between *lhs* and\n    *rhs* is indeterminate.\n\n    Explanation\n    ===========\n\n    This function is intended to give a relatively fast determination and\n    deliberately does not attempt slow calculations that might help in\n    obtaining a determination of True or False in more difficult cases.\n\n    The four comparison functions ``is_le``, ``is_lt``, ``is_ge``, and ``is_gt`` are\n    each implemented in terms of ``is_ge`` in the following way:\n\n    is_ge(x, y) := is_ge(x, y)\n    is_le(x, y) := is_ge(y, x)\n    is_lt(x, y) := fuzzy_not(is_ge(x, y))\n    is_gt(x, y) := fuzzy_not(is_ge(y, x))\n\n    Therefore, supporting new type with this function will ensure behavior for\n    other three functions as well.\n\n    To maintain these equivalences in fuzzy logic it is important that in cases where\n    either x or y is non-real all comparisons will give None.\n\n    Examples\n    ========\n\n    >>> from sympy import S, Q\n    >>> from sympy.core.relational import is_ge, is_le, is_gt, is_lt\n    >>> from sympy.abc import x\n    >>> is_ge(S(2), S(0))\n    True\n    >>> is_ge(S(0), S(2))\n    False\n    >>> is_le(S(0), S(2))\n    True\n    >>> is_gt(S(0), S(2))\n    False\n    >>> is_lt(S(2), S(0))\n    False\n\n    Assumptions can be passed to evaluate the quality which is otherwise\n    indeterminate.\n\n    >>> print(is_ge(x, S(0)))\n    None\n    >>> is_ge(x, S(0), assumptions=Q.positive(x))\n    True\n\n    New types can be supported by dispatching to ``_eval_is_ge``.\n\n    >>> from sympy import Expr, sympify\n    >>> from sympy.multipledispatch import dispatch\n    >>> class MyExpr(Expr):\n    ...     def __new__(cls, arg):\n    ...         return super().__new__(cls, sympify(arg))\n    ...     @property\n    ...     def value(self):\n    ...         return self.args[0]\n    >>> @dispatch(MyExpr, MyExpr)\n    ... def _eval_is_ge(a, b):\n    ...     return is_ge(a.value, b.value)\n    >>> a = MyExpr(1)\n    >>> b = MyExpr(2)\n    >>> is_ge(b, a)\n    True\n    >>> is_le(a, b)\n    True\n    \"\"\"\n    from sympy.assumptions.wrapper import AssumptionsWrapper, is_extended_nonnegative\n\n    if not (isinstance(lhs, Expr) and isinstance(rhs, Expr)):\n        raise TypeError(\"Can only compare inequalities with Expr\")\n\n    retval = _eval_is_ge(lhs, rhs)\n\n    if retval is not None:\n        return retval\n    else:\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            # use float comparison for infinity.\n            # otherwise get stuck in infinite recursion\n            if n2 in (S.Infinity, S.NegativeInfinity):\n                n2 = float(n2)\n            return n2 >= 0\n\n        _lhs = AssumptionsWrapper(lhs, assumptions)\n        _rhs = AssumptionsWrapper(rhs, assumptions)\n        if _lhs.is_extended_real and _rhs.is_extended_real:\n            if (_lhs.is_infinite and _lhs.is_extended_positive) or (_rhs.is_infinite and _rhs.is_extended_negative):\n                return True\n            diff = lhs - rhs\n            if diff is not S.NaN:\n                rv = is_extended_nonnegative(diff, assumptions)\n                if rv is not None:\n                    return rv",
    "sympy.sympy.functions.combinatorial.factorials._eval_Mod": "def _eval_Mod(self, q):\n    n, k = self.args\n\n    if any(x.is_integer is False for x in (n, k, q)):\n        raise ValueError(\"Integers expected for binomial Mod\")\n\n    if all(x.is_Integer for x in (n, k, q)):\n        n, k = map(int, (n, k))\n        aq, res = abs(q), 1\n\n        # handle negative integers k or n\n        if k < 0:\n            return S.Zero\n        if n < 0:\n            n = -n + k - 1\n            res = -1 if k%2 else 1\n\n        # non negative integers k and n\n        if k > n:\n            return S.Zero\n\n        isprime = aq.is_prime\n        aq = int(aq)\n        if isprime:\n            if aq < n:\n                # use Lucas Theorem\n                N, K = n, k\n                while N or K:\n                    res = res*binomial(N % aq, K % aq) % aq\n                    N, K = N // aq, K // aq\n\n            else:\n                # use Factorial Modulo\n                d = n - k\n                if k > d:\n                    k, d = d, k\n                kf = 1\n                for i in range(2, k + 1):\n                    kf = kf*i % aq\n                df = kf\n                for i in range(k + 1, d + 1):\n                    df = df*i % aq\n                res *= df\n                for i in range(d + 1, n + 1):\n                    res = res*i % aq\n\n                res *= pow(kf*df % aq, aq - 2, aq)\n                res %= aq\n\n        elif _sqrt(q) < k and q != 1:\n            res = binomial_mod(n, k, q)\n\n        else:\n            # Binomial Factorization is performed by calculating the\n            # exponents of primes <= n in `n! /(k! (n - k)!)`,\n            # for non-negative integers n and k. As the exponent of\n            # prime in n! is e_p(n) = [n/p] + [n/p**2] + ...\n            # the exponent of prime in binomial(n, k) would be\n            # e_p(n) - e_p(k) - e_p(n - k)\n            M = int(_sqrt(n))\n            for prime in sieve.primerange(2, n + 1):\n                if prime > n - k:\n                    res = res*prime % aq\n                elif prime > n // 2:\n                    continue\n                elif prime > M:\n                    if n % prime < k % prime:\n                        res = res*prime % aq\n                else:\n                    N, K = n, k\n                    exp = a = 0\n\n                    while N > 0:\n                        a = int((N % prime) < (K % prime + a))\n                        N, K = N // prime, K // prime\n                        exp += a\n\n                    if exp > 0:\n                        res *= pow(prime, exp, aq)\n                        res %= aq\n\n        return S(res % q)",
    "sympy.sympy.functions.combinatorial.numbers._eval_Mod": "def _eval_Mod(self, q):\n    # Ramanujan's congruences\n    n = self.args[0]\n    for p, rem in [(5, 4), (7, 5), (11, 6)]:\n        if q == p and n % q == rem:\n            return S.Zero",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return True",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.matrices.matrixbase._eval_Mod": "def _eval_Mod(self, other: Expr) -> Self:\n    return self._new(self.rows, self.cols, lambda i, j: Mod(self[i, j], other))"
}