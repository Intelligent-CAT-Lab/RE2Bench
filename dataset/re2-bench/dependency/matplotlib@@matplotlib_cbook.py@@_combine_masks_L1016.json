{
    "matplotlib.lib.matplotlib.cbook.is_scalar_or_string": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)",
    "matplotlib.lib.matplotlib.cbook.safe_masked_invalid": "def safe_masked_invalid(x, copy=False):\n    x = np.array(x, subok=True, copy=copy)\n    if not x.dtype.isnative:\n        # If we have already made a copy, do the byteswap in place, else make a\n        # copy with the byte order swapped.\n        # Swap to native order.\n        x = x.byteswap(inplace=copy).view(x.dtype.newbyteorder('N'))\n    try:\n        xm = np.ma.masked_where(~(np.isfinite(x)), x, copy=False)\n    except TypeError:\n        if len(x.dtype.descr) == 1:\n            # Arrays with dtype 'object' get returned here.\n            # For example the 'c' kwarg of scatter, which supports multiple types.\n            # `plt.scatter([3, 4], [2, 5], c=[(1, 0, 0), 'y'])`\n            return x\n        else:\n            # In case of a dtype with multiple fields\n            # for example image data using a MultiNorm\n            try:\n                mask = np.empty(x.shape, dtype=np.dtype('bool, '*len(x.dtype.descr)))\n                for dd, dm in zip(x.dtype.descr, mask.dtype.descr):\n                    mask[dm[0]] = ~np.isfinite(x[dd[0]])\n                xm = np.ma.array(x, mask=mask, copy=False)\n            except TypeError:\n                return x\n    return xm"
}