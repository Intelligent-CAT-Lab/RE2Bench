{
    "scikit-learn.sklearn.ensemble._bagging.predict_proba": "def predict_proba(self, X, **params):\n    \"\"\"Predict class probabilities for X.\n\n    The predicted class probabilities of an input sample is computed as\n    the mean predicted class probabilities of the base estimators in the\n    ensemble. If base estimators do not implement a ``predict_proba``\n    method, then it resorts to voting and the predicted class probabilities\n    of an input sample represents the proportion of estimators predicting\n    each class.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The training input samples. Sparse matrices are accepted only if\n        they are supported by the base estimator.\n\n    **params : dict\n        Parameters routed to the `predict_proba` (if available) or the `predict`\n        method (otherwise) of the sub-estimators via the metadata routing API.\n\n        .. versionadded:: 1.7\n\n            Only available if\n            `sklearn.set_config(enable_metadata_routing=True)` is set. See\n            :ref:`Metadata Routing User Guide <metadata_routing>` for more\n            details.\n\n    Returns\n    -------\n    p : ndarray of shape (n_samples, n_classes)\n        The class probabilities of the input samples. The order of the\n        classes corresponds to that in the attribute :term:`classes_`.\n    \"\"\"\n    _raise_for_params(params, self, \"predict_proba\")\n\n    check_is_fitted(self)\n    # Check data\n    X = validate_data(\n        self,\n        X,\n        accept_sparse=[\"csr\", \"csc\"],\n        dtype=None,\n        ensure_all_finite=False,\n        reset=False,\n    )\n\n    if _routing_enabled():\n        routed_params = process_routing(self, \"predict_proba\", **params)\n    else:\n        routed_params = Bunch()\n        routed_params.estimator = Bunch(predict_proba=Bunch())\n\n    # Parallel loop\n    n_jobs, _, starts = _partition_estimators(self.n_estimators, self.n_jobs)\n\n    all_proba = Parallel(\n        n_jobs=n_jobs, verbose=self.verbose, **self._parallel_args()\n    )(\n        delayed(_parallel_predict_proba)(\n            self.estimators_[starts[i] : starts[i + 1]],\n            self.estimators_features_[starts[i] : starts[i + 1]],\n            X,\n            self.n_classes_,\n            predict_params=routed_params.estimator.get(\"predict\", None),\n            predict_proba_params=routed_params.estimator.get(\"predict_proba\", None),\n        )\n        for i in range(n_jobs)\n    )\n\n    # Reduce\n    proba = sum(all_proba) / self.n_estimators\n\n    return proba",
    "scikit-learn.sklearn.utils._metadata_requests._raise_for_params": "def _raise_for_params(params, owner, method, allow=None):\n    \"\"\"Raise an error if metadata routing is not enabled and params are passed.\n\n    .. versionadded:: 1.4\n\n    Parameters\n    ----------\n    params : dict\n        The metadata passed to a method.\n\n    owner : object\n        The object to which the method belongs.\n\n    method : str\n        The name of the method, e.g. \"fit\".\n\n    allow : list of str, default=None\n        A list of parameters which are allowed to be passed even if metadata\n        routing is not enabled.\n\n    Raises\n    ------\n    ValueError\n        If metadata routing is not enabled and params are passed.\n    \"\"\"\n    caller = f\"{_routing_repr(owner)}.{method}\" if method else _routing_repr(owner)\n\n    allow = allow if allow is not None else {}\n\n    if not _routing_enabled() and (params.keys() - allow):\n        raise ValueError(\n            f\"Passing extra keyword arguments to {caller} is only supported if\"\n            \" enable_metadata_routing=True, which you can set using\"\n            \" `sklearn.set_config`. See the User Guide\"\n            \" <https://scikit-learn.org/stable/metadata_routing.html> for more\"\n            f\" details. Extra parameters passed are: {set(params)}\"\n        )"
}