{
    "sympy.sympy.assumptions.handlers.calculus._": "@FinitePredicate.register(Add)\ndef _(expr, assumptions):\n    \"\"\"\n    Return True if expr is bounded, False if not and None if unknown.\n\n    Truth Table:\n\n    +-------+-----+-----------+-----------+\n    |       |     |           |           |\n    |       |  B  |     U     |     ?     |\n    |       |     |           |           |\n    +-------+-----+---+---+---+---+---+---+\n    |       |     |   |   |   |   |   |   |\n    |       |     |'+'|'-'|'x'|'+'|'-'|'x'|\n    |       |     |   |   |   |   |   |   |\n    +-------+-----+---+---+---+---+---+---+\n    |       |     |           |           |\n    |   B   |  B  |     U     |     ?     |\n    |       |     |           |           |\n    +---+---+-----+---+---+---+---+---+---+\n    |   |   |     |   |   |   |   |   |   |\n    |   |'+'|     | U | ? | ? | U | ? | ? |\n    |   |   |     |   |   |   |   |   |   |\n    |   +---+-----+---+---+---+---+---+---+\n    |   |   |     |   |   |   |   |   |   |\n    | U |'-'|     | ? | U | ? | ? | U | ? |\n    |   |   |     |   |   |   |   |   |   |\n    |   +---+-----+---+---+---+---+---+---+\n    |   |   |     |           |           |\n    |   |'x'|     |     ?     |     ?     |\n    |   |   |     |           |           |\n    +---+---+-----+---+---+---+---+---+---+\n    |       |     |           |           |\n    |   ?   |     |           |     ?     |\n    |       |     |           |           |\n    +-------+-----+-----------+---+---+---+\n\n        * 'B' = Bounded\n\n        * 'U' = Unbounded\n\n        * '?' = unknown boundedness\n\n        * '+' = positive sign\n\n        * '-' = negative sign\n\n        * 'x' = sign unknown\n\n        * All Bounded -> True\n\n        * 1 Unbounded and the rest Bounded -> False\n\n        * >1 Unbounded, all with same known sign -> False\n\n        * Any Unknown and unknown sign -> None\n\n        * Else -> None\n\n    When the signs are not the same you can have an undefined\n    result as in oo - oo, hence 'bounded' is also undefined.\n    \"\"\"\n    sign = -1  # sign of unknown or infinite\n    result = True\n    for arg in expr.args:\n        _bounded = ask(Q.finite(arg), assumptions)\n        if _bounded:\n            continue\n        s = ask(Q.extended_positive(arg), assumptions)\n        # if there has been more than one sign or if the sign of this arg\n        # is None and Bounded is None or there was already\n        # an unknown sign, return None\n        if sign != -1 and s != sign or \\\n                s is None and None in (_bounded, sign):\n            return None\n        else:\n            sign = s\n        # once False, do not change\n        if result is not False:\n            result = _bounded\n    return result",
    "sympy.sympy.assumptions.handlers.common._": "@IsTruePredicate.register(Not)\ndef _(expr, assumptions):\n    arg = expr.args[0]\n    if arg.is_Symbol:\n        # symbol used as abstract boolean object\n        return None\n    value = ask(arg, assumptions=assumptions)\n    if value in (True, False):\n        return not value\n    else:\n        return None",
    "sympy.sympy.assumptions.handlers.matrices._": "@SymmetricPredicate.register(MatrixSlice)\ndef _(expr, assumptions):\n    # TODO: implement sathandlers system for the matrices.\n    # Now it duplicates the general fact: Implies(Q.diagonal, Q.symmetric).\n    if ask(Q.diagonal(expr), assumptions):\n        return True\n    if not expr.on_diag:\n        return None\n    else:\n        return ask(Q.symmetric(expr.parent), assumptions)",
    "sympy.sympy.assumptions.handlers.ntheory._": "@CompositePredicate.register(Expr)\ndef _(expr, assumptions):\n    ret = expr.is_composite\n    if ret is None:\n        raise MDNotImplementedError\n    return ret",
    "sympy.sympy.assumptions.handlers.order._": "@NegativePredicate.register(Pow)\ndef _(expr, assumptions):\n    \"\"\"\n    Real ** Even -> NonNegative\n    Real ** Odd  -> same_as_base\n    NonNegative ** Positive -> NonNegative\n    \"\"\"\n    if expr.base == E:\n        # Exponential is always positive:\n        if ask(Q.real(expr.exp), assumptions):\n            return False\n        return\n\n    if expr.is_number:\n        return _NegativePredicate_number(expr, assumptions)\n    if ask(Q.real(expr.base), assumptions):\n        if ask(Q.positive(expr.base), assumptions):\n            if ask(Q.real(expr.exp), assumptions):\n                return False\n        if ask(Q.even(expr.exp), assumptions):\n            return False\n        if ask(Q.odd(expr.exp), assumptions):\n            return ask(Q.negative(expr.base), assumptions)",
    "sympy.sympy.assumptions.handlers.sets._": "@TranscendentalPredicate.register(Expr)\ndef _(expr, assumptions):\n    ret = expr.is_transcendental\n    if ret is not None:\n        return ret\n\n    is_complex = ask(Q.complex(expr), assumptions)\n    if is_complex:\n        is_algebraic = ask(Q.algebraic(expr), assumptions)\n        return fuzzy_not(is_algebraic)\n    return is_complex",
    "sympy.sympy.calculus.accumulationbounds._eval_is_ge": "@dispatch(AccumulationBounds, AccumulationBounds)  # type:ignore\ndef _eval_is_ge(lhs, rhs): # noqa:F811\n    if is_ge(lhs.min, rhs.max):\n        return True\n    if is_lt(lhs.max, rhs.min):\n        return False",
    "sympy.sympy.combinatorics.permutations._eval_is_eq": "@dispatch(Permutation, Permutation)\ndef _eval_is_eq(lhs, rhs):\n    if lhs._size != rhs._size:\n        return None\n    return lhs._array_form == rhs._array_form",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return hash((self.class_key(), frozenset(self._kwargs.items())))",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.numbers._eval_is_eq": "@dispatch(Tuple, Number) # type:ignore\ndef _eval_is_eq(self, other): # noqa: F811\n    return False",
    "sympy.sympy.core.relational._eval_is_ge": "@dispatch(Expr, Expr)\ndef _eval_is_ge(lhs, rhs):\n    return None",
    "sympy.sympy.core.relational._eval_is_eq": "@dispatch(Tuple, Tuple) # type: ignore\ndef _eval_is_eq(lhs, rhs):  # noqa:F811\n    if len(lhs) != len(rhs):\n        return False\n\n    return fuzzy_and(fuzzy_bool(is_eq(s, o)) for s, o in zip(lhs, rhs))",
    "sympy.sympy.functions.elementary.integers._eval_is_eq": "@dispatch(frac, Basic)  # type:ignore\ndef _eval_is_eq(lhs, rhs): # noqa:F811\n    if (lhs.rewrite(floor) == rhs) or \\\n        (lhs.rewrite(ceiling) == rhs):\n        return True\n    # Check if other < 0\n    if rhs.is_extended_negative:\n        return False\n    # Check if other >= 1\n    res = lhs._value_one_or_more(rhs)\n    if res is not None:\n        return False",
    "sympy.sympy.geometry.entity.union_sets": "@dispatch(GeometrySet, Set)  # type:ignore # noqa:F811\ndef union_sets(self, o): # noqa:F811\n    \"\"\" Returns the union of self and o\n    for use with sympy.sets.Set, if possible. \"\"\"\n\n\n    # if its a FiniteSet, merge any points\n    # we contain and return a union with the rest\n    if o.is_FiniteSet:\n        other_points = [p for p in o if not self._contains(p)]\n        if len(other_points) == len(o):\n            return None\n        return Union(self, FiniteSet(*other_points))\n    if self._contains(o):\n        return self\n    return None",
    "sympy.sympy.geometry.entity.intersection_sets": "@dispatch(GeometrySet, Set)  # type: ignore # noqa:F811\ndef intersection_sets(self, o): # noqa:F811\n    \"\"\" Returns a sympy.sets.Set of intersection objects,\n    if possible. \"\"\"\n\n    from sympy.geometry.point import Point\n\n    try:\n        # if o is a FiniteSet, find the intersection directly\n        # to avoid infinite recursion\n        if o.is_FiniteSet:\n            inter = FiniteSet(*(p for p in o if self.contains(p)))\n        else:\n            inter = self.intersection(o)\n    except NotImplementedError:\n        # sympy.sets.Set.reduce expects None if an object\n        # doesn't know how to simplify\n        return None\n\n    # put the points in a FiniteSet\n    points = FiniteSet(*[p for p in inter if isinstance(p, Point)])\n    non_points = [p for p in inter if not isinstance(p, Point)]\n\n    return Union(*(non_points + [points]))",
    "sympy.sympy.matrices.expressions.matexpr._eval_is_eq": "@dispatch(MatrixExpr, MatrixExpr)  # type: ignore\ndef _eval_is_eq(lhs, rhs): # noqa:F811\n    if lhs.shape != rhs.shape:\n        return False\n    if (lhs - rhs).is_ZeroMatrix:\n        return True",
    "sympy.sympy.matrices.immutable._eval_is_eq": "@dispatch(ImmutableDenseMatrix, ImmutableDenseMatrix)\ndef _eval_is_eq(lhs, rhs): # noqa:F811\n    \"\"\"Helper method for Equality with matrices.sympy.\n\n    Relational automatically converts matrices to ImmutableDenseMatrix\n    instances, so this method only applies here.  Returns True if the\n    matrices are definitively the same, False if they are definitively\n    different, and None if undetermined (e.g. if they contain Symbols).\n    Returning None triggers default handling of Equalities.\n\n    \"\"\"\n    if lhs.shape != rhs.shape:\n        return False\n    return (lhs - rhs).is_zero_matrix",
    "sympy.sympy.multipledispatch.dispatcher.<listcomp>": "types = tuple([type(arg) for arg in args])\n",
    "sympy.sympy.multipledispatch.dispatcher.dispatch": "def dispatch(self, *types):\n    \"\"\" Deterimine appropriate implementation for this type signature\n\n    This method is internal.  Users should call this object as a function.\n    Implementation resolution occurs within the ``__call__`` method.\n\n    >>> from sympy.multipledispatch import dispatch\n    >>> @dispatch(int)\n    ... def inc(x):\n    ...     return x + 1\n\n    >>> implementation = inc.dispatch(int)\n    >>> implementation(3)\n    4\n\n    >>> print(inc.dispatch(float))\n    None\n\n    See Also:\n        ``sympy.multipledispatch.conflict`` - module to determine resolution order\n    \"\"\"\n\n    if types in self.funcs:\n        return self.funcs[types]\n\n    try:\n        return next(self.dispatch_iter(*types))\n    except StopIteration:\n        return None",
    "sympy.sympy.multipledispatch.dispatcher.dispatch_iter": "def dispatch_iter(self, *types):\n    n = len(types)\n    for signature in self.ordering:\n        if len(signature) == n and all(map(issubclass, types, signature)):\n            result = self.funcs[signature]\n            yield result",
    "sympy.sympy.multipledispatch.dispatcher.str_signature": "def str_signature(sig):\n    \"\"\" String representation of type signature\n\n    >>> from sympy.multipledispatch.dispatcher import str_signature\n    >>> str_signature((int, float))\n    'int, float'\n    \"\"\"\n    return ', '.join(cls.__name__ for cls in sig)",
    "sympy.sympy.multipledispatch.dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple(type(a) for a in args)\n    raise NotImplementedError(\n        \"Ambiguous signature for %s: <%s>\" % (\n        self.dispatcher.name, str_signature(types)\n    ))",
    "sympy.sympy.physics.quantum.transforms._transform_op_ket": "@_transform_state_pair.register(OuterProduct, KetBase)\ndef _transform_op_ket(a, b):\n    return (InnerProduct(a.bra, b), a.ket)",
    "sympy.sympy.physics.quantum.transforms._transform_bra_op": "@_transform_state_pair.register(BraBase, OuterProduct)\ndef _transform_bra_op(a, b):\n    return (InnerProduct(a, b.ket), b.bra)",
    "sympy.sympy.physics.quantum.transforms._transform_tp_ket": "@_transform_state_pair.register(TensorProduct, KetBase)\ndef _transform_tp_ket(a, b):\n    \"\"\"Raise a TypeError if a user tries to multiply TensorProduct(*kets)*ket.\n\n    Multiplication based on `*` is not a shorthand for tensor products.\n    \"\"\"\n    if a.kind == KetKind:\n        raise TypeError(\n            'Multiplication of TensorProduct(*kets)*ket is invalid.'\n        )",
    "sympy.sympy.physics.quantum.transforms._transform_ket_tp": "@_transform_state_pair.register(KetBase, TensorProduct)\ndef _transform_ket_tp(a, b):\n    \"\"\"Raise a TypeError if a user tries to multiply ket*TensorProduct(*kets).\n\n    Multiplication based on `*` is not a shorthand for tensor products.\n    \"\"\"\n    if b.kind == KetKind:\n        raise TypeError(\n            'Multiplication of ket*TensorProduct(*kets) is invalid.'\n        )",
    "sympy.sympy.physics.quantum.transforms._transform_tp_bra": "@_transform_state_pair.register(TensorProduct, BraBase)\ndef _transform_tp_bra(a, b):\n    \"\"\"Raise a TypeError if a user tries to multiply TensorProduct(*bras)*bra.\n\n    Multiplication based on `*` is not a shorthand for tensor products.\n    \"\"\"\n    if a.kind == BraKind:\n        raise TypeError(\n            'Multiplication of TensorProduct(*bras)*bra is invalid.'\n        )",
    "sympy.sympy.physics.quantum.transforms._transform_bra_tp": "@_transform_state_pair.register(BraBase, TensorProduct)\ndef _transform_bra_tp(a, b):\n    \"\"\"Raise a TypeError if a user tries to multiply bra*TensorProduct(*bras).\n\n    Multiplication based on `*` is not a shorthand for tensor products.\n    \"\"\"\n    if b.kind == BraKind:\n        raise TypeError(\n            'Multiplication of bra*TensorProduct(*bras) is invalid.'\n        )",
    "sympy.sympy.physics.quantum.transforms._transform_tp_tp": "@_transform_state_pair.register(TensorProduct, TensorProduct)\ndef _transform_tp_tp(a, b):\n    \"\"\"Combine a product of tensor products if their number of args matches.\"\"\"\n    debug('_transform_tp_tp', a, b)\n    if len(a.args) == len(b.args):\n        if a.kind == BraKind and b.kind == KetKind:\n            return tuple([InnerProduct(i, j) for (i, j) in zip(a.args, b.args)])\n        else:\n            return (TensorProduct(*(i*j for (i, j) in zip(a.args, b.args))), )",
    "sympy.sympy.physics.quantum.transforms._transform_op_op": "@_transform_state_pair.register(OuterProduct, OuterProduct)\ndef _transform_op_op(a, b):\n    \"\"\"Extract an inner produt from a product of outer products.\"\"\"\n    return (InnerProduct(a.bra, b.ket), OuterProduct(a.ket, b.bra))",
    "sympy.sympy.physics.quantum.transforms._transform_expr": "@_transform_state_pair.register(Expr, Expr)\ndef _transform_expr(a, b):\n    \"\"\"Default transformer that does nothing for base types.\"\"\"\n    return None",
    "sympy.sympy.physics.quantum.transforms.<lambda>": "lambda x, y: (x,),\n",
    "sympy.sympy.physics.quantum.transforms._transform_bra_ket": "@_transform_state_pair.register(BraBase, KetBase)\ndef _transform_bra_ket(a, b):\n    \"\"\"Transform a bra*ket -> InnerProduct(bra, ket).\"\"\"\n    return (InnerProduct(a, b),)",
    "sympy.sympy.physics.quantum.transforms._transform_ket_bra": "@_transform_state_pair.register(KetBase, BraBase)\ndef _transform_ket_bra(a, b):\n    \"\"\"Transform a keT*bra -> OuterProduct(ket, bra).\"\"\"\n    return (OuterProduct(a, b),)",
    "sympy.sympy.polys.rootoftools._eval_is_eq": "@dispatch(ComplexRootOf, Basic)  # type:ignore\ndef _eval_is_eq(lhs, rhs): # noqa:F811\n    # CRootOf represents a Root, so if rhs is that root, it should set\n    # the expression to zero *and* it should be in the interval of the\n    # CRootOf instance. It must also be a number that agrees with the\n    # is_real value of the CRootOf instance.\n    if not rhs.is_number:\n        return None\n    if not rhs.is_finite:\n        return False\n    z = lhs.expr.subs(lhs.expr.free_symbols.pop(), rhs).is_zero\n    if z is False:  # all roots will make z True but we don't know\n        # whether this is the right root if z is True\n        return False\n    o = rhs.is_real, rhs.is_imaginary\n    s = lhs.is_real, lhs.is_imaginary\n    assert None not in s  # this is part of initial refinement\n    if o != s and None not in o:\n        return False\n    re, im = rhs.as_real_imag()\n    if lhs.is_real:\n        if im:\n            return False\n        i = lhs._get_interval()\n        a, b = [Rational(str(_)) for _ in (i.a, i.b)]\n        return sympify(a <= rhs and rhs <= b)\n    i = lhs._get_interval()\n    r1, r2, i1, i2 = [Rational(str(j)) for j in (\n        i.ax, i.bx, i.ay, i.by)]\n    return is_le(r1, re) and is_le(re,r2) and is_le(i1,im) and is_le(im,i2)",
    "sympy.sympy.sets.handlers.add._": "@_set_sub.register(Interval, Interval)\ndef _(x, y):\n    \"\"\"\n    Subtractions in interval arithmetic\n    https://en.wikipedia.org/wiki/Interval_arithmetic\n    \"\"\"\n    return Interval(x.start - y.end, x.end - y.start,\n                    x.left_open or y.right_open, x.right_open or y.left_open)",
    "sympy.sympy.sets.handlers.comparison._eval_is_eq": "@dispatch(Set, Set) # type:ignore\ndef _eval_is_eq(lhs, rhs): # noqa: F811\n    return tfn[fuzzy_and(a.is_subset(b) for a, b in [(lhs, rhs), (rhs, lhs)])]",
    "sympy.sympy.sets.handlers.comparison.<genexpr>": "eqs = (is_eq(x, y) for x, y in zip(lhs.sets, rhs.sets))\n",
    "sympy.sympy.sets.handlers.functions._": "@_set_function.register(Lambda, Interval)\ndef _(f, x):\n    from sympy.solvers.solveset import solveset\n    from sympy.series import limit\n    # TODO: handle functions with infinitely many solutions (eg, sin, tan)\n    # TODO: handle multivariate functions\n\n    expr = f.expr\n    if len(expr.free_symbols) > 1 or len(f.variables) != 1:\n        return\n    var = f.variables[0]\n    if not var.is_real:\n        if expr.subs(var, Dummy(real=True)).is_real is False:\n            return\n\n    if expr.is_Piecewise:\n        result = S.EmptySet\n        domain_set = x\n        for (p_expr, p_cond) in expr.args:\n            if p_cond is true:\n                intrvl = domain_set\n            else:\n                intrvl = p_cond.as_set()\n                intrvl = Intersection(domain_set, intrvl)\n\n            if p_expr.is_Number:\n                image = FiniteSet(p_expr)\n            else:\n                image = imageset(Lambda(var, p_expr), intrvl)\n            result = Union(result, image)\n\n            # remove the part which has been `imaged`\n            domain_set = Complement(domain_set, intrvl)\n            if domain_set is S.EmptySet:\n                break\n        return result\n\n    if not x.start.is_comparable or not x.end.is_comparable:\n        return\n\n    try:\n        from sympy.polys.polyutils import _nsort\n        sing = list(singularities(expr, var, x))\n        if len(sing) > 1:\n            sing = _nsort(sing)\n    except NotImplementedError:\n        return\n\n    if x.left_open:\n        _start = limit(expr, var, x.start, dir=\"+\")\n    elif x.start not in sing:\n        _start = f(x.start)\n    if x.right_open:\n        _end = limit(expr, var, x.end, dir=\"-\")\n    elif x.end not in sing:\n        _end = f(x.end)\n\n    if len(sing) == 0:\n        soln_expr = solveset(diff(expr, var), var)\n        if not (isinstance(soln_expr, FiniteSet)\n                or soln_expr is S.EmptySet):\n            return\n        solns = list(soln_expr)\n\n        extr = [_start, _end] + [f(i) for i in solns\n                                 if i.is_real and i in x]\n        start, end = Min(*extr), Max(*extr)\n\n        left_open, right_open = False, False\n        if _start <= _end:\n            # the minimum or maximum value can occur simultaneously\n            # on both the edge of the interval and in some interior\n            # point\n            if start == _start and start not in solns:\n                left_open = x.left_open\n            if end == _end and end not in solns:\n                right_open = x.right_open\n        else:\n            if start == _end and start not in solns:\n                left_open = x.right_open\n            if end == _start and end not in solns:\n                right_open = x.left_open\n\n        return Interval(start, end, left_open, right_open)\n    else:\n        return imageset(f, Interval(x.start, sing[0],\n                                    x.left_open, True)) + \\\n            Union(*[imageset(f, Interval(sing[i], sing[i + 1], True, True))\n                    for i in range(0, len(sing) - 1)]) + \\\n            imageset(f, Interval(sing[-1], x.end, True, x.right_open))",
    "sympy.sympy.sets.handlers.intersection._": "@intersection_sets.register(Range, Interval)\ndef _(a, b):\n    # Check that there are no symbolic arguments\n    if not all(i.is_number for i in a.args + b.args[:2]):\n        return\n\n    # In case of null Range, return an EmptySet.\n    if a.size == 0:\n        return S.EmptySet\n\n    # trim down to self's size, and represent\n    # as a Range with step 1.\n    start = ceiling(max(b.inf, a.inf))\n    if start not in b:\n        start += 1\n    end = floor(min(b.sup, a.sup))\n    if end not in b:\n        end -= 1\n    return intersection_sets(a, Range(start, end + 1))",
    "sympy.sympy.sets.handlers.issubset._": "@is_subset_sets.register(Range, FiniteSet)\ndef _(a_range, b_finiteset):\n    try:\n        a_size = a_range.size\n    except ValueError:\n        # symbolic Range of unknown size\n        return None\n    if a_size > len(b_finiteset):\n        return False\n    elif any(arg.has(Symbol) for arg in a_range.args):\n        return fuzzy_and(b_finiteset.contains(x) for x in a_range)\n    else:\n        # Checking A \\ B == EmptySet is more efficient than repeated naive\n        # membership checks on an arbitrary FiniteSet.\n        a_set = set(a_range)\n        b_remaining = len(b_finiteset)\n        # Symbolic expressions and numbers of unknown type (integer or not) are\n        # all counted as \"candidates\", i.e. *potentially* matching some a in\n        # a_range.\n        cnt_candidate = 0\n        for b in b_finiteset:\n            if b.is_Integer:\n                a_set.discard(b)\n            elif fuzzy_not(b.is_integer):\n                pass\n            else:\n                cnt_candidate += 1\n            b_remaining -= 1\n            if len(a_set) > b_remaining + cnt_candidate:\n                return False\n            if len(a_set) == 0:\n                return True\n        return None",
    "sympy.sympy.sets.handlers.mul._": "@_set_div.register(Interval, Interval)\ndef _(x, y):\n    \"\"\"\n    Divisions in interval arithmetic\n    https://en.wikipedia.org/wiki/Interval_arithmetic\n    \"\"\"\n    if (y.start*y.end).is_negative:\n        return Interval(-oo, oo)\n    if y.start == 0:\n        s2 = oo\n    else:\n        s2 = 1/y.start\n    if y.end == 0:\n        s1 = -oo\n    else:\n        s1 = 1/y.end\n    return set_mul(x, Interval(s1, s2, y.right_open, y.left_open))",
    "sympy.sympy.sets.handlers.power._": "@_set_pow.register(Interval, Infinity)\ndef _(b, e):\n    # TODO: add logic for open intervals?\n    if b.start.is_nonnegative:\n        if b.end < 1:\n            return FiniteSet(S.Zero)\n        if b.start > 1:\n            return FiniteSet(S.Infinity)\n        return Interval(0, oo)\n    elif b.end.is_negative:\n        if b.start > -1:\n            return FiniteSet(S.Zero)\n        if b.end < -1:\n            return FiniteSet(-oo, oo)\n        return Interval(-oo, oo)\n    else:\n        if b.start > -1:\n            if b.end < 1:\n                return FiniteSet(S.Zero)\n            return Interval(0, oo)\n        return Interval(-oo, oo)",
    "sympy.sympy.sets.handlers.union._": "@union_sets.register(Interval, Interval)\ndef _(a, b):\n    if a._is_comparable(b):\n        # Non-overlapping intervals\n        end = Min(a.end, b.end)\n        start = Max(a.start, b.start)\n        if (end < start or\n           (end == start and (end not in a and end not in b))):\n            return None\n        else:\n            start = Min(a.start, b.start)\n            end = Max(a.end, b.end)\n\n            left_open = ((a.start != start or a.left_open) and\n                         (b.start != start or b.left_open))\n            right_open = ((a.end != end or a.right_open) and\n                          (b.end != end or b.right_open))\n            return Interval(start, end, left_open, right_open)",
    "sympy.sympy.tensor.indexed._eval_is_ge": "@dispatch(Number, Idx)  # type:ignore\ndef _eval_is_ge(lhs, rhs): # noqa:F811\n\n    other_upper = lhs\n    other_lower = lhs\n\n    if rhs.upper is not None and (rhs.upper <= other_lower) == True:\n        return True\n    if rhs.lower is not None and (rhs.lower > other_upper) == True:\n        return False\n    return None"
}