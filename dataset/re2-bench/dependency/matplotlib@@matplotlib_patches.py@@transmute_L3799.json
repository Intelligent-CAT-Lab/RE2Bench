{
    "matplotlib.lib.matplotlib.bezier.split_bezier_intersecting_with_closedpath": "def split_bezier_intersecting_with_closedpath(\n        bezier, inside_closedpath, tolerance=0.01):\n    \"\"\"\n    Split a B\u00e9zier curve into two at the intersection with a closed path.\n\n    Parameters\n    ----------\n    bezier : (N, 2) array-like\n        Control points of the B\u00e9zier segment. See `.BezierSegment`.\n    inside_closedpath : callable\n        A function returning True if a given point (x, y) is inside the\n        closed path. See also `.find_bezier_t_intersecting_with_closedpath`.\n    tolerance : float\n        The tolerance for the intersection. See also\n        `.find_bezier_t_intersecting_with_closedpath`.\n\n    Returns\n    -------\n    left, right\n        Lists of control points for the two B\u00e9zier segments.\n    \"\"\"\n\n    bz = BezierSegment(bezier)\n\n    t0, t1 = find_bezier_t_intersecting_with_closedpath(\n        lambda t: tuple(bz(t)), inside_closedpath, tolerance=tolerance)\n\n    _left, _right = split_de_casteljau(bezier, (t0 + t1) / 2.)\n    return _left, _right",
    "matplotlib.lib.matplotlib.bezier.inside_circle": "def inside_circle(cx, cy, r):\n    \"\"\"\n    Return a function that checks whether a point is in a circle with center\n    (*cx*, *cy*) and radius *r*.\n\n    The returned function has the signature::\n\n        f(xy: tuple[float, float]) -> bool\n    \"\"\"\n    r2 = r ** 2\n\n    def _f(xy):\n        x, y = xy\n        return (x - cx) ** 2 + (y - cy) ** 2 < r2\n    return _f",
    "matplotlib.lib.matplotlib.bezier.make_wedged_bezier2": "def make_wedged_bezier2(bezier2, width, w1=1., wm=0.5, w2=0.):\n    \"\"\"\n    Being similar to `get_parallels`, returns control points of two quadratic\n    B\u00e9zier lines having a width roughly parallel to given one separated by\n    *width*.\n    \"\"\"\n\n    # c1, cm, c2\n    c1x, c1y = bezier2[0]\n    cmx, cmy = bezier2[1]\n    c3x, c3y = bezier2[2]\n\n    # t1 and t2 is the angle between c1 and cm, cm, c3.\n    # They are also an angle of the tangential line of the path at c1 and c3\n    cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy)\n    cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c3x, c3y)\n\n    # find c1_left, c1_right which are located along the lines\n    # through c1 and perpendicular to the tangential lines of the\n    # Bezier path at a distance of width. Same thing for c3_left and\n    # c3_right with respect to c3.\n    c1x_left, c1y_left, c1x_right, c1y_right = (\n        get_normal_points(c1x, c1y, cos_t1, sin_t1, width * w1)\n    )\n    c3x_left, c3y_left, c3x_right, c3y_right = (\n        get_normal_points(c3x, c3y, cos_t2, sin_t2, width * w2)\n    )\n\n    # find c12, c23 and c123 which are middle points of c1-cm, cm-c3 and\n    # c12-c23\n    c12x, c12y = (c1x + cmx) * .5, (c1y + cmy) * .5\n    c23x, c23y = (cmx + c3x) * .5, (cmy + c3y) * .5\n    c123x, c123y = (c12x + c23x) * .5, (c12y + c23y) * .5\n\n    # tangential angle of c123 (angle between c12 and c23)\n    cos_t123, sin_t123 = get_cos_sin(c12x, c12y, c23x, c23y)\n\n    c123x_left, c123y_left, c123x_right, c123y_right = (\n        get_normal_points(c123x, c123y, cos_t123, sin_t123, width * wm)\n    )\n\n    path_left = find_control_points(c1x_left, c1y_left,\n                                    c123x_left, c123y_left,\n                                    c3x_left, c3y_left)\n    path_right = find_control_points(c1x_right, c1y_right,\n                                     c123x_right, c123y_right,\n                                     c3x_right, c3y_right)\n\n    return path_left, path_right",
    "matplotlib.lib.matplotlib.patches._point_along_a_line": "def _point_along_a_line(x0, y0, x1, y1, d):\n    \"\"\"\n    Return the point on the line connecting (*x0*, *y0*) -- (*x1*, *y1*) whose\n    distance from (*x0*, *y0*) is *d*.\n    \"\"\"\n    dx, dy = x0 - x1, y0 - y1\n    ff = d / (dx * dx + dy * dy) ** .5\n    x2, y2 = x0 - ff * dx, y0 - ff * dy\n\n    return x2, y2",
    "matplotlib.lib.matplotlib.patches.ensure_quadratic_bezier": "@staticmethod\ndef ensure_quadratic_bezier(path):\n    \"\"\"\n    Some ArrowStyle classes only works with a simple quadratic\n    B\u00e9zier curve (created with `.ConnectionStyle.Arc3` or\n    `.ConnectionStyle.Angle3`). This static method checks if the\n    provided path is a simple quadratic B\u00e9zier curve and returns its\n    control points if true.\n    \"\"\"\n    segments = list(path.iter_segments())\n    if (len(segments) != 2 or segments[0][1] != Path.MOVETO or\n            segments[1][1] != Path.CURVE3):\n        raise ValueError(\n            \"'path' is not a valid quadratic Bezier curve\")\n    return [*segments[0][0], *segments[1][0]]",
    "matplotlib.lib.matplotlib.patches.<listcomp>": "path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n",
    "matplotlib.lib.matplotlib.path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : (N, 2) array-like\n        The path vertices, as an array, masked array or sequence of pairs.\n        Masked values, if any, will be converted to NaNs, which are then\n        handled correctly by the Agg PathIterator and other consumers of\n        path data, such as :meth:`iter_segments`.\n    codes : array-like or None, optional\n        N-length array of integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        `CLOSEPOLY`).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n\n    if codes is not None and len(vertices):\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'. \"\n                             f\"Your vertices have shape {vertices.shape} \"\n                             f\"but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             f\"to 'MOVETO' ({self.MOVETO}).  \"\n                             f\"Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False"
}