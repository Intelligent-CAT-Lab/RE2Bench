{
    "sympy.sympy.algebras.quaternion.__new__": "def __new__(cls, a: SExpr = 0, b: SExpr = 0, c: SExpr = 0, d: SExpr = 0,\n                 real_field: bool = True,\n                 norm: SExpr | None = None) -> Quaternion:\n\n    a, b, c, d = map(sympify, (a, b, c, d))\n\n    if any(i.is_commutative is False for i in [a, b, c, d]):\n        raise ValueError(\"arguments have to be commutative\")\n\n    obj = super().__new__(cls, a, b, c, d)\n    obj._real_field = real_field\n    obj.set_norm(norm)\n    return obj",
    "sympy.sympy.algebras.quaternion.vector_part": "def vector_part(self) -> Quaternion:\n    r\"\"\"\n    Returns $\\mathbf{V}(q)$, the vector part of the quaternion $q$.\n\n    Explanation\n    ===========\n\n    Given a quaternion $q = a + bi + cj + dk$, returns $\\mathbf{V}(q) = bi + cj + dk$.\n\n    Examples\n    ========\n\n    >>> from sympy.algebras.quaternion import Quaternion\n    >>> q = Quaternion(1, 1, 1, 1)\n    >>> q.vector_part()\n    0 + 1*i + 1*j + 1*k\n\n    >>> q = Quaternion(4, 8, 13, 12)\n    >>> q.vector_part()\n    0 + 8*i + 13*j + 12*k\n\n    \"\"\"\n\n    return Quaternion(0, self.b, self.c, self.d)",
    "sympy.sympy.algebras.quaternion.b": "@property\ndef b(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.algebras.quaternion.c": "@property\ndef c(self) -> Expr:\n    return self.args[2]",
    "sympy.sympy.algebras.quaternion.d": "@property\ndef d(self) -> Expr:\n    return self.args[3]",
    "sympy.sympy.algebras.quaternion.normalize": "def normalize(self) -> Quaternion:\n    \"\"\"Returns the normalized form of the quaternion.\"\"\"\n    q = self\n    return q * (1/q.norm())"
}