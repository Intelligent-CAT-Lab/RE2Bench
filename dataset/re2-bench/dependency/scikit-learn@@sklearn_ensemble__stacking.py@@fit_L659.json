{
    "scikit-learn.sklearn.base.wrapper": "@functools.wraps(fit_method)\ndef wrapper(estimator, *args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n\n    # we don't want to validate again for each call to partial_fit\n    partial_fit_and_fitted = (\n        fit_method.__name__ == \"partial_fit\" and _is_fitted(estimator)\n    )\n\n    if not global_skip_validation and not partial_fit_and_fitted:\n        estimator._validate_params()\n\n    with config_context(\n        skip_parameter_validation=(\n            prefer_skip_nested_validation or global_skip_validation\n        )\n    ):\n        return fit_method(estimator, *args, **kwargs)",
    "scikit-learn.sklearn.ensemble._stacking.<listcomp>": "[\n    self._label_encoder[target_idx].transform(target)\n    for target_idx, target in enumerate(y.T)\n",
    "scikit-learn.sklearn.preprocessing._label.transform": "def transform(self, y):\n    \"\"\"Transform labels to normalized encoding.\n\n    Parameters\n    ----------\n    y : array-like of shape (n_samples,)\n        Target values.\n\n    Returns\n    -------\n    y : array-like of shape (n_samples,)\n        Labels as normalized encodings.\n    \"\"\"\n    check_is_fitted(self)\n    xp, _ = get_namespace(y)\n    y = column_or_1d(y, dtype=self.classes_.dtype, warn=True)\n    # transform of empty array is empty array\n    if _num_samples(y) == 0:\n        return xp.asarray([])\n\n    return _encode(y, uniques=self.classes_)",
    "scikit-learn.sklearn.preprocessing._label.fit": "def fit(self, y):\n    \"\"\"Fit label encoder.\n\n    Parameters\n    ----------\n    y : array-like of shape (n_samples,)\n        Target values.\n\n    Returns\n    -------\n    self : returns an instance of self.\n        Fitted label encoder.\n    \"\"\"\n    y = column_or_1d(y, warn=True)\n    self.classes_ = _unique(y)\n    return self",
    "scikit-learn.sklearn.utils._metadata_requests._raise_for_params": "def _raise_for_params(params, owner, method, allow=None):\n    \"\"\"Raise an error if metadata routing is not enabled and params are passed.\n\n    .. versionadded:: 1.4\n\n    Parameters\n    ----------\n    params : dict\n        The metadata passed to a method.\n\n    owner : object\n        The object to which the method belongs.\n\n    method : str\n        The name of the method, e.g. \"fit\".\n\n    allow : list of str, default=None\n        A list of parameters which are allowed to be passed even if metadata\n        routing is not enabled.\n\n    Raises\n    ------\n    ValueError\n        If metadata routing is not enabled and params are passed.\n    \"\"\"\n    caller = f\"{_routing_repr(owner)}.{method}\" if method else _routing_repr(owner)\n\n    allow = allow if allow is not None else {}\n\n    if not _routing_enabled() and (params.keys() - allow):\n        raise ValueError(\n            f\"Passing extra keyword arguments to {caller} is only supported if\"\n            \" enable_metadata_routing=True, which you can set using\"\n            \" `sklearn.set_config`. See the User Guide\"\n            \" <https://scikit-learn.org/stable/metadata_routing.html> for more\"\n            f\" details. Extra parameters passed are: {set(params)}\"\n        )",
    "scikit-learn.sklearn.utils.multiclass.check_classification_targets": "def check_classification_targets(y):\n    \"\"\"Ensure that target y is of a non-regression type.\n\n    Only the following target types (as defined in type_of_target) are allowed:\n        'binary', 'multiclass', 'multiclass-multioutput',\n        'multilabel-indicator', 'multilabel-sequences'\n\n    Parameters\n    ----------\n    y : array-like\n        Target values.\n    \"\"\"\n    y_type = type_of_target(y, input_name=\"y\")\n    if y_type not in [\n        \"binary\",\n        \"multiclass\",\n        \"multiclass-multioutput\",\n        \"multilabel-indicator\",\n        \"multilabel-sequences\",\n    ]:\n        raise ValueError(\n            f\"Unknown label type: {y_type}. Maybe you are trying to fit a \"\n            \"classifier, which expects discrete classes on a \"\n            \"regression target with continuous values.\"\n        )\n\n    if \"multiclass\" in y_type:\n        n_samples = _num_samples(y)\n        if n_samples > 20 and cached_unique(y).shape[0] > round(0.5 * n_samples):\n            # Only raise the warning when we have at least 20 samples.\n            warnings.warn(\n                \"The number of unique classes is greater than 50% of the number \"\n                \"of samples. `y` could represent a regression problem, not a \"\n                \"classification problem.\",\n                UserWarning,\n                stacklevel=2,\n            )",
    "scikit-learn.sklearn.utils.multiclass.type_of_target": "def type_of_target(y, input_name=\"\", raise_unknown=False):\n    \"\"\"Determine the type of data indicated by the target.\n\n    Note that this type is the most specific type that can be inferred.\n    For example:\n\n    * ``binary`` is more specific but compatible with ``multiclass``.\n    * ``multiclass`` of integers is more specific but compatible with ``continuous``.\n    * ``multilabel-indicator`` is more specific but compatible with\n      ``multiclass-multioutput``.\n\n    Parameters\n    ----------\n    y : {array-like, sparse matrix}\n        Target values. If a sparse matrix, `y` is expected to be a\n        CSR/CSC matrix.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message.\n\n        .. versionadded:: 1.1.0\n\n    raise_unknown : bool, default=False\n        If `True`, raise an error when the type of target returned by\n        :func:`~sklearn.utils.multiclass.type_of_target` is `\"unknown\"`.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    target_type : str\n        One of:\n\n        * 'continuous': `y` is an array-like of floats that are not all\n          integers, and is 1d or a column vector.\n        * 'continuous-multioutput': `y` is a 2d array of floats that are\n          not all integers, and both dimensions are of size > 1.\n        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n          vector.\n        * 'multiclass': `y` contains more than two discrete values, is not a\n          sequence of sequences, and is 1d or a column vector.\n        * 'multiclass-multioutput': `y` is a 2d array that contains more\n          than two discrete values, is not a sequence of sequences, and both\n          dimensions are of size > 1.\n        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n          of two dimensions with at least two columns, and at most 2 unique\n          values.\n        * 'unknown': `y` is array-like but none of the above, such as a 3d\n          array, sequence of sequences, or an array of non-sequence objects.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import type_of_target\n    >>> import numpy as np\n    >>> type_of_target([0.1, 0.6])\n    'continuous'\n    >>> type_of_target([1, -1, -1, 1])\n    'binary'\n    >>> type_of_target(['a', 'b', 'a'])\n    'binary'\n    >>> type_of_target([1.0, 2.0])\n    'binary'\n    >>> type_of_target([1, 0, 2])\n    'multiclass'\n    >>> type_of_target([1.0, 0.0, 3.0])\n    'multiclass'\n    >>> type_of_target(['a', 'b', 'c'])\n    'multiclass'\n    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n    'multiclass-multioutput'\n    >>> type_of_target([[1, 2]])\n    'multilabel-indicator'\n    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n    'continuous-multioutput'\n    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n    'multilabel-indicator'\n    \"\"\"\n    xp, is_array_api_compliant = get_namespace(y)\n\n    def _raise_or_return():\n        \"\"\"Depending on the value of raise_unknown, either raise an error or return\n        'unknown'.\n        \"\"\"\n        if raise_unknown:\n            input = input_name if input_name else \"data\"\n            raise ValueError(f\"Unknown label type for {input}: {y!r}\")\n        else:\n            return \"unknown\"\n\n    valid = (\n        (isinstance(y, Sequence) or issparse(y) or hasattr(y, \"__array__\"))\n        and not isinstance(y, str)\n    ) or is_array_api_compliant\n\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    check_y_kwargs = dict(\n        accept_sparse=True,\n        allow_nd=True,\n        ensure_all_finite=False,\n        ensure_2d=False,\n        ensure_min_samples=0,\n        ensure_min_features=0,\n    )\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                y = check_array(y, dtype=None, **check_y_kwargs)\n            except (VisibleDeprecationWarning, ValueError) as e:\n                if str(e).startswith(\"Complex data not supported\"):\n                    raise\n\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = check_array(y, dtype=object, **check_y_kwargs)\n\n    try:\n        first_row_or_val = y[[0], :] if issparse(y) else y[0]\n        # labels in bytes format\n        if isinstance(first_row_or_val, bytes):\n            raise TypeError(\n                \"Support for labels represented as bytes is not supported. Convert \"\n                \"the labels to a string or integer format.\"\n            )\n        # The old sequence of sequences format\n        if (\n            not hasattr(first_row_or_val, \"__array__\")\n            and isinstance(first_row_or_val, Sequence)\n            and not isinstance(first_row_or_val, str)\n        ):\n            raise ValueError(\n                \"You appear to be using a legacy multi-label data\"\n                \" representation. Sequence of sequences are no\"\n                \" longer supported; use a binary array or sparse\"\n                \" matrix instead - the MultiLabelBinarizer\"\n                \" transformer can convert to this format.\"\n            )\n    except IndexError:\n        pass\n\n    # Invalid inputs\n    if y.ndim not in (1, 2):\n        # Number of dimension greater than 2: [[[1, 2]]]\n        return _raise_or_return()\n    if not min(y.shape):\n        # Empty ndarray: []/[[]]\n        if y.ndim == 1:\n            # 1-D empty array: []\n            return \"binary\"  # []\n        # 2-D empty array: [[]]\n        return _raise_or_return()\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return _raise_or_return()\n\n    # Check if multioutput\n    if y.ndim == 2 and y.shape[1] > 1:\n        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n    else:\n        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n\n    # Check float and contains non-integer float values\n    if xp.isdtype(y.dtype, \"real floating\"):\n        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n        data = y.data if issparse(y) else y\n        integral_data = xp.astype(data, xp.int64)\n        # conversion back to the original float dtype of y is required to\n        # satisfy array-api-strict which does not allow a comparison between\n        # arrays having different dtypes.\n        if xp.any(data != xp.astype(integral_data, y.dtype)):\n            _assert_all_finite(data, input_name=input_name)\n            return \"continuous\" + suffix\n\n    # Check multiclass\n    if issparse(first_row_or_val):\n        first_row_or_val = first_row_or_val.data\n    if cached_unique(y).shape[0] > 2 or (y.ndim == 2 and len(first_row_or_val) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]"
}