{
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.logic.inference.satisfiable": "def satisfiable(expr, algorithm=None, all_models=False, minimal=False, use_lra_theory=False):\n    \"\"\"\n    Check satisfiability of a propositional sentence.\n    Returns a model when it succeeds.\n    Returns {true: true} for trivially true expressions.\n\n    On setting all_models to True, if given expr is satisfiable then\n    returns a generator of models. However, if expr is unsatisfiable\n    then returns a generator containing the single element False.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import A, B\n    >>> from sympy.logic.inference import satisfiable\n    >>> satisfiable(A & ~B)\n    {A: True, B: False}\n    >>> satisfiable(A & ~A)\n    False\n    >>> satisfiable(True)\n    {True: True}\n    >>> next(satisfiable(A & ~A, all_models=True))\n    False\n    >>> models = satisfiable((A >> B) & B, all_models=True)\n    >>> next(models)\n    {A: False, B: True}\n    >>> next(models)\n    {A: True, B: True}\n    >>> def use_models(models):\n    ...     for model in models:\n    ...         if model:\n    ...             # Do something with the model.\n    ...             print(model)\n    ...         else:\n    ...             # Given expr is unsatisfiable.\n    ...             print(\"UNSAT\")\n    >>> use_models(satisfiable(A >> ~A, all_models=True))\n    {A: False}\n    >>> use_models(satisfiable(A ^ A, all_models=True))\n    UNSAT\n\n    \"\"\"\n    if use_lra_theory:\n        if algorithm is not None and algorithm != \"dpll2\":\n            raise ValueError(f\"Currently only dpll2 can handle using lra theory. {algorithm} is not handled.\")\n        algorithm = \"dpll2\"\n\n    if algorithm is None or algorithm == \"pycosat\":\n        pycosat = import_module('pycosat')\n        if pycosat is not None:\n            algorithm = \"pycosat\"\n        else:\n            if algorithm == \"pycosat\":\n                raise ImportError(\"pycosat module is not present\")\n            # Silently fall back to dpll2 if pycosat\n            # is not installed\n            algorithm = \"dpll2\"\n\n    if algorithm==\"minisat22\":\n        pysat = import_module('pysat')\n        if pysat is None:\n            algorithm = \"dpll2\"\n\n    if algorithm==\"z3\":\n        z3 = import_module('z3')\n        if z3 is None:\n            algorithm = \"dpll2\"\n\n    if algorithm == \"dpll\":\n        from sympy.logic.algorithms.dpll import dpll_satisfiable\n        return dpll_satisfiable(expr)\n    elif algorithm == \"dpll2\":\n        from sympy.logic.algorithms.dpll2 import dpll_satisfiable\n        return dpll_satisfiable(expr, all_models, use_lra_theory=use_lra_theory)\n    elif algorithm == \"pycosat\":\n        from sympy.logic.algorithms.pycosat_wrapper import pycosat_satisfiable\n        return pycosat_satisfiable(expr, all_models)\n    elif algorithm == \"minisat22\":\n        from sympy.logic.algorithms.minisat22_wrapper import minisat22_satisfiable\n        return minisat22_satisfiable(expr, all_models, minimal)\n    elif algorithm == \"z3\":\n        from sympy.logic.algorithms.z3_wrapper import z3_satisfiable\n        return z3_satisfiable(expr, all_models)\n\n    raise NotImplementedError"
}