{
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.sorting.default_sort_key": "def default_sort_key(item, order=None):\n    \"\"\"Return a key that can be used for sorting.\n\n    The key has the structure:\n\n    (class_key, (len(args), args), exponent.sort_key(), coefficient)\n\n    This key is supplied by the sort_key routine of Basic objects when\n    ``item`` is a Basic object or an object (other than a string) that\n    sympifies to a Basic object. Otherwise, this function produces the\n    key.\n\n    The ``order`` argument is passed along to the sort_key routine and is\n    used to determine how the terms *within* an expression are ordered.\n    (See examples below) ``order`` options are: 'lex', 'grlex', 'grevlex',\n    and reversed values of the same (e.g. 'rev-lex'). The default order\n    value is None (which translates to 'lex').\n\n    Examples\n    ========\n\n    >>> from sympy import S, I, default_sort_key, sin, cos, sqrt\n    >>> from sympy.core.function import UndefinedFunction\n    >>> from sympy.abc import x\n\n    The following are equivalent ways of getting the key for an object:\n\n    >>> x.sort_key() == default_sort_key(x)\n    True\n\n    Here are some examples of the key that is produced:\n\n    >>> default_sort_key(UndefinedFunction('f'))\n    ((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),\n        (0, ()), (), 1), 1)\n    >>> default_sort_key('1')\n    ((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)\n    >>> default_sort_key(S.One)\n    ((1, 0, 'Number'), (0, ()), (), 1)\n    >>> default_sort_key(2)\n    ((1, 0, 'Number'), (0, ()), (), 2)\n\n    While sort_key is a method only defined for SymPy objects,\n    default_sort_key will accept anything as an argument so it is\n    more robust as a sorting key. For the following, using key=\n    lambda i: i.sort_key() would fail because 2 does not have a sort_key\n    method; that's why default_sort_key is used. Note, that it also\n    handles sympification of non-string items likes ints:\n\n    >>> a = [2, I, -I]\n    >>> sorted(a, key=default_sort_key)\n    [2, -I, I]\n\n    The returned key can be used anywhere that a key can be specified for\n    a function, e.g. sort, min, max, etc...:\n\n    >>> a.sort(key=default_sort_key); a[0]\n    2\n    >>> min(a, key=default_sort_key)\n    2\n\n    Notes\n    =====\n\n    The key returned is useful for getting items into a canonical order\n    that will be the same across platforms. It is not directly useful for\n    sorting lists of expressions:\n\n    >>> a, b = x, 1/x\n\n    Since ``a`` has only 1 term, its value of sort_key is unaffected by\n    ``order``:\n\n    >>> a.sort_key() == a.sort_key('rev-lex')\n    True\n\n    If ``a`` and ``b`` are combined then the key will differ because there\n    are terms that can be ordered:\n\n    >>> eq = a + b\n    >>> eq.sort_key() == eq.sort_key('rev-lex')\n    False\n    >>> eq.as_ordered_terms()\n    [x, 1/x]\n    >>> eq.as_ordered_terms('rev-lex')\n    [1/x, x]\n\n    But since the keys for each of these terms are independent of ``order``'s\n    value, they do not sort differently when they appear separately in a list:\n\n    >>> sorted(eq.args, key=default_sort_key)\n    [1/x, x]\n    >>> sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))\n    [1/x, x]\n\n    The order of terms obtained when using these keys is the order that would\n    be obtained if those terms were *factors* in a product.\n\n    Although it is useful for quickly putting expressions in canonical order,\n    it does not sort expressions based on their complexity defined by the\n    number of operations, power of variables and others:\n\n    >>> sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)\n    [sin(x)*cos(x), sin(x)]\n    >>> sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)\n    [sqrt(x), x, x**2, x**3]\n\n    See Also\n    ========\n\n    ordered, sympy.core.expr.Expr.as_ordered_factors, sympy.core.expr.Expr.as_ordered_terms\n\n    \"\"\"\n    from .basic import Basic\n    from .singleton import S\n\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            # e.g. tuple, list\n            args = list(item)\n            unordered = False\n\n        args = [default_sort_key(arg, order=order) for arg in args]\n\n        if unordered:\n            # e.g. dict, set\n            args = sorted(args)\n\n        cls_index, args = 10, (len(args), tuple(args))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                # e.g. lambda x: x\n                pass\n            else:\n                if isinstance(item, Basic):\n                    # e.g int -> Integer\n                    return default_sort_key(item)\n                # e.g. UndefinedFunction\n\n        # e.g. str\n        cls_index, args = 0, (1, (str(item),))\n\n    return (cls_index, 0, item.__class__.__name__\n            ), args, S.One.sort_key(), S.One",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.printing.pretty.pretty._print_seq": "def _print_seq(self, seq, left=None, right=None, delimiter=', ',\n        parenthesize=lambda x: False, ifascii_nougly=True):\n\n    pforms = []\n    for item in seq:\n        pform = self._print(item)\n        if parenthesize(item):\n            pform = prettyForm(*pform.parens())\n        if pforms:\n            pforms.append(delimiter)\n        pforms.append(pform)\n\n    if not pforms:\n        s = stringPict('')\n    else:\n        s = prettyForm(*stringPict.next(*pforms))\n\n    s = prettyForm(*s.parens(left, right, ifascii_nougly=ifascii_nougly))\n    return s",
    "sympy.sympy.printing.pretty.stringpict.parens": "def parens(self, left='(', right=')', ifascii_nougly=False):\n    \"\"\"Put parentheses around self.\n    Returns string, baseline arguments for stringPict.\n\n    left or right can be None or empty string which means 'no paren from\n    that side'\n    \"\"\"\n    h = self.height()\n    b = self.baseline\n\n    # XXX this is a hack -- ascii parens are ugly!\n    if ifascii_nougly and not pretty_use_unicode():\n        h = 1\n        b = 0\n\n    res = self\n\n    if left:\n        lparen = stringPict(vobj(left, h), baseline=b)\n        res = stringPict(*lparen.right(self))\n    if right:\n        rparen = stringPict(vobj(right, h), baseline=b)\n        res = stringPict(*res.right(rparen))\n\n    return ('\\n'.join(res.picture), res.baseline)",
    "sympy.sympy.printing.pretty.stringpict.__init__": "def __init__(self, s, baseline=0, binding=0, unicode=None):\n    \"\"\"Initialize from stringPict and binding power.\"\"\"\n    stringPict.__init__(self, s, baseline)\n    self.binding = binding\n    if unicode is not None:\n        sympy_deprecation_warning(\n            \"\"\"\n            The unicode argument to prettyForm is deprecated. Only the s\n            argument (the first positional argument) should be passed.\n            \"\"\",\n            deprecated_since_version=\"1.7\",\n            active_deprecations_target=\"deprecated-pretty-printing-functions\")\n    self._unicode = unicode or s"
}