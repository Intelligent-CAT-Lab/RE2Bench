{
    "sympy.sympy.assumptions.assume.function": "@property\ndef function(self):\n    \"\"\"\n    Return the predicate.\n    \"\"\"\n    # Will be changed to self.args[0] after args overriding is removed\n    return self._args[0]",
    "sympy.sympy.assumptions.assume.arguments": "@property\ndef arguments(self):\n    \"\"\"\n    Return the arguments which are applied to the predicate.\n    \"\"\"\n    # Will be changed to self.args[1:] after args overriding is removed\n    return self._args[1:]",
    "sympy.sympy.assumptions.relation.binrel.reversed": "@property\ndef reversed(self):\n    \"\"\"\n    Try to return the relationship with sides reversed.\n    \"\"\"\n    revfunc = self.function.reversed\n    if revfunc is None:\n        return self\n    return revfunc(self.rhs, self.lhs)",
    "sympy.sympy.assumptions.relation.binrel.negated": "@property\ndef negated(self):\n    neg_rel = self.function.negated\n    if neg_rel is None:\n        return Not(self, evaluate=False)\n    return neg_rel(*self.arguments)",
    "sympy.sympy.assumptions.relation.binrel.<genexpr>": "args = tuple(a.simplify() for a in self.arguments)\n",
    "sympy.sympy.assumptions.relation.equality.eval": "def eval(self, args, assumptions=True):\n    if assumptions == True:\n        # default assumptions for is_eq is None\n        assumptions = None\n    return is_eq(*args, assumptions)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.logic.boolalg.conjuncts": "def conjuncts(expr):\n    \"\"\"Return a list of the conjuncts in ``expr``.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import conjuncts\n    >>> from sympy.abc import A, B\n    >>> conjuncts(A & B)\n    frozenset({A, B})\n    >>> conjuncts(A | B)\n    frozenset({A | B})\n\n    \"\"\"\n    return And.make_args(expr)",
    "sympy.sympy.logic.boolalg.__hash__": "def __hash__(self):\n    return hash(True)",
    "sympy.sympy.utilities.decorator.accessor": "@wraps(propfunc)\ndef accessor(self):\n    val = getattr(self, attrname, sentinel)\n    if val is sentinel:\n        val = propfunc(self)\n        setattr(self, attrname, val)\n    return val"
}