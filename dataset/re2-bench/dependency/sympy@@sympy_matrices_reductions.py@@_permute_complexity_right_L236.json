{
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.matrixbase.permute": "def permute(self,\n        perm: list[int] | list[list[int]] | Permutation,\n        orientation: Literal['rows', 'cols'] = 'rows',\n        direction: Literal['forward', 'backward'] = 'forward',\n    ) -> Self:\n    r\"\"\"Permute the rows or columns of a matrix by the given list of\n    swaps.\n\n    Parameters\n    ==========\n\n    perm : Permutation, list, or list of lists\n        A representation for the permutation.\n\n        If it is ``Permutation``, it is used directly with some\n        resizing with respect to the matrix size.\n\n        If it is specified as list of lists,\n        (e.g., ``[[0, 1], [0, 2]]``), then the permutation is formed\n        from applying the product of cycles. The direction how the\n        cyclic product is applied is described in below.\n\n        If it is specified as a list, the list should represent\n        an array form of a permutation. (e.g., ``[1, 2, 0]``) which\n        would would form the swapping function\n        `0 \\mapsto 1, 1 \\mapsto 2, 2\\mapsto 0`.\n\n    orientation : 'rows', 'cols'\n        A flag to control whether to permute the rows or the columns\n\n    direction : 'forward', 'backward'\n        A flag to control whether to apply the permutations from\n        the start of the list first, or from the back of the list\n        first.\n\n        For example, if the permutation specification is\n        ``[[0, 1], [0, 2]]``,\n\n        If the flag is set to ``'forward'``, the cycle would be\n        formed as `0 \\mapsto 2, 2 \\mapsto 1, 1 \\mapsto 0`.\n\n        If the flag is set to ``'backward'``, the cycle would be\n        formed as `0 \\mapsto 1, 1 \\mapsto 2, 2 \\mapsto 0`.\n\n        If the argument ``perm`` is not in a form of list of lists,\n        this flag takes no effect.\n\n    Examples\n    ========\n\n    >>> from sympy import eye\n    >>> M = eye(3)\n    >>> M.permute([[0, 1], [0, 2]], orientation='rows', direction='forward')\n    Matrix([\n    [0, 0, 1],\n    [1, 0, 0],\n    [0, 1, 0]])\n\n    >>> from sympy import eye\n    >>> M = eye(3)\n    >>> M.permute([[0, 1], [0, 2]], orientation='rows', direction='backward')\n    Matrix([\n    [0, 1, 0],\n    [0, 0, 1],\n    [1, 0, 0]])\n\n    Notes\n    =====\n\n    If a bijective function\n    `\\sigma : \\mathbb{N}_0 \\rightarrow \\mathbb{N}_0` denotes the\n    permutation.\n\n    If the matrix `A` is the matrix to permute, represented as\n    a horizontal or a vertical stack of vectors:\n\n    .. math::\n        A =\n        \\begin{bmatrix}\n        a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1}\n        \\end{bmatrix} =\n        \\begin{bmatrix}\n        \\alpha_0 & \\alpha_1 & \\cdots & \\alpha_{n-1}\n        \\end{bmatrix}\n\n    If the matrix `B` is the result, the permutation of matrix rows\n    is defined as:\n\n    .. math::\n        B := \\begin{bmatrix}\n        a_{\\sigma(0)} \\\\ a_{\\sigma(1)} \\\\ \\vdots \\\\ a_{\\sigma(n-1)}\n        \\end{bmatrix}\n\n    And the permutation of matrix columns is defined as:\n\n    .. math::\n        B := \\begin{bmatrix}\n        \\alpha_{\\sigma(0)} & \\alpha_{\\sigma(1)} &\n        \\cdots & \\alpha_{\\sigma(n-1)}\n        \\end{bmatrix}\n    \"\"\"\n    from sympy.combinatorics import Permutation\n\n    # allow british variants and `columns`\n    if direction == 'forwards':\n        direction = 'forward'\n    if direction == 'backwards':\n        direction = 'backward'\n    if orientation == 'columns':\n        orientation = 'cols'\n\n    if direction not in ('forward', 'backward'):\n        raise TypeError(\"direction='{}' is an invalid kwarg. \"\n                        \"Try 'forward' or 'backward'\".format(direction))\n    if orientation not in ('rows', 'cols'):\n        raise TypeError(\"orientation='{}' is an invalid kwarg. \"\n                        \"Try 'rows' or 'cols'\".format(orientation))\n\n    if not isinstance(perm, (Permutation, Iterable)):\n        raise ValueError(\n            \"{} must be a list, a list of lists, \"\n            \"or a SymPy permutation object.\".format(perm))\n\n    # ensure all swaps are in range\n    max_index = self.rows if orientation == 'rows' else self.cols\n    if not all(0 <= t <= max_index for t in flatten(list(perm))):\n        raise IndexError(\"`swap` indices out of range.\")\n\n    if perm and not isinstance(perm, Permutation) and \\\n        isinstance(perm[0], Iterable):\n        if direction == 'forward':\n            perm = list(reversed(perm)) # type: ignore\n        perm = Permutation(perm, size=max_index+1)\n    else:\n        perm = Permutation(perm, size=max_index+1)\n\n    if orientation == 'rows':\n        return self._eval_permute_rows(perm)\n    if orientation == 'cols':\n        return self._eval_permute_cols(perm)",
    "sympy.sympy.matrices.reductions.<listcomp>": "perm    = [j for (i, j) in sorted(complex)]\n\n"
}