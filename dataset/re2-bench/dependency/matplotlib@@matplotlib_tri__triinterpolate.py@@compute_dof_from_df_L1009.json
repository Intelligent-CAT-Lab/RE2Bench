{
    "matplotlib.lib.matplotlib.tri._triinterpolate.get_dof_vec": "@staticmethod\ndef get_dof_vec(tri_z, tri_dz, J):\n    \"\"\"\n    Compute the dof vector of a triangle, from the value of f, df and\n    of the local Jacobian at each node.\n\n    Parameters\n    ----------\n    tri_z : shape (3,) array\n        f nodal values.\n    tri_dz : shape (3, 2) array\n        df/dx, df/dy nodal values.\n    J\n        Jacobian matrix in local basis of apex 0.\n\n    Returns\n    -------\n    dof : shape (9,) array\n        For each apex ``iapex``::\n\n            dof[iapex*3+0] = f(Ai)\n            dof[iapex*3+1] = df(Ai).(AiAi+)\n            dof[iapex*3+2] = df(Ai).(AiAi-)\n    \"\"\"\n    npt = tri_z.shape[0]\n    dof = np.zeros([npt, 9], dtype=np.float64)\n    J1 = _ReducedHCT_Element.J0_to_J1 @ J\n    J2 = _ReducedHCT_Element.J0_to_J2 @ J\n\n    col0 = J @ np.expand_dims(tri_dz[:, 0, :], axis=2)\n    col1 = J1 @ np.expand_dims(tri_dz[:, 1, :], axis=2)\n    col2 = J2 @ np.expand_dims(tri_dz[:, 2, :], axis=2)\n\n    dfdksi = _to_matrix_vectorized([\n        [col0[:, 0, 0], col1[:, 0, 0], col2[:, 0, 0]],\n        [col0[:, 1, 0], col1[:, 1, 0], col2[:, 1, 0]]])\n    dof[:, 0:7:3] = tri_z\n    dof[:, 1:8:3] = dfdksi[:, 0]\n    dof[:, 2:9:3] = dfdksi[:, 1]\n    return dof",
    "matplotlib.lib.matplotlib.tri._triinterpolate._get_jacobian": "@staticmethod\ndef _get_jacobian(tris_pts):\n    \"\"\"\n    Fast (vectorized) function to compute triangle jacobian matrix.\n\n    Parameters\n    ----------\n    tris_pts : array like of dim 3 (shape: (nx, 3, 2))\n        Coordinates of the containing triangles apexes.\n\n    Returns\n    -------\n    array of dim 3 (shape (nx, 2, 2))\n        Barycentric coordinates of the points inside the containing\n        triangles.\n        J[itri, :, :] is the jacobian matrix at apex 0 of the triangle\n        itri, so that the following (matrix) relationship holds:\n           [dz/dksi] = [J] x [dz/dx]\n        with x: global coordinates\n             ksi: element parametric coordinates in triangle first apex\n             local basis.\n    \"\"\"\n    a = np.array(tris_pts[:, 1, :] - tris_pts[:, 0, :])\n    b = np.array(tris_pts[:, 2, :] - tris_pts[:, 0, :])\n    J = _to_matrix_vectorized([[a[:, 0], a[:, 1]],\n                               [b[:, 0], b[:, 1]]])\n    return J"
}