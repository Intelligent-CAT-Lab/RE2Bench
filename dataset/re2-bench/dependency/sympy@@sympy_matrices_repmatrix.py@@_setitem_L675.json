{
    "sympy.sympy.matrices.matrixbase._sympify": "@classmethod\ndef _sympify(cls, expr: SExpr | Poly, /) -> Expr | Poly:\n    if isinstance(expr, Poly):\n        return expr\n    return sympify(expr)",
    "sympy.sympy.matrices.matrixbase.key2ij": "def key2ij(self, key: int | slice | tuple[int | slice, int | slice]) -> tuple[int, int]:\n    \"\"\"Converts key into canonical form, converting integers or indexable\n    items into valid integers for ``self``'s range or returning slices\n    unchanged.\n\n    See Also\n    ========\n\n    key2bounds\n    \"\"\"\n    if is_sequence(key):\n        if not len(key) == 2: # type: ignore\n            raise TypeError('key must be a sequence of length 2')\n        return [a2idx(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)] # type: ignore\n    elif isinstance(key, slice): # type: ignore\n        return key.indices(len(self))[:2]\n    else:\n        return divmod(a2idx(key, len(self)), self.cols)",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.repmatrix.copyin_list": "def copyin_list(self, key, value):\n    \"\"\"Copy in elements from a list.\n\n    Parameters\n    ==========\n\n    key : slice\n        The section of this matrix to replace.\n    value : iterable\n        The iterable to copy values from.\n\n    Examples\n    ========\n\n    >>> from sympy import eye\n    >>> I = eye(3)\n    >>> I[:2, 0] = [1, 2] # col\n    >>> I\n    Matrix([\n    [1, 0, 0],\n    [2, 1, 0],\n    [0, 0, 1]])\n    >>> I[1, :2] = [[3, 4]]\n    >>> I\n    Matrix([\n    [1, 0, 0],\n    [3, 4, 0],\n    [0, 0, 1]])\n\n    See Also\n    ========\n\n    copyin_matrix\n    \"\"\"\n    if not is_sequence(value):\n        raise TypeError(\"`value` must be an ordered iterable, not %s.\" % type(value))\n    return self.copyin_matrix(key, type(self)(value))",
    "sympy.sympy.matrices.repmatrix.copyin_matrix": "def copyin_matrix(self, key, value):\n    \"\"\"Copy in values from a matrix into the given bounds.\n\n    Parameters\n    ==========\n\n    key : slice\n        The section of this matrix to replace.\n    value : Matrix\n        The matrix to copy values from.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, eye\n    >>> M = Matrix([[0, 1], [2, 3], [4, 5]])\n    >>> I = eye(3)\n    >>> I[:3, :2] = M\n    >>> I\n    Matrix([\n    [0, 1, 0],\n    [2, 3, 0],\n    [4, 5, 1]])\n    >>> I[0, 1] = M\n    >>> I\n    Matrix([\n    [0, 0, 1],\n    [2, 2, 3],\n    [4, 4, 5]])\n\n    See Also\n    ========\n\n    copyin_list\n    \"\"\"\n    rlo, rhi, clo, chi = self.key2bounds(key)\n    shape = value.shape\n    dr, dc = rhi - rlo, chi - clo\n    if shape != (dr, dc):\n        raise ShapeError(filldedent(\"The Matrix `value` doesn't have the \"\n                                    \"same dimensions \"\n                                    \"as the in sub-Matrix given by `key`.\"))\n\n    for i in range(value.rows):\n        for j in range(value.cols):\n            self[i + rlo, j + clo] = value[i, j]",
    "sympy.sympy.matrices.sparse._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.polys.solvers.<lambda>": "_sympify = staticmethod(lambda x, *args, **kwargs: x) # type: ignore\n\n",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))"
}