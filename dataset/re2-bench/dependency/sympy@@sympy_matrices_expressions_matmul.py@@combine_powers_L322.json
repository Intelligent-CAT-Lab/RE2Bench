{
    "sympy.sympy.codegen.ast.__eq__": "def __eq__(self, other):\n    if not isinstance(other, self.__class__):\n        return False\n    for attr in self._fields:\n        if getattr(self, attr) != getattr(other, attr):\n            return False\n    return True",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.matrices.expressions.inverse.arg": "@property\ndef arg(self):\n    return self.args[0]",
    "sympy.sympy.matrices.expressions.inverse.shape": "@property\ndef shape(self):\n    return self.arg.shape",
    "sympy.sympy.matrices.expressions.matexpr.is_square": "@property\ndef is_square(self) -> bool | None:\n    rows, cols = self.shape\n    if isinstance(rows, Integer) and isinstance(cols, Integer):\n        return rows == cols\n    if rows == cols:\n        return True\n    return None",
    "sympy.sympy.matrices.expressions.matexpr.inverse": "def inverse(self):\n    if self.is_square is False:\n        raise NonSquareMatrixError('Inverse of non-square matrix')\n    return self._eval_inverse()",
    "sympy.sympy.matrices.expressions.matmul.as_coeff_matrices": "def as_coeff_matrices(self):\n    scalars = [x for x in self.args if not x.is_Matrix]\n    matrices = [x for x in self.args if x.is_Matrix]\n    coeff = Mul(*scalars)\n    if coeff.is_commutative is False:\n        raise NotImplementedError(\"noncommutative scalars in MatMul are not supported.\")\n\n    return coeff, matrices",
    "sympy.sympy.matrices.expressions.matmul.newmul": "def newmul(*args):\n    if args[0] == 1:\n        args = args[1:]\n    return new(MatMul, *args)",
    "sympy.sympy.matrices.expressions.matpow.__new__": "def __new__(cls, base, exp, evaluate=False, **options) -> MatrixExpr: # type: ignore\n    base = _sympify(base)\n    if not base.is_Matrix:\n        raise TypeError(\"MatPow base should be a matrix\")\n\n    if base.is_square is False:\n        raise NonSquareMatrixError(\"Power of non-square matrix %s\" % base)\n\n    exp = _sympify(exp)\n    obj = super().__new__(cls, base, exp)\n\n    if evaluate:\n        obj = obj.doit(deep=False)\n\n    return obj",
    "sympy.sympy.matrices.expressions.matpow.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        base, exp = (arg.doit(**hints) for arg in self.args)\n    else:\n        base, exp = self.args\n\n    # combine all powers, e.g. (A ** 2) ** 3 -> A ** 6\n    while isinstance(base, MatPow):\n        exp *= base.args[1]\n        base = base.args[0]\n\n    if isinstance(base, MatrixBase):\n        # Delegate\n        return base ** exp\n\n    # Handle simple cases so that _eval_power() in MatrixExpr sub-classes can ignore them\n    if exp == S.One:\n        return base\n    if exp == S.Zero:\n        return Identity(base.rows)\n    if exp == S.NegativeOne:\n        from sympy.matrices.expressions import Inverse\n        return Inverse(base).doit(**hints)\n\n    eval_power = getattr(base, '_eval_power', None)\n    if eval_power is not None:\n        return eval_power(exp)\n\n    return MatPow(base, exp)",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, n):\n    n = _sympify(n)\n    cls._check_dim(n)\n\n    return super().__new__(cls, n)",
    "sympy.sympy.matrices.expressions.special.is_square": "@property\ndef is_square(self):\n    return True",
    "sympy.sympy.matrices.matrixbase.is_square": "@property\ndef is_square(self) -> bool:\n    \"\"\"Checks if a matrix is square.\n\n    A matrix is square if the number of rows equals the number of columns.\n    The empty matrix is square by definition, since the number of rows and\n    the number of columns are both zero.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> a = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> c = Matrix([])\n    >>> a.is_square\n    False\n    >>> b.is_square\n    True\n    >>> c.is_square\n    True\n    \"\"\"\n    return self.rows == self.cols",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)"
}