{
    "sympy.sympy.core.basic._hashable_content": "def _hashable_content(self) -> tuple[Hashable, ...]:\n    \"\"\"Return a tuple of information about self that can be used to\n    compute the hash. If a class defines additional attributes,\n    like ``name`` in Symbol, then this method should be updated\n    accordingly to return such relevant attributes.\n\n    Defining more than _hashable_content is necessary if __eq__ has\n    been defined by a class. See note about this in Basic.__eq__.\"\"\"\n    return self._args",
    "sympy.sympy.core.basic.compare": "def compare(self, other):\n    \"\"\"\n    Return -1, 0, 1 if the object is less than, equal,\n    or greater than other in a canonical sense.\n    Non-Basic are always greater than Basic.\n    If both names of the classes being compared appear\n    in the `ordering_of_classes` then the ordering will\n    depend on the appearance of the names there.\n    If either does not appear in that list, then the\n    comparison is based on the class name.\n    If the names are the same then a comparison is made\n    on the length of the hashable content.\n    Items of the equal-lengthed contents are then\n    successively compared using the same rules. If there\n    is never a difference then 0 is returned.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> x.compare(y)\n    -1\n    >>> x.compare(x)\n    0\n    >>> y.compare(x)\n    1\n\n    \"\"\"\n    # all redefinitions of compare method should start with the\n    # following lines:\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = _cmp_name(n1, n2)\n    if c:\n        return c\n    #\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    len_st = len(st)\n    len_ot = len(ot)\n    c = (len_st > len_ot) - (len_st < len_ot)\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        elif isinstance(l, frozenset):\n            l = Basic(*l) if isinstance(l, frozenset) else l\n            r = Basic(*r) if isinstance(r, frozenset) else r\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    "sympy.sympy.core.basic._cmp_name": "def _cmp_name(x: type, y: type) -> int:\n    \"\"\"return -1, 0, 1 if the name of x is before that of y.\n    A string comparison is done if either name does not appear\n    in `ordering_of_classes`. This is the helper for\n    ``Basic.compare``\n\n    Examples\n    ========\n\n    >>> from sympy import cos, tan, sin\n    >>> from sympy.core import basic\n    >>> save = basic.ordering_of_classes\n    >>> basic.ordering_of_classes = ()\n    >>> basic._cmp_name(cos, tan)\n    -1\n    >>> basic.ordering_of_classes = [\"tan\", \"sin\", \"cos\"]\n    >>> basic._cmp_name(cos, tan)\n    1\n    >>> basic._cmp_name(sin, cos)\n    -1\n    >>> basic.ordering_of_classes = save\n\n    \"\"\"\n    n1 = x.__name__\n    n2 = y.__name__\n    if n1 == n2:\n        return 0\n\n    # If the other object is not a Basic subclass, then we are not equal to it.\n    if not issubclass(y, Basic):\n        return -1\n\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    "sympy.sympy.core.expr._hashable_content": "def _hashable_content(self) -> tuple[Basic, ...] | tuple[Hashable, ...]:\n    \"\"\"Return a tuple of information about self that can be used to\n    compute the hash. If a class defines additional attributes,\n    like ``name`` in Symbol, then this method should be updated\n    accordingly to return such relevant attributes.\n    Defining more than _hashable_content is necessary if __eq__ has\n    been defined by a class. See note about this in Basic.__eq__.\"\"\"\n    return self._args",
    "sympy.sympy.core.function._hashable_content": "def _hashable_content(self):\n    return (self._expr.xreplace(self.canonical_variables),\n        ) + tuple(ordered([(v, p) for v, p in\n        zip(self.variables, self.point) if not self.expr.has(v)]))",
    "sympy.sympy.core.numbers._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    "sympy.sympy.core.symbol._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + (self.exclude, self.properties)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.diffgeom.diffgeom._hashable_content": "def _hashable_content(self):\n    return (\n        self.coord_sys, self.index\n    ) + tuple(sorted(self.assumptions0.items()))",
    "sympy.sympy.physics.quantum.trace._hashable_content": "def _hashable_content(self):\n    if isinstance(self.args[0], Mul):\n        args = _cycle_permute(_rearrange_args(self.args[0].args))\n    else:\n        args = [self.args[0]]\n\n    return tuple(args) + (self.args[1], )",
    "sympy.sympy.polys.polyclasses.__lt__": "def __lt__(f, g: Self) -> bool:\n    F, G = f.unify_DMP(g)\n    return F.to_list() < G.to_list()",
    "sympy.sympy.polys.polyclasses.__gt__": "def __gt__(f, g: Self) -> bool:\n    F, G = f.unify_DMP(g)\n    return F.to_list() > G.to_list()",
    "sympy.sympy.polys.polytools._hashable_content": "def _hashable_content(self):\n    \"\"\"Allow SymPy to hash Poly instances. \"\"\"\n    return (self.rep,)",
    "sympy.sympy.polys.rootoftools._hashable_content": "def _hashable_content(self):\n    return (self.poly, self.index)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.tensor.indexed._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + tuple(sorted(self.assumptions0.items()))",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}