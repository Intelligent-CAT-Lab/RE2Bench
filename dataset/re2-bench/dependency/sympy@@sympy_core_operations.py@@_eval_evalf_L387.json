{
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.evalf._evalf": "def _evalf(self, prec: int) -> Expr:\n    \"\"\"Helper for evalf. Does the same thing but takes binary precision\"\"\"\n    r = self._eval_evalf(prec)\n    if r is None:\n        r = self # type: ignore\n    return r # type: ignore",
    "sympy.sympy.core.evalf._eval_evalf": "def _eval_evalf(self, prec: int) -> Expr | None:\n    return None",
    "sympy.sympy.core.expr.as_independent": "def as_independent(\n    self,\n    *deps: Basic | type[Basic],\n    as_Add: bool | None = None,\n    strict: bool = True,\n) -> tuple[Expr, Expr]:\n    \"\"\"\n    A mostly naive separation of a Mul or Add into arguments that are not\n    are dependent on deps. To obtain as complete a separation of variables\n    as possible, use a separation method first, e.g.:\n\n    * ``separatevars()`` to change Mul, Add and Pow (including exp) into Mul\n    * ``.expand(mul=True)`` to change Add or Mul into Add\n    * ``.expand(log=True)`` to change log expr into an Add\n\n    The only non-naive thing that is done here is to respect noncommutative\n    ordering of variables and to always return ``(0, 0)`` for ``self`` of\n    zero regardless of hints.\n\n    For nonzero ``self``, the returned tuple ``(i, d)`` has the following\n    interpretation:\n\n    * ``i`` has no variable that appears in deps\n    * ``d`` will either have terms that contain variables that are in deps,\n      or be equal to ``0`` (when ``self`` is an ``Add``) or ``1`` (when\n      ``self`` is a ``Mul``)\n    * if ``self`` is an Add then ``self = i + d``\n    * if ``self`` is a Mul then ``self = i*d``\n    * otherwise ``(self, S.One)`` or ``(S.One, self)`` is returned.\n\n    To force the expression to be treated as an Add, use the argument\n    ``as_Add=True``.\n\n    The ``strict`` argument is deprecated and has no effect.\n\n    Examples\n    ========\n\n    -- ``self`` is an Add\n\n    >>> from sympy import sin, cos, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> (x + x*y).as_independent(x)\n    (0, x*y + x)\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x)\n    (y + z, 2*x*sin(x) + x)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n    (z, 2*x*sin(x) + x + y)\n\n    -- ``self`` is a Mul\n\n    >>> (x*sin(x)*cos(y)).as_independent(x)\n    (cos(y), x*sin(x))\n\n    Non-commutative terms cannot always be separated out when ``self`` is a\n    Mul\n\n    >>> from sympy import symbols\n    >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n    >>> (n1 + n1*n2).as_independent(n2)\n    (n1, n1*n2)\n    >>> (n2*n1 + n1*n2).as_independent(n2)\n    (0, n1*n2 + n2*n1)\n    >>> (n1*n2*n3).as_independent(n1)\n    (1, n1*n2*n3)\n    >>> (n1*n2*n3).as_independent(n2)\n    (n1, n2*n3)\n    >>> ((x-n1)*(x-y)).as_independent(x)\n    (1, (x - y)*(x - n1))\n\n    -- ``self`` is anything else:\n\n    >>> (sin(x)).as_independent(x)\n    (1, sin(x))\n    >>> (sin(x)).as_independent(y)\n    (sin(x), 1)\n    >>> exp(x+y).as_independent(x)\n    (1, exp(x + y))\n\n    -- force ``self`` to be treated as an Add:\n\n    >>> (3*x).as_independent(x, as_Add=True)\n    (0, 3*x)\n\n    -- force ``self`` to be treated as a Mul:\n\n    >>> (3+x).as_independent(x, as_Add=False)\n    (1, x + 3)\n    >>> (-3+x).as_independent(x, as_Add=False)\n    (1, x - 3)\n\n    Note how the below differs from the above in making the\n    constant on the dep term positive.\n\n    >>> (y*(-3+x)).as_independent(x)\n    (y, x - 3)\n\n    -- use ``.as_independent()`` for true independence testing instead of\n       ``.has()``. The former considers only symbols in the free symbols\n       while the latter considers all symbols\n\n    >>> from sympy import Integral\n    >>> I = Integral(x, (x, 1, 2))\n    >>> I.has(x)\n    True\n    >>> x in I.free_symbols\n    False\n    >>> I.as_independent(x) == (I, 1)\n    True\n    >>> (I + x).as_independent(x) == (I, x)\n    True\n\n    Note: when trying to get independent terms, a separation method might\n    need to be used first. In this case, it is important to keep track of\n    what you send to this routine so you know how to interpret the returned\n    values\n\n    >>> from sympy import separatevars, log\n    >>> separatevars(exp(x+y)).as_independent(x)\n    (exp(y), exp(x))\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> separatevars(x + x*y).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n    (x, x*y)\n    >>> a, b=symbols('a b', positive=True)\n    >>> (log(a*b).expand(log=True)).as_independent(b)\n    (log(a), log(b))\n\n    See Also\n    ========\n\n    separatevars\n    expand_log\n    sympy.core.add.Add.as_two_terms\n    sympy.core.mul.Mul.as_two_terms\n    as_coeff_mul\n    \"\"\"\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n\n    if self is S.Zero:\n        return (self, self)\n\n    if as_Add is None:\n        as_Add = self.is_Add\n\n    syms, other = _sift_true_false(deps, lambda d: isinstance(d, Symbol))\n    syms_set = set(syms)\n\n    if other:\n        def has(e):\n            return e.has_xfree(syms_set) or e.has(*other)\n    else:\n        def has(e):\n            return e.has_xfree(syms_set)\n\n    if as_Add:\n        if not self.is_Add:\n            if has(self):\n                return (S.Zero, self)\n            else:\n                return (self, S.Zero)\n\n        depend, indep = _sift_true_false(self.args, has)\n        return (self.func(*indep), _unevaluated_Add(*depend))\n\n    else:\n        if not self.is_Mul:\n            if has(self):\n                return (S.One, self)\n            else:\n                return (self, S.One)\n\n        args, nc = self.args_cnc()\n        depend, indep = _sift_true_false(args, has)\n\n        # handle noncommutative by stopping at first dependent term\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n\n        return self.func(*indep), _unevaluated_Mul(*depend)",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.function._eval_evalf": "def _eval_evalf(self, prec):\n\n    def _get_mpmath_func(fname):\n        \"\"\"Lookup mpmath function based on name\"\"\"\n        if isinstance(self, AppliedUndef):\n            # Shouldn't lookup in mpmath but might have ._imp_\n            return None\n\n        if not hasattr(mpmath, fname):\n            fname = MPMATH_TRANSLATIONS.get(fname, None)\n            if fname is None:\n                return None\n        return getattr(mpmath, fname)\n\n    _eval_mpmath = getattr(self, '_eval_mpmath', None)\n    if _eval_mpmath is None:\n        func = _get_mpmath_func(self.func.__name__)\n        args = self.args\n    else:\n        func, args = _eval_mpmath()\n\n    # Fall-back evaluation\n    if func is None:\n        imp = getattr(self, '_imp_', None)\n        if imp is None:\n            return None\n        try:\n            return Float(imp(*[i.evalf(prec) for i in self.args]), prec)\n        except (TypeError, ValueError):\n            return None\n\n    # Convert all args to mpf or mpc\n    # Convert the arguments to *higher* precision than requested for the\n    # final result.\n    # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should\n    #     we be more intelligent about it?\n    try:\n        args = [arg._to_mpmath(prec + 5) for arg in args]\n        def bad(m):\n            from mpmath import mpf, mpc\n            # the precision of an mpf value is the last element\n            # if that is 1 (and m[1] is not 1 which would indicate a\n            # power of 2), then the eval failed; so check that none of\n            # the arguments failed to compute to a finite precision.\n            # Note: An mpc value has two parts, the re and imag tuple;\n            # check each of those parts, too. Anything else is allowed to\n            # pass\n            if isinstance(m, mpf):\n                m = m._mpf_\n                return m[1] !=1 and m[-1] == 1\n            elif isinstance(m, mpc):\n                m, n = m._mpc_\n                return m[1] !=1 and m[-1] == 1 and \\\n                    n[1] !=1 and n[-1] == 1\n            else:\n                return False\n        if any(bad(a) for a in args):\n            raise ValueError  # one or more args failed to compute with significance\n    except ValueError:\n        return\n\n    with mpmath.workprec(prec):\n        v = func(*args)\n\n    return Expr._from_mpmath(v, prec)",
    "sympy.sympy.core.mul._eval_evalf": "def _eval_evalf(self, prec):\n    c, m = self.as_coeff_Mul()\n    if c is S.NegativeOne:\n        if m.is_Mul:\n            rv = -AssocOp._eval_evalf(m, prec)\n        else:\n            mnew = m._eval_evalf(prec)\n            if mnew is not None:\n                m = mnew\n            rv = -m\n    else:\n        rv = AssocOp._eval_evalf(self, prec)\n    if rv.is_number:\n        return rv.expand()\n    return rv",
    "sympy.sympy.core.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    return self",
    "sympy.sympy.core.operations._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\"\n    Evaluate the parts of self that are numbers; if the whole thing\n    was a number with no functions it would have been evaluated, but\n    it wasn't so we must judiciously extract the numbers and reconstruct\n    the object. This is *not* simply replacing numbers with evaluated\n    numbers. Numbers should be handled in the largest pure-number\n    expression as possible. So the code below separates ``self`` into\n    number and non-number parts and evaluates the number parts and\n    walks the args of the non-number part recursively (doing the same\n    thing).\n    \"\"\"\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        # if x is an AssocOp Function then the _evalf below will\n        # call _eval_evalf (here) so we must break the recursion\n        if not (tail is self.identity or\n                isinstance(x, AssocOp) and x.is_Function or\n                x is self.identity and isinstance(tail, AssocOp)):\n            # here, we have a number so we just call to _evalf with prec;\n            # prec is not the same as n, it is the binary precision so\n            # that's why we don't call to evalf.\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                # here we call to _eval_evalf since we don't know what we\n                # are dealing with and all other _eval_evalf routines should\n                # be doing the same thing (i.e. taking binary prec and\n                # finding the evalf-able args)\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n\n    # this is the same as above, but there were no pure-number args to\n    # deal with\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power._eval_evalf": "def _eval_evalf(self, prec):\n    base, exp = self.as_base_exp()\n    if base == S.Exp1:\n        # Use mpmath function associated to class \"exp\":\n        from sympy.functions.elementary.exponential import exp as exp_function\n        return exp_function(self.exp, evaluate=False)._eval_evalf(prec)\n    base = base._evalf(prec)\n    if not exp.is_Integer:\n        exp = exp._evalf(prec)\n    if exp.is_negative and base.is_number and base.is_extended_real is False:\n        base = base.conjugate() / (base * base.conjugate())._evalf(prec)\n        exp = -exp\n        return self.func(base, exp).expand()\n    return self.func(base, exp)",
    "sympy.sympy.functions.combinatorial.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    if not all(x.is_number for x in self.args):\n        return\n    n = self.args[0]._to_mpmath(prec)\n    x = (self.args[1] if len(self.args) > 1 else S.One)._to_mpmath(prec)\n    with workprec(prec):\n        if n == 0:\n            res = mp.mpf(1)\n        elif n == 1:\n            res = x - mp.mpf(0.5)\n        elif mp.isint(n) and n >= 0:\n            res = mp.bernoulli(n) if x == 1 else mp.bernpoly(n, x)\n        else:\n            res = -n * mp.zeta(1-n, x)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.elementary.complexes._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    return self.args[0]._eval_evalf(prec)",
    "sympy.sympy.functions.elementary.exponential._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    i = im(self.args[0])\n    try:\n        bad = (i <= -pi or i > pi)\n    except TypeError:\n        bad = True\n    if bad:\n        return self  # cannot evalf for this argument\n    res = exp(self.args[0])._eval_evalf(prec)\n    if i > 0 and im(res) < 0:\n        # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi\n        return re(res)\n    return res",
    "sympy.sympy.functions.elementary.miscellaneous.__new__": "def __new__(cls, *args, **assumptions):\n    from sympy.core.parameters import global_parameters\n    evaluate = assumptions.pop('evaluate', global_parameters.evaluate)\n    args = (sympify(arg) for arg in args)\n\n    # first standard filter, for cls.zero and cls.identity\n    # also reshape Max(a, Max(b, c)) to Max(a, b, c)\n\n    if evaluate:\n        try:\n            args = frozenset(cls._new_args_filter(args))\n        except ShortCircuit:\n            return cls.zero\n        # remove redundant args that are easily identified\n        args = cls._collapse_arguments(args, **assumptions)\n        # find local zeros\n        args = cls._find_localzeros(args, **assumptions)\n    args = frozenset(args)\n\n    if not args:\n        return cls.identity\n\n    if len(args) == 1:\n        return list(args).pop()\n\n    # base creation\n    obj = Expr.__new__(cls, *ordered(args), **assumptions)\n    obj._argset = args\n    return obj",
    "sympy.sympy.functions.elementary.piecewise._eval_evalf": "def _eval_evalf(self, prec):\n    return self.func(*[(e._evalf(prec), c) for e, c in self.args])",
    "sympy.sympy.functions.special.bessel._eval_evalf": "def _eval_evalf(self, prec):\n    if self.order.is_Integer:\n        return self.rewrite(besselj)._eval_evalf(prec)",
    "sympy.sympy.functions.special.error_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if (self.args[0]/polar_lift(-1)).is_positive:\n        return super()._eval_evalf(prec) + (I*pi)._eval_evalf(prec)\n    return super()._eval_evalf(prec)",
    "sympy.sympy.polys.rootoftools._eval_evalf": "def _eval_evalf(self, prec, **kwargs):\n    \"\"\"Evaluate this complex root to the given precision.\"\"\"\n    # all kwargs are ignored\n    return self.eval_rational(n=prec_to_dps(prec))._evalf(prec)"
}