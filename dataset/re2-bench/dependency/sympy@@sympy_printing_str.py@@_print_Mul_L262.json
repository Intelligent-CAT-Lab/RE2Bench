{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    \"\"\"Return list of ordered factors (if Mul) else [self].\"\"\"\n    return [self]",
    "sympy.sympy.core.expr.could_extract_minus_sign": "def could_extract_minus_sign(self) -> bool:\n    \"\"\"Return True if self has -1 as a leading factor or has\n    more literal negative signs than positive signs in a sum,\n    otherwise False.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> e = x - y\n    >>> {i.could_extract_minus_sign() for i in (e, -e)}\n    {False, True}\n\n    Though the ``y - x`` is considered like ``-(x - y)``, since it\n    is in a product without a leading factor of -1, the result is\n    false below:\n\n    >>> (x*(y - x)).could_extract_minus_sign()\n    False\n\n    To put something in canonical form wrt to sign, use `signsimp`:\n\n    >>> from sympy import signsimp\n    >>> signsimp(x*(y - x))\n    -x*(x - y)\n    >>> _.could_extract_minus_sign()\n    True\n    \"\"\"\n    return False",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.mul.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    \"\"\"Transform an expression into an ordered list of factors.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos\n    >>> from sympy.abc import x, y\n\n    >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n    [2, x, y, sin(x), cos(x)]\n\n    \"\"\"\n    cpart, ncpart = self.args_cnc()\n    cpart.sort(key=lambda expr: expr.sort_key(order=order))\n    return cpart + ncpart",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__neg__": "def __neg__(self):\n    return S.Infinity",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    "sympy.sympy.core.operations._from_args": "@classmethod\ndef _from_args(cls, args, is_commutative=None):\n    \"\"\"Create new instance with already-processed args.\n    If the args are not in canonical order, then a non-canonical\n    result will be returned, so use with caution. The order of\n    args may change if the sign of the args is changed.\"\"\"\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and(a.is_commutative for a in args)\n    obj.is_commutative = is_commutative\n    return obj",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.polys.rootoftools.is_commutative": "@property\ndef is_commutative(self):\n    return True",
    "sympy.sympy.printing.precedence.precedence": "def precedence(item):\n    \"\"\"Returns the precedence of a given object.\n\n    This is the precedence for StrPrinter.\n    \"\"\"\n    if hasattr(item, \"precedence\"):\n        return item.precedence\n    if not isinstance(item, type):\n        for i in type(item).mro():\n            n = i.__name__\n            if n in PRECEDENCE_FUNCTIONS:\n                return PRECEDENCE_FUNCTIONS[n](item)\n            elif n in PRECEDENCE_VALUES:\n                return PRECEDENCE_VALUES[n]\n    return PRECEDENCE[\"Atom\"]",
    "sympy.sympy.printing.printer.order": "@property\ndef order(self):\n    if 'order' in self._settings:\n        return self._settings['order']\n    else:\n        raise AttributeError(\"No order defined.\")",
    "sympy.sympy.printing.printer._print": "def _print(self, expr, **kwargs) -> str:\n    \"\"\"Internal dispatcher\n\n    Tries the following concepts to print an expression:\n        1. Let the object print itself if it knows how.\n        2. Take the best fitting method defined in the printer.\n        3. As fall-back use the emptyPrinter method for the printer.\n    \"\"\"\n    self._print_level += 1\n    try:\n        # If the printer defines a name for a printing method\n        # (Printer.printmethod) and the object knows for itself how it\n        # should be printed, use that method.\n        if self.printmethod and hasattr(expr, self.printmethod):\n            if not (isinstance(expr, type) and issubclass(expr, Basic)):\n                return getattr(expr, self.printmethod)(self, **kwargs)\n\n        # See if the class of expr is known, or if one of its super\n        # classes is known, and use that print function\n        # Exception: ignore the subclasses of Undefined, so that, e.g.,\n        # Function('gamma') does not get dispatched to _print_gamma\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        # Another exception: if someone subclasses a known function, e.g.,\n        # gamma, and changes the name, then ignore _print_gamma\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple(c for c in classes[:i] if \\\n                c.__name__ == classes[0].__name__ or \\\n                c.__name__.endswith(\"Base\")) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        # Unknown object, fall back to the emptyPrinter.\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    "sympy.sympy.printing.str.<genexpr>": "if args[0] is S.One or any(\n        isinstance(a, Number) or\n        a.is_Pow and all(ai.is_Integer for ai in a.args)\n        for a in args[1:]):\n    d, n = sift(args, lambda x:\n        isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0),\n        binary=True)\n    for i, di in enumerate(d):\n        if di.exp.is_Number:\n            e = -di.exp\n        else:\n            dargs = list(di.exp.args)\n            dargs[0] = -dargs[0]\n            e = Mul._from_args(dargs)\n        d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base\n\n    pre = []\n    # don't parenthesize first factor if negative\n    if n and not n[0].is_Add and n[0].could_extract_minus_sign():\n        pre = [self._print(n.pop(0))]\n\n    nfactors = pre + [self.parenthesize(a, prec, strict=False)\n        for a in n]\n    if not nfactors:\n        nfactors = ['1']\n\n    # don't parenthesize first of denominator unless singleton\n    if len(d) > 1 and d[0].could_extract_minus_sign():\n        pre = [self._print(d.pop(0))]\n    else:\n        pre = []\n    dfactors = pre + [self.parenthesize(a, prec, strict=False)\n        for a in d]\n\n    n = '*'.join(nfactors)\n    d = '*'.join(dfactors)\n    if len(dfactors) > 1:\n        return '%s/(%s)' % (n, d)\n    elif dfactors:\n        return '%s/%s' % (n, d)\n    return n\n\n",
    "sympy.sympy.printing.str.<listcomp>": "b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n\n# To parenthesize Pow with exp = -1 and having more than one Symbol\n",
    "sympy.sympy.printing.str.apow": "def apow(i):\n    b, e = i.as_base_exp()\n    eargs = list(Mul.make_args(e))\n    if eargs[0] is S.NegativeOne:\n        eargs = eargs[1:]\n    else:\n        eargs[0] = -eargs[0]\n    e = Mul._from_args(eargs)\n    if isinstance(i, Pow):\n        return i.func(b, e, evaluate=False)\n    return i.func(e, evaluate=False)",
    "sympy.sympy.stats.rv.is_commutative": "@property\ndef is_commutative(self):\n    return self.symbol.is_commutative",
    "sympy.sympy.utilities.iterables.sift": "def sift(seq, keyfunc, binary=False):\n    \"\"\"\n    Sift the sequence, ``seq`` according to ``keyfunc``.\n\n    Returns\n    =======\n\n    When ``binary`` is ``False`` (default), the output is a dictionary\n    where elements of ``seq`` are stored in a list keyed to the value\n    of keyfunc for that element. If ``binary`` is True then a tuple\n    with lists ``T`` and ``F`` are returned where ``T`` is a list\n    containing elements of seq for which ``keyfunc`` was ``True`` and\n    ``F`` containing those elements for which ``keyfunc`` was ``False``;\n    a ValueError is raised if the ``keyfunc`` is not binary.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities import sift\n    >>> from sympy.abc import x, y\n    >>> from sympy import sqrt, exp, pi, Tuple\n\n    >>> sift(range(5), lambda x: x % 2)\n    {0: [0, 2, 4], 1: [1, 3]}\n\n    sift() returns a defaultdict() object, so any key that has no matches will\n    give [].\n\n    >>> sift([x], lambda x: x.is_commutative)\n    {True: [x]}\n    >>> _[False]\n    []\n\n    Sometimes you will not know how many keys you will get:\n\n    >>> sift([sqrt(x), exp(x), (y**x)**2],\n    ...      lambda x: x.as_base_exp()[0])\n    {E: [exp(x)], x: [sqrt(x)], y: [y**(2*x)]}\n\n    Sometimes you expect the results to be binary; the\n    results can be unpacked by setting ``binary`` to True:\n\n    >>> sift(range(4), lambda x: x % 2, binary=True)\n    ([1, 3], [0, 2])\n    >>> sift(Tuple(1, pi), lambda x: x.is_rational, binary=True)\n    ([1], [pi])\n\n    A ValueError is raised if the predicate was not actually binary\n    (which is a good test for the logic where sifting is used and\n    binary results were expected):\n\n    >>> unknown = exp(1) - pi  # the rationality of this is unknown\n    >>> args = Tuple(1, pi, unknown)\n    >>> sift(args, lambda x: x.is_rational, binary=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: keyfunc gave non-binary output\n\n    The non-binary sifting shows that there were 3 keys generated:\n\n    >>> set(sift(args, lambda x: x.is_rational).keys())\n    {None, False, True}\n\n    If you need to sort the sifted items it might be better to use\n    ``ordered`` which can economically apply multiple sort keys\n    to a sequence while sorting.\n\n    See Also\n    ========\n\n    ordered\n\n    \"\"\"\n    if not binary:\n        m = defaultdict(list)\n        for i in seq:\n            m[keyfunc(i)].append(i)\n        return m\n    sift = F, T = [], []\n    for i in seq:\n        try:\n            sift[keyfunc(i)].append(i)\n        except (IndexError, TypeError):\n            raise ValueError('keyfunc gave non-binary output')\n    return T, F"
}