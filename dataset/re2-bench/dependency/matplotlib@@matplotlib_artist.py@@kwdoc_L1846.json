{
    "matplotlib.lib.matplotlib.__init__.__getitem__": "def __getitem__(self, key):\n    # In theory, this should only ever be used after the global rcParams\n    # has been set up, but better be safe e.g. in presence of breakpoints.\n    if key == \"backend\" and self is globals().get(\"rcParams\"):\n        val = self._get(key)\n        if val is rcsetup._auto_backend_sentinel:\n            from matplotlib import pyplot as plt\n            plt.switch_backend(rcsetup._auto_backend_sentinel)\n    return self._get(key)",
    "matplotlib.lib.matplotlib.artist.__init__": "def __init__(self, o):\n    r\"\"\"\n    Initialize the artist inspector with an `Artist` or an iterable of\n    `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n    sequence (all `Artist`\\s are of the same type) and it is your\n    responsibility to make sure this is so.\n    \"\"\"\n    if not isinstance(o, Artist):\n        if np.iterable(o):\n            o = list(o)\n            if len(o):\n                o = o[0]\n\n    self.oorig = o\n    if not isinstance(o, type):\n        o = type(o)\n    self.o = o\n\n    self.aliasd = self.get_aliases()",
    "matplotlib.lib.matplotlib.artist.pprint_setters": "def pprint_setters(self, prop=None, leadingspace=2):\n    \"\"\"\n    If *prop* is *None*, return a list of strings of all settable\n    properties and their valid values.\n\n    If *prop* is not *None*, it is a valid property name and that\n    property will be returned as a string of property : valid\n    values.\n    \"\"\"\n    if leadingspace:\n        pad = ' ' * leadingspace\n    else:\n        pad = ''\n    if prop is not None:\n        accepts = self.get_valid_values(prop)\n        return f'{pad}{prop}: {accepts}'\n\n    lines = []\n    for prop in sorted(self.get_setters()):\n        accepts = self.get_valid_values(prop)\n        name = self.aliased_name(prop)\n        lines.append(f'{pad}{name}: {accepts}')\n    return lines"
}