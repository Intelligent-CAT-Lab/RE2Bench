{
    "sympy.sympy.calculus.accumulationbounds.__new__": "def __new__(cls, min, max) -> Expr: # type: ignore\n\n    min = _sympify(min)\n    max = _sympify(max)\n\n    # Only allow real intervals (use symbols with 'is_extended_real=True').\n    if not min.is_extended_real or not max.is_extended_real:\n        raise ValueError(\"Only real AccumulationBounds are supported\")\n\n    if max == min:\n        return max\n\n    # Make sure that the created AccumBounds object will be valid.\n    if max.is_number and min.is_number:\n        bad = max.is_comparable and min.is_comparable and max < min\n    else:\n        bad = (max - min).is_extended_negative\n    if bad:\n        raise ValueError(\n            \"Lower limit should be smaller than upper limit\")\n\n    return Basic.__new__(cls, min, max)",
    "sympy.sympy.codegen.abstract_nodes.__eq__": "def __eq__(self, other):\n    if isinstance(other, list):\n        return self == List(*other)\n    else:\n        return self.args == other",
    "sympy.sympy.codegen.ast.__new__": "def __new__(cls, *args):\n    left_hand_sides = []\n    right_hand_sides = []\n    for i in args:\n        if isinstance(i, Assignment):\n            lhs, rhs = i.args\n            left_hand_sides.append(lhs)\n            right_hand_sides.append(rhs)\n\n    obj = CodegenAST.__new__(cls, *args)\n\n    obj.left_hand_sides = Tuple(*left_hand_sides)\n    obj.right_hand_sides = Tuple(*right_hand_sides)\n    return obj",
    "sympy.sympy.codegen.ast.__eq__": "def __eq__(self, other):\n    if not isinstance(other, self.__class__):\n        return False\n    for attr in self._fields:\n        if getattr(self, attr) != getattr(other, attr):\n            return False\n    return True",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.core.basic.<listcomp>": "newargs = tuple([walk(a, F) for a in args])\n",
    "sympy.sympy.core.basic.rec_replace": "def rec_replace(expr):\n    result = _query(expr)\n    if result or result == {}:\n        v = _value(expr, result)\n        if v is not None and v != expr:\n            if map:\n                mapping[expr] = v\n            expr = v\n    return expr",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.functions.elementary.miscellaneous.__new__": "def __new__(cls, *args, **assumptions):\n    from sympy.core.parameters import global_parameters\n    evaluate = assumptions.pop('evaluate', global_parameters.evaluate)\n    args = (sympify(arg) for arg in args)\n\n    # first standard filter, for cls.zero and cls.identity\n    # also reshape Max(a, Max(b, c)) to Max(a, b, c)\n\n    if evaluate:\n        try:\n            args = frozenset(cls._new_args_filter(args))\n        except ShortCircuit:\n            return cls.zero\n        # remove redundant args that are easily identified\n        args = cls._collapse_arguments(args, **assumptions)\n        # find local zeros\n        args = cls._find_localzeros(args, **assumptions)\n    args = frozenset(args)\n\n    if not args:\n        return cls.identity\n\n    if len(args) == 1:\n        return list(args).pop()\n\n    # base creation\n    obj = Expr.__new__(cls, *ordered(args), **assumptions)\n    obj._argset = args\n    return obj",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.logic.boolalg.__new__": "def __new__(cls, *args, **kwargs):\n    from sympy.core.relational import Eq, Ne\n    if len(args) != 3:\n        raise ValueError('expecting exactly 3 args')\n    a, b, c = args\n    # check use of binary symbols\n    if isinstance(a, (Eq, Ne)):\n        # in this context, we can evaluate the Eq/Ne\n        # if one arg is a binary symbol and the other\n        # is true/false\n        b, c = map(as_Boolean, (b, c))\n        bin_syms = set().union(*[i.binary_symbols for i in (b, c)])\n        if len(set(a.args) - bin_syms) == 1:\n            # one arg is a binary_symbols\n            _a = a\n            if a.lhs is true:\n                a = a.rhs\n            elif a.rhs is true:\n                a = a.lhs\n            elif a.lhs is false:\n                a = Not(a.rhs)\n            elif a.rhs is false:\n                a = Not(a.lhs)\n            else:\n                # binary can only equal True or False\n                a = false\n            if isinstance(_a, Ne):\n                a = Not(a)\n    else:\n        a, b, c = BooleanFunction.binary_check_and_simplify(\n            a, b, c)\n    rv = None\n    if kwargs.get('evaluate', True):\n        rv = cls.eval(a, b, c)\n    if rv is None:\n        rv = BooleanFunction.__new__(cls, a, b, c, evaluate=False)\n    return rv",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return True\n    if other is False:\n        return False\n    return super().__eq__(other)",
    "sympy.sympy.matrices.expressions.applyfunc.__new__": "def __new__(cls, function, expr):\n    expr = _sympify(expr)\n    if not expr.is_Matrix:\n        raise ValueError(\"{} must be a matrix instance.\".format(expr))\n\n    if expr.shape == (1, 1):\n        # Check if the function returns a matrix, in that case, just apply\n        # the function instead of creating an ElementwiseApplyFunc object:\n        ret = function(expr)\n        if isinstance(ret, MatrixExpr):\n            return ret\n\n    if not isinstance(function, (FunctionClass, Lambda)):\n        d = Dummy('d')\n        function = Lambda(d, function(d))\n\n    function = sympify(function)\n    if not isinstance(function, (FunctionClass, Lambda)):\n        raise ValueError(\n            \"{} should be compatible with SymPy function classes.\"\n            .format(function))\n\n    if 1 not in function.nargs:\n        raise ValueError(\n            '{} should be able to accept 1 arguments.'.format(function))\n\n    if not isinstance(function, Lambda):\n        d = Dummy('d')\n        function = Lambda(d, function(d))\n\n    obj = MatrixExpr.__new__(cls, function, expr)\n    return obj",
    "sympy.sympy.matrices.expressions.diagonal.__new__": "def __new__(cls, vector):\n    vector = _sympify(vector)\n    obj = MatrixExpr.__new__(cls, vector)\n    shape = vector.shape\n    dim = shape[1] if shape[0] == 1 else shape[0]\n    if vector.shape[0] != 1:\n        obj._iscolumn = True\n    else:\n        obj._iscolumn = False\n    obj._shape = (dim, dim)\n    obj._vector = vector\n    return obj",
    "sympy.sympy.matrices.expressions.hadamard.__new__": "def __new__(cls, *args, evaluate=False, check=None):\n    args = list(map(sympify, args))\n    if len(args) == 0:\n        # We currently don't have a way to support one-matrices of generic dimensions:\n        raise ValueError(\"HadamardProduct needs at least one argument\")\n\n    if not all(isinstance(arg, MatrixExpr) for arg in args):\n        raise TypeError(\"Mix of Matrix and Scalar symbols\")\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to HadamardProduct is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*args)\n\n    obj = super().__new__(cls, *args)\n    if evaluate:\n        obj = obj.doit(deep=False)\n    return obj",
    "sympy.sympy.matrices.expressions.matadd.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericZeroMatrix().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n\n    if not all(isinstance(arg, MatrixExpr) for arg in args):\n        raise TypeError(\"Mix of Matrix and Scalar symbols\")\n\n    obj = Basic.__new__(cls, *args)\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatAdd is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*args)\n\n    if evaluate:\n        obj = cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.matmul.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericIdentity().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatMul is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*matrices)\n\n    if not matrices:\n        # Should it be\n        #\n        # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n        return factor\n\n    if evaluate:\n        return cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)",
    "sympy.sympy.physics.quantum.commutator.__new__": "def __new__(cls, A, B):\n    r = cls.eval(A, B)\n    if r is not None:\n        return r\n    obj = Expr.__new__(cls, A, B)\n    return obj",
    "sympy.sympy.polys.rootoftools.__new__": "def __new__(cls, expr, func=None, x=None, auto=True, quadratic=False):\n    \"\"\"Construct a new ``RootSum`` instance of roots of a polynomial.\"\"\"\n    coeff, poly = cls._transform(expr, x)\n\n    if not poly.is_univariate:\n        raise MultivariatePolynomialError(\n            \"only univariate polynomials are allowed\")\n\n    if func is None:\n        func = Lambda(poly.gen, poly.gen)\n    else:\n        is_func = getattr(func, 'is_Function', False)\n\n        if is_func and 1 in func.nargs:\n            if not isinstance(func, Lambda):\n                func = Lambda(poly.gen, func(poly.gen))\n        else:\n            raise ValueError(\n                \"expected a univariate function, got %s\" % func)\n\n    var, expr = func.variables[0], func.expr\n\n    if coeff is not S.One:\n        expr = expr.subs(var, coeff*var)\n\n    deg = poly.degree()\n\n    if not expr.has(var):\n        return deg*expr\n\n    if expr.is_Add:\n        add_const, expr = expr.as_independent(var)\n    else:\n        add_const = S.Zero\n\n    if expr.is_Mul:\n        mul_const, expr = expr.as_independent(var)\n    else:\n        mul_const = S.One\n\n    func = Lambda(var, expr)\n\n    rational = cls._is_func_rational(poly, func)\n    factors, terms = _pure_factors(poly), []\n\n    for poly, k in factors:\n        if poly.is_linear:\n            term = func(roots_linear(poly)[0])\n        elif quadratic and poly.is_quadratic:\n            term = sum(map(func, roots_quadratic(poly)))\n        else:\n            if not rational or not auto:\n                term = cls._new(poly, func, auto)\n            else:\n                term = cls._rational_case(poly, func)\n\n        terms.append(k*term)\n\n    return mul_const*Add(*terms) + deg*add_const",
    "sympy.sympy.polys.rootoftools.args": "@property\ndef args(self):\n    return (self.expr, Integer(self.index))",
    "sympy.sympy.sets.conditionset.__new__": "    def __new__(cls, sym, condition, base_set=S.UniversalSet):\n        sym = _sympify(sym)\n        flat = flatten([sym])\n        if has_dups(flat):\n            raise BadSignatureError(\"Duplicate symbols detected\")\n        base_set = _sympify(base_set)\n        if not isinstance(base_set, Set):\n            raise TypeError(\n                'base set should be a Set object, not %s' % base_set)\n        condition = _sympify(condition)\n\n        if isinstance(condition, FiniteSet):\n            condition_orig = condition\n            temp = (Eq(lhs, 0) for lhs in condition)\n            condition = And(*temp)\n            sympy_deprecation_warning(\n                f\"\"\"\nUsing a set for the condition in ConditionSet is deprecated. Use a boolean\ninstead.\n\nIn this case, replace\n\n    {condition_orig}\n\nwith\n\n    {condition}\n\"\"\",\n                deprecated_since_version='1.5',\n                active_deprecations_target=\"deprecated-conditionset-set\",\n                )\n\n        condition = as_Boolean(condition)\n\n        if condition is S.true:\n            return base_set\n\n        if condition is S.false:\n            return S.EmptySet\n\n        if base_set is S.EmptySet:\n            return S.EmptySet\n\n        # no simple answers, so now check syms\n        for i in flat:\n            if not getattr(i, '_diff_wrt', False):\n                raise ValueError('`%s` is not symbol-like' % i)\n\n        if base_set.contains(sym) is S.false:\n            raise TypeError('sym `%s` is not in base_set `%s`' % (sym, base_set))\n\n        know = None\n        if isinstance(base_set, FiniteSet):\n            sifted = sift(\n                base_set, lambda _: fuzzy_bool(condition.subs(sym, _)))\n            if sifted[None]:\n                know = FiniteSet(*sifted[True])\n                base_set = FiniteSet(*sifted[None])\n            else:\n                return FiniteSet(*sifted[True])\n\n        if isinstance(base_set, cls):\n            s, c, b = base_set.args\n            def sig(s):\n                return cls(s, Eq(adummy, 0)).as_dummy().sym\n            sa, sb = map(sig, (sym, s))\n            if sa != sb:\n                raise BadSignatureError('sym does not match sym of base set')\n            reps = dict(zip(flatten([sym]), flatten([s])))\n            if s == sym:\n                condition = And(condition, c)\n                base_set = b\n            elif not c.free_symbols & sym.free_symbols:\n                reps = {v: k for k, v in reps.items()}\n                condition = And(condition, c.xreplace(reps))\n                base_set = b\n            elif not condition.free_symbols & s.free_symbols:\n                sym = sym.xreplace(reps)\n                condition = And(condition.xreplace(reps), c)\n                base_set = b\n\n        # flatten ConditionSet(Contains(ConditionSet())) expressions\n        if isinstance(condition, Contains) and (sym == condition.args[0]):\n            if isinstance(condition.args[1], Set):\n                return condition.args[1].intersect(base_set)\n\n        rv = Basic.__new__(cls, sym, condition, base_set)\n        return rv if know is None else Union(know, rv)",
    "sympy.sympy.sets.fancysets.__new__": "def __new__(cls, flambda, *sets):\n    if not isinstance(flambda, Lambda):\n        raise ValueError('First argument must be a Lambda')\n\n    signature = flambda.signature\n\n    if len(signature) != len(sets):\n        raise ValueError('Incompatible signature')\n\n    sets = [_sympify(s) for s in sets]\n\n    if not all(isinstance(s, Set) for s in sets):\n        raise TypeError(\"Set arguments to ImageSet should of type Set\")\n\n    if not all(cls._check_sig(sg, st) for sg, st in zip(signature, sets)):\n        raise ValueError(\"Signature %s does not match sets %s\" % (signature, sets))\n\n    if flambda is S.IdentityFunction and len(sets) == 1:\n        return sets[0]\n\n    if not set(flambda.variables) & flambda.expr.free_symbols:\n        is_empty = fuzzy_or(s.is_empty for s in sets)\n        if is_empty == True:\n            return S.EmptySet\n        elif is_empty == False:\n            return FiniteSet(flambda.expr)\n\n    return Basic.__new__(cls, flambda, *sets)",
    "sympy.sympy.sets.setexpr.__new__": "def __new__(cls, setarg):\n    return Expr.__new__(cls, setarg)",
    "sympy.sympy.sets.sets.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n\n    # keep the form of the first canonical arg\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                # e.g. i = class without args like `Interval`\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    "sympy.sympy.sets.sets.args": "@property\ndef args(self):\n    return self._args",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, prob, condition=None, **kwargs):\n    prob = _sympify(prob)\n    if condition is None:\n        obj = Expr.__new__(cls, prob)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, prob, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.tensor.array.expressions.array_expressions.__new__": "def __new__(cls, expr, *contraction_indices, **kwargs):\n    contraction_indices = _sort_contraction_indices(contraction_indices)\n    expr = _sympify(expr)\n\n    canonicalize = kwargs.get(\"canonicalize\", False)\n\n    obj = Basic.__new__(cls, expr, *contraction_indices)\n    obj._subranks = _get_subranks(expr)\n    obj._mapping = _get_mapping_from_subranks(obj._subranks)\n\n    free_indices_to_position = {i: i for i in range(sum(obj._subranks)) if all(i not in cind for cind in contraction_indices)}\n    obj._free_indices_to_position = free_indices_to_position\n\n    shape = get_shape(expr)\n    cls._validate(expr, *contraction_indices)\n    if shape:\n        shape = tuple(shp for i, shp in enumerate(shape) if not any(i in j for j in contraction_indices))\n    obj._shape = shape\n    if canonicalize:\n        return obj._canonicalize()\n    return obj",
    "sympy.sympy.tensor.tensor.__new__": "def __new__(cls, *args, **kw_args):\n    is_canon_bp = kw_args.get('is_canon_bp', False)\n    args = list(map(_sympify, args))\n\n    \"\"\"\n    If the internal dummy indices in one arg conflict with the free indices\n    of the remaining args, we need to rename those internal dummy indices.\n    \"\"\"\n    free = [get_free_indices(arg) for arg in args]\n    free = set(itertools.chain(*free)) #flatten free\n    newargs = []\n    for arg in args:\n        dum_this = set(get_dummy_indices(arg))\n        dum_other = [get_dummy_indices(a) for a in newargs]\n        dum_other = set(itertools.chain(*dum_other)) #flatten dum_other\n        free_this = set(get_free_indices(arg))\n        if len(dum_this.intersection(free)) > 0:\n            exclude = free_this.union(free, dum_other)\n            newarg = TensMul._dedupe_indices(arg, exclude)\n        else:\n            newarg = arg\n        newargs.append(newarg)\n\n    args = newargs\n\n    # Flatten:\n    args = [i for arg in args for i in (arg.args if isinstance(arg, (TensMul, Mul)) else [arg])]\n\n    args, indices, free, dum = TensMul._tensMul_contract_indices(args, replace_indices=False)\n\n    # Data for indices:\n    index_types = [i.tensor_index_type for i in indices]\n    index_structure = _IndexStructure(free, dum, index_types, indices, canon_bp=is_canon_bp)\n\n    obj = TensExpr.__new__(cls, *args)\n    obj._indices = indices\n    obj._index_types = index_types.copy()\n    obj._index_structure = index_structure\n    obj._free = index_structure.free[:]\n    obj._dum = index_structure.dum[:]\n    obj._free_indices = {x[0] for x in obj.free}\n    obj._rank = len(obj.free)\n    obj._ext_rank = len(obj._index_structure.free) + 2*len(obj._index_structure.dum)\n    obj._coeff = S.One\n    obj._is_canon_bp = is_canon_bp\n    return obj",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1",
    "sympy.sympy.vector.coordsysrect.__init__": "def __init__(self, name, location=None, rotation_matrix=None,\n             parent=None, vector_names=None, variable_names=None,\n             latex_vects=None, pretty_vects=None, latex_scalars=None,\n             pretty_scalars=None, transformation=None):\n    # Dummy initializer for setting docstring\n    pass",
    "sympy.sympy.vector.coordsysrect.__new__": "def __new__(cls, name, transformation=None, parent=None, location=None,\n            rotation_matrix=None, vector_names=None, variable_names=None):\n    \"\"\"\n    The orientation/location parameters are necessary if this system\n    is being defined at a certain orientation or location wrt another.\n\n    Parameters\n    ==========\n\n    name : str\n        The name of the new CoordSys3D instance.\n\n    transformation : Lambda, Tuple, str\n        Transformation defined by transformation equations or chosen\n        from predefined ones.\n\n    location : Vector\n        The position vector of the new system's origin wrt the parent\n        instance.\n\n    rotation_matrix : SymPy ImmutableMatrix\n        The rotation matrix of the new coordinate system with respect\n        to the parent. In other words, the output of\n        new_system.rotation_matrix(parent).\n\n    parent : CoordSys3D\n        The coordinate system wrt which the orientation/location\n        (or both) is being defined.\n\n    vector_names, variable_names : iterable(optional)\n        Iterables of 3 strings each, with custom names for base\n        vectors and base scalars of the new system respectively.\n        Used for simple str printing.\n\n    \"\"\"\n\n    name = str(name)\n    Vector = sympy.vector.Vector\n    Point = sympy.vector.Point\n\n    if not isinstance(name, str):\n        raise TypeError(\"name should be a string\")\n\n    if transformation is not None:\n        if (location is not None) or (rotation_matrix is not None):\n            raise ValueError(\"specify either `transformation` or \"\n                             \"`location`/`rotation_matrix`\")\n        if isinstance(transformation, (Tuple, tuple, list)):\n            if isinstance(transformation[0], MatrixBase):\n                rotation_matrix = transformation[0]\n                location = transformation[1]\n            else:\n                transformation = Lambda(transformation[0],\n                                        transformation[1])\n        elif isinstance(transformation, Callable):\n            x1, x2, x3 = symbols('x1 x2 x3', cls=Dummy)\n            transformation = Lambda((x1, x2, x3),\n                                    transformation(x1, x2, x3))\n        elif isinstance(transformation, str):\n            transformation = Str(transformation)\n        elif isinstance(transformation, (Str, Lambda)):\n            pass\n        else:\n            raise TypeError(\"transformation: \"\n                            \"wrong type {}\".format(type(transformation)))\n\n    # If orientation information has been provided, store\n    # the rotation matrix accordingly\n    if rotation_matrix is None:\n        rotation_matrix = ImmutableDenseMatrix(eye(3))\n    else:\n        if not isinstance(rotation_matrix, MatrixBase):\n            raise TypeError(\"rotation_matrix should be an Immutable\" +\n                            \"Matrix instance\")\n        rotation_matrix = rotation_matrix.as_immutable()\n\n    # If location information is not given, adjust the default\n    # location as Vector.zero\n    if parent is not None:\n        if not isinstance(parent, CoordSys3D):\n            raise TypeError(\"parent should be a \" +\n                            \"CoordSys3D/None\")\n        if location is None:\n            location = Vector.zero\n        else:\n            if not isinstance(location, Vector):\n                raise TypeError(\"location should be a Vector\")\n            # Check that location does not contain base\n            # scalars\n            for x in location.free_symbols:\n                if isinstance(x, BaseScalar):\n                    raise ValueError(\"location should not contain\" +\n                                     \" BaseScalars\")\n        origin = parent.origin.locate_new(name + '.origin',\n                                          location)\n    else:\n        location = Vector.zero\n        origin = Point(name + '.origin')\n\n    if transformation is None:\n        transformation = Tuple(rotation_matrix, location)\n\n    if isinstance(transformation, Tuple):\n        lambda_transformation = CoordSys3D._compose_rotation_and_translation(\n            transformation[0],\n            transformation[1],\n            parent\n        )\n        r, l = transformation\n        l = l._projections\n        lambda_lame = CoordSys3D._get_lame_coeff('cartesian')\n        lambda_inverse = lambda x, y, z: r.inv()*Matrix(\n            [x-l[0], y-l[1], z-l[2]])\n    elif isinstance(transformation, Str):\n        trname = transformation.name\n        lambda_transformation = CoordSys3D._get_transformation_lambdas(trname)\n        if parent is not None:\n            if parent.lame_coefficients() != (S.One, S.One, S.One):\n                raise ValueError('Parent for pre-defined coordinate '\n                             'system should be Cartesian.')\n        lambda_lame = CoordSys3D._get_lame_coeff(trname)\n        lambda_inverse = CoordSys3D._set_inv_trans_equations(trname)\n    elif isinstance(transformation, Lambda):\n        if not CoordSys3D._check_orthogonality(transformation):\n            raise ValueError(\"The transformation equation does not \"\n                             \"create orthogonal coordinate system\")\n        lambda_transformation = transformation\n        lambda_lame = CoordSys3D._calculate_lame_coeff(lambda_transformation)\n        lambda_inverse = None\n    else:\n        lambda_transformation = lambda x, y, z: transformation(x, y, z)\n        lambda_lame = CoordSys3D._get_lame_coeff(transformation)\n        lambda_inverse = None\n\n    if variable_names is None:\n        if isinstance(transformation, Lambda):\n            variable_names = [\"x1\", \"x2\", \"x3\"]\n        elif isinstance(transformation, Str):\n            if transformation.name == 'spherical':\n                variable_names = [\"r\", \"theta\", \"phi\"]\n            elif transformation.name == 'cylindrical':\n                variable_names = [\"r\", \"theta\", \"z\"]\n            else:\n                variable_names = [\"x\", \"y\", \"z\"]\n        else:\n            variable_names = [\"x\", \"y\", \"z\"]\n    if vector_names is None:\n        vector_names = [\"i\", \"j\", \"k\"]\n\n    # All systems that are defined as 'roots' are unequal, unless\n    # they have the same name.\n    # Systems defined at same orientation/position wrt the same\n    # 'parent' are equal, irrespective of the name.\n    # This is true even if the same orientation is provided via\n    # different methods like Axis/Body/Space/Quaternion.\n    # However, coincident systems may be seen as unequal if\n    # positioned/oriented wrt different parents, even though\n    # they may actually be 'coincident' wrt the root system.\n    if parent is not None:\n        obj = super().__new__(\n            cls, Str(name), transformation, parent)\n    else:\n        obj = super().__new__(\n            cls, Str(name), transformation)\n    obj._name = name\n    # Initialize the base vectors\n\n    _check_strings('vector_names', vector_names)\n    vector_names = list(vector_names)\n    latex_vects = [(r'\\mathbf{\\hat{%s}_{%s}}' % (x, name)) for\n                       x in vector_names]\n    pretty_vects = ['%s_%s' % (x, name) for x in vector_names]\n\n    obj._vector_names = vector_names\n\n    v1 = BaseVector(0, obj, pretty_vects[0], latex_vects[0])\n    v2 = BaseVector(1, obj, pretty_vects[1], latex_vects[1])\n    v3 = BaseVector(2, obj, pretty_vects[2], latex_vects[2])\n\n    obj._base_vectors = (v1, v2, v3)\n\n    # Initialize the base scalars\n\n    _check_strings('variable_names', vector_names)\n    variable_names = list(variable_names)\n    latex_scalars = [(r\"\\mathbf{{%s}_{%s}}\" % (x, name)) for\n                     x in variable_names]\n    pretty_scalars = ['%s_%s' % (x, name) for x in variable_names]\n\n    obj._variable_names = variable_names\n    obj._vector_names = vector_names\n\n    x1 = BaseScalar(0, obj, pretty_scalars[0], latex_scalars[0])\n    x2 = BaseScalar(1, obj, pretty_scalars[1], latex_scalars[1])\n    x3 = BaseScalar(2, obj, pretty_scalars[2], latex_scalars[2])\n\n    obj._base_scalars = (x1, x2, x3)\n\n    obj._transformation = transformation\n    obj._transformation_lambda = lambda_transformation\n    obj._lame_coefficients = lambda_lame(x1, x2, x3)\n    obj._transformation_from_parent_lambda = lambda_inverse\n\n    setattr(obj, variable_names[0], x1)\n    setattr(obj, variable_names[1], x2)\n    setattr(obj, variable_names[2], x3)\n\n    setattr(obj, vector_names[0], v1)\n    setattr(obj, vector_names[1], v2)\n    setattr(obj, vector_names[2], v3)\n\n    # Assign params\n    obj._parent = parent\n    if obj._parent is not None:\n        obj._root = obj._parent._root\n    else:\n        obj._root = obj\n\n    obj._parent_rotation_matrix = rotation_matrix\n    obj._origin = origin\n\n    # Return the instance\n    return obj",
    "sympy.sympy.vector.scalar.__new__": "def __new__(cls, index, system, pretty_str=None, latex_str=None):\n    from sympy.vector.coordsysrect import CoordSys3D\n    if pretty_str is None:\n        pretty_str = \"x{}\".format(index)\n    elif isinstance(pretty_str, Symbol):\n        pretty_str = pretty_str.name\n    if latex_str is None:\n        latex_str = \"x_{}\".format(index)\n    elif isinstance(latex_str, Symbol):\n        latex_str = latex_str.name\n\n    index = _sympify(index)\n    system = _sympify(system)\n    obj = super().__new__(cls, index, system)\n    if not isinstance(system, CoordSys3D):\n        raise TypeError(\"system should be a CoordSys3D\")\n    if index not in range(0, 3):\n        raise ValueError(\"Invalid index specified.\")\n    # The _id is used for equating purposes, and for hashing\n    obj._id = (index, system)\n    obj._name = obj.name = system._name + '.' + system._variable_names[index]\n    obj._pretty_form = '' + pretty_str\n    obj._latex_form = latex_str\n    obj._system = system\n\n    return obj"
}