{
    "sympy.sympy.logic.boolalg.to_nnf": "def to_nnf(expr, simplify=True, form=None):\n    \"\"\"\n    Converts ``expr`` to Negation Normal Form (NNF).\n\n    A logical expression is in NNF if it\n    contains only :py:class:`~.And`, :py:class:`~.Or` and :py:class:`~.Not`,\n    and :py:class:`~.Not` is applied only to literals.\n    If ``simplify`` is ``True``, the result contains no redundant clauses.\n\n    Parameters\n    ==========\n\n    expr : boolean expression\n        The expression to convert to NNF.\n    simplify : bool, optional\n        If True, simplify the result. Default is True.\n    form : str, optional\n        Target form hint: 'cnf' for conjunctive normal form bias,\n        'dnf' for disjunctive normal form bias, or None (default).\n        This hint optimizes XOR conversions.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import A, B, C, D\n    >>> from sympy.logic.boolalg import Not, Equivalent, to_nnf\n    >>> to_nnf(Not((~A & ~B) | (C & D)))\n    (A | B) & (~C | ~D)\n    >>> to_nnf(Equivalent(A >> B, B >> A))\n    (A | ~B | (A & ~B)) & (B | ~A | (B & ~A))\n\n    \"\"\"\n    if is_nnf(expr, simplify):\n        return expr\n    return expr.to_nnf(simplify, form=form)"
}