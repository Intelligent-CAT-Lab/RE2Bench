{
    "scikit-learn.sklearn.metrics._classification._check_targets": "def _check_targets(y_true, y_pred, sample_weight=None):\n    \"\"\"Check that y_true and y_pred belong to the same classification task.\n\n    This converts multiclass or binary types to a common shape, and raises a\n    ValueError for a mix of multilabel and multiclass targets, a mix of\n    multilabel formats, for the presence of continuous-valued or multioutput\n    targets, or for targets of different lengths.\n\n    Column vectors are squeezed to 1d, while multilabel formats are returned\n    as CSR sparse label indicators.\n\n    Parameters\n    ----------\n    y_true : array-like\n\n    y_pred : array-like\n\n    sample_weight : array-like, default=None\n\n    Returns\n    -------\n    type_true : one of {'multilabel-indicator', 'multiclass', 'binary'}\n        The type of the true target data, as output by\n        ``utils.multiclass.type_of_target``.\n\n    y_true : array or indicator matrix\n\n    y_pred : array or indicator matrix\n\n    sample_weight : array or None\n    \"\"\"\n    xp, _ = get_namespace(y_true, y_pred, sample_weight)\n    check_consistent_length(y_true, y_pred, sample_weight)\n    type_true = type_of_target(y_true, input_name=\"y_true\")\n    type_pred = type_of_target(y_pred, input_name=\"y_pred\")\n    for array in [y_true, y_pred]:\n        if _num_samples(array) < 1:\n            raise ValueError(\n                \"Found empty input array (e.g., `y_true` or `y_pred`) while a minimum \"\n                \"of 1 sample is required.\"\n            )\n    if sample_weight is not None:\n        sample_weight = _check_sample_weight(\n            sample_weight, y_true, force_float_dtype=False\n        )\n\n    y_type = {type_true, type_pred}\n    if y_type == {\"binary\", \"multiclass\"}:\n        y_type = {\"multiclass\"}\n\n    if len(y_type) > 1:\n        raise ValueError(\n            \"Classification metrics can't handle a mix of {0} and {1} targets\".format(\n                type_true, type_pred\n            )\n        )\n\n    # We can't have more than one value on y_type => The set is no more needed\n    y_type = y_type.pop()\n\n    # No metrics support \"multiclass-multioutput\" format\n    if y_type not in [\"binary\", \"multiclass\", \"multilabel-indicator\"]:\n        raise ValueError(\"{0} is not supported\".format(y_type))\n\n    if y_type in [\"binary\", \"multiclass\"]:\n        try:\n            y_true = column_or_1d(y_true, input_name=\"y_true\")\n            y_pred = column_or_1d(y_pred, input_name=\"y_pred\")\n        except TypeError as e:\n            if \"Sparse data was passed\" in str(e):\n                raise TypeError(\n                    \"Sparse input is only supported when targets are of multilabel type\"\n                ) from e\n            else:\n                raise\n\n        xp, _ = get_namespace(y_true, y_pred)\n        if y_type == \"binary\":\n            try:\n                unique_values = _union1d(y_true, y_pred, xp)\n            except TypeError as e:\n                # We expect y_true and y_pred to be of the same data type.\n                # If `y_true` was provided to the classifier as strings,\n                # `y_pred` given by the classifier will also be encoded with\n                # strings. So we raise a meaningful error\n                raise TypeError(\n                    \"Labels in y_true and y_pred should be of the same type. \"\n                    f\"Got y_true={xp.unique(y_true)} and \"\n                    f\"y_pred={xp.unique(y_pred)}. Make sure that the \"\n                    \"predictions provided by the classifier coincides with \"\n                    \"the true labels.\"\n                ) from e\n            if unique_values.shape[0] > 2:\n                y_type = \"multiclass\"\n\n    if y_type.startswith(\"multilabel\"):\n        if _is_numpy_namespace(xp):\n            # XXX: do we really want to sparse-encode multilabel indicators when\n            # they are passed as a dense arrays? This is not possible for array\n            # API inputs in general hence we only do it for NumPy inputs. But even\n            # for NumPy the usefulness is questionable.\n            y_true = csr_matrix(y_true)\n            y_pred = csr_matrix(y_pred)\n        y_type = \"multilabel-indicator\"\n\n    return y_type, y_true, y_pred, sample_weight",
    "scikit-learn.sklearn.utils._array_api._tolist": "def _tolist(array, xp=None):\n    xp, _ = get_namespace(array, xp=xp)\n    if _is_numpy_namespace(xp):\n        return array.tolist()\n    array_np = _convert_to_numpy(array, xp=xp)\n    return [element.item() for element in array_np]",
    "scikit-learn.sklearn.utils._unique.attach_unique": "def attach_unique(*ys, return_tuple=False):\n    \"\"\"Attach unique values of ys to ys and return the results.\n\n    The result is a view of y, and the metadata (unique) is not attached to y.\n\n    IMPORTANT: The output of this function should NEVER be returned in functions.\n    This is to avoid this pattern:\n\n    .. code:: python\n\n        y = np.array([1, 2, 3])\n        y = attach_unique(y)\n        y[1] = -1\n        # now np.unique(y) will be different from cached_unique(y)\n\n    Parameters\n    ----------\n    *ys : sequence of array-like\n        Input data arrays.\n\n    return_tuple : bool, default=False\n        If True, always return a tuple even if there is only one array.\n\n    Returns\n    -------\n    ys : tuple of array-like or array-like\n        Input data with unique values attached.\n    \"\"\"\n    res = tuple(_attach_unique(y) for y in ys)\n    if len(res) == 1 and not return_tuple:\n        return res[0]\n    return res",
    "scikit-learn.sklearn.utils.multiclass.unique_labels": "def unique_labels(*ys):\n    \"\"\"Extract an ordered array of unique labels.\n\n    We don't allow:\n        - mix of multilabel and multiclass (single label) targets\n        - mix of label indicator matrix and anything else,\n          because there are no explicit labels)\n        - mix of label indicator matrices of different sizes\n        - mix of string and integer labels\n\n    At the moment, we also don't allow \"multiclass-multioutput\" input type.\n\n    Parameters\n    ----------\n    *ys : array-likes\n        Label values.\n\n    Returns\n    -------\n    out : ndarray of shape (n_unique_labels,)\n        An ordered array of unique labels.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import unique_labels\n    >>> unique_labels([3, 5, 5, 5, 7, 7])\n    array([3, 5, 7])\n    >>> unique_labels([1, 2, 3, 4], [2, 2, 3, 4])\n    array([1, 2, 3, 4])\n    >>> unique_labels([1, 2, 10], [5, 11])\n    array([ 1,  2,  5, 10, 11])\n    \"\"\"\n    ys = attach_unique(*ys, return_tuple=True)\n    xp, is_array_api_compliant = get_namespace(*ys)\n    if len(ys) == 0:\n        raise ValueError(\"No argument has been passed.\")\n    # Check that we don't mix label format\n\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n        raise ValueError(\"Mix type of y not allowed, got types %s\" % ys_types)\n\n    label_type = ys_types.pop()\n\n    # Check consistency for the indicator format\n    if (\n        label_type == \"multilabel-indicator\"\n        and len(\n            set(\n                check_array(y, accept_sparse=[\"csr\", \"csc\", \"coo\"]).shape[1] for y in ys\n            )\n        )\n        > 1\n    ):\n        raise ValueError(\n            \"Multi-label binary indicator input with different numbers of labels\"\n        )\n\n    # Get the unique set of labels\n    _unique_labels = _FN_UNIQUE_LABELS.get(label_type, None)\n    if not _unique_labels:\n        raise ValueError(\"Unknown label type: %s\" % repr(ys))\n\n    if is_array_api_compliant:\n        # array_api does not allow for mixed dtypes\n        unique_ys = xp.concat([_unique_labels(y, xp=xp) for y in ys])\n        return xp.unique_values(unique_ys)\n\n    ys_labels = set(\n        chain.from_iterable((i for i in _unique_labels(y, xp=xp)) for y in ys)\n    )\n    # Check that we don't mix string type with number type\n    if len(set(isinstance(label, str) for label in ys_labels)) > 1:\n        raise ValueError(\"Mix of label input types (string and number)\")\n\n    return xp.asarray(sorted(ys_labels))"
}