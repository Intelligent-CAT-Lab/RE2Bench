{
    "sympy.sympy.polys.densebasic.dmp_multi_deflate": "def dmp_multi_deflate(\n    polys: tuple[dmp[Er], ...], u: int, K: Domain[Er]\n) -> tuple[tuple[int, ...], tuple[dmp[Er], ...]]:\n    \"\"\"\n    Map ``x_i**m_i`` to ``y_i`` in a set of polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_multi_deflate\n\n    >>> f = ZZ.map([[1, 0, 0, 2], [], [3, 0, 0, 4]])\n    >>> g = ZZ.map([[1, 0, 2], [], [3, 0, 4]])\n\n    >>> dmp_multi_deflate((f, g), 1, ZZ)\n    ((2, 1), ([[1, 0, 0, 2], [3, 0, 0, 4]], [[1, 0, 2], [3, 0, 4]]))\n\n    \"\"\"\n    if not u:\n        M, H = dup_multi_deflate(_idup(polys), K)\n        return (M,), _idmp(H)\n\n    F: list[dict[monom, Er]] = []\n    B = [0] * (u + 1)\n\n    for p in polys:\n        f: dict[monom, Er] = dmp_to_dict(p, u, K)\n\n        if not dmp_zero_p(p, u):\n            for m in f.keys():\n                for i, e in enumerate(m):\n                    B[i] = igcd(B[i], e)\n\n        F.append(f)\n\n    for i, b in enumerate(B):\n        if not b:\n            B[i] = 1\n\n    Bt = tuple(B)\n\n    if all(b == 1 for b in Bt):\n        return Bt, polys\n\n    H2: list[dmp[Er]] = []\n\n    for f in F:\n        h: dict[monom, Er] = {}\n\n        for A, coeff in f.items():\n            N = [a // b for a, b in zip(A, Bt)]\n            h[tuple(N)] = coeff\n\n        H2.append(dmp_from_dict(h, u, K))\n\n    return Bt, tuple(H2)",
    "sympy.sympy.polys.densebasic.dmp_inflate": "def dmp_inflate(f: dmp[Er], M: list[int], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Map ``y_i`` to ``x_i**k_i`` in a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_inflate\n\n    >>> f = ZZ.map([[1, 2], [3, 4]])\n\n    >>> dmp_inflate(f, (2, 3), 1, ZZ)\n    [[1, 0, 0, 2], [], [3, 0, 0, 4]]\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_inflate(_dup(f), M[0], K))\n\n    if all(m == 1 for m in M):\n        return f\n    else:\n        return _rec_inflate(f, M, u, 0, K)",
    "sympy.sympy.polys.euclidtools.dup_inner_gcd": "def dup_inner_gcd(f, g, K):\n    \"\"\"\n    Computes polynomial GCD and cofactors of `f` and `g` in `K[x]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_inner_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    \"\"\"\n    # XXX: This used to check for K.is_Exact but leads to awkward results when\n    # the domain is something like RR[z] e.g.:\n    #\n    # >>> g, p, q = Poly(1, x).cancel(Poly(51.05*x*y - 1.0, x))\n    # >>> g\n    # 1.0\n    # >>> p\n    # Poly(17592186044421.0, x, domain='RR[y]')\n    # >>> q\n    # Poly(898081097567692.0*y*x - 17592186044421.0, x, domain='RR[y]'))\n    #\n    # Maybe it would be better to flatten into multivariate polynomials first.\n    if K.is_RR or K.is_CC:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return [K.one], f, g\n\n        f = dup_convert(f, K, exact)\n        g = dup_convert(g, K, exact)\n\n        h, cff, cfg = dup_inner_gcd(f, g, exact)\n\n        h = dup_convert(h, exact, K)\n        cff = dup_convert(cff, exact, K)\n        cfg = dup_convert(cfg, exact, K)\n\n        return h, cff, cfg\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dup_qq_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dup_ff_prs_gcd(f, g, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dup_zz_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dup_rr_prs_gcd(f, g, K)",
    "sympy.sympy.polys.euclidtools._dmp_inner_gcd": "def _dmp_inner_gcd(f, g, u, K):\n    \"\"\"Helper function for `dmp_inner_gcd()`. \"\"\"\n    if not K.is_Exact:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return dmp_one(u, K), f, g\n\n        f = dmp_convert(f, u, K, exact)\n        g = dmp_convert(g, u, K, exact)\n\n        h, cff, cfg = _dmp_inner_gcd(f, g, u, exact)\n\n        h = dmp_convert(h, u, exact, K)\n        cff = dmp_convert(cff, u, exact, K)\n        cfg = dmp_convert(cfg, u, exact, K)\n\n        return h, cff, cfg\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dmp_qq_heu_gcd(f, g, u, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dmp_ff_prs_gcd(f, g, u, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dmp_zz_heu_gcd(f, g, u, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dmp_rr_prs_gcd(f, g, u, K)"
}