{
    "sympy.sympy.algebras.quaternion.__new__": "def __new__(cls, a: SExpr = 0, b: SExpr = 0, c: SExpr = 0, d: SExpr = 0,\n                 real_field: bool = True,\n                 norm: SExpr | None = None) -> Quaternion:\n\n    a, b, c, d = map(sympify, (a, b, c, d))\n\n    if any(i.is_commutative is False for i in [a, b, c, d]):\n        raise ValueError(\"arguments have to be commutative\")\n\n    obj = super().__new__(cls, a, b, c, d)\n    obj._real_field = real_field\n    obj.set_norm(norm)\n    return obj",
    "sympy.sympy.calculus.accumulationbounds.__new__": "def __new__(cls, min, max) -> Expr: # type: ignore\n\n    min = _sympify(min)\n    max = _sympify(max)\n\n    # Only allow real intervals (use symbols with 'is_extended_real=True').\n    if not min.is_extended_real or not max.is_extended_real:\n        raise ValueError(\"Only real AccumulationBounds are supported\")\n\n    if max == min:\n        return max\n\n    # Make sure that the created AccumBounds object will be valid.\n    if max.is_number and min.is_number:\n        bad = max.is_comparable and min.is_comparable and max < min\n    else:\n        bad = (max - min).is_extended_negative\n    if bad:\n        raise ValueError(\n            \"Lower limit should be smaller than upper limit\")\n\n    return Basic.__new__(cls, min, max)",
    "sympy.sympy.concrete.products.__new__": "def __new__(cls, function, *symbols, **assumptions):\n    obj = ExprWithIntLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.core.add.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self. If radical is True (default is False) then\n    common radicals will be removed and included as a factor of the\n    primitive expression.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (3 + 3*sqrt(2)).as_content_primitive()\n    (3, 1 + sqrt(2))\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(\n        radical=radical, clear=clear)) for a in self.args]).primitive()\n    if not clear and not con.is_Integer and prim.is_Add:\n        con, d = con.as_numer_denom()\n        _p = prim/d\n        if any(a.as_coeff_Mul()[0].is_Integer for a in _p.args):\n            prim = _p\n        else:\n            con /= d\n    if radical and prim.is_Add:\n        # look for common radicals that can be removed\n        args = prim.args\n        rads = []\n        common_q = None\n        for m in args:\n            term_rads = defaultdict(list)\n            for ai in Mul.make_args(m):\n                if ai.is_Pow:\n                    b, e = ai.as_base_exp()\n                    if e.is_Rational and b.is_Integer:\n                        term_rads[e.q].append(abs(int(b))**e.p)\n            if not term_rads:\n                break\n            if common_q is None:\n                common_q = set(term_rads.keys())\n            else:\n                common_q = common_q & set(term_rads.keys())\n                if not common_q:\n                    break\n            rads.append(term_rads)\n        else:\n            # process rads\n            # keep only those in common_q\n            for r in rads:\n                for q in list(r.keys()):\n                    if q not in common_q:\n                        r.pop(q)\n                for q in r:\n                    r[q] = Mul(*r[q])\n            # find the gcd of bases for each q\n            G = []\n            for q in common_q:\n                g = reduce(igcd, [r[q] for r in rads], 0)\n                if g != 1:\n                    G.append(g**Rational(1, q))\n            if G:\n                G = Mul(*G)\n                args = [ai/G for ai in args]\n                prim = G*prim.func(*args)\n\n    return con, prim",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.expr.as_base_exp": "def as_base_exp(self) -> tuple[Expr, Expr]:\n    # a -> b ** e\n    return self, S.One",
    "sympy.sympy.core.expr.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"This method should recursively remove a Rational from all arguments\n    and return that (content) and the new self (primitive). The content\n    should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n    The primitive need not be in canonical form and should try to preserve\n    the underlying structure if possible (i.e. expand_mul should not be\n    applied to self).\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import x, y, z\n\n    >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n\n    The as_content_primitive function is recursive and retains structure:\n\n    >>> eq.as_content_primitive()\n    (2, x + 3*y*(y + 1) + 1)\n\n    Integer powers will have Rationals extracted from the base:\n\n    >>> ((2 + 6*x)**2).as_content_primitive()\n    (4, (3*x + 1)**2)\n    >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n    (1, (2*(3*x + 1))**(2*y))\n\n    Terms may end up joining once their as_content_primitives are added:\n\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (11, x*(y + 1))\n    >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (9, x*(y + 1))\n    >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n    (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n    (121, x**2*(y + 1)**2)\n    >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()\n    (1, 4.84*x**2*(y + 1)**2)\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    If clear=False (default is True) then content will not be removed\n    from an Add if it can be distributed to leave one or more\n    terms with integer coefficients.\n\n    >>> (x/2 + y).as_content_primitive()\n    (1/2, x + 2*y)\n    >>> (x/2 + y).as_content_primitive(clear=False)\n    (1, x/2 + y)\n    \"\"\"\n    return S.One, self",
    "sympy.sympy.core.exprtools._factor_sum_int": "def _factor_sum_int(expr, **kwargs):\n    \"\"\"Return Sum or Integral object with factors that are not\n    in the wrt variables removed. In cases where there are additive\n    terms in the function of the object that are independent, the\n    object will be separated into two objects.\n\n    Examples\n    ========\n\n    >>> from sympy import Sum, factor_terms\n    >>> from sympy.abc import x, y\n    >>> factor_terms(Sum(x + y, (x, 1, 3)))\n    y*Sum(1, (x, 1, 3)) + Sum(x, (x, 1, 3))\n    >>> factor_terms(Sum(x*y, (x, 1, 3)))\n    y*Sum(x, (x, 1, 3))\n\n    Notes\n    =====\n\n    If a function in the summand or integrand is replaced\n    with a symbol, then this simplification should not be\n    done or else an incorrect result will be obtained when\n    the symbol is replaced with an expression that depends\n    on the variables of summation/integration:\n\n    >>> eq = Sum(y, (x, 1, 3))\n    >>> factor_terms(eq).subs(y, x).doit()\n    3*x\n    >>> eq.subs(y, x).doit()\n    6\n    \"\"\"\n    result = expr.function\n    if result == 0:\n        return S.Zero\n    limits = expr.limits\n\n    # get the wrt variables\n    wrt = {i.args[0] for i in limits}\n\n    # factor out any common terms that are independent of wrt\n    f = factor_terms(result, **kwargs)\n    i, d = f.as_independent(*wrt)\n    if isinstance(f, Add):\n        return i * expr.func(1, *limits) + expr.func(d, *limits)\n    else:\n        return i * expr.func(d, *limits)",
    "sympy.sympy.core.exprtools.<listcomp>": "*[do(a) for a in p.args])\n",
    "sympy.sympy.core.exprtools.<genexpr>": "if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None\n           for a in list_args):\n    cont = -cont\n    list_args = [-a for a in list_args]\n# watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\n",
    "sympy.sympy.core.exprtools.gcd_terms": "def gcd_terms(terms, isprimitive=False, clear=True, fraction=True):\n    \"\"\"Compute the GCD of ``terms`` and put them together.\n\n    Parameters\n    ==========\n\n    terms : Expr\n        Can be an expression or a non-Basic sequence of expressions\n        which will be handled as though they are terms from a sum.\n\n    isprimitive : bool, optional\n        If ``isprimitive`` is True the _gcd_terms will not run the primitive\n        method on the terms.\n\n    clear : bool, optional\n        It controls the removal of integers from the denominator of an Add\n        expression. When True (default), all numerical denominator will be cleared;\n        when False the denominators will be cleared only if all terms had numerical\n        denominators other than 1.\n\n    fraction : bool, optional\n        When True (default), will put the expression over a common\n        denominator.\n\n    Examples\n    ========\n\n    >>> from sympy import gcd_terms\n    >>> from sympy.abc import x, y\n\n    >>> gcd_terms((x + 1)**2*y + (x + 1)*y**2)\n    y*(x + 1)*(x + y + 1)\n    >>> gcd_terms(x/2 + 1)\n    (x + 2)/2\n    >>> gcd_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> gcd_terms(x/2 + y/2, clear=False)\n    (x + y)/2\n    >>> gcd_terms(x/2 + 1/x)\n    (x**2 + 2)/(2*x)\n    >>> gcd_terms(x/2 + 1/x, fraction=False)\n    (x + 2/x)/2\n    >>> gcd_terms(x/2 + 1/x, fraction=False, clear=False)\n    x/2 + 1/x\n\n    >>> gcd_terms(x/2/y + 1/x/y)\n    (x**2 + 2)/(2*x*y)\n    >>> gcd_terms(x/2/y + 1/x/y, clear=False)\n    (x**2/2 + 1)/(x*y)\n    >>> gcd_terms(x/2/y + 1/x/y, clear=False, fraction=False)\n    (x/2 + 1/x)/y\n\n    The ``clear`` flag was ignored in this case because the returned\n    expression was a rational expression, not a simple sum.\n\n    See Also\n    ========\n\n    factor_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def mask(terms):\n        \"\"\"replace nc portions of each term with a unique Dummy symbols\n        and return the replacements to restore them\"\"\"\n        args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]\n        reps = []\n        for i, (c, nc) in enumerate(args):\n            if nc:\n                nc = Mul(*nc)\n                d = Dummy()\n                reps.append((d, nc))\n                c.append(d)\n                args[i] = Mul(*c)\n            else:\n                args[i] = c\n        return args, dict(reps)\n\n    isadd = isinstance(terms, Add)\n    addlike = isadd or not isinstance(terms, Basic) and \\\n        is_sequence(terms, include=set) and \\\n        not isinstance(terms, Dict)\n\n    if addlike:\n        if isadd:  # i.e. an Add\n            terms = list(terms.args)\n        else:\n            terms = sympify(terms)\n        terms, reps = mask(terms)\n        cont, numer, denom = _gcd_terms(terms, isprimitive, fraction)\n        numer = numer.xreplace(reps)\n        coeff, factors = cont.as_coeff_Mul()\n        if not clear:\n            c, _coeff = coeff.as_coeff_Mul()\n            if not c.is_Integer and not clear and numer.is_Add:\n                n, d = c.as_numer_denom()\n                _numer = numer/d\n                if any(a.as_coeff_Mul()[0].is_Integer\n                        for a in _numer.args):\n                    numer = _numer\n                    coeff = n*_coeff\n        return _keep_coeff(coeff, factors*numer/denom, clear=clear)\n\n    if not isinstance(terms, Basic):\n        return terms\n\n    if terms.is_Atom:\n        return terms\n\n    if terms.is_Mul:\n        c, args = terms.as_coeff_mul()\n        return _keep_coeff(c, Mul(*[gcd_terms(i, isprimitive, clear, fraction)\n            for i in args]), clear=clear)\n\n    def handle(a):\n        # don't treat internal args like terms of an Add\n        if not isinstance(a, Expr):\n            if isinstance(a, Basic):\n                if not a.args:\n                    return a\n                return a.func(*[handle(i) for i in a.args])\n            return type(a)([handle(i) for i in a])\n        return gcd_terms(a, isprimitive, clear, fraction)\n\n    if isinstance(terms, Dict):\n        return Dict(*[(k, handle(v)) for k, v in terms.args])\n    return terms.func(*[handle(i) for i in terms.args])",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.mul.as_base_exp": "def as_base_exp(self):\n    e1 = None\n    bases = []\n    nc = 0\n    for m in self.args:\n        b, e = m.as_base_exp()\n        if not b.is_commutative:\n            nc += 1\n        if e1 is None:\n            e1 = e\n        elif e != e1 or nc > 1 or not e.is_Integer:\n            return self, S.One\n        bases.append(b)\n    return self.func(*bases), e1",
    "sympy.sympy.core.mul.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n    (6, -sqrt(2)*(1 - sqrt(2)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    coef = S.One\n    args = []\n    for a in self.args:\n        c, p = a.as_content_primitive(radical=radical, clear=clear)\n        coef *= c\n        if p is not S.One:\n            args.append(p)\n    # don't use self._from_args here to reconstruct args\n    # since there may be identical args now that should be combined\n    # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n    return coef, self.func(*args)",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.NegativeOne",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.as_base_exp": "def as_base_exp(self):\n    return S.NegativeOne, S.Half",
    "sympy.sympy.core.operations._from_args": "@classmethod\ndef _from_args(cls, args, is_commutative=None):\n    \"\"\"Create new instance with already-processed args.\n    If the args are not in canonical order, then a non-canonical\n    result will be returned, so use with caution. The order of\n    args may change if the sign of the args is changed.\"\"\"\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and(a.is_commutative for a in args)\n    obj.is_commutative = is_commutative\n    return obj",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str | None = None,\n                 dummy_index: int | None = None,\n                 **assumptions: bool | None) -> Self:\n    if dummy_index is not None:\n        assert name is not None, \"If you specify a dummy_index, you must also provide a name\"\n\n    if name is None:\n        name = \"Dummy_\" + str(Dummy._count)\n\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n\n    obj.dummy_index = dummy_index\n\n    return obj",
    "sympy.sympy.diffgeom.diffgeom.__new__": "def __new__(cls, coord_sys, index, **kwargs):\n    index = _sympify(index)\n    obj = super().__new__(cls, coord_sys, index)\n    obj._coord_sys = coord_sys\n    obj._index = index\n    return obj",
    "sympy.sympy.functions.elementary.exponential.as_base_exp": "def as_base_exp(self):\n    \"\"\"\n    Returns the 2-tuple (base, exponent).\n    \"\"\"\n    return self.func(1), Mul(*self.args)",
    "sympy.sympy.functions.elementary.miscellaneous.__new__": "def __new__(cls, *args, **assumptions):\n    from sympy.core.parameters import global_parameters\n    evaluate = assumptions.pop('evaluate', global_parameters.evaluate)\n    args = (sympify(arg) for arg in args)\n\n    # first standard filter, for cls.zero and cls.identity\n    # also reshape Max(a, Max(b, c)) to Max(a, b, c)\n\n    if evaluate:\n        try:\n            args = frozenset(cls._new_args_filter(args))\n        except ShortCircuit:\n            return cls.zero\n        # remove redundant args that are easily identified\n        args = cls._collapse_arguments(args, **assumptions)\n        # find local zeros\n        args = cls._find_localzeros(args, **assumptions)\n    args = frozenset(args)\n\n    if not args:\n        return cls.identity\n\n    if len(args) == 1:\n        return list(args).pop()\n\n    # base creation\n    obj = Expr.__new__(cls, *ordered(args), **assumptions)\n    obj._argset = args\n    return obj",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.functions.special.hyper.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 5:\n        args = [(args[0], args[1]), (args[2], args[3]), args[4]]\n    if len(args) != 3:\n        raise TypeError(\"args must be either as, as', bs, bs', z or \"\n                        \"as, bs, z\")\n\n    def tr(p):\n        if len(p) != 2:\n            raise TypeError(\"wrong argument\")\n        p = [list(ordered(i)) for i in p]\n        return TupleArg(_prep_tuple(p[0]), _prep_tuple(p[1]))\n\n    arg0, arg1 = tr(args[0]), tr(args[1])\n    if Tuple(arg0, arg1).has(oo, zoo, -oo):\n        raise ValueError(\"G-function parameters must be finite\")\n    if any((a - b).is_Integer and a - b > 0\n           for a in arg0[0] for b in arg1[0]):\n        raise ValueError(\"no parameter a1, ..., an may differ from \"\n                     \"any b1, ..., bm by a positive integer\")\n\n    # TODO should we check convergence conditions?\n    return super().__new__(cls, arg0, arg1, args[2], **kwargs)",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, name, n, m):\n    n, m = _sympify(n), _sympify(m)\n\n    cls._check_dim(m)\n    cls._check_dim(n)\n\n    if isinstance(name, str):\n        name = Str(name)\n    obj = Basic.__new__(cls, name, n, m)\n    return obj",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, n):\n    n = _sympify(n)\n    cls._check_dim(n)\n\n    return super().__new__(cls, n)",
    "sympy.sympy.physics.quantum.qexpr.__new__": "def __new__(cls, *args, **kwargs):\n    \"\"\"Construct a new quantum object.\n\n    Parameters\n    ==========\n\n    args : tuple\n        The list of numbers or parameters that uniquely specify the\n        quantum object. For a state, this will be its symbol or its\n        set of quantum numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.qexpr import QExpr\n    >>> q = QExpr(0)\n    >>> q\n    0\n    >>> q.label\n    (0,)\n    >>> q.hilbert_space\n    H\n    >>> q.args\n    (0,)\n    >>> q.is_commutative\n    False\n    \"\"\"\n\n    # First compute args and call Expr.__new__ to create the instance\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    # Now set the slots on the instance\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    "sympy.sympy.physics.quantum.spin.__new__": "def __new__(cls, j, m):\n    j = sympify(j)\n    m = sympify(m)\n    if j.is_number:\n        if 2*j != int(2*j):\n            raise ValueError(\n                'j must be integer or half-integer, got: %s' % j)\n        if j < 0:\n            raise ValueError('j must be >= 0, got: %s' % j)\n    if m.is_number:\n        if 2*m != int(2*m):\n            raise ValueError(\n                'm must be integer or half-integer, got: %s' % m)\n    if j.is_number and m.is_number:\n        if abs(m) > j:\n            raise ValueError('Allowed values for m are -j <= m <= j, got j, m: %s, %s' % (j, m))\n        if int(j - m) != j - m:\n            raise ValueError('Both j and m must be integer or half-integer, got j, m: %s, %s' % (j, m))\n    return State.__new__(cls, j, m)",
    "sympy.sympy.physics.quantum.tensorproduct.__new__": "def __new__(cls, *args):\n    if isinstance(args[0], (Matrix, ImmutableMatrix, numpy_ndarray,\n                                                scipy_sparse_matrix)):\n        return matrix_tensor_product(*args)\n    c_part, new_args = cls.flatten(sympify(args))\n    c_part = Mul(*c_part)\n    if len(new_args) == 0:\n        return c_part\n    elif len(new_args) == 1:\n        return c_part * new_args[0]\n    else:\n        tp = Expr.__new__(cls, *new_args)\n        return c_part * tp",
    "sympy.sympy.physics.units.dimensions.__new__": "def __new__(cls, name, symbol=None):\n\n    if isinstance(name, str):\n        name = Symbol(name)\n    else:\n        name = sympify(name)\n\n    if not isinstance(name, Expr):\n        raise TypeError(\"Dimension name needs to be a valid math expression\")\n\n    if isinstance(symbol, str):\n        symbol = Symbol(symbol)\n    elif symbol is not None:\n        assert isinstance(symbol, Symbol)\n\n    obj = Expr.__new__(cls, name)\n\n    obj._name = name\n    obj._symbol = symbol\n    return obj",
    "sympy.sympy.physics.units.prefixes.__new__": "def __new__(cls, name, abbrev, exponent, base=sympify(10), latex_repr=None):\n\n    name = sympify(name)\n    abbrev = sympify(abbrev)\n    exponent = sympify(exponent)\n    base = sympify(base)\n\n    obj = Expr.__new__(cls, name, abbrev, exponent, base)\n    obj._name = name\n    obj._abbrev = abbrev\n    obj._scale_factor = base**exponent\n    obj._exponent = exponent\n    obj._base = base\n    obj._latex_repr = latex_repr\n    return obj",
    "sympy.sympy.physics.units.quantities.__new__": "def __new__(cls, name, abbrev=None,\n            latex_repr=None, pretty_unicode_repr=None,\n            pretty_ascii_repr=None, mathml_presentation_repr=None,\n            is_prefixed=False,\n            **assumptions):\n\n    if not isinstance(name, Symbol):\n        name = Symbol(name)\n\n    if abbrev is None:\n        abbrev = name\n    elif isinstance(abbrev, str):\n        abbrev = Symbol(abbrev)\n\n    # HACK: These are here purely for type checking. They actually get assigned below.\n    cls._is_prefixed = is_prefixed\n\n    obj = AtomicExpr.__new__(cls, name, abbrev)\n    obj._name = name\n    obj._abbrev = abbrev\n    obj._latex_repr = latex_repr\n    obj._unicode_repr = pretty_unicode_repr\n    obj._ascii_repr = pretty_ascii_repr\n    obj._mathml_repr = mathml_presentation_repr\n    obj._is_prefixed = is_prefixed\n    return obj",
    "sympy.sympy.polys.rootoftools.__new__": "def __new__(cls, f, x, index=None, radicals=False, expand=True):\n    \"\"\" Construct an indexed complex root of a polynomial.\n\n    See ``rootof`` for the parameters.\n\n    The default value of ``radicals`` is ``False`` to satisfy\n    ``eval(srepr(expr) == expr``.\n    \"\"\"\n    x = sympify(x)\n\n    if index is None and x.is_Integer:\n        x, index = None, x\n    else:\n        index = sympify(index)\n\n    if index is not None and index.is_Integer:\n        index = int(index)\n    else:\n        raise ValueError(\"expected an integer root index, got %s\" % index)\n\n    poly = PurePoly(f, x, greedy=False, expand=expand)\n\n    if not poly.is_univariate:\n        raise PolynomialError(\"only univariate polynomials are allowed\")\n\n    if not poly.gen.is_Symbol:\n        # PurePoly(sin(x) + 1) == PurePoly(x + 1) but the roots of\n        # x for each are not the same: issue 8617\n        raise PolynomialError(\"generator must be a Symbol\")\n\n    degree = poly.degree()\n\n    if degree <= 0:\n        raise PolynomialError(\"Cannot construct CRootOf object for %s\" % f)\n\n    if index < -degree or index >= degree:\n        raise IndexError(\"root index out of [%d, %d] range, got %d\" %\n                         (-degree, degree - 1, index))\n    elif index < 0:\n        index += degree\n\n    dom = poly.get_domain()\n\n    if not dom.is_Exact:\n        poly = poly.to_exact()\n\n    roots = cls._roots_trivial(poly, radicals)\n\n    if roots is not None:\n        return roots[index]\n\n    coeff, poly = preprocess_roots(poly)\n    dom = poly.get_domain()\n\n    if not dom.is_ZZ:\n        raise NotImplementedError(\"CRootOf is not supported over %s\" % dom)\n\n    root = cls._indexed_root(poly, index, lazy=True)\n    return coeff * cls._postprocess_root(root, radicals)",
    "sympy.sympy.polys.rootoftools.args": "@property\ndef args(self):\n    return (self.expr, Integer(self.index))",
    "sympy.sympy.sets.sets.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n\n    # keep the form of the first canonical arg\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                # e.g. i = class without args like `Interval`\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    "sympy.sympy.stats.rv.__getattr__": "def __getattr__(self, attr):\n    try:\n        return self.args[self._argnames.index(attr)]\n    except ValueError:\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n            type(self).__name__, attr))",
    "sympy.sympy.stats.rv.__new__": "def __new__(cls, idx_obj, pspace=None):\n    if pspace is None:\n        # Allow single arg, representing pspace == PSpace()\n        pspace = PSpace()\n    if not isinstance(idx_obj, (Indexed, Function)):\n        raise TypeError(\"An Function or Indexed object is expected not %s\"%(idx_obj))\n    return Basic.__new__(cls, idx_obj, pspace)",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, arg, condition=None, **kwargs):\n    arg = _sympify(arg)\n\n    if arg.is_Matrix:\n        from sympy.stats.symbolic_multivariate_probability import VarianceMatrix\n        return VarianceMatrix(arg, condition)\n    if condition is None:\n        obj = Expr.__new__(cls, arg)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, arg, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.tensor.array.array_derivatives.__new__": "def __new__(cls, expr, *variables, **kwargs):\n    obj = super().__new__(cls, expr, *variables, **kwargs)\n    if isinstance(obj, ArrayDerivative):\n        obj._shape = obj._get_shape()\n    return obj",
    "sympy.sympy.tensor.indexed.__new__": "def __new__(cls, base, *args, **kw_args):\n    from sympy.tensor.array.ndim_array import NDimArray\n    from sympy.matrices.matrixbase import MatrixBase\n\n    if not args:\n        raise IndexException(\"Indexed needs at least one index.\")\n    if isinstance(base, (str, Symbol)):\n        base = IndexedBase(base)\n    elif not hasattr(base, '__getitem__') and not isinstance(base, IndexedBase):\n        raise TypeError(filldedent(\"\"\"\n            The base can only be replaced with a string, Symbol,\n            IndexedBase or an object with a method for getting\n            items (i.e. an object with a `__getitem__` method).\n            \"\"\"))\n    args = list(map(sympify, args))\n    if isinstance(base, (NDimArray, Iterable, Tuple, MatrixBase)) and all(i.is_number for i in args):\n        if len(args) == 1:\n            return base[args[0]]\n        else:\n            return base[args]\n\n    base = _sympify(base)\n\n    obj = Expr.__new__(cls, base, *args, **kw_args)\n\n    IndexedBase._set_assumptions(obj, base.assumptions0)\n\n    return obj",
    "sympy.sympy.utilities.iterables.iterable": "def iterable(i, exclude=(str, dict, NotIterable)):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is SymPy iterable.\n    True also indicates that the iterator is finite, e.g. you can\n    call list(...) on the instance.\n\n    When SymPy is working with iterables, it is almost always assuming\n    that the iterable is not a string or a mapping, so those are excluded\n    by default. If you want a pure Python definition, make exclude=None. To\n    exclude multiple items, pass them as a tuple.\n\n    You can also set the _iterable attribute to True or False on your class,\n    which will override the checks here, including the exclude test.\n\n    As a rule of thumb, some SymPy functions use this to check if they should\n    recursively map over an object. If an object is technically iterable in\n    the Python sense but does not desire this behavior (e.g., because its\n    iteration is not finite, or because iteration might induce an unwanted\n    computation), it should disable it by setting the _iterable attribute to False.\n\n    See also: is_sequence\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import iterable\n    >>> from sympy import Tuple\n    >>> things = [[1], (1,), set([1]), Tuple(1), (j for j in [1, 2]), {1:2}, '1', 1]\n    >>> for i in things:\n    ...     print('%s %s' % (iterable(i), type(i)))\n    True <... 'list'>\n    True <... 'tuple'>\n    True <... 'set'>\n    True <class 'sympy.core.containers.Tuple'>\n    True <... 'generator'>\n    False <... 'dict'>\n    False <... 'str'>\n    False <... 'int'>\n\n    >>> iterable({}, exclude=None)\n    True\n    >>> iterable({}, exclude=str)\n    True\n    >>> iterable(\"no\", exclude=str)\n    False\n\n    \"\"\"\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    "sympy.sympy.vector.scalar.__new__": "def __new__(cls, index, system, pretty_str=None, latex_str=None):\n    from sympy.vector.coordsysrect import CoordSys3D\n    if pretty_str is None:\n        pretty_str = \"x{}\".format(index)\n    elif isinstance(pretty_str, Symbol):\n        pretty_str = pretty_str.name\n    if latex_str is None:\n        latex_str = \"x_{}\".format(index)\n    elif isinstance(latex_str, Symbol):\n        latex_str = latex_str.name\n\n    index = _sympify(index)\n    system = _sympify(system)\n    obj = super().__new__(cls, index, system)\n    if not isinstance(system, CoordSys3D):\n        raise TypeError(\"system should be a CoordSys3D\")\n    if index not in range(0, 3):\n        raise ValueError(\"Invalid index specified.\")\n    # The _id is used for equating purposes, and for hashing\n    obj._id = (index, system)\n    obj._name = obj.name = system._name + '.' + system._variable_names[index]\n    obj._pretty_form = '' + pretty_str\n    obj._latex_form = latex_str\n    obj._system = system\n\n    return obj"
}