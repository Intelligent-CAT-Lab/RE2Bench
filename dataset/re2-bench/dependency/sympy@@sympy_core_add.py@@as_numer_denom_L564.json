{
    "sympy.sympy.core.add.primitive": "def primitive(self):\n    \"\"\"\n    Return ``(R, self/R)`` where ``R``` is the Rational GCD of ``self```.\n\n    ``R`` is collected only from the leading coefficient of each term.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n\n    >>> (2*x + 4*y).primitive()\n    (2, x + 2*y)\n\n    >>> (2*x/3 + 4*y/9).primitive()\n    (2/9, 3*x + 2*y)\n\n    >>> (2*x/3 + 4.2*y).primitive()\n    (1/3, 2*x + 12.6*y)\n\n    No subprocessing of term factors is performed:\n\n    >>> ((2 + 2*x)*x + 2).primitive()\n    (1, x*(2*x + 2) + 2)\n\n    Recursive processing can be done with the ``as_content_primitive()``\n    method:\n\n    >>> ((2 + 2*x)*x + 2).as_content_primitive()\n    (2, x*(x + 1) + 1)\n\n    See also: primitive() function in polytools.py\n\n    \"\"\"\n\n    terms = []\n    inf = False\n    for a in self.args:\n        c, m = a.as_coeff_Mul()\n        if not c.is_Rational:\n            c = S.One\n            m = a\n        inf = inf or m is S.ComplexInfinity\n        terms.append((c.p, c.q, m))\n\n    if not inf:\n        ngcd = reduce(igcd, [t[0] for t in terms], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms], 1)\n    else:\n        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n\n    if ngcd == dlcm == 1:\n        return S.One, self\n    if not inf:\n        for i, (p, q, term) in enumerate(terms):\n            terms[i] = _keep_coeff(Rational((p//ngcd)*(dlcm//q)), term)\n    else:\n        for i, (p, q, term) in enumerate(terms):\n            if q:\n                terms[i] = _keep_coeff(Rational((p//ngcd)*(dlcm//q)), term)\n            else:\n                terms[i] = _keep_coeff(Rational(p, q), term)\n\n    # we don't need a complete re-flattening since no new terms will join\n    # so we just use the same sort as is used in Add.flatten. When the\n    # coefficient changes, the ordering of terms may change, e.g.\n    #     (3*x, 6*y) -> (2*y, x)\n    #\n    # We do need to make sure that term[0] stays in position 0, however.\n    #\n    if terms[0].is_Number or terms[0] is S.ComplexInfinity:\n        c = terms.pop(0)\n    else:\n        c = None\n    _addsort(terms)\n    if c:\n        terms.insert(0, c)\n    return Rational(ngcd, dlcm), self._new_rawargs(*terms)",
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.add.<listcomp>": "n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n           for i in range(len(numers))]), Mul(*denoms)\n\n",
    "sympy.sympy.core.add.<dictcomp>": "nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n# assemble single numerator and denominator\n",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.numbers.as_numer_denom": "def as_numer_denom(self):\n    return self, S.One",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.functions.elementary.exponential.as_numer_denom": "def as_numer_denom(self):\n    \"\"\"\n    Returns this with a positive exponent as a 2-tuple (a fraction).\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.abc import x\n    >>> exp(-x).as_numer_denom()\n    (1, exp(x))\n    >>> exp(x).as_numer_denom()\n    (exp(x), 1)\n    \"\"\"\n    # this should be the same as Pow.as_numer_denom wrt\n    # exponent handling\n    if not self.is_commutative:\n        return self, S.One\n    exp = self.exp\n    neg_exp = exp.is_negative\n    if not neg_exp and not (-exp).is_negative:\n        neg_exp = exp.could_extract_minus_sign()\n    if neg_exp:\n        return S.One, self.func(-exp)\n    return self, S.One",
    "sympy.sympy.matrices.expressions.matadd.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericZeroMatrix().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n\n    if not all(isinstance(arg, MatrixExpr) for arg in args):\n        raise TypeError(\"Mix of Matrix and Scalar symbols\")\n\n    obj = Basic.__new__(cls, *args)\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatAdd is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*args)\n\n    if evaluate:\n        obj = cls._evaluate(obj)\n\n    return obj"
}