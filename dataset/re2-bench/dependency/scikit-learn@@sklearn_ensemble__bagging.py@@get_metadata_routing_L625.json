{
    "scikit-learn.sklearn.ensemble._bagging._get_estimator": "def _get_estimator(self):\n    \"\"\"Resolve which estimator to return (default is DecisionTreeClassifier)\"\"\"\n    if self.estimator is None:\n        return DecisionTreeClassifier()\n    return self.estimator",
    "scikit-learn.sklearn.utils._metadata_requests.__init__": "def __init__(self, owner):\n    self._route_mappings = dict()\n    # `_self_request` is used if the router is also a consumer.\n    # _self_request, (added using `add_self_request()`) is treated\n    # differently from the other consumer objects which are stored in\n    # _route_mappings.\n    self._self_request = None\n    self.owner = owner",
    "scikit-learn.sklearn.utils._metadata_requests.add": "def add(self, *, method_mapping, **objs):\n    \"\"\"Add :term:`consumers <consumer>` to the `MetadataRouter`.\n\n    The estimators that consume metadata are passed as named objects along with a\n    method mapping, that defines how their methods relate to those of the\n    :term:`router`.\n\n    Parameters\n    ----------\n    method_mapping : MethodMapping\n        The mapping between the child (:term:`consumer`) and the parent's\n        (:term:`router`'s) methods.\n\n    **objs : dict\n        A dictionary of objects, whose requests are extracted by calling\n        :func:`~sklearn.utils.metadata_routing.get_routing_for_object` on them.\n\n    Returns\n    -------\n    self : MetadataRouter\n        Returns `self`.\n    \"\"\"\n    method_mapping = deepcopy(method_mapping)\n\n    for name, obj in objs.items():\n        self._route_mappings[name] = RouterMappingPair(\n            mapping=method_mapping, router=get_routing_for_object(obj)\n        )\n    return self"
}