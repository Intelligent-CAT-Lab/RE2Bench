{
    "matplotlib.lib.matplotlib._constrained_layout.match_submerged_margins": "def match_submerged_margins(layoutgrids, fig):\n    \"\"\"\n    Make the margins that are submerged inside an Axes the same size.\n\n    This allows Axes that span two columns (or rows) that are offset\n    from one another to have the same size.\n\n    This gives the proper layout for something like::\n        fig = plt.figure(constrained_layout=True)\n        axs = fig.subplot_mosaic(\"AAAB\\nCCDD\")\n\n    Without this routine, the Axes D will be wider than C, because the\n    margin width between the two columns in C has no width by default,\n    whereas the margins between the two columns of D are set by the\n    width of the margin between A and B. However, obviously the user would\n    like C and D to be the same size, so we need to add constraints to these\n    \"submerged\" margins.\n\n    This routine makes all the interior margins the same, and the spacing\n    between the three columns in A and the two column in C are all set to the\n    margins between the two columns of D.\n\n    See test_constrained_layout::test_constrained_layout12 for an example.\n    \"\"\"\n\n    axsdone = []\n    for sfig in fig.subfigs:\n        axsdone += match_submerged_margins(layoutgrids, sfig)\n\n    axs = [a for a in fig.get_axes()\n           if (a.get_subplotspec() is not None and a.get_in_layout() and\n               a not in axsdone)]\n\n    for ax1 in axs:\n        ss1 = ax1.get_subplotspec()\n        if ss1.get_gridspec() not in layoutgrids:\n            axs.remove(ax1)\n            continue\n        lg1 = layoutgrids[ss1.get_gridspec()]\n\n        # interior columns:\n        if len(ss1.colspan) > 1:\n            maxsubl = np.max(\n                lg1.margin_vals['left'][ss1.colspan[1:]] +\n                lg1.margin_vals['leftcb'][ss1.colspan[1:]]\n            )\n            maxsubr = np.max(\n                lg1.margin_vals['right'][ss1.colspan[:-1]] +\n                lg1.margin_vals['rightcb'][ss1.colspan[:-1]]\n            )\n            for ax2 in axs:\n                ss2 = ax2.get_subplotspec()\n                lg2 = layoutgrids[ss2.get_gridspec()]\n                if lg2 is not None and len(ss2.colspan) > 1:\n                    maxsubl2 = np.max(\n                        lg2.margin_vals['left'][ss2.colspan[1:]] +\n                        lg2.margin_vals['leftcb'][ss2.colspan[1:]])\n                    if maxsubl2 > maxsubl:\n                        maxsubl = maxsubl2\n                    maxsubr2 = np.max(\n                        lg2.margin_vals['right'][ss2.colspan[:-1]] +\n                        lg2.margin_vals['rightcb'][ss2.colspan[:-1]])\n                    if maxsubr2 > maxsubr:\n                        maxsubr = maxsubr2\n            for i in ss1.colspan[1:]:\n                lg1.edit_margin_min('left', maxsubl, cell=i)\n            for i in ss1.colspan[:-1]:\n                lg1.edit_margin_min('right', maxsubr, cell=i)\n\n        # interior rows:\n        if len(ss1.rowspan) > 1:\n            maxsubt = np.max(\n                lg1.margin_vals['top'][ss1.rowspan[1:]] +\n                lg1.margin_vals['topcb'][ss1.rowspan[1:]]\n            )\n            maxsubb = np.max(\n                lg1.margin_vals['bottom'][ss1.rowspan[:-1]] +\n                lg1.margin_vals['bottomcb'][ss1.rowspan[:-1]]\n            )\n\n            for ax2 in axs:\n                ss2 = ax2.get_subplotspec()\n                lg2 = layoutgrids[ss2.get_gridspec()]\n                if lg2 is not None:\n                    if len(ss2.rowspan) > 1:\n                        maxsubt = np.max([np.max(\n                            lg2.margin_vals['top'][ss2.rowspan[1:]] +\n                            lg2.margin_vals['topcb'][ss2.rowspan[1:]]\n                        ), maxsubt])\n                        maxsubb = np.max([np.max(\n                            lg2.margin_vals['bottom'][ss2.rowspan[:-1]] +\n                            lg2.margin_vals['bottomcb'][ss2.rowspan[:-1]]\n                        ), maxsubb])\n            for i in ss1.rowspan[1:]:\n                lg1.edit_margin_min('top', maxsubt, cell=i)\n            for i in ss1.rowspan[:-1]:\n                lg1.edit_margin_min('bottom', maxsubb, cell=i)\n\n    return axs",
    "matplotlib.lib.matplotlib._constrained_layout.<listcomp>": "axs = [a for a in fig.get_axes()\n       if (a.get_subplotspec() is not None and a.get_in_layout() and\n           a not in axsdone)]\n\n",
    "matplotlib.lib.matplotlib._layoutgrid.edit_margin_min": "def edit_margin_min(self, todo, size, cell=0):\n    \"\"\"\n    Change the minimum size of the margin for one cell.\n\n    Parameters\n    ----------\n    todo : string (one of 'left', 'right', 'bottom', 'top')\n        margin to alter.\n\n    size : float\n        Minimum size of the margin .  If it is larger than the\n        existing minimum it updates the margin size. Fraction of\n        figure size.\n\n    cell : int\n        Cell column or row to edit.\n    \"\"\"\n\n    if size > self.margin_vals[todo][cell]:\n        self.edit_margin(todo, size, cell)",
    "matplotlib.lib.matplotlib.axes._base.get_subplotspec": "def get_subplotspec(self):\n    \"\"\"Return the `.SubplotSpec` associated with the subplot, or None.\"\"\"\n    return self._subplotspec",
    "matplotlib.lib.matplotlib.figure.axes": "@property\ndef axes(self):\n    \"\"\"\n    List of Axes in the Figure. You can access and modify the Axes in the\n    Figure through this list.\n\n    Do not modify the list itself. Instead, use `~Figure.add_axes`,\n    `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.\n\n    Note: The `.Figure.axes` property and `~.Figure.get_axes` method are\n    equivalent.\n    \"\"\"\n    return self._axstack.as_list()",
    "matplotlib.lib.matplotlib.gridspec.get_gridspec": "def get_gridspec(self):\n    return self._gridspec",
    "matplotlib.lib.matplotlib.gridspec.rowspan": "@property\ndef rowspan(self):\n    \"\"\"The rows spanned by this subplot, as a `range` object.\"\"\"\n    ncols = self.get_gridspec().ncols\n    return range(self.num1 // ncols, self.num2 // ncols + 1)",
    "matplotlib.lib.matplotlib.gridspec.colspan": "@property\ndef colspan(self):\n    \"\"\"The columns spanned by this subplot, as a `range` object.\"\"\"\n    ncols = self.get_gridspec().ncols\n    # We explicitly support num2 referring to a column on num1's *left*, so\n    # we must sort the column indices here so that the range makes sense.\n    c1, c2 = sorted([self.num1 % ncols, self.num2 % ncols])\n    return range(c1, c2 + 1)"
}