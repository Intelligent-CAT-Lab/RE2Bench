{
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.matrixbase.row_join": "def row_join(self, other: Self) -> Self:\n    \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n    Examples\n    ========\n\n    >>> from sympy import zeros, ones\n    >>> M = zeros(3)\n    >>> V = ones(3, 1)\n    >>> M.row_join(V)\n    Matrix([\n    [0, 0, 0, 1],\n    [0, 0, 0, 1],\n    [0, 0, 0, 1]])\n\n    See Also\n    ========\n\n    row\n    col_join\n    \"\"\"\n    # A null matrix can always be stacked (see  #10770)\n    if self.cols == 0 and self.rows != other.rows:\n        return self._new(other.rows, 0, []).row_join(other)\n\n    if self.rows != other.rows:\n        raise ShapeError(\n            \"The matrices have incompatible number of rows ({} and {})\"\n            .format(self.rows, other.rows))\n    return self._eval_row_join(other)",
    "sympy.sympy.matrices.repmatrix._eval_row_join": "def _eval_row_join(self, other):\n    return self._fromrep(self._rep.hstack(other._rep))",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.sparse._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)"
}