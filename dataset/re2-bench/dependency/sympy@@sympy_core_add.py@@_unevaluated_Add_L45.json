{
    "sympy.sympy.core.add._addsort": "def _addsort(args):\n    # in-place sorting of args\n    args.sort(key=_args_sortkey)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.operations._from_args": "@classmethod\ndef _from_args(cls, args, is_commutative=None):\n    \"\"\"Create new instance with already-processed args.\n    If the args are not in canonical order, then a non-canonical\n    result will be returned, so use with caution. The order of\n    args may change if the sign of the args is changed.\"\"\"\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and(a.is_commutative for a in args)\n    obj.is_commutative = is_commutative\n    return obj"
}