{
    "sympy.sympy.concrete.expr_with_limits.is_number": "@property\ndef is_number(self):\n    \"\"\"Return True if the Sum has no free symbols, else False.\"\"\"\n    return not self.free_symbols",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.expr.__complex__": "def __complex__(self) -> complex:\n    result = self.evalf()\n    re, im = result.as_real_imag()\n    return complex(float(re), float(im))",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.exprtools.decompose_power": "def decompose_power(expr: Expr) -> tuple[Expr, int]:\n    \"\"\"\n    Decompose power into symbolic base and integer exponent.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import decompose_power\n    >>> from sympy.abc import x, y\n    >>> from sympy import exp\n\n    >>> decompose_power(x)\n    (x, 1)\n    >>> decompose_power(x**2)\n    (x, 2)\n    >>> decompose_power(exp(2*y/3))\n    (exp(y/3), 2)\n\n    \"\"\"\n    base, exp = expr.as_base_exp()\n\n    if exp.is_Number:\n        if exp.is_Rational:\n            if not exp.is_Integer:\n                base = Pow(base, Rational(1, exp.q))  # type: ignore\n            e = exp.p  # type: ignore\n        else:\n            base, e = expr, 1\n    else:\n        exp, tail = exp.as_coeff_Mul(rational=True)\n\n        if exp is S.NegativeOne:\n            base, e = Pow(base, tail), -1\n        elif exp is not S.One:\n            tail = _keep_coeff(Rational(1, exp.q), tail)\n            base, e = Pow(base, tail), exp.p\n        else:\n            base, e = expr, 1\n\n    return base, e",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    return other is S.Infinity or other == float('inf')",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.sorting.default_sort_key": "def default_sort_key(item, order=None):\n    \"\"\"Return a key that can be used for sorting.\n\n    The key has the structure:\n\n    (class_key, (len(args), args), exponent.sort_key(), coefficient)\n\n    This key is supplied by the sort_key routine of Basic objects when\n    ``item`` is a Basic object or an object (other than a string) that\n    sympifies to a Basic object. Otherwise, this function produces the\n    key.\n\n    The ``order`` argument is passed along to the sort_key routine and is\n    used to determine how the terms *within* an expression are ordered.\n    (See examples below) ``order`` options are: 'lex', 'grlex', 'grevlex',\n    and reversed values of the same (e.g. 'rev-lex'). The default order\n    value is None (which translates to 'lex').\n\n    Examples\n    ========\n\n    >>> from sympy import S, I, default_sort_key, sin, cos, sqrt\n    >>> from sympy.core.function import UndefinedFunction\n    >>> from sympy.abc import x\n\n    The following are equivalent ways of getting the key for an object:\n\n    >>> x.sort_key() == default_sort_key(x)\n    True\n\n    Here are some examples of the key that is produced:\n\n    >>> default_sort_key(UndefinedFunction('f'))\n    ((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),\n        (0, ()), (), 1), 1)\n    >>> default_sort_key('1')\n    ((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)\n    >>> default_sort_key(S.One)\n    ((1, 0, 'Number'), (0, ()), (), 1)\n    >>> default_sort_key(2)\n    ((1, 0, 'Number'), (0, ()), (), 2)\n\n    While sort_key is a method only defined for SymPy objects,\n    default_sort_key will accept anything as an argument so it is\n    more robust as a sorting key. For the following, using key=\n    lambda i: i.sort_key() would fail because 2 does not have a sort_key\n    method; that's why default_sort_key is used. Note, that it also\n    handles sympification of non-string items likes ints:\n\n    >>> a = [2, I, -I]\n    >>> sorted(a, key=default_sort_key)\n    [2, -I, I]\n\n    The returned key can be used anywhere that a key can be specified for\n    a function, e.g. sort, min, max, etc...:\n\n    >>> a.sort(key=default_sort_key); a[0]\n    2\n    >>> min(a, key=default_sort_key)\n    2\n\n    Notes\n    =====\n\n    The key returned is useful for getting items into a canonical order\n    that will be the same across platforms. It is not directly useful for\n    sorting lists of expressions:\n\n    >>> a, b = x, 1/x\n\n    Since ``a`` has only 1 term, its value of sort_key is unaffected by\n    ``order``:\n\n    >>> a.sort_key() == a.sort_key('rev-lex')\n    True\n\n    If ``a`` and ``b`` are combined then the key will differ because there\n    are terms that can be ordered:\n\n    >>> eq = a + b\n    >>> eq.sort_key() == eq.sort_key('rev-lex')\n    False\n    >>> eq.as_ordered_terms()\n    [x, 1/x]\n    >>> eq.as_ordered_terms('rev-lex')\n    [1/x, x]\n\n    But since the keys for each of these terms are independent of ``order``'s\n    value, they do not sort differently when they appear separately in a list:\n\n    >>> sorted(eq.args, key=default_sort_key)\n    [1/x, x]\n    >>> sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))\n    [1/x, x]\n\n    The order of terms obtained when using these keys is the order that would\n    be obtained if those terms were *factors* in a product.\n\n    Although it is useful for quickly putting expressions in canonical order,\n    it does not sort expressions based on their complexity defined by the\n    number of operations, power of variables and others:\n\n    >>> sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)\n    [sin(x)*cos(x), sin(x)]\n    >>> sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)\n    [sqrt(x), x, x**2, x**3]\n\n    See Also\n    ========\n\n    ordered, sympy.core.expr.Expr.as_ordered_factors, sympy.core.expr.Expr.as_ordered_terms\n\n    \"\"\"\n    from .basic import Basic\n    from .singleton import S\n\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            # e.g. tuple, list\n            args = list(item)\n            unordered = False\n\n        args = [default_sort_key(arg, order=order) for arg in args]\n\n        if unordered:\n            # e.g. dict, set\n            args = sorted(args)\n\n        cls_index, args = 10, (len(args), tuple(args))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                # e.g. lambda x: x\n                pass\n            else:\n                if isinstance(item, Basic):\n                    # e.g int -> Integer\n                    return default_sort_key(item)\n                # e.g. UndefinedFunction\n\n        # e.g. str\n        cls_index, args = 0, (1, (str(item),))\n\n    return (cls_index, 0, item.__class__.__name__\n            ), args, S.One.sort_key(), S.One",
    "sympy.sympy.functions.special.hyper.is_number": "@property\ndef is_number(self):\n    \"\"\" Returns true if expression has numeric data only. \"\"\"\n    return not self.free_symbols",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.expressions.matexpr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.rootoftools.is_commutative": "@property\ndef is_commutative(self):\n    return True",
    "sympy.sympy.stats.rv.is_commutative": "@property\ndef is_commutative(self):\n    return self.symbol.is_commutative",
    "sympy.sympy.vector.basisdependent.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return (S.One, self)"
}