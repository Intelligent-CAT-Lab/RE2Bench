{
    "sympy.sympy.polys.densearith.dup_neg": "def dup_neg(f: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_neg(x**2 - 1)\n    -x**2 + 1\n\n    \"\"\"\n    return [ -coeff for coeff in f ]",
    "sympy.sympy.polys.densebasic.dup_LC": "def dup_LC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_LC\n\n    >>> dup_LC([1, 2, 3], ZZ)\n    1\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    "sympy.sympy.polys.domains.domain.is_nonnegative": "def is_nonnegative(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is non-negative. \"\"\"\n    return a >= 0 # type: ignore",
    "sympy.sympy.polys.domains.gaussiandomains.is_nonnegative": "def is_nonnegative(self, a: Telem) -> bool:\n    \"\"\"Returns ``False`` for any ``GaussianElement``. \"\"\"\n    return False",
    "sympy.sympy.polys.domains.gaussiandomains.__neg__": "def __neg__(self) -> Self:\n    return self.new(-self.x, -self.y)",
    "sympy.sympy.polys.domains.polynomialring.is_nonnegative": "def is_nonnegative(self, a):\n    \"\"\"Returns True if `LC(a)` is non-negative. \"\"\"\n    return self.domain.is_nonnegative(a.LC)",
    "sympy.sympy.polys.domains.polynomialring.one": "@property\ndef one(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.one",
    "sympy.sympy.polys.rings.__neg__": "def __neg__(self) -> PolyElement[Er]:\n    # Return (-1) * self in case of python-flint\n    return self.new([(monom, -coeff) for monom, coeff in self.iterterms()])"
}