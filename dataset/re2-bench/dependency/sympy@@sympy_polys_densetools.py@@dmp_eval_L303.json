{
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.polys.densearith.dmp_mul_ground": "def dmp_mul_ground(f: dmp[Er], c: Er, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul_ground(2*x + 2*y, ZZ(3))\n    6*x + 6*y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_mul_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densearith.dmp_add": "def dmp_add(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Add dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add(x**2 + y, x**2*y + x)\n    x**2*y + x**2 + x + y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_add(_dup(f), _dup(g), K))\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return g\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return f\n\n    v = u - 1\n\n    if df == dg:\n        return dmp_strip([ dmp_add(a, b, v, K) for a, b in zip(f, g) ], u, K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = g[:k], g[k:]\n\n        return h + [ dmp_add(a, b, v, K) for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densebasic._ground_dmp": "def _ground_dmp(p, /):\n    return p",
    "sympy.sympy.polys.densebasic.dmp_LC": "def dmp_LC(f: dmp[Er], K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_LC\n\n    >>> f = ZZ.map([[1], [2, 3]])\n\n    >>> dmp_LC(f, ZZ)\n    [1]\n\n    \"\"\"\n    if not f:\n        return _ground_dmp(K.zero)\n    else:\n        return f[0]",
    "sympy.sympy.polys.densebasic.dmp_TC": "def dmp_TC(f: dmp[Er], K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return the trailing coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_TC\n\n    >>> f = ZZ.map([[1], [2, 3]])\n\n    >>> dmp_TC(f, ZZ)\n    [2, 3]\n\n    \"\"\"\n    if not f:\n        return _ground_dmp(K.zero)\n    else:\n        return f[-1]",
    "sympy.sympy.polys.densebasic._dup": "def _dup(p, /):\n    return p",
    "sympy.sympy.polys.densetools.dup_eval": "def dup_eval(f: dup[Er], a: Er, K: Domain[Er]) -> Er:\n    \"\"\"\n    Evaluate a polynomial at ``x = a`` in ``K[x]`` using Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_eval(x**2 + 2*x + 3, 2)\n    11\n\n    \"\"\"\n    if not a:\n        return K.convert(dup_TC(f, K))\n\n    result = K.zero\n\n    for c in f:\n        result *= a\n        result += c\n\n    return result",
    "sympy.sympy.polys.fields.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)"
}