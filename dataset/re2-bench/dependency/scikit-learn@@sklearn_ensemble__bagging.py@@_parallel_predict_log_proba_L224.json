{
    "scikit-learn.sklearn.linear_model._logistic.predict_log_proba": "# Could not extract code for scikit-learn.sklearn.linear_model._logistic.predict_log_proba",
    "scikit-learn.sklearn.pipeline.classes_": "@property\ndef classes_(self):\n    \"\"\"The classes labels. Only exist if the last step is a classifier.\"\"\"\n    return self.steps[-1][1].classes_",
    "scikit-learn.sklearn.pipeline.predict_log_proba": "@available_if(_final_estimator_has(\"predict_log_proba\"))\ndef predict_log_proba(self, X, **params):\n    \"\"\"Transform the data, and apply `predict_log_proba` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed\n    data are finally passed to the final estimator that calls\n    `predict_log_proba` method. Only valid if the final estimator\n    implements `predict_log_proba`.\n\n    Parameters\n    ----------\n    X : iterable\n        Data to predict on. Must fulfill input requirements of first step\n        of the pipeline.\n\n    **params : dict of str -> object\n        - If `enable_metadata_routing=False` (default): Parameters to the\n          `predict_log_proba` called at the end of all transformations in the\n          pipeline.\n\n        - If `enable_metadata_routing=True`: Parameters requested and accepted by\n          steps. Each step must have requested certain metadata for these parameters\n          to be forwarded to them.\n\n        .. versionadded:: 0.20\n\n        .. versionchanged:: 1.4\n            Parameters are now passed to the ``transform`` method of the\n            intermediate steps as well, if requested, and if\n            `enable_metadata_routing=True`.\n\n        See :ref:`Metadata Routing User Guide <metadata_routing>` for more\n        details.\n\n    Returns\n    -------\n    y_log_proba : ndarray of shape (n_samples, n_classes)\n        Result of calling `predict_log_proba` on the final estimator.\n    \"\"\"\n    check_is_fitted(self)\n    Xt = X\n\n    if not _routing_enabled():\n        for _, name, transform in self._iter(with_final=False):\n            Xt = transform.transform(Xt)\n        return self.steps[-1][1].predict_log_proba(Xt, **params)\n\n    # metadata routing enabled\n    routed_params = process_routing(self, \"predict_log_proba\", **params)\n    for _, name, transform in self._iter(with_final=False):\n        Xt = transform.transform(Xt, **routed_params[name].transform)\n    return self.steps[-1][1].predict_log_proba(\n        Xt, **routed_params[self.steps[-1][0]].predict_log_proba\n    )",
    "scikit-learn.sklearn.tree._classes.predict_log_proba": "def predict_log_proba(self, X):\n    \"\"\"Predict class log-probabilities of the input samples X.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The input samples. Internally, it will be converted to\n        ``dtype=np.float32`` and if a sparse matrix is provided\n        to a sparse ``csr_matrix``.\n\n    Returns\n    -------\n    proba : ndarray of shape (n_samples, n_classes) or list of n_outputs \\\n        such arrays if n_outputs > 1\n        The class log-probabilities of the input samples. The order of the\n        classes corresponds to that in the attribute :term:`classes_`.\n    \"\"\"\n    proba = self.predict_proba(X)\n\n    if self.n_outputs_ == 1:\n        return np.log(proba)\n\n    else:\n        for k in range(self.n_outputs_):\n            proba[k] = np.log(proba[k])\n\n        return proba",
    "scikit-learn.sklearn.utils._available_if.__get__": "def __get__(self, obj, owner=None):\n    if obj is not None:\n        # delegate only on instances, not the classes.\n        # this is to allow access to the docstrings.\n        self._check(obj, owner=owner)\n        out = MethodType(self.fn, obj)\n\n    else:\n        # This makes it possible to use the decorated method as an unbound method,\n        # for instance when monkeypatching.\n        @wraps(self.fn)\n        def out(*args, **kwargs):\n            self._check(args[0], owner=owner)\n            return self.fn(*args, **kwargs)\n\n    return out"
}