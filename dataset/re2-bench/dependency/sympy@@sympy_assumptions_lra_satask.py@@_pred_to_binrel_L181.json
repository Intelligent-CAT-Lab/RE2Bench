{
    "sympy.sympy.assumptions.assume.function": "@property\ndef function(self):\n    \"\"\"\n    Return the predicate.\n    \"\"\"\n    # Will be changed to self.args[0] after args overriding is removed\n    return self._args[0]",
    "sympy.sympy.assumptions.assume.arguments": "@property\ndef arguments(self):\n    \"\"\"\n    Return the arguments which are applied to the predicate.\n    \"\"\"\n    # Will be changed to self.args[1:] after args overriding is removed\n    return self._args[1:]",
    "sympy.sympy.assumptions.assume.__call__": "def __call__(self, *args):\n    return AppliedPredicate(self, *args)",
    "sympy.sympy.assumptions.relation.binrel.__call__": "def __call__(self, *args):\n    if not len(args) == 2:\n        raise TypeError(f\"Q.{self.name} takes two arguments, but got {len(args)}.\")\n    return AppliedBinaryRelation(self, *args)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.utilities.decorator.accessor": "@wraps(propfunc)\ndef accessor(self):\n    val = getattr(self, attrname, sentinel)\n    if val is sentinel:\n        val = propfunc(self)\n        setattr(self, attrname, val)\n    return val"
}