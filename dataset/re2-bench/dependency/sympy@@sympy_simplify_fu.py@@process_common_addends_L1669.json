{
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        # S(0) == S.false is False\n        # S(0) == False is True\n        return False\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        # a Rational is always in reduced form so will never be 2/4\n        # so we can just check equivalence of args\n        return self.p == other.p and self.q == other.q\n    return False",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.simplify.fu.do": "def do(rv, first=True):\n    # args which can be expressed as A*(cos(a)*cos(b)+/-sin(a)*sin(b))\n    # or B*(cos(a)*sin(b)+/-cos(b)*sin(a)) can be combined into\n    # A*f(a+/-b) where f is either sin or cos.\n    #\n    # If there are more than two args, the pairs which \"work\" will have\n    # a gcd extractable and the remaining two terms will have the above\n    # structure -- all pairs must be checked to find the ones that\n    # work.\n\n    if not rv.is_Add:\n        return rv\n\n    args = list(ordered(rv.args))\n    if len(args) != 2:\n        hit = False\n        for i in range(len(args)):\n            ai = args[i]\n            if ai is None:\n                continue\n            for j in range(i + 1, len(args)):\n                aj = args[j]\n                if aj is None:\n                    continue\n                was = ai + aj\n                new = do(was)\n                if new != was:\n                    args[i] = new  # update in place\n                    args[j] = None\n                    hit = True\n                    break  # go to next i\n        if hit:\n            rv = Add(*[_f for _f in args if _f])\n            if rv.is_Add:\n                rv = do(rv)\n\n        return rv\n\n    # two-arg Add\n    split = trig_split(*args, two=True)\n    if not split:\n        return rv\n    gcd, n1, n2, a, b, same = split\n\n    # identify and get c1 to be cos then apply rule if possible\n    if same:  # coscos, sinsin\n        gcd = n1*gcd\n        if n1 == n2:\n            return gcd*cos(a - b)\n        return gcd*cos(a + b)\n    else:  #cossin, cossin\n        gcd = n1*gcd\n        if n1 == n2:\n            return gcd*sin(a + b)\n        return gcd*sin(b - a)",
    "sympy.sympy.simplify.fu.<lambda>": "    rv, do, lambda x: tuple(ordered(x.free_symbols)))\n\n# need to check for inducible pairs in ratio of sqrt(3):1 that\n# appeared in different lists when sorting by coefficient\n",
    "sympy.sympy.vector.basisdependent.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return (S.One, self)"
}