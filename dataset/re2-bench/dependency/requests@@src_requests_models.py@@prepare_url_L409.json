{
    "requests.src.requests._internal_utils.to_native_string": "def to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        out = string.decode(encoding)\n\n    return out",
    "requests.src.requests._internal_utils.unicode_is_ascii": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode(\"ascii\")\n        return True\n    except UnicodeEncodeError:\n        return False",
    "requests.src.requests.exceptions.__init__": "def __init__(self, *args, **kwargs):\n    \"\"\"Initialize RequestException with `request` and `response` objects.\"\"\"\n    response = kwargs.pop(\"response\", None)\n    self.response = response\n    self.request = kwargs.pop(\"request\", None)\n    if response is not None and not self.request and hasattr(response, \"request\"):\n        self.request = self.response.request\n    super().__init__(*args, **kwargs)",
    "requests.src.requests.models._encode_params": "@staticmethod\ndef _encode_params(data):\n    \"\"\"Encode parameters in a piece of data.\n\n    Will successfully encode parameters when passed as a dict or a list of\n    2-tuples. Order is retained if data is a list of 2-tuples but arbitrary\n    if parameters are supplied as a dict.\n    \"\"\"\n\n    if isinstance(data, (str, bytes)):\n        return data\n    elif hasattr(data, \"read\"):\n        return data\n    elif hasattr(data, \"__iter__\"):\n        result = []\n        for k, vs in to_key_val_list(data):\n            if isinstance(vs, basestring) or not hasattr(vs, \"__iter__\"):\n                vs = [vs]\n            for v in vs:\n                if v is not None:\n                    result.append(\n                        (\n                            k.encode(\"utf-8\") if isinstance(k, str) else k,\n                            v.encode(\"utf-8\") if isinstance(v, str) else v,\n                        )\n                    )\n        return urlencode(result, doseq=True)\n    else:\n        return data",
    "requests.src.requests.utils.requote_uri": "def requote_uri(uri):\n    \"\"\"Re-quote the given URI.\n\n    This function passes the given URI through an unquote/quote cycle to\n    ensure that it is fully and consistently quoted.\n\n    :rtype: str\n    \"\"\"\n    safe_with_percent = \"!#$%&'()*+,/:;=?@[]~\"\n    safe_without_percent = \"!#$&'()*+,/:;=?@[]~\"\n    try:\n        # Unquote only the unreserved characters\n        # Then quote only illegal characters (do not quote reserved,\n        # unreserved, or '%')\n        return quote(unquote_unreserved(uri), safe=safe_with_percent)\n    except InvalidURL:\n        # We couldn't unquote the given URI, so let's try quoting it, but\n        # there may be unquoted '%'s in the URI. We need to make sure they're\n        # properly quoted so they do not cause issues elsewhere.\n        return quote(uri, safe=safe_without_percent)"
}