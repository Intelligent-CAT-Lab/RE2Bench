{
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)",
    "sympy.sympy.matrices.expressions.adjoint._entry": "def _entry(self, i, j, **kwargs):\n    return conjugate(self.arg._entry(j, i, **kwargs))",
    "sympy.sympy.matrices.expressions.applyfunc._entry": "def _entry(self, i, j, **kwargs):\n    return self.function(self.expr._entry(i, j, **kwargs))",
    "sympy.sympy.matrices.expressions.blockmatrix._entry": "def _entry(self, i, j, **kwargs):\n    # Find row entry\n    orig_i, orig_j = i, j\n    for row_block, numrows in enumerate(self.rowblocksizes):\n        cmp = i < numrows\n        if cmp == True:\n            break\n        elif cmp == False:\n            i -= numrows\n        elif row_block < self.blockshape[0] - 1:\n            # Can't tell which block and it's not the last one, return unevaluated\n            return MatrixElement(self, orig_i, orig_j)\n    for col_block, numcols in enumerate(self.colblocksizes):\n        cmp = j < numcols\n        if cmp == True:\n            break\n        elif cmp == False:\n            j -= numcols\n        elif col_block < self.blockshape[1] - 1:\n            return MatrixElement(self, orig_i, orig_j)\n    return self.blocks[row_block, col_block][i, j]",
    "sympy.sympy.matrices.expressions.companion._entry": "def _entry(self, i, j):\n    if j == self.cols - 1:\n        return -self.args[0].all_coeffs()[-1 - i]\n    elif i == j + 1:\n        return S.One\n    return S.Zero",
    "sympy.sympy.matrices.expressions.diagonal.shape": "@property\ndef shape(self):\n    r, c = self.arg.shape\n    if r.is_Integer and c.is_Integer:\n        m = min(r, c)\n    elif r.is_Integer and not c.is_Integer:\n        m = r\n    elif c.is_Integer and not r.is_Integer:\n        m = c\n    elif r == c:\n        m = r\n    else:\n        try:\n            m = min(r, c)\n        except TypeError:\n            m = None\n    return m, S.One",
    "sympy.sympy.matrices.expressions.diagonal._entry": "def _entry(self, i, j, **kwargs):\n    if self.diagonal_length is not None:\n        if Ge(i, self.diagonal_length) is S.true:\n            return S.Zero\n        elif Ge(j, self.diagonal_length) is S.true:\n            return S.Zero\n    eq = Eq(i, j)\n    if eq is S.true:\n        return self.arg[i, i]\n    elif eq is S.false:\n        return S.Zero\n    return self.arg[i, j]*KroneckerDelta(i, j)",
    "sympy.sympy.matrices.expressions.diagonal.<lambda>": "shape = property(lambda self: self.arg.shape)  # type:ignore\n\n",
    "sympy.sympy.matrices.expressions.fourier._entry": "def _entry(self, i, j, **kwargs):\n    w = exp(-2*S.Pi*I/self.n)\n    return w**(i*j) / sqrt(self.n)",
    "sympy.sympy.matrices.expressions.funcmatrix._entry": "def _entry(self, i, j, **kwargs):\n    return self.lamda(i, j)",
    "sympy.sympy.matrices.expressions.hadamard._entry": "def _entry(self, i, j, **kwargs):\n    return Mul(*[arg._entry(i, j, **kwargs) for arg in self.args])",
    "sympy.sympy.matrices.expressions.kronecker._entry": "def _entry(self, i, j, **kwargs):\n    result = 1\n    for mat in reversed(self.args):\n        i, m = divmod(i, mat.rows)\n        j, n = divmod(j, mat.cols)\n        result *= mat[m, n]\n    return result",
    "sympy.sympy.matrices.expressions.matadd._entry": "def _entry(self, i, j, **kwargs):\n    return Add(*[arg._entry(i, j, **kwargs) for arg in self.args])",
    "sympy.sympy.matrices.expressions.matexpr.valid_index": "def valid_index(self, i, j):\n    def is_valid(idx):\n        return isinstance(idx, (int, Integer, Symbol, Expr))\n    return (is_valid(i) and is_valid(j) and\n            (self.rows is None or\n            (i >= -self.rows) != False and (i < self.rows) != False) and\n            (j >= -self.cols) != False and (j < self.cols) != False)",
    "sympy.sympy.matrices.expressions.matexpr.shape": "@property\ndef shape(self):\n    return self.args[1], self.args[2]",
    "sympy.sympy.matrices.expressions.matexpr._entry": "def _entry(self, i, j, **kwargs):\n    return MatrixElement(self, i, j)",
    "sympy.sympy.matrices.expressions.matmul.shape": "@property\ndef shape(self):\n    matrices = [arg for arg in self.args if arg.is_Matrix]\n    return (matrices[0].rows, matrices[-1].cols)",
    "sympy.sympy.matrices.expressions.matmul._entry": "def _entry(self, i, j, expand=True, **kwargs):\n    # Avoid cyclic imports\n    from sympy.concrete.summations import Sum\n    from sympy.matrices.immutable import ImmutableMatrix\n\n    coeff, matrices = self.as_coeff_matrices()\n\n    if len(matrices) == 1:  # situation like 2*X, matmul is just X\n        return coeff * matrices[0][i, j]\n\n    indices = [None]*(len(matrices) + 1)\n    ind_ranges = [None]*(len(matrices) - 1)\n    indices[0] = i\n    indices[-1] = j\n\n    def f():\n        counter = 1\n        while True:\n            yield Dummy(\"i_%i\" % counter)\n            counter += 1\n\n    dummy_generator = kwargs.get(\"dummy_generator\", f())\n\n    for i in range(1, len(matrices)):\n        indices[i] = next(dummy_generator)\n\n    for i, arg in enumerate(matrices[:-1]):\n        ind_ranges[i] = arg.shape[1] - 1\n    matrices = [arg._entry(indices[i], indices[i+1], dummy_generator=dummy_generator) for i, arg in enumerate(matrices)]\n    expr_in_sum = Mul.fromiter(matrices)\n    if any(v.has(ImmutableMatrix) for v in matrices):\n        expand = True\n    result = coeff*Sum(\n            expr_in_sum,\n            *zip(indices[1:-1], [0]*len(ind_ranges), ind_ranges)\n        )\n\n    # Don't waste time in result.doit() if the sum bounds are symbolic\n    if not any(isinstance(v, (Integer, int)) for v in ind_ranges):\n        expand = False\n    return result.doit() if expand else result",
    "sympy.sympy.matrices.expressions.matmul.f": "def f():\n    counter = 1\n    while True:\n        yield Dummy(\"i_%i\" % counter)\n        counter += 1",
    "sympy.sympy.matrices.expressions.matpow._entry": "def _entry(self, i, j, **kwargs):\n    from sympy.matrices.expressions import MatMul\n    A = self.doit()\n    if isinstance(A, MatPow):\n        # We still have a MatPow, make an explicit MatMul out of it.\n        if A.exp.is_Integer and A.exp.is_positive:\n            A = MatMul(*[A.base for k in range(A.exp)])\n        elif not self._is_shape_symbolic():\n            return A._get_explicit_matrix()[i, j]\n        else:\n            # Leave the expression unevaluated:\n            from sympy.matrices.expressions.matexpr import MatrixElement\n            return MatrixElement(self, i, j)\n    return A[i, j]",
    "sympy.sympy.matrices.expressions.permutation._entry": "def _entry(self, i, j, **kwargs):\n    perm = self.args[0]\n    return KroneckerDelta(perm.apply(i), j)",
    "sympy.sympy.matrices.expressions.slice.__new__": "def __new__(cls, parent, rowslice, colslice):\n    rowslice = normalize(rowslice, parent.shape[0])\n    colslice = normalize(colslice, parent.shape[1])\n    if not (len(rowslice) == len(colslice) == 3):\n        raise IndexError()\n    if ((0 > rowslice[0]) == True or\n        (parent.shape[0] < rowslice[1]) == True or\n        (0 > colslice[0]) == True or\n        (parent.shape[1] < colslice[1]) == True):\n        raise IndexError()\n    if isinstance(parent, MatrixSlice):\n        return mat_slice_of_slice(parent, rowslice, colslice)\n    return Basic.__new__(cls, parent, Tuple(*rowslice), Tuple(*colslice))",
    "sympy.sympy.matrices.expressions.slice.shape": "@property\ndef shape(self):\n    rows = self.rowslice[1] - self.rowslice[0]\n    rows = rows if self.rowslice[2] == 1 else floor(rows/self.rowslice[2])\n    cols = self.colslice[1] - self.colslice[0]\n    cols = cols if self.colslice[2] == 1 else floor(cols/self.colslice[2])\n    return rows, cols",
    "sympy.sympy.matrices.expressions.slice._entry": "def _entry(self, i, j, **kwargs):\n    return self.parent._entry(i*self.rowslice[2] + self.rowslice[0],\n                              j*self.colslice[2] + self.colslice[0],\n                              **kwargs)",
    "sympy.sympy.matrices.expressions.special._entry": "def _entry(self, i, j, **kwargs):\n    return S.Zero",
    "sympy.sympy.matrices.expressions.special.shape": "@property\ndef shape(self):\n    return (self.args[0], self.args[1])",
    "sympy.sympy.matrices.expressions.transpose._entry": "def _entry(self, i, j, expand=False, **kwargs):\n    return self.arg._entry(j, i, expand=expand, **kwargs)",
    "sympy.sympy.utilities.misc.filldedent": "def filldedent(s, w=70, **kwargs):\n    \"\"\"\n    Strips leading and trailing empty lines from a copy of ``s``, then dedents,\n    fills and returns it.\n\n    Empty line stripping serves to deal with docstrings like this one that\n    start with a newline after the initial triple quote, inserting an empty\n    line at the beginning of the string.\n\n    Additional keyword arguments will be passed to ``textwrap.fill()``.\n\n    See Also\n    ========\n    strlines, rawlines\n\n    \"\"\"\n    return '\\n' + fill(dedent(str(s)).strip('\\n'), width=w, **kwargs)"
}