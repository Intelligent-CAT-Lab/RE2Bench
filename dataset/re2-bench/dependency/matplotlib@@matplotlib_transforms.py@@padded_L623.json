{
    "matplotlib.lib.matplotlib.transforms.get_points": "def get_points(self):\n    # docstring inherited\n    if self._invalid:\n        p = self._bbox.get_points()\n        # Transform all four points, then make a new bounding box\n        # from the result, taking care to make the orientation the\n        # same.\n        points = self._transform.transform(\n            [[p[0, 0], p[0, 1]],\n             [p[1, 0], p[0, 1]],\n             [p[0, 0], p[1, 1]],\n             [p[1, 0], p[1, 1]]])\n        points = np.ma.filled(points, 0.0)\n\n        xs = min(points[:, 0]), max(points[:, 0])\n        if p[0, 0] > p[1, 0]:\n            xs = xs[::-1]\n\n        ys = min(points[:, 1]), max(points[:, 1])\n        if p[0, 1] > p[1, 1]:\n            ys = ys[::-1]\n\n        self._points = np.array([\n            [xs[0], ys[0]],\n            [xs[1], ys[1]]\n        ])\n\n        self._invalid = 0\n    return self._points",
    "matplotlib.lib.matplotlib.transforms.__init__": "def __init__(self, points, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    points : `~numpy.ndarray`\n        A (2, 2) array of the form ``[[x0, y0], [x1, y1]]``.\n    \"\"\"\n    super().__init__(**kwargs)\n    points = np.asarray(points, float)\n    if points.shape != (2, 2):\n        raise ValueError('Bbox points must be of the form '\n                         '\"[[x0, y0], [x1, y1]]\".')\n    self._points = points\n    self._minpos = _default_minpos.copy()\n    self._ignore = True\n    # it is helpful in some contexts to know if the bbox is a\n    # default or has been mutated; we store the orig points to\n    # support the mutated methods\n    self._points_orig = self._points.copy()"
}