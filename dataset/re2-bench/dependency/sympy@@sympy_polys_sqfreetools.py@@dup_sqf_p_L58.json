{
    "sympy.sympy.polys.densebasic.dup_degree": "def dup_degree(f: dup[Er]) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``K[x]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_degree\n\n    >>> f = ZZ.map([1, 2, 0, 3])\n\n    >>> dup_degree(f)\n    3\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.densetools.dup_diff": "def dup_diff(f: dup[Er], m: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    ``m``-th order derivative of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_diff(x**3 + 2*x**2 + 3*x + 4, 1)\n    3*x**2 + 4*x + 3\n    >>> R.dup_diff(x**3 + 2*x**2 + 3*x + 4, 2)\n    6*x + 4\n\n    \"\"\"\n    if m <= 0:\n        return f\n\n    n = dup_degree(f)\n\n    if n < m:\n        return []\n\n    deriv: list[Er] = []\n\n    if m == 1:\n        for coeff in f[:-m]:\n            deriv.append(K(n)*coeff)\n            n -= 1\n    else:\n        for coeff in f[:-m]:\n            k = n\n\n            for i in range(n - 1, n - m, -1):\n                k *= i\n\n            deriv.append(K(k)*coeff)\n            n -= 1\n\n    return dup_strip(deriv, K)",
    "sympy.sympy.polys.euclidtools.dup_gcd": "def dup_gcd(f, g, K):\n    \"\"\"\n    Computes polynomial GCD of `f` and `g` in `K[x]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_gcd(x**2 - 1, x**2 - 3*x + 2)\n    x - 1\n\n    \"\"\"\n    return dup_inner_gcd(f, g, K)[0]"
}