{
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils._encode._map_to_integer": "def _map_to_integer(values, uniques):\n    \"\"\"Map values based on its position in uniques.\"\"\"\n    xp, _ = get_namespace(values, uniques)\n    table = _nandict({val: i for i, val in enumerate(uniques)})\n    return xp.asarray([table[v] for v in values], device=device(values))",
    "scikit-learn.sklearn.utils._encode._check_unknown": "def _check_unknown(values, known_values, return_mask=False):\n    \"\"\"\n    Helper function to check for unknowns in values to be encoded.\n\n    Uses pure python method for object dtype, and numpy method for\n    all other dtypes.\n\n    Parameters\n    ----------\n    values : array\n        Values to check for unknowns.\n    known_values : array\n        Known values. Must be unique.\n    return_mask : bool, default=False\n        If True, return a mask of the same shape as `values` indicating\n        the valid values.\n\n    Returns\n    -------\n    diff : list\n        The unique values present in `values` and not in `know_values`.\n    valid_mask : boolean array\n        Additionally returned if ``return_mask=True``.\n\n    \"\"\"\n    xp, _ = get_namespace(values, known_values)\n    valid_mask = None\n\n    if not xp.isdtype(values.dtype, \"numeric\"):\n        values_set = set(values)\n        values_set, missing_in_values = _extract_missing(values_set)\n\n        uniques_set = set(known_values)\n        uniques_set, missing_in_uniques = _extract_missing(uniques_set)\n        diff = values_set - uniques_set\n\n        nan_in_diff = missing_in_values.nan and not missing_in_uniques.nan\n        none_in_diff = missing_in_values.none and not missing_in_uniques.none\n\n        def is_valid(value):\n            return (\n                value in uniques_set\n                or (missing_in_uniques.none and value is None)\n                or (missing_in_uniques.nan and is_scalar_nan(value))\n            )\n\n        if return_mask:\n            if diff or nan_in_diff or none_in_diff:\n                valid_mask = xp.array([is_valid(value) for value in values])\n            else:\n                valid_mask = xp.ones(len(values), dtype=xp.bool)\n\n        diff = list(diff)\n        if none_in_diff:\n            diff.append(None)\n        if nan_in_diff:\n            diff.append(np.nan)\n    else:\n        unique_values = xp.unique_values(values)\n        diff = xpx.setdiff1d(unique_values, known_values, assume_unique=True, xp=xp)\n        if return_mask:\n            if diff.size:\n                valid_mask = _isin(values, known_values, xp)\n            else:\n                valid_mask = xp.ones(len(values), dtype=xp.bool)\n\n        # check for nans in the known_values\n        if xp.any(xp.isnan(known_values)):\n            diff_is_nan = xp.isnan(diff)\n            if xp.any(diff_is_nan):\n                # removes nan from valid_mask\n                if diff.size and return_mask:\n                    is_nan = xp.isnan(values)\n                    valid_mask[is_nan] = 1\n\n                # remove nan from diff\n                diff = diff[~diff_is_nan]\n        diff = list(diff)\n\n    if return_mask:\n        return diff, valid_mask\n    return diff"
}