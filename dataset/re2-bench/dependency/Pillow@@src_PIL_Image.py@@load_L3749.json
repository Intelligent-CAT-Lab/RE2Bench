{
    "Pillow.src.PIL.TiffImagePlugin.__init__": "def __init__(self, ifh=b\"II\\052\\0\\0\\0\\0\\0\", prefix=None, group=None):\n    \"\"\"Initialize an ImageFileDirectory.\n\n    To construct an ImageFileDirectory from a real file, pass the 8-byte\n    magic header to the constructor.  To only set the endianness, pass it\n    as the 'prefix' keyword argument.\n\n    :param ifh: One of the accepted magic headers (cf. PREFIXES); also sets\n          endianness.\n    :param prefix: Override the endianness of the file.\n    \"\"\"\n    if not _accept(ifh):\n        msg = f\"not a TIFF file (header {repr(ifh)} not valid)\"\n        raise SyntaxError(msg)\n    self._prefix = prefix if prefix is not None else ifh[:2]\n    if self._prefix == MM:\n        self._endian = \">\"\n    elif self._prefix == II:\n        self._endian = \"<\"\n    else:\n        msg = \"not a TIFF IFD\"\n        raise SyntaxError(msg)\n    self._bigtiff = ifh[2] == 43\n    self.group = group\n    self.tagtype = {}\n    \"\"\" Dictionary of tag types \"\"\"\n    self.reset()\n    (self.next,) = (\n        self._unpack(\"Q\", ifh[8:]) if self._bigtiff else self._unpack(\"L\", ifh[4:])\n    )\n    self._legacy_api = False",
    "Pillow.src.PIL.TiffImagePlugin.load": "def load(self, fp):\n    self.reset()\n    self._offset = fp.tell()\n\n    try:\n        tag_count = (\n            self._unpack(\"Q\", self._ensure_read(fp, 8))\n            if self._bigtiff\n            else self._unpack(\"H\", self._ensure_read(fp, 2))\n        )[0]\n        for i in range(tag_count):\n            tag, typ, count, data = (\n                self._unpack(\"HHQ8s\", self._ensure_read(fp, 20))\n                if self._bigtiff\n                else self._unpack(\"HHL4s\", self._ensure_read(fp, 12))\n            )\n\n            tagname = TiffTags.lookup(tag, self.group).name\n            typname = TYPES.get(typ, \"unknown\")\n            msg = f\"tag: {tagname} ({tag}) - type: {typname} ({typ})\"\n\n            try:\n                unit_size, handler = self._load_dispatch[typ]\n            except KeyError:\n                logger.debug(\"%s - unsupported type %s\", msg, typ)\n                continue  # ignore unsupported type\n            size = count * unit_size\n            if size > (8 if self._bigtiff else 4):\n                here = fp.tell()\n                (offset,) = self._unpack(\"Q\" if self._bigtiff else \"L\", data)\n                msg += f\" Tag Location: {here} - Data Location: {offset}\"\n                fp.seek(offset)\n                data = ImageFile._safe_read(fp, size)\n                fp.seek(here)\n            else:\n                data = data[:size]\n\n            if len(data) != size:\n                warnings.warn(\n                    \"Possibly corrupt EXIF data.  \"\n                    f\"Expecting to read {size} bytes but only got {len(data)}.\"\n                    f\" Skipping tag {tag}\"\n                )\n                logger.debug(msg)\n                continue\n\n            if not data:\n                logger.debug(msg)\n                continue\n\n            self._tagdata[tag] = data\n            self.tagtype[tag] = typ\n\n            msg += \" - value: \" + (\n                \"<table: %d bytes>\" % size if size > 32 else repr(data)\n            )\n            logger.debug(msg)\n\n        (self.next,) = (\n            self._unpack(\"Q\", self._ensure_read(fp, 8))\n            if self._bigtiff\n            else self._unpack(\"L\", self._ensure_read(fp, 4))\n        )\n    except OSError as msg:\n        warnings.warn(str(msg))\n        return"
}