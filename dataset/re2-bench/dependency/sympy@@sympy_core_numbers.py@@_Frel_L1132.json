{
    "sympy.sympy.core.basic.is_comparable": "@property\ndef is_comparable(self):\n    \"\"\"Return True if self can be computed to a real number\n    (or already is a real number) with precision, else False.\n\n    Examples\n    ========\n\n    >>> from sympy import exp_polar, pi, I\n    >>> (I*exp_polar(I*pi/2)).is_comparable\n    True\n    >>> (I*exp_polar(I*pi*2)).is_comparable\n    False\n\n    A False result does not mean that `self` cannot be rewritten\n    into a form that would be comparable. For example, the\n    difference computed below is zero but without simplification\n    it does not evaluate to a zero with precision:\n\n    >>> e = 2**pi*(1 + 2**pi)\n    >>> dif = e - e.expand()\n    >>> dif.is_comparable\n    False\n    >>> dif.n(2)._prec\n    1\n\n    \"\"\"\n    return self._eval_is_comparable()",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    return other is S.Infinity or other == float('inf')",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)"
}