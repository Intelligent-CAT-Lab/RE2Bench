{
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.exprtools._monotonic_sign": "def _monotonic_sign(self):\n    \"\"\"Return the value closest to 0 that ``self`` may have if all symbols\n    are signed and the result is uniformly the same sign for all values of symbols.\n    If a symbol is only signed but not known to be an\n    integer or the result is 0 then a symbol representative of the sign of self\n    will be returned. Otherwise, None is returned if a) the sign could be positive\n    or negative or b) self is not in one of the following forms:\n\n    - L(x, y, ...) + A: a function linear in all symbols x, y, ... with an\n      additive constant; if A is zero then the function can be a monomial whose\n      sign is monotonic over the range of the variables, e.g. (x + 1)**3 if x is\n      nonnegative.\n    - A/L(x, y, ...) + B: the inverse of a function linear in all symbols x, y, ...\n      that does not have a sign change from positive to negative for any set\n      of values for the variables.\n    - M(x, y, ...) + A: a monomial M whose factors are all signed and a constant, A.\n    - A/M(x, y, ...) + B: the inverse of a monomial and constants A and B.\n    - P(x): a univariate polynomial\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import _monotonic_sign as F\n    >>> from sympy import Dummy\n    >>> nn = Dummy(integer=True, nonnegative=True)\n    >>> p = Dummy(integer=True, positive=True)\n    >>> p2 = Dummy(integer=True, positive=True)\n    >>> F(nn + 1)\n    1\n    >>> F(p - 1)\n    _nneg\n    >>> F(nn*p + 1)\n    1\n    >>> F(p2*p + 1)\n    2\n    >>> F(nn - 1)  # could be negative, zero or positive\n    \"\"\"\n    if not self.is_extended_real:\n        return\n\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return Integer(3)\n            else:\n                return Integer(2)\n        elif s.is_composite:\n            if s.is_odd:\n                return Integer(9)\n            else:\n                return Integer(4)\n        elif s.is_positive:\n            if s.is_even:\n                if s.is_prime is False:\n                    return Integer(4)\n                else:\n                    return Integer(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_extended_negative:\n            if s.is_even:\n                return Integer(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:\n            return S.Zero\n        return None\n\n    # univariate polynomial\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 in (_eps, -_eps):\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    currentroots = []\n                else:\n                    try:\n                        currentroots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        currentroots = [r for r in roots(d, x) if r.is_extended_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all(\n                        (r - x0).is_nonpositive for r in currentroots):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all(\n                        (r - x0).is_nonnegative for r in currentroots):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n*den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n\n    # multivariate\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        # F/A or A/F where A is a number and F is a signed, rational monomial\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (\n                a.is_Mul or a.is_Pow) and \\\n                a.is_rational and \\\n                all(p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow) and \\\n                (a.is_positive or a.is_negative):\n            v = S.One\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        # signed linear expression\n        if not any(p for p in a.atoms(Pow) if not p.is_number) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)"
}