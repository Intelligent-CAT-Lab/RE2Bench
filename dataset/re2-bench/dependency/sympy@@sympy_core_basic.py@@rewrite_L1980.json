{
    "sympy.sympy.core.basic.<genexpr>": "pattern = tuple(p for p in pattern if self.has(p))\n",
    "sympy.sympy.core.basic._rewrite": "def _rewrite(self, pattern, rule, method, **hints):\n    deep = hints.pop('deep', True)\n    if deep:\n        args = [a._rewrite(pattern, rule, method, **hints)\n                for a in self.args]\n    else:\n        args = self.args\n    if not pattern or any(isinstance(self, p) for p in pattern):\n        meth = getattr(self, method, None)\n        if meth is not None:\n            rewritten = meth(*args, **hints)\n        else:\n            rewritten = self._eval_rewrite(rule, args, **hints)\n        if rewritten is not None:\n            return rewritten\n    if not args:\n        return self\n    return self.func(*args)",
    "sympy.sympy.utilities.iterables.iterable": "def iterable(i, exclude=(str, dict, NotIterable)):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is SymPy iterable.\n    True also indicates that the iterator is finite, e.g. you can\n    call list(...) on the instance.\n\n    When SymPy is working with iterables, it is almost always assuming\n    that the iterable is not a string or a mapping, so those are excluded\n    by default. If you want a pure Python definition, make exclude=None. To\n    exclude multiple items, pass them as a tuple.\n\n    You can also set the _iterable attribute to True or False on your class,\n    which will override the checks here, including the exclude test.\n\n    As a rule of thumb, some SymPy functions use this to check if they should\n    recursively map over an object. If an object is technically iterable in\n    the Python sense but does not desire this behavior (e.g., because its\n    iteration is not finite, or because iteration might induce an unwanted\n    computation), it should disable it by setting the _iterable attribute to False.\n\n    See also: is_sequence\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import iterable\n    >>> from sympy import Tuple\n    >>> things = [[1], (1,), set([1]), Tuple(1), (j for j in [1, 2]), {1:2}, '1', 1]\n    >>> for i in things:\n    ...     print('%s %s' % (iterable(i), type(i)))\n    True <... 'list'>\n    True <... 'tuple'>\n    True <... 'set'>\n    True <class 'sympy.core.containers.Tuple'>\n    True <... 'generator'>\n    False <... 'dict'>\n    False <... 'str'>\n    False <... 'int'>\n\n    >>> iterable({}, exclude=None)\n    True\n    >>> iterable({}, exclude=str)\n    True\n    >>> iterable(\"no\", exclude=str)\n    False\n\n    \"\"\"\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True"
}