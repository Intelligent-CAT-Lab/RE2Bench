{
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.conjugate": "def conjugate(self):\n    \"\"\"Returns the complex conjugate of 'self'.\"\"\"\n    from sympy.functions.elementary.complexes import conjugate as c\n    return c(self)",
    "sympy.sympy.core.expr.as_real_imag": "def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:\n    \"\"\"Performs complex expansion on 'self' and returns a tuple\n       containing collected both real and imaginary parts. This\n       method cannot be confused with re() and im() functions,\n       which does not perform complex expansion at evaluation.\n\n       However it is possible to expand both re() and im()\n       functions and get exactly the same results as with\n       a single call to this function.\n\n       >>> from sympy import symbols, I\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> (x + y*I).as_real_imag()\n       (x, y)\n\n       >>> from sympy.abc import z, w\n\n       >>> (z + w*I).as_real_imag()\n       (re(z) - im(w), re(w) + im(z))\n\n    \"\"\"\n    if hints.get('ignore') == self:\n        return None  # type: ignore\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.function.expand_mul": "def expand_mul(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False,\n    power_base=False, basic=False, multinomial=False, log=False)",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.NegativeOne",
    "sympy.sympy.core.power.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if self.exp.is_Integer:\n        from sympy.polys.polytools import poly\n\n        exp = self.exp\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n        if not im_e:\n            return self, S.Zero\n        a, b = symbols('a b', cls=Dummy)\n        if exp >= 0:\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial(self.base**exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly(\n                (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp\n        else:\n            mag = re_e**2 + im_e**2\n            re_e, im_e = re_e/mag, -im_e/mag\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial((re_e + im_e*S.ImaginaryUnit)**-exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly((a + b)**-exp)\n\n        # Terms with even b powers will be real\n        r = [i for i in expr.terms() if not i[0][1] % 2]\n        re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        # Terms with odd b powers will be imaginary\n        r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n        im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n        im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n\n        return (re_part.subs({a: re_e, b: S.ImaginaryUnit*im_e}),\n        im_part1.subs({a: re_e, b: im_e}) + im_part3.subs({a: re_e, b: -im_e}))\n\n    from sympy.functions.elementary.trigonometric import atan2, cos, sin\n\n    if self.exp.is_Rational:\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n\n        if im_e.is_zero and self.exp is S.Half:\n            if re_e.is_extended_nonnegative:\n                return self, S.Zero\n            if re_e.is_extended_nonpositive:\n                return S.Zero, (-self.base)**self.exp\n\n        # XXX: This is not totally correct since for x**(p/q) with\n        #      x being imaginary there are actually q roots, but\n        #      only a single one is returned from here.\n        r = self.func(self.func(re_e, 2) + self.func(im_e, 2), S.Half)\n\n        t = atan2(im_e, re_e)\n\n        rp, tp = self.func(r, self.exp), t*self.exp\n\n        return rp*cos(tp), rp*sin(tp)\n    elif self.base is S.Exp1:\n        from sympy.functions.elementary.exponential import exp\n        re_e, im_e = self.exp.as_real_imag()\n        if deep:\n            re_e = re_e.expand(deep, **hints)\n            im_e = im_e.expand(deep, **hints)\n        c, s = cos(im_e), sin(im_e)\n        return exp(re_e)*c, exp(re_e)*s\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        if deep:\n            hints['complex'] = False\n\n            expanded = self.expand(deep, **hints)\n            if hints.get('ignore') == expanded:\n                return None\n            else:\n                return (re(expanded), im(expanded))\n        else:\n            return re(self), im(self)",
    "sympy.sympy.core.symbol.as_real_imag": "def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:\n    # XXX: Remove the ignore flag\n    if hints.get('ignore') == self:\n        return None # type: ignore\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    "sympy.sympy.functions.elementary.complexes.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return the imaginary part with a zero real part.\n\n    \"\"\"\n    return (self, S.Zero)",
    "sympy.sympy.functions.elementary.exponential.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Returns this function as a complex coordinate.\n\n    Examples\n    ========\n\n    >>> from sympy import I, log\n    >>> from sympy.abc import x\n    >>> log(x).as_real_imag()\n    (log(Abs(x)), arg(x))\n    >>> log(I).as_real_imag()\n    (0, pi/2)\n    >>> log(1 + I).as_real_imag()\n    (log(sqrt(2)), pi/4)\n    >>> log(I*x).as_real_imag()\n    (log(Abs(x)), arg(I*x))\n\n    \"\"\"\n    sarg = self.args[0]\n    if deep:\n        sarg = self.args[0].expand(deep, **hints)\n    sarg_abs = Abs(sarg)\n    if sarg_abs == sarg:\n        return self, S.Zero\n    sarg_arg = arg(sarg)\n    if hints.get('log', False):  # Expand the log\n        hints['complex'] = False\n        return (log(sarg_abs).expand(deep, **hints), sarg_arg)\n    else:\n        return log(sarg_abs), sarg_arg",
    "sympy.sympy.functions.elementary.hyperbolic.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if self.args[0].is_extended_real:\n        if deep:\n            hints['complex'] = False\n            return (self.expand(deep, **hints), S.Zero)\n        else:\n            return (self, S.Zero)\n    if deep:\n        re, im = self.args[0].expand(deep, **hints).as_real_imag()\n    else:\n        re, im = self.args[0].as_real_imag()\n    denom = sinh(re)**2 + cos(im)**2\n    return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)",
    "sympy.sympy.functions.elementary.trigonometric.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.hyperbolic import cosh, sinh\n    re, im = self._as_real_imag(deep=deep, **hints)\n    return (cos(re)*cosh(im), -sin(re)*sinh(im))"
}