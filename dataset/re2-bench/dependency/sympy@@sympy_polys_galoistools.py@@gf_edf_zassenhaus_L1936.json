{
    "sympy.sympy.polys.galoistools.gf_pow_mod": "def gf_pow_mod(\n    f: dup[MPZ], n: MPZ | int, g: dup[MPZ], p: MPZ, K: Domain[MPZ]\n) -> dup[MPZ]:\n    \"\"\"\n    Compute ``f**n`` in ``GF(p)[x]/(g)`` using repeated squaring.\n\n    Given polynomials ``f`` and ``g`` in ``GF(p)[x]`` and a non-negative\n    integer ``n``, efficiently computes ``f**n (mod g)`` i.e. the remainder\n    of ``f**n`` from division by ``g``, using the repeated squaring algorithm.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_pow_mod\n\n    >>> gf_pow_mod(ZZ.map([3, 2, 4]), 3, ZZ.map([1, 1]), 5, ZZ)\n    []\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    if not n:\n        return [K.one]\n    elif n == 1:\n        return gf_rem(f, g, p, K)\n    elif n == 2:\n        return gf_rem(gf_sqr(f, p, K), g, p, K)\n\n    h = [K.one]\n\n    while True:\n        if n & 1:\n            h = gf_mul(h, f, p, K)\n            h = gf_rem(h, g, p, K)\n            n -= 1\n\n        n >>= 1\n\n        if not n:\n            break\n\n        f = gf_sqr(f, p, K)\n        f = gf_rem(f, g, p, K)\n\n    return h",
    "sympy.sympy.polys.galoistools.gf_gcd": "def gf_gcd(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Euclidean Algorithm in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_gcd\n\n    >>> gf_gcd(ZZ.map([3, 2, 4]), ZZ.map([2, 2, 3]), 5, ZZ)\n    [1, 3]\n\n    \"\"\"\n    while g:\n        f, g = g, gf_rem(f, g, p, K)\n\n    return gf_monic(f, p, K)[1]",
    "sympy.sympy.polys.galoistools.gf_random": "def gf_random(n: int, p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Generate a random polynomial in ``GF(p)[x]`` of degree ``n``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_random\n    >>> gf_random(10, 5, ZZ) #doctest: +SKIP\n    [1, 2, 3, 2, 1, 1, 1, 2, 0, 4, 2]\n\n    \"\"\"\n    pi = int(p)\n    return [K.one] + [K(int(uniform(0, pi))) for i in range(0, n)]",
    "sympy.sympy.polys.galoistools.gf_degree": "def gf_degree(f: dup[MPZ]) -> int:\n    \"\"\"\n    Return the leading degree of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_degree\n\n    >>> gf_degree([1, 1, 2, 0])\n    3\n    >>> gf_degree([])\n    -1\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.galoistools.gf_edf_zassenhaus": "def gf_edf_zassenhaus(f: dup[MPZ], n: int, p: MPZ, K: Domain[MPZ]) -> list[dup[MPZ]]:\n    \"\"\"\n    Cantor-Zassenhaus: Probabilistic Equal Degree Factorization\n\n    Given a monic square-free polynomial ``f`` in ``GF(p)[x]`` and\n    an integer ``n``, such that ``n`` divides ``deg(f)``, returns all\n    irreducible factors ``f_1,...,f_d`` of ``f``, each of degree ``n``.\n    EDF procedure gives complete factorization over Galois fields.\n\n    Consider the square-free polynomial ``f = x**3 + x**2 + x + 1`` in\n    ``GF(5)[x]``. Let's compute its irreducible factors of degree one::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_edf_zassenhaus\n\n       >>> gf_edf_zassenhaus([1,1,1,1], 1, 5, ZZ)\n       [[1, 1], [1, 2], [1, 3]]\n\n    Notes\n    =====\n\n    The case p == 2 is handled by Cohen's Algorithm 3.4.8. The case p odd is\n    as in Geddes Algorithm 8.9 (or Cohen's Algorithm 3.4.6).\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n    .. [2] [Geddes92]_ Algorithm 8.9\n    .. [3] [Cohen93]_ Algorithm 3.4.8\n\n    \"\"\"\n    factors = [f]\n\n    if gf_degree(f) <= n:\n        return factors\n\n    N = gf_degree(f) // n\n    if p != 2:\n        b = gf_frobenius_monomial_base(f, p, K)\n\n    t = [K.one, K.zero]\n    while len(factors) < N:\n        if p == 2:\n            h = r = t\n\n            for i in range(n - 1):\n                r = gf_pow_mod(r, 2, f, p, K)\n                h = gf_add(h, r, p, K)\n\n            g = gf_gcd(f, h, p, K)\n            t += [K.zero, K.zero]\n        else:\n            r = gf_random(2 * n - 1, p, K)\n            h = _gf_pow_pnm1d2(r, n, f, b, p, K)\n            g = gf_gcd(f, gf_sub_ground(h, K.one, p, K), p, K)\n\n        if g != [K.one] and g != f:\n            factors = gf_edf_zassenhaus(g, n, p, K) + gf_edf_zassenhaus(\n                gf_quo(f, g, p, K), n, p, K\n            )\n\n    return _sort_factors_single(factors)",
    "sympy.sympy.polys.galoistools.gf_sub_ground": "def gf_sub_ground(f: dup[MPZ], a: MPZ, p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Compute ``f - a`` where ``f`` in ``GF(p)[x]`` and ``a`` in ``GF(p)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sub_ground\n\n    >>> gf_sub_ground([3, 2, 4], 2, 5, ZZ)\n    [3, 2, 2]\n\n    \"\"\"\n    if not f:\n        a = -a % p\n    else:\n        a = (f[-1] - a) % p\n\n        if len(f) > 1:\n            return f[:-1] + [a]\n\n    if not a:\n        return []\n    else:\n        return [a]",
    "sympy.sympy.polys.galoistools.gf_add": "def gf_add(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Add polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_add\n\n    >>> gf_add([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [4, 1]\n\n    \"\"\"\n    if not f:\n        return g\n    if not g:\n        return f\n\n    df = gf_degree(f)\n    dg = gf_degree(g)\n\n    if df == dg:\n        return gf_strip([(a + b) % p for a, b in zip(f, g)])\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = g[:k], g[k:]\n\n        return h + [(a + b) % p for a, b in zip(f, g)]",
    "sympy.sympy.polys.galoistools.gf_quo": "def gf_quo(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Compute exact quotient in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_quo\n\n    >>> gf_quo(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n    [1, 1]\n    >>> gf_quo(ZZ.map([1, 0, 3, 2, 3]), ZZ.map([2, 2, 2]), 5, ZZ)\n    [3, 2, 4]\n\n    \"\"\"\n    df = gf_degree(f)\n    dg = gf_degree(g)\n\n    if not g:\n        raise ZeroDivisionError(\"polynomial division\")\n    elif df < dg:\n        return []\n\n    inv = K.invert(g[0], p)\n\n    h, dq, dr = f[:], df - dg, dg - 1\n\n    for i in range(0, dq + 1):\n        coeff = h[i]\n\n        for j in range(max(0, dg - i), min(df - i, dr) + 1):\n            coeff -= h[i + j - dg] * g[dg - j]\n\n        h[i] = (coeff * inv) % p\n\n    return h[: dq + 1]",
    "sympy.sympy.polys.galoistools.gf_frobenius_monomial_base": "def gf_frobenius_monomial_base(g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> list[dup[MPZ]]:\n    \"\"\"\n    return the list of ``x**(i*p) mod g in Z_p`` for ``i = 0, .., n - 1``\n    where ``n = gf_degree(g)``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_frobenius_monomial_base\n    >>> g = ZZ.map([1, 0, 2, 1])\n    >>> gf_frobenius_monomial_base(g, 5, ZZ)\n    [[1], [4, 4, 2], [1, 2]]\n\n    \"\"\"\n    n = gf_degree(g)\n    if n == 0:\n        return []\n    b = [[K.zero]] * n\n    b[0] = [K.one]\n    if p < n:\n        for i in range(1, n):\n            mon = gf_lshift(b[i - 1], p, K)\n            b[i] = gf_rem(mon, g, p, K)\n    elif n > 1:\n        b[1] = gf_pow_mod([K.one, K.zero], p, g, p, K)\n        for i in range(2, n):\n            b[i] = gf_mul(b[i - 1], b[1], p, K)\n            b[i] = gf_rem(b[i], g, p, K)\n\n    return b",
    "sympy.sympy.polys.galoistools._gf_pow_pnm1d2": "def _gf_pow_pnm1d2(\n    f: dup[MPZ], n: int, g: dup[MPZ], b: list[dup[MPZ]], p: MPZ, K: Domain[MPZ]\n) -> dup[MPZ]:\n    \"\"\"\n    utility function for ``gf_edf_zassenhaus``\n    Compute ``f**((p**n - 1) // 2)`` in ``GF(p)[x]/(g)``\n    ``f**((p**n - 1) // 2) = (f*f**p*...*f**(p**n - 1))**((p - 1) // 2)``\n    \"\"\"\n    f = gf_rem(f, g, p, K)\n    h = f\n    r = f\n    for i in range(1, n):\n        h = gf_frobenius_map(h, g, b, p, K)\n        r = gf_mul(r, h, p, K)\n        r = gf_rem(r, g, p, K)\n\n    res = gf_pow_mod(r, (p - 1) // 2, g, p, K)\n    return res",
    "sympy.sympy.polys.polyutils._sort_factors_single": "def _sort_factors_single(factors: list[dup[Er]]) -> list[dup[Er]]:\n    \"\"\"Sort factors of ordered domain. \"\"\"\n    return sorted(factors, key=lambda f: (len(f), f))"
}