{
    "sympy.sympy.polys.matrices.ddm.__init__": "def __init__(self, rowslist, shape, domain):\n    if not (isinstance(rowslist, list) and all(type(row) is list for row in rowslist)):\n        raise DMBadInputError(\"rowslist must be a list of lists\")\n    m, n = shape\n    if len(rowslist) != m or any(len(row) != n for row in rowslist):\n        raise DMBadInputError(\"Inconsistent row-list/shape\")\n\n    super().__init__([i.copy() for i in rowslist])\n    self.shape = (m, n)\n    self.rows = m\n    self.cols = n\n    self.domain = domain",
    "sympy.sympy.polys.matrices.ddm.to_ddm": "def to_ddm(self):\n    \"\"\"\n    Convert to a :class:`DDM`.\n\n    This just returns ``self`` but exists to parallel the corresponding\n    method in other matrix types like :class:`~.SDM`.\n\n    See Also\n    ========\n\n    to_sdm\n    to_dfm\n    to_dfm_or_ddm\n    sympy.polys.matrices.sdm.SDM.to_ddm\n    sympy.polys.matrices.domainmatrix.DomainMatrix.to_ddm\n    \"\"\"\n    return self",
    "sympy.sympy.polys.matrices.ddm.to_sdm": "def to_sdm(self):\n    \"\"\"\n    Convert to a :class:`~.SDM`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.ddm import DDM\n    >>> from sympy import QQ\n    >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n    >>> A.to_sdm()\n    {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n    >>> type(A.to_sdm())\n    <class 'sympy.polys.matrices.sdm.SDM'>\n\n    See Also\n    ========\n\n    SDM\n    sympy.polys.matrices.sdm.SDM.to_ddm\n    \"\"\"\n    return SDM.from_list(self, self.shape, self.domain)",
    "sympy.sympy.polys.matrices.dfm._supports_domain": "@classmethod\ndef _supports_domain(cls, domain):\n    return False",
    "sympy.sympy.polys.matrices.domainmatrix.from_rep": "@classmethod\ndef from_rep(cls, rep):\n    \"\"\"Create a new DomainMatrix efficiently from DDM/SDM.\n\n    Examples\n    ========\n\n    Create a :py:class:`~.DomainMatrix` with an dense internal\n    representation as :py:class:`~.DDM`:\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.ddm import DDM\n    >>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n    Create a :py:class:`~.DomainMatrix` with a sparse internal\n    representation as :py:class:`~.SDM`:\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import ZZ\n    >>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)\n\n    Parameters\n    ==========\n\n    rep: SDM or DDM\n        The internal sparse or dense representation of the matrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        A :py:class:`~.DomainMatrix` wrapping *rep*.\n\n    Notes\n    =====\n\n    This takes ownership of rep as its internal representation. If rep is\n    being mutated elsewhere then a copy should be provided to\n    ``from_rep``. Only minimal verification or checking is done on *rep*\n    as this is supposed to be an efficient internal routine.\n\n    \"\"\"\n    if not (isinstance(rep, (DDM, SDM)) or (DFM is not None and isinstance(rep, DFM))):\n        raise TypeError(\"rep should be of type DDM or SDM\")\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    "sympy.sympy.polys.matrices.sdm.to_ddm": "def to_ddm(M):\n    \"\"\"\n    Convert a :py:class:`~.SDM` object to a :py:class:`~.DDM` object\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import QQ\n    >>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n    >>> A.to_ddm()\n    [[0, 2], [0, 0]]\n\n    \"\"\"\n    return DDM(M.to_list(), M.shape, M.domain)",
    "sympy.sympy.polys.matrices.sdm.to_sdm": "def to_sdm(M):\n    \"\"\"\n    Convert to :py:class:`~.SDM` format (returns self).\n    \"\"\"\n    return M",
    "sympy.sympy.polys.matrices.sdm.__init__": "def __init__(self, elemsdict, shape, domain):\n    super().__init__(elemsdict)\n    self.shape = self.rows, self.cols = m, n = shape\n    self.domain = domain\n\n    if not all(0 <= r < m for r in self):\n        raise DMBadInputError(\"Row out of range\")\n    if not all(0 <= c < n for row in self.values() for c in row):\n        raise DMBadInputError(\"Column out of range\")"
}