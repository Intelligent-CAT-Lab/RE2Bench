{
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__abs__": "@staticmethod\ndef __abs__():\n    return S.Zero",
    "sympy.sympy.core.numbers.__ge__": "def __ge__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__le__(self)\n    rv = self._Frel(other, mlib.mpf_ge)\n    if rv is None:\n        return Expr.__ge__(self, other)\n    return rv",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__float__": "def __float__(self):\n    return mlib.to_float(self._as_mpf_val(53))",
    "sympy.sympy.core.numbers.__new__": "def __new__(cls, num, dps=None, precision=None):\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. '\n                         'Supply only one. ')\n\n    if isinstance(num, str):\n        _num = num = num.strip()  # Python ignores leading and trailing space\n        num = num.replace(' ', '_').lower()  # Float treats spaces as digit sep; E -> e\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n        elif num in ('inf', '+inf'):\n            return S.Infinity\n        elif num == '-inf':\n            return S.NegativeInfinity\n        elif num == 'nan':\n            return S.NaN\n        elif not _literal_float(num):\n            raise ValueError('string-float not recognized: %s' % _num)\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, float) and num == float('inf'):\n        return S.Infinity\n    elif isinstance(num, float) and num == float('-inf'):\n        return S.NegativeInfinity\n    elif isinstance(num, float) and math.isnan(num):\n        return S.NaN\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity or num is S.NegativeInfinity or num is S.NaN:\n        return num\n    elif _is_numpy_instance(num):  # support for numpy datatypes\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, str):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    # 12e3 is shorthand for int, not float;\n                    # 12.e3 would be the float version\n                    dps = max(dps, num_digits(num))\n                dps = max(15, dps)\n                precision = dps_to_prec(dps)\n    elif precision == '' and dps is None or precision is None and dps == '':\n        if not isinstance(num, str):\n            raise ValueError('The null string can only be used when '\n            'the number to Float is passed as a string or an integer.')\n        try:\n            Num = decimal.Decimal(num)\n        except decimal.InvalidOperation:\n            raise ValueError('string-float not recognized by Decimal: %s' % num)\n        else:\n            isint = '.' not in num\n            num, dps = _decimal_to_Rational_prec(Num)\n            if num.is_Integer and isint:\n                # without dec, e-notation is short for int\n                dps = max(dps, num_digits(num))\n                precision = dps_to_prec(dps)\n\n    # decimal precision(dps) is set and maybe binary precision(precision)\n    # as well.From here on binary precision is used to compute the Float.\n    # Hence, if supplied use binary precision else translate from decimal\n    # precision.\n\n    if precision is None or precision == '':\n        precision = dps_to_prec(dps)\n\n    precision = int(precision)\n\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, str):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            return S.NaN\n        elif num.is_infinite():\n            if num > 0:\n                return S.Infinity\n            return S.NegativeInfinity\n        else:\n            raise ValueError(\"unexpected decimal value %s\" % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if isinstance(num[1], str):\n            # it's a hexadecimal (coming from a pickled object)\n            num = list(num)\n            # If we're loading an object pickled in Python 2 into\n            # Python 3, we may need to strip a tailing 'L' because\n            # of a shim for int on Python 3, see issue #13470.\n            # Strip leading '0x' - gmpy2 only documents such inputs\n            # with base prefix as valid when the 2nd argument (base) is 0.\n            # When mpmath uses Sage as the backend, however, it\n            # ends up including '0x' when preparing the picklable tuple.\n            # See issue #19690.\n            num[1] = num[1].removeprefix('0x').removesuffix('L')\n            # Now we can assume that it is in standard form\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        else:\n            if len(num) == 4:\n                # handle normalization hack\n                return Float._new(num, precision)\n            else:\n                if not all((\n                        num[0] in (0, 1),\n                        num[1] >= 0,\n                        all(type(i) in (int, int) for i in num)\n                        )):\n                    raise ValueError('malformed mpf: %s' % (num,))\n                # don't compute number or else it may\n                # over/underflow\n                return Float._new(\n                    (num[0], num[1], num[2], num[1].bit_length()),\n                    precision)\n    elif isinstance(num, (Number, NumberSymbol)):\n        _mpf_ = num._as_mpf_val(precision)\n    else:\n        _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n\n    return cls._new(_mpf_, precision, zero=False)",
    "sympy.sympy.core.numbers.__ceil__": "def __ceil__(self):\n    return self.ceiling()",
    "sympy.sympy.core.singleton.__call__": "def __call__(self, a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    return sympify(a, locals=locals, convert_xor=convert_xor, strict=strict,\n                   rational=rational, evaluate=evaluate) # type: ignore",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False"
}