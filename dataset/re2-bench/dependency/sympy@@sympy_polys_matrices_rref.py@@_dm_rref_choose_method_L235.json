{
    "sympy.sympy.polys.matrices.rref._dm_rref_choose_method_QQ": "def _dm_rref_choose_method_QQ(M, *, denominator=False):\n    \"\"\"Choose the fastest method for computing RREF over QQ.\"\"\"\n    # The same sorts of considerations apply here as in the case of ZZ. Here\n    # though a new more significant consideration is what sort of denominators\n    # we have and what to do with them so we focus on that.\n\n    # First compute the density. This is the average number of non-zero entries\n    # per row but only counting rows that have at least one non-zero entry\n    # since RREF can ignore fully zero rows.\n    density, _, ncols = _dm_row_density(M)\n\n    # For sparse matrices use Gauss-Jordan elimination over QQ regardless.\n    if density < min(5, ncols/2):\n        return 'GJ'\n\n    # Compare the bit-length of the lcm of the denominators to the bit length\n    # of the numerators.\n    #\n    # The threshold here is empirical: we prefer rref over QQ if clearing\n    # denominators would result in a numerator matrix having 5x the bit size of\n    # the current numerators.\n    numers, denoms = _dm_QQ_numers_denoms(M)\n    numer_bits = max([n.bit_length() for n in numers], default=1)\n\n    denom_lcm = ZZ.one\n    for d in denoms:\n        denom_lcm = ZZ.lcm(denom_lcm, d)\n        if denom_lcm.bit_length() > 5*numer_bits:\n            return 'GJ'\n\n    # If we get here then the matrix is dense and the lcm of the denominators\n    # is not too large compared to the numerators. For particularly small\n    # denominators it is fastest just to clear them and use fraction-free\n    # Gauss-Jordan over ZZ. With very small denominators this is a little\n    # faster than using rref_den over QQ but there is an intermediate regime\n    # where rref_den over QQ is significantly faster. The small denominator\n    # case is probably very common because small fractions like 1/2 or 1/3 are\n    # often seen in user inputs.\n\n    if denom_lcm.bit_length() < 50:\n        return 'CD'\n    else:\n        return 'FF'",
    "sympy.sympy.polys.matrices.rref._dm_rref_choose_method_ZZ": "def _dm_rref_choose_method_ZZ(M, *, denominator=False):\n    \"\"\"Choose the fastest method for computing RREF over ZZ.\"\"\"\n    # In the extreme of very sparse matrices and low bit counts it is faster to\n    # use Gauss-Jordan elimination over QQ rather than fraction-free\n    # Gauss-Jordan over ZZ. In the opposite extreme of dense matrices and high\n    # bit counts it is faster to use fraction-free Gauss-Jordan over ZZ. These\n    # two extreme cases need to be handled differently because they lead to\n    # different asymptotic complexities. In between these two extremes we need\n    # a threshold for deciding which method to use. This threshold is\n    # determined empirically by timing the two methods with random matrices.\n\n    # The disadvantage of using empirical timings is that future optimisations\n    # might change the relative speeds so this can easily become out of date.\n    # The main thing is to get the asymptotic complexity right for the extreme\n    # cases though so the precise value of the threshold is hopefully not too\n    # important.\n\n    # Empirically determined parameter.\n    PARAM = 10000\n\n    # First compute the density. This is the average number of non-zero entries\n    # per row but only counting rows that have at least one non-zero entry\n    # since RREF can ignore fully zero rows.\n    density, nrows_nz, ncols = _dm_row_density(M)\n\n    # For small matrices use QQ if more than half the entries are zero.\n    if nrows_nz < 10:\n        if density < ncols/2:\n            return 'GJ'\n        else:\n            return 'FF'\n\n    # These are just shortcuts for the formula below.\n    if density < 5:\n        return 'GJ'\n    elif density > 5 + PARAM/nrows_nz:\n        return 'FF'  # pragma: no cover\n\n    # Maximum bitsize of any entry.\n    elements = _dm_elements(M)\n    bits = max([e.bit_length() for e in elements], default=1)\n\n    # Wideness parameter. This is 1 for square or tall matrices but >1 for wide\n    # matrices.\n    wideness = max(1, 2/3*ncols/nrows_nz)\n\n    max_density = (5 + PARAM/(nrows_nz*bits**2)) * wideness\n\n    if density < max_density:\n        return 'GJ'\n    else:\n        return 'FF'"
}