{
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.expr.as_real_imag": "def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:\n    \"\"\"Performs complex expansion on 'self' and returns a tuple\n       containing collected both real and imaginary parts. This\n       method cannot be confused with re() and im() functions,\n       which does not perform complex expansion at evaluation.\n\n       However it is possible to expand both re() and im()\n       functions and get exactly the same results as with\n       a single call to this function.\n\n       >>> from sympy import symbols, I\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> (x + y*I).as_real_imag()\n       (x, y)\n\n       >>> from sympy.abc import z, w\n\n       >>> (z + w*I).as_real_imag()\n       (re(z) - im(w), re(w) + im(z))\n\n    \"\"\"\n    if hints.get('ignore') == self:\n        return None  # type: ignore\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    eq = self.__eq__(other)\n    if eq is NotImplemented:\n        return eq\n    else:\n        return not eq",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    # NaN is structurally equal to another NaN\n    return other is S.NaN",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.power.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if self.exp.is_Integer:\n        from sympy.polys.polytools import poly\n\n        exp = self.exp\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n        if not im_e:\n            return self, S.Zero\n        a, b = symbols('a b', cls=Dummy)\n        if exp >= 0:\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial(self.base**exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly(\n                (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp\n        else:\n            mag = re_e**2 + im_e**2\n            re_e, im_e = re_e/mag, -im_e/mag\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial((re_e + im_e*S.ImaginaryUnit)**-exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly((a + b)**-exp)\n\n        # Terms with even b powers will be real\n        r = [i for i in expr.terms() if not i[0][1] % 2]\n        re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        # Terms with odd b powers will be imaginary\n        r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n        im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n        im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n\n        return (re_part.subs({a: re_e, b: S.ImaginaryUnit*im_e}),\n        im_part1.subs({a: re_e, b: im_e}) + im_part3.subs({a: re_e, b: -im_e}))\n\n    from sympy.functions.elementary.trigonometric import atan2, cos, sin\n\n    if self.exp.is_Rational:\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n\n        if im_e.is_zero and self.exp is S.Half:\n            if re_e.is_extended_nonnegative:\n                return self, S.Zero\n            if re_e.is_extended_nonpositive:\n                return S.Zero, (-self.base)**self.exp\n\n        # XXX: This is not totally correct since for x**(p/q) with\n        #      x being imaginary there are actually q roots, but\n        #      only a single one is returned from here.\n        r = self.func(self.func(re_e, 2) + self.func(im_e, 2), S.Half)\n\n        t = atan2(im_e, re_e)\n\n        rp, tp = self.func(r, self.exp), t*self.exp\n\n        return rp*cos(tp), rp*sin(tp)\n    elif self.base is S.Exp1:\n        from sympy.functions.elementary.exponential import exp\n        re_e, im_e = self.exp.as_real_imag()\n        if deep:\n            re_e = re_e.expand(deep, **hints)\n            im_e = im_e.expand(deep, **hints)\n        c, s = cos(im_e), sin(im_e)\n        return exp(re_e)*c, exp(re_e)*s\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        if deep:\n            hints['complex'] = False\n\n            expanded = self.expand(deep, **hints)\n            if hints.get('ignore') == expanded:\n                return None\n            else:\n                return (re(expanded), im(expanded))\n        else:\n            return re(self), im(self)"
}