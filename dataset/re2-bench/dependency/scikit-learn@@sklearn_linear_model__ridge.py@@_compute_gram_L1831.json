{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils.extmath.safe_sparse_dot": "def safe_sparse_dot(a, b, *, dense_output=False):\n    \"\"\"Dot product that handle the sparse matrix case correctly.\n\n    Parameters\n    ----------\n    a : {ndarray, sparse matrix}\n    b : {ndarray, sparse matrix}\n    dense_output : bool, default=False\n        When False, ``a`` and ``b`` both being sparse will yield sparse output.\n        When True, output will always be a dense array.\n\n    Returns\n    -------\n    dot_product : {ndarray, sparse matrix}\n        Sparse if ``a`` and ``b`` are sparse and ``dense_output=False``.\n\n    Examples\n    --------\n    >>> from scipy.sparse import csr_matrix\n    >>> from sklearn.utils.extmath import safe_sparse_dot\n    >>> X = csr_matrix([[1, 2], [3, 4], [5, 6]])\n    >>> dot_product = safe_sparse_dot(X, X.T)\n    >>> dot_product.toarray()\n    array([[ 5, 11, 17],\n           [11, 25, 39],\n           [17, 39, 61]])\n    \"\"\"\n    xp, _ = get_namespace(a, b)\n    if a.ndim > 2 or b.ndim > 2:\n        if sparse.issparse(a):\n            # sparse is always 2D. Implies b is 3D+\n            # [i, j] @ [k, ..., l, m, n] -> [i, k, ..., l, n]\n            b_ = np.rollaxis(b, -2)\n            b_2d = b_.reshape((b.shape[-2], -1))\n            ret = a @ b_2d\n            ret = ret.reshape(a.shape[0], *b_.shape[1:])\n        elif sparse.issparse(b):\n            # sparse is always 2D. Implies a is 3D+\n            # [k, ..., l, m] @ [i, j] -> [k, ..., l, j]\n            a_2d = a.reshape(-1, a.shape[-1])\n            ret = a_2d @ b\n            ret = ret.reshape(*a.shape[:-1], b.shape[1])\n        else:\n            # Alternative for `np.dot` when dealing with a or b having\n            # more than 2 dimensions, that works with the array api.\n            # If b is 1-dim then the last axis for b is taken otherwise\n            # if b is >= 2-dim then the second to last axis is taken.\n            b_axis = -1 if b.ndim == 1 else -2\n            ret = xp.tensordot(a, b, axes=[-1, b_axis])\n    elif (\n        dense_output\n        and a.ndim == 2\n        and b.ndim == 2\n        and a.dtype in (np.float32, np.float64)\n        and b.dtype in (np.float32, np.float64)\n        and (sparse.issparse(a) and a.format in (\"csc\", \"csr\"))\n        and (sparse.issparse(b) and b.format in (\"csc\", \"csr\"))\n    ):\n        # Use dedicated fast method for dense_C = sparse_A @\u00a0sparse_B\n        return sparse_matmul_to_dense(a, b)\n    else:\n        ret = a @ b\n\n    if (\n        sparse.issparse(a)\n        and sparse.issparse(b)\n        and dense_output\n        and hasattr(ret, \"toarray\")\n    ):\n        return ret.toarray()\n    return ret",
    "scikit-learn.sklearn.utils.sparsefuncs.mean_variance_axis": "def mean_variance_axis(X, axis, weights=None, return_sum_weights=False):\n    \"\"\"Compute mean and variance along an axis on a CSR or CSC matrix.\n\n    Parameters\n    ----------\n    X : sparse matrix of shape (n_samples, n_features)\n        Input data. It can be of CSR or CSC format.\n\n    axis : {0, 1}\n        Axis along which the axis should be computed.\n\n    weights : ndarray of shape (n_samples,) or (n_features,), default=None\n        If axis is set to 0 shape is (n_samples,) or\n        if axis is set to 1 shape is (n_features,).\n        If it is set to None, then samples are equally weighted.\n\n        .. versionadded:: 0.24\n\n    return_sum_weights : bool, default=False\n        If True, returns the sum of weights seen for each feature\n        if `axis=0` or each sample if `axis=1`.\n\n        .. versionadded:: 0.24\n\n    Returns\n    -------\n\n    means : ndarray of shape (n_features,), dtype=floating\n        Feature-wise means.\n\n    variances : ndarray of shape (n_features,), dtype=floating\n        Feature-wise variances.\n\n    sum_weights : ndarray of shape (n_features,), dtype=floating\n        Returned if `return_sum_weights` is `True`.\n\n    Examples\n    --------\n    >>> from sklearn.utils import sparsefuncs\n    >>> from scipy import sparse\n    >>> import numpy as np\n    >>> indptr = np.array([0, 3, 4, 4, 4])\n    >>> indices = np.array([0, 1, 2, 2])\n    >>> data = np.array([8, 1, 2, 5])\n    >>> scale = np.array([2, 3, 2])\n    >>> csr = sparse.csr_matrix((data, indices, indptr))\n    >>> csr.todense()\n    matrix([[8, 1, 2],\n            [0, 0, 5],\n            [0, 0, 0],\n            [0, 0, 0]])\n    >>> sparsefuncs.mean_variance_axis(csr, axis=0)\n    (array([2.  , 0.25, 1.75]), array([12.    ,  0.1875,  4.1875]))\n    \"\"\"\n    _raise_error_wrong_axis(axis)\n\n    if sp.issparse(X) and X.format == \"csr\":\n        if axis == 0:\n            return _csr_mean_var_axis0(\n                X, weights=weights, return_sum_weights=return_sum_weights\n            )\n        else:\n            return _csc_mean_var_axis0(\n                X.T, weights=weights, return_sum_weights=return_sum_weights\n            )\n    elif sp.issparse(X) and X.format == \"csc\":\n        if axis == 0:\n            return _csc_mean_var_axis0(\n                X, weights=weights, return_sum_weights=return_sum_weights\n            )\n        else:\n            return _csr_mean_var_axis0(\n                X.T, weights=weights, return_sum_weights=return_sum_weights\n            )\n    else:\n        _raise_typeerror(X)"
}