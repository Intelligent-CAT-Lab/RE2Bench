{
    "matplotlib.lib.matplotlib.cbook._compute_conf_interval": "def _compute_conf_interval(data, med, iqr, bootstrap):\n    if bootstrap is not None:\n        # Do a bootstrap estimate of notch locations.\n        # get conf. intervals around median\n        CI = _bootstrap_median(data, N=bootstrap)\n        notch_min = CI[0]\n        notch_max = CI[1]\n    else:\n\n        N = len(data)\n        notch_min = med - 1.57 * iqr / np.sqrt(N)\n        notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n    return notch_min, notch_max",
    "matplotlib.lib.matplotlib.cbook._reshape_2D": "def _reshape_2D(X, name):\n    \"\"\"\n    Use Fortran ordering to convert ndarrays and lists of iterables to lists of\n    1D arrays.\n\n    Lists of iterables are converted by applying `numpy.asanyarray` to each of\n    their elements.  1D ndarrays are returned in a singleton list containing\n    them.  2D ndarrays are converted to the list of their *columns*.\n\n    *name* is used to generate the error message for invalid inputs.\n    \"\"\"\n\n    # Unpack in case of e.g. Pandas or xarray object\n    X = _unpack_to_numpy(X)\n\n    # Iterate over columns for ndarrays.\n    if isinstance(X, np.ndarray):\n        X = X.transpose()\n\n        if len(X) == 0:\n            return [[]]\n        elif X.ndim == 1 and np.ndim(X[0]) == 0:\n            # 1D array of scalars: directly return it.\n            return [X]\n        elif X.ndim in [1, 2]:\n            # 2D array, or 1D array of iterables: flatten them first.\n            return [np.reshape(x, -1) for x in X]\n        else:\n            raise ValueError(f'{name} must have 2 or fewer dimensions')\n\n    # Iterate over list of iterables.\n    if len(X) == 0:\n        return [[]]\n\n    result = []\n    is_1d = True\n    for xi in X:\n        # check if this is iterable, except for strings which we\n        # treat as singletons.\n        if not isinstance(xi, str):\n            try:\n                iter(xi)\n            except TypeError:\n                pass\n            else:\n                is_1d = False\n        xi = np.asanyarray(xi)\n        nd = np.ndim(xi)\n        if nd > 1:\n            raise ValueError(f'{name} must have 2 or fewer dimensions')\n        result.append(xi.reshape(-1))\n\n    if is_1d:\n        # 1D array of scalars: directly return it.\n        return [np.reshape(result, -1)]\n    else:\n        # 2D array, or 1D array of iterables: use flattened version.\n        return result"
}