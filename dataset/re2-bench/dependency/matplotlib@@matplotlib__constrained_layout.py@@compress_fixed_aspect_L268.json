{
    "matplotlib.lib.matplotlib._layoutgrid.edit_margin_min": "def edit_margin_min(self, todo, size, cell=0):\n    \"\"\"\n    Change the minimum size of the margin for one cell.\n\n    Parameters\n    ----------\n    todo : string (one of 'left', 'right', 'bottom', 'top')\n        margin to alter.\n\n    size : float\n        Minimum size of the margin .  If it is larger than the\n        existing minimum it updates the margin size. Fraction of\n        figure size.\n\n    cell : int\n        Cell column or row to edit.\n    \"\"\"\n\n    if size > self.margin_vals[todo][cell]:\n        self.edit_margin(todo, size, cell)",
    "matplotlib.lib.matplotlib.axes._base.get_position": "def get_position(self, original=False):\n    \"\"\"\n    Return the position of the Axes within the figure as a `.Bbox`.\n\n    Parameters\n    ----------\n    original : bool\n        If ``True``, return the original position. Otherwise, return the\n        active position. For an explanation of the positions see\n        `.set_position`.\n\n    Returns\n    -------\n    `.Bbox`\n\n    \"\"\"\n    if original:\n        return self._originalPosition.frozen()\n    else:\n        locator = self.get_axes_locator()\n        if not locator:\n            self.apply_aspect()\n        return self._position.frozen()",
    "matplotlib.lib.matplotlib.axes._base.apply_aspect": "def apply_aspect(self, position=None):\n    \"\"\"\n    Adjust the Axes for a specified data aspect ratio.\n\n    Depending on `.get_adjustable` this will modify either the\n    Axes box (position) or the view limits. In the former case,\n    `~matplotlib.axes.Axes.get_anchor` will affect the position.\n\n    Parameters\n    ----------\n    position : None or .Bbox\n\n        .. note::\n            This parameter exists for historic reasons and is considered\n            internal. End users should not use it.\n\n        If not ``None``, this defines the position of the\n        Axes within the figure as a Bbox. See `~.Axes.get_position`\n        for further details.\n\n    Notes\n    -----\n    This is called automatically when each Axes is drawn.  You may need\n    to call it yourself if you need to update the Axes position and/or\n    view limits before the Figure is drawn.\n\n    An alternative with a broader scope is `.Figure.draw_without_rendering`,\n    which updates all stale components of a figure, not only the positioning /\n    view limits of a single Axes.\n\n    See Also\n    --------\n    matplotlib.axes.Axes.set_aspect\n        For a description of aspect ratio handling.\n    matplotlib.axes.Axes.set_adjustable\n        Set how the Axes adjusts to achieve the required aspect ratio.\n    matplotlib.axes.Axes.set_anchor\n        Set the position in case of extra space.\n    matplotlib.figure.Figure.draw_without_rendering\n        Update all stale components of a figure.\n\n    Examples\n    --------\n    A typical usage example would be the following. `~.Axes.imshow` sets the\n    aspect to 1, but adapting the Axes position and extent to reflect this is\n    deferred until rendering for performance reasons. If you want to know the\n    Axes size before, you need to call `.apply_aspect` to get the correct\n    values.\n\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(np.zeros((3, 3)))\n    >>> ax.bbox.width, ax.bbox.height\n    (496.0, 369.59999999999997)\n    >>> ax.apply_aspect()\n    >>> ax.bbox.width, ax.bbox.height\n    (369.59999999999997, 369.59999999999997)\n    \"\"\"\n    if position is None:\n        position = self.get_position(original=True)\n\n    aspect = self.get_aspect()\n\n    if aspect == 'auto' and self._box_aspect is None:\n        self._set_position(position, which='active')\n        return\n\n    trans = self.get_figure(root=False).transSubfigure\n    bb = mtransforms.Bbox.unit().transformed(trans)\n    # this is the physical aspect of the panel (or figure):\n    fig_aspect = bb.height / bb.width\n\n    if self._adjustable == 'box':\n        if self in self._twinned_axes:\n            raise RuntimeError(\"Adjustable 'box' is not allowed in a \"\n                               \"twinned Axes; use 'datalim' instead\")\n        box_aspect = aspect * self.get_data_ratio()\n        pb = position.frozen()\n        pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n        self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n        return\n\n    # The following is only seen if self._adjustable == 'datalim'\n    if self._box_aspect is not None:\n        pb = position.frozen()\n        pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)\n        self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n        if aspect == \"auto\":\n            return\n\n    # reset active to original in case it had been changed by prior use\n    # of 'box'\n    if self._box_aspect is None:\n        self._set_position(position, which='active')\n    else:\n        position = pb1.anchored(self.get_anchor(), pb)\n\n    x_trf = self.xaxis.get_transform()\n    y_trf = self.yaxis.get_transform()\n    xmin, xmax = x_trf.transform(self.get_xbound())\n    ymin, ymax = y_trf.transform(self.get_ybound())\n    xsize = max(abs(xmax - xmin), 1e-30)\n    ysize = max(abs(ymax - ymin), 1e-30)\n\n    box_aspect = fig_aspect * (position.height / position.width)\n    data_ratio = box_aspect / aspect\n\n    y_expander = data_ratio * xsize / ysize - 1\n    # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n    if abs(y_expander) < 0.005:\n        return\n\n    dL = self.dataLim\n    x0, x1 = x_trf.transform(dL.intervalx)\n    y0, y1 = y_trf.transform(dL.intervaly)\n    xr = 1.05 * (x1 - x0)\n    yr = 1.05 * (y1 - y0)\n\n    xmarg = xsize - xr\n    ymarg = ysize - yr\n    Ysize = data_ratio * xsize\n    Xsize = ysize / data_ratio\n    Xmarg = Xsize - xr\n    Ymarg = Ysize - yr\n    # Setting these targets to, e.g., 0.05*xr does not seem to help.\n    xm = 0\n    ym = 0\n\n    shared_x = self in self._shared_axes[\"x\"]\n    shared_y = self in self._shared_axes[\"y\"]\n\n    if shared_x and shared_y:\n        raise RuntimeError(\"set_aspect(..., adjustable='datalim') or \"\n                           \"axis('equal') are not allowed when both axes \"\n                           \"are shared.  Try set_aspect(..., \"\n                           \"adjustable='box').\")\n\n    # If y is shared, then we are only allowed to change x, etc.\n    if shared_y:\n        adjust_y = False\n    else:\n        if xmarg > xm and ymarg > ym:\n            adjy = ((Ymarg > 0 and y_expander < 0) or\n                    (Xmarg < 0 and y_expander > 0))\n        else:\n            adjy = y_expander > 0\n        adjust_y = shared_x or adjy  # (Ymarg > xmarg)\n\n    if adjust_y:\n        yc = 0.5 * (ymin + ymax)\n        y0 = yc - Ysize / 2.0\n        y1 = yc + Ysize / 2.0\n        if not self.get_autoscaley_on():\n            _log.warning(\"Ignoring fixed y limits to fulfill fixed data aspect \"\n                         \"with adjustable data limits.\")\n        self.set_ybound(y_trf.inverted().transform([y0, y1]))\n    else:\n        xc = 0.5 * (xmin + xmax)\n        x0 = xc - Xsize / 2.0\n        x1 = xc + Xsize / 2.0\n        if not self.get_autoscalex_on():\n            _log.warning(\"Ignoring fixed x limits to fulfill fixed data aspect \"\n                         \"with adjustable data limits.\")\n        self.set_xbound(x_trf.inverted().transform([x0, x1]))",
    "matplotlib.lib.matplotlib.axes._base.get_subplotspec": "def get_subplotspec(self):\n    \"\"\"Return the `.SubplotSpec` associated with the subplot, or None.\"\"\"\n    return self._subplotspec",
    "matplotlib.lib.matplotlib.figure.axes": "@property\ndef axes(self):\n    \"\"\"\n    List of Axes in the Figure. You can access and modify the Axes in the\n    Figure through this list.\n\n    Do not modify the list itself. Instead, use `~Figure.add_axes`,\n    `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.\n\n    Note: The `.Figure.axes` property and `~.Figure.get_axes` method are\n    equivalent.\n    \"\"\"\n    return self._axstack.as_list()",
    "matplotlib.lib.matplotlib.gridspec.get_gridspec": "def get_gridspec(self):\n    return self._gridspec",
    "matplotlib.lib.matplotlib.gridspec.rowspan": "@property\ndef rowspan(self):\n    \"\"\"The rows spanned by this subplot, as a `range` object.\"\"\"\n    ncols = self.get_gridspec().ncols\n    return range(self.num1 // ncols, self.num2 // ncols + 1)",
    "matplotlib.lib.matplotlib.gridspec.colspan": "@property\ndef colspan(self):\n    \"\"\"The columns spanned by this subplot, as a `range` object.\"\"\"\n    ncols = self.get_gridspec().ncols\n    # We explicitly support num2 referring to a column on num1's *left*, so\n    # we must sort the column indices here so that the range makes sense.\n    c1, c2 = sorted([self.num1 % ncols, self.num2 % ncols])\n    return range(c1, c2 + 1)",
    "matplotlib.lib.matplotlib.gridspec.<lambda>": "ncols = property(lambda self: self._ncols,\n                 doc=\"The number of columns in the grid.\")\n\n",
    "matplotlib.lib.matplotlib.transforms.width": "@property\ndef width(self):\n    \"\"\"The (signed) width of the bounding box.\"\"\"\n    points = self.get_points()\n    return points[1, 0] - points[0, 0]",
    "matplotlib.lib.matplotlib.transforms.height": "@property\ndef height(self):\n    \"\"\"The (signed) height of the bounding box.\"\"\"\n    points = self.get_points()\n    return points[1, 1] - points[0, 1]"
}