{
    "scikit-learn.sklearn.pipeline.__getitem__": "def __getitem__(self, ind):\n    \"\"\"Returns a sub-pipeline or a single estimator in the pipeline\n\n    Indexing with an integer will return an estimator; using a slice\n    returns another Pipeline instance which copies a slice of this\n    Pipeline. This copy is shallow: modifying (or fitting) estimators in\n    the sub-pipeline will affect the larger pipeline and vice-versa.\n    However, replacing a value in `step` will not affect a copy.\n\n    See\n    :ref:`sphx_glr_auto_examples_feature_selection_plot_feature_selection_pipeline.py`\n    for an example of how to use slicing to inspect part of a pipeline.\n    \"\"\"\n    if isinstance(ind, slice):\n        if ind.step not in (1, None):\n            raise ValueError(\"Pipeline slicing only supports a step of 1\")\n        return self.__class__(\n            self.steps[ind], memory=self.memory, verbose=self.verbose\n        )\n    try:\n        name, est = self.steps[ind]\n    except TypeError:\n        # Not an int, try get step by name\n        return self.named_steps[ind]\n    return est",
    "scikit-learn.sklearn.pipeline.<dictcomp>": "transform_params = {\n    key: value\n    for key, value in all_params.items()\n    if key\n    in sub_metadata_routing.consumes(\n        method=\"transform\", params=all_params.keys()\n    )\n",
    "scikit-learn.sklearn.pipeline._cached_transform": "def _cached_transform(\n    sub_pipeline, *, cache, param_name, param_value, transform_params\n):\n    \"\"\"Transform a parameter value using a sub-pipeline and cache the result.\n\n    Parameters\n    ----------\n    sub_pipeline : Pipeline\n        The sub-pipeline to be used for transformation.\n    cache : dict\n        The cache dictionary to store the transformed values.\n    param_name : str\n        The name of the parameter to be transformed.\n    param_value : object\n        The value of the parameter to be transformed.\n    transform_params : dict\n        The metadata to be used for transformation. This passed to the\n        `transform` method of the sub-pipeline.\n\n    Returns\n    -------\n    transformed_value : object\n        The transformed value of the parameter.\n    \"\"\"\n    if param_name not in cache:\n        # If the parameter is a tuple, transform each element of the\n        # tuple. This is needed to support the pattern present in\n        # `lightgbm` and `xgboost` where users can pass multiple\n        # validation sets.\n        if isinstance(param_value, tuple):\n            cache[param_name] = tuple(\n                sub_pipeline.transform(element, **transform_params)\n                for element in param_value\n            )\n        else:\n            cache[param_name] = sub_pipeline.transform(param_value, **transform_params)\n\n    return cache[param_name]",
    "scikit-learn.sklearn.utils._bunch.__init__": "def __init__(self, **kwargs):\n    super().__init__(kwargs)\n\n    # Map from deprecated key to warning message\n    self.__dict__[\"_deprecated_key_to_warnings\"] = {}",
    "scikit-learn.sklearn.utils._metadata_requests.get_routing_for_object": "def get_routing_for_object(obj=None):\n    \"\"\"Get a ``Metadata{Router, Request}`` instance from the given object.\n\n    This function returns a\n    :class:`~sklearn.utils.metadata_routing.MetadataRouter` or a\n    :class:`~sklearn.utils.metadata_routing.MetadataRequest` from the given input.\n\n    This function always returns a copy or an instance constructed from the\n    input, such that changing the output of this function will not change the\n    original object.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    obj : object\n        - If the object provides a `get_metadata_routing` method, return a copy\n            of the output of that method.\n        - If the object is already a\n            :class:`~sklearn.utils.metadata_routing.MetadataRequest` or a\n            :class:`~sklearn.utils.metadata_routing.MetadataRouter`, return a copy\n            of that.\n        - Returns an empty :class:`~sklearn.utils.metadata_routing.MetadataRequest`\n            otherwise.\n\n    Returns\n    -------\n    obj : MetadataRequest or MetadataRouter\n        A ``MetadataRequest`` or a ``MetadataRouter`` taken or created from\n        the given object.\n    \"\"\"\n    # doing this instead of a try/except since an AttributeError could be raised\n    # for other reasons.\n    if hasattr(obj, \"get_metadata_routing\"):\n        return deepcopy(obj.get_metadata_routing())\n\n    elif getattr(obj, \"_type\", None) in [\"metadata_request\", \"metadata_router\"]:\n        return deepcopy(obj)\n\n    return MetadataRequest(owner=None)"
}