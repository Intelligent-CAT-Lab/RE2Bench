{
    "sympy.sympy.polys.euclidtools.dup_inner_gcd": "def dup_inner_gcd(f, g, K):\n    \"\"\"\n    Computes polynomial GCD and cofactors of `f` and `g` in `K[x]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_inner_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    \"\"\"\n    # XXX: This used to check for K.is_Exact but leads to awkward results when\n    # the domain is something like RR[z] e.g.:\n    #\n    # >>> g, p, q = Poly(1, x).cancel(Poly(51.05*x*y - 1.0, x))\n    # >>> g\n    # 1.0\n    # >>> p\n    # Poly(17592186044421.0, x, domain='RR[y]')\n    # >>> q\n    # Poly(898081097567692.0*y*x - 17592186044421.0, x, domain='RR[y]'))\n    #\n    # Maybe it would be better to flatten into multivariate polynomials first.\n    if K.is_RR or K.is_CC:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return [K.one], f, g\n\n        f = dup_convert(f, K, exact)\n        g = dup_convert(g, K, exact)\n\n        h, cff, cfg = dup_inner_gcd(f, g, exact)\n\n        h = dup_convert(h, exact, K)\n        cff = dup_convert(cff, exact, K)\n        cfg = dup_convert(cfg, exact, K)\n\n        return h, cff, cfg\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dup_qq_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dup_ff_prs_gcd(f, g, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dup_zz_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dup_rr_prs_gcd(f, g, K)"
}