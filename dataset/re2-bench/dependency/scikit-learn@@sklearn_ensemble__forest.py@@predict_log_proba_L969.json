{
    "scikit-learn.sklearn.ensemble._forest.predict_proba": "def predict_proba(self, X):\n    \"\"\"\n    Predict class probabilities for X.\n\n    The predicted class probabilities of an input sample are computed as\n    the mean predicted class probabilities of the trees in the forest.\n    The class probability of a single tree is the fraction of samples of\n    the same class in a leaf.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The input samples. Internally, its dtype will be converted to\n        ``dtype=np.float32``. If a sparse matrix is provided, it will be\n        converted into a sparse ``csr_matrix``.\n\n    Returns\n    -------\n    p : ndarray of shape (n_samples, n_classes), or a list of such arrays\n        The class probabilities of the input samples. The order of the\n        classes corresponds to that in the attribute :term:`classes_`.\n    \"\"\"\n    check_is_fitted(self)\n    # Check data\n    X = self._validate_X_predict(X)\n\n    # Assign chunk of trees to jobs\n    n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)\n\n    # avoid storing the output of every estimator by summing them here\n    all_proba = [\n        np.zeros((X.shape[0], j), dtype=np.float64)\n        for j in np.atleast_1d(self.n_classes_)\n    ]\n    lock = threading.Lock()\n    Parallel(n_jobs=n_jobs, verbose=self.verbose, require=\"sharedmem\")(\n        delayed(_accumulate_prediction)(e.predict_proba, X, all_proba, lock)\n        for e in self.estimators_\n    )\n\n    for proba in all_proba:\n        proba /= len(self.estimators_)\n\n    if len(all_proba) == 1:\n        return all_proba[0]\n    else:\n        return all_proba"
}