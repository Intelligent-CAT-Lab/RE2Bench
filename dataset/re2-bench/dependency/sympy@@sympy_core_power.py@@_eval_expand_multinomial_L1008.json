{
    "sympy.sympy.core.add._all_nonneg_or_nonppos": "def _all_nonneg_or_nonppos(self):\n    nn = np = 0\n    for a in self.args:\n        if a.is_nonnegative:\n            if np:\n                return False\n            nn = 1\n        elif a.is_nonpositive:\n            if nn:\n                return False\n            np = 1\n        else:\n            break\n    else:\n        return True",
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.function.expand_mul": "def expand_mul(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False,\n    power_base=False, basic=False, multinomial=False, log=False)",
    "sympy.sympy.core.function.expand_multinomial": "def expand_multinomial(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the multinomial hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_multinomial, exp\n    >>> x, y = symbols('x y', positive=True)\n    >>> expand_multinomial((x + exp(x + 1))**2)\n    x**2 + 2*x*exp(x + 1) + exp(2*x + 2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=False, power_exp=False,\n    power_base=False, basic=False, multinomial=True, log=False)",
    "sympy.sympy.core.numbers.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p + self.p*other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.operations._from_args": "@classmethod\ndef _from_args(cls, args, is_commutative=None):\n    \"\"\"Create new instance with already-processed args.\n    If the args are not in canonical order, then a non-canonical\n    result will be returned, so use with caution. The order of\n    args may change if the sign of the args is changed.\"\"\"\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and(a.is_commutative for a in args)\n    obj.is_commutative = is_commutative\n    return obj",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power._eval_expand_multinomial": "def _eval_expand_multinomial(self, **hints):\n    \"\"\"(a + b + ..)**n -> a**n + n*a**(n-1)*b + .., n is nonzero integer\"\"\"\n\n    base, exp = self.args\n    result = self\n\n    if exp.is_Rational and exp.p > 0 and base.is_Add:\n        if not exp.is_Integer:\n            n = Integer(exp.p // exp.q)\n\n            if not n:\n                return result\n            else:\n                radical, result = self.func(base, exp - n), []\n\n                expanded_base_n = self.func(base, n)\n                if expanded_base_n.is_Pow:\n                    expanded_base_n = \\\n                        expanded_base_n._eval_expand_multinomial()\n                for term in Add.make_args(expanded_base_n):\n                    result.append(term*radical)\n\n                return Add(*result)\n\n        n = int(exp)\n\n        if base.is_commutative:\n            order_terms, other_terms = [], []\n\n            for b in base.args:\n                if b.is_Order:\n                    order_terms.append(b)\n                else:\n                    other_terms.append(b)\n\n            if order_terms:\n                # (f(x) + O(x^n))^m -> f(x)^m + m*f(x)^{m-1} *O(x^n)\n                f = Add(*other_terms)\n                o = Add(*order_terms)\n\n                if n == 2:\n                    return expand_multinomial(f**n, deep=False) + n*f*o\n                else:\n                    g = expand_multinomial(f**(n - 1), deep=False)\n                    return expand_mul(f*g, deep=False) + n*g*o\n\n            if base.is_number:\n                # Efficiently expand expressions of the form (a + b*I)**n\n                # where 'a' and 'b' are real numbers and 'n' is integer.\n                a, b = base.as_real_imag()\n\n                if a.is_Rational and b.is_Rational:\n                    if not a.is_Integer:\n                        if not b.is_Integer:\n                            k = self.func(a.q * b.q, n)\n                            a, b = a.p*b.q, a.q*b.p\n                        else:\n                            k = self.func(a.q, n)\n                            a, b = a.p, a.q*b\n                    elif not b.is_Integer:\n                        k = self.func(b.q, n)\n                        a, b = a*b.q, b.p\n                    else:\n                        k = 1\n\n                    a, b, c, d = int(a), int(b), 1, 0\n\n                    while n:\n                        if n & 1:\n                            c, d = a*c - b*d, b*c + a*d\n                            n -= 1\n                        a, b = a*a - b*b, 2*a*b\n                        n //= 2\n\n                    I = S.ImaginaryUnit\n\n                    if k == 1:\n                        return c + I*d\n                    else:\n                        return Integer(c)/k + I*d/k\n\n            p = other_terms\n            # (x + y)**3 -> x**3 + 3*x**2*y + 3*x*y**2 + y**3\n            # in this particular example:\n            # p = [x,y]; n = 3\n            # so now it's easy to get the correct result -- we get the\n            # coefficients first:\n            from sympy.ntheory.multinomial import multinomial_coefficients\n            from sympy.polys.polyutils import basic_from_dict\n            expansion_dict = multinomial_coefficients(len(p), n)\n            # in our example: {(3, 0): 1, (1, 2): 3, (0, 3): 1, (2, 1): 3}\n            # and now construct the expression.\n            return basic_from_dict(expansion_dict, *p)\n        else:\n            if n == 2:\n                return Add(*[f*g for f in base.args for g in base.args])\n            else:\n                multi = (base**(n - 1))._eval_expand_multinomial()\n                if multi.is_Add:\n                    return Add(*[f*g for f in base.args\n                        for g in multi.args])\n                else:\n                    # XXX can this ever happen if base was an Add?\n                    return Add(*[f*multi for f in base.args])\n    elif (exp.is_Rational and exp.p < 0 and base.is_Add and\n            abs(exp.p) > exp.q):\n        return 1 / self.func(base, -exp)._eval_expand_multinomial()\n    elif exp.is_Add and base.is_Number and (hints.get('force', False) or\n            base.is_zero is False or exp._all_nonneg_or_nonppos()):\n        #  a + b      a  b\n        #  n      --> n  n, where n, a, b are Numbers\n        # XXX should be in expand_power_exp?\n        coeff, tail = [], []\n        for term in exp.args:\n            if term.is_Number:\n                coeff.append(self.func(base, term))\n            else:\n                tail.append(term)\n        return Mul(*(coeff + [self.func(base, Add._from_args(tail))]))\n    else:\n        return result",
    "sympy.sympy.core.power.<listcomp>": "return Add(*[f*g for f in base.args\n    for g in multi.args])\n",
    "sympy.sympy.ntheory.multinomial.multinomial_coefficients": "def multinomial_coefficients(m, n):\n    r\"\"\"Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\n    where ``C_kn`` are multinomial coefficients such that\n    ``n=k1+k2+..+km``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import multinomial_coefficients\n    >>> multinomial_coefficients(2, 5) # indirect doctest\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\n\n    Notes\n    =====\n\n    The algorithm is based on the following result:\n\n    .. math::\n        \\binom{n}{k_1, \\ldots, k_m} =\n        \\frac{k_1 + 1}{n - k_1} \\sum_{i=2}^m \\binom{n}{k_1 + 1, \\ldots, k_i - 1, \\ldots}\n\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\n    of the author.\n\n    See Also\n    ========\n\n    binomial_coefficients_list, binomial_coefficients\n    \"\"\"\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2*n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0  # j will be the leftmost nonzero position\n    else:\n        j = m\n    # enumerate tuples in co-lex order\n    while j < m - 1:\n        # compute next tuple\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        # compute the value\n        # NB: the initialization of v was done above\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = (v * tj) // (n - t[0])\n    return r",
    "sympy.sympy.polys.polyutils.expr_from_dict": "def expr_from_dict(rep, *gens):\n    \"\"\"Convert a multinomial form into an expression. \"\"\"\n    result = []\n\n    for monom, coeff in rep.items():\n        term = [coeff]\n        for g, m in zip(gens, monom):\n            if m:\n                term.append(Pow(g, m))\n\n        result.append(Mul(*term))\n\n    return Add(*result)"
}