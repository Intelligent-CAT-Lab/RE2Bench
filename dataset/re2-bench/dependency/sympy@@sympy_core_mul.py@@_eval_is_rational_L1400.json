{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.logic._fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    \"\"\"Return True if all args are True, None if there is any None else False\n    unless ``quick_exit`` is True (then return None as soon as a second False\n    is seen.\n\n     ``_fuzzy_group`` is like ``fuzzy_and`` except that it is more\n    conservative in returning a False, waiting to make sure that all\n    arguments are True or False and returning None if any arguments are\n    None. It also has the capability of permiting only a single False and\n    returning None if more than one is seen. For example, the presence of a\n    single transcendental amongst rationals would indicate that the group is\n    no longer rational; but a second transcendental in the group would make the\n    determination impossible.\n\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import _fuzzy_group\n\n    By default, multiple Falses mean the group is broken:\n\n    >>> _fuzzy_group([False, False, True])\n    False\n\n    If multiple Falses mean the group status is unknown then set\n    `quick_exit` to True so None can be returned when the 2nd False is seen:\n\n    >>> _fuzzy_group([False, False, True], quick_exit=True)\n\n    But if only a single False is seen then the group is known to\n    be broken:\n\n    >>> _fuzzy_group([False, True, True], quick_exit=True)\n    False\n\n    \"\"\"\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    "sympy.sympy.core.mul.<genexpr>": "if all(a.is_zero is False for a in self.args):\n    return False\n\n",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}