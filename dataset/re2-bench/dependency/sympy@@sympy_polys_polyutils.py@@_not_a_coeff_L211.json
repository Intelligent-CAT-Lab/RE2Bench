{
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.external.pythonmpq.__eq__": "def __eq__(self, other):\n    \"\"\"Compare equal with PythonMPQ, int, float, Decimal or Fraction\"\"\"\n    if isinstance(other, PythonMPQ):\n        return (self.numerator == other.numerator\n            and self.denominator == other.denominator)\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    "sympy.sympy.physics.vector.frame.__eq__": "def __eq__(self, other):\n    # Check if the other object is a CoordinateSym of the same frame and\n    # same index\n    if isinstance(other, CoordinateSym):\n        if other._id == self._id:\n            return True\n    return False",
    "sympy.sympy.polys.agca.extensions.__eq__": "def __eq__(f, g):\n    if isinstance(g, ExtElem):\n        return f.rep == g.rep and f.ext == g.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.agca.homomorphisms.__eq__": "def __eq__(self, oth):\n    try:\n        return (self - oth).is_zero()\n    except TypeError:\n        return False",
    "sympy.sympy.polys.agca.ideals.__eq__": "def __eq__(self, e):\n    if not isinstance(e, Ideal) or e.ring != self.ring:\n        return False\n    return self._equals(e)",
    "sympy.sympy.polys.agca.modules.__eq__": "def __eq__(self, om):\n    if not isinstance(om, self.__class__) or om.module != self.module:\n        try:\n            om = self.module.convert(om)\n        except CoercionFailed:\n            return False\n    return self.eq(self.data, om.data)",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(f, g):\n    return f.ex == f.__class__(g).ex",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, self.__class__):\n        return self.x == other.x and self.y == other.y\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__eq__": "def __eq__(self, other):\n    return self._compare(other, operator.eq)",
    "sympy.sympy.polys.domains.quotientring.__eq__": "def __eq__(self, om):\n    if not isinstance(om, self.__class__) or om.ring != self.ring:\n        return False\n    return self.ring.is_zero(self - om)",
    "sympy.sympy.polys.fields.__eq__": "def __eq__(f, g):\n    if isinstance(g, FracElement) and f.field == g.field:\n        return f.numer == g.numer and f.denom == g.denom\n    else:\n        return f.numer == g and f.denom == f.field.ring.one",
    "sympy.sympy.polys.matrices.domainmatrix.__eq__": "def __eq__(A, B):\n    r\"\"\"\n    Checks for two DomainMatrix matrices to be equal or not\n\n    Parameters\n    ==========\n\n    A, B: DomainMatrix\n        to check equality\n\n    Returns\n    =======\n\n    Boolean\n        True for equal, else False\n\n    Raises\n    ======\n\n    NotImplementedError\n        If B is not a DomainMatrix\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> B = DomainMatrix([\n    ...    [ZZ(1), ZZ(1)],\n    ...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n    >>> A.__eq__(A)\n    True\n    >>> A.__eq__(B)\n    False\n\n    \"\"\"\n    if not isinstance(A, type(B)):\n        return NotImplemented\n    return A.domain == B.domain and A.rep == B.rep",
    "sympy.sympy.polys.matrices.domainscalar.__eq__": "def __eq__(self, other):\n    if not isinstance(other, DomainScalar):\n        return NotImplemented\n    return self.element == other.element and self.domain == other.domain",
    "sympy.sympy.polys.polyclasses.__eq__": "def __eq__(f, g):\n    try:\n        F, G, _, _ = f.unify_ANP(g)\n    except UnificationFailed:\n        return NotImplemented\n    return F == G",
    "sympy.sympy.polys.puiseux.__eq__": "def __eq__(self, other: object) -> bool:\n    if isinstance(other, PuiseuxPoly):\n        return (\n            self.poly == other.poly\n            and self.monom == other.monom\n            and self.ns == other.ns\n        )\n    elif self.monom is None and self.ns is None:\n        return self.poly.__eq__(other)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.rings.__eq__": "def __eq__(self, other: object) -> bool:\n    \"\"\"Equality test for polynomials.\n\n    Examples\n    ========\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> p1 = (x + y)**2 + (x - y)**2\n    >>> p1 == 4*x*y\n    False\n    >>> p1 == 2*(x**2 + y**2)\n    True\n    \"\"\"\n    if not other:\n        return not self\n    elif self.ring.is_element(other):\n        return dict.__eq__(self, other)\n    elif len(self) > 1:\n        return False\n    else:\n        return self.get(self.ring.zero_monom) == other",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}