{
    "matplotlib.lib.matplotlib.cbook._safe_first_finite": "def _safe_first_finite(obj):\n    \"\"\"\n    Return the first finite element in *obj* if one is available and skip_nonfinite is\n    True. Otherwise, return the first element.\n\n    This is a method for internal use.\n\n    This is a type-independent way of obtaining the first finite element, supporting\n    both index access and the iterator protocol.\n    \"\"\"\n    def safe_isfinite(val):\n        if val is None:\n            return False\n        try:\n            return math.isfinite(val)\n        except (TypeError, ValueError):\n            # if the outer object is 2d, then val is a 1d array, and\n            # - math.isfinite(numpy.zeros(3)) raises TypeError\n            # - math.isfinite(torch.zeros(3)) raises ValueError\n            pass\n        try:\n            return np.isfinite(val) if np.isscalar(val) else True\n        except TypeError:\n            # This is something that NumPy cannot make heads or tails of,\n            # assume \"finite\"\n            return True\n\n    if isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not support generators as input\")\n    else:\n        for val in obj:\n            if safe_isfinite(val):\n                return val\n        return safe_first_element(obj)"
}