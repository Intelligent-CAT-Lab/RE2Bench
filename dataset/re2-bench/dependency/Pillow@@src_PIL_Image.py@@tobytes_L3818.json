{
    "Pillow.src.PIL.Image._get_head": "def _get_head(self):\n    version = b\"\\x2B\" if self.bigtiff else b\"\\x2A\"\n    if self.endian == \"<\":\n        head = b\"II\" + version + b\"\\x00\" + o32le(8)\n    else:\n        head = b\"MM\\x00\" + version + o32be(8)\n    if self.bigtiff:\n        head += o32le(8) if self.endian == \"<\" else o32be(8)\n        head += b\"\\x00\\x00\\x00\\x00\"\n    return head",
    "Pillow.src.PIL.Image.get_ifd": "def get_ifd(self, tag):\n    if tag not in self._ifds:\n        if tag == ExifTags.IFD.IFD1:\n            if self._info is not None and self._info.next != 0:\n                self._ifds[tag] = self._get_ifd_dict(self._info.next)\n        elif tag in [ExifTags.IFD.Exif, ExifTags.IFD.GPSInfo]:\n            offset = self._hidden_data.get(tag, self.get(tag))\n            if offset is not None:\n                self._ifds[tag] = self._get_ifd_dict(offset, tag)\n        elif tag in [ExifTags.IFD.Interop, ExifTags.IFD.Makernote]:\n            if ExifTags.IFD.Exif not in self._ifds:\n                self.get_ifd(ExifTags.IFD.Exif)\n            tag_data = self._ifds[ExifTags.IFD.Exif][tag]\n            if tag == ExifTags.IFD.Makernote:\n                from .TiffImagePlugin import ImageFileDirectory_v2\n\n                if tag_data[:8] == b\"FUJIFILM\":\n                    ifd_offset = i32le(tag_data, 8)\n                    ifd_data = tag_data[ifd_offset:]\n\n                    makernote = {}\n                    for i in range(0, struct.unpack(\"<H\", ifd_data[:2])[0]):\n                        ifd_tag, typ, count, data = struct.unpack(\n                            \"<HHL4s\", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]\n                        )\n                        try:\n                            (\n                                unit_size,\n                                handler,\n                            ) = ImageFileDirectory_v2._load_dispatch[typ]\n                        except KeyError:\n                            continue\n                        size = count * unit_size\n                        if size > 4:\n                            (offset,) = struct.unpack(\"<L\", data)\n                            data = ifd_data[offset - 12 : offset + size - 12]\n                        else:\n                            data = data[:size]\n\n                        if len(data) != size:\n                            warnings.warn(\n                                \"Possibly corrupt EXIF MakerNote data.  \"\n                                f\"Expecting to read {size} bytes but only got \"\n                                f\"{len(data)}. Skipping tag {ifd_tag}\"\n                            )\n                            continue\n\n                        if not data:\n                            continue\n\n                        makernote[ifd_tag] = handler(\n                            ImageFileDirectory_v2(), data, False\n                        )\n                    self._ifds[tag] = dict(self._fixup_dict(makernote))\n                elif self.get(0x010F) == \"Nintendo\":\n                    makernote = {}\n                    for i in range(0, struct.unpack(\">H\", tag_data[:2])[0]):\n                        ifd_tag, typ, count, data = struct.unpack(\n                            \">HHL4s\", tag_data[i * 12 + 2 : (i + 1) * 12 + 2]\n                        )\n                        if ifd_tag == 0x1101:\n                            # CameraInfo\n                            (offset,) = struct.unpack(\">L\", data)\n                            self.fp.seek(offset)\n\n                            camerainfo = {\"ModelID\": self.fp.read(4)}\n\n                            self.fp.read(4)\n                            # Seconds since 2000\n                            camerainfo[\"TimeStamp\"] = i32le(self.fp.read(12))\n\n                            self.fp.read(4)\n                            camerainfo[\"InternalSerialNumber\"] = self.fp.read(4)\n\n                            self.fp.read(12)\n                            parallax = self.fp.read(4)\n                            handler = ImageFileDirectory_v2._load_dispatch[\n                                TiffTags.FLOAT\n                            ][1]\n                            camerainfo[\"Parallax\"] = handler(\n                                ImageFileDirectory_v2(), parallax, False\n                            )\n\n                            self.fp.read(4)\n                            camerainfo[\"Category\"] = self.fp.read(2)\n\n                            makernote = {0x1101: dict(self._fixup_dict(camerainfo))}\n                    self._ifds[tag] = makernote\n            else:\n                # Interop\n                self._ifds[tag] = self._get_ifd_dict(tag_data, tag)\n    ifd = self._ifds.get(tag, {})\n    if tag == ExifTags.IFD.Exif and self._hidden_data:\n        ifd = {\n            k: v\n            for (k, v) in ifd.items()\n            if k not in (ExifTags.IFD.Interop, ExifTags.IFD.Makernote)\n        }\n    return ifd",
    "Pillow.src.PIL.TiffImagePlugin.__init__": "def __init__(self, ifh=b\"II\\052\\0\\0\\0\\0\\0\", prefix=None, group=None):\n    \"\"\"Initialize an ImageFileDirectory.\n\n    To construct an ImageFileDirectory from a real file, pass the 8-byte\n    magic header to the constructor.  To only set the endianness, pass it\n    as the 'prefix' keyword argument.\n\n    :param ifh: One of the accepted magic headers (cf. PREFIXES); also sets\n          endianness.\n    :param prefix: Override the endianness of the file.\n    \"\"\"\n    if not _accept(ifh):\n        msg = f\"not a TIFF file (header {repr(ifh)} not valid)\"\n        raise SyntaxError(msg)\n    self._prefix = prefix if prefix is not None else ifh[:2]\n    if self._prefix == MM:\n        self._endian = \">\"\n    elif self._prefix == II:\n        self._endian = \"<\"\n    else:\n        msg = \"not a TIFF IFD\"\n        raise SyntaxError(msg)\n    self._bigtiff = ifh[2] == 43\n    self.group = group\n    self.tagtype = {}\n    \"\"\" Dictionary of tag types \"\"\"\n    self.reset()\n    (self.next,) = (\n        self._unpack(\"Q\", ifh[8:]) if self._bigtiff else self._unpack(\"L\", ifh[4:])\n    )\n    self._legacy_api = False",
    "Pillow.src.PIL.TiffImagePlugin.__setitem__": "def __setitem__(self, tag, value):\n    self._setitem(tag, value, self.legacy_api)",
    "Pillow.src.PIL.TiffImagePlugin.tobytes": "def tobytes(self, offset=0):\n    # FIXME What about tagdata?\n    result = self._pack(\"H\", len(self._tags_v2))\n\n    entries = []\n    offset = offset + len(result) + len(self._tags_v2) * 12 + 4\n    stripoffsets = None\n\n    # pass 1: convert tags to binary format\n    # always write tags in ascending order\n    for tag, value in sorted(self._tags_v2.items()):\n        if tag == STRIPOFFSETS:\n            stripoffsets = len(entries)\n        typ = self.tagtype.get(tag)\n        logger.debug(\"Tag %s, Type: %s, Value: %s\", tag, typ, repr(value))\n        is_ifd = typ == TiffTags.LONG and isinstance(value, dict)\n        if is_ifd:\n            if self._endian == \"<\":\n                ifh = b\"II\\x2A\\x00\\x08\\x00\\x00\\x00\"\n            else:\n                ifh = b\"MM\\x00\\x2A\\x00\\x00\\x00\\x08\"\n            ifd = ImageFileDirectory_v2(ifh, group=tag)\n            values = self._tags_v2[tag]\n            for ifd_tag, ifd_value in values.items():\n                ifd[ifd_tag] = ifd_value\n            data = ifd.tobytes(offset)\n        else:\n            values = value if isinstance(value, tuple) else (value,)\n            data = self._write_dispatch[typ](self, *values)\n\n        tagname = TiffTags.lookup(tag, self.group).name\n        typname = \"ifd\" if is_ifd else TYPES.get(typ, \"unknown\")\n        msg = f\"save: {tagname} ({tag}) - type: {typname} ({typ})\"\n        msg += \" - value: \" + (\n            \"<table: %d bytes>\" % len(data) if len(data) >= 16 else str(values)\n        )\n        logger.debug(msg)\n\n        # count is sum of lengths for string and arbitrary data\n        if is_ifd:\n            count = 1\n        elif typ in [TiffTags.BYTE, TiffTags.ASCII, TiffTags.UNDEFINED]:\n            count = len(data)\n        else:\n            count = len(values)\n        # figure out if data fits into the entry\n        if len(data) <= 4:\n            entries.append((tag, typ, count, data.ljust(4, b\"\\0\"), b\"\"))\n        else:\n            entries.append((tag, typ, count, self._pack(\"L\", offset), data))\n            offset += (len(data) + 1) // 2 * 2  # pad to word\n\n    # update strip offset data to point beyond auxiliary data\n    if stripoffsets is not None:\n        tag, typ, count, value, data = entries[stripoffsets]\n        if data:\n            msg = \"multistrip support not yet implemented\"\n            raise NotImplementedError(msg)\n        value = self._pack(\"L\", self._unpack(\"L\", value)[0] + offset)\n        entries[stripoffsets] = tag, typ, count, value, data\n\n    # pass 2: write entries to file\n    for tag, typ, count, value, data in entries:\n        logger.debug(\"%s %s %s %s %s\", tag, typ, count, repr(value), repr(data))\n        result += self._pack(\"HHL4s\", tag, typ, count, value)\n\n    # -- overwrite here for multi-page --\n    result += b\"\\0\\0\\0\\0\"  # end of entries\n\n    # pass 3: write auxiliary data to file\n    for tag, typ, count, value, data in entries:\n        result += data\n        if len(data) & 1:\n            result += b\"\\0\"\n\n    return result"
}