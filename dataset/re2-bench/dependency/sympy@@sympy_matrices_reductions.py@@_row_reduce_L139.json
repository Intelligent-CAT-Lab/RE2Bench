{
    "sympy.sympy.matrices.common._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    return cls(*args, **kwargs)",
    "sympy.sympy.matrices.common.__getitem__": "def __getitem__(self, key):\n    def _normalize_slices(row_slice, col_slice):\n        \"\"\"Ensure that row_slice and col_slice do not have\n        `None` in their arguments.  Any integers are converted\n        to slices of length 1\"\"\"\n        if not isinstance(row_slice, slice):\n            row_slice = slice(row_slice, row_slice + 1, None)\n        row_slice = slice(*row_slice.indices(self.rows))\n\n        if not isinstance(col_slice, slice):\n            col_slice = slice(col_slice, col_slice + 1, None)\n        col_slice = slice(*col_slice.indices(self.cols))\n\n        return (row_slice, col_slice)\n\n    def _coord_to_index(i, j):\n        \"\"\"Return the index in _mat corresponding\n        to the (i,j) position in the matrix. \"\"\"\n        return i * self.cols + j\n\n    if isinstance(key, tuple):\n        i, j = key\n        if isinstance(i, slice) or isinstance(j, slice):\n            # if the coordinates are not slices, make them so\n            # and expand the slices so they don't contain `None`\n            i, j = _normalize_slices(i, j)\n\n            rowsList, colsList = list(range(self.rows))[i], \\\n                                 list(range(self.cols))[j]\n            indices = (i * self.cols + j for i in rowsList for j in\n                       colsList)\n            return self._new(len(rowsList), len(colsList),\n                             [self.mat[i] for i in indices])\n\n        # if the key is a tuple of ints, change\n        # it to an array index\n        key = _coord_to_index(i, j)\n    return self.mat[key]",
    "sympy.sympy.matrices.common.__len__": "def __len__(self):\n    return self.rows*self.cols",
    "sympy.sympy.matrices.immutable._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    if len(args) == 1 and isinstance(args[0], ImmutableDenseMatrix):\n        return args[0]\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.matrixbase.__len__": "def __len__(self) -> int:\n    \"\"\"Return the number of elements of ``self``.\n\n    Implemented mainly so bool(Matrix()) == False.\n    \"\"\"\n    return self.rows * self.cols",
    "sympy.sympy.matrices.reductions._row_reduce_list": "def _row_reduce_list(mat, rows, cols, one, iszerofunc, simpfunc,\n                normalize_last=True, normalize=True, zero_above=True):\n    \"\"\"Row reduce a flat list representation of a matrix and return a tuple\n    (rref_matrix, pivot_cols, swaps) where ``rref_matrix`` is a flat list,\n    ``pivot_cols`` are the pivot columns and ``swaps`` are any row swaps that\n    were used in the process of row reduction.\n\n    Parameters\n    ==========\n\n    mat : list\n        list of matrix elements, must be ``rows`` * ``cols`` in length\n\n    rows, cols : integer\n        number of rows and columns in flat list representation\n\n    one : SymPy object\n        represents the value one, from ``Matrix.one``\n\n    iszerofunc : determines if an entry can be used as a pivot\n\n    simpfunc : used to simplify elements and test if they are\n        zero if ``iszerofunc`` returns `None`\n\n    normalize_last : indicates where all row reduction should\n        happen in a fraction-free manner and then the rows are\n        normalized (so that the pivots are 1), or whether\n        rows should be normalized along the way (like the naive\n        row reduction algorithm)\n\n    normalize : whether pivot rows should be normalized so that\n        the pivot value is 1\n\n    zero_above : whether entries above the pivot should be zeroed.\n        If ``zero_above=False``, an echelon matrix will be returned.\n    \"\"\"\n\n    def get_col(i):\n        return mat[i::cols]\n\n    def row_swap(i, j):\n        mat[i*cols:(i + 1)*cols], mat[j*cols:(j + 1)*cols] = \\\n            mat[j*cols:(j + 1)*cols], mat[i*cols:(i + 1)*cols]\n\n    def cross_cancel(a, i, b, j):\n        \"\"\"Does the row op row[i] = a*row[i] - b*row[j]\"\"\"\n        q = (j - i)*cols\n        for p in range(i*cols, (i + 1)*cols):\n            mat[p] = isimp(a*mat[p] - b*mat[p + q])\n\n    isimp = _get_intermediate_simp(_dotprodsimp)\n    piv_row, piv_col = 0, 0\n    pivot_cols = []\n    swaps = []\n\n    # use a fraction free method to zero above and below each pivot\n    while piv_col < cols and piv_row < rows:\n        pivot_offset, pivot_val, \\\n        assumed_nonzero, newly_determined = _find_reasonable_pivot(\n                get_col(piv_col)[piv_row:], iszerofunc, simpfunc)\n\n        # _find_reasonable_pivot may have simplified some things\n        # in the process.  Let's not let them go to waste\n        for (offset, val) in newly_determined:\n            offset += piv_row\n            mat[offset*cols + piv_col] = val\n\n        if pivot_offset is None:\n            piv_col += 1\n            continue\n\n        pivot_cols.append(piv_col)\n        if pivot_offset != 0:\n            row_swap(piv_row, pivot_offset + piv_row)\n            swaps.append((piv_row, pivot_offset + piv_row))\n\n        # if we aren't normalizing last\n        # or the pivot_val is non-commutative,\n        # we normalize before we zero the other rows\n        if normalize_last is False or not pivot_val.is_commutative:\n            i, j = piv_row, piv_col\n            mat[i*cols + j] = one\n            for p in range(i*cols + j + 1, (i + 1)*cols):\n                mat[p] = isimp(pivot_val**(-1) * mat[p])\n            # after normalizing, the pivot value is 1\n            pivot_val = one\n\n        # zero above and below the pivot\n        for row in range(rows):\n            # don't zero our current row\n            if row == piv_row:\n                continue\n            # don't zero above the pivot unless we're told.\n            if zero_above is False and row < piv_row:\n                continue\n            # if we're already a zero, don't do anything\n            val = mat[row*cols + piv_col]\n            if iszerofunc(val):\n                continue\n\n            cross_cancel(pivot_val, row, val, piv_row)\n        piv_row += 1\n\n    # normalize each row\n    if normalize_last is True and normalize is True:\n        for piv_i, piv_j in enumerate(pivot_cols):\n            pivot_val = mat[piv_i*cols + piv_j]\n            mat[piv_i*cols + piv_j] = one\n            for p in range(piv_i*cols + piv_j + 1, (piv_i + 1)*cols):\n                mat[p] = isimp(pivot_val**(-1) * mat[p])\n\n    return mat, tuple(pivot_cols), tuple(swaps)",
    "sympy.sympy.matrices.repmatrix.__getitem__": "def __getitem__(self, key: tuple[int | Slice, int | Slice] | int | slice, /\n                ) -> Expr | Self | list[Expr]:\n    return _getitem_RepMatrix(self, key)",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)"
}