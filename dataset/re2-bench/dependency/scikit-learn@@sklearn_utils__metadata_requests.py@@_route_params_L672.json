{
    "scikit-learn.sklearn.utils._metadata_requests._route_params": "def _route_params(self, params, parent, caller):\n    \"\"\"Prepare the given metadata to be passed to the method.\n\n    The output of this method can be used directly as the input to the\n    corresponding method as **kwargs.\n\n    Parameters\n    ----------\n    params : dict\n        A dictionary of provided metadata.\n\n    parent : object\n        Parent class object, that routes the metadata.\n\n    caller : str\n        Method from the parent class object, where the metadata is routed from.\n\n    Returns\n    -------\n    params : Bunch\n        A :class:`~sklearn.utils.Bunch` of {metadata: value} which can be\n        passed to the corresponding method.\n    \"\"\"\n    self._check_warnings(params=params)\n    unrequested = dict()\n    args = {arg: value for arg, value in params.items() if value is not None}\n    res = Bunch()\n    for prop, alias in self._requests.items():\n        if alias is False or alias == WARN:\n            continue\n        elif alias is True and prop in args:\n            res[prop] = args[prop]\n        elif alias is None and prop in args:\n            unrequested[prop] = args[prop]\n        elif alias in args:\n            res[prop] = args[alias]\n    if unrequested:\n        if self.method in COMPOSITE_METHODS:\n            callee_methods = COMPOSITE_METHODS[self.method]\n        else:\n            callee_methods = [self.method]\n        set_requests_on = \"\".join(\n            [\n                f\".set_{method}_request({{metadata}}=True/False)\"\n                for method in callee_methods\n            ]\n        )\n        message = (\n            f\"[{', '.join([key for key in unrequested])}] are passed but are not\"\n            \" explicitly set as requested or not requested for\"\n            f\" {_routing_repr(self.owner)}.{self.method}, which is used within\"\n            f\" {_routing_repr(parent)}.{caller}. Call `{_routing_repr(self.owner)}\"\n            + set_requests_on\n            + \"` for each metadata you want to request/ignore. See the\"\n            \" Metadata Routing User guide\"\n            \" <https://scikit-learn.org/stable/metadata_routing.html> for more\"\n            \" information.\"\n        )\n        raise UnsetMetadataPassedError(\n            message=message,\n            unrequested_params=unrequested,\n            routed_params=res,\n        )\n    return res",
    "scikit-learn.sklearn.utils._metadata_requests.__getattr__": "def __getattr__(self, name):\n    # Called when the default attribute access fails with an AttributeError\n    # (either __getattribute__() raises an AttributeError because name is\n    # not an instance attribute or an attribute in the class tree for self;\n    # or __get__() of a name property raises AttributeError). This method\n    # should either return the (computed) attribute value or raise an\n    # AttributeError exception.\n    # https://docs.python.org/3/reference/datamodel.html#object.__getattr__\n    if name not in COMPOSITE_METHODS:\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n        )\n\n    requests = {}\n    for method in COMPOSITE_METHODS[name]:\n        mmr = getattr(self, method)\n        existing = set(requests.keys())\n        upcoming = set(mmr.requests.keys())\n        common = existing & upcoming\n        conflicts = [key for key in common if requests[key] != mmr._requests[key]]\n        if conflicts:\n            raise ValueError(\n                f\"Conflicting metadata requests for {', '.join(conflicts)} while\"\n                f\" composing the requests for {name}. Metadata with the same name\"\n                f\" for methods {', '.join(COMPOSITE_METHODS[name])} should have the\"\n                \" same request value.\"\n            )\n        requests.update(mmr._requests)\n    return MethodMetadataRequest(owner=self.owner, method=name, requests=requests)"
}