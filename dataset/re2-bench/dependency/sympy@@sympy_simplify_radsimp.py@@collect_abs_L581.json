{
    "sympy.sympy.core.basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None) -> Basic:\n    \"\"\"\n    Replace matching subexpressions of ``self`` with ``value``.\n\n    If ``map = True`` then also return the mapping {old: new} where ``old``\n    was a sub-expression found with query and ``new`` is the replacement\n    value for it. If the expression itself does not match the query, then\n    the returned value will be ``self.xreplace(map)`` otherwise it should\n    be ``self.subs(ordered(map.items()))``.\n\n    Traverses an expression tree and performs replacement of matching\n    subexpressions from the bottom to the top of the tree. The default\n    approach is to do the replacement in a simultaneous fashion so\n    changes made are targeted only once. If this is not desired or causes\n    problems, ``simultaneous`` can be set to False.\n\n    In addition, if an expression containing more than one Wild symbol\n    is being used to match subexpressions and the ``exact`` flag is None\n    it will be set to True so the match will only succeed if all non-zero\n    values are received for each Wild that appears in the match pattern.\n    Setting this to False accepts a match of 0; while setting it True\n    accepts all matches that have a 0 in them. See example below for\n    cautions.\n\n    The list of possible combinations of queries and replacement values\n    is listed below:\n\n    Examples\n    ========\n\n    Initial setup\n\n    >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n    >>> from sympy.abc import x, y\n    >>> f = log(sin(x)) + tan(sin(x**2))\n\n    1.1. type -> type\n        obj.replace(type, newtype)\n\n        When object of type ``type`` is found, replace it with the\n        result of passing its argument(s) to ``newtype``.\n\n        >>> f.replace(sin, cos)\n        log(cos(x)) + tan(cos(x**2))\n        >>> sin(x).replace(sin, cos, map=True)\n        (cos(x), {sin(x): cos(x)})\n        >>> (x*y).replace(Mul, Add)\n        x + y\n\n    1.2. type -> func\n        obj.replace(type, func)\n\n        When object of type ``type`` is found, apply ``func`` to its\n        argument(s). ``func`` must be written to handle the number\n        of arguments of ``type``.\n\n        >>> f.replace(sin, lambda arg: sin(2*arg))\n        log(sin(2*x)) + tan(sin(2*x**2))\n        >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n        sin(2*x*y)\n\n    2.1. pattern -> expr\n        obj.replace(pattern(wild), expr(wild))\n\n        Replace subexpressions matching ``pattern`` with the expression\n        written in terms of the Wild symbols in ``pattern``.\n\n        >>> a, b = map(Wild, 'ab')\n        >>> f.replace(sin(a), tan(a))\n        log(tan(x)) + tan(tan(x**2))\n        >>> f.replace(sin(a), tan(a/2))\n        log(tan(x/2)) + tan(tan(x**2/2))\n        >>> f.replace(sin(a), a)\n        log(x) + tan(x**2)\n        >>> (x*y).replace(a*x, a)\n        y\n\n        Matching is exact by default when more than one Wild symbol\n        is used: matching fails unless the match gives non-zero\n        values for all Wild symbols:\n\n        >>> (2*x + y).replace(a*x + b, b - a)\n        y - 2\n        >>> (2*x).replace(a*x + b, b - a)\n        2*x\n\n        When set to False, the results may be non-intuitive:\n\n        >>> (2*x).replace(a*x + b, b - a, exact=False)\n        2/x\n\n    2.2. pattern -> func\n        obj.replace(pattern(wild), lambda wild: expr(wild))\n\n        All behavior is the same as in 2.1 but now a function in terms of\n        pattern variables is used rather than an expression:\n\n        >>> f.replace(sin(a), lambda a: sin(2*a))\n        log(sin(2*x)) + tan(sin(2*x**2))\n\n    3.1. func -> func\n        obj.replace(filter, func)\n\n        Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n        is True.\n\n        >>> g = 2*sin(x**3)\n        >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n        4*sin(x**9)\n\n    The expression itself is also targeted by the query but is done in\n    such a fashion that changes are not made twice.\n\n        >>> e = x*(x*y + 1)\n        >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n        2*x*(2*x*y + 1)\n\n    When matching a single symbol, `exact` will default to True, but\n    this may or may not be the behavior that is desired:\n\n    Here, we want `exact=False`:\n\n    >>> from sympy import Function\n    >>> f = Function('f')\n    >>> e = f(1) + f(0)\n    >>> q = f(a), lambda a: f(a + 1)\n    >>> e.replace(*q, exact=False)\n    f(1) + f(2)\n    >>> e.replace(*q, exact=True)\n    f(0) + f(2)\n\n    But here, the nature of matching makes selecting\n    the right setting tricky:\n\n    >>> e = x**(1 + y)\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(-x - y + 1)\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(1 - y)\n\n    It is probably better to use a different form of the query\n    that describes the target expression more precisely:\n\n    >>> (1 + x**(1 + y)).replace(\n    ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n    ... lambda x: x.base**(1 - (x.exp - 1)))\n    ...\n    x**(1 - y) + 1\n\n    See Also\n    ========\n\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n\n    \"\"\"\n\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n\n        if isinstance(value, type) or callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError(\n                \"given a type, replace() expects another \"\n                \"type or a callable\")\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            from .symbol import Wild\n            exact = (len(query.atoms(Wild)) > 1)\n\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: (value.subs(result)\n                    if all(result.values()) else expr)\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            # match dictionary keys get the trailing underscore stripped\n            # from them and are then passed as keywords to the callable;\n            # if ``exact`` is True, only accept match if there are no null\n            # values amongst those matched.\n            if exact:\n                _value = lambda expr, result: (value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n                    if all(val for val in result.values()) else expr)\n            else:\n                _value = lambda expr, result: value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError(\n                \"given an expression, replace() expects \"\n                \"another expression or a callable\")\n    elif callable(query):\n        _query = query\n\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError(\n                \"given a callable, replace() expects \"\n                \"another callable\")\n    else:\n        raise TypeError(\n            \"first argument to replace() must be a \"\n            \"type, an expression or a callable\")\n\n    def walk(rv, F):\n        \"\"\"Apply ``F`` to args and then to result.\n        \"\"\"\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        # if rv is something that was already\n                        # matched (that was changed) then skip\n                        # applying F again\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n\n    mapping = {}  # changes that took place\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv # type: ignore",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.polys.polytools.replace": "def replace(f, x, y=None, **_ignore):\n    # XXX this does not match Basic's signature\n    \"\"\"\n    Replace ``x`` with ``y`` in generators list.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> Poly(x**2 + 1, x).replace(x, y)\n    Poly(y**2 + 1, y, domain='ZZ')\n\n    \"\"\"\n    if y is None:\n        if f.is_univariate:\n            x, y = f.gen, x\n        else:\n            raise PolynomialError(\n                \"syntax supported only in univariate case\")\n\n    if x == y or x not in f.gens:\n        return f\n\n    if x in f.gens and y not in f.gens:\n        dom = f.get_domain()\n\n        if not dom.is_Composite or y not in dom.symbols:\n            gens = list(f.gens)\n            gens[gens.index(x)] = y\n            return f.per(f.rep, gens=gens)\n\n    raise PolynomialError(\"Cannot replace %s with %s in %s\" % (x, y, f))"
}