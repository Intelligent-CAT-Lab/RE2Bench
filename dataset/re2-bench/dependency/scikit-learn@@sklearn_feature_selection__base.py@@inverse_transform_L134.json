{
    "scikit-learn.sklearn.feature_selection._base.inverse_transform": "def inverse_transform(self, X):\n    \"\"\"Reverse the transformation operation.\n\n    Parameters\n    ----------\n    X : array of shape [n_samples, n_selected_features]\n        The input samples.\n\n    Returns\n    -------\n    X_original : array of shape [n_samples, n_original_features]\n        `X` with columns of zeros inserted where features would have\n        been removed by :meth:`transform`.\n    \"\"\"\n    if issparse(X):\n        X = X.tocsc()\n        # insert additional entries in indptr:\n        # e.g. if transform changed indptr from [0 2 6 7] to [0 2 3]\n        # col_nonzeros here will be [2 0 1] so indptr becomes [0 2 2 3]\n        it = self.inverse_transform(np.diff(X.indptr).reshape(1, -1))\n        col_nonzeros = it.ravel()\n        indptr = np.concatenate([[0], np.cumsum(col_nonzeros)])\n        Xt = csc_matrix(\n            (X.data, X.indices, indptr),\n            shape=(X.shape[0], len(indptr) - 1),\n            dtype=X.dtype,\n        )\n        return Xt\n\n    support = self.get_support()\n    X = check_array(X, dtype=None)\n    if support.sum() != X.shape[1]:\n        raise ValueError(\"X has a different shape than during fitting.\")\n\n    if X.ndim == 1:\n        X = X[None, :]\n    Xt = np.zeros((X.shape[0], support.size), dtype=X.dtype)\n    Xt[:, support] = X\n    return Xt",
    "scikit-learn.sklearn.feature_selection._base.get_support": "def get_support(self, indices=False):\n    \"\"\"\n    Get a mask, or integer index, of the features selected.\n\n    Parameters\n    ----------\n    indices : bool, default=False\n        If True, the return value will be an array of integers, rather\n        than a boolean mask.\n\n    Returns\n    -------\n    support : array\n        An index that selects the retained features from a feature vector.\n        If `indices` is False, this is a boolean array of shape\n        [# input features], in which an element is True iff its\n        corresponding feature is selected for retention. If `indices` is\n        True, this is an integer array of shape [# output features] whose\n        values are indices into the input feature vector.\n    \"\"\"\n    mask = self._get_support_mask()\n    return mask if not indices else np.nonzero(mask)[0]",
    "scikit-learn.sklearn.utils.validation.check_array": "def check_array(\n    array,\n    accept_sparse=False,\n    *,\n    accept_large_sparse=True,\n    dtype=\"numeric\",\n    order=None,\n    copy=False,\n    force_writeable=False,\n    ensure_all_finite=True,\n    ensure_non_negative=False,\n    ensure_2d=True,\n    allow_nd=False,\n    ensure_min_samples=1,\n    ensure_min_features=1,\n    estimator=None,\n    input_name=\"\",\n):\n    \"\"\"Input validation on an array, list, sparse matrix or similar.\n\n    By default, the input is checked to be a non-empty 2D array containing\n    only finite values. If the dtype of the array is object, attempt\n    converting to float, raising on failure.\n\n    Parameters\n    ----------\n    array : object\n        Input object to check / convert.\n\n    accept_sparse : str, bool or list/tuple of str, default=False\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n\n    accept_large_sparse : bool, default=True\n        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by\n        accept_sparse, accept_large_sparse=False will cause it to be accepted\n        only if its indices are stored with a 32-bit dtype.\n\n        .. versionadded:: 0.20\n\n    dtype : 'numeric', type, list of type or None, default='numeric'\n        Data type of result. If None, the dtype of the input is preserved.\n        If \"numeric\", dtype is preserved unless array.dtype is object.\n        If dtype is a list of types, conversion on the first type is only\n        performed if the dtype of the input is not in the list.\n\n    order : {'F', 'C'} or None, default=None\n        Whether an array will be forced to be fortran or c-style.\n        When order is None (default), then if copy=False, nothing is ensured\n        about the memory layout of the output array; otherwise (copy=True)\n        the memory layout of the returned array is kept as close as possible\n        to the original array.\n\n    copy : bool, default=False\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n    force_writeable : bool, default=False\n        Whether to force the output array to be writeable. If True, the returned array\n        is guaranteed to be writeable, which may require a copy. Otherwise the\n        writeability of the input array is preserved.\n\n        .. versionadded:: 1.6\n\n    ensure_all_finite : bool or 'allow-nan', default=True\n        Whether to raise an error on np.inf, np.nan, pd.NA in array. The\n        possibilities are:\n\n        - True: Force all values of array to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in array.\n        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values\n          cannot be infinite.\n\n        .. versionadded:: 1.6\n           `force_all_finite` was renamed to `ensure_all_finite`.\n\n    ensure_non_negative : bool, default=False\n        Make sure the array has only non-negative values. If True, an array that\n        contains negative values will raise a ValueError.\n\n        .. versionadded:: 1.6\n\n    ensure_2d : bool, default=True\n        Whether to raise a value error if array is not 2D.\n\n    allow_nd : bool, default=False\n        Whether to allow array.ndim > 2.\n\n    ensure_min_samples : int, default=1\n        Make sure that the array has a minimum number of samples in its first\n        axis (rows for a 2D array). Setting to 0 disables this check.\n\n    ensure_min_features : int, default=1\n        Make sure that the 2D array has some minimum number of features\n        (columns). The default value of 1 rejects empty datasets.\n        This check is only enforced when the input data has effectively 2\n        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0\n        disables this check.\n\n    estimator : str or estimator instance, default=None\n        If passed, include the name of the estimator in warning messages.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message. In particular\n        if `input_name` is \"X\" and the data has NaN values and\n        allow_nan is False, the error message will link to the imputer\n        documentation.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    array_converted : object\n        The converted and validated array.\n\n    Examples\n    --------\n    >>> from sklearn.utils.validation import check_array\n    >>> X = [[1, 2, 3], [4, 5, 6]]\n    >>> X_checked = check_array(X)\n    >>> X_checked\n    array([[1, 2, 3], [4, 5, 6]])\n    \"\"\"\n    if isinstance(array, np.matrix):\n        raise TypeError(\n            \"np.matrix is not supported. Please convert to a numpy array with \"\n            \"np.asarray. For more information see: \"\n            \"https://numpy.org/doc/stable/reference/generated/numpy.matrix.html\"\n        )\n\n    xp, is_array_api_compliant = get_namespace(array)\n\n    # store reference to original array to check if copy is needed when\n    # function returns\n    array_orig = array\n\n    # store whether originally we wanted numeric dtype\n    dtype_numeric = isinstance(dtype, str) and dtype == \"numeric\"\n\n    dtype_orig = getattr(array, \"dtype\", None)\n    if not is_array_api_compliant and not hasattr(dtype_orig, \"kind\"):\n        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n        dtype_orig = None\n\n    # check if the object contains several dtypes (typically a pandas\n    # DataFrame), and store them. If not, store None.\n    dtypes_orig = None\n    pandas_requires_conversion = False\n    # track if we have a Series-like object to raise a better error message\n    type_if_series = None\n    if hasattr(array, \"dtypes\") and hasattr(array.dtypes, \"__array__\"):\n        # throw warning if columns are sparse. If all columns are sparse, then\n        # array.sparse exists and sparsity will be preserved (later).\n        with suppress(ImportError):\n            from pandas import SparseDtype\n\n            def is_sparse(dtype):\n                return isinstance(dtype, SparseDtype)\n\n            if not hasattr(array, \"sparse\") and array.dtypes.apply(is_sparse).any():\n                warnings.warn(\n                    \"pandas.DataFrame with sparse columns found.\"\n                    \"It will be converted to a dense numpy array.\"\n                )\n\n        dtypes_orig = list(array.dtypes)\n        pandas_requires_conversion = any(\n            _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig\n        )\n        if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):\n            dtype_orig = np.result_type(*dtypes_orig)\n        elif pandas_requires_conversion and any(d == object for d in dtypes_orig):\n            # Force object if any of the dtypes is an object\n            dtype_orig = object\n\n    elif (_is_extension_array_dtype(array) or hasattr(array, \"iloc\")) and hasattr(\n        array, \"dtype\"\n    ):\n        # array is a pandas series\n        type_if_series = type(array)\n        pandas_requires_conversion = _pandas_dtype_needs_early_conversion(array.dtype)\n        if isinstance(array.dtype, np.dtype):\n            dtype_orig = array.dtype\n        else:\n            # Set to None to let array.astype work out the best dtype\n            dtype_orig = None\n\n    if dtype_numeric:\n        if (\n            dtype_orig is not None\n            and hasattr(dtype_orig, \"kind\")\n            and dtype_orig.kind == \"O\"\n        ):\n            # if input is object, convert to float.\n            dtype = xp.float64\n        else:\n            dtype = None\n\n    if isinstance(dtype, (list, tuple)):\n        if dtype_orig is not None and dtype_orig in dtype:\n            # no dtype conversion required\n            dtype = None\n        else:\n            # dtype conversion required. Let's select the first element of the\n            # list of accepted types.\n            dtype = dtype[0]\n\n    if pandas_requires_conversion:\n        # pandas dataframe requires conversion earlier to handle extension dtypes with\n        # nans\n        # Use the original dtype for conversion if dtype is None\n        new_dtype = dtype_orig if dtype is None else dtype\n        array = array.astype(new_dtype)\n        # Since we converted here, we do not need to convert again later\n        dtype = None\n\n    if ensure_all_finite not in (True, False, \"allow-nan\"):\n        raise ValueError(\n            \"ensure_all_finite should be a bool or 'allow-nan'. Got \"\n            f\"{ensure_all_finite!r} instead.\"\n        )\n\n    if dtype is not None and _is_numpy_namespace(xp):\n        # convert to dtype object to conform to Array API to be use `xp.isdtype` later\n        dtype = np.dtype(dtype)\n\n    estimator_name = _check_estimator_name(estimator)\n    context = \" by %s\" % estimator_name if estimator is not None else \"\"\n\n    # When all dataframe columns are sparse, convert to a sparse array\n    if hasattr(array, \"sparse\") and array.ndim > 1:\n        with suppress(ImportError):\n            from pandas import SparseDtype\n\n            def is_sparse(dtype):\n                return isinstance(dtype, SparseDtype)\n\n            if array.dtypes.apply(is_sparse).all():\n                # DataFrame.sparse only supports `to_coo`\n                array = array.sparse.to_coo()\n                if array.dtype == np.dtype(\"object\"):\n                    unique_dtypes = set([dt.subtype.name for dt in array_orig.dtypes])\n                    if len(unique_dtypes) > 1:\n                        raise ValueError(\n                            \"Pandas DataFrame with mixed sparse extension arrays \"\n                            \"generated a sparse matrix with object dtype which \"\n                            \"can not be converted to a scipy sparse matrix.\"\n                            \"Sparse extension arrays should all have the same \"\n                            \"numeric type.\"\n                        )\n\n    if sp.issparse(array):\n        _ensure_no_complex_data(array)\n        array = _ensure_sparse_format(\n            array,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            accept_large_sparse=accept_large_sparse,\n            estimator_name=estimator_name,\n            input_name=input_name,\n        )\n        if ensure_2d and array.ndim < 2:\n            raise ValueError(\n                f\"Expected 2D input, got input with shape {array.shape}.\\n\"\n                \"Reshape your data either using array.reshape(-1, 1) if \"\n                \"your data has a single feature or array.reshape(1, -1) \"\n                \"if it contains a single sample.\"\n            )\n    else:\n        # If np.array(..) gives ComplexWarning, then we convert the warning\n        # to an error. This is needed because specifying a non complex\n        # dtype to the function converts complex to real dtype,\n        # thereby passing the test made in the lines following the scope\n        # of warnings context manager.\n        with warnings.catch_warnings():\n            try:\n                warnings.simplefilter(\"error\", ComplexWarning)\n                if dtype is not None and xp.isdtype(dtype, \"integral\"):\n                    # Conversion float -> int should not contain NaN or\n                    # inf (numpy#14412). We cannot use casting='safe' because\n                    # then conversion float -> int would be disallowed.\n                    array = _asarray_with_order(array, order=order, xp=xp)\n                    if xp.isdtype(array.dtype, (\"real floating\", \"complex floating\")):\n                        _assert_all_finite(\n                            array,\n                            allow_nan=False,\n                            msg_dtype=dtype,\n                            estimator_name=estimator_name,\n                            input_name=input_name,\n                        )\n                    array = xp.astype(array, dtype, copy=False)\n                else:\n                    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n            except ComplexWarning as complex_warning:\n                raise ValueError(\n                    \"Complex data not supported\\n{}\\n\".format(array)\n                ) from complex_warning\n\n        # It is possible that the np.array(..) gave no warning. This happens\n        # when no dtype conversion happened, for example dtype = None. The\n        # result is that np.array(..) produces an array of complex dtype\n        # and we need to catch and raise exception for such cases.\n        _ensure_no_complex_data(array)\n\n        if ensure_2d:\n            # If input is scalar raise error\n            if array.ndim == 0:\n                raise ValueError(\n                    \"Expected 2D array, got scalar array instead:\\narray={}.\\n\"\n                    \"Reshape your data either using array.reshape(-1, 1) if \"\n                    \"your data has a single feature or array.reshape(1, -1) \"\n                    \"if it contains a single sample.\".format(array)\n                )\n            # If input is 1D raise error\n            if array.ndim == 1:\n                # If input is a Series-like object (eg. pandas Series or polars Series)\n                if type_if_series is not None:\n                    msg = (\n                        f\"Expected a 2-dimensional container but got {type_if_series} \"\n                        \"instead. Pass a DataFrame containing a single row (i.e. \"\n                        \"single sample) or a single column (i.e. single feature) \"\n                        \"instead.\"\n                    )\n                else:\n                    msg = (\n                        f\"Expected 2D array, got 1D array instead:\\narray={array}.\\n\"\n                        \"Reshape your data either using array.reshape(-1, 1) if \"\n                        \"your data has a single feature or array.reshape(1, -1) \"\n                        \"if it contains a single sample.\"\n                    )\n                raise ValueError(msg)\n\n        if dtype_numeric and hasattr(array.dtype, \"kind\") and array.dtype.kind in \"USV\":\n            raise ValueError(\n                \"dtype='numeric' is not compatible with arrays of bytes/strings.\"\n                \"Convert your data to numeric values explicitly instead.\"\n            )\n        if not allow_nd and array.ndim >= 3:\n            raise ValueError(\n                f\"Found array with dim {array.ndim},\"\n                f\" while dim <= 2 is required{context}.\"\n            )\n\n        if ensure_all_finite:\n            _assert_all_finite(\n                array,\n                input_name=input_name,\n                estimator_name=estimator_name,\n                allow_nan=ensure_all_finite == \"allow-nan\",\n            )\n\n        if copy:\n            if _is_numpy_namespace(xp):\n                # only make a copy if `array` and `array_orig` may share memory`\n                if np.may_share_memory(array, array_orig):\n                    array = _asarray_with_order(\n                        array, dtype=dtype, order=order, copy=True, xp=xp\n                    )\n            else:\n                # always make a copy for non-numpy arrays\n                array = _asarray_with_order(\n                    array, dtype=dtype, order=order, copy=True, xp=xp\n                )\n\n    if ensure_min_samples > 0:\n        n_samples = _num_samples(array)\n        if n_samples < ensure_min_samples:\n            raise ValueError(\n                \"Found array with %d sample(s) (shape=%s) while a\"\n                \" minimum of %d is required%s.\"\n                % (n_samples, array.shape, ensure_min_samples, context)\n            )\n\n    if ensure_min_features > 0 and array.ndim == 2:\n        n_features = array.shape[1]\n        if n_features < ensure_min_features:\n            raise ValueError(\n                \"Found array with %d feature(s) (shape=%s) while\"\n                \" a minimum of %d is required%s.\"\n                % (n_features, array.shape, ensure_min_features, context)\n            )\n\n    if ensure_non_negative:\n        whom = input_name\n        if estimator_name:\n            whom += f\" in {estimator_name}\"\n        check_non_negative(array, whom)\n\n    if force_writeable:\n        # By default, array.copy() creates a C-ordered copy. We set order=K to\n        # preserve the order of the array.\n        copy_params = {\"order\": \"K\"} if not sp.issparse(array) else {}\n\n        array_data = array.data if sp.issparse(array) else array\n        flags = getattr(array_data, \"flags\", None)\n        if not getattr(flags, \"writeable\", True):\n            # This situation can only happen when copy=False, the array is read-only and\n            # a writeable output is requested. This is an ambiguous setting so we chose\n            # to always (except for one specific setting, see below) make a copy to\n            # ensure that the output is writeable, even if avoidable, to not overwrite\n            # the user's data by surprise.\n\n            if _is_pandas_df_or_series(array_orig):\n                try:\n                    # In pandas >= 3, np.asarray(df), called earlier in check_array,\n                    # returns a read-only intermediate array. It can be made writeable\n                    # safely without copy because if the original DataFrame was backed\n                    # by a read-only array, trying to change the flag would raise an\n                    # error, in which case we make a copy.\n                    array_data.flags.writeable = True\n                except ValueError:\n                    array = array.copy(**copy_params)\n            else:\n                array = array.copy(**copy_params)\n\n    return array"
}