{
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    \"\"\"Return [commutative factors, non-commutative factors] of self.\n\n    Explanation\n    ===========\n\n    self is treated as a Mul and the ordering of the factors is maintained.\n    If ``cset`` is True the commutative factors will be returned in a set.\n    If there were repeated factors (as may happen with an unevaluated Mul)\n    then an error will be raised unless it is explicitly suppressed by\n    setting ``warn`` to False.\n\n    Note: -1 is always separated from a Number unless split_1 is False.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, oo\n    >>> A, B = symbols('A B', commutative=0)\n    >>> x, y = symbols('x y')\n    >>> (-2*x*y).args_cnc()\n    [[-1, 2, x, y], []]\n    >>> (-2.5*x).args_cnc()\n    [[-1, 2.5, x], []]\n    >>> (-2*x*A*B*y).args_cnc()\n    [[-1, 2, x, y], [A, B]]\n    >>> (-2*x*A*B*y).args_cnc(split_1=False)\n    [[-2, x, y], [A, B]]\n    >>> (-2*x*y).args_cnc(cset=True)\n    [{-1, 2, x, y}, []]\n\n    The arg is always treated as a Mul:\n\n    >>> (-2 + x + A).args_cnc()\n    [[], [x - 2 + A]]\n    >>> (-oo).args_cnc() # -oo is a singleton\n    [[-1, oo], []]\n    \"\"\"\n    args = list(Mul.make_args(self))\n\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n\n    if c and split_1 and (\n        c[0].is_Number and\n        c[0].is_extended_negative and\n            c[0] is not S.NegativeOne):\n        c[:1] = [S.NegativeOne, -c[0]]\n\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and len(c) != clen:\n            raise ValueError('repeated commutative arguments: %s' %\n                             [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    "sympy.sympy.core.mul.<lambda>": "cpart.sort(key=lambda expr: expr.sort_key(order=order))\n",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity or other == float('-inf')",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.expressions.matmul.args_cnc": "def args_cnc(self, cset=False, warn=True, **kwargs):\n    coeff_c = [x for x in self.args if x.is_commutative]\n    coeff_nc = [x for x in self.args if not x.is_commutative]\n    if cset:\n        clen = len(coeff_c)\n        coeff_c = set(coeff_c)\n        if clen and warn and len(coeff_c) != clen:\n            raise ValueError('repeated commutative arguments: %s' %\n                             [ci for ci in coeff_c if list(self.args).count(ci) > 1])\n    return [coeff_c, coeff_nc]"
}