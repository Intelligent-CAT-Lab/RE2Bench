{
    "sympy.sympy.core.basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None) -> Basic:\n    \"\"\"\n    Replace matching subexpressions of ``self`` with ``value``.\n\n    If ``map = True`` then also return the mapping {old: new} where ``old``\n    was a sub-expression found with query and ``new`` is the replacement\n    value for it. If the expression itself does not match the query, then\n    the returned value will be ``self.xreplace(map)`` otherwise it should\n    be ``self.subs(ordered(map.items()))``.\n\n    Traverses an expression tree and performs replacement of matching\n    subexpressions from the bottom to the top of the tree. The default\n    approach is to do the replacement in a simultaneous fashion so\n    changes made are targeted only once. If this is not desired or causes\n    problems, ``simultaneous`` can be set to False.\n\n    In addition, if an expression containing more than one Wild symbol\n    is being used to match subexpressions and the ``exact`` flag is None\n    it will be set to True so the match will only succeed if all non-zero\n    values are received for each Wild that appears in the match pattern.\n    Setting this to False accepts a match of 0; while setting it True\n    accepts all matches that have a 0 in them. See example below for\n    cautions.\n\n    The list of possible combinations of queries and replacement values\n    is listed below:\n\n    Examples\n    ========\n\n    Initial setup\n\n    >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n    >>> from sympy.abc import x, y\n    >>> f = log(sin(x)) + tan(sin(x**2))\n\n    1.1. type -> type\n        obj.replace(type, newtype)\n\n        When object of type ``type`` is found, replace it with the\n        result of passing its argument(s) to ``newtype``.\n\n        >>> f.replace(sin, cos)\n        log(cos(x)) + tan(cos(x**2))\n        >>> sin(x).replace(sin, cos, map=True)\n        (cos(x), {sin(x): cos(x)})\n        >>> (x*y).replace(Mul, Add)\n        x + y\n\n    1.2. type -> func\n        obj.replace(type, func)\n\n        When object of type ``type`` is found, apply ``func`` to its\n        argument(s). ``func`` must be written to handle the number\n        of arguments of ``type``.\n\n        >>> f.replace(sin, lambda arg: sin(2*arg))\n        log(sin(2*x)) + tan(sin(2*x**2))\n        >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n        sin(2*x*y)\n\n    2.1. pattern -> expr\n        obj.replace(pattern(wild), expr(wild))\n\n        Replace subexpressions matching ``pattern`` with the expression\n        written in terms of the Wild symbols in ``pattern``.\n\n        >>> a, b = map(Wild, 'ab')\n        >>> f.replace(sin(a), tan(a))\n        log(tan(x)) + tan(tan(x**2))\n        >>> f.replace(sin(a), tan(a/2))\n        log(tan(x/2)) + tan(tan(x**2/2))\n        >>> f.replace(sin(a), a)\n        log(x) + tan(x**2)\n        >>> (x*y).replace(a*x, a)\n        y\n\n        Matching is exact by default when more than one Wild symbol\n        is used: matching fails unless the match gives non-zero\n        values for all Wild symbols:\n\n        >>> (2*x + y).replace(a*x + b, b - a)\n        y - 2\n        >>> (2*x).replace(a*x + b, b - a)\n        2*x\n\n        When set to False, the results may be non-intuitive:\n\n        >>> (2*x).replace(a*x + b, b - a, exact=False)\n        2/x\n\n    2.2. pattern -> func\n        obj.replace(pattern(wild), lambda wild: expr(wild))\n\n        All behavior is the same as in 2.1 but now a function in terms of\n        pattern variables is used rather than an expression:\n\n        >>> f.replace(sin(a), lambda a: sin(2*a))\n        log(sin(2*x)) + tan(sin(2*x**2))\n\n    3.1. func -> func\n        obj.replace(filter, func)\n\n        Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n        is True.\n\n        >>> g = 2*sin(x**3)\n        >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n        4*sin(x**9)\n\n    The expression itself is also targeted by the query but is done in\n    such a fashion that changes are not made twice.\n\n        >>> e = x*(x*y + 1)\n        >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n        2*x*(2*x*y + 1)\n\n    When matching a single symbol, `exact` will default to True, but\n    this may or may not be the behavior that is desired:\n\n    Here, we want `exact=False`:\n\n    >>> from sympy import Function\n    >>> f = Function('f')\n    >>> e = f(1) + f(0)\n    >>> q = f(a), lambda a: f(a + 1)\n    >>> e.replace(*q, exact=False)\n    f(1) + f(2)\n    >>> e.replace(*q, exact=True)\n    f(0) + f(2)\n\n    But here, the nature of matching makes selecting\n    the right setting tricky:\n\n    >>> e = x**(1 + y)\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(-x - y + 1)\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(1 - y)\n\n    It is probably better to use a different form of the query\n    that describes the target expression more precisely:\n\n    >>> (1 + x**(1 + y)).replace(\n    ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n    ... lambda x: x.base**(1 - (x.exp - 1)))\n    ...\n    x**(1 - y) + 1\n\n    See Also\n    ========\n\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n\n    \"\"\"\n\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n\n        if isinstance(value, type) or callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError(\n                \"given a type, replace() expects another \"\n                \"type or a callable\")\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            from .symbol import Wild\n            exact = (len(query.atoms(Wild)) > 1)\n\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: (value.subs(result)\n                    if all(result.values()) else expr)\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            # match dictionary keys get the trailing underscore stripped\n            # from them and are then passed as keywords to the callable;\n            # if ``exact`` is True, only accept match if there are no null\n            # values amongst those matched.\n            if exact:\n                _value = lambda expr, result: (value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n                    if all(val for val in result.values()) else expr)\n            else:\n                _value = lambda expr, result: value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError(\n                \"given an expression, replace() expects \"\n                \"another expression or a callable\")\n    elif callable(query):\n        _query = query\n\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError(\n                \"given a callable, replace() expects \"\n                \"another callable\")\n    else:\n        raise TypeError(\n            \"first argument to replace() must be a \"\n            \"type, an expression or a callable\")\n\n    def walk(rv, F):\n        \"\"\"Apply ``F`` to args and then to result.\n        \"\"\"\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        # if rv is something that was already\n                        # matched (that was changed) then skip\n                        # applying F again\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n\n    mapping = {}  # changes that took place\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv # type: ignore",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.core.traversal.bottom_up": "def bottom_up(rv, F, atoms=False, nonbasic=False):\n    \"\"\"Apply ``F`` to all expressions in an expression tree from the\n    bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n    if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n    \"\"\"\n    args = getattr(rv, 'args', None)\n    if args is not None:\n        if args:\n            args = tuple([bottom_up(a, F, atoms, nonbasic) for a in args])\n            if args != rv.args:\n                rv = rv.func(*args)\n            rv = F(rv)\n        elif atoms:\n            rv = F(rv)\n    else:\n        if nonbasic:\n            try:\n                rv = F(rv)\n            except TypeError:\n                pass\n\n    return rv",
    "sympy.sympy.matrices.matrixbase.replace": "def replace(self, F, G, map: bool=False, simultaneous: bool=True, exact=None):\n    \"\"\"Replaces Function F in Matrix entries with Function G.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Function, Matrix\n    >>> F, G = symbols('F, G', cls=Function)\n    >>> M = Matrix(2, 2, lambda i, j: F(i+j)) ; M\n    Matrix([\n    [F(0), F(1)],\n    [F(1), F(2)]])\n    >>> N = M.replace(F,G)\n    >>> N\n    Matrix([\n    [G(0), G(1)],\n    [G(1), G(2)]])\n    \"\"\"\n    kwargs = {'map': map, 'simultaneous': simultaneous, 'exact': exact}\n\n    if map:\n\n        d = {}\n        def func(eij):\n            eij, dij = eij.replace(F, G, **kwargs)\n            d.update(dij)\n            return eij\n\n        M = self.applyfunc(func)\n        return M, d\n\n    else:\n        return self.applyfunc(lambda i: i.replace(F, G, **kwargs)) # type: ignore",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}