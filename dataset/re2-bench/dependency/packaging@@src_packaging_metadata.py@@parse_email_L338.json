{
    "packaging.src.packaging.metadata._parse_keywords": "def _parse_keywords(data: str) -> list[str]:\n    \"\"\"Split a string of comma-separated keywords into a list of keywords.\"\"\"\n    return [k.strip() for k in data.split(\",\")]",
    "packaging.src.packaging.metadata._parse_project_urls": "def _parse_project_urls(data: list[str]) -> dict[str, str]:\n    \"\"\"Parse a list of label/URL string pairings separated by a comma.\"\"\"\n    urls = {}\n    for pair in data:\n        # Our logic is slightly tricky here as we want to try and do\n        # *something* reasonable with malformed data.\n        #\n        # The main thing that we have to worry about, is data that does\n        # not have a ',' at all to split the label from the Value. There\n        # isn't a singular right answer here, and we will fail validation\n        # later on (if the caller is validating) so it doesn't *really*\n        # matter, but since the missing value has to be an empty str\n        # and our return value is dict[str, str], if we let the key\n        # be the missing value, then they'd have multiple '' values that\n        # overwrite each other in a accumulating dict.\n        #\n        # The other potential issue is that it's possible to have the\n        # same label multiple times in the metadata, with no solid \"right\"\n        # answer with what to do in that case. As such, we'll do the only\n        # thing we can, which is treat the field as unparsable and add it\n        # to our list of unparsed fields.\n        parts = [p.strip() for p in pair.split(\",\", 1)]\n        parts.extend([\"\"] * (max(0, 2 - len(parts))))  # Ensure 2 items\n\n        # TODO: The spec doesn't say anything about if the keys should be\n        #       considered case sensitive or not... logically they should\n        #       be case-preserving and case-insensitive, but doing that\n        #       would open up more cases where we might have duplicate\n        #       entries.\n        label, url = parts\n        if label in urls:\n            # The label already exists in our set of urls, so this field\n            # is unparsable, and we can just add the whole thing to our\n            # unparsable data and stop processing it.\n            raise KeyError(\"duplicate labels in project urls\")\n        urls[label] = url\n\n    return urls",
    "packaging.src.packaging.metadata._get_payload": "def _get_payload(msg: email.message.Message, source: bytes | str) -> str:\n    \"\"\"Get the body of the message.\"\"\"\n    # If our source is a str, then our caller has managed encodings for us,\n    # and we don't need to deal with it.\n    if isinstance(source, str):\n        payload = msg.get_payload()\n        assert isinstance(payload, str)\n        return payload\n    # If our source is a bytes, then we're managing the encoding and we need\n    # to deal with it.\n    else:\n        bpayload = msg.get_payload(decode=True)\n        assert isinstance(bpayload, bytes)\n        try:\n            return bpayload.decode(\"utf8\", \"strict\")\n        except UnicodeDecodeError as exc:\n            raise ValueError(\"payload in an invalid encoding\") from exc"
}