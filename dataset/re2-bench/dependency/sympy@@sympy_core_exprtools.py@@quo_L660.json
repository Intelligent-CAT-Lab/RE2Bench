{
    "sympy.sympy.core.exprtools.div": "def div(self, other):  # Factors\n    \"\"\"Return ``self`` and ``other`` with ``gcd`` removed from each.\n    This is optimized for the case when there are many factors in common.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> from sympy import S\n\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> a.div(a)\n    (Factors({}), Factors({}))\n    >>> a.div(x*z)\n    (Factors({y: 2}), Factors({z: 1}))\n\n    The ``/`` operator only gives ``quo``:\n\n    >>> a/x\n    Factors({y: 2})\n\n    Factors treats its factors as though they are all in the numerator, so\n    if you violate this assumption the results will be correct but will\n    not strictly correspond to the numerator and denominator of the ratio:\n\n    >>> a.div(x/z)\n    (Factors({y: 2}), Factors({z: -1}))\n\n    Factors is also naive about bases: it does not attempt any denesting\n    of Rational-base terms, for example the following does not become\n    2**(2*x)/2.\n\n    >>> Factors(2**(2*x + 2)).div(S(8))\n    (Factors({2: 2*x + 2}), Factors({8: 1}))\n\n    factor_terms can clean up such Rational-bases powers:\n\n    >>> from sympy import factor_terms\n    >>> n, d = Factors(2**(2*x + 2)).div(S(8))\n    >>> n.as_expr()/d.as_expr()\n    2**(2*x + 2)/8\n    >>> factor_terms(_)\n    2**(2*x)/2\n\n    \"\"\"\n    quo, rem = dict(self.factors), {}\n\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            raise ZeroDivisionError\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n\n    for factor, exp in other.factors.items():\n        if factor in quo:\n            d = quo[factor] - exp\n            if _isnumber(d):\n                if d <= 0:\n                    del quo[factor]\n\n                if d >= 0:\n                    if d:\n                        quo[factor] = d\n\n                    continue\n\n                exp = -d\n\n            else:\n                r = quo[factor].extract_additively(exp)\n                if r is not None:\n                    if r:\n                        quo[factor] = r\n                    else:  # should be handled already\n                        del quo[factor]\n                else:\n                    other_exp = exp\n                    sc, sa = quo[factor].as_coeff_Add()\n                    if sc:\n                        oc, oa = other_exp.as_coeff_Add()\n                        diff = sc - oc\n                        if diff > 0:\n                            quo[factor] -= oc\n                            other_exp = oa\n                        elif diff < 0:\n                            quo[factor] -= sc\n                            other_exp = oa - diff\n                        else:\n                            quo[factor] = sa\n                            other_exp = oa\n                    if other_exp:\n                        rem[factor] = other_exp\n                    else:\n                        assert factor not in rem\n                continue\n\n        rem[factor] = exp\n\n    return Factors(quo), Factors(rem)"
}