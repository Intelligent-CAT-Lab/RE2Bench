{
    "sympy.sympy.codegen.ast._sympystr": "def _sympystr(self, printer, *args, **kwargs):\n    return self.text",
    "sympy.sympy.codegen.ast._sympyrepr": "def _sympyrepr(self, printer, *args, joiner=', ', **kwargs):\n    from sympy.printing.printer import printer_context\n    exclude = kwargs.get('exclude', ())\n    values = [getattr(self, k) for k in self._fields]\n    indent_level = printer._context.get('indent_level', 0)\n\n    arg_reprs = []\n\n    for i, (attr, value) in enumerate(zip(self._fields, values)):\n        if attr in exclude:\n            continue\n\n        # Skip attributes which have the default value\n        if attr in self.defaults and value == self.defaults[attr]:\n            continue\n\n        ilvl = indent_level + 4 if attr in self.indented_args else 0\n        with printer_context(printer, indent_level=ilvl):\n            indented = self._indented(printer, attr, value, *args, **kwargs)\n        arg_reprs.append(('{1}' if i == 0 else '{0}={1}').format(attr, indented.lstrip()))\n\n    return \"{}({})\".format(self.__class__.__name__, joiner.join(arg_reprs))",
    "sympy.sympy.codegen.fnodes._sympystr": "def _sympystr(self, printer):\n    if len(self.args) == 0:\n        return ':'\n    return \":\".join(str(arg) for arg in self.args)",
    "sympy.sympy.codegen.fnodes._fcode": "def _fcode(self, printer, *args, **kwargs):\n    mantissa, sgnd_ex = ('%.{}e'.format(self._decimals) % self).split('e')\n    mantissa = mantissa.strip('0').rstrip('.')\n    ex_sgn, ex_num = sgnd_ex[0], sgnd_ex[1:].lstrip('0')\n    ex_sgn = '' if ex_sgn == '+' else ex_sgn\n    return (mantissa or '0') + self._token + ex_sgn + (ex_num or '0')",
    "sympy.sympy.core.function._print_Dummy": "def _print_Dummy(self, expr):\n    return str(expr) + str(expr.dummy_index)",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.numbers._latex": "def _latex(self, printer):\n    return printer._settings['imaginary_unit_latex']",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.functions.elementary.complexes._latex": "def _latex(self, printer, exp=None, *args):\n    arg = printer._print(self.args[0])\n    tex = r'%s^{\\dagger}' % arg\n    if exp:\n        tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n    return tex",
    "sympy.sympy.functions.elementary.complexes._pretty": "def _pretty(self, printer, *args):\n    from sympy.printing.pretty.stringpict import prettyForm\n    pform = printer._print(self.args[0], *args)\n    if printer._use_unicode:\n        pform = pform**prettyForm('\\N{DAGGER}')\n    else:\n        pform = pform**prettyForm('+')\n    return pform",
    "sympy.sympy.physics.biomechanics.curve._latex": "def _latex(self, printer):\n    \"\"\"Print a LaTeX representation of the function defining the curve.\n\n    Parameters\n    ==========\n\n    printer : Printer\n        The printer to be used to print the LaTeX string representation.\n\n    \"\"\"\n    fl_M_pas = self.args[0]\n    _fl_M_pas = printer._print(fl_M_pas)\n    return r'\\left( \\operatorname{fl}^M_{pas} \\right)^{-1} \\left( %s \\right)' % _fl_M_pas",
    "sympy.sympy.physics.biomechanics.curve._print_code": "def _print_code(self, printer):\n    \"\"\"Print code for the function defining the curve using a printer.\n\n    Explanation\n    ===========\n\n    The order of operations may need to be controlled as constant folding\n    the numeric terms within the equations of a musculotendon\n    characteristic curve can sometimes results in a numerically-unstable\n    expression.\n\n    Parameters\n    ==========\n\n    printer : Printer\n        The printer to be used to print a string representation of the\n        characteristic curve as valid code in the target language.\n\n    \"\"\"\n    return printer._print(printer.parenthesize(\n        self.doit(deep=False, evaluate=False), PRECEDENCE['Atom'],\n    ))",
    "sympy.sympy.physics.quantum.anticommutator._sympyrepr": "def _sympyrepr(self, printer, *args):\n    return \"%s(%s,%s)\" % (\n        self.__class__.__name__, printer._print(\n            self.args[0]), printer._print(self.args[1])\n    )",
    "sympy.sympy.physics.quantum.anticommutator._sympystr": "def _sympystr(self, printer, *args):\n    return \"{%s,%s}\" % (\n        printer._print(self.args[0]), printer._print(self.args[1]))",
    "sympy.sympy.physics.quantum.anticommutator._pretty": "def _pretty(self, printer, *args):\n    pform = printer._print(self.args[0], *args)\n    pform = prettyForm(*pform.right(prettyForm(',')))\n    pform = prettyForm(*pform.right(printer._print(self.args[1], *args)))\n    pform = prettyForm(*pform.parens(left='{', right='}'))\n    return pform",
    "sympy.sympy.physics.quantum.anticommutator._latex": "def _latex(self, printer, *args):\n    return \"\\\\left\\\\{%s,%s\\\\right\\\\}\" % tuple([\n        printer._print(arg, *args) for arg in self.args])",
    "sympy.sympy.physics.quantum.cg._pretty": "def _pretty(self, printer, *args):\n    m = (\n        (printer._print(\n            self.j1), printer._print(self.j3), printer._print(self.j13)),\n        (printer._print(\n            self.j2), printer._print(self.j4), printer._print(self.j24)),\n        (printer._print(self.j12), printer._print(self.j34), printer._print(self.j)))\n    hsep = 2\n    vsep = 1\n    maxw = [-1]*3\n    for j in range(3):\n        maxw[j] = max(m[j][i].width() for i in range(3))\n    D = None\n    for i in range(3):\n        D_row = None\n        for j in range(3):\n            s = m[j][i]\n            wdelta = maxw[j] - s.width()\n            wleft = wdelta //2\n            wright = wdelta - wleft\n\n            s = prettyForm(*s.right(' '*wright))\n            s = prettyForm(*s.left(' '*wleft))\n\n            if D_row is None:\n                D_row = s\n                continue\n            D_row = prettyForm(*D_row.right(' '*hsep))\n            D_row = prettyForm(*D_row.right(s))\n        if D is None:\n            D = D_row\n            continue\n        for _ in range(vsep):\n            D = prettyForm(*D.below(' '))\n        D = prettyForm(*D.below(D_row))\n    D = prettyForm(*D.parens(left='{', right='}'))\n    return D",
    "sympy.sympy.physics.quantum.cg._latex": "def _latex(self, printer, *args):\n    label = map(printer._print, (self.j1, self.j2, self.j12, self.j3,\n            self.j4, self.j34, self.j13, self.j24, self.j))\n    return r'\\left\\{\\begin{array}{ccc} %s & %s & %s \\\\ %s & %s & %s \\\\ %s & %s & %s \\end{array}\\right\\}' % \\\n        tuple(label)",
    "sympy.sympy.physics.quantum.commutator._sympyrepr": "def _sympyrepr(self, printer, *args):\n    return \"%s(%s,%s)\" % (\n        self.__class__.__name__, printer._print(\n            self.args[0]), printer._print(self.args[1])\n    )",
    "sympy.sympy.physics.quantum.commutator._sympystr": "def _sympystr(self, printer, *args):\n    return \"[%s,%s]\" % (\n        printer._print(self.args[0]), printer._print(self.args[1]))",
    "sympy.sympy.physics.quantum.commutator._pretty": "def _pretty(self, printer, *args):\n    pform = printer._print(self.args[0], *args)\n    pform = prettyForm(*pform.right(prettyForm(',')))\n    pform = prettyForm(*pform.right(printer._print(self.args[1], *args)))\n    pform = prettyForm(*pform.parens(left='[', right=']'))\n    return pform",
    "sympy.sympy.physics.quantum.commutator._latex": "def _latex(self, printer, *args):\n    return \"\\\\left[%s,%s\\\\right]\" % tuple([\n        printer._print(arg, *args) for arg in self.args])",
    "sympy.sympy.physics.quantum.constants._sympyrepr": "def _sympyrepr(self, printer, *args):\n    return 'HBar()'",
    "sympy.sympy.physics.quantum.constants._sympystr": "def _sympystr(self, printer, *args):\n    return 'hbar'",
    "sympy.sympy.physics.quantum.constants._pretty": "def _pretty(self, printer, *args):\n    if printer._use_unicode:\n        return prettyForm('\\N{PLANCK CONSTANT OVER TWO PI}')\n    return prettyForm('hbar')",
    "sympy.sympy.physics.quantum.constants._latex": "def _latex(self, printer, *args):\n    return r'\\hbar'",
    "sympy.sympy.physics.quantum.dagger.<lambda>": "adjoint._sympyrepr = lambda a, b: \"Dagger(%s)\" % b._print(a.args[0])\n",
    "sympy.sympy.physics.quantum.gate._sympystr": "def _sympystr(self, printer, *args):\n    label = self._print_label(printer, *args)\n    return '%s(%s)' % (self.gate_name, label)",
    "sympy.sympy.physics.quantum.gate._pretty": "def _pretty(self, printer, *args):\n    return Gate._pretty(self, printer, *args)",
    "sympy.sympy.physics.quantum.gate._latex": "def _latex(self, printer, *args):\n    return Gate._latex(self, printer, *args)",
    "sympy.sympy.physics.quantum.hilbert._sympystr": "def _sympystr(self, printer, *args):\n    return \"%s**%s\" % (printer._print(self.base, *args),\n    printer._print(self.exp, *args))",
    "sympy.sympy.physics.quantum.hilbert._pretty": "def _pretty(self, printer, *args):\n    pform_exp = printer._print(self.exp, *args)\n    if printer._use_unicode:\n        pform_exp = prettyForm(*pform_exp.left(prettyForm('\\N{N-ARY CIRCLED TIMES OPERATOR}')))\n    else:\n        pform_exp = prettyForm(*pform_exp.left(prettyForm('x')))\n    pform_base = printer._print(self.base, *args)\n    return pform_base**pform_exp",
    "sympy.sympy.physics.quantum.hilbert._latex": "def _latex(self, printer, *args):\n    base = printer._print(self.base, *args)\n    exp = printer._print(self.exp, *args)\n    return r'{%s}^{\\otimes %s}' % (base, exp)",
    "sympy.sympy.physics.quantum.hilbert._sympyrepr": "def _sympyrepr(self, printer, *args):\n    return \"TensorPowerHilbertSpace(%s,%s)\" % (printer._print(self.base,\n    *args), printer._print(self.exp, *args))",
    "sympy.sympy.physics.quantum.innerproduct._sympystr": "def _sympystr(self, printer, *args):\n    sbra = printer._print(self.bra)\n    sket = printer._print(self.ket)\n    return '%s|%s' % (sbra[:-1], sket[1:])",
    "sympy.sympy.physics.quantum.innerproduct._pretty": "def _pretty(self, printer, *args):\n    # Print state contents\n    bra = self.bra._print_contents_pretty(printer, *args)\n    ket = self.ket._print_contents_pretty(printer, *args)\n    # Print brackets\n    height = max(bra.height(), ket.height())\n    use_unicode = printer._use_unicode\n    lbracket, _ = self.bra._pretty_brackets(height, use_unicode)\n    cbracket, rbracket = self.ket._pretty_brackets(height, use_unicode)\n    # Build innerproduct\n    pform = prettyForm(*bra.left(lbracket))\n    pform = prettyForm(*pform.right(cbracket))\n    pform = prettyForm(*pform.right(ket))\n    pform = prettyForm(*pform.right(rbracket))\n    return pform",
    "sympy.sympy.physics.quantum.innerproduct._latex": "def _latex(self, printer, *args):\n    bra_label = self.bra._print_contents_latex(printer, *args)\n    ket = printer._print(self.ket, *args)\n    return r'\\left\\langle %s \\right. %s' % (bra_label, ket)",
    "sympy.sympy.physics.quantum.innerproduct._sympyrepr": "def _sympyrepr(self, printer, *args):\n    return '%s(%s,%s)' % (self.__class__.__name__,\n        printer._print(self.bra, *args), printer._print(self.ket, *args))",
    "sympy.sympy.physics.quantum.operator._sympystr": "def _sympystr(self, printer, *args):\n    return printer._print(self.ket) + printer._print(self.bra)",
    "sympy.sympy.physics.quantum.operator._sympyrepr": "def _sympyrepr(self, printer, *args):\n    return '%s(%s,%s)' % (self.__class__.__name__,\n        printer._print(self.ket, *args), printer._print(self.bra, *args))",
    "sympy.sympy.physics.quantum.operator._pretty": "def _pretty(self, printer, *args):\n    pform = self.ket._pretty(printer, *args)\n    return prettyForm(*pform.right(self.bra._pretty(printer, *args)))",
    "sympy.sympy.physics.quantum.operator._latex": "def _latex(self, printer, *args):\n    k = printer._print(self.ket, *args)\n    b = printer._print(self.bra, *args)\n    return k + b",
    "sympy.sympy.physics.quantum.qexpr._sympystr": "def _sympystr(self, printer, *args):\n    \"\"\"Default printing behavior of QExpr objects\n\n    Handles the default printing of a QExpr. To add other things to the\n    printing of the object, such as an operator name to operators or\n    brackets to states, the class should override the _print/_pretty/_latex\n    functions directly and make calls to _print_contents where appropriate.\n    This allows things like InnerProduct to easily control its printing the\n    printing of contents.\n    \"\"\"\n    return self._print_contents(printer, *args)",
    "sympy.sympy.physics.quantum.qexpr._sympyrepr": "def _sympyrepr(self, printer, *args):\n    classname = self.__class__.__name__\n    label = self._print_label_repr(printer, *args)\n    return '%s(%s)' % (classname, label)",
    "sympy.sympy.physics.quantum.qexpr._pretty": "def _pretty(self, printer, *args):\n    pform = self._print_contents_pretty(printer, *args)\n    return pform",
    "sympy.sympy.physics.quantum.qexpr._latex": "def _latex(self, printer, *args):\n    return self._print_contents_latex(printer, *args)",
    "sympy.sympy.physics.quantum.spin._latex": "def _latex(self, printer, *args):\n    if self.alpha == 0 and self.gamma == 0:\n        return r'd^{%s}_{%s,%s}\\left(%s\\right)' % \\\n            (\n                printer._print(self.j), printer._print(\n                    self.m), printer._print(self.mp),\n                printer._print(self.beta) )\n    return r'D^{%s}_{%s,%s}\\left(%s,%s,%s\\right)' % \\\n        (\n            printer._print(\n                self.j), printer._print(self.m), printer._print(self.mp),\n            printer._print(self.alpha), printer._print(self.beta), printer._print(self.gamma) )",
    "sympy.sympy.physics.quantum.spin._pretty": "def _pretty(self, printer, *args):\n    top = printer._print(self.j)\n\n    bot = printer._print(self.m)\n    bot = prettyForm(*bot.right(','))\n    bot = prettyForm(*bot.right(printer._print(self.mp)))\n\n    pad = max(top.width(), bot.width())\n    top = prettyForm(*top.left(' '))\n    bot = prettyForm(*bot.left(' '))\n    if pad > top.width():\n        top = prettyForm(*top.right(' '*(pad - top.width())))\n    if pad > bot.width():\n        bot = prettyForm(*bot.right(' '*(pad - bot.width())))\n    if self.alpha == 0 and self.gamma == 0:\n        args = printer._print(self.beta)\n        s = stringPict('d' + ' '*pad)\n    else:\n        args = printer._print(self.alpha)\n        args = prettyForm(*args.right(','))\n        args = prettyForm(*args.right(printer._print(self.beta)))\n        args = prettyForm(*args.right(','))\n        args = prettyForm(*args.right(printer._print(self.gamma)))\n\n        s = stringPict('D' + ' '*pad)\n\n    args = prettyForm(*args.parens())\n    s = prettyForm(*s.above(top))\n    s = prettyForm(*s.below(bot))\n    s = prettyForm(*s.right(args))\n    return s",
    "sympy.sympy.physics.quantum.state._sympystr": "def _sympystr(self, printer, *args):\n    contents = self._print_contents(printer, *args)\n    return '%s%s%s' % (getattr(self, 'lbracket', \"\"), contents, getattr(self, 'rbracket', \"\"))",
    "sympy.sympy.physics.quantum.state._pretty": "def _pretty(self, printer, *args):\n    from sympy.printing.pretty.stringpict import prettyForm\n    # Get brackets\n    pform = self._print_contents_pretty(printer, *args)\n    lbracket, rbracket = self._pretty_brackets(\n        pform.height(), printer._use_unicode)\n    # Put together state\n    pform = prettyForm(*pform.left(lbracket))\n    pform = prettyForm(*pform.right(rbracket))\n    return pform",
    "sympy.sympy.physics.quantum.state._latex": "def _latex(self, printer, *args):\n    contents = self._print_contents_latex(printer, *args)\n    # The extra {} brackets are needed to get matplotlib's latex\n    # rendered to render this properly.\n    return '{%s%s%s}' % (getattr(self, 'lbracket_latex', \"\"), contents, getattr(self, 'rbracket_latex', \"\"))",
    "sympy.sympy.physics.quantum.tensorproduct._sympystr": "def _sympystr(self, printer, *args):\n    length = len(self.args)\n    s = ''\n    for i in range(length):\n        if isinstance(self.args[i], (Add, Pow, Mul)):\n            s = s + '('\n        s = s + printer._print(self.args[i])\n        if isinstance(self.args[i], (Add, Pow, Mul)):\n            s = s + ')'\n        if i != length - 1 and not isinstance(self.args[i], (KetBase, BraBase)):\n            s = s + 'x'\n    return s",
    "sympy.sympy.physics.quantum.tensorproduct._pretty": "def _pretty(self, printer, *args):\n\n    if (_combined_printing and\n            (all(isinstance(arg, Ket) for arg in self.args) or\n             all(isinstance(arg, Bra) for arg in self.args))):\n\n        length = len(self.args)\n        pform = printer._print('', *args)\n        for i in range(length):\n            next_pform = printer._print('', *args)\n            length_i = len(self.args[i].args)\n            for j in range(length_i):\n                part_pform = printer._print(self.args[i].args[j], *args)\n                next_pform = prettyForm(*next_pform.right(part_pform))\n                if j != length_i - 1:\n                    next_pform = prettyForm(*next_pform.right(', '))\n\n            if len(self.args[i].args) > 1:\n                next_pform = prettyForm(\n                    *next_pform.parens(left='{', right='}'))\n            pform = prettyForm(*pform.right(next_pform))\n            if i != length - 1:\n                pform = prettyForm(*pform.right(',' + ' '))\n\n        pform = prettyForm(*pform.left(self.args[0].lbracket))\n        pform = prettyForm(*pform.right(self.args[0].rbracket))\n        return pform\n\n    length = len(self.args)\n    pform = printer._print('', *args)\n    for i in range(length):\n        next_pform = printer._print(self.args[i], *args)\n        if isinstance(self.args[i], (Add, Mul)):\n            next_pform = prettyForm(\n                *next_pform.parens(left='(', right=')')\n            )\n        pform = prettyForm(*pform.right(next_pform))\n        if i != length - 1 and not isinstance(self.args[i], (KetBase, BraBase)):\n            if printer._use_unicode:\n                pform = prettyForm(*pform.right('\\N{N-ARY CIRCLED TIMES OPERATOR}' + ' '))\n            else:\n                pform = prettyForm(*pform.right('x' + ' '))\n    return pform",
    "sympy.sympy.physics.quantum.tensorproduct._latex": "def _latex(self, printer, *args):\n\n    if (_combined_printing and\n            (all(isinstance(arg, Ket) for arg in self.args) or\n             all(isinstance(arg, Bra) for arg in self.args))):\n\n        def _label_wrap(label, nlabels):\n            return label if nlabels == 1 else r\"\\left\\{%s\\right\\}\" % label\n\n        s = r\", \".join([_label_wrap(arg._print_label_latex(printer, *args),\n                                    len(arg.args)) for arg in self.args])\n\n        return r\"{%s%s%s}\" % (self.args[0].lbracket_latex, s,\n                              self.args[0].rbracket_latex)\n\n    length = len(self.args)\n    s = ''\n    for i in range(length):\n        if isinstance(self.args[i], (Add, Mul)):\n            s = s + '\\\\left('\n        # The extra {} brackets are needed to get matplotlib's latex\n        # rendered to render this properly.\n        s = s + '{' + printer._print(self.args[i], *args) + '}'\n        if isinstance(self.args[i], (Add, Mul)):\n            s = s + '\\\\right)'\n        if i != length - 1 and not isinstance(self.args[i], (KetBase, BraBase)):\n            s = s + '\\\\otimes '\n    return s",
    "sympy.sympy.physics.secondquant._latex": "def _latex(self, printer):\n    return \"%s%s%s\" % (getattr(self, 'lbracket_latex', \"\"), printer._print(self._labels()), getattr(self, 'rbracket_latex', \"\"))",
    "sympy.sympy.physics.secondquant._print_Dummy": "def _print_Dummy(self, expr):\n    return \"(%s_%i)\" % (expr.name, expr.dummy_index)",
    "sympy.sympy.physics.units.prefixes._latex": "def _latex(self, printer):\n    if self._latex_repr is None:\n        return r'\\text{%s}' % self._abbrev\n    return self._latex_repr",
    "sympy.sympy.physics.units.quantities._latex": "def _latex(self, printer):\n    if self._latex_repr:\n        return self._latex_repr\n    else:\n        return r'\\text{{{}}}'.format(self.args[1] \\\n                      if len(self.args) >= 2 else self.args[0])",
    "sympy.sympy.physics.vector.dyadic._latex": "def _latex(self, printer):\n    ar = self.args  # just to shorten things\n    if len(ar) == 0:\n        return str(0)\n    ol = []  # output list, to be concatenated to a string\n    for v in ar:\n        # if the coef of the dyadic is 1, we skip the 1\n        if v[0] == 1:\n            ol.append(' + ' + printer._print(v[1]) + r\"\\otimes \" +\n                      printer._print(v[2]))\n        # if the coef of the dyadic is -1, we skip the 1\n        elif v[0] == -1:\n            ol.append(' - ' +\n                      printer._print(v[1]) +\n                      r\"\\otimes \" +\n                      printer._print(v[2]))\n        # If the coefficient of the dyadic is not 1 or -1,\n        # we might wrap it in parentheses, for readability.\n        elif v[0] != 0:\n            arg_str = printer._print(v[0])\n            if isinstance(v[0], Add):\n                arg_str = '(%s)' % arg_str\n            if arg_str.startswith('-'):\n                arg_str = arg_str[1:]\n                str_start = ' - '\n            else:\n                str_start = ' + '\n            ol.append(str_start + arg_str + printer._print(v[1]) +\n                      r\"\\otimes \" + printer._print(v[2]))\n    outstr = ''.join(ol)\n    if outstr.startswith(' + '):\n        outstr = outstr[3:]\n    elif outstr.startswith(' '):\n        outstr = outstr[1:]\n    return outstr",
    "sympy.sympy.physics.vector.dyadic._pretty": "def _pretty(self, printer):\n    e = self\n\n    class Fake:\n        baseline = 0\n\n        def render(self, *args, **kwargs):\n            ar = e.args  # just to shorten things\n            mpp = printer\n            if len(ar) == 0:\n                return str(0)\n            bar = \"\\N{CIRCLED TIMES}\" if printer._use_unicode else \"|\"\n            ol = []  # output list, to be concatenated to a string\n            for v in ar:\n                # if the coef of the dyadic is 1, we skip the 1\n                if v[0] == 1:\n                    ol.extend([\" + \",\n                              mpp.doprint(v[1]),\n                              bar,\n                              mpp.doprint(v[2])])\n\n                # if the coef of the dyadic is -1, we skip the 1\n                elif v[0] == -1:\n                    ol.extend([\" - \",\n                              mpp.doprint(v[1]),\n                              bar,\n                              mpp.doprint(v[2])])\n\n                # If the coefficient of the dyadic is not 1 or -1,\n                # we might wrap it in parentheses, for readability.\n                elif v[0] != 0:\n                    if isinstance(v[0], Add):\n                        arg_str = mpp._print(\n                            v[0]).parens()[0]\n                    else:\n                        arg_str = mpp.doprint(v[0])\n                    if arg_str.startswith(\"-\"):\n                        arg_str = arg_str[1:]\n                        str_start = \" - \"\n                    else:\n                        str_start = \" + \"\n                    ol.extend([str_start, arg_str, \" \",\n                              mpp.doprint(v[1]),\n                              bar,\n                              mpp.doprint(v[2])])\n\n            outstr = \"\".join(ol)\n            if outstr.startswith(\" + \"):\n                outstr = outstr[3:]\n            elif outstr.startswith(\" \"):\n                outstr = outstr[1:]\n            return outstr\n    return Fake()",
    "sympy.sympy.physics.vector.dyadic._sympystr": "def _sympystr(self, printer):\n    \"\"\"Printing method. \"\"\"\n    ar = self.args  # just to shorten things\n    if len(ar) == 0:\n        return printer._print(0)\n    ol = []  # output list, to be concatenated to a string\n    for v in ar:\n        # if the coef of the dyadic is 1, we skip the 1\n        if v[0] == 1:\n            ol.append(' + (' + printer._print(v[1]) + '|' +\n                      printer._print(v[2]) + ')')\n        # if the coef of the dyadic is -1, we skip the 1\n        elif v[0] == -1:\n            ol.append(' - (' + printer._print(v[1]) + '|' +\n                      printer._print(v[2]) + ')')\n        # If the coefficient of the dyadic is not 1 or -1,\n        # we might wrap it in parentheses, for readability.\n        elif v[0] != 0:\n            arg_str = printer._print(v[0])\n            if isinstance(v[0], Add):\n                arg_str = \"(%s)\" % arg_str\n            if arg_str[0] == '-':\n                arg_str = arg_str[1:]\n                str_start = ' - '\n            else:\n                str_start = ' + '\n            ol.append(str_start + arg_str + '*(' +\n                      printer._print(v[1]) +\n                      '|' + printer._print(v[2]) + ')')\n    outstr = ''.join(ol)\n    if outstr.startswith(' + '):\n        outstr = outstr[3:]\n    elif outstr.startswith(' '):\n        outstr = outstr[1:]\n    return outstr",
    "sympy.sympy.physics.vector.printing._print_Derivative": "def _print_Derivative(self, der_expr):\n    from sympy.physics.vector.functions import dynamicsymbols\n    # make sure it is in the right form\n    der_expr = der_expr.doit()\n    if not isinstance(der_expr, Derivative):\n        return r\"\\left(%s\\right)\" % self.doprint(der_expr)\n\n    # check if expr is a dynamicsymbol\n    t = dynamicsymbols._t\n    expr = der_expr.expr\n    red = expr.atoms(AppliedUndef)\n    syms = der_expr.variables\n    test1 = not all(True for i in red if i.free_symbols == {t})\n    test2 = not all(t == i for i in syms)\n    if test1 or test2:\n        return super()._print_Derivative(der_expr)\n\n    # done checking\n    dots = len(syms)\n    base = self._print_Function(expr)\n    base_split = base.split('_', 1)\n    base = base_split[0]\n    if dots == 1:\n        base = r\"\\dot{%s}\" % base\n    elif dots == 2:\n        base = r\"\\ddot{%s}\" % base\n    elif dots == 3:\n        base = r\"\\dddot{%s}\" % base\n    elif dots == 4:\n        base = r\"\\ddddot{%s}\" % base\n    else:  # Fallback to standard printing\n        return super()._print_Derivative(der_expr)\n    if len(base_split) != 1:\n        base += '_' + base_split[1]\n    return base",
    "sympy.sympy.physics.vector.printing._print_Function": "def _print_Function(self, expr, exp=None):\n    from sympy.physics.vector.functions import dynamicsymbols\n    func = expr.func.__name__\n    t = dynamicsymbols._t\n\n    if (hasattr(self, '_print_' + func) and not\n        isinstance(type(expr), UndefinedFunction)):\n        return getattr(self, '_print_' + func)(expr, exp)\n    elif isinstance(type(expr), UndefinedFunction) and (expr.args == (t,)):\n        # treat this function like a symbol\n        expr = Symbol(func)\n        if exp is not None:\n            # copied from LatexPrinter._helper_print_standard_power, which\n            # we can't call because we only have exp as a string.\n            base = self.parenthesize(expr, PRECEDENCE['Pow'])\n            base = self.parenthesize_super(base)\n            return r\"%s^{%s}\" % (base, exp)\n        else:\n            return super()._print(expr)\n    else:\n        return super()._print_Function(expr, exp)",
    "sympy.sympy.physics.vector.vector._latex": "def _latex(self, printer):\n    \"\"\"Latex Printing method. \"\"\"\n\n    ar = self.args  # just to shorten things\n    if len(ar) == 0:\n        return str(0)\n    ol = []  # output list, to be concatenated to a string\n    for v in ar:\n        for j in 0, 1, 2:\n            # if the coef of the basis vector is 1, we skip the 1\n            if v[0][j] == 1:\n                ol.append(' + ' + v[1].latex_vecs[j])\n            # if the coef of the basis vector is -1, we skip the 1\n            elif v[0][j] == -1:\n                ol.append(' - ' + v[1].latex_vecs[j])\n            elif v[0][j] != 0:\n                # If the coefficient of the basis vector is not 1 or -1;\n                # also, we might wrap it in parentheses, for readability.\n                arg_str = printer._print(v[0][j])\n                if isinstance(v[0][j], Add):\n                    arg_str = \"(%s)\" % arg_str\n                if arg_str[0] == '-':\n                    arg_str = arg_str[1:]\n                    str_start = ' - '\n                else:\n                    str_start = ' + '\n                ol.append(str_start + arg_str + v[1].latex_vecs[j])\n    outstr = ''.join(ol)\n    if outstr.startswith(' + '):\n        outstr = outstr[3:]\n    elif outstr.startswith(' '):\n        outstr = outstr[1:]\n    return outstr",
    "sympy.sympy.physics.vector.vector._pretty": "def _pretty(self, printer):\n    \"\"\"Pretty Printing method. \"\"\"\n    from sympy.printing.pretty.stringpict import prettyForm\n\n    terms = []\n\n    def juxtapose(a, b):\n        pa = printer._print(a)\n        pb = printer._print(b)\n        if a.is_Add:\n            pa = prettyForm(*pa.parens())\n        return printer._print_seq([pa, pb], delimiter=' ')\n\n    for M, N in self.args:\n        for i in range(3):\n            if M[i] == 0:\n                continue\n            elif M[i] == 1:\n                terms.append(prettyForm(N.pretty_vecs[i]))\n            elif M[i] == -1:\n                terms.append(prettyForm(\"-1\") * prettyForm(N.pretty_vecs[i]))\n            else:\n                terms.append(juxtapose(M[i], N.pretty_vecs[i]))\n\n    if terms:\n        pretty_result = prettyForm.__add__(*terms)\n    else:\n        pretty_result = prettyForm(\"0\")\n\n    return pretty_result",
    "sympy.sympy.physics.vector.vector._sympystr": "def _sympystr(self, printer, order=True):\n    \"\"\"Printing method. \"\"\"\n    if not order or len(self.args) == 1:\n        ar = list(self.args)\n    elif len(self.args) == 0:\n        return printer._print(0)\n    else:\n        d = {v[1]: v[0] for v in self.args}\n        keys = sorted(d.keys(), key=lambda x: x.index)\n        ar = []\n        for key in keys:\n            ar.append((d[key], key))\n    ol = []  # output list, to be concatenated to a string\n    for v in ar:\n        for j in 0, 1, 2:\n            # if the coef of the basis vector is 1, we skip the 1\n            if v[0][j] == 1:\n                ol.append(' + ' + v[1].str_vecs[j])\n            # if the coef of the basis vector is -1, we skip the 1\n            elif v[0][j] == -1:\n                ol.append(' - ' + v[1].str_vecs[j])\n            elif v[0][j] != 0:\n                # If the coefficient of the basis vector is not 1 or -1;\n                # also, we might wrap it in parentheses, for readability.\n                arg_str = printer._print(v[0][j])\n                if isinstance(v[0][j], Add):\n                    arg_str = \"(%s)\" % arg_str\n                if arg_str[0] == '-':\n                    arg_str = arg_str[1:]\n                    str_start = ' - '\n                else:\n                    str_start = ' + '\n                ol.append(str_start + arg_str + '*' + v[1].str_vecs[j])\n    outstr = ''.join(ol)\n    if outstr.startswith(' + '):\n        outstr = outstr[3:]\n    elif outstr.startswith(' '):\n        outstr = outstr[1:]\n    return outstr",
    "sympy.sympy.printing.c._meth_wrapper": "@wraps(meth)\ndef _meth_wrapper(self, expr, **kwargs):\n    if expr in self.math_macros:\n        return '%s%s' % (self.math_macros[expr], self._get_math_macro_suffix(real))\n    else:\n        return meth(self, expr, **kwargs)",
    "sympy.sympy.printing.c._print_Mod": "def _print_Mod(self, expr):\n    num, den = expr.args\n    if num.is_integer and den.is_integer:\n        PREC = precedence(expr)\n        snum, sden = [self.parenthesize(arg, PREC) for arg in expr.args]\n        # % is remainder (same sign as numerator), not modulo (same sign as\n        # denominator), in C. Hence, % only works as modulo if both numbers\n        # have the same sign\n        if (num.is_nonnegative and den.is_nonnegative or\n            num.is_nonpositive and den.is_nonpositive):\n            return f\"{snum} % {sden}\"\n        return f\"(({snum} % {sden}) + {sden}) % {sden}\"\n    # Not guaranteed integer\n    return self._print_math_func(expr, known='fmod')",
    "sympy.sympy.printing.c._print_Rational": "def _print_Rational(self, expr):\n    p, q = int(expr.p), int(expr.q)\n    suffix = self._get_literal_suffix(real)\n    return '%d.0%s/%d.0%s' % (p, suffix, q, suffix)",
    "sympy.sympy.printing.c._print_Indexed": "def _print_Indexed(self, expr):\n    # calculate index for 1d array\n    offset = getattr(expr.base, 'offset', S.Zero)\n    strides = getattr(expr.base, 'strides', None)\n    indices = expr.indices\n\n    if strides is None or isinstance(strides, str):\n        dims = expr.shape\n        shift = S.One\n        temp = ()\n        if strides == 'C' or strides is None:\n            traversal = reversed(range(expr.rank))\n            indices = indices[::-1]\n        elif strides == 'F':\n            traversal = range(expr.rank)\n\n        for i in traversal:\n            temp += (shift,)\n            shift *= dims[i]\n        strides = temp\n    flat_index = sum(x[0]*x[1] for x in zip(indices, strides)) + offset\n    return \"%s[%s]\" % (self._print(expr.base.label),\n                       self._print(flat_index))",
    "sympy.sympy.printing.c._print_Infinity": "def _print_Infinity(self, expr):\n    return 'INFINITY'",
    "sympy.sympy.printing.c._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-INFINITY'",
    "sympy.sympy.printing.c._print_Piecewise": "def _print_Piecewise(self, expr):\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n    if expr.has(Assignment):\n        for i, (e, c) in enumerate(expr.args):\n            if i == 0:\n                lines.append(\"if (%s) {\" % self._print(c))\n            elif i == len(expr.args) - 1 and c == True:\n                lines.append(\"else {\")\n            else:\n                lines.append(\"else if (%s) {\" % self._print(c))\n            code0 = self._print(e)\n            lines.append(code0)\n            lines.append(\"}\")\n        return \"\\n\".join(lines)\n    else:\n        # The piecewise was used in an expression, need to do inline\n        # operators. This has the downside that inline operators will\n        # not work for statements that span multiple lines (Matrix or\n        # Indexed expressions).\n        ecpairs = [\"((%s) ? (\\n%s\\n)\\n\" % (self._print(c),\n                                           self._print(e))\n                for e, c in expr.args[:-1]]\n        last_line = \": (\\n%s\\n)\" % self._print(expr.args[-1].expr)\n        return \": \".join(ecpairs) + last_line + \" \".join([\")\"*len(ecpairs)])",
    "sympy.sympy.printing.c._print_ITE": "def _print_ITE(self, expr):\n    from sympy.functions import Piecewise\n    return self._print(expr.rewrite(Piecewise, deep=False))",
    "sympy.sympy.printing.c._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return \"{}[{}]\".format(self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"],\n        strict=True), expr.j + expr.i*expr.parent.shape[1])",
    "sympy.sympy.printing.c._print_Symbol": "def _print_Symbol(self, expr):\n    name = super()._print_Symbol(expr)\n    if expr in self._settings['dereference']:\n        return '(*{})'.format(name)\n    else:\n        return name",
    "sympy.sympy.printing.c._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.c._print_For": "def _print_For(self, expr):\n    target = self._print(expr.target)\n    if isinstance(expr.iterable, Range):\n        start, stop, step = expr.iterable.args\n    else:\n        raise NotImplementedError(\"Only iterable currently supported is Range\")\n    body = self._print(expr.body)\n    return ('for ({target} = {start}; {target} < {stop}; {target} += '\n            '{step}) {{\\n{body}\\n}}').format(target=target, start=start,\n            stop=stop, step=step, body=body)",
    "sympy.sympy.printing.c._print_sign": "def _print_sign(self, func):\n    return '((({0}) > 0) - (({0}) < 0))'.format(self._print(func.args[0]))",
    "sympy.sympy.printing.c._print_Max": "def _print_Max(self, expr):\n    return self._print_math_func(expr, nest=True)",
    "sympy.sympy.printing.c._print_Min": "def _print_Min(self, expr):\n    return self._print_math_func(expr, nest=True)",
    "sympy.sympy.printing.c._print_Tuple": "def _print_Tuple(self, expr):\n    return '{'+', '.join(self._print(e) for e in expr)+'}'",
    "sympy.sympy.printing.c._print_Type": "def _print_Type(self, type_):\n    self.headers.update(self.type_headers.get(type_, set()))\n    self.macros.update(self.type_macros.get(type_, set()))\n    return self._print(self.type_mappings.get(type_, type_.name))",
    "sympy.sympy.printing.c._print_Declaration": "def _print_Declaration(self, decl):\n    from sympy.codegen.cnodes import restrict\n    var = decl.variable\n    val = var.value\n    if var.type == untyped:\n        raise ValueError(\"C does not support untyped variables\")\n\n    if isinstance(var, Pointer):\n        result = '{vc}{t} *{pc} {r}{s}'.format(\n            vc='const ' if value_const in var.attrs else '',\n            t=self._print(var.type),\n            pc=' const' if pointer_const in var.attrs else '',\n            r='restrict ' if restrict in var.attrs else '',\n            s=self._print(var.symbol)\n        )\n    elif isinstance(var, Variable):\n        result = '{vc}{t} {s}'.format(\n            vc='const ' if value_const in var.attrs else '',\n            t=self._print(var.type),\n            s=self._print(var.symbol)\n        )\n    else:\n        raise NotImplementedError(\"Unknown type of var: %s\" % type(var))\n    if val != None: # Must be \"!= None\", cannot be \"is not None\"\n        result += ' = %s' % self._print(val)\n    return result",
    "sympy.sympy.printing.c._print_Float": "def _print_Float(self, flt):\n    type_ = self.type_aliases.get(real, real)\n    self.macros.update(self.type_macros.get(type_, set()))\n    suffix = self._get_literal_suffix(type_)\n    num = str(flt.evalf(type_.decimal_dig))\n    if 'e' not in num and '.' not in num:\n        num += '.0'\n    num_parts = num.split('e')\n    num_parts[0] = num_parts[0].rstrip('0')\n    if num_parts[0].endswith('.'):\n        num_parts[0] += '0'\n    return 'e'.join(num_parts) + suffix",
    "sympy.sympy.printing.c._print_Element": "def _print_Element(self, elem):\n    if elem.strides == None: # Must be \"== None\", cannot be \"is None\"\n        if elem.offset != None: # Must be \"!= None\", cannot be \"is not None\"\n            raise ValueError(\"Expected strides when offset is given\")\n        idxs = ']['.join((self._print(arg) for arg in elem.indices))\n    else:\n        global_idx = sum(i*s for i, s in zip(elem.indices, elem.strides))\n        if elem.offset != None: # Must be \"!= None\", cannot be \"is not None\"\n            global_idx += elem.offset\n        idxs = self._print(global_idx)\n\n    return \"{symb}[{idxs}]\".format(\n        symb=self._print(elem.symbol),\n        idxs=idxs\n    )",
    "sympy.sympy.printing.c._print_CodeBlock": "def _print_CodeBlock(self, expr):\n    \"\"\" Elements of code blocks printed as statements. \"\"\"\n    return '\\n'.join([self._get_statement(self._print(i)) for i in expr.args])",
    "sympy.sympy.printing.c._print_While": "def _print_While(self, expr):\n    return 'while ({condition}) {{\\n{body}\\n}}'.format(**expr.kwargs(\n        apply=lambda arg: self._print(arg)))",
    "sympy.sympy.printing.c._print_Scope": "def _print_Scope(self, expr):\n    return '{\\n%s\\n}' % self._print_CodeBlock(expr.body)",
    "sympy.sympy.printing.c._print_Stream": "def _print_Stream(self, strm):\n    return strm.name",
    "sympy.sympy.printing.c._print_FunctionPrototype": "def _print_FunctionPrototype(self, expr):\n    pars = ', '.join((self._print(Declaration(arg)) for arg in expr.parameters))\n    return \"%s %s(%s)\" % (\n        tuple((self._print(arg) for arg in (expr.return_type, expr.name))) + (pars,)\n    )",
    "sympy.sympy.printing.c._print_FunctionDefinition": "def _print_FunctionDefinition(self, expr):\n    return \"%s%s\" % (self._print_FunctionPrototype(expr),\n                     self._print_Scope(expr))",
    "sympy.sympy.printing.c._print_Return": "def _print_Return(self, expr):\n    arg, = expr.args\n    return 'return %s' % self._print(arg)",
    "sympy.sympy.printing.c._print_CommaOperator": "def _print_CommaOperator(self, expr):\n    return '(%s)' % ', '.join((self._print(arg) for arg in expr.args))",
    "sympy.sympy.printing.c._print_Label": "def _print_Label(self, expr):\n    if expr.body == none:\n        return '%s:' % str(expr.name)\n    if len(expr.body.args) == 1:\n        return '%s:\\n%s' % (str(expr.name), self._print_CodeBlock(expr.body))\n    return '%s:\\n{\\n%s\\n}' % (str(expr.name), self._print_CodeBlock(expr.body))",
    "sympy.sympy.printing.c._print_goto": "def _print_goto(self, expr):\n    return 'goto %s' % expr.label.name",
    "sympy.sympy.printing.c._print_PreIncrement": "def _print_PreIncrement(self, expr):\n    arg, = expr.args\n    return '++(%s)' % self._print(arg)",
    "sympy.sympy.printing.c._print_PostIncrement": "def _print_PostIncrement(self, expr):\n    arg, = expr.args\n    return '(%s)++' % self._print(arg)",
    "sympy.sympy.printing.c._print_PreDecrement": "def _print_PreDecrement(self, expr):\n    arg, = expr.args\n    return '--(%s)' % self._print(arg)",
    "sympy.sympy.printing.c._print_PostDecrement": "def _print_PostDecrement(self, expr):\n    arg, = expr.args\n    return '(%s)--' % self._print(arg)",
    "sympy.sympy.printing.c._print_struct": "def _print_struct(self, expr):\n    return \"%(keyword)s %(name)s {\\n%(lines)s}\" % {\n        \"keyword\": expr.__class__.__name__, \"name\": expr.name, \"lines\": ';\\n'.join(\n            [self._print(decl) for decl in expr.declarations] + [''])\n    }",
    "sympy.sympy.printing.c._print_NaN": "def _print_NaN(self, expr):\n    return 'NAN'",
    "sympy.sympy.printing.codeprinter._method_wrapper": "def _method_wrapper(self_, *args, **kwargs):\n    for k, v in self._req.items():\n        getattr(self_, k).update(v)\n    return method(self_, *args, **kwargs)",
    "sympy.sympy.printing.codeprinter._print_Dummy": "def _print_Dummy(self, expr):\n    if expr.name.startswith('Dummy_'):\n        return '_' + expr.name\n    else:\n        return '%s_%d' % (expr.name, expr.dummy_index)",
    "sympy.sympy.printing.codeprinter._print_Idx": "def _print_Idx(self, expr):\n    return self._print(expr.label)",
    "sympy.sympy.printing.codeprinter._print_CodeBlock": "def _print_CodeBlock(self, expr):\n    return '\\n'.join([self._print(i) for i in expr.args])",
    "sympy.sympy.printing.codeprinter._print_String": "def _print_String(self, string):\n    return str(string)",
    "sympy.sympy.printing.codeprinter._print_QuotedString": "def _print_QuotedString(self, arg):\n    return '\"%s\"' % arg.text",
    "sympy.sympy.printing.codeprinter._print_Comment": "def _print_Comment(self, string):\n    return self._get_comment(str(string))",
    "sympy.sympy.printing.codeprinter._print_Assignment": "def _print_Assignment(self, expr):\n    from sympy.codegen.ast import Assignment\n    from sympy.functions.elementary.piecewise import Piecewise\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    from sympy.tensor.indexed import IndexedBase\n    lhs = expr.lhs\n    rhs = expr.rhs\n    # We special case assignments that take multiple lines\n    if isinstance(expr.rhs, Piecewise):\n        # Here we modify Piecewise so each expression is now\n        # an Assignment, and then continue on the print.\n        expressions = []\n        conditions = []\n        for (e, c) in rhs.args:\n            expressions.append(Assignment(lhs, e))\n            conditions.append(c)\n        temp = Piecewise(*zip(expressions, conditions))\n        return self._print(temp)\n    elif isinstance(lhs, MatrixSymbol):\n        # Here we form an Assignment for each element in the array,\n        # printing each one.\n        lines = []\n        for (i, j) in self._traverse_matrix_indices(lhs):\n            temp = Assignment(lhs[i, j], rhs[i, j])\n            code0 = self._print(temp)\n            lines.append(code0)\n        return \"\\n\".join(lines)\n    elif self._settings.get(\"contract\", False) and (lhs.has(IndexedBase) or\n            rhs.has(IndexedBase)):\n        # Here we check if there is looping to be done, and if so\n        # print the required loops.\n        return self._doprint_loops(rhs, lhs)\n    else:\n        lhs_code = self._print(lhs)\n        rhs_code = self._print(rhs)\n        return self._get_statement(\"%s = %s\" % (lhs_code, rhs_code))",
    "sympy.sympy.printing.codeprinter._print_AugmentedAssignment": "def _print_AugmentedAssignment(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    return self._get_statement(\"{} {} {}\".format(\n        *(self._print(arg) for arg in [lhs_code, expr.op, rhs_code])))",
    "sympy.sympy.printing.codeprinter._print_FunctionCall": "def _print_FunctionCall(self, expr):\n    return '%s(%s)' % (\n        expr.name,\n        ', '.join((self._print(arg) for arg in expr.function_args)))",
    "sympy.sympy.printing.codeprinter._print_Variable": "def _print_Variable(self, expr):\n    return self._print(expr.symbol)",
    "sympy.sympy.printing.codeprinter._print_Symbol": "def _print_Symbol(self, expr):\n    name = super()._print_Symbol(expr)\n\n    if name in self.reserved_words:\n        if self._settings['error_on_reserved']:\n            msg = ('This expression includes the symbol \"{}\" which is a '\n                   'reserved keyword in this language.')\n            raise ValueError(msg.format(name))\n        return name + self._settings['reserved_word_suffix']\n    else:\n        return name",
    "sympy.sympy.printing.codeprinter._print_Function": "def _print_Function(self, expr):\n    if expr.func.__name__ in self.known_functions:\n        cond_func = self.known_functions[expr.func.__name__]\n        if isinstance(cond_func, str):\n            return \"%s(%s)\" % (cond_func, self.stringify(expr.args, \", \"))\n        else:\n            for cond, func in cond_func:\n                if cond(*expr.args):\n                    break\n            if func is not None:\n                try:\n                    return func(*[self.parenthesize(item, 0) for item in expr.args])\n                except TypeError:\n                    return \"%s(%s)\" % (func, self.stringify(expr.args, \", \"))\n    elif hasattr(expr, '_imp_') and isinstance(expr._imp_, Lambda):\n        # inlined function\n        return self._print(expr._imp_(*expr.args))\n    elif expr.func.__name__ in self._rewriteable_functions:\n        # Simple rewrite to supported function possible\n        target_f, required_fs = self._rewriteable_functions[expr.func.__name__]\n        if self._can_print(target_f) and all(self._can_print(f) for f in required_fs):\n            return '(' + self._print(expr.rewrite(target_f)) + ')'\n\n    if expr.is_Function and self._settings.get('allow_unknown_functions', False):\n        return '%s(%s)' % (self._print(expr.func), ', '.join(map(self._print, expr.args)))\n    else:\n        return self._print_not_supported(expr)",
    "sympy.sympy.printing.codeprinter._print_Derivative": "def _print_Derivative(self, expr):\n    obj, *wrt_order_pairs = expr.args\n    for func_arg in obj.args:\n        if not func_arg.is_Symbol:\n            raise ValueError(\"%s._print_Derivative(...) only supports functions with symbols as arguments.\" %\n                             self.__class__.__name__)\n    meth_name = '_print_Derivative_%s' % obj.func.__name__\n    pmeth = getattr(self, meth_name, None)\n    if pmeth is None:\n        if self._settings.get('strict', False):\n            raise PrintMethodNotImplementedError(\n                f\"Unsupported by {type(self)}: {type(expr)}\" +\n                f\"\\nPrinter has no method: {meth_name}\" +\n                \"\\nSet the printer option 'strict' to False in order to generate partially printed code.\"\n            )\n        return self._print_not_supported(expr)\n    orders = dict(wrt_order_pairs)\n    seq_orders = [orders[arg] for arg in obj.args]\n    return pmeth(obj.args, seq_orders)",
    "sympy.sympy.printing.codeprinter._print_Catalan": "def _print_Catalan(self, expr):\n    return self._print_NumberSymbol(expr)",
    "sympy.sympy.printing.codeprinter._print_EulerGamma": "def _print_EulerGamma(self, expr):\n    return self._print_NumberSymbol(expr)",
    "sympy.sympy.printing.codeprinter._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    return self._print_NumberSymbol(expr)",
    "sympy.sympy.printing.codeprinter._print_Exp1": "def _print_Exp1(self, expr):\n    return self._print_NumberSymbol(expr)",
    "sympy.sympy.printing.codeprinter._print_Pi": "def _print_Pi(self, expr):\n    return self._print_NumberSymbol(expr)",
    "sympy.sympy.printing.codeprinter._print_And": "def _print_And(self, expr):\n    PREC = precedence(expr)\n    return (\" %s \" % self._operators['and']).join(self.parenthesize(a, PREC)\n            for a in sorted(expr.args, key=default_sort_key))",
    "sympy.sympy.printing.codeprinter._print_Or": "def _print_Or(self, expr):\n    PREC = precedence(expr)\n    return (\" %s \" % self._operators['or']).join(self.parenthesize(a, PREC)\n            for a in sorted(expr.args, key=default_sort_key))",
    "sympy.sympy.printing.codeprinter._print_Xor": "def _print_Xor(self, expr):\n    if self._operators.get('xor') is None:\n        return self._print(expr.to_nnf())\n    PREC = precedence(expr)\n    return (\" %s \" % self._operators['xor']).join(self.parenthesize(a, PREC)\n            for a in expr.args)",
    "sympy.sympy.printing.codeprinter._print_Equivalent": "def _print_Equivalent(self, expr):\n    if self._operators.get('equivalent') is None:\n        return self._print(expr.to_nnf())\n    PREC = precedence(expr)\n    return (\" %s \" % self._operators['equivalent']).join(self.parenthesize(a, PREC)\n            for a in expr.args)",
    "sympy.sympy.printing.codeprinter._print_Not": "def _print_Not(self, expr):\n    PREC = precedence(expr)\n    return self._operators['not'] + self.parenthesize(expr.args[0], PREC)",
    "sympy.sympy.printing.codeprinter._print_BooleanFunction": "def _print_BooleanFunction(self, expr):\n    return self._print(expr.to_nnf())",
    "sympy.sympy.printing.codeprinter._print_isnan": "def _print_isnan(self, arg):\n    return 'isnan(%s)' % self._print(*arg.args)",
    "sympy.sympy.printing.codeprinter._print_isinf": "def _print_isinf(self, arg):\n    return 'isinf(%s)' % self._print(*arg.args)",
    "sympy.sympy.printing.codeprinter._print_Mul": "def _print_Mul(self, expr):\n\n    prec = precedence(expr)\n\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = \"-\"\n    else:\n        sign = \"\"\n\n    a = []  # items in the numerator\n    b = []  # items that are in the denominator (if any)\n\n    pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        # use make_args in case expr was something like -x -> x\n        args = Mul.make_args(expr)\n\n    # Gather args for numerator/denominator\n    for item in args:\n        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n                    pow_paren.append(item)\n                b.append(Pow(item.base, -item.exp))\n        else:\n            a.append(item)\n\n    a = a or [S.One]\n\n    if len(a) == 1 and sign == \"-\":\n        # Unary minus does not have a SymPy class, and hence there's no\n        # precedence weight associated with it, Python's unary minus has\n        # an operator precedence between multiplication and exponentiation,\n        # so we use this to compute a weight.\n        a_str = [self.parenthesize(a[0], 0.5*(PRECEDENCE[\"Pow\"]+PRECEDENCE[\"Mul\"]))]\n    else:\n        a_str = [self.parenthesize(x, prec) for x in a]\n    b_str = [self.parenthesize(x, prec) for x in b]\n\n    # To parenthesize Pow with exp = -1 and having more than one Symbol\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n\n    if not b:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + \"/\" + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + \"/(%s)\" % '*'.join(b_str)",
    "sympy.sympy.printing.codeprinter._print_not_supported": "def _print_not_supported(self, expr):\n    if self._settings.get('strict', False):\n        raise PrintMethodNotImplementedError(\n            f\"Unsupported by {type(self)}: {type(expr)}\" +\n            \"\\nSet the printer option 'strict' to False in order to generate partially printed code.\"\n        )\n    try:\n        self._not_supported.add(expr)\n    except TypeError:\n        # not hashable\n        pass\n    return self.emptyPrinter(expr)",
    "sympy.sympy.printing.cxx._print_using": "def _print_using(self, expr):\n    if expr.alias == none:\n        return super()._print_using(expr)\n    else:\n        return 'using %(alias)s = %(type)s' % expr.kwargs(apply=self._print)",
    "sympy.sympy.printing.cxx._print_beta": "def _print_beta(self, expr):\n    return self._print_math_func(expr)",
    "sympy.sympy.printing.cxx._print_Ei": "def _print_Ei(self, expr):\n    return self._print_math_func(expr)",
    "sympy.sympy.printing.cxx._print_zeta": "def _print_zeta(self, expr):\n    return self._print_math_func(expr)",
    "sympy.sympy.printing.fortran._print_Symbol": "def _print_Symbol(self, expr):\n    if self._settings['name_mangling'] == True:\n        if expr not in self.mangled_symbols:\n            name = expr.name\n            while name.lower() in self.used_name:\n                name += '_'\n            self.used_name.append(name.lower())\n            if name == expr.name:\n                self.mangled_symbols[expr] = expr\n            else:\n                self.mangled_symbols[expr] = Symbol(name)\n\n        expr = expr.xreplace(self.mangled_symbols)\n\n    name = super()._print_Symbol(expr)\n    return name",
    "sympy.sympy.printing.fortran._print_sign": "def _print_sign(self, expr):\n    from sympy.functions.elementary.complexes import Abs\n    arg, = expr.args\n    if arg.is_integer:\n        new_expr = merge(0, isign(1, arg), Eq(arg, 0))\n    elif (arg.is_complex or arg.is_infinite):\n        new_expr = merge(cmplx(literal_dp(0), literal_dp(0)), arg/Abs(arg), Eq(Abs(arg), literal_dp(0)))\n    else:\n        new_expr = merge(literal_dp(0), dsign(literal_dp(1), arg), Eq(arg, literal_dp(0)))\n    return self._print(new_expr)",
    "sympy.sympy.printing.fortran._print_Piecewise": "def _print_Piecewise(self, expr):\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n    if expr.has(Assignment):\n        for i, (e, c) in enumerate(expr.args):\n            if i == 0:\n                lines.append(\"if (%s) then\" % self._print(c))\n            elif i == len(expr.args) - 1 and c == True:\n                lines.append(\"else\")\n            else:\n                lines.append(\"else if (%s) then\" % self._print(c))\n            lines.append(self._print(e))\n        lines.append(\"end if\")\n        return \"\\n\".join(lines)\n    elif self._settings[\"standard\"] >= 95:\n        # Only supported in F95 and newer:\n        # The piecewise was used in an expression, need to do inline\n        # operators. This has the downside that inline operators will\n        # not work for statements that span multiple lines (Matrix or\n        # Indexed expressions).\n        pattern = \"merge({T}, {F}, {COND})\"\n        code = self._print(expr.args[-1].expr)\n        terms = list(expr.args[:-1])\n        while terms:\n            e, c = terms.pop()\n            expr = self._print(e)\n            cond = self._print(c)\n            code = pattern.format(T=expr, F=code, COND=cond)\n        return code\n    else:\n        # `merge` is not supported prior to F95\n        raise NotImplementedError(\"Using Piecewise as an expression using \"\n                                  \"inline operators is not supported in \"\n                                  \"standards earlier than Fortran95.\")",
    "sympy.sympy.printing.fortran._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return \"{}({}, {})\".format(self.parenthesize(expr.parent,\n            PRECEDENCE[\"Atom\"], strict=True), expr.i + 1, expr.j + 1)",
    "sympy.sympy.printing.fortran._print_Add": "def _print_Add(self, expr):\n    # purpose: print complex numbers nicely in Fortran.\n    # collect the purely real and purely imaginary parts:\n    pure_real = []\n    pure_imaginary = []\n    mixed = []\n    for arg in expr.args:\n        if arg.is_number and arg.is_real:\n            pure_real.append(arg)\n        elif arg.is_number and arg.is_imaginary:\n            pure_imaginary.append(arg)\n        else:\n            mixed.append(arg)\n    if pure_imaginary:\n        if mixed:\n            PREC = precedence(expr)\n            term = Add(*mixed)\n            t = self._print(term)\n            if t.startswith('-'):\n                sign = \"-\"\n                t = t[1:]\n            else:\n                sign = \"+\"\n            if precedence(term) < PREC:\n                t = \"(%s)\" % t\n\n            return \"cmplx(%s,%s) %s %s\" % (\n                self._print(Add(*pure_real)),\n                self._print(-S.ImaginaryUnit*Add(*pure_imaginary)),\n                sign, t,\n            )\n        else:\n            return \"cmplx(%s,%s)\" % (\n                self._print(Add(*pure_real)),\n                self._print(-S.ImaginaryUnit*Add(*pure_imaginary)),\n            )\n    else:\n        return CodePrinter._print_Add(self, expr)",
    "sympy.sympy.printing.fortran._print_Function": "def _print_Function(self, expr):\n    # All constant function args are evaluated as floats\n    prec =  self._settings['precision']\n    args = [N(a, prec) for a in expr.args]\n    eval_expr = expr.func(*args)\n    if not isinstance(eval_expr, Function):\n        return self._print(eval_expr)\n    else:\n        return CodePrinter._print_Function(self, expr.func(*args))",
    "sympy.sympy.printing.fortran._print_Mod": "def _print_Mod(self, expr):\n    # NOTE : Fortran has the functions mod() and modulo(). modulo() behaves\n    # the same wrt to the sign of the arguments as Python and SymPy's\n    # modulus computations (% and Mod()) but is not available in Fortran 66\n    # or Fortran 77, thus we raise an error.\n    if self._settings['standard'] in [66, 77]:\n        msg = (\"Python % operator and SymPy's Mod() function are not \"\n               \"supported by Fortran 66 or 77 standards.\")\n        raise NotImplementedError(msg)\n    else:\n        x, y = expr.args\n        return \"      modulo({}, {})\".format(self._print(x), self._print(y))",
    "sympy.sympy.printing.fortran._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    # purpose: print complex numbers nicely in Fortran.\n    return \"cmplx(0,1)\"",
    "sympy.sympy.printing.fortran._print_int": "def _print_int(self, expr):\n    return str(expr)",
    "sympy.sympy.printing.fortran._print_Mul": "def _print_Mul(self, expr):\n    # purpose: print complex numbers nicely in Fortran.\n    if expr.is_number and expr.is_imaginary:\n        return \"cmplx(0,%s)\" % (\n            self._print(-S.ImaginaryUnit*expr)\n        )\n    else:\n        return CodePrinter._print_Mul(self, expr)",
    "sympy.sympy.printing.fortran._print_Pow": "def _print_Pow(self, expr):\n    PREC = precedence(expr)\n    if equal_valued(expr.exp, -1):\n        return '%s/%s' % (\n            self._print(literal_dp(1)),\n            self.parenthesize(expr.base, PREC)\n        )\n    elif equal_valued(expr.exp, 0.5):\n        if expr.base.is_integer:\n            # Fortran intrinsic sqrt() does not accept integer argument\n            if expr.base.is_Number:\n                return 'sqrt(%s.0d0)' % self._print(expr.base)\n            else:\n                return 'sqrt(dble(%s))' % self._print(expr.base)\n        else:\n            return 'sqrt(%s)' % self._print(expr.base)\n    else:\n        return CodePrinter._print_Pow(self, expr)",
    "sympy.sympy.printing.fortran._print_Rational": "def _print_Rational(self, expr):\n    p, q = int(expr.p), int(expr.q)\n    return \"%d.0d0/%d.0d0\" % (p, q)",
    "sympy.sympy.printing.fortran._print_Float": "def _print_Float(self, expr):\n    printed = CodePrinter._print_Float(self, expr)\n    e = printed.find('e')\n    if e > -1:\n        return \"%sd%s\" % (printed[:e], printed[e + 1:])\n    return \"%sd0\" % printed",
    "sympy.sympy.printing.fortran._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    op = op if op not in self._relationals else self._relationals[op]\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.fortran._print_Indexed": "def _print_Indexed(self, expr):\n    inds = [ self._print(i) for i in expr.indices ]\n    return \"%s(%s)\" % (self._print(expr.base.label), \", \".join(inds))",
    "sympy.sympy.printing.fortran._print_AugmentedAssignment": "def _print_AugmentedAssignment(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    return self._get_statement(\"{0} = {0} {1} {2}\".format(\n        self._print(lhs_code), self._print(expr.binop), self._print(rhs_code)))",
    "sympy.sympy.printing.fortran._print_sum_": "def _print_sum_(self, sm):\n    params = self._print(sm.array)\n    if sm.dim != None: # Must use '!= None', cannot use 'is not None'\n        params += ', ' + self._print(sm.dim)\n    if sm.mask != None: # Must use '!= None', cannot use 'is not None'\n        params += ', mask=' + self._print(sm.mask)\n    return '%s(%s)' % (sm.__class__.__name__.rstrip('_'), params)",
    "sympy.sympy.printing.fortran._print_Do": "def _print_Do(self, do):\n    excl = ['concurrent']\n    if do.step == 1:\n        excl.append('step')\n        step = ''\n    else:\n        step = ', {step}'\n\n    return (\n        'do {concurrent}{counter} = {first}, {last}'+step+'\\n'\n        '{body}\\n'\n        'end do\\n'\n    ).format(\n        concurrent='concurrent ' if do.concurrent else '',\n        **do.kwargs(apply=lambda arg: self._print(arg), exclude=excl)\n    )",
    "sympy.sympy.printing.fortran._print_ImpliedDoLoop": "def _print_ImpliedDoLoop(self, idl):\n    step = '' if idl.step == 1 else ', {step}'\n    return ('({expr}, {counter} = {first}, {last}'+step+')').format(\n        **idl.kwargs(apply=lambda arg: self._print(arg))\n    )",
    "sympy.sympy.printing.fortran._print_For": "def _print_For(self, expr):\n    target = self._print(expr.target)\n    if isinstance(expr.iterable, Range):\n        start, stop, step = expr.iterable.args\n    else:\n        raise NotImplementedError(\"Only iterable currently supported is Range\")\n    body = self._print(expr.body)\n    return ('do {target} = {start}, {stop}, {step}\\n'\n            '{body}\\n'\n            'end do').format(target=target, start=start, stop=stop - 1,\n                    step=step, body=body)",
    "sympy.sympy.printing.fortran._print_Type": "def _print_Type(self, type_):\n    type_ = self.type_aliases.get(type_, type_)\n    type_str = self.type_mappings.get(type_, type_.name)\n    module_uses = self.type_modules.get(type_)\n    if module_uses:\n        for k, v in module_uses:\n            self.module_uses[k].add(v)\n    return type_str",
    "sympy.sympy.printing.fortran._print_Element": "def _print_Element(self, elem):\n    return '{symbol}({idxs})'.format(\n        symbol=self._print(elem.symbol),\n        idxs=', '.join((self._print(arg) for arg in elem.indices))\n    )",
    "sympy.sympy.printing.fortran._print_Extent": "def _print_Extent(self, ext):\n    return str(ext)",
    "sympy.sympy.printing.fortran._print_Declaration": "def _print_Declaration(self, expr):\n    var = expr.variable\n    val = var.value\n    dim = var.attr_params('dimension')\n    intents = [intent in var.attrs for intent in (intent_in, intent_out, intent_inout)]\n    if intents.count(True) == 0:\n        intent = ''\n    elif intents.count(True) == 1:\n        intent = ', intent(%s)' % ['in', 'out', 'inout'][intents.index(True)]\n    else:\n        raise ValueError(\"Multiple intents specified for %s\" % self)\n\n    if isinstance(var, Pointer):\n        raise NotImplementedError(\"Pointers are not available by default in Fortran.\")\n    if self._settings[\"standard\"] >= 90:\n        result = '{t}{vc}{dim}{intent}{alloc} :: {s}'.format(\n            t=self._print(var.type),\n            vc=', parameter' if value_const in var.attrs else '',\n            dim=', dimension(%s)' % ', '.join((self._print(arg) for arg in dim)) if dim else '',\n            intent=intent,\n            alloc=', allocatable' if allocatable in var.attrs else '',\n            s=self._print(var.symbol)\n        )\n        if val != None: # Must be \"!= None\", cannot be \"is not None\"\n            result += ' = %s' % self._print(val)\n    else:\n        if value_const in var.attrs or val:\n            raise NotImplementedError(\"F77 init./parameter statem. req. multiple lines.\")\n        result = ' '.join((self._print(arg) for arg in [var.type, var.symbol]))\n\n    return result",
    "sympy.sympy.printing.fortran._print_While": "def _print_While(self, expr):\n    return 'do while ({condition})\\n{body}\\nend do'.format(**expr.kwargs(\n        apply=lambda arg: self._print(arg)))",
    "sympy.sympy.printing.fortran._print_Program": "def _print_Program(self, prog):\n    return (\n        \"program {name}\\n\"\n        \"{body}\\n\"\n        \"end program\\n\"\n    ).format(**prog.kwargs(apply=lambda arg: self._print(arg)))",
    "sympy.sympy.printing.fortran._print_Module": "def _print_Module(self, mod):\n    return (\n        \"module {name}\\n\"\n        \"{declarations}\\n\"\n        \"\\ncontains\\n\\n\"\n        \"{definitions}\\n\"\n        \"end module\\n\"\n    ).format(**mod.kwargs(apply=lambda arg: self._print(arg)))",
    "sympy.sympy.printing.fortran._print_Print": "def _print_Print(self, ps):\n    if ps.format_string == none: # Must be '!= None', cannot be 'is not None'\n        template = \"print {fmt}, {iolist}\"\n        fmt = '*'\n    else:\n        template = 'write(%(out)s, fmt=\"{fmt}\", advance=\"no\"), {iolist}' % {\n            'out': {stderr: '0', stdout: '6'}.get(ps.file, '*')\n        }\n        fmt = self._print(ps.format_string)\n    return template.format(fmt=fmt, iolist=', '.join(\n        (self._print(arg) for arg in ps.print_args)))",
    "sympy.sympy.printing.fortran._print_Return": "def _print_Return(self, rs):\n    arg, = rs.args\n    return \"{result_name} = {arg}\".format(\n        result_name=self._context.get('result_name', 'sympy_result'),\n        arg=self._print(arg)\n    )",
    "sympy.sympy.printing.fortran._print_FunctionPrototype": "def _print_FunctionPrototype(self, fp):\n    entity = \"{} function \".format(self._print(fp.return_type))\n    return (\n        \"interface\\n\"\n        \"{function_head}\\n\"\n        \"end function\\n\"\n        \"end interface\"\n    ).format(function_head=self._head(entity, fp))",
    "sympy.sympy.printing.fortran._print_FunctionDefinition": "def _print_FunctionDefinition(self, fd):\n    if elemental in fd.attrs:\n        prefix = 'elemental '\n    elif pure in fd.attrs:\n        prefix = 'pure '\n    else:\n        prefix = ''\n\n    entity = \"{} function \".format(self._print(fd.return_type))\n    with printer_context(self, result_name=fd.name):\n        return (\n            \"{prefix}{function_head}\\n\"\n            \"{body}\\n\"\n            \"end function\\n\"\n        ).format(\n            prefix=prefix,\n            function_head=self._head(entity, fd),\n            body=self._print(fd.body)\n        )",
    "sympy.sympy.printing.fortran._print_Subroutine": "def _print_Subroutine(self, sub):\n    return (\n        '{subroutine_head}\\n'\n        '{body}\\n'\n        'end subroutine\\n'\n    ).format(\n        subroutine_head=self._head('subroutine ', sub),\n        body=self._print(sub.body)\n    )",
    "sympy.sympy.printing.fortran._print_SubroutineCall": "def _print_SubroutineCall(self, scall):\n    return 'call {name}({args})'.format(\n        name=self._print(scall.name),\n        args=', '.join((self._print(arg) for arg in scall.subroutine_args))\n    )",
    "sympy.sympy.printing.fortran._print_use": "def _print_use(self, use):\n    result = 'use %s' % self._print(use.namespace)\n    if use.rename != None: # Must be '!= None', cannot be 'is not None'\n        result += ', ' + ', '.join([self._print(rnm) for rnm in use.rename])\n    if use.only != None: # Must be '!= None', cannot be 'is not None'\n        result += ', only: ' + ', '.join([self._print(nly) for nly in use.only])\n    return result",
    "sympy.sympy.printing.fortran._print_ArrayConstructor": "def _print_ArrayConstructor(self, ac):\n    fmtstr = \"[%s]\" if self._settings[\"standard\"] >= 2003 else '(/%s/)'\n    return fmtstr % ', '.join((self._print(arg) for arg in ac.elements))",
    "sympy.sympy.printing.fortran._print_KeywordFunctionCall": "def _print_KeywordFunctionCall(self, expr):\n    args = [self._print(arg) for arg in expr.function_args]\n\n    for key, value in expr.keyword_args.items():\n        args.append(f\"{key}={self._print(value)}\")\n\n    return '{name}({args})'.format(\n        name=self._print(expr.name),\n        args=', '.join(args)\n    )",
    "sympy.sympy.printing.fortran._print_ArrayElement": "def _print_ArrayElement(self, elem):\n    return '{symbol}({idxs})'.format(\n        symbol=self._print(elem.name),\n        idxs=', '.join((self._print(arg) for arg in elem.indices))\n    )",
    "sympy.sympy.printing.glsl._print_MatrixBase": "def _print_MatrixBase(self, mat):\n    mat_separator = self._settings['mat_separator']\n    mat_transpose = self._settings['mat_transpose']\n    column_vector = (mat.rows == 1) if mat_transpose else (mat.cols == 1)\n    A = mat.transpose() if mat_transpose != column_vector else mat\n\n    glsl_types = self._settings['glsl_types']\n    array_type = self._settings['array_type']\n    array_size = A.cols*A.rows\n    array_constructor = \"{}[{}]\".format(array_type, array_size)\n\n    if A.cols == 1:\n        return self._print(A[0])\n    if A.rows <= 4 and A.cols <= 4 and glsl_types:\n        if A.rows == 1:\n            return \"vec{}{}\".format(\n                A.cols, A.table(self,rowstart='(',rowend=')')\n            )\n        elif A.rows == A.cols:\n            return \"mat{}({})\".format(\n                A.rows, A.table(self,rowsep=', ',\n                rowstart='',rowend='')\n            )\n        else:\n            return \"mat{}x{}({})\".format(\n                A.cols, A.rows,\n                A.table(self,rowsep=', ',\n                rowstart='',rowend='')\n            )\n    elif S.One in A.shape:\n        return \"{}({})\".format(\n            array_constructor,\n            A.table(self,rowsep=mat_separator,rowstart='',rowend='')\n        )\n    elif not self._settings['mat_nested']:\n        return \"{}(\\n{}\\n) /* a {}x{} matrix */\".format(\n            array_constructor,\n            A.table(self,rowsep=mat_separator,rowstart='',rowend=''),\n            A.rows, A.cols\n        )\n    elif self._settings['mat_nested']:\n        return \"{}[{}][{}](\\n{}\\n)\".format(\n            array_type, A.rows, A.cols,\n            A.table(self,rowsep=mat_separator,rowstart='float[](',rowend=')')\n        )",
    "sympy.sympy.printing.glsl._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    # print('begin _print_MatrixElement')\n    nest = self._settings['mat_nested']\n    glsl_types = self._settings['glsl_types']\n    mat_transpose = self._settings['mat_transpose']\n    if mat_transpose:\n        cols,rows = expr.parent.shape\n        i,j = expr.j,expr.i\n    else:\n        rows,cols = expr.parent.shape\n        i,j = expr.i,expr.j\n    pnt = self._print(expr.parent)\n    if glsl_types and ((rows <= 4 and cols <=4) or nest):\n        return \"{}[{}][{}]\".format(pnt, i, j)\n    else:\n        return \"{}[{}]\".format(pnt, i + j*rows)",
    "sympy.sympy.printing.glsl._print_list": "def _print_list(self, expr):\n    l = ', '.join(self._print(item) for item in expr)\n    glsl_types = self._settings['glsl_types']\n    array_type = self._settings['array_type']\n    array_size = len(expr)\n    array_constructor = '{}[{}]'.format(array_type, array_size)\n\n    if array_size <= 4 and glsl_types:\n        return 'vec{}({})'.format(array_size, l)\n    else:\n        return '{}({})'.format(array_constructor, l)",
    "sympy.sympy.printing.glsl._print_Piecewise": "def _print_Piecewise(self, expr):\n    from sympy.codegen.ast import Assignment\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n    if expr.has(Assignment):\n        for i, (e, c) in enumerate(expr.args):\n            if i == 0:\n                lines.append(\"if (%s) {\" % self._print(c))\n            elif i == len(expr.args) - 1 and c == True:\n                lines.append(\"else {\")\n            else:\n                lines.append(\"else if (%s) {\" % self._print(c))\n            code0 = self._print(e)\n            lines.append(code0)\n            lines.append(\"}\")\n        return \"\\n\".join(lines)\n    else:\n        # The piecewise was used in an expression, need to do inline\n        # operators. This has the downside that inline operators will\n        # not work for statements that span multiple lines (Matrix or\n        # Indexed expressions).\n        ecpairs = [\"((%s) ? (\\n%s\\n)\\n\" % (self._print(c),\n                                           self._print(e))\n                for e, c in expr.args[:-1]]\n        last_line = \": (\\n%s\\n)\" % self._print(expr.args[-1].expr)\n        return \": \".join(ecpairs) + last_line + \" \".join([\")\"*len(ecpairs)])",
    "sympy.sympy.printing.glsl._print_Indexed": "def _print_Indexed(self, expr):\n    # calculate index for 1d array\n    dims = expr.shape\n    elem = S.Zero\n    offset = S.One\n    for i in reversed(range(expr.rank)):\n        elem += expr.indices[i]*offset\n        offset *= dims[i]\n    return \"{}[{}]\".format(\n        self._print(expr.base.label),\n        self._print(elem)\n    )",
    "sympy.sympy.printing.glsl._print_Pow": "def _print_Pow(self, expr):\n    PREC = precedence(expr)\n    if equal_valued(expr.exp, -1):\n        return '1.0/%s' % (self.parenthesize(expr.base, PREC))\n    elif equal_valued(expr.exp, 0.5):\n        return 'sqrt(%s)' % self._print(expr.base)\n    else:\n        try:\n            e = self._print(float(expr.exp))\n        except TypeError:\n            e = self._print(expr.exp)\n        return self._print_Function_with_args('pow', (\n            self._print(expr.base),\n            e\n        ))",
    "sympy.sympy.printing.glsl._print_int": "def _print_int(self, expr):\n    return str(float(expr))",
    "sympy.sympy.printing.glsl._print_Rational": "def _print_Rational(self, expr):\n    return \"{}.0/{}.0\".format(expr.p, expr.q)",
    "sympy.sympy.printing.glsl._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.glsl._print_Add": "def _print_Add(self, expr, order=None):\n    if self._settings['use_operators']:\n        return CodePrinter._print_Add(self, expr, order=order)\n\n    terms = expr.as_ordered_terms()\n\n    def partition(p,l):\n        return reduce(lambda x, y: (x[0]+[y], x[1]) if p(y) else (x[0], x[1]+[y]), l,  ([], []))\n    def add(a,b):\n        return self._print_Function_with_args('add', (a, b))\n        # return self.known_functions['add']+'(%s, %s)' % (a,b)\n    neg, pos = partition(lambda arg: arg.could_extract_minus_sign(), terms)\n    if pos:\n        s = pos = reduce(lambda a,b: add(a,b), (self._print(t) for t in pos))\n    else:\n        s = pos = self._print(self._settings['zero'])\n\n    if neg:\n        # sum the absolute values of the negative terms\n        neg = reduce(lambda a,b: add(a,b), (self._print(-n) for n in neg))\n        # then subtract them from the positive terms\n        s = self._print_Function_with_args('sub', (pos,neg))\n        # s = self.known_functions['sub']+'(%s, %s)' % (pos,neg)\n    return s",
    "sympy.sympy.printing.glsl._print_Mul": "def _print_Mul(self, expr, **kwargs):\n    if self._settings['use_operators']:\n        return CodePrinter._print_Mul(self, expr, **kwargs)\n    terms = expr.as_ordered_factors()\n    def mul(a,b):\n        # return self.known_functions['mul']+'(%s, %s)' % (a,b)\n        return self._print_Function_with_args('mul', (a,b))\n\n    s = reduce(lambda a,b: mul(a,b), (self._print(t) for t in terms))\n    return s",
    "sympy.sympy.printing.jscode._print_Rational": "def _print_Rational(self, expr):\n    p, q = int(expr.p), int(expr.q)\n    return '%d/%d' % (p, q)",
    "sympy.sympy.printing.jscode._print_Mod": "def _print_Mod(self, expr):\n    num, den = expr.args\n    PREC = precedence(expr)\n    snum, sden = [self.parenthesize(arg, PREC) for arg in expr.args]\n    # % is remainder (same sign as numerator), not modulo (same sign as\n    # denominator), in js. Hence, % only works as modulo if both numbers\n    # have the same sign\n    if (num.is_nonnegative and den.is_nonnegative or\n        num.is_nonpositive and den.is_nonpositive):\n        return f\"{snum} % {sden}\"\n    return f\"(({snum} % {sden}) + {sden}) % {sden}\"",
    "sympy.sympy.printing.jscode._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.jscode._print_Indexed": "def _print_Indexed(self, expr):\n    # calculate index for 1d array\n    dims = expr.shape\n    elem = S.Zero\n    offset = S.One\n    for i in reversed(range(expr.rank)):\n        elem += expr.indices[i]*offset\n        offset *= dims[i]\n    return \"%s[%s]\" % (self._print(expr.base.label), self._print(elem))",
    "sympy.sympy.printing.jscode._print_Exp1": "def _print_Exp1(self, expr):\n    return \"Math.E\"",
    "sympy.sympy.printing.jscode._print_Pi": "def _print_Pi(self, expr):\n    return 'Math.PI'",
    "sympy.sympy.printing.jscode._print_Infinity": "def _print_Infinity(self, expr):\n    return 'Number.POSITIVE_INFINITY'",
    "sympy.sympy.printing.jscode._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return 'Number.NEGATIVE_INFINITY'",
    "sympy.sympy.printing.jscode._print_Piecewise": "def _print_Piecewise(self, expr):\n    from sympy.codegen.ast import Assignment\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n    if expr.has(Assignment):\n        for i, (e, c) in enumerate(expr.args):\n            if i == 0:\n                lines.append(\"if (%s) {\" % self._print(c))\n            elif i == len(expr.args) - 1 and c == True:\n                lines.append(\"else {\")\n            else:\n                lines.append(\"else if (%s) {\" % self._print(c))\n            code0 = self._print(e)\n            lines.append(code0)\n            lines.append(\"}\")\n        return \"\\n\".join(lines)\n    else:\n        # The piecewise was used in an expression, need to do inline\n        # operators. This has the downside that inline operators will\n        # not work for statements that span multiple lines (Matrix or\n        # Indexed expressions).\n        ecpairs = [\"((%s) ? (\\n%s\\n)\\n\" % (self._print(c), self._print(e))\n                for e, c in expr.args[:-1]]\n        last_line = \": (\\n%s\\n)\" % self._print(expr.args[-1].expr)\n        return \": \".join(ecpairs) + last_line + \" \".join([\")\"*len(ecpairs)])",
    "sympy.sympy.printing.jscode._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return \"{}[{}]\".format(self.parenthesize(expr.parent,\n        PRECEDENCE[\"Atom\"], strict=True),\n        expr.j + expr.i*expr.parent.shape[1])",
    "sympy.sympy.printing.jscode._print_Pow": "def _print_Pow(self, expr):\n    PREC = precedence(expr)\n    if equal_valued(expr.exp, -1):\n        return '1/%s' % (self.parenthesize(expr.base, PREC))\n    elif equal_valued(expr.exp, 0.5):\n        return 'Math.sqrt(%s)' % self._print(expr.base)\n    elif expr.exp == S.One/3:\n        return 'Math.cbrt(%s)' % self._print(expr.base)\n    else:\n        return 'Math.pow(%s, %s)' % (self._print(expr.base),\n                             self._print(expr.exp))",
    "sympy.sympy.printing.julia._print_Mul": "def _print_Mul(self, expr):\n    # print complex numbers nicely in Julia\n    if (expr.is_number and expr.is_imaginary and\n            expr.as_coeff_Mul()[0].is_integer):\n        return \"%sim\" % self._print(-S.ImaginaryUnit*expr)\n\n    # cribbed from str.py\n    prec = precedence(expr)\n\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = \"-\"\n    else:\n        sign = \"\"\n\n    a = []  # items in the numerator\n    b = []  # items that are in the denominator (if any)\n\n    pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        # use make_args in case expr was something like -x -> x\n        args = Mul.make_args(expr)\n\n    # Gather args for numerator/denominator\n    for item in args:\n        if (item.is_commutative and item.is_Pow and item.exp.is_Rational\n                and item.exp.is_negative):\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n                    pow_paren.append(item)\n                b.append(Pow(item.base, -item.exp))\n        elif item.is_Rational and item is not S.Infinity and item.p == 1:\n            # Save the Rational type in julia Unless the numerator is 1.\n            # For example:\n            # julia_code(Rational(3, 7)*x) --> (3 // 7) * x\n            # julia_code(x/3) --> x / 3 but not x * (1 // 3)\n            b.append(Rational(item.q))\n        else:\n            a.append(item)\n\n    a = a or [S.One]\n\n    a_str = [self.parenthesize(x, prec) for x in a]\n    b_str = [self.parenthesize(x, prec) for x in b]\n\n    # To parenthesize Pow with exp = -1 and having more than one Symbol\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n\n    # from here it differs from str.py to deal with \"*\" and \".*\"\n    def multjoin(a, a_str):\n        # here we probably are assuming the constants will come first\n        r = a_str[0]\n        for i in range(1, len(a)):\n            mulsym = '*' if a[i-1].is_number else '.*'\n            r = \"%s %s %s\" % (r, mulsym, a_str[i])\n        return r\n\n    if not b:\n        return sign + multjoin(a, a_str)\n    elif len(b) == 1:\n        divsym = '/' if b[0].is_number else './'\n        return \"%s %s %s\" % (sign+multjoin(a, a_str), divsym, b_str[0])\n    else:\n        divsym = '/' if all(bi.is_number for bi in b) else './'\n        return \"%s %s (%s)\" % (sign + multjoin(a, a_str), divsym, multjoin(b, b_str))",
    "sympy.sympy.printing.julia._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.julia._print_Pow": "def _print_Pow(self, expr):\n    powsymbol = '^' if all(x.is_number for x in expr.args) else '.^'\n\n    PREC = precedence(expr)\n\n    if equal_valued(expr.exp, 0.5):\n        return \"sqrt(%s)\" % self._print(expr.base)\n\n    if expr.is_commutative:\n        if equal_valued(expr.exp, -0.5):\n            sym = '/' if expr.base.is_number else './'\n            return \"1 %s sqrt(%s)\" % (sym, self._print(expr.base))\n        if equal_valued(expr.exp, -1):\n            sym = '/' if expr.base.is_number else './'\n            return  \"1 %s %s\" % (sym, self.parenthesize(expr.base, PREC))\n\n    return '%s %s %s' % (self.parenthesize(expr.base, PREC), powsymbol,\n                       self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.julia._print_MatPow": "def _print_MatPow(self, expr):\n    PREC = precedence(expr)\n    return '%s ^ %s' % (self.parenthesize(expr.base, PREC),\n                      self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.julia._print_Pi": "def _print_Pi(self, expr):\n    if self._settings[\"inline\"]:\n        return \"pi\"\n    else:\n        return super()._print_NumberSymbol(expr)",
    "sympy.sympy.printing.julia._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return \"im\"",
    "sympy.sympy.printing.julia._print_Exp1": "def _print_Exp1(self, expr):\n    if self._settings[\"inline\"]:\n        return \"e\"\n    else:\n        return super()._print_NumberSymbol(expr)",
    "sympy.sympy.printing.julia._print_EulerGamma": "def _print_EulerGamma(self, expr):\n    if self._settings[\"inline\"]:\n        return \"eulergamma\"\n    else:\n        return super()._print_NumberSymbol(expr)",
    "sympy.sympy.printing.julia._print_Catalan": "def _print_Catalan(self, expr):\n    if self._settings[\"inline\"]:\n        return \"catalan\"\n    else:\n        return super()._print_NumberSymbol(expr)",
    "sympy.sympy.printing.julia._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    if self._settings[\"inline\"]:\n        return \"golden\"\n    else:\n        return super()._print_NumberSymbol(expr)",
    "sympy.sympy.printing.julia._print_Assignment": "def _print_Assignment(self, expr):\n    from sympy.codegen.ast import Assignment\n    from sympy.functions.elementary.piecewise import Piecewise\n    from sympy.tensor.indexed import IndexedBase\n    # Copied from codeprinter, but remove special MatrixSymbol treatment\n    lhs = expr.lhs\n    rhs = expr.rhs\n    # We special case assignments that take multiple lines\n    if not self._settings[\"inline\"] and isinstance(expr.rhs, Piecewise):\n        # Here we modify Piecewise so each expression is now\n        # an Assignment, and then continue on the print.\n        expressions = []\n        conditions = []\n        for (e, c) in rhs.args:\n            expressions.append(Assignment(lhs, e))\n            conditions.append(c)\n        temp = Piecewise(*zip(expressions, conditions))\n        return self._print(temp)\n    if self._settings[\"contract\"] and (lhs.has(IndexedBase) or\n            rhs.has(IndexedBase)):\n        # Here we check if there is looping to be done, and if so\n        # print the required loops.\n        return self._doprint_loops(rhs, lhs)\n    else:\n        lhs_code = self._print(lhs)\n        rhs_code = self._print(rhs)\n        return self._get_statement(\"%s = %s\" % (lhs_code, rhs_code))",
    "sympy.sympy.printing.julia._print_Infinity": "def _print_Infinity(self, expr):\n    return 'Inf'",
    "sympy.sympy.printing.julia._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-Inf'",
    "sympy.sympy.printing.julia._print_NaN": "def _print_NaN(self, expr):\n    return 'NaN'",
    "sympy.sympy.printing.julia._print_tuple": "def _print_tuple(self, expr):\n    if len(expr) == 1:\n        return \"(%s,)\" % self._print(expr[0])\n    else:\n        return \"(%s)\" % self.stringify(expr, \", \")",
    "sympy.sympy.printing.julia._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return \"true\"",
    "sympy.sympy.printing.julia._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return \"false\"",
    "sympy.sympy.printing.julia._print_MatrixBase": "def _print_MatrixBase(self, A):\n    # Handle zero dimensions:\n    if S.Zero in A.shape:\n        return 'zeros(%s, %s)' % (A.rows, A.cols)\n    elif (A.rows, A.cols) == (1, 1):\n        return \"[%s]\" % A[0, 0]\n    elif A.rows == 1:\n        return \"[%s]\" % A.table(self, rowstart='', rowend='', colsep=' ')\n    elif A.cols == 1:\n        # note .table would unnecessarily equispace the rows\n        return \"[%s]\" % \", \".join([self._print(a) for a in A])\n    return \"[%s]\" % A.table(self, rowstart='', rowend='',\n                            rowsep=';\\n', colsep=' ')",
    "sympy.sympy.printing.julia._print_SparseRepMatrix": "def _print_SparseRepMatrix(self, A):\n    from sympy.matrices import Matrix\n    L = A.col_list()\n    # make row vectors of the indices and entries\n    I = Matrix([k[0] + 1 for k in L])\n    J = Matrix([k[1] + 1 for k in L])\n    AIJ = Matrix([k[2] for k in L])\n    return \"sparse(%s, %s, %s, %s, %s)\" % (self._print(I), self._print(J),\n                                        self._print(AIJ), A.rows, A.cols)",
    "sympy.sympy.printing.julia._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n        + '[%s,%s]' % (expr.i + 1, expr.j + 1)",
    "sympy.sympy.printing.julia._print_MatrixSlice": "def _print_MatrixSlice(self, expr):\n    def strslice(x, lim):\n        l = x[0] + 1\n        h = x[1]\n        step = x[2]\n        lstr = self._print(l)\n        hstr = 'end' if h == lim else self._print(h)\n        if step == 1:\n            if l == 1 and h == lim:\n                return ':'\n            if l == h:\n                return lstr\n            else:\n                return lstr + ':' + hstr\n        else:\n            return ':'.join((lstr, self._print(step), hstr))\n    return (self._print(expr.parent) + '[' +\n            strslice(expr.rowslice, expr.parent.shape[0]) + ',' +\n            strslice(expr.colslice, expr.parent.shape[1]) + ']')",
    "sympy.sympy.printing.julia._print_Indexed": "def _print_Indexed(self, expr):\n    inds = [ self._print(i) for i in expr.indices ]\n    return \"%s[%s]\" % (self._print(expr.base.label), \",\".join(inds))",
    "sympy.sympy.printing.julia._print_Identity": "def _print_Identity(self, expr):\n    return \"eye(%s)\" % self._print(expr.shape[0])",
    "sympy.sympy.printing.julia._print_HadamardProduct": "def _print_HadamardProduct(self, expr):\n    return ' .* '.join([self.parenthesize(arg, precedence(expr))\n                      for arg in expr.args])",
    "sympy.sympy.printing.julia._print_Rational": "def _print_Rational(self, expr):\n    if expr.q == 1:\n        return str(expr.p)\n    return \"%s // %s\" % (expr.p, expr.q)",
    "sympy.sympy.printing.julia._print_jn": "def _print_jn(self, expr):\n    from sympy.functions import sqrt, besselj\n    x = expr.argument\n    expr2 = sqrt(S.Pi/(2*x))*besselj(expr.order + S.Half, x)\n    return self._print(expr2)",
    "sympy.sympy.printing.julia._print_yn": "def _print_yn(self, expr):\n    from sympy.functions import sqrt, bessely\n    x = expr.argument\n    expr2 = sqrt(S.Pi/(2*x))*bessely(expr.order + S.Half, x)\n    return self._print(expr2)",
    "sympy.sympy.printing.julia._print_sinc": "def _print_sinc(self, expr):\n    # Julia has the normalized sinc function\n    return \"sinc({})\".format(self._print(expr.args[0] / S.Pi))",
    "sympy.sympy.printing.julia._print_Piecewise": "def _print_Piecewise(self, expr):\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n    if self._settings[\"inline\"]:\n        # Express each (cond, expr) pair in a nested Horner form:\n        #   (condition) .* (expr) + (not cond) .* (<others>)\n        # Expressions that result in multiple statements won't work here.\n        ecpairs = [\"({}) ? ({}) :\".format\n                   (self._print(c), self._print(e))\n                   for e, c in expr.args[:-1]]\n        elast = \" (%s)\" % self._print(expr.args[-1].expr)\n        pw = \"\\n\".join(ecpairs) + elast\n        # Note: current need these outer brackets for 2*pw.  Would be\n        # nicer to teach parenthesize() to do this for us when needed!\n        return \"(\" + pw + \")\"\n    else:\n        for i, (e, c) in enumerate(expr.args):\n            if i == 0:\n                lines.append(\"if (%s)\" % self._print(c))\n            elif i == len(expr.args) - 1 and c == True:\n                lines.append(\"else\")\n            else:\n                lines.append(\"elseif (%s)\" % self._print(c))\n            code0 = self._print(e)\n            lines.append(code0)\n            if i == len(expr.args) - 1:\n                lines.append(\"end\")\n        return \"\\n\".join(lines)",
    "sympy.sympy.printing.julia._print_MatMul": "def _print_MatMul(self, expr):\n    c, m = expr.as_coeff_mmul()\n\n    sign = \"\"\n    if c.is_number:\n        re, im = c.as_real_imag()\n        if im.is_zero and re.is_negative:\n            expr = _keep_coeff(-c, m)\n            sign = \"-\"\n        elif re.is_zero and im.is_negative:\n            expr = _keep_coeff(-c, m)\n            sign = \"-\"\n\n    return sign + ' * '.join(\n        (self.parenthesize(arg, precedence(expr)) for arg in expr.args)\n    )",
    "sympy.sympy.printing.lambdarepr._print_Piecewise": "def _print_Piecewise(self, expr):\n    \"Piecewise function printer\"\n    exprs = [self._print(arg.expr) for arg in expr.args]\n    conds = [self._print(arg.cond) for arg in expr.args]\n    # If [default_value, True] is a (expr, cond) sequence in a Piecewise object\n    #     it will behave the same as passing the 'default' kwarg to select()\n    #     *as long as* it is the last element in expr.args.\n    # If this is not the case, it may be triggered prematurely.\n    ans = []\n    parenthesis_count = 0\n    is_last_cond_True = False\n    for cond, expr in zip(conds, exprs):\n        if cond == 'True':\n            ans.append(expr)\n            is_last_cond_True = True\n            break\n        else:\n            ans.append('where(%s, %s, ' % (cond, expr))\n            parenthesis_count += 1\n    if not is_last_cond_True:\n        # See https://github.com/pydata/numexpr/issues/298\n        #\n        # simplest way to put a nan but raises\n        # 'RuntimeWarning: invalid value encountered in log'\n        #\n        # There are other ways to do this such as\n        #\n        #   >>> import numexpr as ne\n        #   >>> nan = float('nan')\n        #   >>> ne.evaluate('where(x < 0, -1, nan)', {'x': [-1, 2, 3], 'nan':nan})\n        #   array([-1., nan, nan])\n        #\n        # That needs to be handled in the lambdified function though rather\n        # than here in the printer.\n        ans.append('log(-1)')\n    return ''.join(ans) + ')' * parenthesis_count",
    "sympy.sympy.printing.lambdarepr._print_ITE": "def _print_ITE(self, expr):\n    from sympy.functions.elementary.piecewise import Piecewise\n    return self._print(expr.rewrite(Piecewise))",
    "sympy.sympy.printing.lambdarepr._print_NumExprEvaluate": "def _print_NumExprEvaluate(self, expr):\n    evaluate = self._module_format(self.module +\".evaluate\")\n    return \"%s('%s', truediv=True)\" % (evaluate, self._print(expr.expr))",
    "sympy.sympy.printing.lambdarepr._print_Return": "def _print_Return(self, expr):\n    from sympy.codegen.pynodes import NumExprEvaluate\n    r, = expr.args\n    if not isinstance(r, NumExprEvaluate):\n        expr = expr.func(NumExprEvaluate(r))\n    return super()._print_Return(expr)",
    "sympy.sympy.printing.lambdarepr._print_Assignment": "def _print_Assignment(self, expr):\n    from sympy.codegen.pynodes import NumExprEvaluate\n    lhs, rhs, *args = expr.args\n    if not isinstance(rhs, NumExprEvaluate):\n        expr = expr.func(lhs, NumExprEvaluate(rhs), *args)\n    return super()._print_Assignment(expr)",
    "sympy.sympy.printing.lambdarepr._print_Integer": "def _print_Integer(self, expr):\n    return \"mpi('%s')\" % super(PythonCodePrinter, self)._print_Integer(expr)",
    "sympy.sympy.printing.lambdarepr._print_Rational": "def _print_Rational(self, expr):\n    return \"mpi('%s')\" % super(PythonCodePrinter, self)._print_Rational(expr)",
    "sympy.sympy.printing.lambdarepr._print_Half": "def _print_Half(self, expr):\n    return \"mpi('%s')\" % super(PythonCodePrinter, self)._print_Rational(expr)",
    "sympy.sympy.printing.lambdarepr._print_Pow": "def _print_Pow(self, expr, **kwargs):\n    # XXX Temporary workaround. Should Python math printer be\n    # isolated from PythonCodePrinter?\n    return super(PythonCodePrinter, self)._print_Pow(expr, **kwargs)",
    "sympy.sympy.printing.lambdarepr._print_And": "def _print_And(self, expr):\n    result = ['(']\n    for arg in sorted(expr.args, key=default_sort_key):\n        result.extend(['(', self._print(arg), ')'])\n        result.append(' and ')\n    result = result[:-1]\n    result.append(')')\n    return ''.join(result)",
    "sympy.sympy.printing.lambdarepr._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return \"True\"",
    "sympy.sympy.printing.lambdarepr._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return \"False\"",
    "sympy.sympy.printing.latex._print_UndefinedFunction": "def _print_UndefinedFunction(self, expr):\n    return self._hprint_Function(str(expr))",
    "sympy.sympy.printing.latex._print_ElementwiseApplyFunction": "def _print_ElementwiseApplyFunction(self, expr):\n    return r\"{%s}_{\\circ}\\left({%s}\\right)\" % (\n        self._print(expr.function),\n        self._print(expr.expr),\n    )",
    "sympy.sympy.printing.latex._print_FunctionClass": "def _print_FunctionClass(self, expr):\n    for cls in self._special_function_classes:\n        if issubclass(expr, cls) and expr.__name__ == cls.__name__:\n            return self._special_function_classes[cls]\n    return self._hprint_Function(str(expr))",
    "sympy.sympy.printing.latex._print_Lambda": "def _print_Lambda(self, expr):\n    symbols, expr = expr.args\n\n    if len(symbols) == 1:\n        symbols = self._print(symbols[0])\n    else:\n        symbols = self._print(tuple(symbols))\n\n    tex = r\"\\left( %s \\mapsto %s \\right)\" % (symbols, self._print(expr))\n\n    return tex",
    "sympy.sympy.printing.latex._print_IdentityFunction": "def _print_IdentityFunction(self, expr):\n    return r\"\\left( x \\mapsto x \\right)\"",
    "sympy.sympy.printing.latex._hprint_variadic_function": "def _hprint_variadic_function(self, expr, exp=None) -> str:\n    args = sorted(expr.args, key=default_sort_key)\n    texargs = [r\"%s\" % self._print(symbol) for symbol in args]\n    tex = r\"\\%s\\left(%s\\right)\" % (str(expr.func).lower(),\n                                   \", \".join(texargs))\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_floor": "def _print_floor(self, expr, exp=None):\n    tex = r\"\\left\\lfloor{%s}\\right\\rfloor\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_ceiling": "def _print_ceiling(self, expr, exp=None):\n    tex = r\"\\left\\lceil{%s}\\right\\rceil\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_log": "def _print_log(self, expr, exp=None):\n    if len(expr.args) == 2:\n        argument = self._print(expr.args[0])\n        base = self._print(expr.args[1])\n        if len(base) == 1:\n            tex = r\"\\log_%s{\\left(%s \\right)}\" % (base, argument)\n        else:\n            tex = r\"\\log_{%s}{\\left(%s \\right)}\" % (base, argument)\n    elif not self._settings[\"ln_notation\"]:\n        tex = r\"\\log{\\left(%s \\right)}\" % self._print(expr.args[0])\n    else:\n        tex = r\"\\ln{\\left(%s \\right)}\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_Abs": "def _print_Abs(self, expr, exp=None):\n    tex = r\"\\left|{%s}\\right|\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_re": "def _print_re(self, expr, exp=None):\n    if self._settings['gothic_re_im']:\n        tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n    else:\n        tex = r\"\\operatorname{{re}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))\n\n    return self._do_exponent(tex, exp)",
    "sympy.sympy.printing.latex._print_im": "def _print_im(self, expr, exp=None):\n    if self._settings['gothic_re_im']:\n        tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n    else:\n        tex = r\"\\operatorname{{im}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))\n\n    return self._do_exponent(tex, exp)",
    "sympy.sympy.printing.latex._print_Not": "def _print_Not(self, e):\n    from sympy.logic.boolalg import (Equivalent, Implies)\n    if isinstance(e.args[0], Equivalent):\n        return self._print_Equivalent(e.args[0], r\"\\not\\Leftrightarrow\")\n    if isinstance(e.args[0], Implies):\n        return self._print_Implies(e.args[0], r\"\\not\\Rightarrow\")\n    if (e.args[0].is_Boolean):\n        return r\"\\neg \\left(%s\\right)\" % self._print(e.args[0])\n    else:\n        return r\"\\neg %s\" % self._print(e.args[0])",
    "sympy.sympy.printing.latex._print_And": "def _print_And(self, e):\n    args = sorted(e.args, key=default_sort_key)\n    return self._print_LogOp(args, r\"\\wedge\")",
    "sympy.sympy.printing.latex._print_Or": "def _print_Or(self, e):\n    args = sorted(e.args, key=default_sort_key)\n    return self._print_LogOp(args, r\"\\vee\")",
    "sympy.sympy.printing.latex._print_Xor": "def _print_Xor(self, e):\n    args = sorted(e.args, key=default_sort_key)\n    return self._print_LogOp(args, r\"\\veebar\")",
    "sympy.sympy.printing.latex._print_Implies": "def _print_Implies(self, e, altchar=None):\n    return self._print_LogOp(e.args, altchar or r\"\\Rightarrow\")",
    "sympy.sympy.printing.latex._print_Equivalent": "def _print_Equivalent(self, e, altchar=None):\n    args = sorted(e.args, key=default_sort_key)\n    return self._print_LogOp(args, altchar or r\"\\Leftrightarrow\")",
    "sympy.sympy.printing.latex._print_conjugate": "def _print_conjugate(self, expr, exp=None):\n    tex = r\"\\overline{%s}\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_polar_lift": "def _print_polar_lift(self, expr, exp=None):\n    func = r\"\\operatorname{polar\\_lift}\"\n    arg = r\"{\\left(%s \\right)}\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}%s\" % (func, exp, arg)\n    else:\n        return r\"%s%s\" % (func, arg)",
    "sympy.sympy.printing.latex._print_ExpBase": "def _print_ExpBase(self, expr, exp=None):\n    # TODO should exp_polar be printed differently?\n    #      what about exp_polar(0), exp_polar(1)?\n    tex = r\"e^{%s}\" % self._print(expr.args[0])\n    return self._do_exponent(tex, exp)",
    "sympy.sympy.printing.latex._print_elliptic_k": "def _print_elliptic_k(self, expr, exp=None):\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"K^{%s}%s\" % (exp, tex)\n    else:\n        return r\"K%s\" % tex",
    "sympy.sympy.printing.latex._print_elliptic_f": "def _print_elliptic_f(self, expr, exp=None):\n    tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n        (self._print(expr.args[0]), self._print(expr.args[1]))\n    if exp is not None:\n        return r\"F^{%s}%s\" % (exp, tex)\n    else:\n        return r\"F%s\" % tex",
    "sympy.sympy.printing.latex._print_elliptic_e": "def _print_elliptic_e(self, expr, exp=None):\n    if len(expr.args) == 2:\n        tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n            (self._print(expr.args[0]), self._print(expr.args[1]))\n    else:\n        tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"E^{%s}%s\" % (exp, tex)\n    else:\n        return r\"E%s\" % tex",
    "sympy.sympy.printing.latex._print_elliptic_pi": "def _print_elliptic_pi(self, expr, exp=None):\n    if len(expr.args) == 3:\n        tex = r\"\\left(%s; %s\\middle| %s\\right)\" % \\\n            (self._print(expr.args[0]), self._print(expr.args[1]),\n             self._print(expr.args[2]))\n    else:\n        tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n            (self._print(expr.args[0]), self._print(expr.args[1]))\n    if exp is not None:\n        return r\"\\Pi^{%s}%s\" % (exp, tex)\n    else:\n        return r\"\\Pi%s\" % tex",
    "sympy.sympy.printing.latex._print_beta": "def _print_beta(self, expr, exp=None):\n    x = expr.args[0]\n    # Deal with unevaluated single argument beta\n    y = expr.args[0] if len(expr.args) == 1 else expr.args[1]\n    tex = rf\"\\left({x}, {y}\\right)\"\n\n    if exp is not None:\n        return r\"\\operatorname{B}^{%s}%s\" % (exp, tex)\n    else:\n        return r\"\\operatorname{B}%s\" % tex",
    "sympy.sympy.printing.latex._print_uppergamma": "def _print_uppergamma(self, expr, exp=None):\n    tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n                                    self._print(expr.args[1]))\n\n    if exp is not None:\n        return r\"\\Gamma^{%s}%s\" % (exp, tex)\n    else:\n        return r\"\\Gamma%s\" % tex",
    "sympy.sympy.printing.latex._print_lowergamma": "def _print_lowergamma(self, expr, exp=None):\n    tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n                                    self._print(expr.args[1]))\n\n    if exp is not None:\n        return r\"\\gamma^{%s}%s\" % (exp, tex)\n    else:\n        return r\"\\gamma%s\" % tex",
    "sympy.sympy.printing.latex._hprint_one_arg_func": "def _hprint_one_arg_func(self, expr, exp=None) -> str:\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"%s^{%s}%s\" % (self._print(expr.func), exp, tex)\n    else:\n        return r\"%s%s\" % (self._print(expr.func), tex)",
    "sympy.sympy.printing.latex._print_Chi": "def _print_Chi(self, expr, exp=None):\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"\\operatorname{Chi}^{%s}%s\" % (exp, tex)\n    else:\n        return r\"\\operatorname{Chi}%s\" % tex",
    "sympy.sympy.printing.latex._print_expint": "def _print_expint(self, expr, exp=None):\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[1])\n    nu = self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"\\operatorname{E}_{%s}^{%s}%s\" % (nu, exp, tex)\n    else:\n        return r\"\\operatorname{E}_{%s}%s\" % (nu, tex)",
    "sympy.sympy.printing.latex._print_fresnels": "def _print_fresnels(self, expr, exp=None):\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"S^{%s}%s\" % (exp, tex)\n    else:\n        return r\"S%s\" % tex",
    "sympy.sympy.printing.latex._print_fresnelc": "def _print_fresnelc(self, expr, exp=None):\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n\n    if exp is not None:\n        return r\"C^{%s}%s\" % (exp, tex)\n    else:\n        return r\"C%s\" % tex",
    "sympy.sympy.printing.latex._print_subfactorial": "def _print_subfactorial(self, expr, exp=None):\n    tex = r\"!%s\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n\n    if exp is not None:\n        return r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_factorial": "def _print_factorial(self, expr, exp=None):\n    tex = r\"%s!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_factorial2": "def _print_factorial2(self, expr, exp=None):\n    tex = r\"%s!!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_binomial": "def _print_binomial(self, expr, exp=None):\n    tex = r\"{\\binom{%s}{%s}}\" % (self._print(expr.args[0]),\n                                 self._print(expr.args[1]))\n\n    if exp is not None:\n        return r\"%s^{%s}\" % (tex, exp)\n    else:\n        return tex",
    "sympy.sympy.printing.latex._print_RisingFactorial": "def _print_RisingFactorial(self, expr, exp=None):\n    n, k = expr.args\n    base = r\"%s\" % self.parenthesize(n, PRECEDENCE['Func'])\n\n    tex = r\"{%s}^{\\left(%s\\right)}\" % (base, self._print(k))\n\n    return self._do_exponent(tex, exp)",
    "sympy.sympy.printing.latex._print_FallingFactorial": "def _print_FallingFactorial(self, expr, exp=None):\n    n, k = expr.args\n    sub = r\"%s\" % self.parenthesize(k, PRECEDENCE['Func'])\n\n    tex = r\"{\\left(%s\\right)}_{%s}\" % (self._print(n), sub)\n\n    return self._do_exponent(tex, exp)",
    "sympy.sympy.printing.latex._print_besselj": "def _print_besselj(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'J')",
    "sympy.sympy.printing.latex._print_besseli": "def _print_besseli(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'I')",
    "sympy.sympy.printing.latex._print_besselk": "def _print_besselk(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'K')",
    "sympy.sympy.printing.latex._print_bessely": "def _print_bessely(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'Y')",
    "sympy.sympy.printing.latex._print_yn": "def _print_yn(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'y')",
    "sympy.sympy.printing.latex._print_jn": "def _print_jn(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'j')",
    "sympy.sympy.printing.latex._print_hankel1": "def _print_hankel1(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'H^{(1)}')",
    "sympy.sympy.printing.latex._print_hankel2": "def _print_hankel2(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'H^{(2)}')",
    "sympy.sympy.printing.latex._print_hn1": "def _print_hn1(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'h^{(1)}')",
    "sympy.sympy.printing.latex._print_hn2": "def _print_hn2(self, expr, exp=None):\n    return self._hprint_BesselBase(expr, exp, 'h^{(2)}')",
    "sympy.sympy.printing.latex._print_hyper": "def _print_hyper(self, expr, exp=None):\n    tex = r\"{{}_{%s}F_{%s}\\left(\\begin{matrix} %s \\\\ %s \\end{matrix}\" \\\n          r\"\\middle| {%s} \\right)}\" % \\\n        (self._print(len(expr.ap)), self._print(len(expr.bq)),\n          self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),\n          self._print(expr.argument))\n\n    if exp is not None:\n        tex = r\"{%s}^{%s}\" % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_meijerg": "def _print_meijerg(self, expr, exp=None):\n    tex = r\"{G_{%s, %s}^{%s, %s}\\left(\\begin{matrix} %s & %s \\\\\" \\\n          r\"%s & %s \\end{matrix} \\middle| {%s} \\right)}\" % \\\n        (self._print(len(expr.ap)), self._print(len(expr.bq)),\n          self._print(len(expr.bm)), self._print(len(expr.an)),\n          self._hprint_vec(expr.an), self._hprint_vec(expr.aother),\n          self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),\n          self._print(expr.argument))\n\n    if exp is not None:\n        tex = r\"{%s}^{%s}\" % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_dirichlet_eta": "def _print_dirichlet_eta(self, expr, exp=None):\n    tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"\\eta^{%s}%s\" % (exp, tex)\n    return r\"\\eta%s\" % tex",
    "sympy.sympy.printing.latex._print_zeta": "def _print_zeta(self, expr, exp=None):\n    if len(expr.args) == 2:\n        tex = r\"\\left(%s, %s\\right)\" % tuple(map(self._print, expr.args))\n    else:\n        tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"\\zeta^{%s}%s\" % (exp, tex)\n    return r\"\\zeta%s\" % tex",
    "sympy.sympy.printing.latex._print_stieltjes": "def _print_stieltjes(self, expr, exp=None):\n    if len(expr.args) == 2:\n        tex = r\"_{%s}\\left(%s\\right)\" % tuple(map(self._print, expr.args))\n    else:\n        tex = r\"_{%s}\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"\\gamma%s^{%s}\" % (tex, exp)\n    return r\"\\gamma%s\" % tex",
    "sympy.sympy.printing.latex._print_lerchphi": "def _print_lerchphi(self, expr, exp=None):\n    tex = r\"\\left(%s, %s, %s\\right)\" % tuple(map(self._print, expr.args))\n    if exp is None:\n        return r\"\\Phi%s\" % tex\n    return r\"\\Phi^{%s}%s\" % (exp, tex)",
    "sympy.sympy.printing.latex._print_polylog": "def _print_polylog(self, expr, exp=None):\n    s, z = map(self._print, expr.args)\n    tex = r\"\\left(%s\\right)\" % z\n    if exp is None:\n        return r\"\\operatorname{Li}_{%s}%s\" % (s, tex)\n    return r\"\\operatorname{Li}_{%s}^{%s}%s\" % (s, exp, tex)",
    "sympy.sympy.printing.latex._print_jacobi": "def _print_jacobi(self, expr, exp=None):\n    n, a, b, x = map(self._print, expr.args)\n    tex = r\"P_{%s}^{\\left(%s,%s\\right)}\\left(%s\\right)\" % (n, a, b, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_gegenbauer": "def _print_gegenbauer(self, expr, exp=None):\n    n, a, x = map(self._print, expr.args)\n    tex = r\"C_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_chebyshevt": "def _print_chebyshevt(self, expr, exp=None):\n    n, x = map(self._print, expr.args)\n    tex = r\"T_{%s}\\left(%s\\right)\" % (n, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_chebyshevu": "def _print_chebyshevu(self, expr, exp=None):\n    n, x = map(self._print, expr.args)\n    tex = r\"U_{%s}\\left(%s\\right)\" % (n, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_legendre": "def _print_legendre(self, expr, exp=None):\n    n, x = map(self._print, expr.args)\n    tex = r\"P_{%s}\\left(%s\\right)\" % (n, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_assoc_legendre": "def _print_assoc_legendre(self, expr, exp=None):\n    n, a, x = map(self._print, expr.args)\n    tex = r\"P_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_hermite": "def _print_hermite(self, expr, exp=None):\n    n, x = map(self._print, expr.args)\n    tex = r\"H_{%s}\\left(%s\\right)\" % (n, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_laguerre": "def _print_laguerre(self, expr, exp=None):\n    n, x = map(self._print, expr.args)\n    tex = r\"L_{%s}\\left(%s\\right)\" % (n, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_assoc_laguerre": "def _print_assoc_laguerre(self, expr, exp=None):\n    n, a, x = map(self._print, expr.args)\n    tex = r\"L_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_Ynm": "def _print_Ynm(self, expr, exp=None):\n    n, m, theta, phi = map(self._print, expr.args)\n    tex = r\"Y_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_Znm": "def _print_Znm(self, expr, exp=None):\n    n, m, theta, phi = map(self._print, expr.args)\n    tex = r\"Z_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n    if exp is not None:\n        tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (exp)\n    return tex",
    "sympy.sympy.printing.latex._print_mathieuc": "def _print_mathieuc(self, expr, exp=None):\n    return self.__print_mathieu_functions(\"C\", expr.args, exp=exp)",
    "sympy.sympy.printing.latex._print_mathieus": "def _print_mathieus(self, expr, exp=None):\n    return self.__print_mathieu_functions(\"S\", expr.args, exp=exp)",
    "sympy.sympy.printing.latex._print_mathieucprime": "def _print_mathieucprime(self, expr, exp=None):\n    return self.__print_mathieu_functions(\"C\", expr.args, prime=True, exp=exp)",
    "sympy.sympy.printing.latex._print_mathieusprime": "def _print_mathieusprime(self, expr, exp=None):\n    return self.__print_mathieu_functions(\"S\", expr.args, prime=True, exp=exp)",
    "sympy.sympy.printing.latex._print_Rational": "def _print_Rational(self, expr):\n    if expr.q != 1:\n        sign = \"\"\n        p = expr.p\n        if expr.p < 0:\n            sign = \"- \"\n            p = -p\n        if self._settings['fold_short_frac']:\n            return r\"%s%d / %d\" % (sign, p, expr.q)\n        return r\"%s\\frac{%d}{%d}\" % (sign, p, expr.q)\n    else:\n        return self._print(expr.p)",
    "sympy.sympy.printing.latex._print_Order": "def _print_Order(self, expr):\n    s = self._print(expr.expr)\n    if expr.point and any(p != S.Zero for p in expr.point) or \\\n       len(expr.variables) > 1:\n        s += '; '\n        if len(expr.variables) > 1:\n            s += self._print(expr.variables)\n        elif expr.variables:\n            s += self._print(expr.variables[0])\n        s += r'\\rightarrow '\n        if len(expr.point) > 1:\n            s += self._print(expr.point)\n        else:\n            s += self._print(expr.point[0])\n    return r\"O\\left(%s\\right)\" % s",
    "sympy.sympy.printing.latex._print_Symbol": "def _print_Symbol(self, expr: Symbol, style='plain'):\n    name: str = self._settings['symbol_names'].get(expr)\n    if name is not None:\n        return name\n\n    return self._deal_with_super_sub(expr.name, style=style)",
    "sympy.sympy.printing.latex._print_Relational": "def _print_Relational(self, expr):\n    if self._settings['itex']:\n        gt = r\"\\gt\"\n        lt = r\"\\lt\"\n    else:\n        gt = \">\"\n        lt = \"<\"\n\n    charmap = {\n        \"==\": \"=\",\n        \">\": gt,\n        \"<\": lt,\n        \">=\": r\"\\geq\",\n        \"<=\": r\"\\leq\",\n        \"!=\": r\"\\neq\",\n    }\n\n    return \"%s %s %s\" % (self._print(expr.lhs),\n                         charmap[expr.rel_op], self._print(expr.rhs))",
    "sympy.sympy.printing.latex._print_Piecewise": "def _print_Piecewise(self, expr):\n    ecpairs = [r\"%s & \\text{for}\\: %s\" % (self._print(e), self._print(c))\n               for e, c in expr.args[:-1]]\n    if expr.args[-1].cond == true:\n        ecpairs.append(r\"%s & \\text{otherwise}\" %\n                       self._print(expr.args[-1].expr))\n    else:\n        ecpairs.append(r\"%s & \\text{for}\\: %s\" %\n                       (self._print(expr.args[-1].expr),\n                        self._print(expr.args[-1].cond)))\n    tex = r\"\\begin{cases} %s \\end{cases}\"\n    return tex % r\" \\\\\".join(ecpairs)",
    "sympy.sympy.printing.latex._print_MatrixBase": "def _print_MatrixBase(self, expr):\n    out_str = self._print_matrix_contents(expr)\n    if self._settings['mat_delim']:\n        left_delim = self._settings['mat_delim']\n        right_delim = self._delim_dict[left_delim]\n        out_str = r'\\left' + left_delim + out_str + \\\n                  r'\\right' + right_delim\n    return out_str",
    "sympy.sympy.printing.latex._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    matrix_part = self.parenthesize(expr.parent, PRECEDENCE['Atom'], strict=True)\n    index_part = f\"{self._print(expr.i)},{self._print(expr.j)}\"\n    return f\"{{{matrix_part}}}_{{{index_part}}}\"",
    "sympy.sympy.printing.latex._print_MatrixSlice": "def _print_MatrixSlice(self, expr):\n    def latexslice(x, dim):\n        x = list(x)\n        if x[2] == 1:\n            del x[2]\n        if x[0] == 0:\n            x[0] = None\n        if x[1] == dim:\n            x[1] = None\n        return ':'.join(self._print(xi) if xi is not None else '' for xi in x)\n    return (self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) + r'\\left[' +\n            latexslice(expr.rowslice, expr.parent.rows) + ', ' +\n            latexslice(expr.colslice, expr.parent.cols) + r'\\right]')",
    "sympy.sympy.printing.latex._print_BlockMatrix": "def _print_BlockMatrix(self, expr):\n    return self._print(expr.blocks)",
    "sympy.sympy.printing.latex._print_Transpose": "def _print_Transpose(self, expr):\n    mat = expr.arg\n    from sympy.matrices import MatrixSymbol, BlockMatrix\n    if (not isinstance(mat, MatrixSymbol) and\n        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n        return r\"\\left(%s\\right)^{T}\" % self._print(mat)\n    else:\n        s = self.parenthesize(mat, precedence_traditional(expr), True)\n        if '^' in s:\n            return r\"\\left(%s\\right)^{T}\" % s\n        else:\n            return \"%s^{T}\" % s",
    "sympy.sympy.printing.latex._print_Trace": "def _print_Trace(self, expr):\n    mat = expr.arg\n    return r\"\\operatorname{tr}\\left(%s \\right)\" % self._print(mat)",
    "sympy.sympy.printing.latex._print_Adjoint": "def _print_Adjoint(self, expr):\n    style_to_latex = {\n        \"dagger\"   : r\"\\dagger\",\n        \"star\"     : r\"\\ast\",\n        \"hermitian\": r\"\\mathsf{H}\"\n    }\n    adjoint_style = style_to_latex.get(self._settings[\"adjoint_style\"], r\"\\dagger\")\n    mat = expr.arg\n    from sympy.matrices import MatrixSymbol, BlockMatrix\n    if (not isinstance(mat, MatrixSymbol) and\n        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n        return r\"\\left(%s\\right)^{%s}\" % (self._print(mat), adjoint_style)\n    else:\n        s = self.parenthesize(mat, precedence_traditional(expr), True)\n        if '^' in s:\n            return r\"\\left(%s\\right)^{%s}\" % (s, adjoint_style)\n        else:\n            return r\"%s^{%s}\" % (s, adjoint_style)",
    "sympy.sympy.printing.latex._print_MatMul": "def _print_MatMul(self, expr):\n    from sympy import MatMul\n\n    # Parenthesize nested MatMul but not other types of Mul objects:\n    parens = lambda x: self._print(x) if isinstance(x, Mul) and not isinstance(x, MatMul) else \\\n        self.parenthesize(x, precedence_traditional(expr), False)\n\n    args = list(expr.args)\n    if expr.could_extract_minus_sign():\n        if args[0] == -1:\n            args = args[1:]\n        else:\n            args[0] = -args[0]\n        return '- ' + ' '.join(map(parens, args))\n    else:\n        return ' '.join(map(parens, args))",
    "sympy.sympy.printing.latex._print_DotProduct": "def _print_DotProduct(self, expr):\n    level = precedence_traditional(expr)\n    left, right = expr.args\n    return rf\"{self.parenthesize(left, level)} \\cdot {self.parenthesize(right, level)}\"",
    "sympy.sympy.printing.latex._print_Determinant": "def _print_Determinant(self, expr):\n    mat = expr.arg\n    if mat.is_MatrixExpr:\n        from sympy.matrices.expressions.blockmatrix import BlockMatrix\n        if isinstance(mat, BlockMatrix):\n            return r\"\\left|{%s}\\right|\" % self._print_matrix_contents(mat.blocks)\n        return r\"\\left|{%s}\\right|\" % self._print(mat)\n    return r\"\\left|{%s}\\right|\" % self._print_matrix_contents(mat)",
    "sympy.sympy.printing.latex._print_Mod": "def _print_Mod(self, expr, exp=None):\n    if exp is not None:\n        return r'\\left(%s \\bmod %s\\right)^{%s}' % \\\n            (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],\n                               strict=True),\n             self.parenthesize(expr.args[1], PRECEDENCE['Mul'],\n                               strict=True),\n             exp)\n    return r'%s \\bmod %s' % (self.parenthesize(expr.args[0],\n                                               PRECEDENCE['Mul'],\n                                               strict=True),\n                             self.parenthesize(expr.args[1],\n                                               PRECEDENCE['Mul'],\n                                               strict=True))",
    "sympy.sympy.printing.latex._print_HadamardProduct": "def _print_HadamardProduct(self, expr):\n    args = expr.args\n    prec = PRECEDENCE['Pow']\n    parens = self.parenthesize\n\n    return r' \\circ '.join(\n        (parens(arg, prec, strict=True) for arg in args))",
    "sympy.sympy.printing.latex._print_HadamardPower": "def _print_HadamardPower(self, expr):\n    if precedence_traditional(expr.exp) < PRECEDENCE[\"Mul\"]:\n        template = r\"%s^{\\circ \\left({%s}\\right)}\"\n    else:\n        template = r\"%s^{\\circ {%s}}\"\n    return self._helper_print_standard_power(expr, template)",
    "sympy.sympy.printing.latex._print_KroneckerProduct": "def _print_KroneckerProduct(self, expr):\n    args = expr.args\n    prec = PRECEDENCE['Pow']\n    parens = self.parenthesize\n\n    return r' \\otimes '.join(\n        (parens(arg, prec, strict=True) for arg in args))",
    "sympy.sympy.printing.latex._print_MatPow": "def _print_MatPow(self, expr):\n    base, exp = expr.base, expr.exp\n    from sympy.matrices import MatrixSymbol\n    if not isinstance(base, MatrixSymbol) and base.is_MatrixExpr:\n        return \"\\\\left(%s\\\\right)^{%s}\" % (self._print(base),\n                                          self._print(exp))\n    else:\n        base_str = self._print(base)\n        if '^' in base_str:\n            return r\"\\left(%s\\right)^{%s}\" % (base_str, self._print(exp))\n        else:\n            return \"%s^{%s}\" % (base_str, self._print(exp))",
    "sympy.sympy.printing.latex._print_MatrixSymbol": "def _print_MatrixSymbol(self, expr):\n    return self._print_Symbol(expr, style=self._settings[\n        'mat_symbol_style'])",
    "sympy.sympy.printing.latex._print_MatrixUnit": "def _print_MatrixUnit(self, E):\n    return \"E_{%s,%s}\" % (self._print(E._i), self._print(E._j)) \\\n        if self._settings['mat_symbol_style'] == 'plain' else r\"\\mathcal{E}_{%s,%s}\" % (self._print(E._i), self._print(E._j))",
    "sympy.sympy.printing.latex._print_ZeroMatrix": "def _print_ZeroMatrix(self, Z):\n    return \"0\" if self._settings[\n        'mat_symbol_style'] == 'plain' else r\"\\mathbf{0}\"",
    "sympy.sympy.printing.latex._print_OneMatrix": "def _print_OneMatrix(self, O):\n    return \"1\" if self._settings[\n        'mat_symbol_style'] == 'plain' else r\"\\mathbf{1}\"",
    "sympy.sympy.printing.latex._print_Identity": "def _print_Identity(self, I):\n    return r\"\\mathbb{I}\" if self._settings[\n        'mat_symbol_style'] == 'plain' else r\"\\mathbf{I}\"",
    "sympy.sympy.printing.latex._print_PermutationMatrix": "def _print_PermutationMatrix(self, P):\n    perm_str = self._print(P.args[0])\n    return \"P_{%s}\" % perm_str",
    "sympy.sympy.printing.latex._print_NDimArray": "def _print_NDimArray(self, expr: NDimArray):\n\n    if expr.rank() == 0:\n        return self._print(expr[()])\n\n    mat_str = self._settings['mat_str']\n    if mat_str is None:\n        if self._settings['mode'] == 'inline':\n            mat_str = 'smallmatrix'\n        else:\n            if (expr.rank() == 0) or (expr.shape[-1] <= 10):\n                mat_str = 'matrix'\n            else:\n                mat_str = 'array'\n    block_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n    block_str = block_str.replace('%MATSTR%', mat_str)\n    if mat_str == 'array':\n        block_str = block_str.replace('%s', '{' + 'c'*expr.shape[0] + '}%s')\n\n    if self._settings['mat_delim']:\n        left_delim: str = self._settings['mat_delim']\n        right_delim = self._delim_dict[left_delim]\n        block_str = r'\\left' + left_delim + block_str + \\\n                    r'\\right' + right_delim\n\n    if expr.rank() == 0:\n        return block_str % \"\"\n\n    level_str: list[list[str]] = [[] for i in range(expr.rank() + 1)]\n    shape_ranges = [list(range(i)) for i in expr.shape]\n    for outer_i in itertools.product(*shape_ranges):\n        level_str[-1].append(self._print(expr[outer_i]))\n        even = True\n        for back_outer_i in range(expr.rank()-1, -1, -1):\n            if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:\n                break\n            if even:\n                level_str[back_outer_i].append(\n                    r\" & \".join(level_str[back_outer_i+1]))\n            else:\n                level_str[back_outer_i].append(\n                    block_str % (r\"\\\\\".join(level_str[back_outer_i+1])))\n                if len(level_str[back_outer_i+1]) == 1:\n                    level_str[back_outer_i][-1] = r\"\\left[\" + \\\n                        level_str[back_outer_i][-1] + r\"\\right]\"\n            even = not even\n            level_str[back_outer_i+1] = []\n\n    out_str = level_str[0][0]\n\n    if expr.rank() % 2 == 1:\n        out_str = block_str % out_str\n\n    return out_str",
    "sympy.sympy.printing.latex._print_Tensor": "def _print_Tensor(self, expr):\n    name = expr.args[0].args[0]\n    indices = expr.get_indices()\n    return self._printer_tensor_indices(name, indices, {})",
    "sympy.sympy.printing.latex._print_TensorElement": "def _print_TensorElement(self, expr):\n    name = expr.expr.args[0].args[0]\n    indices = expr.expr.get_indices()\n    index_map = expr.index_map\n    return self._printer_tensor_indices(name, indices, index_map)",
    "sympy.sympy.printing.latex._print_TensMul": "def _print_TensMul(self, expr):\n    # prints expressions like \"A(a)\", \"3*A(a)\", \"(1+x)*A(a)\"\n    sign, args = expr._get_args_for_traditional_printer()\n    return sign + \"\".join(\n        [self.parenthesize(arg, precedence(expr)) for arg in args]\n    )",
    "sympy.sympy.printing.latex._print_TensAdd": "def _print_TensAdd(self, expr):\n    a = []\n    args = expr.args\n    for x in args:\n        a.append(self.parenthesize(x, precedence(expr)))\n    a.sort()\n    s = ' + '.join(a)\n    s = s.replace('+ -', '- ')\n    return s",
    "sympy.sympy.printing.latex._print_TensorIndex": "def _print_TensorIndex(self, expr):\n    return \"{}%s{%s}\" % (\n        \"^\" if expr.is_up else \"_\",\n        self._print(expr.args[0])\n    )",
    "sympy.sympy.printing.latex._print_PartialDerivative": "def _print_PartialDerivative(self, expr):\n    if len(expr.variables) == 1:\n        return r\"\\frac{\\partial}{\\partial {%s}}{%s}\" % (\n            self._print(expr.variables[0]),\n            self.parenthesize(expr.expr, PRECEDENCE[\"Mul\"], False)\n        )\n    else:\n        return r\"\\frac{\\partial^{%s}}{%s}{%s}\" % (\n            len(expr.variables),\n            \" \".join([r\"\\partial {%s}\" % self._print(i) for i in expr.variables]),\n            self.parenthesize(expr.expr, PRECEDENCE[\"Mul\"], False)\n        )",
    "sympy.sympy.printing.latex._print_ArraySymbol": "def _print_ArraySymbol(self, expr):\n    return self._print(expr.name)",
    "sympy.sympy.printing.latex._print_ArrayElement": "def _print_ArrayElement(self, expr):\n    return \"{{%s}_{%s}}\" % (\n        self.parenthesize(expr.name, PRECEDENCE[\"Func\"], True),\n        \", \".join([f\"{self._print(i)}\" for i in expr.indices]))",
    "sympy.sympy.printing.latex._print_UniversalSet": "def _print_UniversalSet(self, expr):\n    return r\"\\mathbb{U}\"",
    "sympy.sympy.printing.latex._print_frac": "def _print_frac(self, expr, exp=None):\n    if exp is None:\n        return r\"\\operatorname{frac}{\\left(%s\\right)}\" % self._print(expr.args[0])\n    else:\n        return r\"\\operatorname{frac}{\\left(%s\\right)}^{%s}\" % (\n                self._print(expr.args[0]), exp)",
    "sympy.sympy.printing.latex._print_tuple": "def _print_tuple(self, expr):\n    if self._settings['decimal_separator'] == 'comma':\n        sep = \";\"\n    elif self._settings['decimal_separator'] == 'period':\n        sep = \",\"\n    else:\n        raise ValueError('Unknown Decimal Separator')\n\n    if len(expr) == 1:\n        # 1-tuple needs a trailing separator\n        return self._add_parens_lspace(self._print(expr[0]) + sep)\n    else:\n        return self._add_parens_lspace(\n            (sep + r\" \\  \").join([self._print(i) for i in expr]))",
    "sympy.sympy.printing.latex._print_TensorProduct": "def _print_TensorProduct(self, expr):\n    elements = [self._print(a) for a in expr.args]\n    return r' \\otimes '.join(elements)",
    "sympy.sympy.printing.latex._print_WedgeProduct": "def _print_WedgeProduct(self, expr):\n    elements = [self._print(a) for a in expr.args]\n    return r' \\wedge '.join(elements)",
    "sympy.sympy.printing.latex._print_Tuple": "def _print_Tuple(self, expr):\n    return self._print_tuple(expr)",
    "sympy.sympy.printing.latex._print_list": "def _print_list(self, expr):\n    if self._settings['decimal_separator'] == 'comma':\n        return r\"\\left[ %s\\right]\" % \\\n            r\"; \\  \".join([self._print(i) for i in expr])\n    elif self._settings['decimal_separator'] == 'period':\n        return r\"\\left[ %s\\right]\" % \\\n            r\", \\  \".join([self._print(i) for i in expr])\n    else:\n        raise ValueError('Unknown Decimal Separator')",
    "sympy.sympy.printing.latex._print_dict": "def _print_dict(self, d):\n    keys = sorted(d.keys(), key=default_sort_key)\n    items = []\n\n    for key in keys:\n        val = d[key]\n        items.append(\"%s : %s\" % (self._print(key), self._print(val)))\n\n    return r\"\\left\\{ %s\\right\\}\" % r\", \\  \".join(items)",
    "sympy.sympy.printing.latex._print_Dict": "def _print_Dict(self, expr):\n    return self._print_dict(expr)",
    "sympy.sympy.printing.latex._print_DiracDelta": "def _print_DiracDelta(self, expr, exp=None):\n    if len(expr.args) == 1 or expr.args[1] == 0:\n        tex = r\"\\delta\\left(%s\\right)\" % self._print(expr.args[0])\n    else:\n        tex = r\"\\delta^{\\left( %s \\right)}\\left( %s \\right)\" % (\n            self._print(expr.args[1]), self._print(expr.args[0]))\n    if exp:\n        tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_SingularityFunction": "def _print_SingularityFunction(self, expr, exp=None):\n    shift = self._print(expr.args[0] - expr.args[1])\n    power = self._print(expr.args[2])\n    tex = r\"{\\left\\langle %s \\right\\rangle}^{%s}\" % (shift, power)\n    if exp is not None:\n        tex = r\"{\\left({\\langle %s \\rangle}^{%s}\\right)}^{%s}\" % (shift, power, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_Heaviside": "def _print_Heaviside(self, expr, exp=None):\n    pargs = ', '.join(self._print(arg) for arg in expr.pargs)\n    tex = r\"\\theta\\left(%s\\right)\" % pargs\n    if exp:\n        tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_KroneckerDelta": "def _print_KroneckerDelta(self, expr, exp=None):\n    i = self._print(expr.args[0])\n    j = self._print(expr.args[1])\n    if expr.args[0].is_Atom and expr.args[1].is_Atom:\n        tex = r'\\delta_{%s %s}' % (i, j)\n    else:\n        tex = r'\\delta_{%s, %s}' % (i, j)\n    if exp is not None:\n        tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_LeviCivita": "def _print_LeviCivita(self, expr, exp=None):\n    indices = map(self._print, expr.args)\n    if all(x.is_Atom for x in expr.args):\n        tex = r'\\varepsilon_{%s}' % \" \".join(indices)\n    else:\n        tex = r'\\varepsilon_{%s}' % \", \".join(indices)\n    if exp:\n        tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_RandomDomain": "def _print_RandomDomain(self, d):\n    if hasattr(d, 'as_boolean'):\n        return '\\\\text{Domain: }' + self._print(d.as_boolean())\n    elif hasattr(d, 'set'):\n        return ('\\\\text{Domain: }' + self._print(d.symbols) + ' \\\\in ' +\n                self._print(d.set))\n    elif hasattr(d, 'symbols'):\n        return '\\\\text{Domain on }' + self._print(d.symbols)\n    else:\n        return self._print(None)",
    "sympy.sympy.printing.latex._print_FiniteSet": "def _print_FiniteSet(self, s):\n    items = sorted(s.args, key=default_sort_key)\n    return self._print_set(items)",
    "sympy.sympy.printing.latex._print_set": "def _print_set(self, s):\n    items = sorted(s, key=default_sort_key)\n    if self._settings['decimal_separator'] == 'comma':\n        items = \"; \".join(map(self._print, items))\n    elif self._settings['decimal_separator'] == 'period':\n        items = \", \".join(map(self._print, items))\n    else:\n        raise ValueError('Unknown Decimal Separator')\n    return r\"\\left\\{%s\\right\\}\" % items",
    "sympy.sympy.printing.latex._print_Range": "def _print_Range(self, s):\n    def _print_symbolic_range():\n        # Symbolic Range that cannot be resolved\n        if s.args[0] == 0:\n            if s.args[2] == 1:\n                cont = self._print(s.args[1])\n            else:\n                cont = \", \".join(self._print(arg) for arg in s.args)\n        else:\n            if s.args[2] == 1:\n                cont = \", \".join(self._print(arg) for arg in s.args[:2])\n            else:\n                cont = \", \".join(self._print(arg) for arg in s.args)\n\n        return(f\"\\\\text{{Range}}\\\\left({cont}\\\\right)\")\n\n    dots = object()\n\n    if s.start.is_infinite and s.stop.is_infinite:\n        if s.step.is_positive:\n            printset = dots, -1, 0, 1, dots\n        else:\n            printset = dots, 1, 0, -1, dots\n    elif s.start.is_infinite:\n        printset = dots, s[-1] - s.step, s[-1]\n    elif s.stop.is_infinite:\n        it = iter(s)\n        printset = next(it), next(it), dots\n    elif s.is_empty is not None:\n        if (s.size < 4) == True:\n            printset = tuple(s)\n        elif s.is_iterable:\n            it = iter(s)\n            printset = next(it), next(it), dots, s[-1]\n        else:\n            return _print_symbolic_range()\n    else:\n        return _print_symbolic_range()\n    return (r\"\\left\\{\" +\n            r\", \".join(self._print(el) if el is not dots else r'\\ldots' for el in printset) +\n            r\"\\right\\}\")",
    "sympy.sympy.printing.latex._print_bernoulli": "def _print_bernoulli(self, expr, exp=None):\n    return self.__print_number_polynomial(expr, \"B\", exp)",
    "sympy.sympy.printing.latex._print_genocchi": "def _print_genocchi(self, expr, exp=None):\n    return self.__print_number_polynomial(expr, \"G\", exp)",
    "sympy.sympy.printing.latex._print_bell": "def _print_bell(self, expr, exp=None):\n    if len(expr.args) == 3:\n        tex1 = r\"B_{%s, %s}\" % (self._print(expr.args[0]),\n                            self._print(expr.args[1]))\n        tex2 = r\"\\left(%s\\right)\" % r\", \".join(self._print(el) for\n                                           el in expr.args[2])\n        if exp is not None:\n            tex = r\"%s^{%s}%s\" % (tex1, exp, tex2)\n        else:\n            tex = tex1 + tex2\n        return tex\n    return self.__print_number_polynomial(expr, \"B\", exp)",
    "sympy.sympy.printing.latex._print_fibonacci": "def _print_fibonacci(self, expr, exp=None):\n    return self.__print_number_polynomial(expr, \"F\", exp)",
    "sympy.sympy.printing.latex._print_lucas": "def _print_lucas(self, expr, exp=None):\n    tex = r\"L_{%s}\" % self._print(expr.args[0])\n    if exp is not None:\n        tex = r\"%s^{%s}\" % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_tribonacci": "def _print_tribonacci(self, expr, exp=None):\n    return self.__print_number_polynomial(expr, \"T\", exp)",
    "sympy.sympy.printing.latex._print_mobius": "def _print_mobius(self, expr, exp=None):\n    if exp is None:\n        return r'\\mu\\left(%s\\right)' % self._print(expr.args[0])\n    return r'\\mu^{%s}\\left(%s\\right)' % (exp, self._print(expr.args[0]))",
    "sympy.sympy.printing.latex._print_SeqFormula": "def _print_SeqFormula(self, s):\n    dots = object()\n    if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:\n        return r\"\\left\\{%s\\right\\}_{%s=%s}^{%s}\" % (\n            self._print(s.formula),\n            self._print(s.variables[0]),\n            self._print(s.start),\n            self._print(s.stop)\n        )\n    if s.start is S.NegativeInfinity:\n        stop = s.stop\n        printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),\n                    s.coeff(stop - 1), s.coeff(stop))\n    elif s.stop is S.Infinity or s.length > 4:\n        printset = s[:4]\n        printset.append(dots)\n    else:\n        printset = tuple(s)\n\n    return (r\"\\left[\" +\n            r\", \".join(self._print(el) if el is not dots else r'\\ldots' for el in printset) +\n            r\"\\right]\")",
    "sympy.sympy.printing.latex._print_Interval": "def _print_Interval(self, i):\n    if i.start == i.end:\n        return r\"\\left\\{%s\\right\\}\" % self._print(i.start)\n\n    else:\n        if i.left_open:\n            left = '('\n        else:\n            left = '['\n\n        if i.right_open:\n            right = ')'\n        else:\n            right = ']'\n\n        return r\"\\left%s%s, %s\\right%s\" % \\\n               (left, self._print(i.start), self._print(i.end), right)",
    "sympy.sympy.printing.latex._print_AccumulationBounds": "def _print_AccumulationBounds(self, i):\n    return r\"\\left\\langle %s, %s\\right\\rangle\" % \\\n            (self._print(i.min), self._print(i.max))",
    "sympy.sympy.printing.latex._print_Union": "def _print_Union(self, u):\n    prec = precedence_traditional(u)\n    args_str = [self.parenthesize(i, prec) for i in u.args]\n    return r\" \\cup \".join(args_str)",
    "sympy.sympy.printing.latex._print_Complement": "def _print_Complement(self, u):\n    prec = precedence_traditional(u)\n    args_str = [self.parenthesize(i, prec) for i in u.args]\n    return r\" \\setminus \".join(args_str)",
    "sympy.sympy.printing.latex._print_Intersection": "def _print_Intersection(self, u):\n    prec = precedence_traditional(u)\n    args_str = [self.parenthesize(i, prec) for i in u.args]\n    return r\" \\cap \".join(args_str)",
    "sympy.sympy.printing.latex._print_SymmetricDifference": "def _print_SymmetricDifference(self, u):\n    prec = precedence_traditional(u)\n    args_str = [self.parenthesize(i, prec) for i in u.args]\n    return r\" \\triangle \".join(args_str)",
    "sympy.sympy.printing.latex._print_ProductSet": "def _print_ProductSet(self, p):\n    prec = precedence_traditional(p)\n    if len(p.sets) >= 1 and not has_variety(p.sets):\n        return self.parenthesize(p.sets[0], prec) + \"^{%d}\" % len(p.sets)\n    return r\" \\times \".join(\n        self.parenthesize(set, prec) for set in p.sets)",
    "sympy.sympy.printing.latex._print_EmptySet": "def _print_EmptySet(self, e):\n    return r\"\\emptyset\"",
    "sympy.sympy.printing.latex._print_Naturals": "def _print_Naturals(self, n):\n    return r\"\\mathbb{N}\"",
    "sympy.sympy.printing.latex._print_Naturals0": "def _print_Naturals0(self, n):\n    return r\"\\mathbb{N}_0\"",
    "sympy.sympy.printing.latex._print_Integers": "def _print_Integers(self, i):\n    return r\"\\mathbb{Z}\"",
    "sympy.sympy.printing.latex._print_Rationals": "def _print_Rationals(self, i):\n    return r\"\\mathbb{Q}\"",
    "sympy.sympy.printing.latex._print_Reals": "def _print_Reals(self, i):\n    return r\"\\mathbb{R}\"",
    "sympy.sympy.printing.latex._print_Complexes": "def _print_Complexes(self, i):\n    return r\"\\mathbb{C}\"",
    "sympy.sympy.printing.latex._print_ImageSet": "def _print_ImageSet(self, s):\n    expr = s.lamda.expr\n    sig = s.lamda.signature\n    xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))\n    xinys = r\", \".join(r\"%s \\in %s\" % xy for xy in xys)\n    return r\"\\left\\{%s\\; \\middle|\\; %s\\right\\}\" % (self._print(expr), xinys)",
    "sympy.sympy.printing.latex._print_ConditionSet": "def _print_ConditionSet(self, s):\n    vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])\n    if s.base_set is S.UniversalSet:\n        return r\"\\left\\{%s\\; \\middle|\\; %s \\right\\}\" % \\\n            (vars_print, self._print(s.condition))\n\n    return r\"\\left\\{%s\\; \\middle|\\; %s \\in %s \\wedge %s \\right\\}\" % (\n        vars_print,\n        vars_print,\n        self._print(s.base_set),\n        self._print(s.condition))",
    "sympy.sympy.printing.latex._print_PowerSet": "def _print_PowerSet(self, expr):\n    arg_print = self._print(expr.args[0])\n    return r\"\\mathcal{{P}}\\left({}\\right)\".format(arg_print)",
    "sympy.sympy.printing.latex._print_ComplexRegion": "def _print_ComplexRegion(self, s):\n    vars_print = ', '.join([self._print(var) for var in s.variables])\n    return r\"\\left\\{%s\\; \\middle|\\; %s \\in %s \\right\\}\" % (\n        self._print(s.expr),\n        vars_print,\n        self._print(s.sets))",
    "sympy.sympy.printing.latex._print_Contains": "def _print_Contains(self, e):\n    return r\"%s \\in %s\" % tuple(self._print(a) for a in e.args)",
    "sympy.sympy.printing.latex._print_FourierSeries": "def _print_FourierSeries(self, s):\n    if s.an.formula is S.Zero and s.bn.formula is S.Zero:\n        return self._print(s.a0)\n    return self._print_Add(s.truncate()) + r' + \\ldots'",
    "sympy.sympy.printing.latex._print_FormalPowerSeries": "def _print_FormalPowerSeries(self, s):\n    return self._print_Add(s.infinite)",
    "sympy.sympy.printing.latex._print_IntegerRing": "def _print_IntegerRing(self, expr):\n    return r\"\\mathbb{Z}\"",
    "sympy.sympy.printing.latex._print_RationalField": "def _print_RationalField(self, expr):\n    return r\"\\mathbb{Q}\"",
    "sympy.sympy.printing.latex._print_RealField": "def _print_RealField(self, expr):\n    return r\"\\mathbb{R}\"",
    "sympy.sympy.printing.latex._print_PolynomialRing": "def _print_PolynomialRing(self, expr):\n    domain = self._print(expr.domain)\n    symbols = \", \".join(map(self._print, expr.symbols))\n    return r\"%s\\left[%s\\right]\" % (domain, symbols)",
    "sympy.sympy.printing.latex._print_FractionField": "def _print_FractionField(self, expr):\n    domain = self._print(expr.domain)\n    symbols = \", \".join(map(self._print, expr.symbols))\n    return r\"%s\\left(%s\\right)\" % (domain, symbols)",
    "sympy.sympy.printing.latex._print_PolynomialRingBase": "def _print_PolynomialRingBase(self, expr):\n    domain = self._print(expr.domain)\n    symbols = \", \".join(map(self._print, expr.symbols))\n    inv = \"\"\n    if not expr.is_Poly:\n        inv = r\"S_<^{-1}\"\n    return r\"%s%s\\left[%s\\right]\" % (inv, domain, symbols)",
    "sympy.sympy.printing.latex._print_Poly": "def _print_Poly(self, poly):\n    cls = poly.__class__.__name__\n    terms = []\n    for monom, coeff in poly.terms():\n        s_monom = ''\n        for i, exp in enumerate(monom):\n            if exp > 0:\n                if exp == 1:\n                    s_monom += self._print(poly.gens[i])\n                else:\n                    s_monom += self._print(pow(poly.gens[i], exp))\n\n        if coeff.is_Add:\n            if s_monom:\n                s_coeff = r\"\\left(%s\\right)\" % self._print(coeff)\n            else:\n                s_coeff = self._print(coeff)\n        else:\n            if s_monom:\n                if coeff is S.One:\n                    terms.extend(['+', s_monom])\n                    continue\n\n                if coeff is S.NegativeOne:\n                    terms.extend(['-', s_monom])\n                    continue\n\n            s_coeff = self._print(coeff)\n\n        if not s_monom:\n            s_term = s_coeff\n        else:\n            s_term = s_coeff + \" \" + s_monom\n\n        if s_term.startswith('-'):\n            terms.extend(['-', s_term[1:]])\n        else:\n            terms.extend(['+', s_term])\n\n    if terms[0] in ('-', '+'):\n        modifier = terms.pop(0)\n\n        if modifier == '-':\n            terms[0] = '-' + terms[0]\n\n    expr = ' '.join(terms)\n    gens = list(map(self._print, poly.gens))\n    domain = \"domain=%s\" % self._print(poly.get_domain())\n\n    args = \", \".join([expr] + gens + [domain])\n    if cls in accepted_latex_functions:\n        tex = r\"\\%s {\\left(%s \\right)}\" % (cls, args)\n    else:\n        tex = r\"\\operatorname{%s}{\\left( %s \\right)}\" % (cls, args)\n\n    return tex",
    "sympy.sympy.printing.latex._print_ComplexRootOf": "def _print_ComplexRootOf(self, root):\n    cls = root.__class__.__name__\n    if cls == \"ComplexRootOf\":\n        cls = \"CRootOf\"\n    expr = self._print(root.expr)\n    index = root.index\n    if cls in accepted_latex_functions:\n        return r\"\\%s {\\left(%s, %d\\right)}\" % (cls, expr, index)\n    else:\n        return r\"\\operatorname{%s} {\\left(%s, %d\\right)}\" % (cls, expr,\n                                                             index)",
    "sympy.sympy.printing.latex._print_RootSum": "def _print_RootSum(self, expr):\n    cls = expr.__class__.__name__\n    args = [self._print(expr.expr)]\n\n    if expr.fun is not S.IdentityFunction:\n        args.append(self._print(expr.fun))\n\n    if cls in accepted_latex_functions:\n        return r\"\\%s {\\left(%s\\right)}\" % (cls, \", \".join(args))\n    else:\n        return r\"\\operatorname{%s} {\\left(%s\\right)}\" % (cls,\n                                                         \", \".join(args))",
    "sympy.sympy.printing.latex._print_OrdinalOmega": "def _print_OrdinalOmega(self, expr):\n    return r\"\\omega\"",
    "sympy.sympy.printing.latex._print_OmegaPower": "def _print_OmegaPower(self, expr):\n    exp, mul = expr.args\n    if mul != 1:\n        if exp != 1:\n            return r\"{} \\omega^{{{}}}\".format(mul, exp)\n        else:\n            return r\"{} \\omega\".format(mul)\n    else:\n        if exp != 1:\n            return r\"\\omega^{{{}}}\".format(exp)\n        else:\n            return r\"\\omega\"",
    "sympy.sympy.printing.latex._print_Ordinal": "def _print_Ordinal(self, expr):\n    return \" + \".join([self._print(arg) for arg in expr.args])",
    "sympy.sympy.printing.latex._print_PolyElement": "def _print_PolyElement(self, poly):\n    mul_symbol = self._settings['mul_symbol_latex']\n    return poly.str(self, PRECEDENCE, \"{%s}^{%d}\", mul_symbol)",
    "sympy.sympy.printing.latex._print_FracElement": "def _print_FracElement(self, frac):\n    if frac.denom == 1:\n        return self._print(frac.numer)\n    else:\n        numer = self._print(frac.numer)\n        denom = self._print(frac.denom)\n        return r\"\\frac{%s}{%s}\" % (numer, denom)",
    "sympy.sympy.printing.latex._print_euler": "def _print_euler(self, expr, exp=None):\n    m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args\n    tex = r\"E_{%s}\" % self._print(m)\n    if exp is not None:\n        tex = r\"%s^{%s}\" % (tex, exp)\n    if x is not None:\n        tex = r\"%s\\left(%s\\right)\" % (tex, self._print(x))\n    return tex",
    "sympy.sympy.printing.latex._print_catalan": "def _print_catalan(self, expr, exp=None):\n    tex = r\"C_{%s}\" % self._print(expr.args[0])\n    if exp is not None:\n        tex = r\"%s^{%s}\" % (tex, exp)\n    return tex",
    "sympy.sympy.printing.latex._print_MellinTransform": "def _print_MellinTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'M')",
    "sympy.sympy.printing.latex._print_InverseMellinTransform": "def _print_InverseMellinTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'M', True)",
    "sympy.sympy.printing.latex._print_LaplaceTransform": "def _print_LaplaceTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'L')",
    "sympy.sympy.printing.latex._print_InverseLaplaceTransform": "def _print_InverseLaplaceTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'L', True)",
    "sympy.sympy.printing.latex._print_FourierTransform": "def _print_FourierTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'F')",
    "sympy.sympy.printing.latex._print_InverseFourierTransform": "def _print_InverseFourierTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'F', True)",
    "sympy.sympy.printing.latex._print_SineTransform": "def _print_SineTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'SIN')",
    "sympy.sympy.printing.latex._print_InverseSineTransform": "def _print_InverseSineTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'SIN', True)",
    "sympy.sympy.printing.latex._print_CosineTransform": "def _print_CosineTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'COS')",
    "sympy.sympy.printing.latex._print_InverseCosineTransform": "def _print_InverseCosineTransform(self, expr):\n    return self._print_UnifiedTransform(expr, 'COS', True)",
    "sympy.sympy.printing.latex._print_Object": "def _print_Object(self, object):\n    return self._print(Symbol(object.name))",
    "sympy.sympy.printing.latex._print_LambertW": "def _print_LambertW(self, expr, exp=None):\n    arg0 = self._print(expr.args[0])\n    exp = r\"^{%s}\" % (exp,) if exp is not None else \"\"\n    if len(expr.args) == 1:\n        result = r\"W%s\\left(%s\\right)\" % (exp, arg0)\n    else:\n        arg1 = self._print(expr.args[1])\n        result = \"W{0}_{{{1}}}\\\\left({2}\\\\right)\".format(exp, arg1, arg0)\n    return result",
    "sympy.sympy.printing.latex._print_Expectation": "def _print_Expectation(self, expr):\n    return r\"\\operatorname{{E}}\\left[{}\\right]\".format(self._print(expr.args[0]))",
    "sympy.sympy.printing.latex._print_Variance": "def _print_Variance(self, expr):\n    return r\"\\operatorname{{Var}}\\left({}\\right)\".format(self._print(expr.args[0]))",
    "sympy.sympy.printing.latex._print_Covariance": "def _print_Covariance(self, expr):\n    return r\"\\operatorname{{Cov}}\\left({}\\right)\".format(\", \".join(self._print(arg) for arg in expr.args))",
    "sympy.sympy.printing.latex._print_Probability": "def _print_Probability(self, expr):\n    return r\"\\operatorname{{P}}\\left({}\\right)\".format(self._print(expr.args[0]))",
    "sympy.sympy.printing.latex._print_TransferFunction": "def _print_TransferFunction(self, expr):\n    num, den = self._print(expr.num), self._print(expr.den)\n    return r\"\\frac{%s}{%s}\" % (num, den)",
    "sympy.sympy.printing.latex._print_DiscreteTransferFunction": "def _print_DiscreteTransferFunction(self, expr):\n    num, den = self._print(expr.num), self._print(expr.den)\n    sampling_time = self._print(expr.sampling_time)\n    return r\"\\frac{%s}{%s} \\text{ [st: } {%s} \\text{]}\" % \\\n        (num, den, sampling_time)",
    "sympy.sympy.printing.latex._print_Series": "def _print_Series(self, expr):\n    args = list(expr.args)\n    parens = lambda x: self.parenthesize(x, precedence_traditional(expr),\n                                        False)\n    return ' '.join(map(parens, args))",
    "sympy.sympy.printing.latex._print_MIMOSeries": "def _print_MIMOSeries(self, expr):\n    from sympy.physics.control.lti import MIMOParallel\n    args = list(expr.args)[::-1]\n    parens = lambda x: self.parenthesize(x, precedence_traditional(expr),\n                                         False) if isinstance(x, MIMOParallel) else self._print(x)\n    return r\"\\cdot\".join(map(parens, args))",
    "sympy.sympy.printing.latex._print_Parallel": "def _print_Parallel(self, expr):\n    return ' + '.join(map(self._print, expr.args))",
    "sympy.sympy.printing.latex._print_MIMOParallel": "def _print_MIMOParallel(self, expr):\n    return ' + '.join(map(self._print, expr.args))",
    "sympy.sympy.printing.latex._print_Feedback": "def _print_Feedback(self, expr):\n    from sympy.physics.control import TransferFunction, Series\n\n    num, tf = expr.sys1, TransferFunction(1, 1, expr.var)\n    num_arg_list = list(num.args) if isinstance(num, Series) else [num]\n    den_arg_list = list(expr.sys2.args) if \\\n        isinstance(expr.sys2, Series) else [expr.sys2]\n    den_term_1 = tf\n\n    if isinstance(num, Series) and isinstance(expr.sys2, Series):\n        den_term_2 = Series(*num_arg_list, *den_arg_list)\n    elif isinstance(num, Series) and isinstance(expr.sys2, TransferFunction):\n        if expr.sys2 == tf:\n            den_term_2 = Series(*num_arg_list)\n        else:\n            den_term_2 = tf, Series(*num_arg_list, expr.sys2)\n    elif isinstance(num, TransferFunction) and isinstance(expr.sys2, Series):\n        if num == tf:\n            den_term_2 = Series(*den_arg_list)\n        else:\n            den_term_2 = Series(num, *den_arg_list)\n    else:\n        if num == tf:\n            den_term_2 = Series(*den_arg_list)\n        elif expr.sys2 == tf:\n            den_term_2 = Series(*num_arg_list)\n        else:\n            den_term_2 = Series(*num_arg_list, *den_arg_list)\n\n    numer = self._print(num)\n    denom_1 = self._print(den_term_1)\n    denom_2 = self._print(den_term_2)\n    _sign = \"+\" if expr.sign == -1 else \"-\"\n\n    return r\"\\frac{%s}{%s %s %s}\" % (numer, denom_1, _sign, denom_2)",
    "sympy.sympy.printing.latex._print_MIMOFeedback": "def _print_MIMOFeedback(self, expr):\n    from sympy.physics.control import MIMOSeries\n    inv_mat = self._print(MIMOSeries(expr.sys2, expr.sys1))\n    sys1 = self._print(expr.sys1)\n    _sign = \"+\" if expr.sign == -1 else \"-\"\n    return r\"\\left(I_{\\tau} %s %s\\right)^{-1} \\cdot %s\" % (_sign, inv_mat,\n                                                           sys1)",
    "sympy.sympy.printing.latex._print_TransferFunctionMatrix": "def _print_TransferFunctionMatrix(self, expr):\n    mat = self._print(expr._expr_mat)\n    if expr.sampling_time == 0:\n        print_mat = r\"%s_\\tau\" % mat\n    else:\n        print_mat = r\"\\underset{[st:\\ {%s}]}{%s_k}\" %\\\n                    (expr.sampling_time, mat)\n    return print_mat",
    "sympy.sympy.printing.latex._print_DFT": "def _print_DFT(self, expr):\n    return r\"\\text{{{}}}_{{{}}}\".format(expr.__class__.__name__, expr.n)",
    "sympy.sympy.printing.latex._print_NamedMorphism": "def _print_NamedMorphism(self, morphism):\n    pretty_name = self._print(Symbol(morphism.name))\n    pretty_morphism = self._print_Morphism(morphism)\n    return \"%s:%s\" % (pretty_name, pretty_morphism)",
    "sympy.sympy.printing.latex._print_IdentityMorphism": "def _print_IdentityMorphism(self, morphism):\n    from sympy.categories import NamedMorphism\n    return self._print_NamedMorphism(NamedMorphism(\n        morphism.domain, morphism.codomain, \"id\"))",
    "sympy.sympy.printing.latex._print_CompositeMorphism": "def _print_CompositeMorphism(self, morphism):\n    # All components of the morphism have names and it is thus\n    # possible to build the name of the composite.\n    component_names_list = [self._print(Symbol(component.name)) for\n                            component in morphism.components]\n    component_names_list.reverse()\n    component_names = \"\\\\circ \".join(component_names_list) + \":\"\n\n    pretty_morphism = self._print_Morphism(morphism)\n    return component_names + pretty_morphism",
    "sympy.sympy.printing.latex._print_Category": "def _print_Category(self, morphism):\n    return r\"\\mathbf{{{}}}\".format(self._print(Symbol(morphism.name)))",
    "sympy.sympy.printing.latex._print_Diagram": "def _print_Diagram(self, diagram):\n    if not diagram.premises:\n        # This is an empty diagram.\n        return self._print(S.EmptySet)\n\n    latex_result = self._print(diagram.premises)\n    if diagram.conclusions:\n        latex_result += \"\\\\Longrightarrow %s\" % \\\n                        self._print(diagram.conclusions)\n\n    return latex_result",
    "sympy.sympy.printing.latex._print_DiagramGrid": "def _print_DiagramGrid(self, grid):\n    latex_result = \"\\\\begin{array}{%s}\\n\" % (\"c\" * grid.width)\n\n    for i in range(grid.height):\n        for j in range(grid.width):\n            if grid[i, j]:\n                latex_result += latex(grid[i, j])\n            latex_result += \" \"\n            if j != grid.width - 1:\n                latex_result += \"& \"\n\n        if i != grid.height - 1:\n            latex_result += \"\\\\\\\\\"\n        latex_result += \"\\n\"\n\n    latex_result += \"\\\\end{array}\\n\"\n    return latex_result",
    "sympy.sympy.printing.latex._print_FreeModule": "def _print_FreeModule(self, M):\n    return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))",
    "sympy.sympy.printing.latex._print_SubModule": "def _print_SubModule(self, m):\n    gens = [[self._print(m.ring.to_sympy(x)) for x in g] for g in m.gens]\n    curly = lambda o: r\"{\" + o + r\"}\"\n    square = lambda o: r\"\\left[ \" + o + r\" \\right]\"\n    gens_latex = \",\".join(curly(square(\",\".join(curly(x) for x in g))) for g in gens)\n    return r\"\\left\\langle {} \\right\\rangle\".format(gens_latex)",
    "sympy.sympy.printing.latex._print_SubQuotientModule": "def _print_SubQuotientModule(self, m):\n    gens_latex = \",\".join([\"{\" + self._print(g) + \"}\" for g in m.gens])\n    return r\"\\left\\langle {} \\right\\rangle\".format(gens_latex)",
    "sympy.sympy.printing.latex._print_ModuleImplementedIdeal": "def _print_ModuleImplementedIdeal(self, m):\n    gens = [m.ring.to_sympy(x) for [x] in m._module.gens]\n    gens_latex = \",\".join('{' + self._print(x) + '}' for x in gens)\n    return r\"\\left\\langle {} \\right\\rangle\".format(gens_latex)",
    "sympy.sympy.printing.latex._print_Quaternion": "def _print_Quaternion(self, expr):\n    # TODO: This expression is potentially confusing,\n    # shall we print it as `Quaternion( ... )`?\n    s = [self.parenthesize(i, PRECEDENCE[\"Mul\"], strict=True)\n         for i in expr.args]\n    a = [s[0]] + [i+\" \"+j for i, j in zip(s[1:], \"ijk\")]\n    return \" + \".join(a)",
    "sympy.sympy.printing.latex._print_QuotientRing": "def _print_QuotientRing(self, R):\n    # TODO nicer fractions for few generators...\n    return r\"\\frac{{{}}}{{{}}}\".format(self._print(R.ring),\n             self._print(R.base_ideal))",
    "sympy.sympy.printing.latex._print_QuotientRingElement": "def _print_QuotientRingElement(self, x):\n    x_latex = self._print(x.ring.to_sympy(x))\n    return r\"{{{}}} + {{{}}}\".format(x_latex,\n             self._print(x.ring.base_ideal))",
    "sympy.sympy.printing.latex._print_QuotientModuleElement": "def _print_QuotientModuleElement(self, m):\n    data = [m.module.ring.to_sympy(x) for x in m.data]\n    data_latex = r\"\\left[ {} \\right]\".format(\",\".join(\n        '{' + self._print(x) + '}' for x in data))\n    return r\"{{{}}} + {{{}}}\".format(data_latex,\n             self._print(m.module.killed_module))",
    "sympy.sympy.printing.latex._print_QuotientModule": "def _print_QuotientModule(self, M):\n    # TODO nicer fractions for few generators...\n    return r\"\\frac{{{}}}{{{}}}\".format(self._print(M.base),\n             self._print(M.killed_module))",
    "sympy.sympy.printing.latex._print_MatrixHomomorphism": "def _print_MatrixHomomorphism(self, h):\n    return r\"{{{}}} : {{{}}} \\to {{{}}}\".format(self._print(h._sympy_matrix()),\n        self._print(h.domain), self._print(h.codomain))",
    "sympy.sympy.printing.latex._print_Manifold": "def _print_Manifold(self, manifold):\n    name, supers, subs = self._split_super_sub(manifold.name.name)\n\n    name = r'\\text{%s}' % name\n    if supers:\n        name += \"^{%s}\" % \" \".join(supers)\n    if subs:\n        name += \"_{%s}\" % \" \".join(subs)\n\n    return name",
    "sympy.sympy.printing.latex._print_Patch": "def _print_Patch(self, patch):\n    return r'\\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))",
    "sympy.sympy.printing.latex._print_CoordSystem": "def _print_CoordSystem(self, coordsys):\n    return r'\\text{%s}^{\\text{%s}}_{%s}' % (\n        self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)\n    )",
    "sympy.sympy.printing.latex._print_BaseScalarField": "def _print_BaseScalarField(self, field):\n    string = field._coord_sys.symbols[field._index].name\n    return r'\\mathbf{{{}}}'.format(self._print(Symbol(string)))",
    "sympy.sympy.printing.latex._print_Differential": "def _print_Differential(self, diff):\n    field = diff._form_field\n    if hasattr(field, '_coord_sys'):\n        string = field._coord_sys.symbols[field._index].name\n        return r'\\operatorname{{d}}{}'.format(self._print(Symbol(string)))\n    else:\n        string = self._print(field)\n        return r'\\operatorname{{d}}\\left({}\\right)'.format(string)",
    "sympy.sympy.printing.latex._print_Tr": "def _print_Tr(self, p):\n    # TODO: Handle indices\n    contents = self._print(p.args[0])\n    return r'\\operatorname{{tr}}\\left({}\\right)'.format(contents)",
    "sympy.sympy.printing.latex._print_totient": "def _print_totient(self, expr, exp=None):\n    if exp is not None:\n        return r'\\left(\\phi\\left(%s\\right)\\right)^{%s}' % \\\n            (self._print(expr.args[0]), exp)\n    return r'\\phi\\left(%s\\right)' % self._print(expr.args[0])",
    "sympy.sympy.printing.latex._print_reduced_totient": "def _print_reduced_totient(self, expr, exp=None):\n    if exp is not None:\n        return r'\\left(\\lambda\\left(%s\\right)\\right)^{%s}' % \\\n            (self._print(expr.args[0]), exp)\n    return r'\\lambda\\left(%s\\right)' % self._print(expr.args[0])",
    "sympy.sympy.printing.latex._print_divisor_sigma": "def _print_divisor_sigma(self, expr, exp=None):\n    if len(expr.args) == 2:\n        tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n                                            (expr.args[1], expr.args[0])))\n    else:\n        tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"\\sigma^{%s}%s\" % (exp, tex)\n    return r\"\\sigma%s\" % tex",
    "sympy.sympy.printing.latex._print_udivisor_sigma": "def _print_udivisor_sigma(self, expr, exp=None):\n    if len(expr.args) == 2:\n        tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n                                            (expr.args[1], expr.args[0])))\n    else:\n        tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n    if exp is not None:\n        return r\"\\sigma^*^{%s}%s\" % (exp, tex)\n    return r\"\\sigma^*%s\" % tex",
    "sympy.sympy.printing.latex._print_primenu": "def _print_primenu(self, expr, exp=None):\n    if exp is not None:\n        return r'\\left(\\nu\\left(%s\\right)\\right)^{%s}' % \\\n            (self._print(expr.args[0]), exp)\n    return r'\\nu\\left(%s\\right)' % self._print(expr.args[0])",
    "sympy.sympy.printing.latex._print_primeomega": "def _print_primeomega(self, expr, exp=None):\n    if exp is not None:\n        return r'\\left(\\Omega\\left(%s\\right)\\right)^{%s}' % \\\n            (self._print(expr.args[0]), exp)\n    return r'\\Omega\\left(%s\\right)' % self._print(expr.args[0])",
    "sympy.sympy.printing.latex._print_Str": "def _print_Str(self, s):\n    return str(s.name)",
    "sympy.sympy.printing.latex._print_float": "def _print_float(self, expr):\n    return self._print(Float(expr))",
    "sympy.sympy.printing.latex._print_int": "def _print_int(self, expr):\n    return str(expr)",
    "sympy.sympy.printing.latex.emptyPrinter": "def emptyPrinter(self, expr):\n    # default to just printing as monospace, like would normally be shown\n    s = super().emptyPrinter(expr)\n\n    return r\"\\mathtt{\\text{%s}}\" % latex_escape(s)",
    "sympy.sympy.printing.latex._print_Basic": "def _print_Basic(self, expr):\n    name = self._deal_with_super_sub(expr.__class__.__name__)\n    if expr.args:\n        ls = [self._print(o) for o in expr.args]\n        s = r\"\\operatorname{{{}}}\\left({}\\right)\"\n        return s.format(name, \", \".join(ls))\n    else:\n        return r\"\\text{{{}}}\".format(name)",
    "sympy.sympy.printing.latex._print_bool": "def _print_bool(self, e: bool | BooleanTrue | BooleanFalse):\n    return r\"\\text{%s}\" % e",
    "sympy.sympy.printing.latex._print_NoneType": "def _print_NoneType(self, e):\n    return r\"\\text{%s}\" % e",
    "sympy.sympy.printing.latex._print_Add": "def _print_Add(self, expr, order=None):\n    terms = self._as_ordered_terms(expr, order=order)\n\n    tex = \"\"\n    for i, term in enumerate(terms):\n        if i == 0:\n            pass\n        elif term.could_extract_minus_sign():\n            tex += \" - \"\n            term = -term\n        else:\n            tex += \" + \"\n        term_tex = self._print(term)\n        if self._needs_add_brackets(term):\n            term_tex = r\"\\left(%s\\right)\" % term_tex\n        tex += term_tex\n\n    return tex",
    "sympy.sympy.printing.latex._print_Cycle": "def _print_Cycle(self, expr):\n    from sympy.combinatorics.permutations import Permutation\n    if expr.size == 0:\n        return r\"\\left( \\right)\"\n    expr = Permutation(expr)\n    expr_perm = expr.cyclic_form\n    siz = expr.size\n    if expr.array_form[-1] == siz - 1:\n        expr_perm = expr_perm + [[siz - 1]]\n    term_tex = ''\n    for i in expr_perm:\n        term_tex += str(i).replace(',', r\"\\;\")\n    term_tex = term_tex.replace('[', r\"\\left( \")\n    term_tex = term_tex.replace(']', r\"\\right)\")\n    return term_tex",
    "sympy.sympy.printing.latex._print_Permutation": "def _print_Permutation(self, expr):\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.utilities.exceptions import sympy_deprecation_warning\n\n    perm_cyclic = Permutation.print_cyclic\n    if perm_cyclic is not None:\n        sympy_deprecation_warning(\n            f\"\"\"\n            Setting Permutation.print_cyclic is deprecated. Instead use\n            init_printing(perm_cyclic={perm_cyclic}).\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-permutation-print_cyclic\",\n            stacklevel=8,\n        )\n    else:\n        perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n    if perm_cyclic:\n        return self._print_Cycle(expr)\n\n    if expr.size == 0:\n        return r\"\\left( \\right)\"\n\n    lower = [self._print(arg) for arg in expr.array_form]\n    upper = [self._print(arg) for arg in range(len(lower))]\n\n    row1 = \" & \".join(upper)\n    row2 = \" & \".join(lower)\n    mat = r\" \\\\ \".join((row1, row2))\n    return r\"\\begin{pmatrix} %s \\end{pmatrix}\" % mat",
    "sympy.sympy.printing.latex._print_AppliedPermutation": "def _print_AppliedPermutation(self, expr):\n    perm, var = expr.args\n    return r\"\\sigma_{%s}(%s)\" % (self._print(perm), self._print(var))",
    "sympy.sympy.printing.latex._print_Float": "def _print_Float(self, expr):\n    # Based off of that in StrPrinter\n    dps = prec_to_dps(expr._prec)\n    strip = False if self._settings['full_prec'] else True\n    low = self._settings[\"min\"] if \"min\" in self._settings else None\n    high = self._settings[\"max\"] if \"max\" in self._settings else None\n    str_real = mlib_to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)\n\n    # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n    # thus we use the number separator\n    separator = self._settings['mul_symbol_latex_numbers']\n\n    if 'e' in str_real:\n        (mant, exp) = str_real.split('e')\n\n        if exp[0] == '+':\n            exp = exp[1:]\n        if self._settings['decimal_separator'] == 'comma':\n            mant = mant.replace('.','{,}')\n\n        return r\"%s%s10^{%s}\" % (mant, separator, exp)\n    elif str_real == \"+inf\":\n        return r\"\\infty\"\n    elif str_real == \"-inf\":\n        return r\"- \\infty\"\n    else:\n        if self._settings['decimal_separator'] == 'comma':\n            str_real = str_real.replace('.','{,}')\n        return str_real",
    "sympy.sympy.printing.latex._print_Cross": "def _print_Cross(self, expr):\n    vec1 = expr._expr1\n    vec2 = expr._expr2\n    return r\"%s \\times %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n                              self.parenthesize(vec2, PRECEDENCE['Mul']))",
    "sympy.sympy.printing.latex._print_Curl": "def _print_Curl(self, expr):\n    vec = expr._expr\n    return r\"\\nabla\\times %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])",
    "sympy.sympy.printing.latex._print_Divergence": "def _print_Divergence(self, expr):\n    vec = expr._expr\n    return r\"\\nabla\\cdot %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])",
    "sympy.sympy.printing.latex._print_Dot": "def _print_Dot(self, expr):\n    vec1 = expr._expr1\n    vec2 = expr._expr2\n    return r\"%s \\cdot %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n                             self.parenthesize(vec2, PRECEDENCE['Mul']))",
    "sympy.sympy.printing.latex._print_Gradient": "def _print_Gradient(self, expr):\n    func = expr._expr\n    return r\"\\nabla %s\" % self.parenthesize(func, PRECEDENCE['Mul'])",
    "sympy.sympy.printing.latex._print_Laplacian": "def _print_Laplacian(self, expr):\n    func = expr._expr\n    return r\"\\Delta %s\" % self.parenthesize(func, PRECEDENCE['Mul'])",
    "sympy.sympy.printing.latex._print_Mul": "def _print_Mul(self, expr: Expr):\n    from sympy.simplify import fraction\n    separator: str = self._settings['mul_symbol_latex']\n    numbersep: str = self._settings['mul_symbol_latex_numbers']\n\n    def convert(expr) -> str:\n        if not expr.is_Mul:\n            return str(self._print(expr))\n        else:\n            if self.order not in ('old', 'none'):\n                args = expr.as_ordered_factors()\n            else:\n                args = list(expr.args)\n\n            # If there are quantities or prefixes, append them at the back.\n            units, nonunits = sift(args, lambda x: (hasattr(x, \"_scale_factor\") or hasattr(x, \"is_physical_constant\")) or\n                          (isinstance(x, Pow) and\n                           hasattr(x.base, \"is_physical_constant\")), binary=True)\n            prefixes, units = sift(units, lambda x: hasattr(x, \"_scale_factor\"), binary=True)\n            return convert_args(nonunits + prefixes + units)\n\n    def convert_args(args) -> str:\n        _tex = last_term_tex = \"\"\n\n        for i, term in enumerate(args):\n            term_tex = self._print(term)\n            if not (hasattr(term, \"_scale_factor\") or hasattr(term, \"is_physical_constant\")):\n                if self._needs_mul_brackets(term, first=(i == 0),\n                                            last=(i == len(args) - 1)):\n                    term_tex = r\"\\left(%s\\right)\" % term_tex\n\n                if  _between_two_numbers_p[0].search(last_term_tex) and \\\n                    _between_two_numbers_p[1].match(term_tex):\n                    # between two numbers\n                    _tex += numbersep\n                elif _tex:\n                    _tex += separator\n            elif _tex:\n                _tex += separator\n\n            _tex += term_tex\n            last_term_tex = term_tex\n        return _tex\n\n    # Check for unevaluated Mul. In this case we need to make sure the\n    # identities are visible, multiple Rational factors are not combined\n    # etc so we display in a straight-forward form that fully preserves all\n    # args and their order.\n    # XXX: _print_Pow calls this routine with instances of Pow...\n    if isinstance(expr, Mul):\n        args = expr.args\n        if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):\n            return convert_args(args)\n\n    include_parens = False\n    if expr.could_extract_minus_sign():\n        expr = -expr\n        tex = \"- \"\n        if expr.is_Add:\n            tex += \"(\"\n            include_parens = True\n    else:\n        tex = \"\"\n\n    numer, denom = fraction(expr, exact=True)\n\n    if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:\n        # use the original expression here, since fraction() may have\n        # altered it when producing numer and denom\n        tex += convert(expr)\n\n    else:\n        snumer = convert(numer)\n        sdenom = convert(denom)\n        ldenom = len(sdenom.split())\n        ratio = self._settings['long_frac_ratio']\n        if self._settings['fold_short_frac'] and ldenom <= 2 and \\\n                \"^\" not in sdenom:\n            # handle short fractions\n            if self._needs_mul_brackets(numer, last=False):\n                tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n            else:\n                tex += r\"%s / %s\" % (snumer, sdenom)\n        elif ratio is not None and \\\n                len(snumer.split()) > ratio*ldenom:\n            # handle long fractions\n            if self._needs_mul_brackets(numer, last=True):\n                tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                    % (sdenom, separator, snumer)\n            elif numer.is_Mul:\n                # split a long numerator\n                a = S.One\n                b = S.One\n                for x in numer.args:\n                    if self._needs_mul_brackets(x, last=False) or \\\n                            len(convert(a*x).split()) > ratio*ldenom or \\\n                            (b.is_commutative is x.is_commutative is False):\n                        b *= x\n                    else:\n                        a *= x\n                if self._needs_mul_brackets(b, last=True):\n                    tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                        % (convert(a), sdenom, separator, convert(b))\n                else:\n                    tex += r\"\\frac{%s}{%s}%s%s\" \\\n                        % (convert(a), sdenom, separator, convert(b))\n            else:\n                tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n        else:\n            tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n\n    if include_parens:\n        tex += \")\"\n    return tex",
    "sympy.sympy.printing.latex._print_AlgebraicNumber": "def _print_AlgebraicNumber(self, expr):\n    if expr.is_aliased:\n        return self._print(expr.as_poly().as_expr())\n    else:\n        return self._print(expr.as_expr())",
    "sympy.sympy.printing.latex._print_PrimeIdeal": "def _print_PrimeIdeal(self, expr):\n    p = self._print(expr.p)\n    if expr.is_inert:\n        return rf'\\left({p}\\right)'\n    alpha = self._print(expr.alpha.as_expr())\n    return rf'\\left({p}, {alpha}\\right)'",
    "sympy.sympy.printing.latex._print_Pow": "def _print_Pow(self, expr: Pow):\n    # Treat x**Rational(1,n) as special case\n    if expr.exp.is_Rational:\n        p: int = expr.exp.p  # type: ignore\n        q: int = expr.exp.q  # type: ignore\n        if abs(p) == 1 and q != 1 and self._settings['root_notation']:\n            base = self._print(expr.base)\n            if q == 2:\n                tex = r\"\\sqrt{%s}\" % base\n            elif self._settings['itex']:\n                tex = r\"\\root{%d}{%s}\" % (q, base)\n            else:\n                tex = r\"\\sqrt[%d]{%s}\" % (q, base)\n            if expr.exp.is_negative:\n                return r\"\\frac{1}{%s}\" % tex\n            else:\n                return tex\n        elif self._settings['fold_frac_powers'] and q != 1:\n            base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n            # issue #12886: add parentheses for superscripts raised to powers\n            if expr.base.is_Symbol:\n                base = self.parenthesize_super(base)\n            if expr.base.is_Function:\n                return self._print(expr.base, exp=\"%s/%s\" % (p, q))\n            return r\"%s^{%s/%s}\" % (base, p, q)\n        elif expr.exp.is_negative and expr.base.is_commutative:\n            # special case for 1^(-x), issue 9216\n            if expr.base == 1:\n                return r\"%s^{%s}\" % (expr.base, expr.exp)\n            # special case for (1/x)^(-y) and (-1/-x)^(-y), issue 20252\n            if expr.base.is_Rational:\n                base_p: int = expr.base.p  # type: ignore\n                base_q: int = expr.base.q  # type: ignore\n                if base_p * base_q == abs(base_q):\n                    if expr.exp == -1:\n                        return r\"\\frac{1}{\\frac{%s}{%s}}\" % (base_p, base_q)\n                    else:\n                        return r\"\\frac{1}{(\\frac{%s}{%s})^{%s}}\" % (base_p, base_q, abs(expr.exp))\n            # things like 1/x\n            return self._print_Mul(expr)\n    if expr.base.is_Function:\n        return self._print(expr.base, exp=self._print(expr.exp))\n    tex = r\"%s^{%s}\"\n    return self._helper_print_standard_power(expr, tex)",
    "sympy.sympy.printing.latex._print_UnevaluatedExpr": "def _print_UnevaluatedExpr(self, expr):\n    return self._print(expr.args[0])",
    "sympy.sympy.printing.latex._print_Sum": "def _print_Sum(self, expr):\n    if len(expr.limits) == 1:\n        tex = r\"\\sum_{%s=%s}^{%s} \" % \\\n            tuple([self._print(i) for i in expr.limits[0]])\n    else:\n        def _format_ineq(l):\n            return r\"%s \\leq %s \\leq %s\" % \\\n                tuple([self._print(s) for s in (l[1], l[0], l[2])])\n\n        tex = r\"\\sum_{\\substack{%s}} \" % \\\n            str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n\n    if isinstance(expr.function, Add):\n        tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n    else:\n        tex += self._print(expr.function)\n\n    return tex",
    "sympy.sympy.printing.latex._print_Product": "def _print_Product(self, expr):\n    if len(expr.limits) == 1:\n        tex = r\"\\prod_{%s=%s}^{%s} \" % \\\n            tuple([self._print(i) for i in expr.limits[0]])\n    else:\n        def _format_ineq(l):\n            return r\"%s \\leq %s \\leq %s\" % \\\n                tuple([self._print(s) for s in (l[1], l[0], l[2])])\n\n        tex = r\"\\prod_{\\substack{%s}} \" % \\\n            str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n\n    if isinstance(expr.function, Add):\n        tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n    else:\n        tex += self._print(expr.function)\n\n    return tex",
    "sympy.sympy.printing.latex._print_BasisDependent": "def _print_BasisDependent(self, expr: 'BasisDependent'):\n    from sympy.vector import Vector\n\n    o1: list[str] = []\n    if expr == expr.zero:\n        return expr.zero._latex_form\n    if isinstance(expr, Vector):\n        items = expr.separate().items()\n    else:\n        items = [(0, expr)]\n\n    for system, vect in items:\n        inneritems = list(vect.components.items())\n        inneritems.sort(key=lambda x: x[0].__str__())\n        for k, v in inneritems:\n            if v == 1:\n                o1.append(' + ' + k._latex_form)\n            elif v == -1:\n                o1.append(' - ' + k._latex_form)\n            else:\n                arg_str = r'\\left(' + self._print(v) + r'\\right)'\n                o1.append(' + ' + arg_str + k._latex_form)\n\n    outstr = (''.join(o1))\n    if outstr[1] != '-':\n        outstr = outstr[3:]\n    else:\n        outstr = outstr[1:]\n    return outstr",
    "sympy.sympy.printing.latex._print_Indexed": "def _print_Indexed(self, expr):\n    tex_base = self._print(expr.base)\n    tex = '{'+tex_base+'}'+'_{%s}' % ','.join(\n        map(self._print, expr.indices))\n    return tex",
    "sympy.sympy.printing.latex._print_IndexedBase": "def _print_IndexedBase(self, expr):\n    return self._print(expr.label)",
    "sympy.sympy.printing.latex._print_Idx": "def _print_Idx(self, expr):\n    label = self._print(expr.label)\n    if expr.upper is not None:\n        upper = self._print(expr.upper)\n        if expr.lower is not None:\n            lower = self._print(expr.lower)\n        else:\n            lower = self._print(S.Zero)\n        interval = '{lower}\\\\mathrel{{..}}\\\\nobreak {upper}'.format(\n                lower = lower, upper = upper)\n        return '{{{label}}}_{{{interval}}}'.format(\n            label = label, interval = interval)\n    #if no bounds are defined this just prints the label\n    return label",
    "sympy.sympy.printing.latex._print_Derivative": "def _print_Derivative(self, expr):\n    if requires_partial(expr.expr):\n        diff_symbol = r'\\partial'\n    else:\n        diff_symbol = self._settings[\"diff_operator_latex\"]\n\n    tex = \"\"\n    dim = 0\n    for x, num in reversed(expr.variable_count):\n        dim += num\n        if num == 1:\n            tex += r\"%s %s\" % (diff_symbol, self._print(x))\n        else:\n            tex += r\"%s %s^{%s}\" % (diff_symbol,\n                                    self.parenthesize_super(self._print(x)),\n                                    self._print(num))\n\n    if dim == 1:\n        tex = r\"\\frac{%s}{%s}\" % (diff_symbol, tex)\n    else:\n        tex = r\"\\frac{%s^{%s}}{%s}\" % (diff_symbol, self._print(dim), tex)\n\n    precedence = PRECEDENCE[\"Mul\"]\n    if self._settings['mul_symbol']:\n        # Nudge up the precedence so d/dx (f(x) * g(x)) also gets parenthesized\n        precedence += 1\n    if any(i.could_extract_minus_sign() for i in expr.args):\n        return r\"%s %s\" % (tex, self.parenthesize(expr.expr,\n                                              precedence,\n                                              is_neg=True,\n                                              strict=True))\n\n    return r\"%s %s\" % (tex, self.parenthesize(expr.expr,\n                                              precedence,\n                                              is_neg=False,\n                                              strict=True))",
    "sympy.sympy.printing.latex._print_Subs": "def _print_Subs(self, subs):\n    expr, old, new = subs.args\n    latex_expr = self._print(expr)\n    latex_old = (self._print(e) for e in old)\n    latex_new = (self._print(e) for e in new)\n    latex_subs = r'\\\\ '.join(\n        e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n    return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr,\n                                                     latex_subs)",
    "sympy.sympy.printing.latex.<genexpr>": "latex_new = (self._print(e) for e in new)\n",
    "sympy.sympy.printing.latex._print_Integral": "def _print_Integral(self, expr):\n    tex, symbols = \"\", []\n    diff_symbol = self._settings[\"diff_operator_latex\"]\n\n    # Only up to \\iiiint exists\n    if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):\n        # Use len(expr.limits)-1 so that syntax highlighters don't think\n        # \\\" is an escaped quote\n        tex = r\"\\i\" + \"i\"*(len(expr.limits) - 1) + \"nt\"\n        symbols = [r\"\\, %s%s\" % (diff_symbol, self._print(symbol[0]))\n                   for symbol in expr.limits]\n\n    else:\n        for lim in reversed(expr.limits):\n            symbol = lim[0]\n            tex += r\"\\int\"\n\n            if len(lim) > 1:\n                if self._settings['mode'] != 'inline' \\\n                        and not self._settings['itex']:\n                    tex += r\"\\limits\"\n\n                if len(lim) == 3:\n                    tex += \"_{%s}^{%s}\" % (self._print(lim[1]),\n                                           self._print(lim[2]))\n                if len(lim) == 2:\n                    tex += \"^{%s}\" % (self._print(lim[1]))\n\n            symbols.insert(0, r\"\\, %s%s\" % (diff_symbol, self._print(symbol)))\n\n    return r\"%s %s%s\" % (tex, self.parenthesize(expr.function,\n                                                PRECEDENCE[\"Mul\"],\n                                                is_neg=any(i.could_extract_minus_sign() for i in expr.args),\n                                                strict=True),\n                         \"\".join(symbols))",
    "sympy.sympy.printing.latex._print_Limit": "def _print_Limit(self, expr):\n    e, z, z0, dir = expr.args\n\n    tex = r\"\\lim_{%s \\to \" % self._print(z)\n    if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n        tex += r\"%s}\" % self._print(z0)\n    else:\n        tex += r\"%s^%s}\" % (self._print(z0), self._print(dir))\n\n    if isinstance(e, AssocOp):\n        return r\"%s\\left(%s\\right)\" % (tex, self._print(e))\n    else:\n        return r\"%s %s\" % (tex, self._print(e))",
    "sympy.sympy.printing.latex._print_Function": "def _print_Function(self, expr: Function, exp=None) -> str:\n    r'''\n    Render functions to LaTeX, handling functions that LaTeX knows about\n    e.g., sin, cos, ... by using the proper LaTeX command (\\sin, \\cos, ...).\n    For single-letter function names, render them as regular LaTeX math\n    symbols. For multi-letter function names that LaTeX does not know\n    about, (e.g., Li, sech) use \\operatorname{} so that the function name\n    is rendered in Roman font and LaTeX handles spacing properly.\n\n    expr is the expression involving the function\n    exp is an exponent\n    '''\n    func = expr.func.__name__\n    if hasattr(self, '_print_' + func) and \\\n            not isinstance(expr, AppliedUndef):\n        return getattr(self, '_print_' + func)(expr, exp)\n    else:\n        args = [str(self._print(arg)) for arg in expr.args]\n        # How inverse trig functions should be displayed, formats are:\n        # abbreviated: asin, full: arcsin, power: sin^-1\n        inv_trig_style = self._settings['inv_trig_style']\n        # If we are dealing with a power-style inverse trig function\n        inv_trig_power_case = False\n        # If it is applicable to fold the argument brackets\n        can_fold_brackets = self._settings['fold_func_brackets'] and \\\n            len(args) == 1 and \\\n            not self._needs_function_brackets(expr.args[0])\n\n        inv_trig_table = [\n            \"asin\", \"acos\", \"atan\",\n            \"acsc\", \"asec\", \"acot\",\n            \"asinh\", \"acosh\", \"atanh\",\n            \"acsch\", \"asech\", \"acoth\",\n        ]\n\n        # If the function is an inverse trig function, handle the style\n        if func in inv_trig_table:\n            if inv_trig_style == \"abbreviated\":\n                pass\n            elif inv_trig_style == \"full\":\n                func = (\"ar\" if func[-1] == \"h\" else \"arc\") + func[1:]\n            elif inv_trig_style == \"power\":\n                func = func[1:]\n                inv_trig_power_case = True\n\n                # Can never fold brackets if we're raised to a power\n                if exp is not None:\n                    can_fold_brackets = False\n\n        if inv_trig_power_case:\n            if func in accepted_latex_functions:\n                name = r\"\\%s^{-1}\" % func\n            else:\n                name = r\"\\operatorname{%s}^{-1}\" % func\n        elif exp is not None:\n            func_tex = self._hprint_Function(func)\n            func_tex = self.parenthesize_super(func_tex)\n            name = r'%s^{%s}' % (func_tex, exp)\n        else:\n            name = self._hprint_Function(func)\n\n        if can_fold_brackets:\n            if func in accepted_latex_functions:\n                # Wrap argument safely to avoid parse-time conflicts\n                # with the function name itself\n                name += r\" {%s}\"\n            else:\n                name += r\"%s\"\n        else:\n            name += r\"{\\left(%s \\right)}\"\n\n        if inv_trig_power_case and exp is not None:\n            name += r\"^{%s}\" % exp\n\n        return name % \",\".join(args)",
    "sympy.sympy.printing.maple._print_Tuple": "def _print_Tuple(self, expr):\n    return self._print(list(expr))",
    "sympy.sympy.printing.maple._print_Assignment": "def _print_Assignment(self, expr):\n    lhs = self._print(expr.lhs)\n    rhs = self._print(expr.rhs)\n    return \"{lhs} := {rhs}\".format(lhs=lhs, rhs=rhs)",
    "sympy.sympy.printing.maple._print_Pow": "def _print_Pow(self, expr, **kwargs):\n    PREC = precedence(expr)\n    if equal_valued(expr.exp, -1):\n        return '1/%s' % (self.parenthesize(expr.base, PREC))\n    elif equal_valued(expr.exp, 0.5):\n        return 'sqrt(%s)' % self._print(expr.base)\n    elif equal_valued(expr.exp, -0.5):\n        return '1/sqrt(%s)' % self._print(expr.base)\n    else:\n        return '{base}^{exp}'.format(\n            base=self.parenthesize(expr.base, PREC),\n            exp=self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.maple._print_Piecewise": "def _print_Piecewise(self, expr):\n    if (expr.args[-1].cond is not True) and (expr.args[-1].cond != S.BooleanTrue):\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    _coup_list = [\n        (\"{c}, {e}\".format(c=self._print(c),\n                           e=self._print(e)) if c is not True and c is not S.BooleanTrue else \"{e}\".format(\n            e=self._print(e)))\n        for e, c in expr.args]\n    _inbrace = ', '.join(_coup_list)\n    return 'piecewise({_inbrace})'.format(_inbrace=_inbrace)",
    "sympy.sympy.printing.maple._print_Rational": "def _print_Rational(self, expr):\n    p, q = int(expr.p), int(expr.q)\n    return \"{p}/{q}\".format(p=str(p), q=str(q))",
    "sympy.sympy.printing.maple._print_Relational": "def _print_Relational(self, expr):\n    PREC=precedence(expr)\n    lhs_code = self.parenthesize(expr.lhs, PREC)\n    rhs_code = self.parenthesize(expr.rhs, PREC)\n    op = expr.rel_op\n    if op in spec_relational_ops:\n        op = spec_relational_ops[op]\n    return \"{lhs} {rel_op} {rhs}\".format(lhs=lhs_code, rel_op=op, rhs=rhs_code)",
    "sympy.sympy.printing.maple._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-infinity'",
    "sympy.sympy.printing.maple._print_Infinity": "def _print_Infinity(self, expr):\n    return 'infinity'",
    "sympy.sympy.printing.maple._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return \"true\"",
    "sympy.sympy.printing.maple._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return \"false\"",
    "sympy.sympy.printing.maple._print_NaN": "def _print_NaN(self, expr):\n    return 'undefined'",
    "sympy.sympy.printing.maple._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return \"{parent}[{i_maple}, {j_maple}]\".format(\n        parent=self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True),\n        i_maple=self._print(expr.i + 1),\n        j_maple=self._print(expr.j + 1))",
    "sympy.sympy.printing.maple._print_MatrixBase": "def _print_MatrixBase(self, expr):\n    return self._get_matrix(expr, sparse=False)",
    "sympy.sympy.printing.maple._print_SparseRepMatrix": "def _print_SparseRepMatrix(self, expr):\n    return self._get_matrix(expr, sparse=True)",
    "sympy.sympy.printing.maple._print_Identity": "def _print_Identity(self, expr):\n    if isinstance(expr.rows, (Integer, IntegerConstant)):\n        return self._print(sympy.SparseMatrix(expr))\n    else:\n        return \"Matrix({var_size}, shape = identity)\".format(var_size=self._print(expr.rows))",
    "sympy.sympy.printing.maple._print_MatMul": "def _print_MatMul(self, expr):\n    PREC=precedence(expr)\n    _fact_list = list(expr.args)\n    _const = None\n    if not isinstance(_fact_list[0], (sympy.MatrixBase, sympy.MatrixExpr,\n                                      sympy.MatrixSlice, sympy.MatrixSymbol)):\n        _const, _fact_list = _fact_list[0], _fact_list[1:]\n\n    if _const is None or _const == 1:\n        return '.'.join(self.parenthesize(_m, PREC) for _m in _fact_list)\n    else:\n        return '{c}*{m}'.format(c=_const, m='.'.join(self.parenthesize(_m, PREC) for _m in _fact_list))",
    "sympy.sympy.printing.maple._print_MatPow": "def _print_MatPow(self, expr):\n    # This function requires LinearAlgebra Function in Maple\n    return 'MatrixPower({A}, {n})'.format(A=self._print(expr.base), n=self._print(expr.exp))",
    "sympy.sympy.printing.maple._print_HadamardProduct": "def _print_HadamardProduct(self, expr):\n    PREC = precedence(expr)\n    _fact_list = list(expr.args)\n    return '*'.join(self.parenthesize(_m, PREC) for _m in _fact_list)",
    "sympy.sympy.printing.maple._print_Derivative": "def _print_Derivative(self, expr):\n    _f, (_var, _order) = expr.args\n\n    if _order != 1:\n        _second_arg = '{var}${order}'.format(var=self._print(_var),\n                                             order=self._print(_order))\n    else:\n        _second_arg = '{var}'.format(var=self._print(_var))\n    return 'diff({func_expr}, {sec_arg})'.format(func_expr=self._print(_f), sec_arg=_second_arg)",
    "sympy.sympy.printing.mathematica._print_Pow": "def _print_Pow(self, expr):\n    PREC = precedence(expr)\n    return '%s^%s' % (self.parenthesize(expr.base, PREC),\n                      self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.mathematica._print_Mul": "def _print_Mul(self, expr):\n    PREC = precedence(expr)\n    c, nc = expr.args_cnc()\n    res = super()._print_Mul(expr.func(*c))\n    if nc:\n        res += '*'\n        res += '**'.join(self.parenthesize(a, PREC) for a in nc)\n    return res",
    "sympy.sympy.printing.mathematica._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.mathematica._print_Zero": "def _print_Zero(self, expr):\n    return '0'",
    "sympy.sympy.printing.mathematica._print_One": "def _print_One(self, expr):\n    return '1'",
    "sympy.sympy.printing.mathematica._print_NegativeOne": "def _print_NegativeOne(self, expr):\n    return '-1'",
    "sympy.sympy.printing.mathematica._print_Half": "def _print_Half(self, expr):\n    return '1/2'",
    "sympy.sympy.printing.mathematica._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return 'I'",
    "sympy.sympy.printing.mathematica._print_Infinity": "def _print_Infinity(self, expr):\n    return 'Infinity'",
    "sympy.sympy.printing.mathematica._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-Infinity'",
    "sympy.sympy.printing.mathematica._print_ComplexInfinity": "def _print_ComplexInfinity(self, expr):\n    return 'ComplexInfinity'",
    "sympy.sympy.printing.mathematica._print_NaN": "def _print_NaN(self, expr):\n    return 'Indeterminate'",
    "sympy.sympy.printing.mathematica._print_Exp1": "def _print_Exp1(self, expr):\n    return 'E'",
    "sympy.sympy.printing.mathematica._print_Pi": "def _print_Pi(self, expr):\n    return 'Pi'",
    "sympy.sympy.printing.mathematica._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    return 'GoldenRatio'",
    "sympy.sympy.printing.mathematica._print_TribonacciConstant": "def _print_TribonacciConstant(self, expr):\n    expanded = expr.expand(func=True)\n    PREC = precedence(expr)\n    return self.parenthesize(expanded, PREC)",
    "sympy.sympy.printing.mathematica._print_EulerGamma": "def _print_EulerGamma(self, expr):\n    return 'EulerGamma'",
    "sympy.sympy.printing.mathematica._print_Catalan": "def _print_Catalan(self, expr):\n    return 'Catalan'",
    "sympy.sympy.printing.mathematica._print_list": "def _print_list(self, expr):\n    return '{' + ', '.join(self.doprint(a) for a in expr) + '}'",
    "sympy.sympy.printing.mathematica._print_ImmutableDenseMatrix": "def _print_ImmutableDenseMatrix(self, expr):\n    return self.doprint(expr.tolist())",
    "sympy.sympy.printing.mathematica._print_ImmutableSparseMatrix": "def _print_ImmutableSparseMatrix(self, expr):\n\n    def print_rule(pos, val):\n        return '{} -> {}'.format(\n        self.doprint((pos[0]+1, pos[1]+1)), self.doprint(val))\n\n    def print_data():\n        items = sorted(expr.todok().items(), key=default_sort_key)\n        return '{' + \\\n            ', '.join(print_rule(k, v) for k, v in items) + \\\n            '}'\n\n    def print_dims():\n        return self.doprint(expr.shape)\n\n    return 'SparseArray[{}, {}]'.format(print_data(), print_dims())",
    "sympy.sympy.printing.mathematica._print_ImmutableDenseNDimArray": "def _print_ImmutableDenseNDimArray(self, expr):\n    return self.doprint(expr.tolist())",
    "sympy.sympy.printing.mathematica._print_ImmutableSparseNDimArray": "def _print_ImmutableSparseNDimArray(self, expr):\n    def print_string_list(string_list):\n        return '{' + ', '.join(a for a in string_list) + '}'\n\n    def to_mathematica_index(*args):\n        \"\"\"Helper function to change Python style indexing to\n        Pathematica indexing.\n\n        Python indexing (0, 1 ... n-1)\n        -> Mathematica indexing (1, 2 ... n)\n        \"\"\"\n        return tuple(i + 1 for i in args)\n\n    def print_rule(pos, val):\n        \"\"\"Helper function to print a rule of Mathematica\"\"\"\n        return '{} -> {}'.format(self.doprint(pos), self.doprint(val))\n\n    def print_data():\n        \"\"\"Helper function to print data part of Mathematica\n        sparse array.\n\n        It uses the fourth notation ``SparseArray[data,{d1,d2,...}]``\n        from\n        https://reference.wolfram.com/language/ref/SparseArray.html\n\n        ``data`` must be formatted with rule.\n        \"\"\"\n        return print_string_list(\n            [print_rule(\n                to_mathematica_index(*(expr._get_tuple_index(key))),\n                value)\n            for key, value in sorted(expr._sparse_array.items())]\n        )\n\n    def print_dims():\n        \"\"\"Helper function to print dimensions part of Mathematica\n        sparse array.\n\n        It uses the fourth notation ``SparseArray[data,{d1,d2,...}]``\n        from\n        https://reference.wolfram.com/language/ref/SparseArray.html\n        \"\"\"\n        return self.doprint(expr.shape)\n\n    return 'SparseArray[{}, {}]'.format(print_data(), print_dims())",
    "sympy.sympy.printing.mathematica._print_Function": "def _print_Function(self, expr):\n    if expr.func.__name__ in self.known_functions:\n        cond_mfunc = self.known_functions[expr.func.__name__]\n        for cond, mfunc in cond_mfunc:\n            if cond(*expr.args):\n                return \"%s[%s]\" % (mfunc, self.stringify(expr.args, \", \"))\n    elif expr.func.__name__ in self._rewriteable_functions:\n        # Simple rewrite to supported function possible\n        target_f, required_fs = self._rewriteable_functions[expr.func.__name__]\n        if self._can_print(target_f) and all(self._can_print(f) for f in required_fs):\n            return self._print(expr.rewrite(target_f))\n    return expr.func.__name__ + \"[%s]\" % self.stringify(expr.args, \", \")",
    "sympy.sympy.printing.mathematica._print_LambertW": "def _print_LambertW(self, expr):\n    if len(expr.args) == 1:\n        return \"ProductLog[{}]\".format(self._print(expr.args[0]))\n    return \"ProductLog[{}, {}]\".format(\n        self._print(expr.args[1]), self._print(expr.args[0]))",
    "sympy.sympy.printing.mathematica._print_atan2": "def _print_atan2(self, expr):\n    return \"ArcTan[{}, {}]\".format(\n        self._print(expr.args[1]), self._print(expr.args[0]))",
    "sympy.sympy.printing.mathematica._print_Integral": "def _print_Integral(self, expr):\n    if len(expr.variables) == 1 and not expr.limits[0][1:]:\n        args = [expr.args[0], expr.variables[0]]\n    else:\n        args = expr.args\n    return \"Hold[Integrate[\" + ', '.join(self.doprint(a) for a in args) + \"]]\"",
    "sympy.sympy.printing.mathematica._print_Sum": "def _print_Sum(self, expr):\n    return \"Hold[Sum[\" + ', '.join(self.doprint(a) for a in expr.args) + \"]]\"",
    "sympy.sympy.printing.mathematica._print_Derivative": "def _print_Derivative(self, expr):\n    dexpr = expr.expr\n    dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]\n    return \"Hold[D[\" + ', '.join(self.doprint(a) for a in [dexpr] + dvars) + \"]]\"",
    "sympy.sympy.printing.mathml._print_MatrixSymbol": "def _print_MatrixSymbol(self, sym):\n    return self._print_Symbol(sym,\n                              style=self._settings['mat_symbol_style'])",
    "sympy.sympy.printing.mathml._print_conjugate": "def _print_conjugate(self, expr):\n    enc = self.dom.createElement('menclose')\n    enc.setAttribute('notation', 'top')\n    enc.appendChild(self._print(expr.args[0]))\n    return enc",
    "sympy.sympy.printing.mathml._print_factorial": "def _print_factorial(self, expr):\n    return self._print_operator_after('!', expr.args[0])",
    "sympy.sympy.printing.mathml._print_factorial2": "def _print_factorial2(self, expr):\n    return self._print_operator_after('!!', expr.args[0])",
    "sympy.sympy.printing.mathml._print_binomial": "def _print_binomial(self, expr):\n    frac = self.dom.createElement('mfrac')\n    frac.setAttribute('linethickness', '0')\n    frac.appendChild(self._print(expr.args[0]))\n    frac.appendChild(self._print(expr.args[1]))\n    brac = self.dom.createElement('mrow')\n    brac.appendChild(self._l_paren())\n    brac.appendChild(frac)\n    brac.appendChild(self._r_paren())\n    return brac",
    "sympy.sympy.printing.mathml._print_Pow": "def _print_Pow(self, e):\n    # Here we use root instead of power if the exponent is the reciprocal\n    # of an integer\n    if (self._settings['root_notation'] and e.exp.is_Rational\n            and e.exp.p == 1):\n        x = self.dom.createElement('apply')\n        x.appendChild(self.dom.createElement('root'))\n        if e.exp.q != 2:\n            xmldeg = self.dom.createElement('degree')\n            xmlcn = self.dom.createElement('cn')\n            xmlcn.appendChild(self.dom.createTextNode(str(e.exp.q)))\n            xmldeg.appendChild(xmlcn)\n            x.appendChild(xmldeg)\n        x.appendChild(self._print(e.base))\n        return x\n\n    x = self.dom.createElement('apply')\n    x_1 = self.dom.createElement(self.mathml_tag(e))\n    x.appendChild(x_1)\n    x.appendChild(self._print(e.base))\n    x.appendChild(self._print(e.exp))\n    return x",
    "sympy.sympy.printing.mathml._print_AccumulationBounds": "def _print_AccumulationBounds(self, i):\n    left = self.dom.createElement('mo')\n    left.appendChild(self.dom.createTextNode('\\u27e8'))\n    right = self.dom.createElement('mo')\n    right.appendChild(self.dom.createTextNode('\\u27e9'))\n    brac = self.dom.createElement('mrow')\n    brac.appendChild(left)\n    brac.appendChild(self._print(i.min))\n    brac.appendChild(self._comma())\n    brac.appendChild(self._print(i.max))\n    brac.appendChild(right)\n    return brac",
    "sympy.sympy.printing.mathml._print_Derivative": "def _print_Derivative(self, e):\n    x = self.dom.createElement('apply')\n    diff_symbol = self.mathml_tag(e)\n    if requires_partial(e.expr):\n        diff_symbol = 'partialdiff'\n    x.appendChild(self.dom.createElement(diff_symbol))\n    x_1 = self.dom.createElement('bvar')\n\n    for sym, times in reversed(e.variable_count):\n        x_1.appendChild(self._print(sym))\n        if times > 1:\n            degree = self.dom.createElement('degree')\n            degree.appendChild(self._print(sympify(times)))\n            x_1.appendChild(degree)\n\n    x.appendChild(x_1)\n    x.appendChild(self._print(e.expr))\n    return x",
    "sympy.sympy.printing.mathml._print_Function": "def _print_Function(self, e):\n    x = self.dom.createElement(\"apply\")\n    x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n    for arg in e.args:\n        x.appendChild(self._print(arg))\n    return x",
    "sympy.sympy.printing.mathml._print_Float": "def _print_Float(self, e):\n    x = self.dom.createElement(self.mathml_tag(e))\n    repr_e = mlib_to_str(e._mpf_, repr_dps(e._prec))\n    x.appendChild(self.dom.createTextNode(repr_e))\n    return x",
    "sympy.sympy.printing.mathml._print_polylog": "def _print_polylog(self, expr):\n    mrow = self.dom.createElement('mrow')\n    m = self.dom.createElement('msub')\n\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode('Li'))\n    m.appendChild(mi)\n    m.appendChild(self._print(expr.args[0]))\n    mrow.appendChild(m)\n    brac = self.dom.createElement('mrow')\n    brac.appendChild(self._l_paren())\n    brac.appendChild(self._print(expr.args[1]))\n    brac.appendChild(self._r_paren())\n    mrow.appendChild(brac)\n    return mrow",
    "sympy.sympy.printing.mathml._print_Basic": "def _print_Basic(self, e):\n    x = self.dom.createElement(self.mathml_tag(e))\n    for arg in e.args:\n        x.appendChild(self._print(arg))\n    return x",
    "sympy.sympy.printing.mathml._print_Tuple": "def _print_Tuple(self, e):\n    return self._paren_comma_separated(*e.args)",
    "sympy.sympy.printing.mathml._print_Interval": "def _print_Interval(self, i):\n    right = self.dom.createElement('mo')\n    if i.right_open:\n        right.appendChild(self.dom.createTextNode(')'))\n    else:\n        right.appendChild(self.dom.createTextNode(']'))\n    left = self.dom.createElement('mo')\n    if i.left_open:\n        left.appendChild(self.dom.createTextNode('('))\n    else:\n        left.appendChild(self.dom.createTextNode('['))\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(left)\n    mrow.appendChild(self._print(i.start))\n    mrow.appendChild(self._comma())\n    mrow.appendChild(self._print(i.end))\n    mrow.appendChild(right)\n    return mrow",
    "sympy.sympy.printing.mathml._print_Abs": "def _print_Abs(self, expr, exp=None):\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(self._bar())\n    mrow.appendChild(self._print(expr.args[0]))\n    mrow.appendChild(self._bar())\n    return mrow",
    "sympy.sympy.printing.mathml._print_re": "def _print_re(self, expr, exp=None):\n    return self._print_re_im('\\u211C', expr.args[0])",
    "sympy.sympy.printing.mathml._print_im": "def _print_im(self, expr, exp=None):\n    return self._print_re_im('\\u2111', expr.args[0])",
    "sympy.sympy.printing.mathml._print_AssocOp": "def _print_AssocOp(self, e):\n    x = self.dom.createElement('apply')\n    x_1 = self.dom.createElement(self.mathml_tag(e))\n    x.appendChild(x_1)\n    for arg in e.args:\n        x.appendChild(self._print(arg))\n    return x",
    "sympy.sympy.printing.mathml._print_Union": "def _print_Union(self, expr):\n    prec = PRECEDENCE_TRADITIONAL['Union']\n    return self._print_SetOp(expr, '&#x222A;', prec)",
    "sympy.sympy.printing.mathml._print_Intersection": "def _print_Intersection(self, expr):\n    prec = PRECEDENCE_TRADITIONAL['Intersection']\n    return self._print_SetOp(expr, '&#x2229;', prec)",
    "sympy.sympy.printing.mathml._print_Complement": "def _print_Complement(self, e):\n    x = self.dom.createElement('apply')\n    x.appendChild(self.dom.createElement('setdiff'))\n    for arg in e.args:\n        x.appendChild(self._print(arg))\n    return x",
    "sympy.sympy.printing.mathml._print_SymmetricDifference": "def _print_SymmetricDifference(self, expr):\n    prec = PRECEDENCE_TRADITIONAL['SymmetricDifference']\n    return self._print_SetOp(expr, '&#x2206;', prec)",
    "sympy.sympy.printing.mathml._print_ProductSet": "def _print_ProductSet(self, e):\n    x = self.dom.createElement('apply')\n    x.appendChild(self.dom.createElement('cartesianproduct'))\n    for arg in e.args:\n        x.appendChild(self._print(arg))\n    return x",
    "sympy.sympy.printing.mathml._print_FiniteSet": "def _print_FiniteSet(self, e):\n    x = self.dom.createElement('set')\n    for arg in e.args:\n        x.appendChild(self._print(arg))\n    return x",
    "sympy.sympy.printing.mathml._print_set": "def _print_set(self, s):\n    items = sorted(s, key=default_sort_key)\n    brac = self.dom.createElement('mrow')\n    brac.appendChild(self._l_brace())\n    for i, item in enumerate(items):\n        if i:\n            brac.appendChild(self._comma())\n        brac.appendChild(self._print(item))\n    brac.appendChild(self._r_brace())\n    return brac",
    "sympy.sympy.printing.mathml._print_BasisDependent": "def _print_BasisDependent(self, expr):\n    from sympy.vector import Vector\n\n    if expr == expr.zero:\n        # Not clear if this is ever called\n        return self._print(expr.zero)\n    if isinstance(expr, Vector):\n        items = expr.separate().items()\n    else:\n        items = [(0, expr)]\n\n    mrow = self.dom.createElement('mrow')\n    for system, vect in items:\n        inneritems = list(vect.components.items())\n        inneritems.sort(key = lambda x:x[0].__str__())\n        for i, (k, v) in enumerate(inneritems):\n            if v == 1:\n                if i: # No + for first item\n                    mo = self.dom.createElement('mo')\n                    mo.appendChild(self.dom.createTextNode('+'))\n                    mrow.appendChild(mo)\n                mrow.appendChild(self._print(k))\n            elif v == -1:\n                mo = self.dom.createElement('mo')\n                mo.appendChild(self.dom.createTextNode('-'))\n                mrow.appendChild(mo)\n                mrow.appendChild(self._print(k))\n            else:\n                if i: # No + for first item\n                    mo = self.dom.createElement('mo')\n                    mo.appendChild(self.dom.createTextNode('+'))\n                    mrow.appendChild(mo)\n                mbrac = self.dom.createElement('mrow')\n                mbrac.appendChild(self._l_paren())\n                mbrac.appendChild(self._print(v))\n                mbrac.appendChild(self._r_paren())\n                mrow.appendChild(mbrac)\n                mo = self.dom.createElement('mo')\n                mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))\n                mrow.appendChild(mo)\n                mrow.appendChild(self._print(k))\n    return mrow",
    "sympy.sympy.printing.mathml._print_And": "def _print_And(self, expr):\n    args = sorted(expr.args, key=default_sort_key)\n    return self._print_LogOp(args, '&#x2227;')",
    "sympy.sympy.printing.mathml._print_Or": "def _print_Or(self, expr):\n    args = sorted(expr.args, key=default_sort_key)\n    return self._print_LogOp(args, '&#x2228;')",
    "sympy.sympy.printing.mathml._print_Xor": "def _print_Xor(self, expr):\n    args = sorted(expr.args, key=default_sort_key)\n    return self._print_LogOp(args, '&#x22BB;')",
    "sympy.sympy.printing.mathml._print_Implies": "def _print_Implies(self, expr):\n    return self._print_LogOp(expr.args, '&#x21D2;')",
    "sympy.sympy.printing.mathml._print_Equivalent": "def _print_Equivalent(self, expr):\n    args = sorted(expr.args, key=default_sort_key)\n    return self._print_LogOp(args, '&#x21D4;')",
    "sympy.sympy.printing.mathml._print_Not": "def _print_Not(self, e):\n    mrow = self.dom.createElement('mrow')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#xAC;'))\n    mrow.appendChild(mo)\n    if (e.args[0].is_Boolean):\n        x = self.dom.createElement('mrow')\n        x.appendChild(self._l_paren())\n        x.appendChild(self._print(e.args[0]))\n        x.appendChild(self._r_paren())\n    else:\n        x = self._print(e.args[0])\n    mrow.appendChild(x)\n    return mrow",
    "sympy.sympy.printing.mathml._print_bool": "def _print_bool(self, e):\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n    return mi",
    "sympy.sympy.printing.mathml._print_NoneType": "def _print_NoneType(self, e):\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n    return mi",
    "sympy.sympy.printing.mathml._print_Range": "def _print_Range(self, s):\n    dots = \"\\u2026\"\n    if s.start.is_infinite and s.stop.is_infinite:\n        if s.step.is_positive:\n            printset = dots, -1, 0, 1, dots\n        else:\n            printset = dots, 1, 0, -1, dots\n    elif s.start.is_infinite:\n        printset = dots, s[-1] - s.step, s[-1]\n    elif s.stop.is_infinite:\n        it = iter(s)\n        printset = next(it), next(it), dots\n    elif len(s) > 4:\n        it = iter(s)\n        printset = next(it), next(it), dots, s[-1]\n    else:\n        printset = tuple(s)\n    brac = self.dom.createElement('mrow')\n    brac.appendChild(self._l_brace())\n    for i, el in enumerate(printset):\n        if i:\n            brac.appendChild(self._comma())\n        if el == dots:\n            mi = self.dom.createElement('mi')\n            mi.appendChild(self.dom.createTextNode(dots))\n            brac.appendChild(mi)\n        else:\n            brac.appendChild(self._print(el))\n    brac.appendChild(self._r_brace())\n    return brac",
    "sympy.sympy.printing.mathml._hprint_variadic_function": "def _hprint_variadic_function(self, expr):\n    args = sorted(expr.args, key=default_sort_key)\n    mrow = self.dom.createElement('mrow')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode((str(expr.func)).lower()))\n    mrow.appendChild(mo)\n    mrow.appendChild(self._paren_comma_separated(*args))\n    return mrow",
    "sympy.sympy.printing.mathml._print_exp": "def _print_exp(self, expr):\n    msup = self.dom.createElement('msup')\n    msup.appendChild(self._print_Exp1(None))\n    msup.appendChild(self._print(expr.args[0]))\n    return msup",
    "sympy.sympy.printing.mathml._print_Relational": "def _print_Relational(self, e):\n    x = self.dom.createElement('apply')\n    x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n    x.appendChild(self._print(e.lhs))\n    x.appendChild(self._print(e.rhs))\n    return x",
    "sympy.sympy.printing.mathml._print_int": "def _print_int(self, p):\n    dom_element = self.dom.createElement(self.mathml_tag(p))\n    dom_element.appendChild(self.dom.createTextNode(str(p)))\n    return dom_element",
    "sympy.sympy.printing.mathml._print_BaseScalar": "def _print_BaseScalar(self, e):\n    msub = self.dom.createElement('msub')\n    index, system = e._id\n    mi = self.dom.createElement('mi')\n    mi.setAttribute('mathvariant', 'bold')\n    mi.appendChild(self.dom.createTextNode(system._variable_names[index]))\n    msub.appendChild(mi)\n    mi = self.dom.createElement('mi')\n    mi.setAttribute('mathvariant', 'bold')\n    mi.appendChild(self.dom.createTextNode(system._name))\n    msub.appendChild(mi)\n    return msub",
    "sympy.sympy.printing.mathml._print_BaseVector": "def _print_BaseVector(self, e):\n    msub = self.dom.createElement('msub')\n    index, system = e._id\n    mover = self.dom.createElement('mover')\n    mi = self.dom.createElement('mi')\n    mi.setAttribute('mathvariant', 'bold')\n    mi.appendChild(self.dom.createTextNode(system._vector_names[index]))\n    mover.appendChild(mi)\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('^'))\n    mover.appendChild(mo)\n    msub.appendChild(mover)\n    mi = self.dom.createElement('mi')\n    mi.setAttribute('mathvariant', 'bold')\n    mi.appendChild(self.dom.createTextNode(system._name))\n    msub.appendChild(mi)\n    return msub",
    "sympy.sympy.printing.mathml._print_Mul": "def _print_Mul(self, expr):\n\n    def multiply(expr, mrow):\n        from sympy.simplify import fraction\n        numer, denom = fraction(expr)\n        if denom is not S.One:\n            frac = self.dom.createElement('mfrac')\n            if self._settings[\"fold_short_frac\"] and len(str(expr)) < 7:\n                frac.setAttribute('bevelled', 'true')\n            xnum = self._print(numer)\n            xden = self._print(denom)\n            frac.appendChild(xnum)\n            frac.appendChild(xden)\n            mrow.appendChild(frac)\n            return mrow\n\n        coeff, terms = expr.as_coeff_mul()\n        if coeff is S.One and len(terms) == 1:\n            mrow.appendChild(self._print(terms[0]))\n            return mrow\n        if self.order != 'old':\n            terms = Mul._from_args(terms).as_ordered_factors()\n\n        if coeff != 1:\n            x = self._print(coeff)\n            y = self.dom.createElement('mo')\n            y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n            mrow.appendChild(x)\n            mrow.appendChild(y)\n        for term in terms:\n            mrow.appendChild(self.parenthesize(term, PRECEDENCE['Mul']))\n            if not term == terms[-1]:\n                y = self.dom.createElement('mo')\n                y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n                mrow.appendChild(y)\n        return mrow\n    mrow = self.dom.createElement('mrow')\n    if expr.could_extract_minus_sign():\n        x = self.dom.createElement('mo')\n        x.appendChild(self.dom.createTextNode('-'))\n        mrow.appendChild(x)\n        mrow = multiply(-expr, mrow)\n    else:\n        mrow = multiply(expr, mrow)\n\n    return mrow",
    "sympy.sympy.printing.mathml._print_Cross": "def _print_Cross(self, expr):\n    mrow = self.dom.createElement('mrow')\n    vec1 = expr._expr1\n    vec2 = expr._expr2\n    mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#xD7;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Curl": "def _print_Curl(self, expr):\n    mrow = self.dom.createElement('mrow')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x2207;'))\n    mrow.appendChild(mo)\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#xD7;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Divergence": "def _print_Divergence(self, expr):\n    mrow = self.dom.createElement('mrow')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x2207;'))\n    mrow.appendChild(mo)\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#xB7;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Dot": "def _print_Dot(self, expr):\n    mrow = self.dom.createElement('mrow')\n    vec1 = expr._expr1\n    vec2 = expr._expr2\n    mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#xB7;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Gradient": "def _print_Gradient(self, expr):\n    mrow = self.dom.createElement('mrow')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x2207;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Laplacian": "def _print_Laplacian(self, expr):\n    mrow = self.dom.createElement('mrow')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x2206;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Integers": "def _print_Integers(self, e):\n    x = self.dom.createElement('mi')\n    x.setAttribute('mathvariant', 'normal')\n    x.appendChild(self.dom.createTextNode('&#x2124;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Complexes": "def _print_Complexes(self, e):\n    x = self.dom.createElement('mi')\n    x.setAttribute('mathvariant', 'normal')\n    x.appendChild(self.dom.createTextNode('&#x2102;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Reals": "def _print_Reals(self, e):\n    x = self.dom.createElement('mi')\n    x.setAttribute('mathvariant', 'normal')\n    x.appendChild(self.dom.createTextNode('&#x211D;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Naturals": "def _print_Naturals(self, e):\n    x = self.dom.createElement('mi')\n    x.setAttribute('mathvariant', 'normal')\n    x.appendChild(self.dom.createTextNode('&#x2115;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Naturals0": "def _print_Naturals0(self, e):\n    sub = self.dom.createElement('msub')\n    x = self.dom.createElement('mi')\n    x.setAttribute('mathvariant', 'normal')\n    x.appendChild(self.dom.createTextNode('&#x2115;'))\n    sub.appendChild(x)\n    sub.appendChild(self._print(S.Zero))\n    return sub",
    "sympy.sympy.printing.mathml._print_SingularityFunction": "def _print_SingularityFunction(self, expr):\n    shift = expr.args[0] - expr.args[1]\n    power = expr.args[2]\n    left = self.dom.createElement('mo')\n    left.appendChild(self.dom.createTextNode('\\u27e8'))\n    right = self.dom.createElement('mo')\n    right.appendChild(self.dom.createTextNode('\\u27e9'))\n    brac = self.dom.createElement('mrow')\n    brac.appendChild(left)\n    brac.appendChild(self._print(shift))\n    brac.appendChild(right)\n    sup = self.dom.createElement('msup')\n    sup.appendChild(brac)\n    sup.appendChild(self._print(power))\n    return sup",
    "sympy.sympy.printing.mathml._print_NaN": "def _print_NaN(self, e):\n    return self.dom.createElement('notanumber')",
    "sympy.sympy.printing.mathml._print_bernoulli": "def _print_bernoulli(self, e):\n    return self._print_number_function(e, 'B')",
    "sympy.sympy.printing.mathml._print_catalan": "def _print_catalan(self, e):\n    return self._print_number_function(e, 'C')",
    "sympy.sympy.printing.mathml._print_euler": "def _print_euler(self, e):\n    return self._print_number_function(e, 'E')",
    "sympy.sympy.printing.mathml._print_fibonacci": "def _print_fibonacci(self, e):\n    return self._print_number_function(e, 'F')",
    "sympy.sympy.printing.mathml._print_lucas": "def _print_lucas(self, e):\n    return self._print_number_function(e, 'L')",
    "sympy.sympy.printing.mathml._print_stieltjes": "def _print_stieltjes(self, e):\n    return self._print_number_function(e, '&#x03B3;')",
    "sympy.sympy.printing.mathml._print_tribonacci": "def _print_tribonacci(self, e):\n    return self._print_number_function(e, 'T')",
    "sympy.sympy.printing.mathml._print_ComplexInfinity": "def _print_ComplexInfinity(self, e):\n    x = self.dom.createElement('mover')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x221E;'))\n    x.appendChild(mo)\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('~'))\n    x.appendChild(mo)\n    return x",
    "sympy.sympy.printing.mathml._print_EmptySet": "def _print_EmptySet(self, e):\n    return self.dom.createElement('emptyset')",
    "sympy.sympy.printing.mathml._print_UniversalSet": "def _print_UniversalSet(self, e):\n    x = self.dom.createElement('mo')\n    x.appendChild(self.dom.createTextNode('&#x1D54C;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Adjoint": "def _print_Adjoint(self, expr):\n    from sympy.matrices import MatrixSymbol\n    mat = expr.arg\n    sup = self.dom.createElement('msup')\n    if not isinstance(mat, MatrixSymbol):\n        brac = self.dom.createElement('mrow')\n        brac.appendChild(self._l_paren())\n        brac.appendChild(self._print(mat))\n        brac.appendChild(self._r_paren())\n        sup.appendChild(brac)\n    else:\n        sup.appendChild(self._print(mat))\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x2020;'))\n    sup.appendChild(mo)\n    return sup",
    "sympy.sympy.printing.mathml._print_Transpose": "def _print_Transpose(self, expr):\n    from sympy.matrices import MatrixSymbol\n    mat = expr.arg\n    sup = self.dom.createElement('msup')\n    if not isinstance(mat, MatrixSymbol):\n        brac = self.dom.createElement('mrow')\n        brac.appendChild(self._l_paren())\n        brac.appendChild(self._print(mat))\n        brac.appendChild(self._r_paren())\n        sup.appendChild(brac)\n    else:\n        sup.appendChild(self._print(mat))\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('T'))\n    sup.appendChild(mo)\n    return sup",
    "sympy.sympy.printing.mathml._print_Inverse": "def _print_Inverse(self, expr):\n    from sympy.matrices import MatrixSymbol\n    mat = expr.arg\n    sup = self.dom.createElement('msup')\n    if not isinstance(mat, MatrixSymbol):\n        brac = self.dom.createElement('mrow')\n        brac.appendChild(self._l_paren())\n        brac.appendChild(self._print(mat))\n        brac.appendChild(self._r_paren())\n        sup.appendChild(brac)\n    else:\n        sup.appendChild(self._print(mat))\n    sup.appendChild(self._print(-1))\n    return sup",
    "sympy.sympy.printing.mathml._print_MatMul": "def _print_MatMul(self, expr):\n    from sympy.matrices.expressions.matmul import MatMul\n\n    x = self.dom.createElement('mrow')\n    args = expr.args\n    if isinstance(args[0], Mul):\n        args = args[0].as_ordered_factors() + list(args[1:])\n    else:\n        args = list(args)\n\n    if isinstance(expr, MatMul) and expr.could_extract_minus_sign():\n        if args[0] == -1:\n            args = args[1:]\n        else:\n            args[0] = -args[0]\n        mo = self.dom.createElement('mo')\n        mo.appendChild(self.dom.createTextNode('-'))\n        x.appendChild(mo)\n\n    for arg in args[:-1]:\n        x.appendChild(self.parenthesize(arg, precedence_traditional(expr),\n                                        False))\n        mo = self.dom.createElement('mo')\n        mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))\n        x.appendChild(mo)\n    x.appendChild(self.parenthesize(args[-1], precedence_traditional(expr),\n                                    False))\n    return x",
    "sympy.sympy.printing.mathml._print_MatPow": "def _print_MatPow(self, expr):\n    from sympy.matrices import MatrixSymbol\n    base, exp = expr.base, expr.exp\n    sup = self.dom.createElement('msup')\n    if not isinstance(base, MatrixSymbol):\n        brac = self.dom.createElement('mrow')\n        brac.appendChild(self._l_paren())\n        brac.appendChild(self._print(base))\n        brac.appendChild(self._r_paren())\n        sup.appendChild(brac)\n    else:\n        sup.appendChild(self._print(base))\n    sup.appendChild(self._print(exp))\n    return sup",
    "sympy.sympy.printing.mathml._print_HadamardProduct": "def _print_HadamardProduct(self, expr):\n    x = self.dom.createElement('mrow')\n    args = expr.args\n    for arg in args[:-1]:\n        x.appendChild(\n            self.parenthesize(arg, precedence_traditional(expr), False))\n        mo = self.dom.createElement('mo')\n        mo.appendChild(self.dom.createTextNode('&#x2218;'))\n        x.appendChild(mo)\n    x.appendChild(\n        self.parenthesize(args[-1], precedence_traditional(expr), False))\n    return x",
    "sympy.sympy.printing.mathml._print_ZeroMatrix": "def _print_ZeroMatrix(self, Z):\n    x = self.dom.createElement('mn')\n    x.appendChild(self.dom.createTextNode('&#x1D7D8'))\n    return x",
    "sympy.sympy.printing.mathml._print_OneMatrix": "def _print_OneMatrix(self, Z):\n    x = self.dom.createElement('mn')\n    x.appendChild(self.dom.createTextNode('&#x1D7D9'))\n    return x",
    "sympy.sympy.printing.mathml._print_Identity": "def _print_Identity(self, I):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x1D540;'))\n    return x",
    "sympy.sympy.printing.mathml._print_floor": "def _print_floor(self, e):\n    left = self.dom.createElement('mo')\n    left.appendChild(self.dom.createTextNode('\\u230A'))\n    right = self.dom.createElement('mo')\n    right.appendChild(self.dom.createTextNode('\\u230B'))\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(left)\n    mrow.appendChild(self._print(e.args[0]))\n    mrow.appendChild(right)\n    return mrow",
    "sympy.sympy.printing.mathml._print_ceiling": "def _print_ceiling(self, e):\n    left = self.dom.createElement('mo')\n    left.appendChild(self.dom.createTextNode('\\u2308'))\n    right = self.dom.createElement('mo')\n    right.appendChild(self.dom.createTextNode('\\u2309'))\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(left)\n    mrow.appendChild(self._print(e.args[0]))\n    mrow.appendChild(right)\n    return mrow",
    "sympy.sympy.printing.mathml._print_Lambda": "def _print_Lambda(self, e):\n    # MathML reference for the lambda element:\n    # https://www.w3.org/TR/MathML2/chapter4.html#id.4.2.1.7\n    x = self.dom.createElement(self.mathml_tag(e))\n    for arg in e.signature:\n        x_1 = self.dom.createElement('bvar')\n        x_1.appendChild(self._print(arg))\n        x.appendChild(x_1)\n    x.appendChild(self._print(e.expr))\n    return x",
    "sympy.sympy.printing.mathml._print_tuple": "def _print_tuple(self, e):\n    return self._paren_comma_separated(*e)",
    "sympy.sympy.printing.mathml._print_IndexedBase": "def _print_IndexedBase(self, e):\n    return self._print(e.label)",
    "sympy.sympy.printing.mathml._print_Indexed": "def _print_Indexed(self, e):\n    x = self.dom.createElement('msub')\n    x.appendChild(self._print(e.base))\n    if len(e.indices) == 1:\n        x.appendChild(self._print(e.indices[0]))\n        return x\n    x.appendChild(self._print(e.indices))\n    return x",
    "sympy.sympy.printing.mathml._print_Add": "def _print_Add(self, expr, order=None):\n    mrow = self.dom.createElement('mrow')\n    args = self._as_ordered_terms(expr, order=order)\n    mrow.appendChild(self._print(args[0]))\n    for arg in args[1:]:\n        if arg.could_extract_minus_sign():\n            # use minus\n            x = self.dom.createElement('mo')\n            x.appendChild(self.dom.createTextNode('-'))\n            y = self._print(-arg)\n            # invert expression since this is now minused\n        else:\n            x = self.dom.createElement('mo')\n            x.appendChild(self.dom.createTextNode('+'))\n            y = self._print(arg)\n        mrow.appendChild(x)\n        mrow.appendChild(y)\n\n    return mrow",
    "sympy.sympy.printing.mathml._print_MatrixElement": "def _print_MatrixElement(self, e):\n    x = self.dom.createElement('msub')\n    x.appendChild(self.parenthesize(e.parent, PRECEDENCE[\"Atom\"], strict = True))\n    brac = self.dom.createElement('mrow')\n    for i, arg in enumerate(e.indices):\n        if i:\n            brac.appendChild(self._comma())\n        brac.appendChild(self._print(arg))\n    x.appendChild(brac)\n    return x",
    "sympy.sympy.printing.mathml._print_elliptic_f": "def _print_elliptic_f(self, e):\n    x = self.dom.createElement('mrow')\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode('&#x1d5a5;'))\n    x.appendChild(mi)\n    x.appendChild(self._paren_bar_separated(*e.args))\n    return x",
    "sympy.sympy.printing.mathml._print_elliptic_e": "def _print_elliptic_e(self, e):\n    x = self.dom.createElement('mrow')\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode('&#x1d5a4;'))\n    x.appendChild(mi)\n    x.appendChild(self._paren_bar_separated(*e.args))\n    return x",
    "sympy.sympy.printing.mathml._print_elliptic_pi": "def _print_elliptic_pi(self, e):\n    x = self.dom.createElement('mrow')\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode('&#x1d6f1;'))\n    x.appendChild(mi)\n    y = self.dom.createElement('mrow')\n    y.appendChild(self._l_paren())\n    if len(e.args) == 2:\n        n, m = e.args\n        y.appendChild(self._print(n))\n        y.appendChild(self._bar())\n        y.appendChild(self._print(m))\n    else:\n        n, m, z = e.args\n        y.appendChild(self._print(n))\n        y.appendChild(self._semicolon())\n        y.appendChild(self._print(m))\n        y.appendChild(self._bar())\n        y.appendChild(self._print(z))\n    y.appendChild(self._r_paren())\n    x.appendChild(y)\n    return x",
    "sympy.sympy.printing.mathml._print_Ei": "def _print_Ei(self, e):\n    x = self.dom.createElement('mrow')\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode('Ei'))\n    x.appendChild(mi)\n    x.appendChild(self._print(e.args))\n    return x",
    "sympy.sympy.printing.mathml._print_expint": "def _print_expint(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msub')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('E'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[1:]))\n    return x",
    "sympy.sympy.printing.mathml._print_jacobi": "def _print_jacobi(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msubsup')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('P'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    y.appendChild(self._print(e.args[1:3]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[3:]))\n    return x",
    "sympy.sympy.printing.mathml._print_gegenbauer": "def _print_gegenbauer(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msubsup')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('C'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    y.appendChild(self._print(e.args[1:2]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[2:]))\n    return x",
    "sympy.sympy.printing.mathml._print_chebyshevt": "def _print_chebyshevt(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msub')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('T'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[1:]))\n    return x",
    "sympy.sympy.printing.mathml._print_chebyshevu": "def _print_chebyshevu(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msub')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('U'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[1:]))\n    return x",
    "sympy.sympy.printing.mathml._print_legendre": "def _print_legendre(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msub')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('P'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[1:]))\n    return x",
    "sympy.sympy.printing.mathml._print_assoc_legendre": "def _print_assoc_legendre(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msubsup')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('P'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    y.appendChild(self._print(e.args[1:2]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[2:]))\n    return x",
    "sympy.sympy.printing.mathml._print_laguerre": "def _print_laguerre(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msub')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('L'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[1:]))\n    return x",
    "sympy.sympy.printing.mathml._print_assoc_laguerre": "def _print_assoc_laguerre(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msubsup')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('L'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    y.appendChild(self._print(e.args[1:2]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[2:]))\n    return x",
    "sympy.sympy.printing.mathml._print_hermite": "def _print_hermite(self, e):\n    x = self.dom.createElement('mrow')\n    y = self.dom.createElement('msub')\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('H'))\n    y.appendChild(mo)\n    y.appendChild(self._print(e.args[0]))\n    x.appendChild(y)\n    x.appendChild(self._print(e.args[1:]))\n    return x",
    "sympy.sympy.printing.mathml._print_Piecewise": "def _print_Piecewise(self, expr):\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    root = self.dom.createElement('piecewise')\n    for i, (e, c) in enumerate(expr.args):\n        if i == len(expr.args) - 1 and c == True:\n            piece = self.dom.createElement('otherwise')\n            piece.appendChild(self._print(e))\n        else:\n            piece = self.dom.createElement('piece')\n            piece.appendChild(self._print(e))\n            piece.appendChild(self._print(c))\n        root.appendChild(piece)\n    return root",
    "sympy.sympy.printing.mathml._print_MatrixBase": "def _print_MatrixBase(self, m):\n    table = self.dom.createElement('mtable')\n    for i in range(m.rows):\n        x = self.dom.createElement('mtr')\n        for j in range(m.cols):\n            y = self.dom.createElement('mtd')\n            y.appendChild(self._print(m[i, j]))\n            x.appendChild(y)\n        table.appendChild(x)\n    mat_delim = self._settings[\"mat_delim\"]\n    if mat_delim == '':\n        return table\n    left = self.dom.createElement('mo')\n    right = self.dom.createElement('mo')\n    if mat_delim == \"[\":\n        left.appendChild(self.dom.createTextNode(\"[\"))\n        right.appendChild(self.dom.createTextNode(\"]\"))\n    else:\n        left.appendChild(self.dom.createTextNode(\"(\"))\n        right.appendChild(self.dom.createTextNode(\")\"))\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(left)\n    mrow.appendChild(table)\n    mrow.appendChild(right)\n    return mrow",
    "sympy.sympy.printing.mathml._print_Rational": "def _print_Rational(self, e):\n    if e.q == 1:\n        # don't divide\n        return self._print(e.p)\n\n    return self._get_printed_Rational(e, self._settings[\"fold_short_frac\"])",
    "sympy.sympy.printing.mathml._print_Limit": "def _print_Limit(self, e):\n    mrow = self.dom.createElement('mrow')\n    munder = self.dom.createElement('munder')\n    mi = self.dom.createElement('mi')\n    mi.appendChild(self.dom.createTextNode('lim'))\n\n    x = self.dom.createElement('mrow')\n    x_1 = self._print(e.args[1])\n    arrow = self.dom.createElement('mo')\n    arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n    x_2 = self._print(e.args[2])\n    x.appendChild(x_1)\n    x.appendChild(arrow)\n    x.appendChild(x_2)\n\n    munder.appendChild(mi)\n    munder.appendChild(x)\n    mrow.appendChild(munder)\n    mrow.appendChild(self._print(e.args[0]))\n\n    return mrow",
    "sympy.sympy.printing.mathml._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&ImaginaryI;'))\n    return x",
    "sympy.sympy.printing.mathml._print_EulerGamma": "def _print_EulerGamma(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x3B3;'))\n    return x",
    "sympy.sympy.printing.mathml._print_GoldenRatio": "def _print_GoldenRatio(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x3A6;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Exp1": "def _print_Exp1(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&ExponentialE;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Pi": "def _print_Pi(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&pi;'))\n    return x",
    "sympy.sympy.printing.mathml._print_Infinity": "def _print_Infinity(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x221E;'))\n    return x",
    "sympy.sympy.printing.mathml._print_BooleanTrue": "def _print_BooleanTrue(self, e):\n    return self.dom.createElement('true')",
    "sympy.sympy.printing.mathml._print_BooleanFalse": "def _print_BooleanFalse(self, e):\n    return self.dom.createElement('false')",
    "sympy.sympy.printing.mathml._print_Integral": "def _print_Integral(self, expr):\n    intsymbols = {1: \"&#x222B;\", 2: \"&#x222C;\", 3: \"&#x222D;\"}\n\n    mrow = self.dom.createElement('mrow')\n    if len(expr.limits) <= 3 and all(len(lim) == 1 for lim in expr.limits):\n        # Only up to three-integral signs exists\n        mo = self.dom.createElement('mo')\n        mo.appendChild(self.dom.createTextNode(intsymbols[len(expr.limits)]))\n        mrow.appendChild(mo)\n    else:\n        # Either more than three or limits provided\n        for lim in reversed(expr.limits):\n            mo = self.dom.createElement('mo')\n            mo.appendChild(self.dom.createTextNode(intsymbols[1]))\n            if len(lim) == 1:\n                mrow.appendChild(mo)\n            if len(lim) == 2:\n                msup = self.dom.createElement('msup')\n                msup.appendChild(mo)\n                msup.appendChild(self._print(lim[1]))\n                mrow.appendChild(msup)\n            if len(lim) == 3:\n                msubsup = self.dom.createElement('msubsup')\n                msubsup.appendChild(mo)\n                msubsup.appendChild(self._print(lim[1]))\n                msubsup.appendChild(self._print(lim[2]))\n                mrow.appendChild(msubsup)\n    # print function\n    mrow.appendChild(self.parenthesize(expr.function, PRECEDENCE[\"Mul\"],\n                                       strict=True))\n    # print integration variables\n    for lim in reversed(expr.limits):\n        d = self.dom.createElement('mo')\n        d.appendChild(self.dom.createTextNode('&dd;'))\n        mrow.appendChild(d)\n        mrow.appendChild(self._print(lim[0]))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Sum": "def _print_Sum(self, e):\n    limits = list(e.limits)\n    subsup = self.dom.createElement('munderover')\n    low_elem = self._print(limits[0][1])\n    up_elem = self._print(limits[0][2])\n    summand = self.dom.createElement('mo')\n    summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n\n    low = self.dom.createElement('mrow')\n    var = self._print(limits[0][0])\n    equal = self.dom.createElement('mo')\n    equal.appendChild(self.dom.createTextNode('='))\n    low.appendChild(var)\n    low.appendChild(equal)\n    low.appendChild(low_elem)\n\n    subsup.appendChild(summand)\n    subsup.appendChild(low)\n    subsup.appendChild(up_elem)\n\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(subsup)\n    mrow.appendChild(self.parenthesize(e.function, precedence_traditional(e)))\n    return mrow",
    "sympy.sympy.printing.mathml._print_Symbol": "def _print_Symbol(self, sym, style='plain'):\n    def join(items):\n        if len(items) > 1:\n            mrow = self.dom.createElement('mrow')\n            for i, item in enumerate(items):\n                if i > 0:\n                    mo = self.dom.createElement('mo')\n                    mo.appendChild(self.dom.createTextNode(\" \"))\n                    mrow.appendChild(mo)\n                mi = self.dom.createElement('mi')\n                mi.appendChild(self.dom.createTextNode(item))\n                mrow.appendChild(mi)\n            return mrow\n        else:\n            mi = self.dom.createElement('mi')\n            mi.appendChild(self.dom.createTextNode(items[0]))\n            return mi\n\n    # translate name, supers and subs to unicode characters\n    def translate(s):\n        if s in greek_unicode:\n            return greek_unicode.get(s)\n        else:\n            return s\n\n    name, supers, subs = self._split_super_sub(sym.name)\n    name = translate(name)\n    supers = [translate(sup) for sup in supers]\n    subs = [translate(sub) for sub in subs]\n\n    mname = self.dom.createElement('mi')\n    mname.appendChild(self.dom.createTextNode(name))\n    if len(supers) == 0:\n        if len(subs) == 0:\n            x = mname\n        else:\n            x = self.dom.createElement('msub')\n            x.appendChild(mname)\n            x.appendChild(join(subs))\n    else:\n        if len(subs) == 0:\n            x = self.dom.createElement('msup')\n            x.appendChild(mname)\n            x.appendChild(join(supers))\n        else:\n            x = self.dom.createElement('msubsup')\n            x.appendChild(mname)\n            x.appendChild(join(subs))\n            x.appendChild(join(supers))\n    # Set bold font?\n    if style == 'bold':\n        x.setAttribute('mathvariant', 'bold')\n    return x",
    "sympy.sympy.printing.mathml._print_list": "def _print_list(self, seq):\n    \"\"\"MathML reference for the <list> element:\n    https://www.w3.org/TR/MathML2/chapter4.html#contm.list\"\"\"\n    dom_element = self.dom.createElement('list')\n    for item in seq:\n        dom_element.appendChild(self._print(item))\n    return dom_element",
    "sympy.sympy.printing.mathml._print_NegativeInfinity": "def _print_NegativeInfinity(self, e):\n    mrow = self.dom.createElement('mrow')\n    y = self.dom.createElement('mo')\n    y.appendChild(self.dom.createTextNode('-'))\n    x = self._print_Infinity(e)\n    mrow.appendChild(y)\n    mrow.appendChild(x)\n    return mrow",
    "sympy.sympy.printing.mathml._print_HBar": "def _print_HBar(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x210F;'))\n    return x",
    "sympy.sympy.printing.mathml._print_TribonacciConstant": "def _print_TribonacciConstant(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('TribonacciConstant'))\n    return x",
    "sympy.sympy.printing.mathml._print_Dagger": "def _print_Dagger(self, e):\n    msup = self.dom.createElement('msup')\n    msup.appendChild(self._print(e.args[0]))\n    msup.appendChild(self.dom.createTextNode('&#x2020;'))\n    return msup",
    "sympy.sympy.printing.mathml._print_Contains": "def _print_Contains(self, e):\n    mrow = self.dom.createElement('mrow')\n    mrow.appendChild(self._print(e.args[0]))\n    mo = self.dom.createElement('mo')\n    mo.appendChild(self.dom.createTextNode('&#x2208;'))\n    mrow.appendChild(mo)\n    mrow.appendChild(self._print(e.args[1]))\n    return mrow",
    "sympy.sympy.printing.mathml._print_HilbertSpace": "def _print_HilbertSpace(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x210B;'))\n    return x",
    "sympy.sympy.printing.mathml._print_ComplexSpace": "def _print_ComplexSpace(self, e):\n    msup = self.dom.createElement('msup')\n    msup.appendChild(self.dom.createTextNode('&#x1D49E;'))\n    msup.appendChild(self._print(e.args[0]))\n    return msup",
    "sympy.sympy.printing.mathml._print_FockSpace": "def _print_FockSpace(self, e):\n    x = self.dom.createElement('mi')\n    x.appendChild(self.dom.createTextNode('&#x2131;'))\n    return x",
    "sympy.sympy.printing.numpy._print_MatrixSolve": "def _print_MatrixSolve(self, expr):\n    return \"%s(%s, %s)\" % (self._module_format(self._module + '.linalg.solve'),\n                           self._print(expr.matrix),\n                           self._print(expr.vector))",
    "sympy.sympy.printing.numpy._print_ZeroMatrix": "def _print_ZeroMatrix(self, expr):\n    return '{}({})'.format(self._module_format(self._module + '.zeros'),\n        self._print(expr.shape))",
    "sympy.sympy.printing.numpy._print_OneMatrix": "def _print_OneMatrix(self, expr):\n    return '{}({})'.format(self._module_format(self._module + '.ones'),\n        self._print(expr.shape))",
    "sympy.sympy.printing.numpy._print_FunctionMatrix": "def _print_FunctionMatrix(self, expr):\n    from sympy.abc import i, j\n    lamda = expr.lamda\n    if not isinstance(lamda, Lambda):\n        lamda = Lambda((i, j), lamda(i, j))\n    return '{}(lambda {}: {}, {})'.format(self._module_format(self._module + '.fromfunction'),\n        ', '.join(self._print(arg) for arg in lamda.args[0]),\n        self._print(lamda.args[1]), self._print(expr.shape))",
    "sympy.sympy.printing.numpy._print_HadamardProduct": "def _print_HadamardProduct(self, expr):\n    func = self._module_format(self._module + '.multiply')\n    return ''.join('{}({}, '.format(func, self._print(arg)) \\\n        for arg in expr.args[:-1]) + \"{}{}\".format(self._print(expr.args[-1]),\n        ')' * (len(expr.args) - 1))",
    "sympy.sympy.printing.numpy._print_KroneckerProduct": "def _print_KroneckerProduct(self, expr):\n    func = self._module_format(self._module + '.kron')\n    return ''.join('{}({}, '.format(func, self._print(arg)) \\\n        for arg in expr.args[:-1]) + \"{}{}\".format(self._print(expr.args[-1]),\n        ')' * (len(expr.args) - 1))",
    "sympy.sympy.printing.numpy._print_Adjoint": "def _print_Adjoint(self, expr):\n    return '{}({}({}))'.format(\n        self._module_format(self._module + '.conjugate'),\n        self._module_format(self._module + '.transpose'),\n        self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_DiagonalOf": "def _print_DiagonalOf(self, expr):\n    vect = '{}({})'.format(\n        self._module_format(self._module + '.diag'),\n        self._print(expr.arg))\n    return '{}({}, (-1, 1))'.format(\n        self._module_format(self._module + '.reshape'), vect)",
    "sympy.sympy.printing.numpy._print_DiagMatrix": "def _print_DiagMatrix(self, expr):\n    return '{}({})'.format(self._module_format(self._module + '.diagflat'),\n        self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_DiagonalMatrix": "def _print_DiagonalMatrix(self, expr):\n    return '{}({}, {}({}, {}))'.format(self._module_format(self._module + '.multiply'),\n        self._print(expr.arg), self._module_format(self._module + '.eye'),\n        self._print(expr.shape[0]), self._print(expr.shape[1]))",
    "sympy.sympy.printing.numpy._print_Piecewise": "def _print_Piecewise(self, expr):\n    \"Piecewise function printer\"\n    from sympy.logic.boolalg import ITE, simplify_logic\n    def print_cond(cond):\n        \"\"\" Problem having an ITE in the cond. \"\"\"\n        if cond.has(ITE):\n            return self._print(simplify_logic(cond))\n        else:\n            return self._print(cond)\n    exprs = '[{}]'.format(','.join(self._print(arg.expr) for arg in expr.args))\n    conds = '[{}]'.format(','.join(print_cond(arg.cond) for arg in expr.args))\n    # If [default_value, True] is a (expr, cond) sequence in a Piecewise object\n    #     it will behave the same as passing the 'default' kwarg to select()\n    #     *as long as* it is the last element in expr.args.\n    # If this is not the case, it may be triggered prematurely.\n    return '{}({}, {}, default={})'.format(\n        self._module_format(self._module + '.select'), conds, exprs,\n        self._print(S.NaN))",
    "sympy.sympy.printing.numpy._print_Relational": "def _print_Relational(self, expr):\n    \"Relational printer for Equality and Unequality\"\n    op = {\n        '==' :'equal',\n        '!=' :'not_equal',\n        '<'  :'less',\n        '<=' :'less_equal',\n        '>'  :'greater',\n        '>=' :'greater_equal',\n    }\n    if expr.rel_op in op:\n        lhs = self._print(expr.lhs)\n        rhs = self._print(expr.rhs)\n        return '{op}({lhs}, {rhs})'.format(op=self._module_format(self._module + '.'+op[expr.rel_op]),\n                                           lhs=lhs, rhs=rhs)\n    return super()._print_Relational(expr)",
    "sympy.sympy.printing.numpy._print_Pow": "def _print_Pow(self, expr, rational=False):\n    # XXX Workaround for negative integer power error\n    if expr.exp.is_integer and expr.exp.is_negative:\n        expr = Pow(expr.base, expr.exp.evalf(), evaluate=False)\n    return self._hprint_Pow(expr, rational=rational, sqrt=self._module + '.sqrt')",
    "sympy.sympy.printing.numpy._print_Identity": "def _print_Identity(self, expr):\n    shape = expr.shape\n    if all(dim.is_Integer for dim in shape):\n        return \"%s(%s)\" % (self._module_format(self._module + '.eye'), self._print(expr.shape[0]))\n    else:\n        raise NotImplementedError(\"Symbolic matrix dimensions are not yet supported for identity matrices\")",
    "sympy.sympy.printing.numpy._print_NDimArray": "def _print_NDimArray(self, expr):\n    if expr.rank() == 0:\n        func = self._module_format(f'{self._module}.array')\n        return f\"{func}({self._print(expr[()])})\"\n    if 0 in expr.shape:\n        func = self._module_format(f'{self._module}.{self._zeros}')\n        return f\"{func}({self._print(expr.shape)})\"\n    func = self._module_format(f'{self._module}.array')\n    return f\"{func}({self._print(expr.tolist())})\"",
    "sympy.sympy.printing.numpy._print_SparseRepMatrix": "def _print_SparseRepMatrix(self, expr):\n    i, j, data = [], [], []\n    for (r, c), v in expr.todok().items():\n        i.append(r)\n        j.append(c)\n        data.append(v)\n\n    return \"{name}(({data}, ({i}, {j})), shape={shape})\".format(\n        name=self._module_format('scipy.sparse.coo_matrix'),\n        data=data, i=i, j=j, shape=expr.shape\n    )",
    "sympy.sympy.printing.numpy._print_lowergamma": "def _print_lowergamma(self, expr):\n    return \"{0}({2})*{1}({2}, {3})\".format(\n        self._module_format('scipy.special.gamma'),\n        self._module_format('scipy.special.gammainc'),\n        self._print(expr.args[0]),\n        self._print(expr.args[1]))",
    "sympy.sympy.printing.numpy._print_uppergamma": "def _print_uppergamma(self, expr):\n    return \"{0}({2})*{1}({2}, {3})\".format(\n        self._module_format('scipy.special.gamma'),\n        self._module_format('scipy.special.gammaincc'),\n        self._print(expr.args[0]),\n        self._print(expr.args[1]))",
    "sympy.sympy.printing.numpy._print_fresnels": "def _print_fresnels(self, expr):\n    return \"{}({})[0]\".format(\n            self._module_format(\"scipy.special.fresnel\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_fresnelc": "def _print_fresnelc(self, expr):\n    return \"{}({})[1]\".format(\n            self._module_format(\"scipy.special.fresnel\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_airyai": "def _print_airyai(self, expr):\n    return \"{}({})[0]\".format(\n            self._module_format(\"scipy.special.airy\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_airyaiprime": "def _print_airyaiprime(self, expr):\n    return \"{}({})[1]\".format(\n            self._module_format(\"scipy.special.airy\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_airybi": "def _print_airybi(self, expr):\n    return \"{}({})[2]\".format(\n            self._module_format(\"scipy.special.airy\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_airybiprime": "def _print_airybiprime(self, expr):\n    return \"{}({})[3]\".format(\n            self._module_format(\"scipy.special.airy\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_Integral": "def _print_Integral(self, e):\n    integration_vars, limits = _unpack_integral_limits(e)\n\n    if len(limits) == 1:\n        # nicer (but not necessary) to prefer quad over nquad for 1D case\n        module_str = self._module_format(\"scipy.integrate.quad\")\n        limit_str = \"%s, %s\" % tuple(map(self._print, limits[0]))\n    else:\n        module_str = self._module_format(\"scipy.integrate.nquad\")\n        limit_str = \"({})\".format(\", \".join(\n            \"(%s, %s)\" % tuple(map(self._print, l)) for l in limits))\n\n    return \"{}(lambda {}: {}, {})[0]\".format(\n            module_str,\n            \", \".join(map(self._print, integration_vars)),\n            self._print(e.args[0]),\n            limit_str)",
    "sympy.sympy.printing.numpy._print_Si": "def _print_Si(self, expr):\n    return \"{}({})[0]\".format(\n            self._module_format(\"scipy.special.sici\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_Ci": "def _print_Ci(self, expr):\n    return \"{}({})[1]\".format(\n            self._module_format(\"scipy.special.sici\"),\n            self._print(expr.args[0]))",
    "sympy.sympy.printing.numpy._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-' + self._print(S.Infinity)",
    "sympy.sympy.printing.numpy._print_MatPow": "def _print_MatPow(self, expr):\n    \"Matrix power printer\"\n    return '{}({}, {})'.format(self._module_format(self._module + '.linalg.matrix_power'),\n        self._print(expr.args[0]), self._print(expr.args[1]))",
    "sympy.sympy.printing.numpy._print_Inverse": "def _print_Inverse(self, expr):\n    \"Matrix inverse printer\"\n    return '{}({})'.format(self._module_format(self._module + '.linalg.inv'),\n        self._print(expr.args[0]))",
    "sympy.sympy.printing.octave._print_Mul": "def _print_Mul(self, expr):\n    # print complex numbers nicely in Octave\n    if (expr.is_number and expr.is_imaginary and\n            (S.ImaginaryUnit*expr).is_Integer):\n        return \"%si\" % self._print(-S.ImaginaryUnit*expr)\n\n    # cribbed from str.py\n    prec = precedence(expr)\n\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = \"-\"\n    else:\n        sign = \"\"\n\n    a = []  # items in the numerator\n    b = []  # items that are in the denominator (if any)\n\n    pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        # use make_args in case expr was something like -x -> x\n        args = Mul.make_args(expr)\n\n    # Gather args for numerator/denominator\n    for item in args:\n        if (item.is_commutative and item.is_Pow and item.exp.is_Rational\n                and item.exp.is_negative):\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n                    pow_paren.append(item)\n                b.append(Pow(item.base, -item.exp))\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append(Rational(item.p))\n            if item.q != 1:\n                b.append(Rational(item.q))\n        else:\n            a.append(item)\n\n    a = a or [S.One]\n\n    a_str = [self.parenthesize(x, prec) for x in a]\n    b_str = [self.parenthesize(x, prec) for x in b]\n\n    # To parenthesize Pow with exp = -1 and having more than one Symbol\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n\n    # from here it differs from str.py to deal with \"*\" and \".*\"\n    def multjoin(a, a_str):\n        # here we probably are assuming the constants will come first\n        r = a_str[0]\n        for i in range(1, len(a)):\n            mulsym = '*' if a[i-1].is_number else '.*'\n            r = r + mulsym + a_str[i]\n        return r\n\n    if not b:\n        return sign + multjoin(a, a_str)\n    elif len(b) == 1:\n        divsym = '/' if b[0].is_number else './'\n        return sign + multjoin(a, a_str) + divsym + b_str[0]\n    else:\n        divsym = '/' if all(bi.is_number for bi in b) else './'\n        return (sign + multjoin(a, a_str) +\n                divsym + \"(%s)\" % multjoin(b, b_str))",
    "sympy.sympy.printing.octave._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.octave._print_Pow": "def _print_Pow(self, expr):\n    powsymbol = '^' if all(x.is_number for x in expr.args) else '.^'\n\n    PREC = precedence(expr)\n\n    if equal_valued(expr.exp, 0.5):\n        return \"sqrt(%s)\" % self._print(expr.base)\n\n    if expr.is_commutative:\n        if equal_valued(expr.exp, -0.5):\n            sym = '/' if expr.base.is_number else './'\n            return \"1\" + sym + \"sqrt(%s)\" % self._print(expr.base)\n        if equal_valued(expr.exp, -1):\n            sym = '/' if expr.base.is_number else './'\n            return \"1\" + sym + \"%s\" % self.parenthesize(expr.base, PREC)\n\n    return '%s%s%s' % (self.parenthesize(expr.base, PREC), powsymbol,\n                       self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.octave._print_MatPow": "def _print_MatPow(self, expr):\n    PREC = precedence(expr)\n    return '%s^%s' % (self.parenthesize(expr.base, PREC),\n                      self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.octave._print_MatrixSolve": "def _print_MatrixSolve(self, expr):\n    PREC = precedence(expr)\n    return \"%s \\\\ %s\" % (self.parenthesize(expr.matrix, PREC),\n                         self.parenthesize(expr.vector, PREC))",
    "sympy.sympy.printing.octave._print_Pi": "def _print_Pi(self, expr):\n    return 'pi'",
    "sympy.sympy.printing.octave._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return \"1i\"",
    "sympy.sympy.printing.octave._print_Exp1": "def _print_Exp1(self, expr):\n    return \"exp(1)\"",
    "sympy.sympy.printing.octave._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    # FIXME: how to do better, e.g., for octave_code(2*GoldenRatio)?\n    #return self._print((1+sqrt(S(5)))/2)\n    return \"(1+sqrt(5))/2\"",
    "sympy.sympy.printing.octave._print_Assignment": "def _print_Assignment(self, expr):\n    from sympy.codegen.ast import Assignment\n    from sympy.functions.elementary.piecewise import Piecewise\n    from sympy.tensor.indexed import IndexedBase\n    # Copied from codeprinter, but remove special MatrixSymbol treatment\n    lhs = expr.lhs\n    rhs = expr.rhs\n    # We special case assignments that take multiple lines\n    if not self._settings[\"inline\"] and isinstance(expr.rhs, Piecewise):\n        # Here we modify Piecewise so each expression is now\n        # an Assignment, and then continue on the print.\n        expressions = []\n        conditions = []\n        for (e, c) in rhs.args:\n            expressions.append(Assignment(lhs, e))\n            conditions.append(c)\n        temp = Piecewise(*zip(expressions, conditions))\n        return self._print(temp)\n    if self._settings[\"contract\"] and (lhs.has(IndexedBase) or\n            rhs.has(IndexedBase)):\n        # Here we check if there is looping to be done, and if so\n        # print the required loops.\n        return self._doprint_loops(rhs, lhs)\n    else:\n        lhs_code = self._print(lhs)\n        rhs_code = self._print(rhs)\n        return self._get_statement(\"%s = %s\" % (lhs_code, rhs_code))",
    "sympy.sympy.printing.octave._print_Infinity": "def _print_Infinity(self, expr):\n    return 'inf'",
    "sympy.sympy.printing.octave._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-inf'",
    "sympy.sympy.printing.octave._print_NaN": "def _print_NaN(self, expr):\n    return 'NaN'",
    "sympy.sympy.printing.octave._print_list": "def _print_list(self, expr):\n    return '{' + ', '.join(self._print(a) for a in expr) + '}'",
    "sympy.sympy.printing.octave._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return \"true\"",
    "sympy.sympy.printing.octave._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return \"false\"",
    "sympy.sympy.printing.octave._print_MatrixBase": "def _print_MatrixBase(self, A):\n    # Handle zero dimensions:\n    if (A.rows, A.cols) == (0, 0):\n        return '[]'\n    elif S.Zero in A.shape:\n        return 'zeros(%s, %s)' % (A.rows, A.cols)\n    elif (A.rows, A.cols) == (1, 1):\n        # Octave does not distinguish between scalars and 1x1 matrices\n        return self._print(A[0, 0])\n    return \"[%s]\" % \"; \".join(\" \".join([self._print(a) for a in A[r, :]])\n                              for r in range(A.rows))",
    "sympy.sympy.printing.octave._print_SparseRepMatrix": "def _print_SparseRepMatrix(self, A):\n    from sympy.matrices import Matrix\n    L = A.col_list()\n    # make row vectors of the indices and entries\n    I = Matrix([[k[0] + 1 for k in L]])\n    J = Matrix([[k[1] + 1 for k in L]])\n    AIJ = Matrix([[k[2] for k in L]])\n    return \"sparse(%s, %s, %s, %s, %s)\" % (self._print(I), self._print(J),\n                                        self._print(AIJ), A.rows, A.cols)",
    "sympy.sympy.printing.octave._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n        + '(%s, %s)' % (expr.i + 1, expr.j + 1)",
    "sympy.sympy.printing.octave._print_MatrixSlice": "def _print_MatrixSlice(self, expr):\n    def strslice(x, lim):\n        l = x[0] + 1\n        h = x[1]\n        step = x[2]\n        lstr = self._print(l)\n        hstr = 'end' if h == lim else self._print(h)\n        if step == 1:\n            if l == 1 and h == lim:\n                return ':'\n            if l == h:\n                return lstr\n            else:\n                return lstr + ':' + hstr\n        else:\n            return ':'.join((lstr, self._print(step), hstr))\n    return (self._print(expr.parent) + '(' +\n            strslice(expr.rowslice, expr.parent.shape[0]) + ', ' +\n            strslice(expr.colslice, expr.parent.shape[1]) + ')')",
    "sympy.sympy.printing.octave._print_Indexed": "def _print_Indexed(self, expr):\n    inds = [ self._print(i) for i in expr.indices ]\n    return \"%s(%s)\" % (self._print(expr.base.label), \", \".join(inds))",
    "sympy.sympy.printing.octave._print_KroneckerDelta": "def _print_KroneckerDelta(self, expr):\n    prec = PRECEDENCE[\"Pow\"]\n    return \"double(%s == %s)\" % tuple(self.parenthesize(x, prec)\n                                      for x in expr.args)",
    "sympy.sympy.printing.octave._print_HadamardProduct": "def _print_HadamardProduct(self, expr):\n    return '.*'.join([self.parenthesize(arg, precedence(expr))\n                      for arg in expr.args])",
    "sympy.sympy.printing.octave._print_HadamardPower": "def _print_HadamardPower(self, expr):\n    PREC = precedence(expr)\n    return '.**'.join([\n        self.parenthesize(expr.base, PREC),\n        self.parenthesize(expr.exp, PREC)\n        ])",
    "sympy.sympy.printing.octave._print_Identity": "def _print_Identity(self, expr):\n    shape = expr.shape\n    if len(shape) == 2 and shape[0] == shape[1]:\n        shape = [shape[0]]\n    s = \", \".join(self._print(n) for n in shape)\n    return \"eye(\" + s + \")\"",
    "sympy.sympy.printing.octave._print_lowergamma": "def _print_lowergamma(self, expr):\n    # Octave implements regularized incomplete gamma function\n    return \"(gammainc({1}, {0}).*gamma({0}))\".format(\n        self._print(expr.args[0]), self._print(expr.args[1]))",
    "sympy.sympy.printing.octave._print_uppergamma": "def _print_uppergamma(self, expr):\n    return \"(gammainc({1}, {0}, 'upper').*gamma({0}))\".format(\n        self._print(expr.args[0]), self._print(expr.args[1]))",
    "sympy.sympy.printing.octave._print_sinc": "def _print_sinc(self, expr):\n    #Note: Divide by pi because Octave implements normalized sinc function.\n    return \"sinc(%s)\" % self._print(expr.args[0]/S.Pi)",
    "sympy.sympy.printing.octave._print_hankel1": "def _print_hankel1(self, expr):\n    return \"besselh(%s, 1, %s)\" % (self._print(expr.order),\n                                   self._print(expr.argument))",
    "sympy.sympy.printing.octave._print_hankel2": "def _print_hankel2(self, expr):\n    return \"besselh(%s, 2, %s)\" % (self._print(expr.order),\n                                   self._print(expr.argument))",
    "sympy.sympy.printing.octave._print_jn": "def _print_jn(self, expr):\n    from sympy.functions import sqrt, besselj\n    x = expr.argument\n    expr2 = sqrt(S.Pi/(2*x))*besselj(expr.order + S.Half, x)\n    return self._print(expr2)",
    "sympy.sympy.printing.octave._print_yn": "def _print_yn(self, expr):\n    from sympy.functions import sqrt, bessely\n    x = expr.argument\n    expr2 = sqrt(S.Pi/(2*x))*bessely(expr.order + S.Half, x)\n    return self._print(expr2)",
    "sympy.sympy.printing.octave._print_airyai": "def _print_airyai(self, expr):\n    return \"airy(0, %s)\" % self._print(expr.args[0])",
    "sympy.sympy.printing.octave._print_airyaiprime": "def _print_airyaiprime(self, expr):\n    return \"airy(1, %s)\" % self._print(expr.args[0])",
    "sympy.sympy.printing.octave._print_airybi": "def _print_airybi(self, expr):\n    return \"airy(2, %s)\" % self._print(expr.args[0])",
    "sympy.sympy.printing.octave._print_airybiprime": "def _print_airybiprime(self, expr):\n    return \"airy(3, %s)\" % self._print(expr.args[0])",
    "sympy.sympy.printing.octave._print_expint": "def _print_expint(self, expr):\n    mu, x = expr.args\n    if mu != 1:\n        return self._print_not_supported(expr)\n    return \"expint(%s)\" % self._print(x)",
    "sympy.sympy.printing.octave._one_or_two_reversed_args": "def _one_or_two_reversed_args(self, expr):\n    assert len(expr.args) <= 2\n    return '{name}({args})'.format(\n        name=self.known_functions[expr.__class__.__name__],\n        args=\", \".join([self._print(x) for x in reversed(expr.args)])\n    )",
    "sympy.sympy.printing.octave._nested_binary_math_func": "def _nested_binary_math_func(self, expr):\n    return '{name}({arg1}, {arg2})'.format(\n        name=self.known_functions[expr.__class__.__name__],\n        arg1=self._print(expr.args[0]),\n        arg2=self._print(expr.func(*expr.args[1:]))\n        )",
    "sympy.sympy.printing.octave._print_Piecewise": "def _print_Piecewise(self, expr):\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n    if self._settings[\"inline\"]:\n        # Express each (cond, expr) pair in a nested Horner form:\n        #   (condition) .* (expr) + (not cond) .* (<others>)\n        # Expressions that result in multiple statements won't work here.\n        ecpairs = [\"({0}).*({1}) + (~({0})).*(\".format\n                   (self._print(c), self._print(e))\n                   for e, c in expr.args[:-1]]\n        elast = \"%s\" % self._print(expr.args[-1].expr)\n        pw = \" ...\\n\".join(ecpairs) + elast + \")\"*len(ecpairs)\n        # Note: current need these outer brackets for 2*pw.  Would be\n        # nicer to teach parenthesize() to do this for us when needed!\n        return \"(\" + pw + \")\"\n    else:\n        for i, (e, c) in enumerate(expr.args):\n            if i == 0:\n                lines.append(\"if (%s)\" % self._print(c))\n            elif i == len(expr.args) - 1 and c == True:\n                lines.append(\"else\")\n            else:\n                lines.append(\"elseif (%s)\" % self._print(c))\n            code0 = self._print(e)\n            lines.append(code0)\n            if i == len(expr.args) - 1:\n                lines.append(\"end\")\n        return \"\\n\".join(lines)",
    "sympy.sympy.printing.octave._print_zeta": "def _print_zeta(self, expr):\n    if len(expr.args) == 1:\n        return \"zeta(%s)\" % self._print(expr.args[0])\n    else:\n        # Matlab two argument zeta is not equivalent to SymPy's\n        return self._print_not_supported(expr)",
    "sympy.sympy.printing.pretty.pretty._print_DiscreteTransferFunction": "def _print_DiscreteTransferFunction(self, expr):\n    if not expr.num == 1:\n        res = Mul(expr.num, Pow(expr.den, -1, evaluate=False),\n                  evaluate=False)\n        result = self._print_Mul(res)\n    else:\n        result =  self._print(1)/self._print(expr.den)\n\n    result = prettyForm(\\\n        *result.right(f\" [st: {expr.sampling_time}]\"))\n    return result",
    "sympy.sympy.printing.pretty.pretty._print_Series": "def _print_Series(self, expr):\n    args = list(expr.args)\n    for i, a in enumerate(expr.args):\n        args[i] = prettyForm(*self._print(a).parens())\n    return prettyForm.__mul__(*args)",
    "sympy.sympy.printing.pretty.pretty._print_MIMOSeries": "def _print_MIMOSeries(self, expr):\n    from sympy.physics.control.lti import MIMOParallel\n    args = list(expr.args)\n    pretty_args = []\n    for a in reversed(args):\n        if (isinstance(a, MIMOParallel) and len(expr.args) > 1):\n            expression = self._print(a)\n            expression.baseline = expression.height()//2\n            pretty_args.append(prettyForm(*expression.parens()))\n        else:\n            expression = self._print(a)\n            expression.baseline = expression.height()//2\n            pretty_args.append(expression)\n    return prettyForm.__mul__(*pretty_args)",
    "sympy.sympy.printing.pretty.pretty._print_Parallel": "def _print_Parallel(self, expr):\n    s = None\n    for item in expr.args:\n        pform = self._print(item)\n        if s is None:\n            s = pform     # First element\n        else:\n            s = prettyForm(*stringPict.next(s))\n            s.baseline = s.height()//2\n            s = prettyForm(*stringPict.next(s, ' + '))\n            s = prettyForm(*stringPict.next(s, pform))\n    return s",
    "sympy.sympy.printing.pretty.pretty._print_MIMOParallel": "def _print_MIMOParallel(self, expr):\n    from sympy.physics.control.lti import TransferFunctionMatrix\n    s = None\n    for item in expr.args:\n        pform = self._print(item)\n        if s is None:\n            s = pform     # First element\n        else:\n            s = prettyForm(*stringPict.next(s))\n            s.baseline = s.height()//2\n            s = prettyForm(*stringPict.next(s, ' + '))\n            if isinstance(item, TransferFunctionMatrix):\n                s.baseline = s.height() - 1\n            s = prettyForm(*stringPict.next(s, pform))\n        # s.baseline = s.height()//2\n    return s",
    "sympy.sympy.printing.pretty.pretty._print_Feedback": "def _print_Feedback(self, expr):\n    from sympy.physics.control import TransferFunction, Series\n\n    num, tf = expr.sys1, TransferFunction(1, 1, expr.var)\n    num_arg_list = list(num.args) if isinstance(num, Series) else [num]\n    den_arg_list = list(expr.sys2.args) if \\\n        isinstance(expr.sys2, Series) else [expr.sys2]\n\n    if isinstance(num, Series) and isinstance(expr.sys2, Series):\n        den = Series(*num_arg_list, *den_arg_list)\n    elif isinstance(num, Series) and isinstance(expr.sys2, TransferFunction):\n        if expr.sys2 == tf:\n            den = Series(*num_arg_list)\n        else:\n            den = Series(*num_arg_list, expr.sys2)\n    elif isinstance(num, TransferFunction) and isinstance(expr.sys2, Series):\n        if num == tf:\n            den = Series(*den_arg_list)\n        else:\n            den = Series(num, *den_arg_list)\n    else:\n        if num == tf:\n            den = Series(*den_arg_list)\n        elif expr.sys2 == tf:\n            den = Series(*num_arg_list)\n        else:\n            den = Series(*num_arg_list, *den_arg_list)\n\n    denom = prettyForm(*stringPict.next(self._print(tf)))\n    denom.baseline = denom.height()//2\n    denom = prettyForm(*stringPict.next(denom, ' + ')) if expr.sign == -1 \\\n        else prettyForm(*stringPict.next(denom, ' - '))\n    denom = prettyForm(*stringPict.next(denom, self._print(den)))\n\n    return self._print(num)/denom",
    "sympy.sympy.printing.pretty.pretty._print_Curl": "def _print_Curl(self, e):\n    vec = e._expr\n    pform = self._print(vec)\n    pform = prettyForm(*pform.left('('))\n    pform = prettyForm(*pform.right(')'))\n    pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))\n    pform = prettyForm(*pform.left(self._print(U('NABLA'))))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_MIMOFeedback": "def _print_MIMOFeedback(self, expr):\n    from sympy.physics.control import MIMOSeries, TransferFunctionMatrix\n\n    inv_mat = self._print(MIMOSeries(expr.sys2, expr.sys1))\n    plant = self._print(expr.sys1)\n    _feedback = prettyForm(*stringPict.next(inv_mat))\n    _feedback = prettyForm(*stringPict.right(\"I + \", _feedback)) if expr.sign == -1 \\\n        else prettyForm(*stringPict.right(\"I - \", _feedback))\n    _feedback = prettyForm(*stringPict.parens(_feedback))\n    _feedback.baseline = 0\n    _feedback = prettyForm(*stringPict.right(_feedback, '-1 '))\n    _feedback.baseline = _feedback.height()//2\n    _feedback = prettyForm.__mul__(_feedback, prettyForm(\" \"))\n    if isinstance(expr.sys1, TransferFunctionMatrix):\n        _feedback.baseline = _feedback.height() - 1\n    _feedback = prettyForm(*stringPict.next(_feedback, plant))\n    return _feedback",
    "sympy.sympy.printing.pretty.pretty._print_TransferFunctionMatrix": "def _print_TransferFunctionMatrix(self, expr):\n    mat = self._print(expr._expr_mat)\n    mat.baseline = mat.height() - 1\n    if expr.sampling_time == 0:\n        subscript = greek_unicode['tau'] if self._use_unicode else r'{t}'\n    else:\n        subscript = r'{k}'\n    mat = prettyForm(*mat.right(subscript))\n\n    if expr.sampling_time == 0:\n        return mat\n\n    return prettyForm(*mat.below(f\"[st: {expr.sampling_time}]\"))",
    "sympy.sympy.printing.pretty.pretty._print_StateSpace": "def _print_StateSpace(self, expr):\n    from sympy.matrices.expressions.blockmatrix import BlockMatrix\n    A = expr._A\n    B = expr._B\n    C = expr._C\n    D = expr._D\n    mat = BlockMatrix([[A, B], [C, D]])\n    return self._print(mat.blocks)",
    "sympy.sympy.printing.pretty.pretty._print_DiscreteStateSpace": "def _print_DiscreteStateSpace(self, expr):\n    from sympy.matrices.expressions.blockmatrix import BlockMatrix\n    A = expr._A\n    B = expr._B\n    C = expr._C\n    D = expr._D\n    mat = BlockMatrix([[A, B], [C, D]])\n    mat = self._print(mat)\n    return prettyForm(*mat.below(f\"\\n[st: {expr.sampling_time}]\"))",
    "sympy.sympy.printing.pretty.pretty._print_BasisDependent": "def _print_BasisDependent(self, expr):\n    from sympy.vector import Vector\n\n    if not self._use_unicode:\n        raise NotImplementedError(\"ASCII pretty printing of BasisDependent is not implemented\")\n\n    if expr == expr.zero:\n        return prettyForm(expr.zero._pretty_form)\n    o1 = []\n    vectstrs = []\n    if isinstance(expr, Vector):\n        items = expr.separate().items()\n    else:\n        items = [(0, expr)]\n    for system, vect in items:\n        inneritems = list(vect.components.items())\n        inneritems.sort(key = lambda x: x[0].__str__())\n        for k, v in inneritems:\n            #if the coef of the basis vector is 1\n            #we skip the 1\n            if v == 1:\n                o1.append(\"\" +\n                          k._pretty_form)\n            #Same for -1\n            elif v == -1:\n                o1.append(\"(-1) \" +\n                          k._pretty_form)\n            #For a general expr\n            else:\n                #We always wrap the measure numbers in\n                #parentheses\n                arg_str = self._print(\n                    v).parens()[0]\n\n                o1.append(arg_str + ' ' + k._pretty_form)\n            vectstrs.append(k._pretty_form)\n\n    #outstr = u(\"\").join(o1)\n    if o1[0].startswith(\" + \"):\n        o1[0] = o1[0][3:]\n    elif o1[0].startswith(\" \"):\n        o1[0] = o1[0][1:]\n    #Fixing the newlines\n    lengths = []\n    strs = ['']\n    flag = []\n    for i, partstr in enumerate(o1):\n        flag.append(0)\n        # XXX: What is this hack?\n        if '\\n' in partstr:\n            tempstr = partstr\n            tempstr = tempstr.replace(vectstrs[i], '')\n            if xobj(')_ext', 1) in tempstr:   # If scalar is a fraction\n                for paren in range(len(tempstr)):\n                    flag[i] = 1\n                    if tempstr[paren] == xobj(')_ext', 1) and tempstr[paren + 1] == '\\n':\n                        # We want to place the vector string after all the right parentheses, because\n                        # otherwise, the vector will be in the middle of the string\n                        tempstr = tempstr[:paren] + xobj(')_ext', 1)\\\n                                     + ' '  + vectstrs[i] + tempstr[paren + 1:]\n                        break\n            elif xobj(')_lower_hook', 1) in tempstr:\n                # We want to place the vector string after all the right parentheses, because\n                # otherwise, the vector will be in the middle of the string. For this reason,\n                # we insert the vector string at the rightmost index.\n                index = tempstr.rfind(xobj(')_lower_hook', 1))\n                if index != -1: # then this character was found in this string\n                    flag[i] = 1\n                    tempstr = tempstr[:index] + xobj(')_lower_hook', 1)\\\n                                 + ' '  + vectstrs[i] + tempstr[index + 1:]\n            o1[i] = tempstr\n\n    o1 = [x.split('\\n') for x in o1]\n    n_newlines = max(len(x) for x in o1)  # Width of part in its pretty form\n\n    if 1 in flag:                           # If there was a fractional scalar\n        for i, parts in enumerate(o1):\n            if len(parts) == 1:             # If part has no newline\n                parts.insert(0, ' ' * (len(parts[0])))\n                flag[i] = 1\n\n    for i, parts in enumerate(o1):\n        lengths.append(len(parts[flag[i]]))\n        for j in range(n_newlines):\n            if j+1 <= len(parts):\n                if j >= len(strs):\n                    strs.append(' ' * (sum(lengths[:-1]) +\n                                       3*(len(lengths)-1)))\n                if j == flag[i]:\n                    strs[flag[i]] += parts[flag[i]] + ' + '\n                else:\n                    strs[j] += parts[j] + ' '*(lengths[-1] -\n                                               len(parts[j])+\n                                               3)\n            else:\n                if j >= len(strs):\n                    strs.append(' ' * (sum(lengths[:-1]) +\n                                       3*(len(lengths)-1)))\n                strs[j] += ' '*(lengths[-1]+3)\n\n    return prettyForm('\\n'.join([s[:-3] for s in strs]))",
    "sympy.sympy.printing.pretty.pretty._print_Divergence": "def _print_Divergence(self, e):\n    vec = e._expr\n    pform = self._print(vec)\n    pform = prettyForm(*pform.left('('))\n    pform = prettyForm(*pform.right(')'))\n    pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))\n    pform = prettyForm(*pform.left(self._print(U('NABLA'))))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_NDimArray": "def _print_NDimArray(self, expr):\n    from sympy.matrices.immutable import ImmutableMatrix\n\n    if expr.rank() == 0:\n        return self._print(expr[()])\n\n    level_str = [[]] + [[] for i in range(expr.rank())]\n    shape_ranges = [list(range(i)) for i in expr.shape]\n    # leave eventual matrix elements unflattened\n    mat = lambda x: ImmutableMatrix(x, evaluate=False)\n    for outer_i in itertools.product(*shape_ranges):\n        level_str[-1].append(expr[outer_i])\n        even = True\n        for back_outer_i in range(expr.rank()-1, -1, -1):\n            if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:\n                break\n            if even:\n                level_str[back_outer_i].append(level_str[back_outer_i+1])\n            else:\n                level_str[back_outer_i].append(mat(\n                    level_str[back_outer_i+1]))\n                if len(level_str[back_outer_i + 1]) == 1:\n                    level_str[back_outer_i][-1] = mat(\n                        [[level_str[back_outer_i][-1]]])\n            even = not even\n            level_str[back_outer_i+1] = []\n\n    out_expr = level_str[0][0]\n    if expr.rank() % 2 == 1:\n        out_expr = mat([out_expr])\n\n    return self._print(out_expr)",
    "sympy.sympy.printing.pretty.pretty._print_Dot": "def _print_Dot(self, e):\n    vec1 = e._expr1\n    vec2 = e._expr2\n    pform = self._print(vec2)\n    pform = prettyForm(*pform.left('('))\n    pform = prettyForm(*pform.right(')'))\n    pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))\n    pform = prettyForm(*pform.left(')'))\n    pform = prettyForm(*pform.left(self._print(vec1)))\n    pform = prettyForm(*pform.left('('))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Tensor": "def _print_Tensor(self, expr):\n    name = expr.args[0].name\n    indices = expr.get_indices()\n    return self._printer_tensor_indices(name, indices)",
    "sympy.sympy.printing.pretty.pretty._print_TensorElement": "def _print_TensorElement(self, expr):\n    name = expr.expr.args[0].name\n    indices = expr.expr.get_indices()\n    index_map = expr.index_map\n    return self._printer_tensor_indices(name, indices, index_map)",
    "sympy.sympy.printing.pretty.pretty._print_TensMul": "def _print_TensMul(self, expr):\n    sign, args = expr._get_args_for_traditional_printer()\n    args = [\n        prettyForm(*self._print(i).parens()) if\n        precedence_traditional(i) < PRECEDENCE[\"Mul\"] else self._print(i)\n        for i in args\n    ]\n    pform = prettyForm.__mul__(*args)\n    if sign:\n        return prettyForm(*pform.left(sign))\n    else:\n        return pform",
    "sympy.sympy.printing.pretty.pretty._print_TensAdd": "def _print_TensAdd(self, expr):\n    args = [\n        prettyForm(*self._print(i).parens()) if\n        precedence_traditional(i) < PRECEDENCE[\"Mul\"] else self._print(i)\n        for i in expr.args\n    ]\n    return prettyForm.__add__(*args)",
    "sympy.sympy.printing.pretty.pretty._print_TensorIndex": "def _print_TensorIndex(self, expr):\n    sym = expr.args[0]\n    if not expr.is_up:\n        sym = -sym\n    return self._print(sym)",
    "sympy.sympy.printing.pretty.pretty._print_PartialDerivative": "def _print_PartialDerivative(self, deriv):\n    if self._use_unicode:\n        deriv_symbol = U('PARTIAL DIFFERENTIAL')\n    else:\n        deriv_symbol = r'd'\n    x = None\n\n    for variable in reversed(deriv.variables):\n        s = self._print(variable)\n        ds = prettyForm(*s.left(deriv_symbol))\n\n        if x is None:\n            x = ds\n        else:\n            x = prettyForm(*x.right(' '))\n            x = prettyForm(*x.right(ds))\n\n    f = prettyForm(\n        binding=prettyForm.FUNC, *self._print(deriv.expr).parens())\n\n    pform = prettyForm(deriv_symbol)\n\n    if len(deriv.variables) > 1:\n        pform = pform**self._print(len(deriv.variables))\n\n    pform = prettyForm(*pform.below(stringPict.LINE, x))\n    pform.baseline = pform.baseline + 1\n    pform = prettyForm(*stringPict.next(pform, f))\n    pform.binding = prettyForm.MUL\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Gradient": "def _print_Gradient(self, e):\n    func = e._expr\n    pform = self._print(func)\n    pform = prettyForm(*pform.left('('))\n    pform = prettyForm(*pform.right(')'))\n    pform = prettyForm(*pform.left(self._print(U('NABLA'))))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Piecewise": "def _print_Piecewise(self, pexpr):\n\n    P = {}\n    for n, ec in enumerate(pexpr.args):\n        P[n, 0] = self._print(ec.expr)\n        if ec.cond == True:\n            P[n, 1] = prettyForm('otherwise')\n        else:\n            P[n, 1] = prettyForm(\n                *prettyForm('for ').right(self._print(ec.cond)))\n    hsep = 2\n    vsep = 1\n    len_args = len(pexpr.args)\n\n    # max widths\n    maxw = [max(P[i, j].width() for i in range(len_args))\n            for j in range(2)]\n\n    # FIXME: Refactor this code and matrix into some tabular environment.\n    # drawing result\n    D = None\n\n    for i in range(len_args):\n        D_row = None\n        for j in range(2):\n            p = P[i, j]\n            assert p.width() <= maxw[j]\n\n            wdelta = maxw[j] - p.width()\n            wleft = wdelta // 2\n            wright = wdelta - wleft\n\n            p = prettyForm(*p.right(' '*wright))\n            p = prettyForm(*p.left(' '*wleft))\n\n            if D_row is None:\n                D_row = p\n                continue\n\n            D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer\n            D_row = prettyForm(*D_row.right(p))\n        if D is None:\n            D = D_row       # first row in a picture\n            continue\n\n        # v-spacer\n        for _ in range(vsep):\n            D = prettyForm(*D.below(' '))\n\n        D = prettyForm(*D.below(D_row))\n\n    D = prettyForm(*D.parens('{', ''))\n    D.baseline = D.height()//2\n    D.binding = prettyForm.OPEN\n    return D",
    "sympy.sympy.printing.pretty.pretty._print_ITE": "def _print_ITE(self, ite):\n    from sympy.functions.elementary.piecewise import Piecewise\n    return self._print(ite.rewrite(Piecewise))",
    "sympy.sympy.printing.pretty.pretty._print_Laplacian": "def _print_Laplacian(self, e):\n    func = e._expr\n    pform = self._print(func)\n    pform = prettyForm(*pform.left('('))\n    pform = prettyForm(*pform.right(')'))\n    pform = prettyForm(*pform.left(self._print(U('INCREMENT'))))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_hyper": "def _print_hyper(self, e):\n    # FIXME refactor Matrix, Piecewise, and this into a tabular environment\n    ap = [self._print(a) for a in e.ap]\n    bq = [self._print(b) for b in e.bq]\n\n    P = self._print(e.argument)\n    P.baseline = P.height()//2\n\n    # Drawing result - first create the ap, bq vectors\n    D = None\n    for v in [ap, bq]:\n        D_row = self._hprint_vec(v)\n        if D is None:\n            D = D_row       # first row in a picture\n        else:\n            D = prettyForm(*D.below(' '))\n            D = prettyForm(*D.below(D_row))\n\n    # make sure that the argument `z' is centred vertically\n    D.baseline = D.height()//2\n\n    # insert horizontal separator\n    P = prettyForm(*P.left(' '))\n    D = prettyForm(*D.right(' '))\n\n    # insert separating `|`\n    D = self._hprint_vseparator(D, P)\n\n    # add parens\n    D = prettyForm(*D.parens('(', ')'))\n\n    # create the F symbol\n    above = D.height()//2 - 1\n    below = D.height() - above - 1\n\n    sz, t, b, add, img = annotated('F')\n    F = prettyForm('\\n' * (above - t) + img + '\\n' * (below - b),\n                   baseline=above + sz)\n    add = (sz + 1)//2\n\n    F = prettyForm(*F.left(self._print(len(e.ap))))\n    F = prettyForm(*F.right(self._print(len(e.bq))))\n    F.baseline = above + add\n\n    D = prettyForm(*F.right(' ', D))\n\n    return D",
    "sympy.sympy.printing.pretty.pretty._print_meijerg": "def _print_meijerg(self, e):\n    # FIXME refactor Matrix, Piecewise, and this into a tabular environment\n\n    v = {}\n    v[(0, 0)] = [self._print(a) for a in e.an]\n    v[(0, 1)] = [self._print(a) for a in e.aother]\n    v[(1, 0)] = [self._print(b) for b in e.bm]\n    v[(1, 1)] = [self._print(b) for b in e.bother]\n\n    P = self._print(e.argument)\n    P.baseline = P.height()//2\n\n    vp = {}\n    for idx in v:\n        vp[idx] = self._hprint_vec(v[idx])\n\n    for i in range(2):\n        maxw = max(vp[(0, i)].width(), vp[(1, i)].width())\n        for j in range(2):\n            s = vp[(j, i)]\n            left = (maxw - s.width()) // 2\n            right = maxw - left - s.width()\n            s = prettyForm(*s.left(' ' * left))\n            s = prettyForm(*s.right(' ' * right))\n            vp[(j, i)] = s\n\n    D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))\n    D1 = prettyForm(*D1.below(' '))\n    D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))\n    D = prettyForm(*D1.below(D2))\n\n    # make sure that the argument `z' is centred vertically\n    D.baseline = D.height()//2\n\n    # insert horizontal separator\n    P = prettyForm(*P.left(' '))\n    D = prettyForm(*D.right(' '))\n\n    # insert separating `|`\n    D = self._hprint_vseparator(D, P)\n\n    # add parens\n    D = prettyForm(*D.parens('(', ')'))\n\n    # create the G symbol\n    above = D.height()//2 - 1\n    below = D.height() - above - 1\n\n    sz, t, b, add, img = annotated('G')\n    F = prettyForm('\\n' * (above - t) + img + '\\n' * (below - b),\n                   baseline=above + sz)\n\n    pp = self._print(len(e.ap))\n    pq = self._print(len(e.bq))\n    pm = self._print(len(e.bm))\n    pn = self._print(len(e.an))\n\n    def adjust(p1, p2):\n        diff = p1.width() - p2.width()\n        if diff == 0:\n            return p1, p2\n        elif diff > 0:\n            return p1, prettyForm(*p2.left(' '*diff))\n        else:\n            return prettyForm(*p1.left(' '*-diff)), p2\n    pp, pm = adjust(pp, pm)\n    pq, pn = adjust(pq, pn)\n    pu = prettyForm(*pm.right(', ', pn))\n    pl = prettyForm(*pp.right(', ', pq))\n\n    ht = F.baseline - above - 2\n    if ht > 0:\n        pu = prettyForm(*pu.below('\\n'*ht))\n    p = prettyForm(*pu.below(pl))\n\n    F.baseline = above\n    F = prettyForm(*F.right(p))\n\n    F.baseline = above + add\n\n    D = prettyForm(*F.right(' ', D))\n\n    return D",
    "sympy.sympy.printing.pretty.pretty._print_Atom": "def _print_Atom(self, e):\n    try:\n        # print atoms like Exp1 or Pi\n        return prettyForm(pretty_atom(e.__class__.__name__, printer=self))\n    except KeyError:\n        return self.emptyPrinter(e)",
    "sympy.sympy.printing.pretty.pretty._print_ExpBase": "def _print_ExpBase(self, e):\n    # TODO should exp_polar be printed differently?\n    #      what about exp_polar(0), exp_polar(1)?\n    base = prettyForm(pretty_atom('Exp1', 'e'))\n    return base ** self._print(e.args[0])",
    "sympy.sympy.printing.pretty.pretty._print_Exp1": "def _print_Exp1(self, e):\n    return prettyForm(pretty_atom('Exp1', 'e'))",
    "sympy.sympy.printing.pretty.pretty._print_Function": "def _print_Function(self, e, sort=False, func_name=None, left='(',\n                    right=')'):\n    # optional argument func_name for supplying custom names\n    # XXX works only for applied functions\n    return self._helper_print_function(e.func, e.args, sort=sort, func_name=func_name, left=left, right=right)",
    "sympy.sympy.printing.pretty.pretty._print_mathieuc": "def _print_mathieuc(self, e):\n    return self._print_Function(e, func_name='C')",
    "sympy.sympy.printing.pretty.pretty._print_mathieus": "def _print_mathieus(self, e):\n    return self._print_Function(e, func_name='S')",
    "sympy.sympy.printing.pretty.pretty._print_mathieucprime": "def _print_mathieucprime(self, e):\n    return self._print_Function(e, func_name=\"C'\")",
    "sympy.sympy.printing.pretty.pretty._print_mathieusprime": "def _print_mathieusprime(self, e):\n    return self._print_Function(e, func_name=\"S'\")",
    "sympy.sympy.printing.pretty.pretty._print_ElementwiseApplyFunction": "def _print_ElementwiseApplyFunction(self, e):\n    func = e.function\n    arg = e.expr\n    args = [arg]\n    return self._helper_print_function(func, args, delimiter=\"\", elementwise=True)",
    "sympy.sympy.printing.pretty.pretty._print_FunctionClass": "def _print_FunctionClass(self, expr):\n    for cls in self._special_function_classes:\n        if issubclass(expr, cls) and expr.__name__ == cls.__name__:\n            if self._use_unicode:\n                return prettyForm(self._special_function_classes[cls][0])\n            else:\n                return prettyForm(self._special_function_classes[cls][1])\n    func_name = expr.__name__\n    return prettyForm(pretty_symbol(func_name))",
    "sympy.sympy.printing.pretty.pretty._print_GeometryEntity": "def _print_GeometryEntity(self, expr):\n    # GeometryEntity is based on Tuple but should not print like a Tuple\n    return self.emptyPrinter(expr)",
    "sympy.sympy.printing.pretty.pretty._print_polylog": "def _print_polylog(self, e):\n    subscript = self._print(e.args[0])\n    if self._use_unicode and is_subscriptable_in_unicode(subscript):\n        return self._print_Function(Function('Li_%s' % subscript)(e.args[1]))\n    return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_lerchphi": "def _print_lerchphi(self, e):\n    func_name = greek_unicode['Phi'] if self._use_unicode else 'lerchphi'\n    return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_dirichlet_eta": "def _print_dirichlet_eta(self, e):\n    func_name = greek_unicode['eta'] if self._use_unicode else 'dirichlet_eta'\n    return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_Heaviside": "def _print_Heaviside(self, e):\n    func_name = greek_unicode['theta'] if self._use_unicode else 'Heaviside'\n    if e.args[1] is S.Half:\n        pform = prettyForm(*self._print(e.args[0]).parens())\n        pform = prettyForm(*pform.left(func_name))\n        return pform\n    else:\n        return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_Reals": "def _print_Reals(self, e):\n    if self._use_unicode:\n        return self._print_Atom(e)\n    else:\n        inf_list = ['-oo', 'oo']\n        return self._print_seq(inf_list, '(', ')')",
    "sympy.sympy.printing.pretty.pretty._print_fresnels": "def _print_fresnels(self, e):\n    return self._print_Function(e, func_name=\"S\")",
    "sympy.sympy.printing.pretty.pretty._print_fresnelc": "def _print_fresnelc(self, e):\n    return self._print_Function(e, func_name=\"C\")",
    "sympy.sympy.printing.pretty.pretty._print_airyai": "def _print_airyai(self, e):\n    return self._print_Function(e, func_name=\"Ai\")",
    "sympy.sympy.printing.pretty.pretty._print_airybi": "def _print_airybi(self, e):\n    return self._print_Function(e, func_name=\"Bi\")",
    "sympy.sympy.printing.pretty.pretty._print_airyaiprime": "def _print_airyaiprime(self, e):\n    return self._print_Function(e, func_name=\"Ai'\")",
    "sympy.sympy.printing.pretty.pretty._print_airybiprime": "def _print_airybiprime(self, e):\n    return self._print_Function(e, func_name=\"Bi'\")",
    "sympy.sympy.printing.pretty.pretty._print_LambertW": "def _print_LambertW(self, e):\n    return self._print_Function(e, func_name=\"W\")",
    "sympy.sympy.printing.pretty.pretty._print_Covariance": "def _print_Covariance(self, e):\n    return self._print_Function(e, func_name=\"Cov\")",
    "sympy.sympy.printing.pretty.pretty._print_Variance": "def _print_Variance(self, e):\n    return self._print_Function(e, func_name=\"Var\")",
    "sympy.sympy.printing.pretty.pretty._print_Probability": "def _print_Probability(self, e):\n    return self._print_Function(e, func_name=\"P\")",
    "sympy.sympy.printing.pretty.pretty._print_Expectation": "def _print_Expectation(self, e):\n    return self._print_Function(e, func_name=\"E\", left='[', right=']')",
    "sympy.sympy.printing.pretty.pretty._print_Lambda": "def _print_Lambda(self, e):\n    expr = e.expr\n    sig = e.signature\n    if self._use_unicode:\n        arrow = f\" {pretty_atom('ArrowFromBar')} \"\n    else:\n        arrow = \" -> \"\n    if len(sig) == 1 and sig[0].is_symbol:\n        sig = sig[0]\n    var_form = self._print(sig)\n\n    return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)",
    "sympy.sympy.printing.pretty.pretty._print_Order": "def _print_Order(self, expr):\n    pform = self._print(expr.expr)\n    if (expr.point and any(p != S.Zero for p in expr.point)) or \\\n       len(expr.variables) > 1:\n        pform = prettyForm(*pform.right(\"; \"))\n        if len(expr.variables) > 1:\n            pform = prettyForm(*pform.right(self._print(expr.variables)))\n        elif len(expr.variables):\n            pform = prettyForm(*pform.right(self._print(expr.variables[0])))\n        if self._use_unicode:\n            pform = prettyForm(*pform.right(f\" {pretty_atom('Arrow')} \"))\n        else:\n            pform = prettyForm(*pform.right(\" -> \"))\n        if len(expr.point) > 1:\n            pform = prettyForm(*pform.right(self._print(expr.point)))\n        else:\n            pform = prettyForm(*pform.right(self._print(expr.point[0])))\n    pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left(\"O\"))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_subfactorial": "def _print_subfactorial(self, e):\n    x = e.args[0]\n    pform = self._print(x)\n    # Add parentheses if needed\n    if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):\n        pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left('!'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_SingularityFunction": "def _print_SingularityFunction(self, e):\n    if self._use_unicode:\n        shift = self._print(e.args[0]-e.args[1])\n        n = self._print(e.args[2])\n        base = prettyForm(\"<\")\n        base = prettyForm(*base.right(shift))\n        base = prettyForm(*base.right(\">\"))\n        pform = base**n\n        return pform\n    else:\n        n = self._print(e.args[2])\n        shift = self._print(e.args[0]-e.args[1])\n        base = self._print_seq(shift, \"<\", \">\", ' ')\n        return base**n",
    "sympy.sympy.printing.pretty.pretty._print_beta": "def _print_beta(self, e):\n    func_name = greek_unicode['Beta'] if self._use_unicode else 'B'\n    return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_gamma": "def _print_gamma(self, e):\n    func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'\n    return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_uppergamma": "def _print_uppergamma(self, e):\n    func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'\n    return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_lowergamma": "def _print_lowergamma(self, e):\n    func_name = greek_unicode['gamma'] if self._use_unicode else 'lowergamma'\n    return self._print_Function(e, func_name=func_name)",
    "sympy.sympy.printing.pretty.pretty._print_DiracDelta": "def _print_DiracDelta(self, e):\n    if self._use_unicode:\n        if len(e.args) == 2:\n            a = prettyForm(greek_unicode['delta'])\n            b = self._print(e.args[1])\n            b = prettyForm(*b.parens())\n            c = self._print(e.args[0])\n            c = prettyForm(*c.parens())\n            pform = a**b\n            pform = prettyForm(*pform.right(' '))\n            pform = prettyForm(*pform.right(c))\n            return pform\n        pform = self._print(e.args[0])\n        pform = prettyForm(*pform.parens())\n        pform = prettyForm(*pform.left(greek_unicode['delta']))\n        return pform\n    else:\n        return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_expint": "def _print_expint(self, e):\n    subscript = self._print(e.args[0])\n    if self._use_unicode and is_subscriptable_in_unicode(subscript):\n        return self._print_Function(Function('E_%s' % subscript)(e.args[1]))\n    return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_Chi": "def _print_Chi(self, e):\n    # This needs a special case since otherwise it comes out as greek\n    # letter chi...\n    prettyFunc = prettyForm(\"Chi\")\n    prettyArgs = prettyForm(*self._print_seq(e.args).parens())\n\n    pform = prettyForm(\n        binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))\n\n    # store pform parts so it can be reassembled e.g. when powered\n    pform.prettyFunc = prettyFunc\n    pform.prettyArgs = prettyArgs\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_elliptic_e": "def _print_elliptic_e(self, e):\n    pforma0 = self._print(e.args[0])\n    if len(e.args) == 1:\n        pform = pforma0\n    else:\n        pforma1 = self._print(e.args[1])\n        pform = self._hprint_vseparator(pforma0, pforma1)\n    pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left('E'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_factorial": "def _print_factorial(self, e):\n    x = e.args[0]\n    pform = self._print(x)\n    # Add parentheses if needed\n    if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):\n        pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.right('!'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_elliptic_k": "def _print_elliptic_k(self, e):\n    pform = self._print(e.args[0])\n    pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left('K'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_elliptic_f": "def _print_elliptic_f(self, e):\n    pforma0 = self._print(e.args[0])\n    pforma1 = self._print(e.args[1])\n    pform = self._hprint_vseparator(pforma0, pforma1)\n    pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left('F'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_elliptic_pi": "def _print_elliptic_pi(self, e):\n    name = greek_unicode['Pi'] if self._use_unicode else 'Pi'\n    pforma0 = self._print(e.args[0])\n    pforma1 = self._print(e.args[1])\n    if len(e.args) == 2:\n        pform = self._hprint_vseparator(pforma0, pforma1)\n    else:\n        pforma2 = self._print(e.args[2])\n        pforma = self._hprint_vseparator(pforma1, pforma2, ifascii_nougly=False)\n        pforma = prettyForm(*pforma.left('; '))\n        pform = prettyForm(*pforma.left(pforma0))\n    pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left(name))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_symbol('phi'))\n    return self._print(Symbol(\"GoldenRatio\"))",
    "sympy.sympy.printing.pretty.pretty._print_EulerGamma": "def _print_EulerGamma(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_symbol('gamma'))\n    return self._print(Symbol(\"EulerGamma\"))",
    "sympy.sympy.printing.pretty.pretty._print_Catalan": "def _print_Catalan(self, expr):\n    return self._print(Symbol(\"G\"))",
    "sympy.sympy.printing.pretty.pretty._print_Mod": "def _print_Mod(self, expr):\n    pform = self._print(expr.args[0])\n    if pform.binding > prettyForm.MUL:\n        pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.right(' mod '))\n    pform = prettyForm(*pform.right(self._print(expr.args[1])))\n    pform.binding = prettyForm.OPEN\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Add": "def _print_Add(self, expr, order=None):\n    terms = self._as_ordered_terms(expr, order=order)\n    pforms, indices = [], []\n\n    def pretty_negative(pform, index):\n        \"\"\"Prepend a minus sign to a pretty form. \"\"\"\n        #TODO: Move this code to prettyForm\n        if index == 0:\n            if pform.height() > 1:\n                pform_neg = '- '\n            else:\n                pform_neg = '-'\n        else:\n            pform_neg = ' - '\n\n        if (pform.binding > prettyForm.NEG\n            or pform.binding == prettyForm.ADD):\n            p = stringPict(*pform.parens())\n        else:\n            p = pform\n        p = stringPict.next(pform_neg, p)\n        # Lower the binding to NEG, even if it was higher. Otherwise, it\n        # will print as a + ( - (b)), instead of a - (b).\n        return prettyForm(binding=prettyForm.NEG, *p)\n\n    for i, term in enumerate(terms):\n        if term.is_Mul and term.could_extract_minus_sign():\n            coeff, other = term.as_coeff_mul(rational=False)\n            if coeff == -1:\n                negterm = Mul(*other, evaluate=False)\n            else:\n                negterm = Mul(-coeff, *other, evaluate=False)\n            pform = self._print(negterm)\n            pforms.append(pretty_negative(pform, i))\n        elif term.is_Rational and term.q > 1:\n            pforms.append(None)\n            indices.append(i)\n        elif term.is_Number and term < 0:\n            pform = self._print(-term)\n            pforms.append(pretty_negative(pform, i))\n        elif term.is_Relational:\n            pforms.append(prettyForm(*self._print(term).parens()))\n        else:\n            pforms.append(self._print(term))\n\n    if indices:\n        large = True\n\n        for pform in pforms:\n            if pform is not None and pform.height() > 1:\n                break\n        else:\n            large = False\n\n        for i in indices:\n            term, negative = terms[i], False\n\n            if term < 0:\n                term, negative = -term, True\n\n            if large:\n                pform = prettyForm(str(term.p))/prettyForm(str(term.q))\n            else:\n                pform = self._print(term)\n\n            if negative:\n                pform = pretty_negative(pform, i)\n\n            pforms[i] = pform\n\n    return prettyForm.__add__(*pforms)",
    "sympy.sympy.printing.pretty.pretty._print_factorial2": "def _print_factorial2(self, e):\n    x = e.args[0]\n    pform = self._print(x)\n    # Add parentheses if needed\n    if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):\n        pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.right('!!'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Mul": "def _print_Mul(self, product):\n    from sympy.physics.units import Quantity\n\n    # Check for unevaluated Mul. In this case we need to make sure the\n    # identities are visible, multiple Rational factors are not combined\n    # etc so we display in a straight-forward form that fully preserves all\n    # args and their order.\n    args = product.args\n    if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):\n        strargs = list(map(self._print, args))\n        # XXX: This is a hack to work around the fact that\n        # prettyForm.__mul__ absorbs a leading -1 in the args. Probably it\n        # would be better to fix this in prettyForm.__mul__ instead.\n        negone = strargs[0] == '-1'\n        if negone:\n            strargs[0] = prettyForm('1', 0, 0)\n        obj = prettyForm.__mul__(*strargs)\n        if negone:\n            obj = prettyForm('-' + obj.s, obj.baseline, obj.binding)\n        return obj\n\n    a = []  # items in the numerator\n    b = []  # items that are in the denominator (if any)\n\n    if self.order not in ('old', 'none'):\n        args = product.as_ordered_factors()\n    else:\n        args = list(product.args)\n\n    # If quantities are present append them at the back\n    args = sorted(args, key=lambda x: isinstance(x, Quantity) or\n                 (isinstance(x, Pow) and isinstance(x.base, Quantity)))\n\n    # Gather terms for numerator/denominator\n    for item in args:\n        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                b.append(Pow(item.base, -item.exp))\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append( Rational(item.p) )\n            if item.q != 1:\n                b.append( Rational(item.q) )\n        else:\n            a.append(item)\n\n    # Convert to pretty forms. Parentheses are added by `__mul__`.\n    a = [self._print(ai) for ai in a]\n    b = [self._print(bi) for bi in b]\n\n    # Construct a pretty form\n    if len(b) == 0:\n        return prettyForm.__mul__(*a)\n    else:\n        if len(a) == 0:\n            a.append( self._print(S.One) )\n        return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)",
    "sympy.sympy.printing.pretty.pretty._print_binomial": "def _print_binomial(self, e):\n    n, k = e.args\n\n    n_pform = self._print(n)\n    k_pform = self._print(k)\n\n    bar = ' '*max(n_pform.width(), k_pform.width())\n\n    pform = prettyForm(*k_pform.above(bar))\n    pform = prettyForm(*pform.above(n_pform))\n    pform = prettyForm(*pform.parens('(', ')'))\n\n    pform.baseline = (pform.baseline + 1)//2\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Pow": "def _print_Pow(self, power):\n    from sympy.simplify.simplify import fraction\n    b, e = power.as_base_exp()\n    if power.is_commutative:\n        if e is S.NegativeOne:\n            return prettyForm(\"1\")/self._print(b)\n        n, d = fraction(e)\n        if n is S.One and d.is_Atom and not e.is_Integer and (e.is_Rational or d.is_Symbol) \\\n                and self._settings['root_notation']:\n            return self._print_nth_root(b, d)\n        if e.is_Rational and e < 0:\n            return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n\n    if b.is_Relational:\n        return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n\n    return self._print(b)**self._print(e)",
    "sympy.sympy.printing.pretty.pretty._print_UnevaluatedExpr": "def _print_UnevaluatedExpr(self, expr):\n    return self._print(expr.args[0])",
    "sympy.sympy.printing.pretty.pretty._print_Rational": "def _print_Rational(self, expr):\n    result = self.__print_numer_denom(expr.p, expr.q)\n\n    if result is not None:\n        return result\n    else:\n        return self.emptyPrinter(expr)",
    "sympy.sympy.printing.pretty.pretty._print_ProductSet": "def _print_ProductSet(self, p):\n    if len(p.sets) >= 1 and not has_variety(p.sets):\n        return self._print(p.sets[0]) ** self._print(len(p.sets))\n    else:\n        prod_char = pretty_atom('Multiplication') if self._use_unicode else 'x'\n        return self._print_seq(p.sets, None, None, ' %s ' % prod_char,\n                               parenthesize=lambda set: set.is_Union or\n                               set.is_Intersection or set.is_ProductSet)",
    "sympy.sympy.printing.pretty.pretty._print_FiniteSet": "def _print_FiniteSet(self, s):\n    items = sorted(s.args, key=default_sort_key)\n    return self._print_seq(items, '{', '}', ', ' )",
    "sympy.sympy.printing.pretty.pretty._print_Range": "def _print_Range(self, s):\n\n    if self._use_unicode:\n        dots = pretty_atom('Dots')\n    else:\n        dots = '...'\n\n    if s.start.is_infinite and s.stop.is_infinite:\n        if s.step.is_positive:\n            printset = dots, -1, 0, 1, dots\n        else:\n            printset = dots, 1, 0, -1, dots\n    elif s.start.is_infinite:\n        printset = dots, s[-1] - s.step, s[-1]\n    elif s.stop.is_infinite:\n        it = iter(s)\n        printset = next(it), next(it), dots\n    elif len(s) > 4:\n        it = iter(s)\n        printset = next(it), next(it), dots, s[-1]\n    else:\n        printset = tuple(s)\n\n    return self._print_seq(printset, '{', '}', ', ' )",
    "sympy.sympy.printing.pretty.pretty._print_Interval": "def _print_Interval(self, i):\n    if i.start == i.end:\n        return self._print_seq(i.args[:1], '{', '}')\n\n    else:\n        if i.left_open:\n            left = '('\n        else:\n            left = '['\n\n        if i.right_open:\n            right = ')'\n        else:\n            right = ']'\n\n        return self._print_seq(i.args[:2], left, right)",
    "sympy.sympy.printing.pretty.pretty._print_Relational": "def _print_Relational(self, e):\n    op = prettyForm(' ' + xsym(e.rel_op) + ' ')\n\n    l = self._print(e.lhs)\n    r = self._print(e.rhs)\n    pform = prettyForm(*stringPict.next(l, op, r), binding=prettyForm.OPEN)\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Intersection": "def _print_Intersection(self, u):\n\n    delimiter = ' %s ' % pretty_atom('Intersection', 'n')\n\n    return self._print_seq(u.args, None, None, delimiter,\n                           parenthesize=lambda set: set.is_ProductSet or\n                           set.is_Union or set.is_Complement)",
    "sympy.sympy.printing.pretty.pretty._print_Union": "def _print_Union(self, u):\n\n    union_delimiter = ' %s ' % pretty_atom('Union', 'U')\n\n    return self._print_seq(u.args, None, None, union_delimiter,\n                           parenthesize=lambda set: set.is_ProductSet or\n                           set.is_Intersection or set.is_Complement)",
    "sympy.sympy.printing.pretty.pretty._print_SymmetricDifference": "def _print_SymmetricDifference(self, u):\n    if not self._use_unicode:\n        raise NotImplementedError(\"ASCII pretty printing of SymmetricDifference is not implemented\")\n\n    sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')\n\n    return self._print_seq(u.args, None, None, sym_delimeter)",
    "sympy.sympy.printing.pretty.pretty._print_Complement": "def _print_Complement(self, u):\n\n    delimiter = r' \\ '\n\n    return self._print_seq(u.args, None, None, delimiter,\n         parenthesize=lambda set: set.is_ProductSet or set.is_Intersection\n                           or set.is_Union)",
    "sympy.sympy.printing.pretty.pretty._print_ImageSet": "def _print_ImageSet(self, ts):\n    if self._use_unicode:\n        inn = pretty_atom(\"SmallElementOf\")\n    else:\n        inn = 'in'\n    fun = ts.lamda\n    sets = ts.base_sets\n    signature = fun.signature\n    expr = self._print(fun.expr)\n\n    # TODO: the stuff to the left of the | and the stuff to the right of\n    # the | should have independent baselines, that way something like\n    # ImageSet(Lambda(x, 1/x**2), S.Naturals) prints the \"x in N\" part\n    # centered on the right instead of aligned with the fraction bar on\n    # the left. The same also applies to ConditionSet and ComplexRegion\n    if len(signature) == 1:\n        S = self._print_seq((signature[0], inn, sets[0]),\n                            delimiter=' ')\n        return self._hprint_vseparator(expr, S,\n                                       left='{', right='}',\n                                       ifascii_nougly=True, delimiter=' ')\n    else:\n        pargs = tuple(j for var, setv in zip(signature, sets) for j in\n                      (var, ' ', inn, ' ', setv, \", \"))\n        S = self._print_seq(pargs[:-1], delimiter='')\n        return self._hprint_vseparator(expr, S,\n                                       left='{', right='}',\n                                       ifascii_nougly=True, delimiter=' ')",
    "sympy.sympy.printing.pretty.pretty._print_ConditionSet": "def _print_ConditionSet(self, ts):\n    if self._use_unicode:\n        inn = pretty_atom('SmallElementOf')\n        # using _and because and is a keyword and it is bad practice to\n        # overwrite them\n        _and = pretty_atom('And')\n    else:\n        inn = 'in'\n        _and = 'and'\n\n    variables = self._print_seq(Tuple(ts.sym))\n    as_expr = getattr(ts.condition, 'as_expr', None)\n    if as_expr is not None:\n        cond = self._print(ts.condition.as_expr())\n    else:\n        cond = self._print(ts.condition)\n        if self._use_unicode:\n            cond = self._print(cond)\n            cond = prettyForm(*cond.parens())\n\n    if ts.base_set is S.UniversalSet:\n        return self._hprint_vseparator(variables, cond, left=\"{\",\n                                       right=\"}\", ifascii_nougly=True,\n                                       delimiter=' ')\n\n    base = self._print(ts.base_set)\n    C = self._print_seq((variables, inn, base, _and, cond),\n                        delimiter=' ')\n    return self._hprint_vseparator(variables, C, left=\"{\", right=\"}\",\n                                   ifascii_nougly=True, delimiter=' ')",
    "sympy.sympy.printing.pretty.pretty._print_Not": "def _print_Not(self, e):\n    from sympy.logic.boolalg import (Equivalent, Implies)\n    if self._use_unicode:\n        arg = e.args[0]\n        pform = self._print(arg)\n        if isinstance(arg, Equivalent):\n            return self._print_Equivalent(arg, altchar=pretty_atom('NotEquiv'))\n        if isinstance(arg, Implies):\n            return self._print_Implies(arg, altchar=pretty_atom('NotArrow'))\n\n        if arg.is_Boolean and not arg.is_Not:\n            pform = prettyForm(*pform.parens())\n\n        return prettyForm(*pform.left(pretty_atom('Not')))\n    else:\n        return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_ComplexRegion": "def _print_ComplexRegion(self, ts):\n    if self._use_unicode:\n        inn = pretty_atom('SmallElementOf')\n    else:\n        inn = 'in'\n    variables = self._print_seq(ts.variables)\n    expr = self._print(ts.expr)\n    prodsets = self._print(ts.sets)\n\n    C = self._print_seq((variables, inn, prodsets),\n                        delimiter=' ')\n    return self._hprint_vseparator(expr, C, left=\"{\", right=\"}\",\n                                   ifascii_nougly=True, delimiter=' ')",
    "sympy.sympy.printing.pretty.pretty._print_Contains": "def _print_Contains(self, e):\n    var, set = e.args\n    if self._use_unicode:\n        el = f\" {pretty_atom('ElementOf')} \"\n        return prettyForm(*stringPict.next(self._print(var),\n                                           el, self._print(set)), binding=8)\n    else:\n        return prettyForm(sstr(e))",
    "sympy.sympy.printing.pretty.pretty._print_FourierSeries": "def _print_FourierSeries(self, s):\n    if s.an.formula is S.Zero and s.bn.formula is S.Zero:\n        return self._print(s.a0)\n    if self._use_unicode:\n        dots = pretty_atom('Dots')\n    else:\n        dots = '...'\n    return self._print_Add(s.truncate()) + self._print(dots)",
    "sympy.sympy.printing.pretty.pretty._print_FormalPowerSeries": "def _print_FormalPowerSeries(self, s):\n    return self._print_Add(s.infinite)",
    "sympy.sympy.printing.pretty.pretty._print_SetExpr": "def _print_SetExpr(self, se):\n    pretty_set = prettyForm(*self._print(se.set).parens())\n    pretty_name = self._print(Symbol(\"SetExpr\"))\n    return prettyForm(*pretty_name.right(pretty_set))",
    "sympy.sympy.printing.pretty.pretty._print_SeqFormula": "def _print_SeqFormula(self, s):\n    if self._use_unicode:\n        dots = pretty_atom('Dots')\n    else:\n        dots = '...'\n\n    if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:\n        raise NotImplementedError(\"Pretty printing of sequences with symbolic bound not implemented\")\n\n    if s.start is S.NegativeInfinity:\n        stop = s.stop\n        printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),\n            s.coeff(stop - 1), s.coeff(stop))\n    elif s.stop is S.Infinity or s.length > 4:\n        printset = s[:4]\n        printset.append(dots)\n        printset = tuple(printset)\n    else:\n        printset = tuple(s)\n    return self._print_list(printset)",
    "sympy.sympy.printing.pretty.pretty._print_list": "def _print_list(self, l):\n    return self._print_seq(l, '[', ']')",
    "sympy.sympy.printing.pretty.pretty._print_tuple": "def _print_tuple(self, t):\n    if len(t) == 1:\n        ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))\n        return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))\n    else:\n        return self._print_seq(t, '(', ')')",
    "sympy.sympy.printing.pretty.pretty._print_Tuple": "def _print_Tuple(self, expr):\n    return self._print_tuple(expr)",
    "sympy.sympy.printing.pretty.pretty._print_dict": "def _print_dict(self, d):\n    keys = sorted(d.keys(), key=default_sort_key)\n    items = []\n\n    for k in keys:\n        K = self._print(k)\n        V = self._print(d[k])\n        s = prettyForm(*stringPict.next(K, ': ', V))\n\n        items.append(s)\n\n    return self._print_seq(items, '{', '}')",
    "sympy.sympy.printing.pretty.pretty._print_Dict": "def _print_Dict(self, d):\n    return self._print_dict(d)",
    "sympy.sympy.printing.pretty.pretty._print_set": "def _print_set(self, s):\n    if not s:\n        return prettyForm('set()')\n    items = sorted(s, key=default_sort_key)\n    pretty = self._print_seq(items)\n    pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))\n    return pretty",
    "sympy.sympy.printing.pretty.pretty._print_frozenset": "def _print_frozenset(self, s):\n    if not s:\n        return prettyForm('frozenset()')\n    items = sorted(s, key=default_sort_key)\n    pretty = self._print_seq(items)\n    pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))\n    pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))\n    pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))\n    return pretty",
    "sympy.sympy.printing.pretty.pretty._print_UniversalSet": "def _print_UniversalSet(self, s):\n    if self._use_unicode:\n        return prettyForm(pretty_atom('Universe'))\n    else:\n        return prettyForm('UniversalSet')",
    "sympy.sympy.printing.pretty.pretty._print_PolyElement": "def _print_PolyElement(self, poly):\n    return prettyForm(sstr(poly))",
    "sympy.sympy.printing.pretty.pretty._print_FracElement": "def _print_FracElement(self, frac):\n    return prettyForm(sstr(frac))",
    "sympy.sympy.printing.pretty.pretty._print_ComplexRootOf": "def _print_ComplexRootOf(self, expr):\n    args = [self._print_Add(expr.expr, order='lex'), expr.index]\n    pform = prettyForm(*self._print_seq(args).parens())\n    pform = prettyForm(*pform.left('CRootOf'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_RootSum": "def _print_RootSum(self, expr):\n    args = [self._print_Add(expr.expr, order='lex')]\n\n    if expr.fun is not S.IdentityFunction:\n        args.append(self._print(expr.fun))\n\n    pform = prettyForm(*self._print_seq(args).parens())\n    pform = prettyForm(*pform.left('RootSum'))\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_FiniteField": "def _print_FiniteField(self, expr):\n    if self._use_unicode:\n        form = f\"{pretty_atom('Integers')}_%d\"\n    else:\n        form = 'GF(%d)'\n\n    return prettyForm(pretty_symbol(form % expr.mod))",
    "sympy.sympy.printing.pretty.pretty._print_IntegerRing": "def _print_IntegerRing(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_atom('Integers'))\n    else:\n        return prettyForm('ZZ')",
    "sympy.sympy.printing.pretty.pretty._print_RationalField": "def _print_RationalField(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_atom('Rationals'))\n    else:\n        return prettyForm('QQ')",
    "sympy.sympy.printing.pretty.pretty._print_RealField": "def _print_RealField(self, domain):\n    if self._use_unicode:\n        prefix = pretty_atom(\"Reals\")\n    else:\n        prefix = 'RR'\n\n    if domain.has_default_precision:\n        return prettyForm(prefix)\n    else:\n        return self._print(pretty_symbol(prefix + \"_\" + str(domain.precision)))",
    "sympy.sympy.printing.pretty.pretty._print_PolynomialRing": "def _print_PolynomialRing(self, expr):\n    args = list(expr.symbols)\n\n    if not expr.order.is_default:\n        order = prettyForm(*prettyForm(\"order=\").right(self._print(expr.order)))\n        args.append(order)\n\n    pform = self._print_seq(args, '[', ']')\n    pform = prettyForm(*pform.left(self._print(expr.domain)))\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_FractionField": "def _print_FractionField(self, expr):\n    args = list(expr.symbols)\n\n    if not expr.order.is_default:\n        order = prettyForm(*prettyForm(\"order=\").right(self._print(expr.order)))\n        args.append(order)\n\n    pform = self._print_seq(args, '(', ')')\n    pform = prettyForm(*pform.left(self._print(expr.domain)))\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_PolynomialRingBase": "def _print_PolynomialRingBase(self, expr):\n    g = expr.symbols\n    if str(expr.order) != str(expr.default_order):\n        g = g + (\"order=\" + str(expr.order),)\n    pform = self._print_seq(g, '[', ']')\n    pform = prettyForm(*pform.left(self._print(expr.domain)))\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_GroebnerBasis": "def _print_GroebnerBasis(self, basis):\n    exprs = [ self._print_Add(arg, order=basis.order)\n              for arg in basis.exprs ]\n    exprs = prettyForm(*self.join(\", \", exprs).parens(left=\"[\", right=\"]\"))\n\n    gens = [ self._print(gen) for gen in basis.gens ]\n\n    domain = prettyForm(\n        *prettyForm(\"domain=\").right(self._print(basis.domain)))\n    order = prettyForm(\n        *prettyForm(\"order=\").right(self._print(basis.order)))\n\n    pform = self.join(\", \", [exprs] + gens + [domain, order])\n\n    pform = prettyForm(*pform.parens())\n    pform = prettyForm(*pform.left(basis.__class__.__name__))\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Subs": "def _print_Subs(self, e):\n    pform = self._print(e.expr)\n    pform = prettyForm(*pform.parens())\n\n    h = pform.height() if pform.height() > 1 else 2\n    rvert = stringPict(vobj('|', h), baseline=pform.baseline)\n    pform = prettyForm(*pform.right(rvert))\n\n    b = pform.baseline\n    pform.baseline = pform.height() - 1\n    pform = prettyForm(*pform.right(self._print_seq([\n        self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),\n            delimiter='') for v in zip(e.variables, e.point) ])))\n\n    pform.baseline = b\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_euler": "def _print_euler(self, e):\n    return self._print_number_function(e, \"E\")",
    "sympy.sympy.printing.pretty.pretty._print_catalan": "def _print_catalan(self, e):\n    return self._print_number_function(e, \"C\")",
    "sympy.sympy.printing.pretty.pretty._print_bernoulli": "def _print_bernoulli(self, e):\n    return self._print_number_function(e, \"B\")",
    "sympy.sympy.printing.pretty.pretty._print_lucas": "def _print_lucas(self, e):\n    return self._print_number_function(e, \"L\")",
    "sympy.sympy.printing.pretty.pretty._print_fibonacci": "def _print_fibonacci(self, e):\n    return self._print_number_function(e, \"F\")",
    "sympy.sympy.printing.pretty.pretty._print_tribonacci": "def _print_tribonacci(self, e):\n    return self._print_number_function(e, \"T\")",
    "sympy.sympy.printing.pretty.pretty._print_stieltjes": "def _print_stieltjes(self, e):\n    if self._use_unicode:\n        return self._print_number_function(e, greek_unicode['gamma'])\n    else:\n        return self._print_number_function(e, \"stieltjes\")",
    "sympy.sympy.printing.pretty.pretty._print_KroneckerDelta": "def _print_KroneckerDelta(self, e):\n    pform = self._print(e.args[0])\n    pform = prettyForm(*pform.right(prettyForm(',')))\n    pform = prettyForm(*pform.right(self._print(e.args[1])))\n    if self._use_unicode:\n        a = stringPict(pretty_symbol('delta'))\n    else:\n        a = stringPict('d')\n    b = pform\n    top = stringPict(*b.left(' '*a.width()))\n    bot = stringPict(*a.right(' '*b.width()))\n    return prettyForm(binding=prettyForm.POW, *bot.below(top))",
    "sympy.sympy.printing.pretty.pretty._print_RandomDomain": "def _print_RandomDomain(self, d):\n    if hasattr(d, 'as_boolean'):\n        pform = self._print('Domain: ')\n        pform = prettyForm(*pform.right(self._print(d.as_boolean())))\n        return pform\n    elif hasattr(d, 'set'):\n        pform = self._print('Domain: ')\n        pform = prettyForm(*pform.right(self._print(d.symbols)))\n        pform = prettyForm(*pform.right(self._print(' in ')))\n        pform = prettyForm(*pform.right(self._print(d.set)))\n        return pform\n    elif hasattr(d, 'symbols'):\n        pform = self._print('Domain on ')\n        pform = prettyForm(*pform.right(self._print(d.symbols)))\n        return pform\n    else:\n        return self._print(None)",
    "sympy.sympy.printing.pretty.pretty._print_And": "def _print_And(self, e):\n    if self._use_unicode:\n        return self.__print_Boolean(e, pretty_atom('And'))\n    else:\n        return self._print_Function(e, sort=True)",
    "sympy.sympy.printing.pretty.pretty._print_Object": "def _print_Object(self, object):\n    return self._print(pretty_symbol(object.name))",
    "sympy.sympy.printing.pretty.pretty._print_NamedMorphism": "def _print_NamedMorphism(self, morphism):\n    pretty_name = self._print(pretty_symbol(morphism.name))\n    pretty_morphism = self._print_Morphism(morphism)\n    return prettyForm(pretty_name.right(\":\", pretty_morphism)[0])",
    "sympy.sympy.printing.pretty.pretty._print_IdentityMorphism": "def _print_IdentityMorphism(self, morphism):\n    from sympy.categories import NamedMorphism\n    return self._print_NamedMorphism(\n        NamedMorphism(morphism.domain, morphism.codomain, \"id\"))",
    "sympy.sympy.printing.pretty.pretty._print_CompositeMorphism": "def _print_CompositeMorphism(self, morphism):\n\n    circle = xsym(\".\")\n\n    # All components of the morphism have names and it is thus\n    # possible to build the name of the composite.\n    component_names_list = [pretty_symbol(component.name) for\n                            component in morphism.components]\n    component_names_list.reverse()\n    component_names = circle.join(component_names_list) + \":\"\n\n    pretty_name = self._print(component_names)\n    pretty_morphism = self._print_Morphism(morphism)\n    return prettyForm(pretty_name.right(pretty_morphism)[0])",
    "sympy.sympy.printing.pretty.pretty._print_Or": "def _print_Or(self, e):\n    if self._use_unicode:\n        return self.__print_Boolean(e, pretty_atom('Or'))\n    else:\n        return self._print_Function(e, sort=True)",
    "sympy.sympy.printing.pretty.pretty._print_Category": "def _print_Category(self, category):\n    return self._print(pretty_symbol(category.name))",
    "sympy.sympy.printing.pretty.pretty._print_Diagram": "def _print_Diagram(self, diagram):\n    if not diagram.premises:\n        # This is an empty diagram.\n        return self._print(S.EmptySet)\n\n    pretty_result = self._print(diagram.premises)\n    if diagram.conclusions:\n        results_arrow = \" %s \" % xsym(\"==>\")\n\n        pretty_conclusions = self._print(diagram.conclusions)[0]\n        pretty_result = pretty_result.right(\n            results_arrow, pretty_conclusions)\n\n    return prettyForm(pretty_result[0])",
    "sympy.sympy.printing.pretty.pretty._print_DiagramGrid": "def _print_DiagramGrid(self, grid):\n    from sympy.matrices import Matrix\n    matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(\" \")\n                      for j in range(grid.width)]\n                     for i in range(grid.height)])\n    return self._print_matrix_contents(matrix)",
    "sympy.sympy.printing.pretty.pretty._print_SubModule": "def _print_SubModule(self, M):\n    gens = [[M.ring.to_sympy(g) for g in gen] for gen in M.gens]\n    return self._print_seq(gens, '<', '>')",
    "sympy.sympy.printing.pretty.pretty._print_FreeModule": "def _print_FreeModule(self, M):\n    return self._print(M.ring)**self._print(M.rank)",
    "sympy.sympy.printing.pretty.pretty._print_ModuleImplementedIdeal": "def _print_ModuleImplementedIdeal(self, M):\n    sym = M.ring.to_sympy\n    return self._print_seq([sym(x) for [x] in M._module.gens], '<', '>')",
    "sympy.sympy.printing.pretty.pretty._print_QuotientRing": "def _print_QuotientRing(self, R):\n    return self._print(R.ring) / self._print(R.base_ideal)",
    "sympy.sympy.printing.pretty.pretty._print_QuotientRingElement": "def _print_QuotientRingElement(self, R):\n    return self._print(R.ring.to_sympy(R)) + self._print(R.ring.base_ideal)",
    "sympy.sympy.printing.pretty.pretty._print_QuotientModule": "def _print_QuotientModule(self, M):\n    return self._print(M.base) / self._print(M.killed_module)",
    "sympy.sympy.printing.pretty.pretty._print_MatrixHomomorphism": "def _print_MatrixHomomorphism(self, h):\n    matrix = self._print(h._sympy_matrix())\n    matrix.baseline = matrix.height() // 2\n    pform = prettyForm(*matrix.right(' : ', self._print(h.domain),\n        ' %s> ' % hobj('-', 2), self._print(h.codomain)))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Xor": "def _print_Xor(self, e):\n    if self._use_unicode:\n        return self.__print_Boolean(e, pretty_atom(\"Xor\"))\n    else:\n        return self._print_Function(e, sort=True)",
    "sympy.sympy.printing.pretty.pretty._print_Manifold": "def _print_Manifold(self, manifold):\n    return self._print(manifold.name)",
    "sympy.sympy.printing.pretty.pretty._print_Patch": "def _print_Patch(self, patch):\n    return self._print(patch.name)",
    "sympy.sympy.printing.pretty.pretty._print_CoordSystem": "def _print_CoordSystem(self, coords):\n    return self._print(coords.name)",
    "sympy.sympy.printing.pretty.pretty._print_BaseScalarField": "def _print_BaseScalarField(self, field):\n    string = field._coord_sys.symbols[field._index].name\n    return self._print(pretty_symbol(string))",
    "sympy.sympy.printing.pretty.pretty._print_Differential": "def _print_Differential(self, diff):\n    if self._use_unicode:\n        d = pretty_atom('Differential')\n    else:\n        d = 'd'\n    field = diff._form_field\n    if hasattr(field, '_coord_sys'):\n        string = field._coord_sys.symbols[field._index].name\n        return self._print(d + ' ' + pretty_symbol(string))\n    else:\n        pform = self._print(field)\n        pform = prettyForm(*pform.parens())\n        return prettyForm(*pform.left(d))",
    "sympy.sympy.printing.pretty.pretty._print_Tr": "def _print_Tr(self, p):\n    #TODO: Handle indices\n    pform = self._print(p.args[0])\n    pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))\n    pform = prettyForm(*pform.right(')'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_primenu": "def _print_primenu(self, e):\n    pform = self._print(e.args[0])\n    pform = prettyForm(*pform.parens())\n    if self._use_unicode:\n        pform = prettyForm(*pform.left(greek_unicode['nu']))\n    else:\n        pform = prettyForm(*pform.left('nu'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_primeomega": "def _print_primeomega(self, e):\n    pform = self._print(e.args[0])\n    pform = prettyForm(*pform.parens())\n    if self._use_unicode:\n        pform = prettyForm(*pform.left(greek_unicode['Omega']))\n    else:\n        pform = prettyForm(*pform.left('Omega'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Quantity": "def _print_Quantity(self, e):\n    if e.name.name == 'degree':\n        if self._use_unicode:\n            pform = self._print(pretty_atom('Degree'))\n        else:\n            pform = self._print(chr(176))\n        return pform\n    else:\n        return self.emptyPrinter(e)",
    "sympy.sympy.printing.pretty.pretty._print_Nand": "def _print_Nand(self, e):\n    if self._use_unicode:\n        return self.__print_Boolean(e, pretty_atom('Nand'))\n    else:\n        return self._print_Function(e, sort=True)",
    "sympy.sympy.printing.pretty.pretty._print_AssignmentBase": "def _print_AssignmentBase(self, e):\n\n    op = prettyForm(' ' + xsym(e.op) + ' ')\n\n    l = self._print(e.lhs)\n    r = self._print(e.rhs)\n    pform = prettyForm(*stringPict.next(l, op, r))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Str": "def _print_Str(self, s):\n    return self._print(s.name)",
    "sympy.sympy.printing.pretty.pretty._print_Nor": "def _print_Nor(self, e):\n    if self._use_unicode:\n        return self.__print_Boolean(e, pretty_atom('Nor'))\n    else:\n        return self._print_Function(e, sort=True)",
    "sympy.sympy.printing.pretty.pretty._print_Implies": "def _print_Implies(self, e, altchar=None):\n    if self._use_unicode:\n        return self.__print_Boolean(e, altchar or pretty_atom('Arrow'), sort=False)\n    else:\n        return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_Equivalent": "def _print_Equivalent(self, e, altchar=None):\n    if self._use_unicode:\n        return self.__print_Boolean(e, altchar or pretty_atom('Equiv'))\n    else:\n        return self._print_Function(e, sort=True)",
    "sympy.sympy.printing.pretty.pretty._print_conjugate": "def _print_conjugate(self, e):\n    pform = self._print(e.args[0])\n    return prettyForm( *pform.above( hobj('_', pform.width())) )",
    "sympy.sympy.printing.pretty.pretty._print_Abs": "def _print_Abs(self, e):\n    pform = self._print(e.args[0])\n    pform = prettyForm(*pform.parens('|', '|'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_floor": "def _print_floor(self, e):\n    if self._use_unicode:\n        pform = self._print(e.args[0])\n        pform = prettyForm(*pform.parens('lfloor', 'rfloor'))\n        return pform\n    else:\n        return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_ceiling": "def _print_ceiling(self, e):\n    if self._use_unicode:\n        pform = self._print(e.args[0])\n        pform = prettyForm(*pform.parens('lceil', 'rceil'))\n        return pform\n    else:\n        return self._print_Function(e)",
    "sympy.sympy.printing.pretty.pretty._print_Derivative": "def _print_Derivative(self, deriv):\n    if requires_partial(deriv.expr) and self._use_unicode:\n        deriv_symbol = U('PARTIAL DIFFERENTIAL')\n    else:\n        deriv_symbol = r'd'\n    x = None\n    count_total_deriv = 0\n\n    for sym, num in reversed(deriv.variable_count):\n        s = self._print(sym)\n        ds = prettyForm(*s.left(deriv_symbol))\n        count_total_deriv += num\n\n        if (not num.is_Integer) or (num > 1):\n            ds = ds**prettyForm(str(num))\n\n        if x is None:\n            x = ds\n        else:\n            x = prettyForm(*x.right(' '))\n            x = prettyForm(*x.right(ds))\n\n    f = prettyForm(\n        binding=prettyForm.FUNC, *self._print(deriv.expr).parens())\n\n    pform = prettyForm(deriv_symbol)\n\n    if (count_total_deriv > 1) != False:\n        pform = pform**prettyForm(str(count_total_deriv))\n\n    pform = prettyForm(*pform.below(stringPict.LINE, x))\n    pform.baseline = pform.baseline + 1\n    pform = prettyForm(*stringPict.next(pform, f))\n    pform.binding = prettyForm.MUL\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Cycle": "def _print_Cycle(self, dc):\n    from sympy.combinatorics.permutations import Permutation, Cycle\n    # for Empty Cycle\n    if dc == Cycle():\n        cyc = stringPict('')\n        return prettyForm(*cyc.parens())\n\n    dc_list = Permutation(dc.list()).cyclic_form\n    # for Identity Cycle\n    if dc_list == []:\n        cyc = self._print(dc.size - 1)\n        return prettyForm(*cyc.parens())\n\n    cyc = stringPict('')\n    for i in dc_list:\n        l = self._print(str(tuple(i)).replace(',', ''))\n        cyc = prettyForm(*cyc.right(l))\n    return cyc",
    "sympy.sympy.printing.pretty.pretty._print_Permutation": "def _print_Permutation(self, expr):\n    from sympy.combinatorics.permutations import Permutation, Cycle\n\n    perm_cyclic = Permutation.print_cyclic\n    if perm_cyclic is not None:\n        sympy_deprecation_warning(\n            f\"\"\"\n            Setting Permutation.print_cyclic is deprecated. Instead use\n            init_printing(perm_cyclic={perm_cyclic}).\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-permutation-print_cyclic\",\n            stacklevel=7,\n        )\n    else:\n        perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n    if perm_cyclic:\n        return self._print_Cycle(Cycle(expr))\n\n    lower = expr.array_form\n    upper = list(range(len(lower)))\n\n    result = stringPict('')\n    first = True\n    for u, l in zip(upper, lower):\n        s1 = self._print(u)\n        s2 = self._print(l)\n        col = prettyForm(*s1.below(s2))\n        if first:\n            first = False\n        else:\n            col = prettyForm(*col.left(\" \"))\n        result = prettyForm(*result.right(col))\n    return prettyForm(*result.parens())",
    "sympy.sympy.printing.pretty.pretty._print_Integral": "def _print_Integral(self, integral):\n    f = integral.function\n\n    # Add parentheses if arg involves addition of terms and\n    # create a pretty form for the argument\n    prettyF = self._print(f)\n    # XXX generalize parens\n    if f.is_Add:\n        prettyF = prettyForm(*prettyF.parens())\n\n    # dx dy dz ...\n    arg = prettyF\n    for x in integral.limits:\n        prettyArg = self._print(x[0])\n        # XXX qparens (parens if needs-parens)\n        if prettyArg.width() > 1:\n            prettyArg = prettyForm(*prettyArg.parens())\n\n        arg = prettyForm(*arg.right(' d', prettyArg))\n\n    # \\int \\int \\int ...\n    firstterm = True\n    s = None\n    for lim in integral.limits:\n        # Create bar based on the height of the argument\n        h = arg.height()\n        H = h + 2\n\n        # XXX hack!\n        ascii_mode = not self._use_unicode\n        if ascii_mode:\n            H += 2\n\n        vint = vobj('int', H)\n\n        # Construct the pretty form with the integral sign and the argument\n        pform = prettyForm(vint)\n        pform.baseline = arg.baseline + (\n            H - h)//2    # covering the whole argument\n\n        if len(lim) > 1:\n            # Create pretty forms for endpoints, if definite integral.\n            # Do not print empty endpoints.\n            if len(lim) == 2:\n                prettyA = prettyForm(\"\")\n                prettyB = self._print(lim[1])\n            if len(lim) == 3:\n                prettyA = self._print(lim[1])\n                prettyB = self._print(lim[2])\n\n            if ascii_mode:  # XXX hack\n                # Add spacing so that endpoint can more easily be\n                # identified with the correct integral sign\n                spc = max(1, 3 - prettyB.width())\n                prettyB = prettyForm(*prettyB.left(' ' * spc))\n\n                spc = max(1, 4 - prettyA.width())\n                prettyA = prettyForm(*prettyA.right(' ' * spc))\n\n            pform = prettyForm(*pform.above(prettyB))\n            pform = prettyForm(*pform.below(prettyA))\n\n        if not ascii_mode:  # XXX hack\n            pform = prettyForm(*pform.right(' '))\n\n        if firstterm:\n            s = pform   # first term\n            firstterm = False\n        else:\n            s = prettyForm(*s.left(pform))\n\n    pform = prettyForm(*arg.left(s))\n    pform.binding = prettyForm.MUL\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Product": "def _print_Product(self, expr):\n    func = expr.term\n    pretty_func = self._print(func)\n\n    horizontal_chr = xobj('_', 1)\n    corner_chr = xobj('_', 1)\n    vertical_chr = xobj('|', 1)\n\n    if self._use_unicode:\n        # use unicode corners\n        horizontal_chr = xobj('-', 1)\n        corner_chr = xobj('UpTack', 1)\n\n    func_height = pretty_func.height()\n\n    first = True\n    max_upper = 0\n    sign_height = 0\n\n    for lim in expr.limits:\n        pretty_lower, pretty_upper = self.__print_SumProduct_Limits(lim)\n\n        width = (func_height + 2) * 5 // 3 - 2\n        sign_lines = [horizontal_chr + corner_chr + (horizontal_chr * (width-2)) + corner_chr + horizontal_chr]\n        for _ in range(func_height + 1):\n            sign_lines.append(' ' + vertical_chr + (' ' * (width-2)) + vertical_chr + ' ')\n\n        pretty_sign = stringPict('')\n        pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))\n\n\n        max_upper = max(max_upper, pretty_upper.height())\n\n        if first:\n            sign_height = pretty_sign.height()\n\n        pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))\n        pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))\n\n        if first:\n            pretty_func.baseline = 0\n            first = False\n\n        height = pretty_sign.height()\n        padding = stringPict('')\n        padding = prettyForm(*padding.stack(*[' ']*(height - 1)))\n        pretty_sign = prettyForm(*pretty_sign.right(padding))\n\n        pretty_func = prettyForm(*pretty_sign.right(pretty_func))\n\n    pretty_func.baseline = max_upper + sign_height//2\n    pretty_func.binding = prettyForm.MUL\n    return pretty_func",
    "sympy.sympy.printing.pretty.pretty.emptyPrinter": "def emptyPrinter(self, expr):\n    return prettyForm(str(expr))",
    "sympy.sympy.printing.pretty.pretty._print_Sum": "def _print_Sum(self, expr):\n    ascii_mode = not self._use_unicode\n\n    def asum(hrequired, lower, upper, use_ascii):\n        def adjust(s, wid=None, how='<^>'):\n            if not wid or len(s) > wid:\n                return s\n            need = wid - len(s)\n            if how in ('<^>', \"<\") or how not in list('<^>'):\n                return s + ' '*need\n            half = need//2\n            lead = ' '*half\n            if how == \">\":\n                return \" \"*need + s\n            return lead + s + ' '*(need - len(lead))\n\n        h = max(hrequired, 2)\n        d = h//2\n        w = d + 1\n        more = hrequired % 2\n\n        lines = []\n        if use_ascii:\n            lines.append(\"_\"*(w) + ' ')\n            lines.append(r\"\\%s`\" % (' '*(w - 1)))\n            for i in range(1, d):\n                lines.append('%s\\\\%s' % (' '*i, ' '*(w - i)))\n            if more:\n                lines.append('%s)%s' % (' '*(d), ' '*(w - d)))\n            for i in reversed(range(1, d)):\n                lines.append('%s/%s' % (' '*i, ' '*(w - i)))\n            lines.append(\"/\" + \"_\"*(w - 1) + ',')\n            return d, h + more, lines, more\n        else:\n            w = w + more\n            d = d + more\n            vsum = vobj('sum', 4)\n            lines.append(\"_\"*(w))\n            for i in range(0, d):\n                lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))\n            for i in reversed(range(0, d)):\n                lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))\n            lines.append(vsum[8]*(w))\n            return d, h + 2*more, lines, more\n\n    f = expr.function\n\n    prettyF = self._print(f)\n\n    if f.is_Add:  # add parens\n        prettyF = prettyForm(*prettyF.parens())\n\n    H = prettyF.height() + 2\n\n    # \\sum \\sum \\sum ...\n    first = True\n    max_upper = 0\n    sign_height = 0\n\n    for lim in expr.limits:\n        prettyLower, prettyUpper = self.__print_SumProduct_Limits(lim)\n\n        max_upper = max(max_upper, prettyUpper.height())\n\n        # Create sum sign based on the height of the argument\n        d, h, slines, adjustment = asum(\n            H, prettyLower.width(), prettyUpper.width(), ascii_mode)\n        prettySign = stringPict('')\n        prettySign = prettyForm(*prettySign.stack(*slines))\n\n        if first:\n            sign_height = prettySign.height()\n\n        prettySign = prettyForm(*prettySign.above(prettyUpper))\n        prettySign = prettyForm(*prettySign.below(prettyLower))\n\n        if first:\n            # change F baseline so it centers on the sign\n            prettyF.baseline -= d - (prettyF.height()//2 -\n                                     prettyF.baseline)\n            first = False\n\n        # put padding to the right\n        pad = stringPict('')\n        pad = prettyForm(*pad.stack(*[' ']*h))\n        prettySign = prettyForm(*prettySign.right(pad))\n        # put the present prettyF to the right\n        prettyF = prettyForm(*prettySign.right(prettyF))\n\n    # adjust baseline of ascii mode sigma with an odd height so that it is\n    # exactly through the center\n    ascii_adjustment = ascii_mode if not adjustment else 0\n    prettyF.baseline = max_upper + sign_height//2 + ascii_adjustment\n\n    prettyF.binding = prettyForm.MUL\n    return prettyF",
    "sympy.sympy.printing.pretty.pretty._print_Limit": "def _print_Limit(self, l):\n    e, z, z0, dir = l.args\n\n    E = self._print(e)\n    if precedence(e) <= PRECEDENCE[\"Mul\"]:\n        E = prettyForm(*E.parens('(', ')'))\n    Lim = prettyForm('lim')\n\n    LimArg = self._print(z)\n    if self._use_unicode:\n        LimArg = prettyForm(*LimArg.right(f\"{xobj('-', 1)}{pretty_atom('Arrow')}\"))\n    else:\n        LimArg = prettyForm(*LimArg.right('->'))\n    LimArg = prettyForm(*LimArg.right(self._print(z0)))\n\n    if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n        dir = \"\"\n    else:\n        if self._use_unicode:\n            dir = pretty_atom('SuperscriptPlus') if str(dir) == \"+\" else pretty_atom('SuperscriptMinus')\n\n    LimArg = prettyForm(*LimArg.right(self._print(dir)))\n\n    Lim = prettyForm(*Lim.below(LimArg))\n    Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)\n\n    return Lim",
    "sympy.sympy.printing.pretty.pretty._print_stringPict": "def _print_stringPict(self, e):\n    return e",
    "sympy.sympy.printing.pretty.pretty._print_atan2": "def _print_atan2(self, e):\n    pform = prettyForm(*self._print_seq(e.args).parens())\n    pform = prettyForm(*pform.left('atan2'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_MatrixBase": "def _print_MatrixBase(self, e, lparens='[', rparens=']'):\n    D = self._print_matrix_contents(e)\n    D.baseline = D.height()//2\n    D = prettyForm(*D.parens(lparens, rparens))\n    return D",
    "sympy.sympy.printing.pretty.pretty._print_Determinant": "def _print_Determinant(self, e):\n    mat = e.arg\n    if mat.is_MatrixExpr:\n        from sympy.matrices.expressions.blockmatrix import BlockMatrix\n        if isinstance(mat, BlockMatrix):\n            return self._print_MatrixBase(mat.blocks, lparens='|', rparens='|')\n        D = self._print(mat)\n        D.baseline = D.height()//2\n        return prettyForm(*D.parens('|', '|'))\n    else:\n        return self._print_MatrixBase(mat, lparens='|', rparens='|')",
    "sympy.sympy.printing.pretty.pretty._print_TensorProduct": "def _print_TensorProduct(self, expr):\n    # This should somehow share the code with _print_WedgeProduct:\n    if self._use_unicode:\n        circled_times = \"\\u2297\"\n    else:\n        circled_times = \".*\"\n    return self._print_seq(expr.args, None, None, circled_times,\n        parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE[\"Mul\"])",
    "sympy.sympy.printing.pretty.pretty._print_WedgeProduct": "def _print_WedgeProduct(self, expr):\n    # This should somehow share the code with _print_TensorProduct:\n    if self._use_unicode:\n        wedge_symbol = \"\\u2227\"\n    else:\n        wedge_symbol = '/\\\\'\n    return self._print_seq(expr.args, None, None, wedge_symbol,\n        parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE[\"Mul\"])",
    "sympy.sympy.printing.pretty.pretty._print_Trace": "def _print_Trace(self, e):\n    D = self._print(e.arg)\n    D = prettyForm(*D.parens('(',')'))\n    D.baseline = D.height()//2\n    D = prettyForm(*D.left('\\n'*(0) + 'tr'))\n    return D",
    "sympy.sympy.printing.pretty.pretty._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    from sympy.matrices import MatrixSymbol\n    if (isinstance(expr.parent, MatrixSymbol)\n            and expr.i.is_number and expr.j.is_number):\n        return self._print(\n                Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))\n    else:\n        prettyFunc = self._print(expr.parent)\n        prettyFunc = prettyForm(*prettyFunc.parens())\n        prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '\n                ).parens(left='[', right=']')[0]\n        pform = prettyForm(binding=prettyForm.FUNC,\n                *stringPict.next(prettyFunc, prettyIndices))\n\n        # store pform parts so it can be reassembled e.g. when powered\n        pform.prettyFunc = prettyFunc\n        pform.prettyArgs = prettyIndices\n\n        return pform",
    "sympy.sympy.printing.pretty.pretty._print_Symbol": "def _print_Symbol(self, e, bold_name=False):\n    symb = pretty_symbol(e.name, bold_name)\n    return prettyForm(symb)",
    "sympy.sympy.printing.pretty.pretty._print_MatrixSlice": "def _print_MatrixSlice(self, m):\n    # XXX works only for applied functions\n    from sympy.matrices import MatrixSymbol\n    prettyFunc = self._print(m.parent)\n    if not isinstance(m.parent, MatrixSymbol):\n        prettyFunc = prettyForm(*prettyFunc.parens())\n    def ppslice(x, dim):\n        x = list(x)\n        if x[2] == 1:\n            del x[2]\n        if x[0] == 0:\n            x[0] = ''\n        if x[1] == dim:\n            x[1] = ''\n        return prettyForm(*self._print_seq(x, delimiter=':'))\n    prettyArgs = self._print_seq((ppslice(m.rowslice, m.parent.rows),\n        ppslice(m.colslice, m.parent.cols)), delimiter=', ').parens(left='[', right=']')[0]\n\n    pform = prettyForm(\n        binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))\n\n    # store pform parts so it can be reassembled e.g. when powered\n    pform.prettyFunc = prettyFunc\n    pform.prettyArgs = prettyArgs\n\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_MatrixSymbol": "def _print_MatrixSymbol(self, e):\n    return self._print_Symbol(e, self._settings['mat_symbol_style'] == \"bold\")",
    "sympy.sympy.printing.pretty.pretty._print_Transpose": "def _print_Transpose(self, expr):\n    mat = expr.arg\n    pform = self._print(mat)\n    from sympy.matrices import MatrixSymbol, BlockMatrix\n    if (not isinstance(mat, MatrixSymbol) and\n        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n        pform = prettyForm(*pform.parens())\n    pform = pform**(prettyForm('T'))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Adjoint": "def _print_Adjoint(self, expr):\n    mat = expr.arg\n    pform = self._print(mat)\n    if self._use_unicode:\n        dag = prettyForm(pretty_atom('Dagger'))\n    else:\n        dag = prettyForm('+')\n    from sympy.matrices import MatrixSymbol, BlockMatrix\n    if (not isinstance(mat, MatrixSymbol) and\n        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n        pform = prettyForm(*pform.parens())\n    pform = pform**dag\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_BlockMatrix": "def _print_BlockMatrix(self, B):\n    if B.blocks.shape == (1, 1):\n        return self._print(B.blocks[0, 0])\n    return self._print(B.blocks)",
    "sympy.sympy.printing.pretty.pretty._print_Float": "def _print_Float(self, e):\n    # we will use StrPrinter's Float printer, but we need to handle the\n    # full_prec ourselves, according to the self._print_level\n    full_prec = self._settings[\"full_prec\"]\n    if full_prec == \"auto\":\n        full_prec = self._print_level == 1\n    return prettyForm(sstr(e, full_prec=full_prec))",
    "sympy.sympy.printing.pretty.pretty._print_MatAdd": "def _print_MatAdd(self, expr):\n    s = None\n    for item in expr.args:\n        pform = self._print(item)\n        if s is None:\n            s = pform     # First element\n        else:\n            coeff = item.as_coeff_mmul()[0]\n            if S(coeff).could_extract_minus_sign():\n                s = prettyForm(*stringPict.next(s, ' '))\n                pform = self._print(item)\n            else:\n                s = prettyForm(*stringPict.next(s, ' + '))\n            s = prettyForm(*stringPict.next(s, pform))\n\n    return s",
    "sympy.sympy.printing.pretty.pretty._print_MatMul": "def _print_MatMul(self, expr):\n    args = list(expr.args)\n    from sympy.matrices.expressions.hadamard import HadamardProduct\n    from sympy.matrices.expressions.kronecker import KroneckerProduct\n    from sympy.matrices.expressions.matadd import MatAdd\n    for i, a in enumerate(args):\n        if (isinstance(a, (Add, MatAdd, HadamardProduct, KroneckerProduct))\n                and len(expr.args) > 1):\n            args[i] = prettyForm(*self._print(a).parens())\n        else:\n            args[i] = self._print(a)\n\n    return prettyForm.__mul__(*args)",
    "sympy.sympy.printing.pretty.pretty._print_Identity": "def _print_Identity(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_atom('IdentityMatrix'))\n    else:\n        return prettyForm('I')",
    "sympy.sympy.printing.pretty.pretty._print_ZeroMatrix": "def _print_ZeroMatrix(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_atom('ZeroMatrix'))\n    else:\n        return prettyForm('0')",
    "sympy.sympy.printing.pretty.pretty._print_OneMatrix": "def _print_OneMatrix(self, expr):\n    if self._use_unicode:\n        return prettyForm(pretty_atom(\"OneMatrix\"))\n    else:\n        return prettyForm('1')",
    "sympy.sympy.printing.pretty.pretty._print_MatrixUnit": "def _print_MatrixUnit(self, expr):\n    if self._use_unicode:\n        s = self._print(Symbol(f'{pretty_atom(\"MatrixUnit\")}_{expr._i}{expr._j}'))\n    else:\n        s = self._print(Symbol(f'E_{expr._i}{expr._j}'))\n    return s",
    "sympy.sympy.printing.pretty.pretty._print_DotProduct": "def _print_DotProduct(self, expr):\n    args = list(expr.args)\n\n    for i, a in enumerate(args):\n        args[i] = self._print(a)\n    return prettyForm.__mul__(*args)",
    "sympy.sympy.printing.pretty.pretty._print_MatPow": "def _print_MatPow(self, expr):\n    pform = self._print(expr.base)\n    from sympy.matrices import MatrixSymbol\n    if not isinstance(expr.base, MatrixSymbol) and expr.base.is_MatrixExpr:\n        pform = prettyForm(*pform.parens())\n    pform = pform**(self._print(expr.exp))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_Cross": "def _print_Cross(self, e):\n    vec1 = e._expr1\n    vec2 = e._expr2\n    pform = self._print(vec2)\n    pform = prettyForm(*pform.left('('))\n    pform = prettyForm(*pform.right(')'))\n    pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))\n    pform = prettyForm(*pform.left(')'))\n    pform = prettyForm(*pform.left(self._print(vec1)))\n    pform = prettyForm(*pform.left('('))\n    return pform",
    "sympy.sympy.printing.pretty.pretty._print_HadamardPower": "def _print_HadamardPower(self, expr):\n    # from sympy import MatAdd, MatMul\n    if self._use_unicode:\n        circ = pretty_atom('Ring')\n    else:\n        circ = self._print('.')\n    pretty_base = self._print(expr.base)\n    pretty_exp = self._print(expr.exp)\n    if precedence(expr.exp) < PRECEDENCE[\"Mul\"]:\n        pretty_exp = prettyForm(*pretty_exp.parens())\n    pretty_circ_exp = prettyForm(\n        binding=prettyForm.LINE,\n        *stringPict.next(circ, pretty_exp)\n    )\n    return pretty_base**pretty_circ_exp",
    "sympy.sympy.printing.pretty.pretty._print_KroneckerProduct": "def _print_KroneckerProduct(self, expr):\n    from sympy.matrices.expressions.matadd import MatAdd\n    from sympy.matrices.expressions.matmul import MatMul\n    if self._use_unicode:\n        delim = f\" {pretty_atom('TensorProduct')} \"\n    else:\n        delim = ' x '\n    return self._print_seq(expr.args, None, None, delim,\n            parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))",
    "sympy.sympy.printing.pretty.pretty._print_TransferFunction": "def _print_TransferFunction(self, expr):\n    if not expr.num == 1:\n        num, den = expr.num, expr.den\n        res = Mul(num, Pow(den, -1, evaluate=False), evaluate=False)\n        return self._print_Mul(res)\n    else:\n        return self._print(1)/self._print(expr.den)",
    "sympy.sympy.printing.printer.<genexpr>": "classes = tuple(c for c in classes[:i] if \\\n    c.__name__ == classes[0].__name__ or \\\n    c.__name__.endswith(\"Base\")) + classes[i:]\n",
    "sympy.sympy.printing.pycode._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return \"float('-inf')\"",
    "sympy.sympy.printing.pycode._print_Assignment": "def _print_Assignment(self, expr):\n    #XXX: maybe this needs to happen at a higher level e.g. at _print or\n    #doprint?\n    lhs = self._print(self._arrayify(expr.lhs))\n    rhs = self._print(self._arrayify(expr.rhs))\n    return \"%s = %s\" % ( lhs, rhs )",
    "sympy.sympy.printing.pycode._print_Mod": "def _print_Mod(self, expr):\n    PREC = precedence(expr)\n    return ('{} % {}'.format(*(self.parenthesize(x, PREC) for x in expr.args)))",
    "sympy.sympy.printing.pycode._print_Piecewise": "def _print_Piecewise(self, expr):\n    result = []\n    for i, arg in enumerate(expr.args):\n        e = arg.expr\n        c = arg.cond\n        if i == 0:\n            result.append('(')\n        result.append('(')\n        result.append(self._print(e))\n        result.append(')')\n        result.append(' if ')\n        result.append(self._print(c))\n        result.append(' else ')\n    result = result[:-1]\n    if result[-1] == 'True':\n        result = result[:-2]\n        result.append(')')\n    else:\n        result.append(' else None)')\n    return ''.join(result)",
    "sympy.sympy.printing.pycode._print_Relational": "def _print_Relational(self, expr):\n    \"Relational printer for Equality and Unequality\"\n    op = {\n        '==' :'equal',\n        '!=' :'not_equal',\n        '<'  :'less',\n        '<=' :'less_equal',\n        '>'  :'greater',\n        '>=' :'greater_equal',\n    }\n    if expr.rel_op in op:\n        lhs = self._print(expr.lhs)\n        rhs = self._print(expr.rhs)\n        return '({lhs} {op} {rhs})'.format(op=expr.rel_op, lhs=lhs, rhs=rhs)\n    return super()._print_Relational(expr)",
    "sympy.sympy.printing.pycode._print_ITE": "def _print_ITE(self, expr):\n    from sympy.functions.elementary.piecewise import Piecewise\n    return self._print(expr.rewrite(Piecewise))",
    "sympy.sympy.printing.pycode._print_Sum": "def _print_Sum(self, expr):\n    loops = (\n        'for {i} in range({a}, {b}+1)'.format(\n            i=self._print(i),\n            a=self._print(a),\n            b=self._print(b))\n        for i, a, b in expr.limits[::-1])\n    return '(builtins.sum({function} {loops}))'.format(\n        function=self._print(expr.function),\n        loops=' '.join(loops))",
    "sympy.sympy.printing.pycode._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return '1j'",
    "sympy.sympy.printing.pycode._print_KroneckerDelta": "def _print_KroneckerDelta(self, expr):\n    a, b = expr.args\n\n    return '(1 if {a} == {b} else 0)'.format(\n        a = self._print(a),\n        b = self._print(b)\n    )",
    "sympy.sympy.printing.pycode.<lambda>": "lambda self, expr: self._print_MatrixBase(expr)\n\n",
    "sympy.sympy.printing.pycode._print_FunctionDefinition": "def _print_FunctionDefinition(self, fd):\n    body = '\\n'.join((self._print(arg) for arg in fd.body))\n    return \"def {name}({parameters}):\\n{body}\".format(\n        name=self._print(fd.name),\n        parameters=', '.join([self._print(var.symbol) for var in fd.parameters]),\n        body=self._indent_codestring(body)\n    )",
    "sympy.sympy.printing.pycode._print_While": "def _print_While(self, whl):\n    body = '\\n'.join((self._print(arg) for arg in whl.body))\n    return \"while {cond}:\\n{body}\".format(\n        cond=self._print(whl.condition),\n        body=self._indent_codestring(body)\n    )",
    "sympy.sympy.printing.pycode._print_Declaration": "def _print_Declaration(self, decl):\n    return '%s = %s' % (\n        self._print(decl.variable.symbol),\n        self._print(decl.variable.value)\n    )",
    "sympy.sympy.printing.pycode._print_BreakToken": "def _print_BreakToken(self, bt):\n    return 'break'",
    "sympy.sympy.printing.pycode._print_Return": "def _print_Return(self, ret):\n    arg, = ret.args\n    return 'return %s' % self._print(arg)",
    "sympy.sympy.printing.pycode._print_Raise": "def _print_Raise(self, rs):\n    arg, = rs.args\n    return 'raise %s' % self._print(arg)",
    "sympy.sympy.printing.pycode._print_RuntimeError_": "def _print_RuntimeError_(self, re):\n    message, = re.args\n    return \"RuntimeError(%s)\" % self._print(message)",
    "sympy.sympy.printing.pycode._print_Print": "def _print_Print(self, prnt):\n    print_args = ', '.join((self._print(arg) for arg in prnt.print_args))\n    from sympy.codegen.ast import none\n    if prnt.format_string != none:\n        print_args = '{} % ({}), end=\"\"'.format(\n            self._print(prnt.format_string),\n            print_args\n        )\n    if prnt.file != None: # Must be '!= None', cannot be 'is not None'\n        print_args += ', file=%s' % self._print(prnt.file)\n    return 'print(%s)' % print_args",
    "sympy.sympy.printing.pycode._print_NoneToken": "def _print_NoneToken(self, arg):\n    return 'None'",
    "sympy.sympy.printing.pycode._print_ArrayContraction": "def _print_ArrayContraction(self, expr):\n    from sympy.tensor.array.expressions.array_expressions import ArrayTensorProduct\n    base = expr.expr\n    contraction_indices = expr.contraction_indices\n\n    if isinstance(base, ArrayTensorProduct):\n        elems = \",\".join([\"%s\" % (self._print(arg)) for arg in base.args])\n        ranks = base.subranks\n    else:\n        elems = self._print(base)\n        ranks = [len(base.shape)]\n\n    contraction_string, letters_free, letters_dum = self._get_einsum_string(ranks, contraction_indices)\n\n    if not contraction_indices:\n        return self._print(base)\n    if isinstance(base, ArrayTensorProduct):\n        elems = \",\".join([\"%s\" % (self._print(arg)) for arg in base.args])\n    else:\n        elems = self._print(base)\n    return \"%s(\\\"%s\\\", %s)\" % (\n        self._module_format(self._module + \".\" + self._einsum),\n        \"{}->{}\".format(contraction_string, \"\".join(sorted(letters_free))),\n        elems,\n    )",
    "sympy.sympy.printing.pycode._print_ArrayDiagonal": "def _print_ArrayDiagonal(self, expr):\n    from sympy.tensor.array.expressions.array_expressions import ArrayTensorProduct\n    diagonal_indices = list(expr.diagonal_indices)\n    if isinstance(expr.expr, ArrayTensorProduct):\n        subranks = expr.expr.subranks\n        elems = expr.expr.args\n    else:\n        subranks = expr.subranks\n        elems = [expr.expr]\n    diagonal_string, letters_free, letters_dum = self._get_einsum_string(subranks, diagonal_indices)\n    elems = [self._print(i) for i in elems]\n    return '%s(\"%s\", %s)' % (\n        self._module_format(self._module + \".\" + self._einsum),\n        \"{}->{}\".format(diagonal_string, \"\".join(letters_free+letters_dum)),\n        \", \".join(elems)\n    )",
    "sympy.sympy.printing.pycode._print_OneArray": "def _print_OneArray(self, expr):\n    return \"%s((%s,))\" % (\n        self._module_format(self._module+ \".\" + self._ones),\n        ','.join(map(self._print,expr.args))\n    )",
    "sympy.sympy.printing.pycode._print_ZeroArray": "def _print_ZeroArray(self, expr):\n    return \"%s((%s,))\" % (\n        self._module_format(self._module+ \".\" + self._zeros),\n        ','.join(map(self._print,expr.args))\n    )",
    "sympy.sympy.printing.pycode._print_IndexedBase": "def _print_IndexedBase(self, expr):\n    return expr.name",
    "sympy.sympy.printing.pycode._print_sign": "def _print_sign(self, e):\n    return '(0.0 if {e} == 0 else {f}(1, {e}))'.format(\n        f=self._module_format('math.copysign'), e=self._print(e.args[0]))",
    "sympy.sympy.printing.pycode._print_Not": "def _print_Not(self, expr):\n    PREC = precedence(expr)\n    return self._operators['not'] + ' ' + self.parenthesize(expr.args[0], PREC)",
    "sympy.sympy.printing.pycode._print_Indexed": "def _print_Indexed(self, expr):\n    base = expr.args[0]\n    index = expr.args[1:]\n    return \"{}[{}]\".format(self._print(base), \", \".join([self._print(ind) for ind in index]))",
    "sympy.sympy.printing.pycode._print_Pow": "def _print_Pow(self, expr, rational=False):\n    return self._hprint_Pow(expr, rational=rational, sqrt='sympy.sqrt')",
    "sympy.sympy.printing.pycode._print_Rational": "def _print_Rational(self, e):\n    return \"{func}({p})/{func}({q})\".format(\n        func=self._module_format('mpmath.mpf'),\n        q=self._print(e.q),\n        p=self._print(e.p)\n    )",
    "sympy.sympy.printing.pycode._print_Half": "def _print_Half(self, e):\n    return self._print_Rational(e)",
    "sympy.sympy.printing.pycode._print_frac": "def _print_frac(self, expr):\n    return self._print_Mod(Mod(expr.args[0], 1))",
    "sympy.sympy.printing.pycode._print_Symbol": "def _print_Symbol(self, expr):\n\n    name = super()._print_Symbol(expr)\n\n    if name in self.reserved_words:\n        if self._settings['error_on_reserved']:\n            msg = ('This expression includes the symbol \"{}\" which is a '\n                   'reserved keyword in this language.')\n            raise ValueError(msg.format(name))\n        return name + self._settings['reserved_word_suffix']\n    elif '{' in name:   # Remove curly braces from subscripted variables\n        return name.replace('{', '').replace('}', '')\n    else:\n        return name",
    "sympy.sympy.printing.pycode._print_known_func": "def _print_known_func(self, expr):\n    known = self.known_functions[expr.__class__.__name__]\n    return '{name}({args})'.format(name=self._module_format(known),\n                                   args=', '.join((self._print(arg) for arg in expr.args)))",
    "sympy.sympy.printing.pycode._print_re": "def _print_re(self, expr):\n    \"\"\"Prints `re(z)` as `z.real`\"\"\"\n    return f\"({self._print(expr.args[0])}).real\"",
    "sympy.sympy.printing.pycode._print_im": "def _print_im(self, expr):\n    \"\"\"Prints `im(z)` as `z.imag`\"\"\"\n    return f\"({self._print(expr.args[0])}).imag\"",
    "sympy.sympy.printing.pycode._print_known_const": "def _print_known_const(self, expr):\n    known = self.known_constants[expr.__class__.__name__]\n    return self._module_format(known)",
    "sympy.sympy.printing.pycode._print_Float": "def _print_Float(self, e):\n    # XXX: This does not handle setting mpmath.mp.dps. It is assumed that\n    # the caller of the lambdified function will have set it to sufficient\n    # precision to match the Floats in the expression.\n\n    # Remove 'mpz' if gmpy is installed.\n    args = str(tuple(map(int, e._mpf_)))\n    return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)",
    "sympy.sympy.printing.pycode._print_uppergamma": "def _print_uppergamma(self, e):\n    return \"{}({}, {}, {})\".format(\n        self._module_format('mpmath.gammainc'),\n        self._print(e.args[0]),\n        self._print(e.args[1]),\n        self._module_format('mpmath.inf'))",
    "sympy.sympy.printing.pycode._print_lowergamma": "def _print_lowergamma(self, e):\n    return \"{}({}, 0, {})\".format(\n        self._module_format('mpmath.gammainc'),\n        self._print(e.args[0]),\n        self._print(e.args[1]))",
    "sympy.sympy.printing.pycode._print_log1p": "def _print_log1p(self, e):\n    return '{}({})'.format(\n        self._module_format('mpmath.log1p'), self._print(e.args[0]))",
    "sympy.sympy.printing.pycode._print_Integral": "def _print_Integral(self, e):\n    integration_vars, limits = _unpack_integral_limits(e)\n\n    return \"{}(lambda {}: {}, {})\".format(\n            self._module_format(\"mpmath.quad\"),\n            \", \".join(map(self._print, integration_vars)),\n            self._print(e.args[0]),\n            \", \".join(\"(%s, %s)\" % tuple(map(self._print, l)) for l in limits))",
    "sympy.sympy.printing.pycode._print_Function": "def _print_Function(self, expr):\n    mod = expr.func.__module__ or ''\n    return '%s(%s)' % (self._module_format(mod + ('.' if mod else '') + expr.func.__name__),\n                       ', '.join((self._print(arg) for arg in expr.args)))",
    "sympy.sympy.printing.python._print_Function": "def _print_Function(self, expr):\n    func = expr.func.__name__\n    if not hasattr(sympy, func) and func not in self.functions:\n        self.functions.append(func)\n    return StrPrinter._print_Function(self, expr)",
    "sympy.sympy.printing.python._print_Symbol": "def _print_Symbol(self, expr):\n    symbol = self._str(expr)\n    if symbol not in self.symbols:\n        self.symbols.append(symbol)\n    return StrPrinter._print_Symbol(self, expr)",
    "sympy.sympy.printing.pytorch._print_Derivative": "def _print_Derivative(self, expr):\n    # this version handles multi-variable and mixed partial derivatives. The tensorflow version does not.\n    variables = expr.variables\n    expr_arg = expr.expr\n\n    # Handle multi-variable or repeated derivatives\n    if len(variables) > 1 or (\n        len(variables) == 1 and not isinstance(variables[0], tuple) and variables.count(variables[0]) > 1):\n        result = self._print(expr_arg)\n        var_groups = {}\n\n        # Group variables by base symbol\n        for var in variables:\n            if isinstance(var, tuple):\n                base_var, order = var\n                var_groups[base_var] = var_groups.get(base_var, 0) + order\n            else:\n                var_groups[var] = var_groups.get(var, 0) + 1\n\n        # Apply gradients in sequence\n        for var, order in var_groups.items():\n            for _ in range(order):\n                result = \"torch.autograd.grad({}, {}, create_graph=True)[0]\".format(result, self._print(var))\n        return result\n\n    # Handle single variable case\n    if len(variables) == 1:\n        variable = variables[0]\n        if isinstance(variable, tuple) and len(variable) == 2:\n            base_var, order = variable\n            if not isinstance(order, Integer): raise NotImplementedError(\"Only integer orders are supported\")\n            result = self._print(expr_arg)\n            for _ in range(order):\n                result = \"torch.autograd.grad({}, {}, create_graph=True)[0]\".format(result, self._print(base_var))\n            return result\n        return \"torch.autograd.grad({}, {})[0]\".format(self._print(expr_arg), self._print(variable))\n\n    return self._print(expr_arg)  # Empty variables case",
    "sympy.sympy.printing.pytorch._print_Function": "def _print_Function(self, expr):\n\n    op = self.mapping.get(type(expr), None)\n    if op is None:\n        return super()._print_Basic(expr)\n    children = [self._print(arg) for arg in expr.args]\n    if len(children) == 1:\n        return \"%s(%s)\" % (\n            self._module_format(op),\n            children[0]\n        )\n    else:\n        return self._expand_fold_binary_op(op, children)",
    "sympy.sympy.printing.rcode._print_Pow": "def _print_Pow(self, expr):\n    if \"Pow\" in self.known_functions:\n        return self._print_Function(expr)\n    PREC = precedence(expr)\n    if equal_valued(expr.exp, -1):\n        return '1.0/%s' % (self.parenthesize(expr.base, PREC))\n    elif equal_valued(expr.exp, 0.5):\n        return 'sqrt(%s)' % self._print(expr.base)\n    else:\n        return '%s^%s' % (self.parenthesize(expr.base, PREC),\n                             self.parenthesize(expr.exp, PREC))",
    "sympy.sympy.printing.rcode._print_Rational": "def _print_Rational(self, expr):\n    p, q = int(expr.p), int(expr.q)\n    return '%d.0/%d.0' % (p, q)",
    "sympy.sympy.printing.rcode._print_Indexed": "def _print_Indexed(self, expr):\n    inds = [ self._print(i) for i in expr.indices ]\n    return \"%s[%s]\" % (self._print(expr.base.label), \", \".join(inds))",
    "sympy.sympy.printing.rcode._print_Exp1": "def _print_Exp1(self, expr):\n    return \"exp(1)\"",
    "sympy.sympy.printing.rcode._print_Pi": "def _print_Pi(self, expr):\n    return 'pi'",
    "sympy.sympy.printing.rcode._print_Infinity": "def _print_Infinity(self, expr):\n    return 'Inf'",
    "sympy.sympy.printing.rcode._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-Inf'",
    "sympy.sympy.printing.rcode._print_Assignment": "def _print_Assignment(self, expr):\n    from sympy.codegen.ast import Assignment\n\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    from sympy.tensor.indexed import IndexedBase\n    lhs = expr.lhs\n    rhs = expr.rhs\n    # We special case assignments that take multiple lines\n    #if isinstance(expr.rhs, Piecewise):\n    #    from sympy.functions.elementary.piecewise import Piecewise\n    #    # Here we modify Piecewise so each expression is now\n    #    # an Assignment, and then continue on the print.\n    #    expressions = []\n    #    conditions = []\n    #    for (e, c) in rhs.args:\n    #        expressions.append(Assignment(lhs, e))\n    #        conditions.append(c)\n    #    temp = Piecewise(*zip(expressions, conditions))\n    #    return self._print(temp)\n    #elif isinstance(lhs, MatrixSymbol):\n    if isinstance(lhs, MatrixSymbol):\n        # Here we form an Assignment for each element in the array,\n        # printing each one.\n        lines = []\n        for (i, j) in self._traverse_matrix_indices(lhs):\n            temp = Assignment(lhs[i, j], rhs[i, j])\n            code0 = self._print(temp)\n            lines.append(code0)\n        return \"\\n\".join(lines)\n    elif self._settings[\"contract\"] and (lhs.has(IndexedBase) or\n            rhs.has(IndexedBase)):\n        # Here we check if there is looping to be done, and if so\n        # print the required loops.\n        return self._doprint_loops(rhs, lhs)\n    else:\n        lhs_code = self._print(lhs)\n        rhs_code = self._print(rhs)\n        return self._get_statement(\"%s = %s\" % (lhs_code, rhs_code))",
    "sympy.sympy.printing.rcode._print_Piecewise": "def _print_Piecewise(self, expr):\n    # This method is called only for inline if constructs\n    # Top level piecewise is handled in doprint()\n    if expr.args[-1].cond == True:\n        last_line = \"%s\" % self._print(expr.args[-1].expr)\n    else:\n        last_line = \"ifelse(%s,%s,NA)\" % (self._print(expr.args[-1].cond), self._print(expr.args[-1].expr))\n    code=last_line\n    for e, c in reversed(expr.args[:-1]):\n        code= \"ifelse(%s,%s,\" % (self._print(c), self._print(e))+code+\")\"\n    return(code)",
    "sympy.sympy.printing.rcode._print_ITE": "def _print_ITE(self, expr):\n    from sympy.functions import Piecewise\n    return self._print(expr.rewrite(Piecewise))",
    "sympy.sympy.printing.rcode._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return \"{}[{}]\".format(self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"],\n        strict=True), expr.j + expr.i*expr.parent.shape[1])",
    "sympy.sympy.printing.rcode._print_Symbol": "def _print_Symbol(self, expr):\n    name = super()._print_Symbol(expr)\n    if expr in self._dereference:\n        return '(*{})'.format(name)\n    else:\n        return name",
    "sympy.sympy.printing.rcode._print_Relational": "def _print_Relational(self, expr):\n    lhs_code = self._print(expr.lhs)\n    rhs_code = self._print(expr.rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.rcode._print_AugmentedAssignment": "def _print_AugmentedAssignment(self, expr):\n    lhs_code = self._print(expr.lhs)\n    op = expr.op\n    rhs_code = self._print(expr.rhs)\n    return \"{} {} {};\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.rcode._print_For": "def _print_For(self, expr):\n    target = self._print(expr.target)\n    if isinstance(expr.iterable, Range):\n        start, stop, step = expr.iterable.args\n    else:\n        raise NotImplementedError(\"Only iterable currently supported is Range\")\n    body = self._print(expr.body)\n    return 'for({target} in seq(from={start}, to={stop}, by={step}){{\\n{body}\\n}}'.format(target=target, start=start,\n            stop=stop-1, step=step, body=body)",
    "sympy.sympy.printing.repr._print_Function": "def _print_Function(self, expr):\n    r = self._print(expr.func)\n    r += '(%s)' % ', '.join([self._print(a) for a in expr.args])\n    return r",
    "sympy.sympy.printing.repr._print_Heaviside": "def _print_Heaviside(self, expr):\n    # Same as _print_Function but uses pargs to suppress default value for\n    # 2nd arg.\n    r = self._print(expr.func)\n    r += '(%s)' % ', '.join([self._print(a) for a in expr.pargs])\n    return r",
    "sympy.sympy.printing.repr._print_FunctionClass": "def _print_FunctionClass(self, expr):\n    if issubclass(expr, AppliedUndef):\n        return 'Function(%r)' % (expr.__name__)\n    else:\n        return expr.__name__",
    "sympy.sympy.printing.repr._print_Half": "def _print_Half(self, expr):\n    return 'Rational(1, 2)'",
    "sympy.sympy.printing.repr._print_AtomicExpr": "def _print_AtomicExpr(self, expr):\n    return str(expr)",
    "sympy.sympy.printing.repr._print_NumberSymbol": "def _print_NumberSymbol(self, expr):\n    return str(expr)",
    "sympy.sympy.printing.repr._print_Integer": "def _print_Integer(self, expr):\n    return 'Integer(%i)' % expr.p",
    "sympy.sympy.printing.repr._print_Complexes": "def _print_Complexes(self, expr):\n    return 'Complexes'",
    "sympy.sympy.printing.repr._print_Integers": "def _print_Integers(self, expr):\n    return 'Integers'",
    "sympy.sympy.printing.repr._print_Naturals": "def _print_Naturals(self, expr):\n    return 'Naturals'",
    "sympy.sympy.printing.repr._print_Naturals0": "def _print_Naturals0(self, expr):\n    return 'Naturals0'",
    "sympy.sympy.printing.repr._print_Rationals": "def _print_Rationals(self, expr):\n    return 'Rationals'",
    "sympy.sympy.printing.repr._print_Reals": "def _print_Reals(self, expr):\n    return 'Reals'",
    "sympy.sympy.printing.repr._print_EmptySet": "def _print_EmptySet(self, expr):\n    return 'EmptySet'",
    "sympy.sympy.printing.repr._print_UniversalSet": "def _print_UniversalSet(self, expr):\n    return 'UniversalSet'",
    "sympy.sympy.printing.repr._print_EmptySequence": "def _print_EmptySequence(self, expr):\n    return 'EmptySequence'",
    "sympy.sympy.printing.repr._print_list": "def _print_list(self, expr):\n    return \"[%s]\" % self.reprify(expr, \", \")",
    "sympy.sympy.printing.repr._print_dict": "def _print_dict(self, expr):\n    sep = \", \"\n    dict_kvs = [\"%s: %s\" % (self.doprint(key), self.doprint(value)) for key, value in expr.items()]\n    return \"{%s}\" % sep.join(dict_kvs)",
    "sympy.sympy.printing.repr._print_set": "def _print_set(self, expr):\n    if not expr:\n        return \"set()\"\n    return \"{%s}\" % self.reprify(expr, \", \")",
    "sympy.sympy.printing.repr._print_MatrixBase": "def _print_MatrixBase(self, expr):\n    # special case for some empty matrices\n    if (expr.rows == 0) ^ (expr.cols == 0):\n        return '%s(%s, %s, %s)' % (expr.__class__.__name__,\n                                   self._print(expr.rows),\n                                   self._print(expr.cols),\n                                   self._print([]))\n    l = []\n    for i in range(expr.rows):\n        l.append([])\n        for j in range(expr.cols):\n            l[-1].append(expr[i, j])\n    return '%s(%s)' % (expr.__class__.__name__, self._print(l))",
    "sympy.sympy.printing.repr._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return \"true\"",
    "sympy.sympy.printing.repr._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return \"false\"",
    "sympy.sympy.printing.repr._print_NaN": "def _print_NaN(self, expr):\n    return \"nan\"",
    "sympy.sympy.printing.repr._print_Mul": "def _print_Mul(self, expr, order=None):\n    args = Mul.make_args(expr)\n    args = map(self._print, args)\n    clsname = type(expr).__name__\n    return clsname + \"(%s)\" % \", \".join(args)",
    "sympy.sympy.printing.repr._print_Rational": "def _print_Rational(self, expr):\n    return 'Rational(%s, %s)' % (self._print(expr.p), self._print(expr.q))",
    "sympy.sympy.printing.repr._print_Float": "def _print_Float(self, expr):\n    r = mlib_to_str(expr._mpf_, repr_dps(expr._prec))\n    return \"%s('%s', precision=%i)\" % (expr.__class__.__name__, r, expr._prec)",
    "sympy.sympy.printing.repr._print_Str": "def _print_Str(self, s):\n    return \"%s(%s)\" % (s.__class__.__name__, self._print(s.name))",
    "sympy.sympy.printing.repr._print_Symbol": "def _print_Symbol(self, expr):\n    d = expr._assumptions_orig\n    # print the dummy_index like it was an assumption\n    if expr.is_Dummy:\n        d = d.copy()\n        d['dummy_index'] = expr.dummy_index\n\n    if d == {}:\n        return \"%s(%s)\" % (expr.__class__.__name__, self._print(expr.name))\n    else:\n        attr = ['%s=%s' % (k, v) for k, v in d.items()]\n        return \"%s(%s, %s)\" % (expr.__class__.__name__,\n                               self._print(expr.name), ', '.join(attr))",
    "sympy.sympy.printing.repr._print_Predicate": "def _print_Predicate(self, expr):\n    return \"Q.%s\" % expr.name",
    "sympy.sympy.printing.repr._print_AppliedPredicate": "def _print_AppliedPredicate(self, expr):\n    # will be changed to just expr.args when args overriding is removed\n    args = expr._args\n    return \"%s(%s)\" % (expr.__class__.__name__, self.reprify(args, \", \"))",
    "sympy.sympy.printing.repr._print_str": "def _print_str(self, expr):\n    return repr(expr)",
    "sympy.sympy.printing.repr._print_tuple": "def _print_tuple(self, expr):\n    if len(expr) == 1:\n        return \"(%s,)\" % self._print(expr[0])\n    else:\n        return \"(%s)\" % self.reprify(expr, \", \")",
    "sympy.sympy.printing.repr._print_WildFunction": "def _print_WildFunction(self, expr):\n    return \"%s('%s')\" % (expr.__class__.__name__, expr.name)",
    "sympy.sympy.printing.repr._print_AlgebraicNumber": "def _print_AlgebraicNumber(self, expr):\n    return \"%s(%s, %s)\" % (expr.__class__.__name__,\n        self._print(expr.root), self._print(expr.coeffs()))",
    "sympy.sympy.printing.repr._print_PolyRing": "def _print_PolyRing(self, ring):\n    return \"%s(%s, %s, %s)\" % (ring.__class__.__name__,\n        self._print(ring.symbols), self._print(ring.domain), self._print(ring.order))",
    "sympy.sympy.printing.repr._print_FracField": "def _print_FracField(self, field):\n    return \"%s(%s, %s, %s)\" % (field.__class__.__name__,\n        self._print(field.symbols), self._print(field.domain), self._print(field.order))",
    "sympy.sympy.printing.repr._print_PolyElement": "def _print_PolyElement(self, poly):\n    terms = list(poly.terms())\n    terms.sort(key=poly.ring.order, reverse=True)\n    return \"%s(%s, %s)\" % (poly.__class__.__name__, self._print(poly.ring), self._print(terms))",
    "sympy.sympy.printing.repr._print_FracElement": "def _print_FracElement(self, frac):\n    numer_terms = list(frac.numer.terms())\n    numer_terms.sort(key=frac.field.order, reverse=True)\n    denom_terms = list(frac.denom.terms())\n    denom_terms.sort(key=frac.field.order, reverse=True)\n    numer = self._print(numer_terms)\n    denom = self._print(denom_terms)\n    return \"%s(%s, %s, %s)\" % (frac.__class__.__name__, self._print(frac.field), numer, denom)",
    "sympy.sympy.printing.repr._print_FractionField": "def _print_FractionField(self, domain):\n    cls = domain.__class__.__name__\n    field = self._print(domain.field)\n    return \"%s(%s)\" % (cls, field)",
    "sympy.sympy.printing.repr._print_PolynomialRingBase": "def _print_PolynomialRingBase(self, ring):\n    cls = ring.__class__.__name__\n    dom = self._print(ring.domain)\n    gens = ', '.join(map(self._print, ring.gens))\n    order = str(ring.order)\n    if order != ring.default_order:\n        orderstr = \", order=\" + order\n    else:\n        orderstr = \"\"\n    return \"%s(%s, %s%s)\" % (cls, dom, gens, orderstr)",
    "sympy.sympy.printing.repr._print_DMP": "def _print_DMP(self, p):\n    cls = p.__class__.__name__\n    rep = self._print(p.to_list())\n    dom = self._print(p.dom)\n    return \"%s(%s, %s)\" % (cls, rep, dom)",
    "sympy.sympy.printing.repr._print_MonogenicFiniteExtension": "def _print_MonogenicFiniteExtension(self, ext):\n    # The expanded tree shown by srepr(ext.modulus)\n    # is not practical.\n    return \"FiniteExtension(%s)\" % str(ext.modulus)",
    "sympy.sympy.printing.repr._print_ExtensionElement": "def _print_ExtensionElement(self, f):\n    rep = self._print(f.rep)\n    ext = self._print(f.ext)\n    return \"ExtElem(%s, %s)\" % (rep, ext)",
    "sympy.sympy.printing.repr.emptyPrinter": "def emptyPrinter(self, expr):\n    \"\"\"\n    The fallback printer.\n    \"\"\"\n    if isinstance(expr, str):\n        return expr\n    elif hasattr(expr, \"__srepr__\"):\n        return expr.__srepr__()\n    elif hasattr(expr, \"args\") and hasattr(expr.args, \"__iter__\"):\n        l = []\n        for o in expr.args:\n            l.append(self._print(o))\n        return expr.__class__.__name__ + '(%s)' % ', '.join(l)\n    elif hasattr(expr, \"__module__\") and hasattr(expr, \"__name__\"):\n        return \"<'%s.%s'>\" % (expr.__module__, expr.__name__)\n    else:\n        return str(expr)",
    "sympy.sympy.printing.repr._print_Add": "def _print_Add(self, expr, order=None):\n    args = Add.make_args(expr)\n    args = map(self._print, args)\n    clsname = type(expr).__name__\n    return clsname + \"(%s)\" % \", \".join(args)",
    "sympy.sympy.printing.repr._print_Cycle": "def _print_Cycle(self, expr):\n    return expr.__repr__()",
    "sympy.sympy.printing.repr._print_Permutation": "def _print_Permutation(self, expr):\n    from sympy.combinatorics.permutations import Permutation, Cycle\n    from sympy.utilities.exceptions import sympy_deprecation_warning\n\n    perm_cyclic = Permutation.print_cyclic\n    if perm_cyclic is not None:\n        sympy_deprecation_warning(\n            f\"\"\"\n            Setting Permutation.print_cyclic is deprecated. Instead use\n            init_printing(perm_cyclic={perm_cyclic}).\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-permutation-print_cyclic\",\n            stacklevel=7,\n        )\n    else:\n        perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n    if perm_cyclic:\n        if not expr.size:\n            return 'Permutation()'\n        # before taking Cycle notation, see if the last element is\n        # a singleton and move it to the head of the string\n        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]\n        last = s.rfind('(')\n        if not last == 0 and ',' not in s[last:]:\n            s = s[last:] + s[:last]\n        return 'Permutation%s' %s\n    else:\n        s = expr.support()\n        if not s:\n            if expr.size < 5:\n                return 'Permutation(%s)' % str(expr.array_form)\n            return 'Permutation([], size=%s)' % expr.size\n        trim = str(expr.array_form[:s[-1] + 1]) + ', size=%s' % expr.size\n        use = full = str(expr.array_form)\n        if len(trim) < len(full):\n            use = trim\n        return 'Permutation(%s)' % use",
    "sympy.sympy.printing.rust._print_Function": "def _print_Function(self, expr):\n    \"\"\"\n    basic function for printing `Function`\n\n    Function Style :\n\n    1. args[0].func(args[1:]), method with arguments\n    2. args[0].func(), method without arguments\n    3. args[1].func(), method without arguments (e.g. (e, x) => x.exp())\n    4. func(args), function with arguments\n    \"\"\"\n\n    if expr.func.__name__ in self.known_functions:\n        cond_func = self.known_functions[expr.func.__name__]\n        func = None\n        style = 1\n        if isinstance(cond_func, str):\n            func = cond_func\n        else:\n            for cond, func, style in cond_func:\n                if cond(*expr.args):\n                    break\n        if func is not None:\n            if style == 1:\n                ret = \"%(var)s.%(method)s(%(args)s)\" % {\n                    'var': self._print_caller_var(expr.args[0]),\n                    'method': func,\n                    'args': self.stringify(expr.args[1:], \", \") if len(expr.args) > 1 else ''\n                }\n            elif style == 2:\n                ret = \"%(var)s.%(method)s()\" % {\n                    'var': self._print_caller_var(expr.args[0]),\n                    'method': func,\n                }\n            elif style == 3:\n                ret = \"%(var)s.%(method)s()\" % {\n                    'var': self._print_caller_var(expr.args[1]),\n                    'method': func,\n                }\n            else:\n                ret = \"%(func)s(%(args)s)\" % {\n                    'func': func,\n                    'args': self.stringify(expr.args, \", \"),\n                }\n            return ret\n    elif hasattr(expr, '_imp_') and isinstance(expr._imp_, Lambda):\n        # inlined function\n        return self._print(expr._imp_(*expr.args))\n    else:\n        return self._print_not_supported(expr)",
    "sympy.sympy.printing.rust._print_Mul": "def _print_Mul(self, expr):\n    contains_floats = any(arg.is_real and not arg.is_integer for arg in expr.args)\n    if contains_floats:\n        expr = reduce(operator.mul,(self._cast_to_float(arg) if arg != -1 else arg for arg in expr.args))\n\n    return super()._print_Mul(expr)",
    "sympy.sympy.printing.rust._print_Add": "def _print_Add(self, expr, order=None):\n    contains_floats = any(arg.is_real and not arg.is_integer for arg in expr.args)\n    if contains_floats:\n        expr = reduce(operator.add, (self._cast_to_float(arg) for arg in expr.args))\n\n    return super()._print_Add(expr, order)",
    "sympy.sympy.printing.rust._print_Pow": "def _print_Pow(self, expr):\n    if expr.base.is_integer and not expr.exp.is_integer:\n        expr = type(expr)(Float(expr.base), expr.exp)\n        return self._print(expr)\n    return self._print_Function(expr)",
    "sympy.sympy.printing.rust._print_TypeCast": "def _print_TypeCast(self, expr):\n    if not expr.explicit:\n        return self._print(expr.expr)\n    else:\n        return self._print(expr.expr) + ' as %s' % self.type_mappings[self.type_aliases[expr.type_]]",
    "sympy.sympy.printing.rust._print_Float": "def _print_Float(self, expr, _type=False):\n    ret = super()._print_Float(expr)\n    if _type:\n        return ret + '_%s' % self.type_mappings[self.type_aliases[real]]\n    else:\n        return ret",
    "sympy.sympy.printing.rust._print_Integer": "def _print_Integer(self, expr, _type=False):\n    ret = super()._print_Integer(expr)\n    if _type:\n        return ret + '_%s' % self.type_mappings[self.type_aliases[integer]]\n    else:\n        return ret",
    "sympy.sympy.printing.rust._print_Rational": "def _print_Rational(self, expr):\n    p, q = int(expr.p), int(expr.q)\n    float_suffix = self.type_mappings[self.type_aliases[real]]\n    return '%d_%s/%d.0' % (p, float_suffix, q)",
    "sympy.sympy.printing.rust._print_Relational": "def _print_Relational(self, expr):\n    if (expr.lhs.is_integer and not expr.rhs.is_integer) or (expr.rhs.is_integer and not expr.lhs.is_integer):\n        lhs = self._cast_to_float(expr.lhs)\n        rhs = self._cast_to_float(expr.rhs)\n    else:\n        lhs = expr.lhs\n        rhs = expr.rhs\n    lhs_code = self._print(lhs)\n    rhs_code = self._print(rhs)\n    op = expr.rel_op\n    return \"{} {} {}\".format(lhs_code, op, rhs_code)",
    "sympy.sympy.printing.rust._print_Indexed": "def _print_Indexed(self, expr):\n    # calculate index for 1d array\n    dims = expr.shape\n    elem = S.Zero\n    offset = S.One\n    for i in reversed(range(expr.rank)):\n        elem += expr.indices[i]*offset\n        offset *= dims[i]\n    return \"%s[%s]\" % (self._print(expr.base.label), self._print(elem))",
    "sympy.sympy.printing.rust._print_Idx": "def _print_Idx(self, expr):\n    return expr.label.name",
    "sympy.sympy.printing.rust._print_Dummy": "def _print_Dummy(self, expr):\n    return expr.name",
    "sympy.sympy.printing.rust._print_Exp1": "def _print_Exp1(self, expr, _type=False):\n    return \"E\"",
    "sympy.sympy.printing.rust._print_Pi": "def _print_Pi(self, expr, _type=False):\n    return 'PI'",
    "sympy.sympy.printing.rust._print_Infinity": "def _print_Infinity(self, expr, _type=False):\n    return 'INFINITY'",
    "sympy.sympy.printing.rust._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr, _type=False):\n    return 'NEG_INFINITY'",
    "sympy.sympy.printing.rust._print_BooleanTrue": "def _print_BooleanTrue(self, expr, _type=False):\n    return \"true\"",
    "sympy.sympy.printing.rust._print_BooleanFalse": "def _print_BooleanFalse(self, expr, _type=False):\n    return \"false\"",
    "sympy.sympy.printing.rust._print_NaN": "def _print_NaN(self, expr, _type=False):\n    return \"NAN\"",
    "sympy.sympy.printing.rust._print_Piecewise": "def _print_Piecewise(self, expr):\n    if expr.args[-1].cond != True:\n        # We need the last conditional to be a True, otherwise the resulting\n        # function may not return a result.\n        raise ValueError(\"All Piecewise expressions must contain an \"\n                         \"(expr, True) statement to be used as a default \"\n                         \"condition. Without one, the generated \"\n                         \"expression may not evaluate to anything under \"\n                         \"some condition.\")\n    lines = []\n\n    for i, (e, c) in enumerate(expr.args):\n        if i == 0:\n            lines.append(\"if (%s) {\" % self._print(c))\n        elif i == len(expr.args) - 1 and c == True:\n            lines[-1] += \" else {\"\n        else:\n            lines[-1] += \" else if (%s) {\" % self._print(c)\n        code0 = self._print(e)\n        lines.append(code0)\n        lines.append(\"}\")\n\n    if self._settings['inline']:\n        return \" \".join(lines)\n    else:\n        return \"\\n\".join(lines)",
    "sympy.sympy.printing.rust._print_ITE": "def _print_ITE(self, expr):\n    from sympy.functions import Piecewise\n    return self._print(expr.rewrite(Piecewise, deep=False))",
    "sympy.sympy.printing.rust._print_MatrixBase": "def _print_MatrixBase(self, A):\n    if A.cols == 1:\n        return \"[%s]\" % \", \".join(self._print(a) for a in A)\n    else:\n        raise ValueError(\"Full Matrix Support in Rust need Crates (https://crates.io/keywords/matrix).\")",
    "sympy.sympy.printing.rust._print_SparseRepMatrix": "def _print_SparseRepMatrix(self, mat):\n    # do not allow sparse matrices to be made dense\n    return self._print_not_supported(mat)",
    "sympy.sympy.printing.rust._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return \"%s[%s]\" % (expr.parent,\n                       expr.j + expr.i*expr.parent.shape[1])",
    "sympy.sympy.printing.rust._print_Symbol": "def _print_Symbol(self, expr):\n\n    name = super()._print_Symbol(expr)\n\n    if expr in self._dereference:\n        return '(*%s)' % name\n    else:\n        return name",
    "sympy.sympy.printing.rust._print_Assignment": "def _print_Assignment(self, expr):\n    from sympy.tensor.indexed import IndexedBase\n    lhs = expr.lhs\n    rhs = expr.rhs\n    if self._settings[\"contract\"] and (lhs.has(IndexedBase) or\n            rhs.has(IndexedBase)):\n        # Here we check if there is looping to be done, and if so\n        # print the required loops.\n        return self._doprint_loops(rhs, lhs)\n    else:\n        lhs_code = self._print(lhs)\n        rhs_code = self._print(rhs)\n        return self._get_statement(\"%s = %s\" % (lhs_code, rhs_code))",
    "sympy.sympy.printing.rust._print_sign": "def _print_sign(self, expr):\n    arg = self._print(expr.args[0])\n    return \"(if (%s == 0.0) { 0.0 } else { (%s).signum() })\" % (arg, arg)",
    "sympy.sympy.printing.smtlib._print_Function": "def _print_Function(self, e):\n    if e in self._known_functions:\n        op = self._known_functions[e]\n    elif type(e) in self._known_functions:\n        op = self._known_functions[type(e)]\n    elif type(type(e)) == UndefinedFunction:\n        op = e.name\n    elif isinstance(e, AppliedBinaryRelation) and e.function in self._known_functions:\n        op = self._known_functions[e.function]\n        return self._s_expr(op, e.arguments)\n    else:\n        op = self._known_functions[e]  # throw KeyError\n\n    return self._s_expr(op, e.args)",
    "sympy.sympy.printing.smtlib._print_Relational": "def _print_Relational(self, e: Relational):\n    return self._print_Function(e)",
    "sympy.sympy.printing.smtlib._print_BooleanFunction": "def _print_BooleanFunction(self, e: BooleanFunction):\n    return self._print_Function(e)",
    "sympy.sympy.printing.smtlib._print_Expr": "def _print_Expr(self, e: Expr):\n    return self._print_Function(e)",
    "sympy.sympy.printing.smtlib._print_Unequality": "def _print_Unequality(self, e: Unequality):\n    if type(e) in self._known_functions:\n        return self._print_Relational(e)  # default\n    else:\n        eq_op = self._known_functions[Equality]\n        not_op = self._known_functions[Not]\n        return self._s_expr(not_op, [self._s_expr(eq_op, e.args)])",
    "sympy.sympy.printing.smtlib._print_Piecewise": "def _print_Piecewise(self, e: Piecewise):\n    def _print_Piecewise_recursive(args: typing.Union[list, tuple]):\n        e, c = args[0]\n        if len(args) == 1:\n            assert (c is True) or isinstance(c, BooleanTrue)\n            return self._print(e)\n        else:\n            ite = self._known_functions[ITE]\n            return self._s_expr(ite, [\n                c, e, _print_Piecewise_recursive(args[1:])\n            ])\n\n    return _print_Piecewise_recursive(e.args)",
    "sympy.sympy.printing.smtlib._print_Interval": "def _print_Interval(self, e: Interval):\n    if e.start.is_infinite and e.end.is_infinite:\n        return ''\n    elif e.start.is_infinite != e.end.is_infinite:\n        raise ValueError(f'One-sided intervals (`{e}`) are not supported in SMT.')\n    else:\n        return f'[{e.start}, {e.end}]'",
    "sympy.sympy.printing.smtlib._print_AppliedPredicate": "def _print_AppliedPredicate(self, e: AppliedPredicate):\n    if e.function == Q.positive:\n        rel = Q.gt(e.arguments[0],0)\n    elif e.function == Q.negative:\n        rel = Q.lt(e.arguments[0], 0)\n    elif e.function == Q.zero:\n        rel = Q.eq(e.arguments[0], 0)\n    elif e.function == Q.nonpositive:\n        rel = Q.le(e.arguments[0], 0)\n    elif e.function == Q.nonnegative:\n        rel = Q.ge(e.arguments[0], 0)\n    elif e.function == Q.nonzero:\n        rel = Q.ne(e.arguments[0], 0)\n    else:\n        raise ValueError(f\"Predicate (`{e}`) is not handled.\")\n\n    return self._print_AppliedBinaryRelation(rel)",
    "sympy.sympy.printing.smtlib._print_AppliedBinaryRelation": "def _print_AppliedBinaryRelation(self, e: AppliedPredicate):\n    if e.function == Q.ne:\n        return self._print_Unequality(Unequality(*e.arguments))\n    else:\n        return self._print_Function(e)",
    "sympy.sympy.printing.smtlib._print_BooleanTrue": "def _print_BooleanTrue(self, x: BooleanTrue):\n    return 'true'",
    "sympy.sympy.printing.smtlib._print_BooleanFalse": "def _print_BooleanFalse(self, x: BooleanFalse):\n    return 'false'",
    "sympy.sympy.printing.smtlib._print_Float": "def _print_Float(self, x: Float):\n    dps = prec_to_dps(x._prec)\n    str_real = mlib_to_str(x._mpf_, dps, strip_zeros=True, min_fixed=None, max_fixed=None)\n\n    if 'e' in str_real:\n        (mant, exp) = str_real.split('e')\n\n        if exp[0] == '+':\n            exp = exp[1:]\n\n        mul = self._known_functions[Mul]\n        pow = self._known_functions[Pow]\n\n        return r\"(%s %s (%s 10 %s))\" % (mul, mant, pow, exp)\n    elif str_real in [\"+inf\", \"-inf\"]:\n        raise ValueError(\"Infinite values are not supported in SMT.\")\n    else:\n        return str_real",
    "sympy.sympy.printing.smtlib._print_Rational": "def _print_Rational(self, x: Rational):\n    return self._s_expr('/', [x.p, x.q])",
    "sympy.sympy.printing.smtlib._print_Integer": "def _print_Integer(self, x: Integer):\n    assert x.q == 1\n    return str(x.p)",
    "sympy.sympy.printing.smtlib._print_int": "def _print_int(self, x: int):\n    return str(x)",
    "sympy.sympy.printing.smtlib._print_Symbol": "def _print_Symbol(self, x: Symbol):\n    assert self._is_legal_name(x.name)\n    return x.name",
    "sympy.sympy.printing.smtlib._print_NumberSymbol": "def _print_NumberSymbol(self, x):\n    name = self._known_constants.get(x)\n    if name:\n        return name\n    else:\n        f = x.evalf(self._precision) if self._precision else x.evalf()\n        return self._print_Float(f)",
    "sympy.sympy.printing.smtlib._print_UndefinedFunction": "def _print_UndefinedFunction(self, x):\n    assert self._is_legal_name(x.name)\n    return x.name",
    "sympy.sympy.printing.smtlib._print_Exp1": "def _print_Exp1(self, x):\n    return (\n        self._print_Function(exp(1, evaluate=False))\n        if exp in self._known_functions else\n        self._print_NumberSymbol(x)\n    )",
    "sympy.sympy.printing.str._print_str": "def _print_str(self, expr):\n    return str(expr)",
    "sympy.sympy.printing.str._print_Str": "def _print_Str(self, s):\n    return self._print(s.name)",
    "sympy.sympy.printing.str._print_Basic": "def _print_Basic(self, expr):\n    l = [self._print(o) for o in expr.args]\n    return expr.__class__.__name__ + \"(%s)\" % \", \".join(l)",
    "sympy.sympy.printing.str._print_BlockMatrix": "def _print_BlockMatrix(self, B):\n    if B.blocks.shape == (1, 1):\n        self._print(B.blocks[0, 0])\n    return self._print(B.blocks)",
    "sympy.sympy.printing.str._print_Catalan": "def _print_Catalan(self, expr):\n    return 'Catalan'",
    "sympy.sympy.printing.str._print_ComplexInfinity": "def _print_ComplexInfinity(self, expr):\n    return 'zoo'",
    "sympy.sympy.printing.str._print_ConditionSet": "def _print_ConditionSet(self, s):\n    args = tuple([self._print(i) for i in (s.sym, s.condition)])\n    if s.base_set is S.UniversalSet:\n        return 'ConditionSet(%s, %s)' % args\n    args += (self._print(s.base_set),)\n    return 'ConditionSet(%s, %s, %s)' % args",
    "sympy.sympy.printing.str._print_Derivative": "def _print_Derivative(self, expr):\n    dexpr = expr.expr\n    dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]\n    return 'Derivative(%s)' % \", \".join((self._print(arg) for arg in [dexpr] + dvars))",
    "sympy.sympy.printing.str._print_dict": "def _print_dict(self, d):\n    keys = sorted(d.keys(), key=default_sort_key)\n    items = []\n\n    for key in keys:\n        item = \"%s: %s\" % (self._print(key), self._print(d[key]))\n        items.append(item)\n\n    return \"{%s}\" % \", \".join(items)",
    "sympy.sympy.printing.str._print_Dict": "def _print_Dict(self, expr):\n    return self._print_dict(expr)",
    "sympy.sympy.printing.str._print_RandomDomain": "def _print_RandomDomain(self, d):\n    if hasattr(d, 'as_boolean'):\n        return 'Domain: ' + self._print(d.as_boolean())\n    elif hasattr(d, 'set'):\n        return ('Domain: ' + self._print(d.symbols) + ' in ' +\n                self._print(d.set))\n    else:\n        return 'Domain on ' + self._print(d.symbols)",
    "sympy.sympy.printing.str._print_Dummy": "def _print_Dummy(self, expr):\n    return '_' + expr.name",
    "sympy.sympy.printing.str._print_EulerGamma": "def _print_EulerGamma(self, expr):\n    return 'EulerGamma'",
    "sympy.sympy.printing.str._print_Exp1": "def _print_Exp1(self, expr):\n    return 'E'",
    "sympy.sympy.printing.str._print_ExprCondPair": "def _print_ExprCondPair(self, expr):\n    return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))",
    "sympy.sympy.printing.str._print_Function": "def _print_Function(self, expr):\n    return expr.func.__name__ + \"(%s)\" % self.stringify(expr.args, \", \")",
    "sympy.sympy.printing.str._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    return 'GoldenRatio'",
    "sympy.sympy.printing.str._print_Heaviside": "def _print_Heaviside(self, expr):\n    # Same as _print_Function but uses pargs to suppress default 1/2 for\n    # 2nd args\n    return expr.func.__name__ + \"(%s)\" % self.stringify(expr.pargs, \", \")",
    "sympy.sympy.printing.str._print_TribonacciConstant": "def _print_TribonacciConstant(self, expr):\n    return 'TribonacciConstant'",
    "sympy.sympy.printing.str._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return 'I'",
    "sympy.sympy.printing.str._print_Infinity": "def _print_Infinity(self, expr):\n    return 'oo'",
    "sympy.sympy.printing.str._print_Integral": "def _print_Integral(self, expr):\n    def _xab_tostr(xab):\n        if len(xab) == 1:\n            return self._print(xab[0])\n        else:\n            return self._print((xab[0],) + tuple(xab[1:]))\n    L = ', '.join([_xab_tostr(l) for l in expr.limits])\n    return 'Integral(%s, %s)' % (self._print(expr.function), L)",
    "sympy.sympy.printing.str._print_Interval": "def _print_Interval(self, i):\n    fin =  'Interval{m}({a}, {b})'\n    a, b, l, r = i.args\n    if a.is_infinite and b.is_infinite:\n        m = ''\n    elif a.is_infinite and not r:\n        m = ''\n    elif b.is_infinite and not l:\n        m = ''\n    elif not l and not r:\n        m = ''\n    elif l and r:\n        m = '.open'\n    elif l:\n        m = '.Lopen'\n    else:\n        m = '.Ropen'\n    return fin.format(**{'a': a, 'b': b, 'm': m})",
    "sympy.sympy.printing.str._print_AccumulationBounds": "def _print_AccumulationBounds(self, i):\n    return \"AccumBounds(%s, %s)\" % (self._print(i.min),\n                                    self._print(i.max))",
    "sympy.sympy.printing.str._print_Inverse": "def _print_Inverse(self, I):\n    return \"%s**(-1)\" % self.parenthesize(I.arg, PRECEDENCE[\"Pow\"])",
    "sympy.sympy.printing.str._print_Lambda": "def _print_Lambda(self, obj):\n    expr = obj.expr\n    sig = obj.signature\n    if len(sig) == 1 and sig[0].is_symbol:\n        sig = sig[0]\n    return \"Lambda(%s, %s)\" % (self._print(sig), self._print(expr))",
    "sympy.sympy.printing.str._print_LatticeOp": "def _print_LatticeOp(self, expr):\n    args = sorted(expr.args, key=default_sort_key)\n    return expr.func.__name__ + \"(%s)\" % \", \".join(self._print(arg) for arg in args)",
    "sympy.sympy.printing.str._print_Limit": "def _print_Limit(self, expr):\n    e, z, z0, dir = expr.args\n    return \"Limit(%s, %s, %s, dir='%s')\" % tuple(map(self._print, (e, z, z0, dir)))",
    "sympy.sympy.printing.str._print_list": "def _print_list(self, expr):\n    return \"[%s]\" % self.stringify(expr, \", \")",
    "sympy.sympy.printing.str._print_List": "def _print_List(self, expr):\n    return self._print_list(expr)",
    "sympy.sympy.printing.str._print_MatrixBase": "def _print_MatrixBase(self, expr):\n    return expr._format_str(self)",
    "sympy.sympy.printing.str._print_MatrixElement": "def _print_MatrixElement(self, expr):\n    return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n        + '[%s, %s]' % (self._print(expr.i), self._print(expr.j))",
    "sympy.sympy.printing.str._print_MatrixSlice": "def _print_MatrixSlice(self, expr):\n    def strslice(x, dim):\n        x = list(x)\n        if x[2] == 1:\n            del x[2]\n        if x[0] == 0:\n            x[0] = ''\n        if x[1] == dim:\n            x[1] = ''\n        return ':'.join((self._print(arg) for arg in x))\n    return (self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) + '[' +\n            strslice(expr.rowslice, expr.parent.rows) + ', ' +\n            strslice(expr.colslice, expr.parent.cols) + ']')",
    "sympy.sympy.printing.str._print_DeferredVector": "def _print_DeferredVector(self, expr):\n    return expr.name",
    "sympy.sympy.printing.str._print_Mul": "def _print_Mul(self, expr):\n\n    prec = precedence(expr)\n\n    # Check for unevaluated Mul. In this case we need to make sure the\n    # identities are visible, multiple Rational factors are not combined\n    # etc so we display in a straight-forward form that fully preserves all\n    # args and their order.\n    args = expr.args\n    if args[0] is S.One or any(\n            isinstance(a, Number) or\n            a.is_Pow and all(ai.is_Integer for ai in a.args)\n            for a in args[1:]):\n        d, n = sift(args, lambda x:\n            isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0),\n            binary=True)\n        for i, di in enumerate(d):\n            if di.exp.is_Number:\n                e = -di.exp\n            else:\n                dargs = list(di.exp.args)\n                dargs[0] = -dargs[0]\n                e = Mul._from_args(dargs)\n            d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base\n\n        pre = []\n        # don't parenthesize first factor if negative\n        if n and not n[0].is_Add and n[0].could_extract_minus_sign():\n            pre = [self._print(n.pop(0))]\n\n        nfactors = pre + [self.parenthesize(a, prec, strict=False)\n            for a in n]\n        if not nfactors:\n            nfactors = ['1']\n\n        # don't parenthesize first of denominator unless singleton\n        if len(d) > 1 and d[0].could_extract_minus_sign():\n            pre = [self._print(d.pop(0))]\n        else:\n            pre = []\n        dfactors = pre + [self.parenthesize(a, prec, strict=False)\n            for a in d]\n\n        n = '*'.join(nfactors)\n        d = '*'.join(dfactors)\n        if len(dfactors) > 1:\n            return '%s/(%s)' % (n, d)\n        elif dfactors:\n            return '%s/%s' % (n, d)\n        return n\n\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = \"-\"\n    else:\n        sign = \"\"\n\n    a = []  # items in the numerator\n    b = []  # items that are in the denominator (if any)\n\n    pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        # use make_args in case expr was something like -x -> x\n        args = Mul.make_args(expr)\n\n    # Gather args for numerator/denominator\n    def apow(i):\n        b, e = i.as_base_exp()\n        eargs = list(Mul.make_args(e))\n        if eargs[0] is S.NegativeOne:\n            eargs = eargs[1:]\n        else:\n            eargs[0] = -eargs[0]\n        e = Mul._from_args(eargs)\n        if isinstance(i, Pow):\n            return i.func(b, e, evaluate=False)\n        return i.func(e, evaluate=False)\n    for item in args:\n        if (item.is_commutative and\n                isinstance(item, Pow) and\n                bool(item.exp.as_coeff_Mul()[0] < 0)):\n            if item.exp is not S.NegativeOne:\n                b.append(apow(item))\n            else:\n                if (len(item.args[0].args) != 1 and\n                        isinstance(item.base, (Mul, Pow))):\n                    # To avoid situations like #14160\n                    pow_paren.append(item)\n                b.append(item.base)\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append(Rational(item.p))\n            if item.q != 1:\n                b.append(Rational(item.q))\n        else:\n            a.append(item)\n\n    a = a or [S.One]\n\n    a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n    b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n\n    # To parenthesize Pow with exp = -1 and having more than one Symbol\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n\n    if not b:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + \"/\" + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + \"/(%s)\" % '*'.join(b_str)",
    "sympy.sympy.printing.str._print_MatMul": "def _print_MatMul(self, expr):\n    c, m = expr.as_coeff_mmul()\n\n    sign = \"\"\n    if c.is_number:\n        re, im = c.as_real_imag()\n        if im.is_zero and re.is_negative:\n            expr = _keep_coeff(-c, m)\n            sign = \"-\"\n        elif re.is_zero and im.is_negative:\n            expr = _keep_coeff(-c, m)\n            sign = \"-\"\n\n    return sign + '*'.join(\n        [self.parenthesize(arg, precedence(expr)) for arg in expr.args]\n    )",
    "sympy.sympy.printing.str._print_ElementwiseApplyFunction": "def _print_ElementwiseApplyFunction(self, expr):\n    return \"{}.({})\".format(\n        expr.function,\n        self._print(expr.expr),\n    )",
    "sympy.sympy.printing.str._print_NaN": "def _print_NaN(self, expr):\n    return 'nan'",
    "sympy.sympy.printing.str._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-oo'",
    "sympy.sympy.printing.str._print_Order": "def _print_Order(self, expr):\n    if not expr.variables or all(p is S.Zero for p in expr.point):\n        if len(expr.variables) <= 1:\n            return 'O(%s)' % self._print(expr.expr)\n        else:\n            return 'O(%s)' % self.stringify((expr.expr,) + expr.variables, ', ', 0)\n    else:\n        return 'O(%s)' % self.stringify(expr.args, ', ', 0)",
    "sympy.sympy.printing.str._print_Cycle": "def _print_Cycle(self, expr):\n    return expr.__str__()",
    "sympy.sympy.printing.str._print_Permutation": "def _print_Permutation(self, expr):\n    from sympy.combinatorics.permutations import Permutation, Cycle\n    from sympy.utilities.exceptions import sympy_deprecation_warning\n\n    perm_cyclic = Permutation.print_cyclic\n    if perm_cyclic is not None:\n        sympy_deprecation_warning(\n            f\"\"\"\n            Setting Permutation.print_cyclic is deprecated. Instead use\n            init_printing(perm_cyclic={perm_cyclic}).\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-permutation-print_cyclic\",\n            stacklevel=7,\n        )\n    else:\n        perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n    if perm_cyclic:\n        if not expr.size:\n            return '()'\n        # before taking Cycle notation, see if the last element is\n        # a singleton and move it to the head of the string\n        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]\n        last = s.rfind('(')\n        if not last == 0 and ',' not in s[last:]:\n            s = s[last:] + s[:last]\n        s = s.replace(',', '')\n        return s\n    else:\n        s = expr.support()\n        if not s:\n            if expr.size < 5:\n                return 'Permutation(%s)' % self._print(expr.array_form)\n            return 'Permutation([], size=%s)' % self._print(expr.size)\n        trim = self._print(expr.array_form[:s[-1] + 1]) + ', size=%s' % self._print(expr.size)\n        use = full = self._print(expr.array_form)\n        if len(trim) < len(full):\n            use = trim\n        return 'Permutation(%s)' % use",
    "sympy.sympy.printing.str.emptyPrinter": "def emptyPrinter(self, expr):\n    if isinstance(expr, str):\n        return expr\n    elif isinstance(expr, Basic):\n        return repr(expr)\n    else:\n        return str(expr)",
    "sympy.sympy.printing.str._print_Subs": "def _print_Subs(self, obj):\n    expr, old, new = obj.args\n    if len(obj.point) == 1:\n        old = old[0]\n        new = new[0]\n    return \"Subs(%s, %s, %s)\" % (\n        self._print(expr), self._print(old), self._print(new))",
    "sympy.sympy.printing.str._print_TensorIndex": "def _print_TensorIndex(self, expr):\n    return expr._print()",
    "sympy.sympy.printing.str._print_TensorHead": "def _print_TensorHead(self, expr):\n    return expr._print()",
    "sympy.sympy.printing.str._print_Tensor": "def _print_Tensor(self, expr):\n    return expr._print()",
    "sympy.sympy.printing.str._print_TensMul": "def _print_TensMul(self, expr):\n    # prints expressions like \"A(a)\", \"3*A(a)\", \"(1+x)*A(a)\"\n    sign, args = expr._get_args_for_traditional_printer()\n    return sign + \"*\".join(\n        [self.parenthesize(arg, precedence(expr)) for arg in args]\n    )",
    "sympy.sympy.printing.str._print_TensAdd": "def _print_TensAdd(self, expr):\n    return expr._print()",
    "sympy.sympy.printing.str._print_ArraySymbol": "def _print_ArraySymbol(self, expr):\n    return self._print(expr.name)",
    "sympy.sympy.printing.str._print_ArrayElement": "def _print_ArrayElement(self, expr):\n    return \"%s[%s]\" % (\n        self.parenthesize(expr.name, PRECEDENCE[\"Func\"], True), \", \".join([self._print(i) for i in expr.indices]))",
    "sympy.sympy.printing.str._print_Pi": "def _print_Pi(self, expr):\n    return 'pi'",
    "sympy.sympy.printing.str._print_PolyRing": "def _print_PolyRing(self, ring):\n    return \"Polynomial ring in %s over %s with %s order\" % \\\n        (\", \".join((self._print(rs) for rs in ring.symbols)),\n        self._print(ring.domain), self._print(ring.order))",
    "sympy.sympy.printing.str._print_FracField": "def _print_FracField(self, field):\n    return \"Rational function field in %s over %s with %s order\" % \\\n        (\", \".join((self._print(fs) for fs in field.symbols)),\n        self._print(field.domain), self._print(field.order))",
    "sympy.sympy.printing.str._print_GaussianElement": "def _print_GaussianElement(self, poly):\n    return \"(%s + %s*I)\" % (poly.x, poly.y)",
    "sympy.sympy.printing.str._print_PolyElement": "def _print_PolyElement(self, poly):\n    return poly.str(self, PRECEDENCE, \"%s**%s\", \"*\")",
    "sympy.sympy.printing.str._print_FracElement": "def _print_FracElement(self, frac):\n    if frac.denom == 1:\n        return self._print(frac.numer)\n    else:\n        numer = self.parenthesize(frac.numer, PRECEDENCE[\"Mul\"], strict=True)\n        denom = self.parenthesize(frac.denom, PRECEDENCE[\"Atom\"], strict=True)\n        return numer + \"/\" + denom",
    "sympy.sympy.printing.str._print_Add": "def _print_Add(self, expr, order=None):\n    terms = self._as_ordered_terms(expr, order=order)\n\n    prec = precedence(expr)\n    l = []\n    for term in terms:\n        t = self._print(term)\n        if t.startswith('-') and not term.is_Add:\n            sign = \"-\"\n            t = t[1:]\n        else:\n            sign = \"+\"\n        if precedence(term) < prec or term.is_Add:\n            l.extend([sign, \"(%s)\" % t])\n        else:\n            l.extend([sign, t])\n    sign = l.pop(0)\n    if sign == '+':\n        sign = \"\"\n    return sign + ' '.join(l)",
    "sympy.sympy.printing.str._print_Poly": "def _print_Poly(self, expr):\n    ATOM_PREC = PRECEDENCE[\"Atom\"] - 1\n    terms, gens = [], [ self.parenthesize(s, ATOM_PREC) for s in expr.gens ]\n\n    for monom, coeff in expr.terms():\n        s_monom = []\n\n        for i, e in enumerate(monom):\n            if e > 0:\n                if e == 1:\n                    s_monom.append(gens[i])\n                else:\n                    s_monom.append(gens[i] + \"**%d\" % e)\n\n        s_monom = \"*\".join(s_monom)\n\n        if coeff.is_Add:\n            if s_monom:\n                s_coeff = \"(\" + self._print(coeff) + \")\"\n            else:\n                s_coeff = self._print(coeff)\n        else:\n            if s_monom:\n                if coeff is S.One:\n                    terms.extend(['+', s_monom])\n                    continue\n\n                if coeff is S.NegativeOne:\n                    terms.extend(['-', s_monom])\n                    continue\n\n            s_coeff = self._print(coeff)\n\n        if not s_monom:\n            s_term = s_coeff\n        else:\n            s_term = s_coeff + \"*\" + s_monom\n\n        if s_term.startswith('-'):\n            terms.extend(['-', s_term[1:]])\n        else:\n            terms.extend(['+', s_term])\n\n    if terms[0] in ('-', '+'):\n        modifier = terms.pop(0)\n\n        if modifier == '-':\n            terms[0] = '-' + terms[0]\n\n    format = expr.__class__.__name__ + \"(%s, %s\"\n\n    from sympy.polys.polyerrors import PolynomialError\n\n    try:\n        format += \", modulus=%s\" % expr.get_modulus()\n    except PolynomialError:\n        format += \", domain='%s'\" % expr.get_domain()\n\n    format += \")\"\n\n    for index, item in enumerate(gens):\n        if len(item) > 2 and (item[:1] == \"(\" and item[len(item) - 1:] == \")\"):\n            gens[index] = item[1:len(item) - 1]\n\n    return format % (' '.join(terms), ', '.join(gens))",
    "sympy.sympy.printing.str._print_UniversalSet": "def _print_UniversalSet(self, p):\n    return 'UniversalSet'",
    "sympy.sympy.printing.str._print_AlgebraicNumber": "def _print_AlgebraicNumber(self, expr):\n    if expr.is_aliased:\n        return self._print(expr.as_poly().as_expr())\n    else:\n        return self._print(expr.as_expr())",
    "sympy.sympy.printing.str._print_Pow": "def _print_Pow(self, expr, rational=False):\n    \"\"\"Printing helper function for ``Pow``\n\n    Parameters\n    ==========\n\n    rational : bool, optional\n        If ``True``, it will not attempt printing ``sqrt(x)`` or\n        ``x**S.Half`` as ``sqrt``, and will use ``x**(1/2)``\n        instead.\n\n        See examples for additional details\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt, StrPrinter\n    >>> from sympy.abc import x\n\n    How ``rational`` keyword works with ``sqrt``:\n\n    >>> printer = StrPrinter()\n    >>> printer._print_Pow(sqrt(x), rational=True)\n    'x**(1/2)'\n    >>> printer._print_Pow(sqrt(x), rational=False)\n    'sqrt(x)'\n    >>> printer._print_Pow(1/sqrt(x), rational=True)\n    'x**(-1/2)'\n    >>> printer._print_Pow(1/sqrt(x), rational=False)\n    '1/sqrt(x)'\n\n    Notes\n    =====\n\n    ``sqrt(x)`` is canonicalized as ``Pow(x, S.Half)`` in SymPy,\n    so there is no need of defining a separate printer for ``sqrt``.\n    Instead, it should be handled here as well.\n    \"\"\"\n    PREC = precedence(expr)\n\n    if expr.exp is S.Half and not rational:\n        return \"sqrt(%s)\" % self._print(expr.base)\n\n    if expr.is_commutative:\n        if -expr.exp is S.Half and not rational:\n            # Note: Don't test \"expr.exp == -S.Half\" here, because that will\n            # match -0.5, which we don't want.\n            return \"%s/sqrt(%s)\" % tuple((self._print(arg) for arg in (S.One, expr.base)))\n        if expr.exp is -S.One:\n            # Similarly to the S.Half case, don't test with \"==\" here.\n            return '%s/%s' % (self._print(S.One),\n                              self.parenthesize(expr.base, PREC, strict=False))\n\n    e = self.parenthesize(expr.exp, PREC, strict=False)\n    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and expr.exp.q != 1:\n        # the parenthesized exp should be '(Rational(a, b))' so strip parens,\n        # but just check to be sure.\n        if e.startswith('(Rational'):\n            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])\n    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)",
    "sympy.sympy.printing.str._print_UnevaluatedExpr": "def _print_UnevaluatedExpr(self, expr):\n    return self._print(expr.args[0])",
    "sympy.sympy.printing.str._print_MatPow": "def _print_MatPow(self, expr):\n    PREC = precedence(expr)\n    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False),\n                     self.parenthesize(expr.exp, PREC, strict=False))",
    "sympy.sympy.printing.str._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get(\"sympy_integers\", False):\n        return \"S(%s)\" % (expr)\n    return str(expr.p)",
    "sympy.sympy.printing.str._print_Integers": "def _print_Integers(self, expr):\n    return 'Integers'",
    "sympy.sympy.printing.str._print_Naturals": "def _print_Naturals(self, expr):\n    return 'Naturals'",
    "sympy.sympy.printing.str._print_Naturals0": "def _print_Naturals0(self, expr):\n    return 'Naturals0'",
    "sympy.sympy.printing.str._print_Reals": "def _print_Reals(self, expr):\n    return 'Reals'",
    "sympy.sympy.printing.str._print_Complexes": "def _print_Complexes(self, expr):\n    return 'Complexes'",
    "sympy.sympy.printing.str._print_EmptySet": "def _print_EmptySet(self, expr):\n    return 'EmptySet'",
    "sympy.sympy.printing.str._print_int": "def _print_int(self, expr):\n    return str(expr)",
    "sympy.sympy.printing.str._print_Rational": "def _print_Rational(self, expr):\n    if expr.q == 1:\n        return str(expr.p)\n    else:\n        if self._settings.get(\"sympy_integers\", False):\n            return \"S(%s)/%s\" % (expr.p, expr.q)\n        return \"%s/%s\" % (expr.p, expr.q)",
    "sympy.sympy.printing.str._print_Float": "def _print_Float(self, expr):\n    prec = expr._prec\n    dps = self._settings.get('dps', None)\n    if dps is None:\n        dps = 0 if prec < 5 else prec_to_dps(expr._prec)\n    if self._settings[\"full_prec\"] is True:\n        strip = False\n    elif self._settings[\"full_prec\"] is False:\n        strip = True\n    elif self._settings[\"full_prec\"] == \"auto\":\n        strip = self._print_level > 1\n    low = self._settings[\"min\"] if \"min\" in self._settings else None\n    high = self._settings[\"max\"] if \"max\" in self._settings else None\n    rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)\n    if rv.startswith('-.0'):\n        rv = '-0.' + rv[3:]\n    elif rv.startswith('.0'):\n        rv = '0.' + rv[2:]\n    rv = rv.removeprefix('+') # e.g., +inf -> inf\n    return rv",
    "sympy.sympy.printing.str._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return \"True\"",
    "sympy.sympy.printing.str._print_Relational": "def _print_Relational(self, expr):\n\n    charmap = {\n        \"==\": \"Eq\",\n        \"!=\": \"Ne\",\n        \":=\": \"Assignment\",\n        '+=': \"AddAugmentedAssignment\",\n        \"-=\": \"SubAugmentedAssignment\",\n        \"*=\": \"MulAugmentedAssignment\",\n        \"/=\": \"DivAugmentedAssignment\",\n        \"%=\": \"ModAugmentedAssignment\",\n    }\n\n    if expr.rel_op in charmap:\n        return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs),\n                               self._print(expr.rhs))\n\n    return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),\n                       self._relationals.get(expr.rel_op) or expr.rel_op,\n                       self.parenthesize(expr.rhs, precedence(expr)))",
    "sympy.sympy.printing.str._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return \"False\"",
    "sympy.sympy.printing.str._print_ComplexRootOf": "def _print_ComplexRootOf(self, expr):\n    return \"CRootOf(%s, %d)\" % (self._print_Add(expr.expr,  order='lex'),\n                                expr.index)",
    "sympy.sympy.printing.str._print_RootSum": "def _print_RootSum(self, expr):\n    args = [self._print_Add(expr.expr, order='lex')]\n\n    if expr.fun is not S.IdentityFunction:\n        args.append(self._print(expr.fun))\n\n    return \"RootSum(%s)\" % \", \".join(args)",
    "sympy.sympy.printing.str._print_GroebnerBasis": "def _print_GroebnerBasis(self, basis):\n    cls = basis.__class__.__name__\n\n    exprs = [self._print_Add(arg, order=basis.order) for arg in basis.exprs]\n    exprs = \"[%s]\" % \", \".join(exprs)\n\n    gens = [ self._print(gen) for gen in basis.gens ]\n    domain = \"domain='%s'\" % self._print(basis.domain)\n    order = \"order='%s'\" % self._print(basis.order)\n\n    args = [exprs] + gens + [domain, order]\n\n    return \"%s(%s)\" % (cls, \", \".join(args))",
    "sympy.sympy.printing.str._print_Not": "def _print_Not(self, expr):\n    return '~%s' %(self.parenthesize(expr.args[0],PRECEDENCE[\"Not\"]))",
    "sympy.sympy.printing.str._print_set": "def _print_set(self, s):\n    items = sorted(s, key=default_sort_key)\n\n    args = ', '.join(self._print(item) for item in items)\n    if not args:\n        return \"set()\"\n    return '{%s}' % args",
    "sympy.sympy.printing.str._print_FiniteSet": "def _print_FiniteSet(self, s):\n    from sympy.sets.sets import FiniteSet\n    items = sorted(s, key=default_sort_key)\n\n    args = ', '.join(self._print(item) for item in items)\n    if any(item.has(FiniteSet) for item in items):\n        return 'FiniteSet({})'.format(args)\n    return '{{{}}}'.format(args)",
    "sympy.sympy.printing.str._print_Partition": "def _print_Partition(self, s):\n    items = sorted(s, key=default_sort_key)\n\n    args = ', '.join(self._print(arg) for arg in items)\n    return 'Partition({})'.format(args)",
    "sympy.sympy.printing.str._print_frozenset": "def _print_frozenset(self, s):\n    if not s:\n        return \"frozenset()\"\n    return \"frozenset(%s)\" % self._print_set(s)",
    "sympy.sympy.printing.str._print_And": "def _print_And(self, expr):\n    args = list(expr.args)\n    for j, i in enumerate(args):\n        if isinstance(i, Relational) and (\n                i.canonical.rhs is S.NegativeInfinity):\n            args.insert(0, args.pop(j))\n    return self.stringify(args, \" & \", PRECEDENCE[\"BitwiseAnd\"])",
    "sympy.sympy.printing.str._print_Sum": "def _print_Sum(self, expr):\n    def _xab_tostr(xab):\n        if len(xab) == 1:\n            return self._print(xab[0])\n        else:\n            return self._print((xab[0],) + tuple(xab[1:]))\n    L = ', '.join([_xab_tostr(l) for l in expr.limits])\n    return 'Sum(%s, %s)' % (self._print(expr.function), L)",
    "sympy.sympy.printing.str._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    "sympy.sympy.printing.str._print_Identity": "def _print_Identity(self, expr):\n    return \"I\"",
    "sympy.sympy.printing.str._print_ZeroMatrix": "def _print_ZeroMatrix(self, expr):\n    return \"0\"",
    "sympy.sympy.printing.str._print_OneMatrix": "def _print_OneMatrix(self, expr):\n    return \"1\"",
    "sympy.sympy.printing.str._print_Predicate": "def _print_Predicate(self, expr):\n    return \"Q.%s\" % expr.name",
    "sympy.sympy.printing.str._print_tuple": "def _print_tuple(self, expr):\n    if len(expr) == 1:\n        return \"(%s,)\" % self._print(expr[0])\n    else:\n        return \"(%s)\" % self.stringify(expr, \", \")",
    "sympy.sympy.printing.str._print_Tuple": "def _print_Tuple(self, expr):\n    return self._print_tuple(expr)",
    "sympy.sympy.printing.str._print_Transpose": "def _print_Transpose(self, T):\n    return \"%s.T\" % self.parenthesize(T.arg, PRECEDENCE[\"Pow\"])",
    "sympy.sympy.printing.str._print_Quantity": "def _print_Quantity(self, expr):\n    if self._settings.get(\"abbrev\", False):\n        return \"%s\" % expr.abbrev\n    return \"%s\" % expr.name",
    "sympy.sympy.printing.str._print_Quaternion": "def _print_Quaternion(self, expr):\n    s = [self.parenthesize(i, PRECEDENCE[\"Mul\"], strict=True) for i in expr.args]\n    a = [s[0]] + [i+\"*\"+j for i, j in zip(s[1:], \"ijk\")]\n    return \" + \".join(a)",
    "sympy.sympy.printing.str._print_Wild": "def _print_Wild(self, expr):\n    return expr.name + '_'",
    "sympy.sympy.printing.str._print_WildFunction": "def _print_WildFunction(self, expr):\n    return expr.name + '_'",
    "sympy.sympy.printing.str._print_Zero": "def _print_Zero(self, expr):\n    if self._settings.get(\"sympy_integers\", False):\n        return \"S(0)\"\n    return self._print_Integer(Integer(0))",
    "sympy.sympy.printing.str._print_Or": "def _print_Or(self, expr):\n    return self.stringify(expr.args, \" | \", PRECEDENCE[\"BitwiseOr\"])",
    "sympy.sympy.printing.str._print_DMF": "def _print_DMF(self, expr):\n    cls = expr.__class__.__name__\n    num = self._print(expr.num)\n    den = self._print(expr.den)\n    dom = self._print(expr.dom)\n\n    return \"%s(%s, %s, %s)\" % (cls, num, den, dom)",
    "sympy.sympy.printing.str._print_Object": "def _print_Object(self, obj):\n    return 'Object(\"%s\")' % obj.name",
    "sympy.sympy.printing.str._print_IdentityMorphism": "def _print_IdentityMorphism(self, morphism):\n    return 'IdentityMorphism(%s)' % morphism.domain",
    "sympy.sympy.printing.str._print_NamedMorphism": "def _print_NamedMorphism(self, morphism):\n    return 'NamedMorphism(%s, %s, \"%s\")' % \\\n           (morphism.domain, morphism.codomain, morphism.name)",
    "sympy.sympy.printing.str._print_Category": "def _print_Category(self, category):\n    return 'Category(\"%s\")' % category.name",
    "sympy.sympy.printing.str._print_Manifold": "def _print_Manifold(self, manifold):\n    return manifold.name.name",
    "sympy.sympy.printing.str._print_Xor": "def _print_Xor(self, expr):\n    return self.stringify(expr.args, \" ^ \", PRECEDENCE[\"BitwiseXor\"])",
    "sympy.sympy.printing.str._print_Patch": "def _print_Patch(self, patch):\n    return patch.name.name",
    "sympy.sympy.printing.str._print_CoordSystem": "def _print_CoordSystem(self, coords):\n    return coords.name.name",
    "sympy.sympy.printing.str._print_BaseScalarField": "def _print_BaseScalarField(self, field):\n    return field._coord_sys.symbols[field._index].name",
    "sympy.sympy.printing.str._print_Tr": "def _print_Tr(self, expr):\n    #TODO : Handle indices\n    return \"%s(%s)\" % (\"Tr\", self._print(expr.args[0]))",
    "sympy.sympy.printing.str._print_AppliedBinaryRelation": "def _print_AppliedBinaryRelation(self, expr):\n    rel = expr.function\n    return '%s(%s, %s)' % (self._print(rel),\n                           self._print(expr.lhs),\n                           self._print(expr.rhs))",
    "sympy.sympy.printing.str._print_AppliedPredicate": "def _print_AppliedPredicate(self, expr):\n    return '%s(%s)' % (\n        self._print(expr.function), self.stringify(expr.arguments, \", \"))",
    "sympy.sympy.printing.tableform._sympystr": "def _sympystr(self, p):\n    \"\"\"\n    Returns the string representation of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import TableForm\n    >>> t = TableForm([[5, 7], [4, 2], [10, 3]])\n    >>> s = t.as_str()\n\n    \"\"\"\n    column_widths = [0] * self._w\n    lines = []\n    for line in self._lines:\n        new_line = []\n        for i in range(self._w):\n            # Format the item somehow if needed:\n            s = str(line[i])\n            if self._wipe_zeros and (s == \"0\"):\n                s = \" \"\n            w = len(s)\n            if w > column_widths[i]:\n                column_widths[i] = w\n            new_line.append(s)\n        lines.append(new_line)\n\n    # Check heading:\n    if self._headings[0]:\n        self._headings[0] = [str(x) for x in self._headings[0]]\n        _head_width = max(len(x) for x in self._headings[0])\n\n    if self._headings[1]:\n        new_line = []\n        for i in range(self._w):\n            # Format the item somehow if needed:\n            s = str(self._headings[1][i])\n            w = len(s)\n            if w > column_widths[i]:\n                column_widths[i] = w\n            new_line.append(s)\n        self._headings[1] = new_line\n\n    format_str = []\n\n    def _align(align, w):\n        return '%%%s%ss' % (\n            (\"-\" if align == \"l\" else \"\"),\n            str(w))\n    format_str = [_align(align, w) for align, w in\n                  zip(self._alignments, column_widths)]\n    if self._headings[0]:\n        format_str.insert(0, _align(self._head_align, _head_width))\n        format_str.insert(1, '|')\n    format_str = ' '.join(format_str) + '\\n'\n\n    s = []\n    if self._headings[1]:\n        d = self._headings[1]\n        if self._headings[0]:\n            d = [\"\"] + d\n        first_line = format_str % tuple(d)\n        s.append(first_line)\n        s.append(\"-\" * (len(first_line) - 1) + \"\\n\")\n    for i, line in enumerate(lines):\n        d = [l if self._alignments[j] != 'c' else\n             l.center(column_widths[j]) for j, l in enumerate(line)]\n        if self._headings[0]:\n            l = self._headings[0][i]\n            l = (l if self._head_align != 'c' else\n                 l.center(_head_width))\n            d = [l] + d\n        s.append(format_str % tuple(d))\n    return ''.join(s)[:-1]  # don't include trailing newline",
    "sympy.sympy.printing.tableform._latex": "def _latex(self, printer):\n    \"\"\"\n    Returns the string representation of 'self'.\n    \"\"\"\n    # Check heading:\n    if self._headings[1]:\n        new_line = []\n        for i in range(self._w):\n            # Format the item somehow if needed:\n            new_line.append(str(self._headings[1][i]))\n        self._headings[1] = new_line\n\n    alignments = []\n    if self._headings[0]:\n        self._headings[0] = [str(x) for x in self._headings[0]]\n        alignments = [self._head_align]\n    alignments.extend(self._alignments)\n\n    s = r\"\\begin{tabular}{\" + \" \".join(alignments) + \"}\\n\"\n\n    if self._headings[1]:\n        d = self._headings[1]\n        if self._headings[0]:\n            d = [\"\"] + d\n        first_line = \" & \".join(d) + r\" \\\\\" + \"\\n\"\n        s += first_line\n        s += r\"\\hline\" + \"\\n\"\n    for i, line in enumerate(self._lines):\n        d = []\n        for j, x in enumerate(line):\n            if self._wipe_zeros and (x in (0, \"0\")):\n                d.append(\" \")\n                continue\n            f = self._column_formats[j]\n            if f:\n                if isinstance(f, FunctionType):\n                    v = f(x, i, j)\n                    if v is None:\n                        v = printer._print(x)\n                else:\n                    v = f % x\n                d.append(v)\n            else:\n                v = printer._print(x)\n                d.append(\"$%s$\" % v)\n        if self._headings[0]:\n            d = [self._headings[0][i]] + d\n        s += \" & \".join(d) + r\" \\\\\" + \"\\n\"\n    s += r\"\\end{tabular}\"\n    return s",
    "sympy.sympy.printing.tensorflow._print_Derivative": "def _print_Derivative(self, expr):\n    variables = expr.variables\n    if any(isinstance(i, Iterable) for i in variables):\n        raise NotImplementedError(\"derivation by multiple variables is not supported\")\n    def unfold(expr, args):\n        if not args:\n            return self._print(expr)\n        return \"%s(%s, %s)[0]\" % (\n                self._module_format(\"tensorflow.gradients\"),\n                unfold(expr, args[:-1]),\n                self._print(args[-1]),\n            )\n    return unfold(expr.expr, variables)",
    "sympy.sympy.printing.tensorflow._print_MatMul": "def _print_MatMul(self, expr):\n    from sympy.matrices.expressions import MatrixExpr\n    mat_args = [arg for arg in expr.args if isinstance(arg, MatrixExpr)]\n    args = [arg for arg in expr.args if arg not in mat_args]\n    if args:\n        return \"%s*%s\" % (\n            self.parenthesize(Mul.fromiter(args), PRECEDENCE[\"Mul\"]),\n            self._expand_fold_binary_op(\n                \"tensorflow.linalg.matmul\", mat_args)\n        )\n    else:\n        return self._expand_fold_binary_op(\n            \"tensorflow.linalg.matmul\", mat_args)",
    "sympy.sympy.printing.tensorflow._print_Function": "def _print_Function(self, expr):\n    op = self.mapping.get(type(expr), None)\n    if op is None:\n        return super()._print_Basic(expr)\n    children = [self._print(arg) for arg in expr.args]\n    if len(children) == 1:\n        return \"%s(%s)\" % (\n            self._module_format(op),\n            children[0]\n        )\n    else:\n        return self._expand_fold_binary_op(op, children)",
    "sympy.sympy.sets.fancysets.__iter__": "def __iter__(self):\n    n = self.size  # validate\n    if not (n.has(S.Infinity) or n.has(S.NegativeInfinity) or n.is_Integer):\n        raise TypeError(\"Cannot iterate over symbolic Range\")\n    if self.start in [S.NegativeInfinity, S.Infinity]:\n        raise TypeError(\"Cannot iterate over Range with infinite start\")\n    elif self.start != self.stop:\n        i = self.start\n        if n.is_infinite:\n            while True:\n                yield i\n                i += self.step\n        else:\n            for _ in range(n):\n                yield i\n                i += self.step",
    "sympy.sympy.sets.setexpr._latex": "def _latex(self, printer):\n    return r\"SetExpr\\left({}\\right)\".format(printer._print(self.set))",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.stats.rv.__getattr__": "def __getattr__(self, attr):\n    try:\n        return self.args[self._argnames.index(attr)]\n    except ValueError:\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n            type(self).__name__, attr))",
    "sympy.sympy.tensor.array.ndim_array._sympystr": "def _sympystr(self, printer):\n    def f(sh, shape_left, i, j):\n        if len(shape_left) == 1:\n            return \"[\"+\", \".join([printer._print(self[self._get_tuple_index(e)]) for e in range(i, j)])+\"]\"\n\n        sh //= shape_left[0]\n        return \"[\" + \", \".join([f(sh, shape_left[1:], i+e*sh, i+(e+1)*sh) for e in range(shape_left[0])]) + \"]\" # + \"\\n\"*len(shape_left)\n\n    if self.rank() == 0:\n        return printer._print(self[()])\n    if 0 in self.shape:\n        return f\"{self.__class__.__name__}([], {self.shape})\"\n    return f(self._loop_size, self.shape, 0, self._loop_size)",
    "sympy.sympy.tensor.indexed._sympystr": "def _sympystr(self, p):\n    return p.doprint(self.label)",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1",
    "sympy.sympy.vector.basisdependent._sympystr": "def _sympystr(self, printer):\n    return '0'",
    "sympy.sympy.vector.coordsysrect._sympystr": "def _sympystr(self, printer):\n    return self._name",
    "sympy.sympy.vector.dyadic._sympystr": "def _sympystr(self, printer):\n    items = list(self.components.items())\n    items.sort(key=lambda x: x[0].__str__())\n    return \" + \".join(printer._print(k * v) for k, v in items)",
    "sympy.sympy.vector.dyadic._sympyrepr": "def _sympyrepr(self, printer):\n    return \"BaseDyadic({}, {})\".format(\n        printer._print(self.args[0]), printer._print(self.args[1]))",
    "sympy.sympy.vector.scalar._latex": "def _latex(self, printer=None):\n    return self._latex_form",
    "sympy.sympy.vector.scalar._pretty": "def _pretty(self, printer=None):\n    return prettyForm(self._pretty_form)",
    "sympy.sympy.vector.scalar._sympystr": "def _sympystr(self, printer):\n    return self._name",
    "sympy.sympy.vector.vector._sympystr": "def _sympystr(self, printer):\n    ret_str = ''\n    items = list(self.separate().items())\n    items.sort(key=lambda x: x[0].__str__())\n    for system, vect in items:\n        base_vects = system.base_vectors()\n        for x in base_vects:\n            if x in vect.components:\n                temp_vect = self.components[x] * x\n                ret_str += printer._print(temp_vect) + \" + \"\n    return ret_str[:-3]",
    "sympy.sympy.vector.vector._sympyrepr": "def _sympyrepr(self, printer):\n    index, system = self._id\n    return printer._print(system) + '.' + system._vector_names[index]"
}