{
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_independent": "def as_independent(\n    self,\n    *deps: Basic | type[Basic],\n    as_Add: bool | None = None,\n    strict: bool = True,\n) -> tuple[Expr, Expr]:\n    \"\"\"\n    A mostly naive separation of a Mul or Add into arguments that are not\n    are dependent on deps. To obtain as complete a separation of variables\n    as possible, use a separation method first, e.g.:\n\n    * ``separatevars()`` to change Mul, Add and Pow (including exp) into Mul\n    * ``.expand(mul=True)`` to change Add or Mul into Add\n    * ``.expand(log=True)`` to change log expr into an Add\n\n    The only non-naive thing that is done here is to respect noncommutative\n    ordering of variables and to always return ``(0, 0)`` for ``self`` of\n    zero regardless of hints.\n\n    For nonzero ``self``, the returned tuple ``(i, d)`` has the following\n    interpretation:\n\n    * ``i`` has no variable that appears in deps\n    * ``d`` will either have terms that contain variables that are in deps,\n      or be equal to ``0`` (when ``self`` is an ``Add``) or ``1`` (when\n      ``self`` is a ``Mul``)\n    * if ``self`` is an Add then ``self = i + d``\n    * if ``self`` is a Mul then ``self = i*d``\n    * otherwise ``(self, S.One)`` or ``(S.One, self)`` is returned.\n\n    To force the expression to be treated as an Add, use the argument\n    ``as_Add=True``.\n\n    The ``strict`` argument is deprecated and has no effect.\n\n    Examples\n    ========\n\n    -- ``self`` is an Add\n\n    >>> from sympy import sin, cos, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> (x + x*y).as_independent(x)\n    (0, x*y + x)\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x)\n    (y + z, 2*x*sin(x) + x)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n    (z, 2*x*sin(x) + x + y)\n\n    -- ``self`` is a Mul\n\n    >>> (x*sin(x)*cos(y)).as_independent(x)\n    (cos(y), x*sin(x))\n\n    Non-commutative terms cannot always be separated out when ``self`` is a\n    Mul\n\n    >>> from sympy import symbols\n    >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n    >>> (n1 + n1*n2).as_independent(n2)\n    (n1, n1*n2)\n    >>> (n2*n1 + n1*n2).as_independent(n2)\n    (0, n1*n2 + n2*n1)\n    >>> (n1*n2*n3).as_independent(n1)\n    (1, n1*n2*n3)\n    >>> (n1*n2*n3).as_independent(n2)\n    (n1, n2*n3)\n    >>> ((x-n1)*(x-y)).as_independent(x)\n    (1, (x - y)*(x - n1))\n\n    -- ``self`` is anything else:\n\n    >>> (sin(x)).as_independent(x)\n    (1, sin(x))\n    >>> (sin(x)).as_independent(y)\n    (sin(x), 1)\n    >>> exp(x+y).as_independent(x)\n    (1, exp(x + y))\n\n    -- force ``self`` to be treated as an Add:\n\n    >>> (3*x).as_independent(x, as_Add=True)\n    (0, 3*x)\n\n    -- force ``self`` to be treated as a Mul:\n\n    >>> (3+x).as_independent(x, as_Add=False)\n    (1, x + 3)\n    >>> (-3+x).as_independent(x, as_Add=False)\n    (1, x - 3)\n\n    Note how the below differs from the above in making the\n    constant on the dep term positive.\n\n    >>> (y*(-3+x)).as_independent(x)\n    (y, x - 3)\n\n    -- use ``.as_independent()`` for true independence testing instead of\n       ``.has()``. The former considers only symbols in the free symbols\n       while the latter considers all symbols\n\n    >>> from sympy import Integral\n    >>> I = Integral(x, (x, 1, 2))\n    >>> I.has(x)\n    True\n    >>> x in I.free_symbols\n    False\n    >>> I.as_independent(x) == (I, 1)\n    True\n    >>> (I + x).as_independent(x) == (I, x)\n    True\n\n    Note: when trying to get independent terms, a separation method might\n    need to be used first. In this case, it is important to keep track of\n    what you send to this routine so you know how to interpret the returned\n    values\n\n    >>> from sympy import separatevars, log\n    >>> separatevars(exp(x+y)).as_independent(x)\n    (exp(y), exp(x))\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> separatevars(x + x*y).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n    (x, x*y)\n    >>> a, b=symbols('a b', positive=True)\n    >>> (log(a*b).expand(log=True)).as_independent(b)\n    (log(a), log(b))\n\n    See Also\n    ========\n\n    separatevars\n    expand_log\n    sympy.core.add.Add.as_two_terms\n    sympy.core.mul.Mul.as_two_terms\n    as_coeff_mul\n    \"\"\"\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n\n    if self is S.Zero:\n        return (self, self)\n\n    if as_Add is None:\n        as_Add = self.is_Add\n\n    syms, other = _sift_true_false(deps, lambda d: isinstance(d, Symbol))\n    syms_set = set(syms)\n\n    if other:\n        def has(e):\n            return e.has_xfree(syms_set) or e.has(*other)\n    else:\n        def has(e):\n            return e.has_xfree(syms_set)\n\n    if as_Add:\n        if not self.is_Add:\n            if has(self):\n                return (S.Zero, self)\n            else:\n                return (self, S.Zero)\n\n        depend, indep = _sift_true_false(self.args, has)\n        return (self.func(*indep), _unevaluated_Add(*depend))\n\n    else:\n        if not self.is_Mul:\n            if has(self):\n                return (S.One, self)\n            else:\n                return (self, S.One)\n\n        args, nc = self.args_cnc()\n        depend, indep = _sift_true_false(args, has)\n\n        # handle noncommutative by stopping at first dependent term\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n\n        return self.func(*indep), _unevaluated_Mul(*depend)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.matrices.matrixbase.has": "def has(self, *patterns: SExpr | Basic | type[Basic]) -> bool:\n    \"\"\"Test whether any subexpression matches any of the patterns.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, SparseMatrix, Float\n    >>> from sympy.abc import x, y\n    >>> A = Matrix(((1, x), (0.2, 3)))\n    >>> B = SparseMatrix(((1, x), (0.2, 3)))\n    >>> A.has(x)\n    True\n    >>> A.has(y)\n    False\n    >>> A.has(Float)\n    True\n    >>> B.has(x)\n    True\n    >>> B.has(y)\n    False\n    >>> B.has(Float)\n    True\n    \"\"\"\n    return self._eval_has(*patterns)",
    "sympy.sympy.strategies.core.minrule": "def minrule(expr: _S) -> _T:\n    return min([rule(expr) for rule in rules], key=objective)",
    "sympy.sympy.strategies.tree.greedy": "def greedy(tree, objective=identity, **kwargs):\n    \"\"\" Execute a strategic tree.  Select alternatives greedily\n\n    Trees\n    -----\n\n    Nodes in a tree can be either\n\n    function - a leaf\n    list     - a selection among operations\n    tuple    - a sequence of chained operations\n\n    Textual examples\n    ----------------\n\n    Text: Run f, then run g, e.g. ``lambda x: g(f(x))``\n    Code: ``(f, g)``\n\n    Text: Run either f or g, whichever minimizes the objective\n    Code: ``[f, g]``\n\n    Textx: Run either f or g, whichever is better, then run h\n    Code: ``([f, g], h)``\n\n    Text: Either expand then simplify or try factor then foosimp. Finally print\n    Code: ``([(expand, simplify), (factor, foosimp)], print)``\n\n    Objective\n    ---------\n\n    \"Better\" is determined by the objective keyword.  This function makes\n    choices to minimize the objective.  It defaults to the identity.\n\n    Examples\n    ========\n\n    >>> from sympy.strategies.tree import greedy\n    >>> inc    = lambda x: x + 1\n    >>> dec    = lambda x: x - 1\n    >>> double = lambda x: 2*x\n\n    >>> tree = [inc, (dec, double)] # either inc or dec-then-double\n    >>> fn = greedy(tree)\n    >>> fn(4)  # lowest value comes from the inc\n    5\n    >>> fn(1)  # lowest value comes from dec then double\n    0\n\n    This function selects between options in a tuple.  The result is chosen\n    that minimizes the objective function.\n\n    >>> fn = greedy(tree, objective=lambda x: -x)  # maximize\n    >>> fn(4)  # highest value comes from the dec then double\n    6\n    >>> fn(1)  # highest value comes from the inc\n    2\n\n    Greediness\n    ----------\n\n    This is a greedy algorithm.  In the example:\n\n        ([a, b], c)  # do either a or b, then do c\n\n    the choice between running ``a`` or ``b`` is made without foresight to c\n    \"\"\"\n    optimize = partial(minimize, objective=objective)\n    return treeapply(tree, {list: optimize, tuple: chain}, **kwargs)"
}