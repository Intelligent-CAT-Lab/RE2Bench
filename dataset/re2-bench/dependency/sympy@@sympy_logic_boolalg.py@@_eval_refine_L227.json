{
    "sympy.sympy.assumptions.ask.ask": "def ask(proposition, assumptions=True, context=global_assumptions):\n    \"\"\"\n    Function to evaluate the proposition with assumptions.\n\n    Explanation\n    ===========\n\n    This function evaluates the proposition to ``True`` or ``False`` if\n    the truth value can be determined. If not, it returns ``None``.\n\n    It should be discerned from :func:`~.refine` which, when applied to a\n    proposition, simplifies the argument to symbolic ``Boolean`` instead of\n    Python built-in ``True``, ``False`` or ``None``.\n\n    **Syntax**\n\n        * ask(proposition)\n            Evaluate the *proposition* in global assumption context.\n\n        * ask(proposition, assumptions)\n            Evaluate the *proposition* with respect to *assumptions* in\n            global assumption context.\n\n    Parameters\n    ==========\n\n    proposition : Boolean\n        Proposition which will be evaluated to boolean value. If this is\n        not ``AppliedPredicate``, it will be wrapped by ``Q.is_true``.\n\n    assumptions : Boolean, optional\n        Local assumptions to evaluate the *proposition*.\n\n    context : AssumptionsContext, optional\n        Default assumptions to evaluate the *proposition*. By default,\n        this is ``sympy.assumptions.global_assumptions`` variable.\n\n    Returns\n    =======\n\n    ``True``, ``False``, or ``None``\n\n    Raises\n    ======\n\n    TypeError : *proposition* or *assumptions* is not valid logical expression.\n\n    ValueError : assumptions are inconsistent.\n\n    Examples\n    ========\n\n    >>> from sympy import ask, Q, pi\n    >>> from sympy.abc import x, y\n    >>> ask(Q.rational(pi))\n    False\n    >>> ask(Q.even(x*y), Q.even(x) & Q.integer(y))\n    True\n    >>> ask(Q.prime(4*x), Q.integer(x))\n    False\n\n    If the truth value cannot be determined, ``None`` will be returned.\n\n    >>> print(ask(Q.odd(3*x))) # cannot determine unless we know x\n    None\n\n    ``ValueError`` is raised if assumptions are inconsistent.\n\n    >>> ask(Q.integer(x), Q.even(x) & Q.odd(x))\n    Traceback (most recent call last):\n      ...\n    ValueError: inconsistent assumptions Q.even(x) & Q.odd(x)\n\n    Notes\n    =====\n\n    Relations in assumptions are not implemented (yet), so the following\n    will not give a meaningful result.\n\n    >>> ask(Q.positive(x), x > 0)\n\n    It is however a work in progress.\n\n    See Also\n    ========\n\n    sympy.assumptions.refine.refine : Simplification using assumptions.\n        Proposition is not reduced to ``None`` if the truth value cannot\n        be determined.\n    \"\"\"\n    from sympy.assumptions.satask import satask\n    from sympy.assumptions.lra_satask import lra_satask\n    from sympy.logic.algorithms.lra_theory import UnhandledInput\n\n    proposition = sympify(proposition)\n    assumptions = sympify(assumptions)\n\n    if isinstance(proposition, Predicate) or proposition.kind is not BooleanKind:\n        raise TypeError(\"proposition must be a valid logical expression\")\n\n    if isinstance(assumptions, Predicate) or assumptions.kind is not BooleanKind:\n        raise TypeError(\"assumptions must be a valid logical expression\")\n\n    # Normalize both proposition and assumptions\n    proposition = _normalize_expr(proposition)\n    assumptions = _normalize_expr(assumptions)\n\n    if isinstance(proposition, AppliedPredicate):\n        key, args = proposition.function, proposition.arguments\n    else:\n        key, args = Q.is_true, (proposition,)\n\n    # convert local and global assumptions to CNF\n    assump_cnf = CNF.from_prop(assumptions)\n    assump_cnf.extend(context)\n\n    # extract the relevant facts from assumptions with respect to args\n    local_facts = _extract_all_facts(assump_cnf, args)\n\n    # convert default facts and assumed facts to encoded CNF\n    known_facts_cnf = get_all_known_facts()\n    enc_cnf = EncodedCNF()\n    enc_cnf.from_cnf(CNF(known_facts_cnf))\n    enc_cnf.add_from_cnf(local_facts)\n\n    # check the satisfiability of given assumptions\n    if local_facts.clauses and satisfiable(enc_cnf) is False:\n        raise ValueError(f\"inconsistent assumptions {assumptions}\")\n\n    # quick computation for single fact\n    res = _ask_single_fact(key, local_facts)\n    if res is not None:\n        return res\n\n    # direct resolution method, no logic\n    res = key(*args)._eval_ask(assumptions)\n    if res is not None:\n        return bool(res)\n\n    # using satask (still costly)\n    res = satask(proposition, assumptions=assumptions, context=context)\n    if res is not None:\n        return res\n\n    try:\n        res = lra_satask(proposition, assumptions=assumptions, context=context)\n    except UnhandledInput:\n        return None\n\n    return res"
}