{
    "sympy.sympy.assumptions.ask.<lambda>": "lambda e: hasattr(e, 'function') and e.function == Q.ge,\n",
    "sympy.sympy.assumptions.ask._filter": "def _filter(e):\n    return isinstance(e, (Gt, Ge, Lt, Le, Eq, Ne))",
    "sympy.sympy.calculus.finite_diff.<lambda>": "lambda arg: isinstance(arg, Subs),\n",
    "sympy.sympy.codegen.approximations.query": "def query(self, expr):\n    return expr.is_Add",
    "sympy.sympy.codegen.rewriting.<lambda>": "lambda e: e.is_Pow and base_req(e.base) and e.exp.is_Integer and abs(e.exp) <= limit,\n",
    "sympy.sympy.codegen.rewriting._matinv_predicate": "def _matinv_predicate(expr):\n    # TODO: We should be able to support more than 2 elements\n    if expr.is_MatMul and len(expr.args) == 2:\n        left, right = expr.args\n        if left.is_Inverse and right.shape[1] == 1:\n            inv_arg = left.arg\n            if isinstance(inv_arg, MatrixSymbol):\n                return bool(ask(Q.fullrank(left.arg)))\n\n    return False",
    "sympy.sympy.concrete.summations.<lambda>": "lambda x: isinstance(x, Sum),\n",
    "sympy.sympy.core.add.<lambda>": "lambda x: x.is_Pow and x.base is oo,\n",
    "sympy.sympy.core.basic.<lambda>": "lambda x: hasattr(x, 'bound_symbols'),\n",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.containers.__ne__": "def __ne__(self, other):\n    if isinstance(other, Basic):\n        return super().__ne__(other)\n    return self.args != other",
    "sympy.sympy.core.function.<lambda>": "lambda x: x.is_Mul and all(any(isinstance(i, log) and i.args[0].is_Rational\n",
    "sympy.sympy.core.function.__ne__": "def __ne__(self, other):\n    return not(self == other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.functions.elementary.piecewise.<lambda>": "lambda x: isinstance(x, (Min, Max)),\n",
    "sympy.sympy.integrals.integrals.<lambda>": "lambda x: isinstance(x, Heaviside) and x.args[1]*2 != 1,\n",
    "sympy.sympy.integrals.manualintegrate.<lambda>": "expr = expr.replace(lambda x: x.is_Pow and x.base == x0,\n    lambda x: exp(x.exp*new))\n",
    "sympy.sympy.integrals.meijerint.<lambda>": "cond = cond.replace(lambda _: _.is_Relational, rel_touchup)\n",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.physics.units.dimensions.<lambda>": "lambda x: isinstance(x, Quantity),\n",
    "sympy.sympy.physics.units.quantities.<lambda>": "lambda x: isinstance(x, Prefix),\n",
    "sympy.sympy.physics.units.util.<lambda>": "expr = expr.replace(lambda x: isinstance(x, Quantity),\n    lambda x: x.convert_to(target_units, unit_system))\n\n",
    "sympy.sympy.series.gruntz.<lambda>": "f = f.replace(lambda f: f.is_Pow and f.has(x), lambda f: exp(log(f.base)*f.exp))\n\n",
    "sympy.sympy.simplify.fu.<lambda>": "lambda x:\n    isinstance(x, TrigonometricFunction) and\n    (r:=x.args[0]/pi).is_Rational and r.q in (1, 2, 3, 4, 6),\n",
    "sympy.sympy.simplify.radsimp.<lambda>": "lambda x: isinstance(x, Pow),\n",
    "sympy.sympy.simplify.simplify.<lambda>": "lambda x: isinstance(x, Expr) and x.args and not isinstance(\n    x, handled),\n",
    "sympy.sympy.solvers.bivariate.<lambda>": "lambda i:  # find symbol**even\n    i.is_Pow and i.base == symbol and i.exp.is_even,\n",
    "sympy.sympy.solvers.ode.systems.<lambda>": "expandable = lambda e: e.is_Mul and any(map(add_dep_terms, e.args))\n",
    "sympy.sympy.solvers.solvers.<lambda>": "f[i] = f[i].replace(lambda w: isinstance(w, HyperbolicFunction) and \\\n    w.has_free(*symbols), lambda w: w.rewrite(exp))\n\n# if we have a Matrix, we need to iterate over its elements again\n"
}