{
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.functions.elementary.piecewise.eval": "@classmethod\ndef eval(cls, *_args):\n    \"\"\"Either return a modified version of the args or, if no\n    modifications were made, return None.\n\n    Modifications that are made here:\n\n    1. relationals are made canonical\n    2. any False conditions are dropped\n    3. any repeat of a previous condition is ignored\n    4. any args past one with a true condition are dropped\n\n    If there are no args left, nan will be returned.\n    If there is a single arg with a True condition, its\n    corresponding expression will be returned.\n\n    EXAMPLES\n    ========\n\n    >>> from sympy import Piecewise\n    >>> from sympy.abc import x\n    >>> cond = -x < -1\n    >>> args = [(1, cond), (4, cond), (3, False), (2, True), (5, x < 1)]\n    >>> Piecewise(*args, evaluate=False)\n    Piecewise((1, -x < -1), (4, -x < -1), (2, True))\n    >>> Piecewise(*args)\n    Piecewise((1, x > 1), (2, True))\n    \"\"\"\n    if not _args:\n        return Undefined\n\n    if len(_args) == 1 and _args[0][-1] == True:\n        return _args[0][0]\n\n    newargs = _piecewise_collapse_arguments(_args)\n\n    # some conditions may have been redundant\n    missing = len(newargs) != len(_args)\n    # some conditions may have changed\n    same = all(a == b for a, b in zip(newargs, _args))\n    # if either change happened we return the expr with the\n    # updated args\n    if not newargs:\n        raise ValueError(filldedent('''\n            There are no conditions (or none that\n            are not trivially false) to define an\n            expression.'''))\n    if missing or not same:\n        return cls(*newargs)",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.functions.elementary.piecewise.expr": "@property\ndef expr(self):\n    \"\"\"\n    Returns the expression of this pair.\n    \"\"\"\n    return self.args[0]",
    "sympy.sympy.functions.elementary.piecewise.cond": "@property\ndef cond(self):\n    \"\"\"\n    Returns the condition of this pair.\n    \"\"\"\n    return self.args[1]",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return True\n    if other is False:\n        return False\n    return super().__eq__(other)"
}