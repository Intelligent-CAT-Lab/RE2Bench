{
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.matrices.immutable.shape": "@property\ndef shape(self):\n    return self._rows, self._cols",
    "sympy.sympy.matrices.matrixbase.shape": "@property\ndef shape(self) -> tuple[int, int]:\n    \"\"\"The shape (dimensions) of the matrix as the 2-tuple (rows, cols).\n\n    Examples\n    ========\n\n    >>> from sympy import zeros\n    >>> M = zeros(2, 3)\n    >>> M.shape\n    (2, 3)\n    >>> M.rows\n    2\n    >>> M.cols\n    3\n    \"\"\"\n    return (self.rows, self.cols)",
    "sympy.sympy.matrices.matrixbase.<listcomp>": "m = m._new(m.rows, m.cols, [_dotprodsimp(e) for e in m.flat()])\n\n",
    "sympy.sympy.matrices.matrixbase._unify_with_other": "def _unify_with_other(self: MatrixBase, other: Any\n            ) -> tuple[MatrixBase, MatrixBase | Expr, str]:\n    \"\"\"Unify self and other into a single matrix type, or check for scalar.\"\"\"\n    other, T = _coerce_operand(self, other)\n\n    if isinstance(other, MatrixBase):\n        typ = classof(self, other)\n        if typ != self.__class__:\n            self = _convert_matrix(typ, self)\n        if typ != other.__class__:\n            other = _convert_matrix(typ, other)\n\n    return self, other, T",
    "sympy.sympy.matrices.repmatrix.flat": "def flat(self):\n    return self._rep.to_sympy().to_list_flat()",
    "sympy.sympy.matrices.repmatrix._eval_matrix_mul": "def _eval_matrix_mul(self, other: RepMatrix): # type: ignore\n    return classof(self, other)._fromrep(self._rep * other._rep)",
    "sympy.sympy.matrices.repmatrix._eval_scalar_mul": "def _eval_scalar_mul(self, other):\n    rep, other = self._unify_element_sympy(self._rep, other)\n    return self._fromrep(rep.scalarmul(other))",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.sparse._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.utilities._get_intermediate_simp_bool": "def _get_intermediate_simp_bool(default=False, dotprodsimp=None):\n    \"\"\"Same as ``_get_intermediate_simp`` but returns bools instead of functions\n    by default.\"\"\"\n\n    return _get_intermediate_simp(default, False, True, dotprodsimp)"
}