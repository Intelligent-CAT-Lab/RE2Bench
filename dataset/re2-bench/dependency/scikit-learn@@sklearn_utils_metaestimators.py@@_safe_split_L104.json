{
    "scikit-learn.sklearn.utils._indexing._safe_indexing": "def _safe_indexing(X, indices, *, axis=0):\n    \"\"\"Return rows, items or columns of X using indices.\n\n    .. warning::\n\n        This utility is documented, but **private**. This means that\n        backward compatibility might be broken without any deprecation\n        cycle.\n\n    Parameters\n    ----------\n    X : array-like, sparse-matrix, list, pandas.DataFrame, pandas.Series\n        Data from which to sample rows, items or columns. `list` are only\n        supported when `axis=0`.\n    indices : bool, int, str, slice, array-like\n        - If `axis=0`, boolean and integer array-like, integer slice,\n          and scalar integer are supported.\n        - If `axis=1`:\n            - to select a single column, `indices` can be of `int` type for\n              all `X` types and `str` only for dataframe. The selected subset\n              will be 1D, unless `X` is a sparse matrix in which case it will\n              be 2D.\n            - to select multiples columns, `indices` can be one of the\n              following: `list`, `array`, `slice`. The type used in\n              these containers can be one of the following: `int`, 'bool' and\n              `str`. However, `str` is only supported when `X` is a dataframe.\n              The selected subset will be 2D.\n    axis : int, default=0\n        The axis along which `X` will be subsampled. `axis=0` will select\n        rows while `axis=1` will select columns.\n\n    Returns\n    -------\n    subset\n        Subset of X on axis 0 or 1.\n\n    Notes\n    -----\n    CSR, CSC, and LIL sparse matrices are supported. COO sparse matrices are\n    not supported.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.utils import _safe_indexing\n    >>> data = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> _safe_indexing(data, 0, axis=0)  # select the first row\n    array([1, 2])\n    >>> _safe_indexing(data, 0, axis=1)  # select the first column\n    array([1, 3, 5])\n    \"\"\"\n    if indices is None:\n        return X\n\n    if axis not in (0, 1):\n        raise ValueError(\n            \"'axis' should be either 0 (to index rows) or 1 (to index \"\n            \" column). Got {} instead.\".format(axis)\n        )\n\n    indices_dtype = _determine_key_type(indices)\n\n    if axis == 0 and indices_dtype == \"str\":\n        raise ValueError(\n            f\"String indexing (indices={indices}) is not supported with 'axis=0'. \"\n            \"Did you mean to use axis=1 for column selection?\"\n        )\n\n    if axis == 1 and isinstance(X, list):\n        raise ValueError(\"axis=1 is not supported for lists\")\n\n    if axis == 1 and (ndim := len(getattr(X, \"shape\", [0]))) != 2:\n        raise ValueError(\n            \"'X' should be a 2D NumPy array, 2D sparse matrix or \"\n            \"dataframe when indexing the columns (i.e. 'axis=1'). \"\n            f\"Got {type(X)} instead with {ndim} dimension(s).\"\n        )\n\n    if (\n        axis == 1\n        and indices_dtype == \"str\"\n        and not (_is_pandas_df(X) or _use_interchange_protocol(X))\n    ):\n        raise ValueError(\n            \"Specifying the columns using strings is only supported for dataframes.\"\n        )\n\n    if hasattr(X, \"iloc\"):\n        # TODO: we should probably use _is_pandas_df_or_series(X) instead but:\n        # 1) Currently, it (probably) works for dataframes compliant to pandas' API.\n        # 2) Updating would require updating some tests such as\n        #    test_train_test_split_mock_pandas.\n        return _pandas_indexing(X, indices, indices_dtype, axis=axis)\n    elif _is_polars_df_or_series(X):\n        return _polars_indexing(X, indices, indices_dtype, axis=axis)\n    elif _is_pyarrow_data(X):\n        return _pyarrow_indexing(X, indices, indices_dtype, axis=axis)\n    elif _use_interchange_protocol(X):  # pragma: no cover\n        # Once the dataframe X is converted into its dataframe interchange protocol\n        # version by calling X.__dataframe__(), it becomes very hard to turn it back\n        # into its original type, e.g., a pyarrow.Table, see\n        # https://github.com/data-apis/dataframe-api/issues/85.\n        raise warnings.warn(\n            message=\"A data object with support for the dataframe interchange protocol\"\n            \"was passed, but scikit-learn does currently not know how to handle this \"\n            \"kind of data. Some array/list indexing will be tried.\",\n            category=UserWarning,\n        )\n\n    if hasattr(X, \"shape\"):\n        return _array_indexing(X, indices, indices_dtype, axis=axis)\n    else:\n        return _list_indexing(X, indices, indices_dtype)",
    "scikit-learn.sklearn.utils._tags.get_tags": "def get_tags(estimator) -> Tags:\n    \"\"\"Get estimator tags.\n\n    :class:`~sklearn.BaseEstimator` provides the estimator tags machinery.\n\n    For scikit-learn built-in estimators, we should still rely on\n    `self.__sklearn_tags__()`. `get_tags(est)` should be used when we\n    are not sure where `est` comes from: typically\n    `get_tags(self.estimator)` where `self` is a meta-estimator, or in\n    the common checks.\n\n    .. versionadded:: 1.6\n\n    Parameters\n    ----------\n    estimator : estimator object\n        The estimator from which to get the tag.\n\n    Returns\n    -------\n    tags : :class:`~.sklearn.utils.Tags`\n        The estimator tags.\n    \"\"\"\n\n    try:\n        tags = estimator.__sklearn_tags__()\n    except AttributeError as exc:\n        if \"object has no attribute '__sklearn_tags__'\" in str(exc):\n            # Happens when `__sklearn_tags__` is implemented by calling\n            # `super().__sklearn_tags__()` but there is no `__sklearn_tags__`\n            # method in the base class. Typically happens when only inheriting\n            # from Mixins.\n\n            raise AttributeError(\n                f\"The following error was raised: {exc}. It seems that \"\n                \"there are no classes that implement `__sklearn_tags__` \"\n                \"in the MRO and/or all classes in the MRO call \"\n                \"`super().__sklearn_tags__()`. Make sure to inherit from \"\n                \"`BaseEstimator` which implements `__sklearn_tags__` (or \"\n                \"alternatively define `__sklearn_tags__` but we don't recommend \"\n                \"this approach). Note that `BaseEstimator` needs to be on the \"\n                \"right side of other Mixins in the inheritance order.\"\n            )\n        else:\n            raise\n\n    return tags"
}