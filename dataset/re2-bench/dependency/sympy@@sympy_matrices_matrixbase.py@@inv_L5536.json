{
    "sympy.sympy.matrices.inverse._inv": "def _inv(M: Tmat,\n         method: str | None = None,\n         iszerofunc: Callable[[Expr], bool | None] = _iszero,\n         try_block_diag: bool = False\n    ) -> Tmat:\n    \"\"\"\n    Return the inverse of a matrix using the method indicated. The default\n    is DM if a suitable domain is found or otherwise GE for dense matrices\n    LDL for sparse matrices.\n\n    Parameters\n    ==========\n\n    method : ('DM', 'DMNC', 'GE', 'LU', 'ADJ', 'CH', 'LDL', 'QR')\n\n    iszerofunc : function, optional\n        Zero-testing function to use.\n\n    try_block_diag : bool, optional\n        If True then will try to form block diagonal matrices using the\n        method get_diag_blocks(), invert these individually, and then\n        reconstruct the full inverse matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import SparseMatrix, Matrix\n    >>> A = SparseMatrix([\n    ... [ 2, -1,  0],\n    ... [-1,  2, -1],\n    ... [ 0,  0,  2]])\n    >>> A.inv('CH')\n    Matrix([\n    [2/3, 1/3, 1/6],\n    [1/3, 2/3, 1/3],\n    [  0,   0, 1/2]])\n    >>> A.inv(method='LDL') # use of 'method=' is optional\n    Matrix([\n    [2/3, 1/3, 1/6],\n    [1/3, 2/3, 1/3],\n    [  0,   0, 1/2]])\n    >>> A * _\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> A = Matrix(A)\n    >>> A.inv('CH')\n    Matrix([\n    [2/3, 1/3, 1/6],\n    [1/3, 2/3, 1/3],\n    [  0,   0, 1/2]])\n    >>> A.inv('ADJ') == A.inv('GE') == A.inv('LU') == A.inv('CH') == A.inv('LDL') == A.inv('QR')\n    True\n\n    Notes\n    =====\n\n    According to the ``method`` keyword, it calls the appropriate method:\n\n        DM .... Use DomainMatrix ``inv_den`` method\n        DMNC .... Use DomainMatrix ``inv_den`` method without cancellation\n        GE .... inverse_GE(); default for dense matrices\n        LU .... inverse_LU()\n        ADJ ... inverse_ADJ()\n        CH ... inverse_CH()\n        LDL ... inverse_LDL(); default for sparse matrices\n        QR ... inverse_QR()\n\n    Note, the GE and LU methods may require the matrix to be simplified\n    before it is inverted in order to properly detect zeros during\n    pivoting. In difficult cases a custom zero detection function can\n    be provided by setting the ``iszerofunc`` argument to a function that\n    should return True if its argument is zero. The ADJ routine computes\n    the determinant and uses that to detect singular matrices in addition\n    to testing for zeros on the diagonal.\n\n    See Also\n    ========\n\n    inverse_ADJ\n    inverse_GE\n    inverse_LU\n    inverse_CH\n    inverse_LDL\n\n    Raises\n    ======\n\n    ValueError\n        If the determinant of the matrix is zero.\n    \"\"\"\n\n    from sympy.matrices import SparseMatrix\n\n    if not M.is_square:\n        raise NonSquareMatrixError(\"A Matrix must be square to invert.\")\n\n    if try_block_diag:\n        blocks = M.get_diag_blocks()\n        r      = []\n\n        for block in blocks:\n            r.append(block.inv(method=method, iszerofunc=iszerofunc))\n\n        return M.diag(*r)\n\n    # Default: Use DomainMatrix if the domain is not EX.\n    # If DM is requested explicitly then use it even if the domain is EX.\n    if method is None and iszerofunc is _iszero:\n        dM = _try_DM(M, use_EX=False)\n    elif method in (\"DM\", \"DMNC\"):\n        dM = _try_DM(M, use_EX=True)\n    else:\n        dM = None\n\n    # A suitable domain was not found, fall back to GE for dense matrices\n    # and LDL for sparse matrices.\n    if method is None:\n        if isinstance(M, SparseMatrix):\n            method = 'LDL'\n        else:\n            method = 'GE'\n\n    if dM is not None:\n        rv = _inv_DM(dM)\n    elif method == \"DMNC\":\n        rv = _inv_DM(dM, cancel=False)\n    elif method == \"GE\":\n        rv = M.inverse_GE(iszerofunc=iszerofunc)\n    elif method == \"LU\":\n        rv = M.inverse_LU(iszerofunc=iszerofunc)\n    elif method == \"ADJ\":\n        rv = M.inverse_ADJ(iszerofunc=iszerofunc)\n    elif method == \"CH\":\n        rv = M.inverse_CH(iszerofunc=iszerofunc)\n    elif method == \"LDL\":\n        rv = M.inverse_LDL(iszerofunc=iszerofunc)\n    elif method == \"QR\":\n        rv = M.inverse_QR(iszerofunc=iszerofunc)\n    elif method == \"BLOCK\":\n        rv = M.inverse_BLOCK(iszerofunc=iszerofunc)\n    else:\n        raise ValueError(\"Inversion method unrecognized\")\n\n    return M._new(rv)"
}