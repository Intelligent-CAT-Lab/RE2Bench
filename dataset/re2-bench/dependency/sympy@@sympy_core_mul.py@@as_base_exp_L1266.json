{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.as_base_exp": "def as_base_exp(self) -> tuple[Expr, Expr]:\n    # a -> b ** e\n    return self, S.One",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.as_base_exp": "def as_base_exp(self):\n    return S.NegativeOne, S.Half",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e",
    "sympy.sympy.functions.elementary.exponential.as_base_exp": "def as_base_exp(self):\n    \"\"\"\n    Returns the 2-tuple (base, exponent).\n    \"\"\"\n    return self.func(1), Mul(*self.args)",
    "sympy.sympy.stats.rv.is_commutative": "@property\ndef is_commutative(self):\n    return self.symbol.is_commutative"
}