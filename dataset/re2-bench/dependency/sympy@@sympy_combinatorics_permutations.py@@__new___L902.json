{
    "sympy.sympy.combinatorics.permutations._af_new": "@classmethod\ndef _af_new(cls, perm):\n    \"\"\"A method to produce a Permutation object from a list;\n    the list is bound to the _array_form attribute, so it must\n    not be modified; this method is meant for internal use only;\n    the list ``a`` is supposed to be generated as a temporary value\n    in a method, so p = Perm._af_new(a) is the only object\n    to hold a reference to ``a``::\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.permutations import Perm\n    >>> from sympy import init_printing\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n    >>> a = [2, 1, 3, 0]\n    >>> p = Perm._af_new(a)\n    >>> p\n    Permutation([2, 1, 3, 0])\n\n    \"\"\"\n    p = super().__new__(cls)\n    p._array_form = perm\n    p._size = len(perm)\n    return p",
    "sympy.sympy.combinatorics.permutations.array_form": "@property\ndef array_form(self):\n    \"\"\"\n    Return a copy of the attribute _array_form\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Permutation\n    >>> p = Permutation([[2, 0], [3, 1]])\n    >>> p.array_form\n    [2, 3, 0, 1]\n    >>> Permutation([[2, 0, 3, 1]]).array_form\n    [3, 2, 0, 1]\n    >>> Permutation([2, 0, 3, 1]).array_form\n    [2, 0, 3, 1]\n    >>> Permutation([[1, 2], [4, 5]]).array_form\n    [0, 2, 1, 3, 5, 4]\n    \"\"\"\n    return self._array_form[:]",
    "sympy.sympy.combinatorics.permutations.size": "@property\ndef size(self):\n    \"\"\"\n    Returns the number of elements in the permutation.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Permutation\n    >>> Permutation([[3, 2], [0, 1]]).size\n    4\n\n    See Also\n    ========\n\n    cardinality, length, order, rank\n    \"\"\"\n    return self._size",
    "sympy.sympy.combinatorics.permutations.__call__": "def __call__(self, *other):\n    \"\"\"Return product of cycles processed from R to L.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Cycle\n    >>> Cycle(1, 2)(2, 3)\n    (1 3 2)\n\n    An instance of a Cycle will automatically parse list-like\n    objects and Permutations that are on the right. It is more\n    flexible than the Permutation in that all elements need not\n    be present:\n\n    >>> a = Cycle(1, 2)\n    >>> a(2, 3)\n    (1 3 2)\n    >>> a(2, 3)(4, 5)\n    (1 3 2)(4 5)\n\n    \"\"\"\n    rv = Cycle(*other)\n    for k, v in zip(list(self.keys()), [rv[self[k]] for k in self.keys()]):\n        rv[k] = v\n    return rv",
    "sympy.sympy.combinatorics.permutations.list": "def list(self, size=None):\n    \"\"\"Return the cycles as an explicit list starting from 0 up\n    to the greater of the largest value in the cycles and size.\n\n    Truncation of trailing unmoved items will occur when size\n    is less than the maximum element in the cycle; if this is\n    desired, setting ``size=-1`` will guarantee such trimming.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Cycle\n    >>> p = Cycle(2, 3)(4, 5)\n    >>> p.list()\n    [0, 1, 3, 2, 5, 4]\n    >>> p.list(10)\n    [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]\n\n    Passing a length too small will trim trailing, unchanged elements\n    in the permutation:\n\n    >>> Cycle(2, 4)(1, 2, 4).list(-1)\n    [0, 2, 1]\n    \"\"\"\n    if not self and size is None:\n        raise ValueError('must give size for empty Cycle')\n    if size is not None:\n        big = max([i for i in self.keys() if self[i] != i] + [-1])\n        size = max(size, big + 1)\n    else:\n        size = self.size\n    return [self[i] for i in range(size)]",
    "sympy.sympy.combinatorics.permutations.__init__": "def __init__(self, *args):\n    \"\"\"Load up a Cycle instance with the values for the cycle.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Cycle\n    >>> Cycle(1, 2, 6)\n    (1 2 6)\n    \"\"\"\n\n    if not args:\n        return\n    if len(args) == 1:\n        if isinstance(args[0], Permutation):\n            for c in args[0].cyclic_form:\n                self.update(self(*c))\n            return\n        elif isinstance(args[0], Cycle):\n            for k, v in args[0].items():\n                self[k] = v\n            return\n    args = [as_int(a) for a in args]\n    if any(i < 0 for i in args):\n        raise ValueError('negative integers are not allowed in a cycle.')\n    if has_dups(args):\n        raise ValueError('All elements must be unique in a cycle.')\n    for i in range(-len(args), 0):\n        self[args[i]] = args[i + 1]",
    "sympy.sympy.combinatorics.permutations.__new__": "def __new__(cls, *args, size=None, **kwargs):\n    \"\"\"\n    Constructor for the Permutation object from a list or a\n    list of lists in which all elements of the permutation may\n    appear only once.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Permutation\n    >>> from sympy import init_printing\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n\n    Permutations entered in array-form are left unaltered:\n\n    >>> Permutation([0, 2, 1])\n    Permutation([0, 2, 1])\n\n    Permutations entered in cyclic form are converted to array form;\n    singletons need not be entered, but can be entered to indicate the\n    largest element:\n\n    >>> Permutation([[4, 5, 6], [0, 1]])\n    Permutation([1, 0, 2, 3, 5, 6, 4])\n    >>> Permutation([[4, 5, 6], [0, 1], [19]])\n    Permutation([1, 0, 2, 3, 5, 6, 4], size=20)\n\n    All manipulation of permutations assumes that the smallest element\n    is 0 (in keeping with 0-based indexing in Python) so if the 0 is\n    missing when entering a permutation in array form, an error will be\n    raised:\n\n    >>> Permutation([2, 1])\n    Traceback (most recent call last):\n    ...\n    ValueError: Integers 0 through 2 must be present.\n\n    If a permutation is entered in cyclic form, it can be entered without\n    singletons and the ``size`` specified so those values can be filled\n    in, otherwise the array form will only extend to the maximum value\n    in the cycles:\n\n    >>> Permutation([[1, 4], [3, 5, 2]], size=10)\n    Permutation([0, 4, 3, 5, 1, 2], size=10)\n    >>> _.array_form\n    [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]\n    \"\"\"\n    if size is not None:\n        size = int(size)\n\n    #a) ()\n    #b) (1) = identity\n    #c) (1, 2) = cycle\n    #d) ([1, 2, 3]) = array form\n    #e) ([[1, 2]]) = cyclic form\n    #f) (Cycle) = conversion to permutation\n    #g) (Permutation) = adjust size or return copy\n    ok = True\n    if not args:  # a\n        return cls._af_new(list(range(size or 0)))\n    elif len(args) > 1:  # c\n        return cls._af_new(Cycle(*args).list(size))\n    if len(args) == 1:\n        a = args[0]\n        if isinstance(a, cls):  # g\n            if size is None or size == a.size:\n                return a\n            return cls(a.array_form, size=size)\n        if isinstance(a, Cycle):  # f\n            return cls._af_new(a.list(size))\n        if not is_sequence(a):  # b\n            if size is not None and a + 1 > size:\n                raise ValueError('size is too small when max is %s' % a)\n            return cls._af_new(list(range(a + 1)))\n        if has_variety(is_sequence(ai) for ai in a):\n            ok = False\n    else:\n        ok = False\n    if not ok:\n        raise ValueError(\"Permutation argument must be a list of ints, \"\n                         \"a list of lists, Permutation or Cycle.\")\n\n    # safe to assume args are valid; this also makes a copy\n    # of the args\n    args = list(args[0])\n\n    is_cycle = args and is_sequence(args[0])\n    if is_cycle:  # e\n        args = [[int(i) for i in c] for c in args]\n    else:  # d\n        args = [int(i) for i in args]\n\n    # if there are n elements present, 0, 1, ..., n-1 should be present\n    # unless a cycle notation has been provided. A 0 will be added\n    # for convenience in case one wants to enter permutations where\n    # counting starts from 1.\n\n    temp = flatten(args)\n    if has_dups(temp) and not is_cycle:\n        raise ValueError('there were repeated elements.')\n    temp = set(temp)\n\n    if not is_cycle:\n        if temp != set(range(len(temp))):\n            raise ValueError('Integers 0 through %s must be present.' %\n            max(temp))\n        if size is not None and temp and max(temp) + 1 > size:\n            raise ValueError('max element should not exceed %s' % (size - 1))\n\n    if is_cycle:\n        # it's not necessarily canonical so we won't store\n        # it -- use the array form instead\n        c = Cycle()\n        for ci in args:\n            c = c(*ci)\n        aform = c.list()\n    else:\n        aform = list(args)\n    if size and size > len(aform):\n        # don't allow for truncation of permutation which\n        # might split a cycle and lead to an invalid aform\n        # but do allow the permutation size to be increased\n        aform.extend(list(range(len(aform), size)))\n\n    return cls._af_new(aform)",
    "sympy.sympy.combinatorics.permutations.<genexpr>": "if has_variety(is_sequence(ai) for ai in a):\n    ok = False\n",
    "sympy.sympy.combinatorics.permutations.<listcomp>": "    args = [int(i) for i in args]\n\n# if there are n elements present, 0, 1, ..., n-1 should be present\n# unless a cycle notation has been provided. A 0 will be added\n# for convenience in case one wants to enter permutations where\n# counting starts from 1.\n\n",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__index__": "def __index__(self):\n    return self.p",
    "sympy.sympy.utilities.iterables.has_dups": "def has_dups(seq):\n    \"\"\"Return True if there are any duplicate elements in ``seq``.\n\n    Examples\n    ========\n\n    >>> from sympy import has_dups, Dict, Set\n    >>> has_dups((1, 2, 1))\n    True\n    >>> has_dups(range(3))\n    False\n    >>> all(has_dups(c) is False for c in (set(), Set(), dict(), Dict()))\n    True\n    \"\"\"\n    from sympy.core.containers import Dict\n    from sympy.sets.sets import Set\n    if isinstance(seq, (dict, set, Dict, Set)):\n        return False\n    unique = set()\n    try:\n        return any(True for s in seq if s in unique or unique.add(s))\n    except TypeError:\n        return len(seq) != len(list(uniq(seq)))",
    "sympy.sympy.utilities.iterables.has_variety": "def has_variety(seq):\n    \"\"\"Return True if there are any different elements in ``seq``.\n\n    Examples\n    ========\n\n    >>> from sympy import has_variety\n\n    >>> has_variety((1, 2, 1))\n    True\n    >>> has_variety((1, 1, 1))\n    False\n    \"\"\"\n    for i, s in enumerate(seq):\n        if i == 0:\n            sentinel = s\n        else:\n            if s != sentinel:\n                return True\n    return False",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))",
    "sympy.sympy.utilities.iterables.flatten": "def flatten(iterable, levels=None, cls=None):  # noqa: F811\n    \"\"\"\n    Recursively denest iterable containers.\n\n    >>> from sympy import flatten\n\n    >>> flatten([1, 2, 3])\n    [1, 2, 3]\n    >>> flatten([1, 2, [3]])\n    [1, 2, 3]\n    >>> flatten([1, [2, 3], [4, 5]])\n    [1, 2, 3, 4, 5]\n    >>> flatten([1.0, 2, (1, None)])\n    [1.0, 2, 1, None]\n\n    If you want to denest only a specified number of levels of\n    nested containers, then set ``levels`` flag to the desired\n    number of levels::\n\n    >>> ls = [[(-2, -1), (1, 2)], [(0, 0)]]\n\n    >>> flatten(ls, levels=1)\n    [(-2, -1), (1, 2), (0, 0)]\n\n    If cls argument is specified, it will only flatten instances of that\n    class, for example:\n\n    >>> from sympy import Basic, S\n    >>> class MyOp(Basic):\n    ...     pass\n    ...\n    >>> flatten([MyOp(S(1), MyOp(S(2), S(3)))], cls=MyOp)\n    [1, 2, 3]\n\n    adapted from https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks\n    \"\"\"\n    from sympy.tensor.array import NDimArray\n    if levels is not None:\n        if not levels:\n            return iterable\n        elif levels > 0:\n            levels -= 1\n        else:\n            raise ValueError(\n                \"expected non-negative number of levels, got %s\" % levels)\n\n    if cls is None:\n        def reducible(x):\n            return is_sequence(x, set)\n    else:\n        def reducible(x):\n            return isinstance(x, cls)\n\n    result = []\n\n    for el in iterable:\n        if reducible(el):\n            if hasattr(el, 'args') and not isinstance(el, NDimArray):\n                el = el.args\n            result.extend(flatten(el, levels=levels, cls=cls))\n        else:\n            result.append(el)\n\n    return result"
}