{
    "sympy.sympy.assumptions.handlers.common.<genexpr>": "(ask(query, assumptions) for query in queries))\n",
    "sympy.sympy.assumptions.handlers.order.<genexpr>": "    return fuzzy_or(ask(Q.zero(arg), assumptions) for arg in expr.args)\n\n\n# NonPositivePredicate\n\n",
    "sympy.sympy.core.expr.<genexpr>": "return fuzzy_not(fuzzy_or(den.is_zero for den in denoms(self)))\n\n",
    "sympy.sympy.core.function.<genexpr>": "return fuzzy_or(a.is_infinite if s is S.ComplexInfinity\n                else (a - s).is_zero for s in ss)\n\n",
    "sympy.sympy.core.logic.fuzzy_bool": "def fuzzy_bool(x):\n    \"\"\"Return True, False or None according to x.\n\n    Whereas bool(x) returns True or False, fuzzy_bool allows\n    for the None value and non-false values (which become None), too.\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import fuzzy_bool\n    >>> from sympy.abc import x\n    >>> fuzzy_bool(x), fuzzy_bool(None)\n    (None, None)\n    >>> bool(x), bool(None)\n    (True, False)\n\n    \"\"\"\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    "sympy.sympy.functions.elementary.exponential.complex_extended_negative": "def complex_extended_negative(arg):\n    yield arg.is_complex\n    yield arg.is_extended_negative",
    "sympy.sympy.functions.elementary.miscellaneous.<genexpr>": "return fuzzy_or(a.is_negative for a in self.args)\n\n\n",
    "sympy.sympy.sets.fancysets.<genexpr>": "is_empty = fuzzy_or(s.is_empty for s in sets)\n",
    "sympy.sympy.sets.handlers.issubset.<genexpr>": "if fuzzy_or(a_interval.is_subset(s) for s in b_u.args):\n    return True\n",
    "sympy.sympy.sets.sets.<genexpr>": "if fuzzy_or(arg.is_finite_set for arg in self.args):\n    return True\n\n"
}