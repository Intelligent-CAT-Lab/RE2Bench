{
    "scikit-learn.sklearn.utils.graph._fix_connected_components": "def _fix_connected_components(\n    X,\n    graph,\n    n_connected_components,\n    component_labels,\n    mode=\"distance\",\n    metric=\"euclidean\",\n    **kwargs,\n):\n    \"\"\"Add connections to sparse graph to connect unconnected components.\n\n    For each pair of unconnected components, compute all pairwise distances\n    from one component to the other, and add a connection on the closest pair\n    of samples. This is a hacky way to get a graph with a single connected\n    component, which is necessary for example to compute a shortest path\n    between all pairs of samples in the graph.\n\n    Parameters\n    ----------\n    X : array of shape (n_samples, n_features) or (n_samples, n_samples)\n        Features to compute the pairwise distances. If `metric =\n        \"precomputed\"`, X is the matrix of pairwise distances.\n\n    graph : sparse matrix of shape (n_samples, n_samples)\n        Graph of connection between samples.\n\n    n_connected_components : int\n        Number of connected components, as computed by\n        `scipy.sparse.csgraph.connected_components`.\n\n    component_labels : array of shape (n_samples)\n        Labels of connected components, as computed by\n        `scipy.sparse.csgraph.connected_components`.\n\n    mode : {'connectivity', 'distance'}, default='distance'\n        Type of graph matrix: 'connectivity' corresponds to the connectivity\n        matrix with ones and zeros, and 'distance' corresponds to the distances\n        between neighbors according to the given metric.\n\n    metric : str\n        Metric used in `sklearn.metrics.pairwise.pairwise_distances`.\n\n    kwargs : kwargs\n        Keyword arguments passed to\n        `sklearn.metrics.pairwise.pairwise_distances`.\n\n    Returns\n    -------\n    graph : sparse matrix of shape (n_samples, n_samples)\n        Graph of connection between samples, with a single connected component.\n    \"\"\"\n    if metric == \"precomputed\" and sparse.issparse(X):\n        raise RuntimeError(\n            \"_fix_connected_components with metric='precomputed' requires the \"\n            \"full distance matrix in X, and does not work with a sparse \"\n            \"neighbors graph.\"\n        )\n\n    for i in range(n_connected_components):\n        idx_i = np.flatnonzero(component_labels == i)\n        Xi = X[idx_i]\n        for j in range(i):\n            idx_j = np.flatnonzero(component_labels == j)\n            Xj = X[idx_j]\n\n            if metric == \"precomputed\":\n                D = X[np.ix_(idx_i, idx_j)]\n            else:\n                D = pairwise_distances(Xi, Xj, metric=metric, **kwargs)\n\n            ii, jj = np.unravel_index(D.argmin(axis=None), D.shape)\n            if mode == \"connectivity\":\n                graph[idx_i[ii], idx_j[jj]] = 1\n                graph[idx_j[jj], idx_i[ii]] = 1\n            elif mode == \"distance\":\n                graph[idx_i[ii], idx_j[jj]] = D[ii, jj]\n                graph[idx_j[jj], idx_i[ii]] = D[ii, jj]\n            else:\n                raise ValueError(\n                    \"Unknown mode=%r, should be one of ['connectivity', 'distance'].\"\n                    % mode\n                )\n\n    return graph"
}