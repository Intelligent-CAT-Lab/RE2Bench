{
    "matplotlib.lib.matplotlib._api.__init__.check_in_list": "def check_in_list(values, /, *, _print_supported_values=True, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is in *values*;\n    if not, raise an appropriate ValueError.\n\n    Parameters\n    ----------\n    values : iterable\n        Sequence of values to check on.\n\n        Note: All values must support == comparisons.\n        This means in particular the entries must not be numpy arrays.\n    _print_supported_values : bool, default: True\n        Whether to print *values* when raising ValueError.\n    **kwargs : dict\n        *key, value* pairs as keyword arguments to find in *values*.\n\n    Raises\n    ------\n    ValueError\n        If any *value* in *kwargs* is not found in *values*.\n\n    Examples\n    --------\n    >>> _api.check_in_list([\"foo\", \"bar\"], arg=arg, other_arg=other_arg)\n    \"\"\"\n    if not kwargs:\n        raise TypeError(\"No argument to check!\")\n    for key, val in kwargs.items():\n        try:\n            exists = val in values\n        except ValueError:\n            # `in` internally uses `val == values[i]`. There are some objects\n            # that do not support == to arbitrary other objects, in particular\n            # numpy arrays.\n            # Since such objects are not allowed in values, we can gracefully\n            # handle the case that val (typically provided by users) is of such\n            # type and directly state it's not in the list instead of letting\n            # the individual `val == values[i]` ValueError surface.\n            exists = False\n        if not exists:\n            msg = f\"{val!r} is not a valid value for {key}\"\n            if _print_supported_values:\n                msg += f\"; supported values are {', '.join(map(repr, values))}\"\n            raise ValueError(msg)",
    "matplotlib.lib.matplotlib.mlab._stride_windows": "def _stride_windows(x, n, noverlap=0):\n    _api.check_isinstance(Integral, n=n, noverlap=noverlap)\n    x = np.asarray(x)\n    step = n - noverlap\n    shape = (n, (x.shape[-1]-noverlap)//step)\n    strides = (x.strides[0], step*x.strides[0])\n    return np.lib.stride_tricks.as_strided(x, shape=shape, strides=strides)",
    "matplotlib.lib.matplotlib.mlab.window_hanning": "def window_hanning(x):\n    \"\"\"\n    Return *x* times the Hanning (or Hann) window of len(*x*).\n\n    See Also\n    --------\n    window_none : Another window algorithm.\n    \"\"\"\n    return np.hanning(len(x))*x",
    "matplotlib.lib.matplotlib.mlab.window_none": "def window_none(x):\n    \"\"\"\n    No window function; simply return *x*.\n\n    See Also\n    --------\n    window_hanning : Another window algorithm.\n    \"\"\"\n    return x",
    "matplotlib.lib.matplotlib.mlab.detrend": "def detrend(x, key=None, axis=None):\n    \"\"\"\n    Return *x* with its trend removed.\n\n    Parameters\n    ----------\n    x : array or sequence\n        Array or sequence containing the data.\n\n    key : {'default', 'constant', 'mean', 'linear', 'none'} or function\n        The detrending algorithm to use. 'default', 'mean', and 'constant' are\n        the same as `detrend_mean`. 'linear' is the same as `detrend_linear`.\n        'none' is the same as `detrend_none`. The default is 'mean'. See the\n        corresponding functions for more details regarding the algorithms. Can\n        also be a function that carries out the detrend operation.\n\n    axis : int\n        The axis along which to do the detrending.\n\n    See Also\n    --------\n    detrend_mean : Implementation of the 'mean' algorithm.\n    detrend_linear : Implementation of the 'linear' algorithm.\n    detrend_none : Implementation of the 'none' algorithm.\n    \"\"\"\n    if key is None or key in ['constant', 'mean', 'default']:\n        return detrend(x, key=detrend_mean, axis=axis)\n    elif key == 'linear':\n        return detrend(x, key=detrend_linear, axis=axis)\n    elif key == 'none':\n        return detrend(x, key=detrend_none, axis=axis)\n    elif callable(key):\n        x = np.asarray(x)\n        if axis is not None and axis + 1 > x.ndim:\n            raise ValueError(f'axis(={axis}) out of bounds')\n        if (axis is None and x.ndim == 0) or (not axis and x.ndim == 1):\n            return key(x)\n        # try to use the 'axis' argument if the function supports it,\n        # otherwise use apply_along_axis to do it\n        try:\n            return key(x, axis=axis)\n        except TypeError:\n            return np.apply_along_axis(key, axis=axis, arr=x)\n    else:\n        raise ValueError(\n            f\"Unknown value for key: {key!r}, must be one of: 'default', \"\n            f\"'constant', 'mean', 'linear', or a function\")"
}