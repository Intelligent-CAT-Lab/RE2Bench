{
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.numbers._Frel": "def _Frel(self, other, op):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Rational:\n        # test self*other.q <?> other.p without losing precision\n        '''\n        >>> f = Float(.1,2)\n        >>> i = 1234567890\n        >>> (f*i)._mpf_\n        (0, 471, 18, 9)\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\n        (0, 505555550955, -12, 39)\n        '''\n        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n        ompf = mlib.from_int(other.p)\n        return _sympify(bool(op(smpf, ompf)))\n    elif other.is_Float:\n        return _sympify(bool(\n                    op(self._mpf_, other._mpf_)))\n    elif other.is_comparable and other not in (\n            S.Infinity, S.NegativeInfinity):\n        other = other.evalf(prec_to_dps(self._prec))\n        if other._prec > 1:\n            if other.is_Number:\n                return _sympify(bool(\n                    op(self._mpf_, other._as_mpf_val(self._prec))))"
}