{
    "sympy.sympy.polys.densebasic.dup_inflate": "def dup_inflate(f: dup[Er], m: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Map ``y`` to ``x**m`` in a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_inflate\n\n    >>> f = ZZ.map([1, 1, 1])\n\n    >>> dup_inflate(f, 3, ZZ)\n    [1, 0, 0, 1, 0, 0, 1]\n\n    \"\"\"\n    if m <= 0:\n        raise IndexError(\"'m' must be positive, got %s\" % m)\n    if m == 1 or not f:\n        return f\n\n    result = [f[0]]\n\n    for coeff in f[1:]:\n        result.extend([K.zero] * (m - 1))\n        result.append(coeff)\n\n    return result",
    "sympy.sympy.polys.densebasic._rec_inflate": "def _rec_inflate(g: dmp[Er], M: list[int], v: int, i: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"Recursive helper for :func:`dmp_inflate`.\"\"\"\n    if not v:\n        return _dmp(dup_inflate(_dup(g), M[i], K))\n    if M[i] <= 0:\n        raise IndexError(\"all M[i] must be positive, got %s\" % M[i])\n\n    w, j = v - 1, i + 1\n\n    g = [_rec_inflate(c, M, w, j, K) for c in g]\n\n    result = [g[0]]\n\n    for coeff in g[1:]:\n        for _ in range(1, M[i]):\n            result.append(dmp_zero(w, K))\n\n        result.append(coeff)\n\n    return result",
    "sympy.sympy.polys.densebasic.<genexpr>": "if all(m == 1 for m in M):\n    return f\n",
    "sympy.sympy.polys.densebasic._dup": "def _dup(p, /):\n    return p",
    "sympy.sympy.polys.densebasic._dmp": "def _dmp(p, /):\n    return p"
}