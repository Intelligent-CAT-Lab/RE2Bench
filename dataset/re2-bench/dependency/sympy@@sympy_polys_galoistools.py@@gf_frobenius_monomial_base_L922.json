{
    "sympy.sympy.polys.galoistools.gf_pow_mod": "def gf_pow_mod(\n    f: dup[MPZ], n: MPZ | int, g: dup[MPZ], p: MPZ, K: Domain[MPZ]\n) -> dup[MPZ]:\n    \"\"\"\n    Compute ``f**n`` in ``GF(p)[x]/(g)`` using repeated squaring.\n\n    Given polynomials ``f`` and ``g`` in ``GF(p)[x]`` and a non-negative\n    integer ``n``, efficiently computes ``f**n (mod g)`` i.e. the remainder\n    of ``f**n`` from division by ``g``, using the repeated squaring algorithm.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_pow_mod\n\n    >>> gf_pow_mod(ZZ.map([3, 2, 4]), 3, ZZ.map([1, 1]), 5, ZZ)\n    []\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    if not n:\n        return [K.one]\n    elif n == 1:\n        return gf_rem(f, g, p, K)\n    elif n == 2:\n        return gf_rem(gf_sqr(f, p, K), g, p, K)\n\n    h = [K.one]\n\n    while True:\n        if n & 1:\n            h = gf_mul(h, f, p, K)\n            h = gf_rem(h, g, p, K)\n            n -= 1\n\n        n >>= 1\n\n        if not n:\n            break\n\n        f = gf_sqr(f, p, K)\n        f = gf_rem(f, g, p, K)\n\n    return h",
    "sympy.sympy.polys.galoistools.gf_degree": "def gf_degree(f: dup[MPZ]) -> int:\n    \"\"\"\n    Return the leading degree of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_degree\n\n    >>> gf_degree([1, 1, 2, 0])\n    3\n    >>> gf_degree([])\n    -1\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.galoistools.gf_mul": "def gf_mul(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Multiply polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_mul\n\n    >>> gf_mul([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [1, 0, 3, 2, 3]\n\n    \"\"\"\n    df = gf_degree(f)\n    dg = gf_degree(g)\n\n    dh = df + dg\n    h = [K.zero] * (dh + 1)\n\n    for i in range(0, dh + 1):\n        coeff = K.zero\n\n        for j in range(max(0, i - dg), min(i, df) + 1):\n            coeff += f[j] * g[i - j]\n\n        h[i] = coeff % p\n\n    return gf_strip(h)",
    "sympy.sympy.polys.galoistools.gf_rem": "def gf_rem(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Compute polynomial remainder in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_rem\n\n    >>> gf_rem(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n    [1]\n\n    \"\"\"\n    return gf_div(f, g, p, K)[1]",
    "sympy.sympy.polys.galoistools.gf_lshift": "def gf_lshift(f: dup[MPZ], n: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Efficiently multiply ``f`` by ``x**n``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_lshift\n\n    >>> gf_lshift([3, 2, 4], 4, ZZ)\n    [3, 2, 4, 0, 0, 0, 0]\n\n    \"\"\"\n    if not f:\n        return f\n    else:\n        return f + [K.zero] * n"
}