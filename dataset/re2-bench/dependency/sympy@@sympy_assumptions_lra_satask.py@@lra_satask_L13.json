{
    "sympy.sympy.assumptions.cnf.__init__": "def __init__(self, data=None, encoding=None):\n    if not data and not encoding:\n        data = []\n        encoding = {}\n    self.data = data\n    self.encoding = encoding\n    self._symbols = list(encoding.keys())",
    "sympy.sympy.assumptions.cnf.extend": "def extend(self, props):\n    for p in props:\n        self.add(p)\n    return self",
    "sympy.sympy.assumptions.cnf.from_prop": "@classmethod\ndef from_prop(cls, prop):\n    res = cls()\n    res.add(prop)\n    return res",
    "sympy.sympy.assumptions.cnf.from_cnf": "def from_cnf(self, cnf):\n    self._symbols = list(cnf.all_predicates())\n    n = len(self._symbols)\n    self.encoding = dict(zip(self._symbols, range(1, n + 1)))\n    self.data = [self.encode(clause) for clause in cnf.clauses]",
    "sympy.sympy.assumptions.cnf.add_from_cnf": "def add_from_cnf(self, cnf):\n    clauses = [self.encode(clause) for clause in cnf.clauses]\n    self.data += clauses",
    "sympy.sympy.assumptions.lra_satask.check_satisfiability": "def check_satisfiability(prop, _prop, factbase):\n    sat_true = factbase.copy()\n    sat_false = factbase.copy()\n    sat_true.add_from_cnf(prop)\n    sat_false.add_from_cnf(_prop)\n\n    all_pred, all_exprs = get_all_pred_and_expr_from_enc_cnf(sat_true)\n\n    for pred in all_pred:\n        if pred.function not in WHITE_LIST and pred.function != Q.ne:\n            raise UnhandledInput(f\"LRASolver: {pred} is an unhandled predicate\")\n    for expr in all_exprs:\n        if expr.kind == MatrixKind(NumberKind):\n            raise UnhandledInput(f\"LRASolver: {expr} is of MatrixKind\")\n        if expr == S.NaN:\n            raise UnhandledInput(\"LRASolver: nan\")\n\n    # convert old assumptions into predicates and add them to sat_true and sat_false\n    # also check for unhandled predicates\n    for assm in extract_pred_from_old_assum(all_exprs):\n        n = len(sat_true.encoding)\n        if assm not in sat_true.encoding:\n            sat_true.encoding[assm] = n+1\n        sat_true.data.append([sat_true.encoding[assm]])\n\n        n = len(sat_false.encoding)\n        if assm not in sat_false.encoding:\n            sat_false.encoding[assm] = n+1\n        sat_false.data.append([sat_false.encoding[assm]])\n\n\n    sat_true = _preprocess(sat_true)\n    sat_false = _preprocess(sat_false)\n\n    can_be_true = satisfiable(sat_true, use_lra_theory=True) is not False\n    can_be_false = satisfiable(sat_false, use_lra_theory=True) is not False\n\n    if can_be_true and can_be_false:\n        return None\n\n    if can_be_true and not can_be_false:\n        return True\n\n    if not can_be_true and can_be_false:\n        return False\n\n    if not can_be_true and not can_be_false:\n        raise ValueError(\"Inconsistent assumptions\")",
    "sympy.sympy.logic.boolalg.__invert__": "def __invert__(self):\n    \"\"\"Overloading for ~\"\"\"\n    return Not(self)"
}