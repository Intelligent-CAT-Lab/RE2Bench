{
    "sympy.sympy.polys.domains.domain.__contains__": "def __contains__(self, a: Any) -> bool:\n    \"\"\"Check if ``a`` belongs to this domain. \"\"\"\n    try:\n        if _not_a_coeff(a):\n            raise CoercionFailed\n        self.convert(a)  # this might raise, too\n    except CoercionFailed:\n        return False\n\n    return True",
    "sympy.sympy.polys.matrices.domainmatrix.matmul": "def matmul(A, B):\n    r\"\"\"\n    Performs matrix multiplication of two DomainMatrix matrices\n\n    Parameters\n    ==========\n\n    A, B: DomainMatrix\n        to multiply\n\n    Returns\n    =======\n\n    DomainMatrix\n        DomainMatrix after multiplication\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> B = DomainMatrix([\n    ...    [ZZ(1), ZZ(1)],\n    ...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n\n    >>> A.matmul(B)\n    DomainMatrix([[1, 3], [3, 7]], (2, 2), ZZ)\n\n    See Also\n    ========\n\n    mul, pow, add, sub\n\n    \"\"\"\n\n    A._check('*', B, A.shape[1], B.shape[0])\n    return A.from_rep(A.rep.matmul(B.rep))",
    "sympy.sympy.polys.matrices.domainmatrix.scalarmul": "def scalarmul(A, lamda):\n    return A._scalarmul(lamda, reverse=False)",
    "sympy.sympy.polys.matrices.domainmatrix.unify": "def unify(self, *others, fmt=None):\n    \"\"\"\n    Unifies the domains and the format of self and other\n    matrices.\n\n    Parameters\n    ==========\n\n    others : DomainMatrix\n\n    fmt: string 'dense', 'sparse' or `None` (default)\n        The preferred format to convert to if self and other are not\n        already in the same format. If `None` or not specified then no\n        conversion if performed.\n\n    Returns\n    =======\n\n    Tuple[DomainMatrix]\n        Matrices with unified domain and format\n\n    Examples\n    ========\n\n    Unify the domain of DomainMatrix that have different domains:\n\n    >>> from sympy import ZZ, QQ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)\n    >>> Aq, Bq = A.unify(B)\n    >>> Aq\n    DomainMatrix([[1, 2]], (1, 2), QQ)\n    >>> Bq\n    DomainMatrix([[1/2, 2]], (1, 2), QQ)\n\n    Unify the format (dense or sparse):\n\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)\n    >>> B.rep\n    {0: {0: 1}}\n\n    >>> A2, B2 = A.unify(B, fmt='dense')\n    >>> B2.rep\n    [[1, 0], [0, 0]]\n\n    See Also\n    ========\n\n    convert_to, to_dense, to_sparse\n\n    \"\"\"\n    matrices = (self,) + others\n    matrices = DomainMatrix._unify_domain(*matrices)\n    if fmt is not None:\n        matrices = DomainMatrix._unify_fmt(*matrices, fmt=fmt)\n    return matrices"
}