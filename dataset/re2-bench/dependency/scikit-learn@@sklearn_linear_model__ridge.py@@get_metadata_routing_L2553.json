{
    "scikit-learn.sklearn.linear_model._ridge._get_scorer": "def _get_scorer(self):\n    \"\"\"Make sure the scorer is weighted if necessary.\n\n    This uses `self._get_scorer_instance()` implemented in child objects to get the\n    raw scorer instance of the estimator, which will be ignored if `self.scoring` is\n    not None.\n    \"\"\"\n    if _routing_enabled() and self.scoring is None:\n        # This estimator passes an array of 1s as sample_weight even if\n        # sample_weight is not provided by the user. Therefore we need to\n        # always request it. But we don't set it if it's passed explicitly\n        # by the user.\n        return self._get_scorer_instance().set_score_request(sample_weight=True)\n\n    return check_scoring(estimator=self, scoring=self.scoring, allow_none=True)",
    "scikit-learn.sklearn.utils._metadata_requests.__init__": "def __init__(self, owner):\n    self._route_mappings = dict()\n    # `_self_request` is used if the router is also a consumer.\n    # _self_request, (added using `add_self_request()`) is treated\n    # differently from the other consumer objects which are stored in\n    # _route_mappings.\n    self._self_request = None\n    self.owner = owner",
    "scikit-learn.sklearn.utils._metadata_requests.add": "def add(self, *, method_mapping, **objs):\n    \"\"\"Add :term:`consumers <consumer>` to the `MetadataRouter`.\n\n    The estimators that consume metadata are passed as named objects along with a\n    method mapping, that defines how their methods relate to those of the\n    :term:`router`.\n\n    Parameters\n    ----------\n    method_mapping : MethodMapping\n        The mapping between the child (:term:`consumer`) and the parent's\n        (:term:`router`'s) methods.\n\n    **objs : dict\n        A dictionary of objects, whose requests are extracted by calling\n        :func:`~sklearn.utils.metadata_routing.get_routing_for_object` on them.\n\n    Returns\n    -------\n    self : MetadataRouter\n        Returns `self`.\n    \"\"\"\n    method_mapping = deepcopy(method_mapping)\n\n    for name, obj in objs.items():\n        self._route_mappings[name] = RouterMappingPair(\n            mapping=method_mapping, router=get_routing_for_object(obj)\n        )\n    return self",
    "scikit-learn.sklearn.utils._metadata_requests.add_self_request": "def add_self_request(self, obj):\n    \"\"\"Add `self` (as a :term:`consumer`) to the `MetadataRouter`.\n\n    This method is used if the :term:`router` is also a :term:`consumer`, and hence\n    the router itself needs to be included in the routing. The passed object\n    can be an estimator or a\n    :class:`~sklearn.utils.metadata_routing.MetadataRequest`.\n\n    A router should add itself using this method instead of `add` since it\n    should be treated differently than the other consumer objects to which metadata\n    is routed by the router.\n\n    Parameters\n    ----------\n    obj : object\n        This is typically the router instance, i.e. `self` in a\n        ``get_metadata_routing()`` implementation. It can also be a\n        ``MetadataRequest`` instance.\n\n    Returns\n    -------\n    self : MetadataRouter\n        Returns `self`.\n    \"\"\"\n    if getattr(obj, \"_type\", None) == \"metadata_request\":\n        self._self_request = deepcopy(obj)\n    elif hasattr(obj, \"_get_metadata_request\"):\n        self._self_request = deepcopy(obj._get_metadata_request())\n    else:\n        raise ValueError(\n            \"Given `obj` is neither a `MetadataRequest` nor does it implement the\"\n            \" required API. Inheriting from `BaseEstimator` implements the required\"\n            \" API.\"\n        )\n    return self"
}