{
    "scikit-learn.sklearn.datasets._arff_parser._io_to_generator": "def _io_to_generator(gzip_file):\n    for line in gzip_file:\n        yield line.decode(\"utf-8\")",
    "scikit-learn.sklearn.externals._arff.__init__": "def __init__(self, values):\n    self.values = {v: i for i, v in enumerate(values)}\n    self.values[0] = 0",
    "scikit-learn.sklearn.externals._arff._get_data_object_for_decoding": "def _get_data_object_for_decoding(matrix_type):\n    if matrix_type == DENSE:\n        return Data()\n    elif matrix_type == COO:\n        return COOData()\n    elif matrix_type == LOD:\n        return LODData()\n    elif matrix_type == DENSE_GEN:\n        return DenseGeneratorData()\n    elif matrix_type == LOD_GEN:\n        return LODGeneratorData()\n    else:\n        raise ValueError(\"Matrix type %s not supported.\" % str(matrix_type))",
    "scikit-learn.sklearn.externals._arff._decode_comment": "def _decode_comment(self, s):\n    '''(INTERNAL) Decodes a comment line.\n\n    Comments are single line strings starting, obligatorily, with the ``%``\n    character, and can have any symbol, including whitespaces or special\n    characters.\n\n    This method must receive a normalized string, i.e., a string without\n    padding, including the \"\\r\\n\" characters.\n\n    :param s: a normalized string.\n    :return: a string with the decoded comment.\n    '''\n    res = re.sub(r'^\\%( )?', '', s)\n    return res",
    "scikit-learn.sklearn.externals._arff._decode_relation": "def _decode_relation(self, s):\n    '''(INTERNAL) Decodes a relation line.\n\n    The relation declaration is a line with the format ``@RELATION\n    <relation-name>``, where ``relation-name`` is a string. The string must\n    start with alphabetic character and must be quoted if the name includes\n    spaces, otherwise this method will raise a `BadRelationFormat` exception.\n\n    This method must receive a normalized string, i.e., a string without\n    padding, including the \"\\r\\n\" characters.\n\n    :param s: a normalized string.\n    :return: a string with the decoded relation name.\n    '''\n    _, v = s.split(' ', 1)\n    v = v.strip()\n\n    if not _RE_RELATION.match(v):\n        raise BadRelationFormat()\n\n    res = str(v.strip('\"\\''))\n    return res",
    "scikit-learn.sklearn.externals._arff._decode_attribute": "def _decode_attribute(self, s):\n    '''(INTERNAL) Decodes an attribute line.\n\n    The attribute is the most complex declaration in an arff file. All\n    attributes must follow the template::\n\n         @attribute <attribute-name> <datatype>\n\n    where ``attribute-name`` is a string, quoted if the name contains any\n    whitespace, and ``datatype`` can be:\n\n    - Numerical attributes as ``NUMERIC``, ``INTEGER`` or ``REAL``.\n    - Strings as ``STRING``.\n    - Dates (NOT IMPLEMENTED).\n    - Nominal attributes with format:\n\n        {<nominal-name1>, <nominal-name2>, <nominal-name3>, ...}\n\n    The nominal names follow the rules for the attribute names, i.e., they\n    must be quoted if the name contains whitespaces.\n\n    This method must receive a normalized string, i.e., a string without\n    padding, including the \"\\r\\n\" characters.\n\n    :param s: a normalized string.\n    :return: a tuple (ATTRIBUTE_NAME, TYPE_OR_VALUES).\n    '''\n    _, v = s.split(' ', 1)\n    v = v.strip()\n\n    # Verify the general structure of declaration\n    m = _RE_ATTRIBUTE.match(v)\n    if not m:\n        raise BadAttributeFormat()\n\n    # Extracts the raw name and type\n    name, type_ = m.groups()\n\n    # Extracts the final name\n    name = str(name.strip('\"\\''))\n\n    # Extracts the final type\n    if type_[:1] == \"{\" and type_[-1:] == \"}\":\n        try:\n            type_ = _parse_values(type_.strip('{} '))\n        except Exception:\n            raise BadAttributeType()\n        if isinstance(type_, dict):\n            raise BadAttributeType()\n\n    else:\n        # If not nominal, verify the type name\n        type_ = str(type_).upper()\n        if type_ not in ['NUMERIC', 'REAL', 'INTEGER', 'STRING']:\n            raise BadAttributeType()\n\n    return (name, type_)"
}