{
    "pycparser.pycparser.c_generator.visit_Assignment": "def visit_Assignment(self, n):\n    rval_str = self._parenthesize_if(\n                        n.rvalue,\n                        lambda n: isinstance(n, c_ast.Assignment))\n    return '%s %s %s' % (self.visit(n.lvalue), n.op, rval_str)",
    "pycparser.pycparser.c_generator.visit_IdentifierType": "def visit_IdentifierType(self, n):\n    return ' '.join(n.names)",
    "pycparser.pycparser.c_generator.visit_Decl": "def visit_Decl(self, n, no_type=False):\n    # no_type is used when a Decl is part of a DeclList, where the type is\n    # explicitly only for the first declaration in a list.\n    #\n    s = n.name if no_type else self._generate_decl(n)\n    if n.bitsize: s += ' : ' + self.visit(n.bitsize)\n    if n.init:\n        s += ' = ' + self._visit_expr(n.init)\n    return s",
    "pycparser.pycparser.c_generator.visit_DeclList": "def visit_DeclList(self, n):\n    s = self.visit(n.decls[0])\n    if len(n.decls) > 1:\n        s += ', ' + ', '.join(self.visit_Decl(decl, no_type=True)\n                                for decl in n.decls[1:])\n    return s",
    "pycparser.pycparser.c_generator.visit_Typedef": "def visit_Typedef(self, n):\n    s = ''\n    if n.storage: s += ' '.join(n.storage) + ' '\n    s += self._generate_type(n.type)\n    return s",
    "pycparser.pycparser.c_generator.visit_Cast": "def visit_Cast(self, n):\n    s = '(' + self._generate_type(n.to_type, emit_declname=False) + ')'\n    return s + ' ' + self._parenthesize_unless_simple(n.expr)",
    "pycparser.pycparser.c_generator.visit_ExprList": "def visit_ExprList(self, n):\n    visited_subexprs = []\n    for expr in n.exprs:\n        visited_subexprs.append(self._visit_expr(expr))\n    return ', '.join(visited_subexprs)",
    "pycparser.pycparser.c_generator.visit_InitList": "def visit_InitList(self, n):\n    visited_subexprs = []\n    for expr in n.exprs:\n        visited_subexprs.append(self._visit_expr(expr))\n    return ', '.join(visited_subexprs)",
    "pycparser.pycparser.c_generator.visit_Enum": "def visit_Enum(self, n):\n    return self._generate_struct_union_enum(n, name='enum')",
    "pycparser.pycparser.c_generator.visit_Alignas": "def visit_Alignas(self, n):\n    return '_Alignas({})'.format(self.visit(n.alignment))",
    "pycparser.pycparser.c_generator.visit_Enumerator": "def visit_Enumerator(self, n):\n    if not n.value:\n        return '{indent}{name},\\n'.format(\n            indent=self._make_indent(),\n            name=n.name,\n        )\n    else:\n        return '{indent}{name} = {value},\\n'.format(\n            indent=self._make_indent(),\n            name=n.name,\n            value=self.visit(n.value),\n        )",
    "pycparser.pycparser.c_generator.visit_FuncDef": "def visit_FuncDef(self, n):\n    decl = self.visit(n.decl)\n    self.indent_level = 0\n    body = self.visit(n.body)\n    if n.param_decls:\n        knrdecls = ';\\n'.join(self.visit(p) for p in n.param_decls)\n        return decl + '\\n' + knrdecls + ';\\n' + body + '\\n'\n    else:\n        return decl + '\\n' + body + '\\n'",
    "pycparser.pycparser.c_generator.visit_FileAST": "def visit_FileAST(self, n):\n    s = ''\n    for ext in n.ext:\n        if isinstance(ext, c_ast.FuncDef):\n            s += self.visit(ext)\n        elif isinstance(ext, c_ast.Pragma):\n            s += self.visit(ext) + '\\n'\n        else:\n            s += self.visit(ext) + ';\\n'\n    return s",
    "pycparser.pycparser.c_generator.visit_Compound": "def visit_Compound(self, n):\n    s = self._make_indent() + '{\\n'\n    self.indent_level += 2\n    if n.block_items:\n        s += ''.join(self._generate_stmt(stmt) for stmt in n.block_items)\n    self.indent_level -= 2\n    s += self._make_indent() + '}\\n'\n    return s",
    "pycparser.pycparser.c_generator.visit_CompoundLiteral": "def visit_CompoundLiteral(self, n):\n    return '(' + self.visit(n.type) + '){' + self.visit(n.init) + '}'",
    "pycparser.pycparser.c_generator.visit_EmptyStatement": "def visit_EmptyStatement(self, n):\n    return ';'",
    "pycparser.pycparser.c_generator.visit_ParamList": "def visit_ParamList(self, n):\n    return ', '.join(self.visit(param) for param in n.params)",
    "pycparser.pycparser.c_generator.visit_Return": "def visit_Return(self, n):\n    s = 'return'\n    if n.expr: s += ' ' + self.visit(n.expr)\n    return s + ';'",
    "pycparser.pycparser.c_generator.visit_Break": "def visit_Break(self, n):\n    return 'break;'",
    "pycparser.pycparser.c_generator.visit_TernaryOp": "def visit_TernaryOp(self, n):\n    s  = '(' + self._visit_expr(n.cond) + ') ? '\n    s += '(' + self._visit_expr(n.iftrue) + ') : '\n    s += '(' + self._visit_expr(n.iffalse) + ')'\n    return s",
    "pycparser.pycparser.c_generator.visit_If": "def visit_If(self, n):\n    s = 'if ('\n    if n.cond: s += self.visit(n.cond)\n    s += ')\\n'\n    s += self._generate_stmt(n.iftrue, add_indent=True)\n    if n.iffalse:\n        s += self._make_indent() + 'else\\n'\n        s += self._generate_stmt(n.iffalse, add_indent=True)\n    return s",
    "pycparser.pycparser.c_generator.visit_For": "def visit_For(self, n):\n    s = 'for ('\n    if n.init: s += self.visit(n.init)\n    s += ';'\n    if n.cond: s += ' ' + self.visit(n.cond)\n    s += ';'\n    if n.next: s += ' ' + self.visit(n.next)\n    s += ')\\n'\n    s += self._generate_stmt(n.stmt, add_indent=True)\n    return s",
    "pycparser.pycparser.c_generator.visit_StaticAssert": "def visit_StaticAssert(self, n):\n    s = '_Static_assert('\n    s += self.visit(n.cond)\n    if n.message:\n        s += ','\n        s += self.visit(n.message)\n    s += ')'\n    return s",
    "pycparser.pycparser.c_generator.visit_Switch": "def visit_Switch(self, n):\n    s = 'switch (' + self.visit(n.cond) + ')\\n'\n    s += self._generate_stmt(n.stmt, add_indent=True)\n    return s",
    "pycparser.pycparser.c_generator.visit_Case": "def visit_Case(self, n):\n    s = 'case ' + self.visit(n.expr) + ':\\n'\n    for stmt in n.stmts:\n        s += self._generate_stmt(stmt, add_indent=True)\n    return s",
    "pycparser.pycparser.c_generator.visit_Default": "def visit_Default(self, n):\n    s = 'default:\\n'\n    for stmt in n.stmts:\n        s += self._generate_stmt(stmt, add_indent=True)\n    return s",
    "pycparser.pycparser.c_generator.visit_Struct": "def visit_Struct(self, n):\n    return self._generate_struct_union_enum(n, 'struct')",
    "pycparser.pycparser.c_generator.visit_Typename": "def visit_Typename(self, n):\n    return self._generate_type(n.type)",
    "pycparser.pycparser.c_generator.visit_NamedInitializer": "def visit_NamedInitializer(self, n):\n    s = ''\n    for name in n.name:\n        if isinstance(name, c_ast.ID):\n            s += '.' + name.name\n        else:\n            s += '[' + self.visit(name) + ']'\n    s += ' = ' + self._visit_expr(n.expr)\n    return s",
    "pycparser.pycparser.c_generator.visit_FuncDecl": "def visit_FuncDecl(self, n):\n    return self._generate_type(n)",
    "pycparser.pycparser.c_generator.visit_ArrayDecl": "def visit_ArrayDecl(self, n):\n    return self._generate_type(n, emit_declname=False)",
    "pycparser.pycparser.c_generator.visit_TypeDecl": "def visit_TypeDecl(self, n):\n    return self._generate_type(n, emit_declname=False)",
    "pycparser.pycparser.c_generator.visit_PtrDecl": "def visit_PtrDecl(self, n):\n    return self._generate_type(n, emit_declname=False)",
    "pycparser.pycparser.c_generator.generic_visit": "def generic_visit(self, node):\n    if node is None:\n        return ''\n    else:\n        return ''.join(self.visit(c) for c_name, c in node.children())",
    "pycparser.pycparser.c_generator.visit_Constant": "def visit_Constant(self, n):\n    return n.value",
    "pycparser.pycparser.c_generator.visit_ID": "def visit_ID(self, n):\n    return n.name",
    "pycparser.pycparser.c_generator.visit_Pragma": "def visit_Pragma(self, n):\n    ret = '#pragma'\n    if n.string:\n        ret += ' ' + n.string\n    return ret",
    "pycparser.pycparser.c_generator.visit_ArrayRef": "def visit_ArrayRef(self, n):\n    arrref = self._parenthesize_unless_simple(n.name)\n    return arrref + '[' + self.visit(n.subscript) + ']'",
    "pycparser.pycparser.c_generator.visit_FuncCall": "def visit_FuncCall(self, n):\n    fref = self._parenthesize_unless_simple(n.name)\n    return fref + '(' + self.visit(n.args) + ')'",
    "pycparser.pycparser.c_generator.visit_UnaryOp": "def visit_UnaryOp(self, n):\n    if n.op == 'sizeof':\n        # Always parenthesize the argument of sizeof since it can be\n        # a name.\n        return 'sizeof(%s)' % self.visit(n.expr)\n    else:\n        operand = self._parenthesize_unless_simple(n.expr)\n        if n.op == 'p++':\n            return '%s++' % operand\n        elif n.op == 'p--':\n            return '%s--' % operand\n        else:\n            return '%s%s' % (n.op, operand)",
    "pycparser.pycparser.c_generator.visit_BinaryOp": "def visit_BinaryOp(self, n):\n    # Note: all binary operators are left-to-right associative\n    #\n    # If `n.left.op` has a stronger or equally binding precedence in\n    # comparison to `n.op`, no parenthesis are needed for the left:\n    # e.g., `(a*b) + c` is equivalent to `a*b + c`, as well as\n    #       `(a+b) - c` is equivalent to `a+b - c` (same precedence).\n    # If the left operator is weaker binding than the current, then\n    # parentheses are necessary:\n    # e.g., `(a+b) * c` is NOT equivalent to `a+b * c`.\n    lval_str = self._parenthesize_if(\n        n.left,\n        lambda d: not (self._is_simple_node(d) or\n                  self.reduce_parentheses and isinstance(d, c_ast.BinaryOp) and\n                  self.precedence_map[d.op] >= self.precedence_map[n.op]))\n    # If `n.right.op` has a stronger -but not equal- binding precedence,\n    # parenthesis can be omitted on the right:\n    # e.g., `a + (b*c)` is equivalent to `a + b*c`.\n    # If the right operator is weaker or equally binding, then parentheses\n    # are necessary:\n    # e.g., `a * (b+c)` is NOT equivalent to `a * b+c` and\n    #       `a - (b+c)` is NOT equivalent to `a - b+c` (same precedence).\n    rval_str = self._parenthesize_if(\n        n.right,\n        lambda d: not (self._is_simple_node(d) or\n                  self.reduce_parentheses and isinstance(d, c_ast.BinaryOp) and\n                  self.precedence_map[d.op] > self.precedence_map[n.op]))\n    return '%s %s %s' % (lval_str, n.op, rval_str)"
}