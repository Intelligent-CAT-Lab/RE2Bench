{
    "sympy.sympy.concrete.expr_with_limits.function": "@property\ndef function(self):\n    \"\"\"Return the function applied across limits.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x\n    >>> Integral(x**2, (x,)).function\n    x**2\n\n    See Also\n    ========\n\n    limits, variables, free_symbols\n    \"\"\"\n    return self._args[0]",
    "sympy.sympy.concrete.expr_with_limits.limits": "@property\ndef limits(self):\n    \"\"\"Return the limits of expression.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, i\n    >>> Integral(x**i, (i, 1, 3)).limits\n    ((i, 1, 3),)\n\n    See Also\n    ========\n\n    function, variables, free_symbols\n    \"\"\"\n    return self._args[1:]",
    "sympy.sympy.concrete.expr_with_limits.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols in the object, excluding those\n    that take on a specific value (i.e. the dummy symbols).\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.abc import x, y\n    >>> Sum(x, (x, y, 1)).free_symbols\n    {y}\n    \"\"\"\n    # don't test for any special values -- nominal free symbols\n    # should be returned, e.g. don't return set() if the\n    # function is zero -- treat it like an unevaluated expression.\n    function, limits = self.function, self.limits\n    # mask off non-symbol integration variables that have\n    # more than themself as a free symbol\n    reps = {i[0]: i[0] if i[0].free_symbols == {i[0]} else Dummy()\n        for i in self.limits}\n    function = function.xreplace(reps)\n    isyms = function.free_symbols\n    for xab in limits:\n        v = reps[xab[0]]\n        if len(xab) == 1:\n            isyms.add(v)\n            continue\n        # take out the target symbol\n        if v in isyms:\n            isyms.remove(v)\n        # add in the new symbols\n        for i in xab[1:]:\n            isyms.update(i.free_symbols)\n    reps = {v: k for k, v in reps.items()}\n    return {reps.get(_, _) for _ in isyms}",
    "sympy.sympy.concrete.expr_with_limits.<genexpr>": "if not (limits and all(len(limit) == 3 for limit in limits)):\n    sympy_deprecation_warning(\n        \"\"\"\n        Creating a indefinite integral with an Eq() argument is\n        deprecated.\n\n        This is because indefinite integrals do not preserve equality\n        due to the arbitrary constants. If you want an equality of\n        indefinite integrals, use Eq(Integral(a, x), Integral(b, x))\n        explicitly.\n        \"\"\",\n        deprecated_since_version=\"1.6\",\n        active_deprecations_target=\"deprecated-indefinite-integral-eq\",\n        stacklevel=5,\n    )\n\n",
    "sympy.sympy.concrete.expr_with_limits.<listcomp>": "    limits, orientation = [Tuple(s) for s in free], 1\n\n# denest any nested calls\n",
    "sympy.sympy.concrete.expr_with_limits.<setcomp>": "symbols_of_integration = {i[0] for i in limits}\n",
    "sympy.sympy.concrete.expr_with_limits.<dictcomp>": "function = function.xreplace({v: k for k, v in reps.items()})\n\n",
    "sympy.sympy.concrete.expr_with_limits._process_limits": "def _process_limits(*symbols, discrete=None):\n    \"\"\"Process the list of symbols and convert them to canonical limits,\n    storing them as Tuple(symbol, lower, upper). The orientation of\n    the function is also returned when the upper limit is missing\n    so (x, 1, None) becomes (x, None, 1) and the orientation is changed.\n    In the case that a limit is specified as (symbol, Range), a list of\n    length 4 may be returned if a change of variables is needed; the\n    expression that should replace the symbol in the expression is\n    the fourth element in the list.\n    \"\"\"\n    limits = []\n    orientation = 1\n    if discrete is None:\n        err_msg = 'discrete must be True or False'\n    elif discrete:\n        err_msg = 'use Range, not Interval or Relational'\n    else:\n        err_msg = 'use Interval or Relational, not Range'\n    for V in symbols:\n        if isinstance(V, (Relational, BooleanFunction)):\n            if discrete:\n                raise TypeError(err_msg)\n            variable = V.atoms(Symbol).pop()\n            V = (variable, V.as_set())\n        elif isinstance(V, Symbol) or getattr(V, '_diff_wrt', False):\n            if isinstance(V, Idx):\n                if V.lower is None or V.upper is None:\n                    limits.append(Tuple(V))\n                else:\n                    limits.append(Tuple(V, V.lower, V.upper))\n            else:\n                limits.append(Tuple(V))\n            continue\n        if is_sequence(V) and not isinstance(V, Set):\n            if len(V) == 2 and isinstance(V[1], Set):\n                V = list(V)\n                if isinstance(V[1], Interval):  # includes Reals\n                    if discrete:\n                        raise TypeError(err_msg)\n                    V[1:] = V[1].inf, V[1].sup\n                elif isinstance(V[1], Range):\n                    if not discrete:\n                        raise TypeError(err_msg)\n                    lo = V[1].inf\n                    hi = V[1].sup\n                    dx = abs(V[1].step)  # direction doesn't matter\n                    if dx == 1:\n                        V[1:] = [lo, hi]\n                    else:\n                        if lo is not S.NegativeInfinity:\n                            V = [V[0]] + [0, (hi - lo)//dx, dx*V[0] + lo]\n                        else:\n                            V = [V[0]] + [0, S.Infinity, -dx*V[0] + hi]\n                else:\n                    # more complicated sets would require splitting, e.g.\n                    # Union(Interval(1, 3), interval(6,10))\n                    raise NotImplementedError(\n                        'expecting Range' if discrete else\n                        'Relational or single Interval' )\n            V = sympify(flatten(V))  # list of sympified elements/None\n            if isinstance(V[0], (Symbol, Idx)) or getattr(V[0], '_diff_wrt', False):\n                newsymbol = V[0]\n                if len(V) == 3:\n                    # general case\n                    if V[2] is None and V[1] is not None:\n                        orientation *= -1\n                    V = [newsymbol] + [i for i in V[1:] if i is not None]\n\n                lenV = len(V)\n                if not isinstance(newsymbol, Idx) or lenV == 3:\n                    if lenV == 4:\n                        limits.append(Tuple(*V))\n                        continue\n                    if lenV == 3:\n                        if isinstance(newsymbol, Idx):\n                            # Idx represents an integer which may have\n                            # specified values it can take on; if it is\n                            # given such a value, an error is raised here\n                            # if the summation would try to give it a larger\n                            # or smaller value than permitted. None and Symbolic\n                            # values will not raise an error.\n                            lo, hi = newsymbol.lower, newsymbol.upper\n                            try:\n                                if lo is not None and not bool(V[1] >= lo):\n                                    raise ValueError(\"Summation will set Idx value too low.\")\n                            except TypeError:\n                                pass\n                            try:\n                                if hi is not None and not bool(V[2] <= hi):\n                                    raise ValueError(\"Summation will set Idx value too high.\")\n                            except TypeError:\n                                pass\n                        limits.append(Tuple(*V))\n                        continue\n                    if lenV == 1 or (lenV == 2 and V[1] is None):\n                        limits.append(Tuple(newsymbol))\n                        continue\n                    elif lenV == 2:\n                        limits.append(Tuple(newsymbol, V[1]))\n                        continue\n\n        raise ValueError('Invalid limits given: %s' % str(symbols))\n\n    return limits, orientation",
    "sympy.sympy.concrete.products.__new__": "def __new__(cls, function, *symbols, **assumptions):\n    obj = ExprWithIntLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.concrete.products.term": "@property\ndef term(self):\n    return self._args[0]",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.containers.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    "sympy.sympy.core.containers.__len__": "def __len__(self):\n    return len(self.args)",
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.core.function.free_symbols": "@property\ndef free_symbols(self):\n    ret = self.expr.free_symbols\n    # Add symbolic counts to free_symbols\n    for _, count in self.variable_count:\n        ret.update(count.free_symbols)\n    return ret",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.relational.lhs": "@property\ndef lhs(self) -> Basic:\n    \"\"\"The left-hand side of the relation.\"\"\"\n    return self._args[0]",
    "sympy.sympy.core.relational.rhs": "@property\ndef rhs(self) -> Basic:\n    \"\"\"The right-hand side of the relation.\"\"\"\n    return self._args[1]",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs, rhs, **options) -> Equality | BooleanFalse | BooleanTrue: # type: ignore\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    if evaluate:\n        val = is_eq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n\n    return Relational.__new__(cls, lhs, rhs)",
    "sympy.sympy.core.symbol.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    return {self}",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str | None = None,\n                 dummy_index: int | None = None,\n                 **assumptions: bool | None) -> Self:\n    if dummy_index is not None:\n        assert name is not None, \"If you specify a dummy_index, you must also provide a name\"\n\n    if name is None:\n        name = \"Dummy_\" + str(Dummy._count)\n\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n\n    obj.dummy_index = dummy_index\n\n    return obj",
    "sympy.sympy.core.sympify.sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    \"\"\"\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n\n    Explanation\n    ===========\n\n    It will convert Python ints into instances of :class:`~.Integer`, floats\n    into instances of :class:`~.Float`, etc. It is also able to coerce\n    symbolic expressions which inherit from :class:`~.Basic`. This can be\n    useful in cooperation with SAGE.\n\n    .. warning::\n        Note that this function uses ``eval``, and thus shouldn't be used on\n        unsanitized input.\n\n    If the argument is already a type that SymPy understands, it will do\n    nothing but return that value. This can be used at the beginning of a\n    function to ensure you are working with the correct type.\n\n    Examples\n    ========\n\n    >>> from sympy import sympify\n\n    >>> sympify(2).is_integer\n    True\n    >>> sympify(2).is_real\n    True\n\n    >>> sympify(2.0).is_real\n    True\n    >>> sympify(\"2.0\").is_real\n    True\n    >>> sympify(\"2e-45\").is_real\n    True\n\n    If the expression could not be converted, a SympifyError is raised.\n\n    >>> sympify(\"x***2\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: \"could not parse 'x***2'\"\n\n    When attempting to parse non-Python syntax using ``sympify``, it raises a\n    ``SympifyError``:\n\n    >>> sympify(\"2x+1\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: Sympify of expression 'could not parse '2x+1'' failed\n\n    To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"2x+1\", transformations=\"all\")\n    2*x + 1\n\n    For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`\n\n    Locals\n    ------\n\n    The sympification happens with access to everything that is loaded\n    by ``from sympy import *``; anything used in a string that is not\n    defined by that import will be converted to a symbol. In the following,\n    the ``bitcount`` function is treated as a symbol and the ``O`` is\n    interpreted as the :class:`~.Order` object (used with series) and it raises\n    an error when used improperly:\n\n    >>> s = 'bitcount(42)'\n    >>> sympify(s)\n    bitcount(42)\n    >>> sympify(\"O(x)\")\n    O(x)\n    >>> sympify(\"O + 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: unbound method...\n\n    In order to have ``bitcount`` be recognized it can be defined in a\n    namespace dictionary and passed as locals:\n\n    >>> ns = {}\n    >>> exec('bitcount = lambda n: int(n).bit_length()', ns)\n    >>> sympify(s, locals=ns)\n    6\n\n    In order to have the ``O`` interpreted as a Symbol, identify it as such\n    in the namespace dictionary. This can be done in a variety of ways; all\n    three of the following are possibilities:\n\n    >>> from sympy import Symbol\n    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n    >>> exec('from sympy.abc import O', ns)  # method 2\n    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n    >>> sympify(\"O + 1\", locals=ns)\n    O + 1\n\n    If you want *all* single-letter and Greek-letter variables to be symbols\n    then you can use the clashing-symbols dictionaries that have been defined\n    there as private variables: ``_clash1`` (single-letter variables),\n    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n    multi-letter names that are defined in ``abc``).\n\n    >>> from sympy.abc import _clash1\n    >>> set(_clash1)  # if this fails, see issue #23903\n    {'E', 'I', 'N', 'O', 'Q', 'S'}\n    >>> sympify('I & Q', _clash1)\n    I & Q\n\n    Strict\n    ------\n\n    If the option ``strict`` is set to ``True``, only the types for which an\n    explicit conversion has been defined are converted. In the other\n    cases, a SympifyError is raised.\n\n    >>> print(sympify(None))\n    None\n    >>> sympify(None, strict=True)\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: None\n\n    .. deprecated:: 1.6\n\n       ``sympify(obj)`` automatically falls back to ``str(obj)`` when all\n       other conversion methods fail, but this is deprecated. ``strict=True``\n       will disable this deprecated behavior. See\n       :ref:`deprecated-sympify-string-fallback`.\n\n    Evaluation\n    ----------\n\n    If the option ``evaluate`` is set to ``False``, then arithmetic and\n    operators will be converted into their SymPy equivalents and the\n    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n    be denested first. This is done via an AST transformation that replaces\n    operators with their SymPy equivalents, so if an operand redefines any\n    of those operations, the redefined operators will not be used. If\n    argument a is not a string, the mathematical expression is evaluated\n    before being passed to sympify, so adding ``evaluate=False`` will still\n    return the evaluated result of expression.\n\n    >>> sympify('2**2 / 3 + 5')\n    19/3\n    >>> sympify('2**2 / 3 + 5', evaluate=False)\n    2**2/3 + 5\n    >>> sympify('4/2+7', evaluate=True)\n    9\n    >>> sympify('4/2+7', evaluate=False)\n    4/2 + 7\n    >>> sympify(4/2+7, evaluate=False)\n    9.00000000000000\n\n    Extending\n    ---------\n\n    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n    just define a ``_sympy_`` method to your class. You can do that even to\n    classes that you do not own by subclassing or adding the method at runtime.\n\n    >>> from sympy import Matrix\n    >>> class MyList1(object):\n    ...     def __iter__(self):\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    ...     def _sympy_(self): return Matrix(self)\n    >>> sympify(MyList1())\n    Matrix([\n    [1],\n    [2]])\n\n    If you do not have control over the class definition you could also use the\n    ``converter`` global dictionary. The key is the class and the value is a\n    function that takes a single argument and returns the desired SymPy\n    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n\n    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n    ...     def __iter__(self):  #     Use _sympy_!\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    >>> from sympy.core.sympify import converter\n    >>> converter[MyList2] = lambda x: Matrix(x)\n    >>> sympify(MyList2())\n    Matrix([\n    [1],\n    [2]])\n\n    Notes\n    =====\n\n    The keywords ``rational`` and ``convert_xor`` are only used\n    when the input is a string.\n\n    convert_xor\n    -----------\n\n    >>> sympify('x^y',convert_xor=True)\n    x**y\n    >>> sympify('x^y',convert_xor=False)\n    x ^ y\n\n    rational\n    --------\n\n    >>> sympify('0.1',rational=False)\n    0.1\n    >>> sympify('0.1',rational=True)\n    1/10\n\n    Sometimes autosimplification during sympification results in expressions\n    that are very different in structure than what was entered. Until such\n    autosimplification is no longer done, the ``kernS`` function might be of\n    some use. In the example below you can see how an expression reduces to\n    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n\n    >>> from sympy.core.sympify import kernS\n    >>> from sympy.abc import x\n    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n    -1\n    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n    >>> sympify(s)\n    -1\n    >>> kernS(s)\n    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n\n    Parameters\n    ==========\n\n    a :\n        - any object defined in SymPy\n        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n        - booleans, including ``None`` (will leave ``None`` unchanged)\n        - dicts, lists, sets or tuples containing any of the above\n\n    convert_xor : bool, optional\n        If true, treats ``^`` as exponentiation.\n        If False, treats ``^`` as XOR itself.\n        Used only when input is a string.\n\n    locals : any object defined in SymPy, optional\n        In order to have strings be recognized it can be imported\n        into a namespace dictionary and passed as locals.\n\n    strict : bool, optional\n        If the option strict is set to ``True``, only the types for which\n        an explicit conversion has been defined are converted. In the\n        other cases, a SympifyError is raised.\n\n    rational : bool, optional\n        If ``True``, converts floats into :class:`~.Rational`.\n        If ``False``, it lets floats remain as it is.\n        Used only when input is a string.\n\n    evaluate : bool, optional\n        If False, then arithmetic and operators will be converted into\n        their SymPy equivalents. If True the expression will be evaluated\n        and the result will be returned.\n\n    \"\"\"\n    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n    # was used for a long time we allow it to pass. However if strict=True as\n    # is the case in internal calls to _sympify then we only allow\n    # is_sympy=True.\n    #\n    # https://github.com/sympy/sympy/issues/20124\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n\n    cls = getattr(a, \"__class__\", None)\n\n    #Check if there exists a converter for any of the types in the mro\n    for superclass in getmro(cls):\n        #First check for user defined converters\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            #if none exists, check for SymPy defined converters\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    # Support for basic numpy datatypes\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals,\n                convert_xor=convert_xor, strict=strict, rational=rational,\n                evaluate=evaluate)\n\n    _sympy_ = getattr(a, \"_sympy_\", None)\n    if _sympy_ is not None:\n        return a._sympy_()\n\n    if not strict:\n        # Put numpy array conversion _before_ float/int, see\n        # <https://github.com/sympy/sympy/issues/13924>.\n        flat = getattr(a, \"flat\", None)\n        if flat is not None:\n            shape = getattr(a, \"shape\", None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                # Scalar arrays (those with zero dimensions) have sympify\n                # called on the scalar element.\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(),\n                                       locals=locals,\n                                       convert_xor=convert_xor,\n                                       strict=strict,\n                                       rational=rational,\n                                       evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        elif hasattr(a, '__float__'):\n            # float and int can coerce size-one numpy arrays to their lone\n            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n            return sympify(float(a))\n        elif hasattr(a, '__int__'):\n            return sympify(int(a))\n\n    if strict:\n        raise SympifyError(a)\n\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n                rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            # Not all iterables are rebuildable with their type.\n            pass\n\n    if not isinstance(a, str):\n        raise SympifyError('cannot sympify object of type %r' % type(a))\n\n    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n                                            standard_transformations)\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n\n    transformations = standard_transformations\n\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n\n    return expr",
    "sympy.sympy.functions.elementary.piecewise.piecewise_fold": "def piecewise_fold(expr, evaluate=True):\n    \"\"\"\n    Takes an expression containing a piecewise function and returns the\n    expression in piecewise form. In addition, any ITE conditions are\n    rewritten in negation normal form and simplified.\n\n    The final Piecewise is evaluated (default) but if the raw form\n    is desired, send ``evaluate=False``; if trivial evaluation is\n    desired, send ``evaluate=None`` and duplicate conditions and\n    processing of True and False will be handled.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, piecewise_fold, S\n    >>> from sympy.abc import x\n    >>> p = Piecewise((x, x < 1), (1, S(1) <= x))\n    >>> piecewise_fold(x*p)\n    Piecewise((x**2, x < 1), (x, True))\n\n    See Also\n    ========\n\n    Piecewise\n    piecewise_exclusive\n    \"\"\"\n    if not isinstance(expr, Basic) or not expr.has(Piecewise):\n        return expr\n\n    new_args = []\n    if isinstance(expr, (ExprCondPair, Piecewise)):\n        for e, c in expr.args:\n            if not isinstance(e, Piecewise):\n                e = piecewise_fold(e)\n            # we don't keep Piecewise in condition because\n            # it has to be checked to see that it's complete\n            # and we convert it to ITE at that time\n            assert not c.has(Piecewise)  # pragma: no cover\n            if isinstance(c, ITE):\n                c = c.to_nnf()\n                c = simplify_logic(c, form='cnf')\n            if isinstance(e, Piecewise):\n                new_args.extend([(piecewise_fold(ei), And(ci, c))\n                    for ei, ci in e.args])\n            else:\n                new_args.append((e, c))\n    else:\n        # Given\n        #     P1 = Piecewise((e11, c1), (e12, c2), A)\n        #     P2 = Piecewise((e21, c1), (e22, c2), B)\n        #     ...\n        # the folding of f(P1, P2) is trivially\n        # Piecewise(\n        #   (f(e11, e21), c1),\n        #   (f(e12, e22), c2),\n        #   (f(Piecewise(A), Piecewise(B)), True))\n        # Certain objects end up rewriting themselves as thus, so\n        # we do that grouping before the more generic folding.\n        # The following applies this idea when f = Add or f = Mul\n        # (and the expression is commutative).\n        if expr.is_Add or expr.is_Mul and expr.is_commutative:\n            p, args = sift(expr.args, lambda x: x.is_Piecewise, binary=True)\n            pc = sift(p, lambda x: tuple([c for e,c in x.args]))\n            for c in list(ordered(pc)):\n                if len(pc[c]) > 1:\n                    pargs = [list(i.args) for i in pc[c]]\n                    # the first one is the same; there may be more\n                    com = common_prefix(*[\n                        [i.cond for i in j] for j in pargs])\n                    n = len(com)\n                    collected = []\n                    for i in range(n):\n                        collected.append((\n                            expr.func(*[ai[i].expr for ai in pargs]),\n                            com[i]))\n                    remains = []\n                    for a in pargs:\n                        if n == len(a):  # no more args\n                            continue\n                        if a[n].cond == True:  # no longer Piecewise\n                            remains.append(a[n].expr)\n                        else:  # restore the remaining Piecewise\n                            remains.append(\n                                Piecewise(*a[n:], evaluate=False))\n                    if remains:\n                        collected.append((expr.func(*remains), True))\n                    args.append(Piecewise(*collected, evaluate=False))\n                    continue\n                args.extend(pc[c])\n        else:\n            args = expr.args\n        # fold\n        folded = list(map(piecewise_fold, args))\n        for ec in product(*[\n                (i.args if isinstance(i, Piecewise) else\n                 [(i, true)]) for i in folded]):\n            e, c = zip(*ec)\n            new_args.append((expr.func(*e), And(*c)))\n\n    if evaluate is None:\n        # don't return duplicate conditions, otherwise don't evaluate\n        new_args = list(reversed([(e, c) for c, e in {\n            c: e for e, c in reversed(new_args)}.items()]))\n    rv = Piecewise(*new_args, evaluate=evaluate)\n    if evaluate is None and len(rv.args) == 1 and rv.args[0].cond == True:\n        return rv.args[0].expr\n    if any(s.expr.has(Piecewise) for p in rv.atoms(Piecewise) for s in p.args):\n        return piecewise_fold(rv)\n    return rv",
    "sympy.sympy.integrals.integrals.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"\n    This method returns the symbols that will exist when the\n    integral is evaluated. This is useful if one is trying to\n    determine whether an integral depends on a certain\n    symbol or not.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x, (x, y, 1)).free_symbols\n    {y}\n\n    See Also\n    ========\n\n    sympy.concrete.expr_with_limits.ExprWithLimits.function\n    sympy.concrete.expr_with_limits.ExprWithLimits.limits\n    sympy.concrete.expr_with_limits.ExprWithLimits.variables\n    \"\"\"\n    return super().free_symbols",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.matrices.matrixbase.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import Matrix\n    >>> Matrix([[x]])\n    Matrix([[x]])\n    >>> _.atoms()\n    {x}\n    >>> Matrix([[x, y], [y, x]])\n    Matrix([\n    [x, y],\n    [y, x]])\n    >>> _.atoms()\n    {x, y}\n    \"\"\"\n    types = tuple(t if isinstance(t, type) else type(t) for t in types)\n    if not types:\n        # XXX: .atoms(Atom) is not the same as .atoms()\n        # This should be changed.\n        return self._eval_atoms(Atom) # type: ignore\n    else:\n        return self._eval_atoms(*types)",
    "sympy.sympy.matrices.matrixbase.xreplace": "def xreplace(self, rule: Mapping[SBasic, SBasic]) -> Self:\n    \"\"\"Return a new matrix with xreplace applied to each entry.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import SparseMatrix, Matrix\n    >>> SparseMatrix(1, 1, [x])\n    Matrix([[x]])\n    >>> _.xreplace({x: y})\n    Matrix([[y]])\n    >>> Matrix(_).xreplace({y: x})\n    Matrix([[x]])\n    \"\"\"\n    return self.applyfunc(lambda x: x.xreplace(rule))",
    "sympy.sympy.utilities.exceptions.sympy_deprecation_warning": "def sympy_deprecation_warning(message, *, deprecated_since_version,\n                              active_deprecations_target, stacklevel=3):\n    r'''\n    Warn that a feature is deprecated in SymPy.\n\n    See the :ref:`deprecation-policy` document for details on when and how\n    things should be deprecated in SymPy.\n\n    To mark an entire function or class as deprecated, you can use the\n    :func:`@deprecated <sympy.utilities.decorator.deprecated>` decorator.\n\n    Parameters\n    ==========\n\n    message : str\n         The deprecation message. This may span multiple lines and contain\n         code examples. Messages should be wrapped to 80 characters. The\n         message is automatically dedented and leading and trailing whitespace\n         stripped. Messages may include dynamic content based on the user\n         input, but avoid using ``str(expression)`` if an expression can be\n         arbitrary, as it might be huge and make the warning message\n         unreadable.\n\n    deprecated_since_version : str\n         The version of SymPy the feature has been deprecated since. For new\n         deprecations, this should be the version in `sympy/release.py\n         <https://github.com/sympy/sympy/blob/master/sympy/release.py>`_\n         without the ``.dev``. If the next SymPy version ends up being\n         different from this, the release manager will need to update any\n         ``SymPyDeprecationWarning``\\s using the incorrect version. This\n         argument is required and must be passed as a keyword argument.\n         (example:  ``deprecated_since_version=\"1.10\"``).\n\n    active_deprecations_target : str\n        The Sphinx target corresponding to the section for the deprecation in\n        the :ref:`active-deprecations` document (see\n        ``doc/src/explanation/active-deprecations.md``). This is used to\n        automatically generate a URL to the page in the warning message. This\n        argument is required and must be passed as a keyword argument.\n        (example: ``active_deprecations_target=\"deprecated-feature-abc\"``)\n\n    stacklevel : int, default: 3\n        The ``stacklevel`` parameter that is passed to ``warnings.warn``. If\n        you create a wrapper that calls this function, this should be\n        increased so that the warning message shows the user line of code that\n        produced the warning. Note that in some cases there will be multiple\n        possible different user code paths that could result in the warning.\n        In that case, just choose the smallest common stacklevel.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.exceptions import sympy_deprecation_warning\n    >>> def is_this_zero(x, y=0):\n    ...     \"\"\"\n    ...     Determine if x = 0.\n    ...\n    ...     Parameters\n    ...     ==========\n    ...\n    ...     x : Expr\n    ...       The expression to check.\n    ...\n    ...     y : Expr, optional\n    ...       If provided, check if x = y.\n    ...\n    ...       .. deprecated:: 1.1\n    ...\n    ...          The ``y`` argument to ``is_this_zero`` is deprecated. Use\n    ...          ``is_this_zero(x - y)`` instead.\n    ...\n    ...     \"\"\"\n    ...     from sympy import simplify\n    ...\n    ...     if y != 0:\n    ...         sympy_deprecation_warning(\"\"\"\n    ...     The y argument to is_zero() is deprecated. Use is_zero(x - y) instead.\"\"\",\n    ...             deprecated_since_version=\"1.1\",\n    ...             active_deprecations_target='is-this-zero-y-deprecation')\n    ...     return simplify(x - y) == 0\n    >>> is_this_zero(0)\n    True\n    >>> is_this_zero(1, 1) # doctest: +SKIP\n    <stdin>:1: SymPyDeprecationWarning:\n    <BLANKLINE>\n    The y argument to is_zero() is deprecated. Use is_zero(x - y) instead.\n    <BLANKLINE>\n    See https://docs.sympy.org/latest/explanation/active-deprecations.html#is-this-zero-y-deprecation\n    for details.\n    <BLANKLINE>\n    This has been deprecated since SymPy version 1.1. It\n    will be removed in a future version of SymPy.\n    <BLANKLINE>\n      is_this_zero(1, 1)\n    True\n\n    See Also\n    ========\n\n    sympy.utilities.exceptions.SymPyDeprecationWarning\n    sympy.utilities.exceptions.ignore_warnings\n    sympy.utilities.decorator.deprecated\n    sympy.testing.pytest.warns_deprecated_sympy\n\n    '''\n    w = SymPyDeprecationWarning(message,\n                            deprecated_since_version=deprecated_since_version,\n                                active_deprecations_target=active_deprecations_target)\n    warnings.warn(w, stacklevel=stacklevel)"
}