{
    "scikit-learn.sklearn.utils._metadata_requests._consumes": "def _consumes(self, params):\n    \"\"\"Return subset of `params` consumed by the method that owns this instance.\n\n    Parameters\n    ----------\n    params : iterable of str\n        An iterable of parameter names to test for consumption.\n\n    Returns\n    -------\n    consumed_params : set of str\n        A subset of parameters from `params` which are consumed by this method.\n    \"\"\"\n    params = set(params)\n    consumed_params = set()\n    for metadata_name, alias in self._requests.items():\n        if alias is True and metadata_name in params:\n            consumed_params.add(metadata_name)\n        elif isinstance(alias, str) and alias in params:\n            consumed_params.add(alias)\n    return consumed_params",
    "scikit-learn.sklearn.utils._metadata_requests.__getattr__": "def __getattr__(self, name):\n    # Called when the default attribute access fails with an AttributeError\n    # (either __getattribute__() raises an AttributeError because name is\n    # not an instance attribute or an attribute in the class tree for self;\n    # or __get__() of a name property raises AttributeError). This method\n    # should either return the (computed) attribute value or raise an\n    # AttributeError exception.\n    # https://docs.python.org/3/reference/datamodel.html#object.__getattr__\n    if name not in COMPOSITE_METHODS:\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n        )\n\n    requests = {}\n    for method in COMPOSITE_METHODS[name]:\n        mmr = getattr(self, method)\n        existing = set(requests.keys())\n        upcoming = set(mmr.requests.keys())\n        common = existing & upcoming\n        conflicts = [key for key in common if requests[key] != mmr._requests[key]]\n        if conflicts:\n            raise ValueError(\n                f\"Conflicting metadata requests for {', '.join(conflicts)} while\"\n                f\" composing the requests for {name}. Metadata with the same name\"\n                f\" for methods {', '.join(COMPOSITE_METHODS[name])} should have the\"\n                \" same request value.\"\n            )\n        requests.update(mmr._requests)\n    return MethodMetadataRequest(owner=self.owner, method=name, requests=requests)"
}