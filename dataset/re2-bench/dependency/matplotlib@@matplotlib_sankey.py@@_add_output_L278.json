{
    "matplotlib.lib.matplotlib.sankey._arc": "def _arc(self, quadrant=0, cw=True, radius=1, center=(0, 0)):\n    \"\"\"\n    Return the codes and vertices for a rotated, scaled, and translated\n    90 degree arc.\n\n    Other Parameters\n    ----------------\n    quadrant : {0, 1, 2, 3}, default: 0\n        Uses 0-based indexing (0, 1, 2, or 3).\n    cw : bool, default: True\n        If True, the arc vertices are produced clockwise; counter-clockwise\n        otherwise.\n    radius : float, default: 1\n        The radius of the arc.\n    center : (float, float), default: (0, 0)\n        (x, y) tuple of the arc's center.\n    \"\"\"\n    # Note:  It would be possible to use matplotlib's transforms to rotate,\n    # scale, and translate the arc, but since the angles are discrete,\n    # it's just as easy and maybe more efficient to do it here.\n    ARC_CODES = [Path.LINETO,\n                 Path.CURVE4,\n                 Path.CURVE4,\n                 Path.CURVE4,\n                 Path.CURVE4,\n                 Path.CURVE4,\n                 Path.CURVE4]\n    # Vertices of a cubic Bezier curve approximating a 90 deg arc\n    # These can be determined by Path.arc(0, 90).\n    ARC_VERTICES = np.array([[1.00000000e+00, 0.00000000e+00],\n                             [1.00000000e+00, 2.65114773e-01],\n                             [8.94571235e-01, 5.19642327e-01],\n                             [7.07106781e-01, 7.07106781e-01],\n                             [5.19642327e-01, 8.94571235e-01],\n                             [2.65114773e-01, 1.00000000e+00],\n                             # Insignificant\n                             # [6.12303177e-17, 1.00000000e+00]])\n                             [0.00000000e+00, 1.00000000e+00]])\n    if quadrant in (0, 2):\n        if cw:\n            vertices = ARC_VERTICES\n        else:\n            vertices = ARC_VERTICES[:, ::-1]  # Swap x and y.\n    else:  # 1, 3\n        # Negate x.\n        if cw:\n            # Swap x and y.\n            vertices = np.column_stack((-ARC_VERTICES[:, 1],\n                                         ARC_VERTICES[:, 0]))\n        else:\n            vertices = np.column_stack((-ARC_VERTICES[:, 0],\n                                         ARC_VERTICES[:, 1]))\n    if quadrant > 1:\n        radius = -radius  # Rotate 180 deg.\n    return list(zip(ARC_CODES, radius * vertices +\n                    np.tile(center, (ARC_VERTICES.shape[0], 1))))"
}