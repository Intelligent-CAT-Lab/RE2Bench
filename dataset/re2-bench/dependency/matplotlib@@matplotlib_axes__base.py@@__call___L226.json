{
    "matplotlib.lib.matplotlib.__init__._label_from_arg": "def _label_from_arg(y, default_name):\n    try:\n        return y.name\n    except AttributeError:\n        if isinstance(default_name, str):\n            return default_name\n    return None",
    "matplotlib.lib.matplotlib._api.__init__.kwarg_error": "def kwarg_error(name, kw):\n    \"\"\"\n    Generate a TypeError to be raised by function calls with wrong kwarg.\n\n    Parameters\n    ----------\n    name : str\n        The name of the calling function.\n    kw : str or Iterable[str]\n        Either the invalid keyword argument name, or an iterable yielding\n        invalid keyword arguments (e.g., a ``kwargs`` dict).\n    \"\"\"\n    if not isinstance(kw, str):\n        kw = next(iter(kw))\n    return TypeError(f\"{name}() got an unexpected keyword argument '{kw}'\")",
    "matplotlib.lib.matplotlib.axes._base._process_plot_format": "def _process_plot_format(fmt, *, ambiguous_fmt_datakey=False):\n    \"\"\"\n    Convert a MATLAB style color/line style format string to a (*linestyle*,\n    *marker*, *color*) tuple.\n\n    Example format strings include:\n\n    * 'ko': black circles\n    * '.b': blue dots\n    * 'r--': red dashed lines\n    * 'C2--': the third color in the color cycle, dashed lines\n\n    The format is absolute in the sense that if a linestyle or marker is not\n    defined in *fmt*, there is no line or marker. This is expressed by\n    returning 'None' for the respective quantity.\n\n    See Also\n    --------\n    matplotlib.Line2D.lineStyles, matplotlib.colors.cnames\n        All possible styles and color format strings.\n    \"\"\"\n\n    linestyle = None\n    marker = None\n    color = None\n\n    # First check whether fmt is just a colorspec, but specifically exclude the\n    # grayscale string \"1\" (not \"1.0\"), which is interpreted as the tri_down\n    # marker \"1\".  The grayscale string \"0\" could be unambiguously understood\n    # as a color (black) but also excluded for consistency.\n    if fmt not in [\"0\", \"1\"]:\n        try:\n            color = mcolors.to_rgba(fmt)\n            return linestyle, marker, color\n        except ValueError:\n            pass\n\n    errfmt = (\"{!r} is neither a data key nor a valid format string ({})\"\n              if ambiguous_fmt_datakey else\n              \"{!r} is not a valid format string ({})\")\n\n    i = 0\n    while i < len(fmt):\n        c = fmt[i]\n        if fmt[i:i+2] in mlines.lineStyles:  # First, the two-char styles.\n            if linestyle is not None:\n                raise ValueError(errfmt.format(fmt, \"two linestyle symbols\"))\n            linestyle = fmt[i:i+2]\n            i += 2\n        elif c in mlines.lineStyles:\n            if linestyle is not None:\n                raise ValueError(errfmt.format(fmt, \"two linestyle symbols\"))\n            linestyle = c\n            i += 1\n        elif c in mlines.lineMarkers:\n            if marker is not None:\n                raise ValueError(errfmt.format(fmt, \"two marker symbols\"))\n            marker = c\n            i += 1\n        elif c in mcolors.get_named_colors_mapping():\n            if color is not None:\n                raise ValueError(errfmt.format(fmt, \"two color symbols\"))\n            color = c\n            i += 1\n        elif c == \"C\":\n            cn_color = re.match(r\"C\\d+\", fmt[i:])\n            if not cn_color:\n                raise ValueError(errfmt.format(fmt, \"'C' must be followed by a number\"))\n            color = mcolors.to_rgba(cn_color[0])\n            i += len(cn_color[0])\n        else:\n            raise ValueError(errfmt.format(fmt, f\"unrecognized character {c!r}\"))\n\n    if linestyle is None and marker is None:\n        linestyle = mpl.rcParams['lines.linestyle']\n    if linestyle is None:\n        linestyle = 'None'\n    if marker is None:\n        marker = 'None'\n\n    return linestyle, marker, color",
    "matplotlib.lib.matplotlib.axes._base.<listcomp>": "replaced = [mpl._replacer(data, arg) for arg in args]\n",
    "matplotlib.lib.matplotlib.axes._base._process_unit_info": "def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):\n    \"\"\"\n    Set axis units based on *datasets* and *kwargs*, and optionally apply\n    unit conversions to *datasets*.\n\n    Parameters\n    ----------\n    datasets : list\n        List of (axis_name, dataset) pairs (where the axis name is defined\n        as in `._axis_map`).  Individual datasets can also be None\n        (which gets passed through).\n    kwargs : dict\n        Other parameters from which unit info (i.e., the *xunits*,\n        *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for\n        polar) entries) is popped, if present.  Note that this dict is\n        mutated in-place!\n    convert : bool, default: True\n        Whether to return the original datasets or the converted ones.\n\n    Returns\n    -------\n    list\n        Either the original datasets if *convert* is False, or the\n        converted ones if *convert* is True (the default).\n    \"\"\"\n    # The API makes datasets a list of pairs rather than an axis_name to\n    # dataset mapping because it is sometimes necessary to process multiple\n    # datasets for a single axis, and concatenating them may be tricky\n    # (e.g. if some are scalars, etc.).\n    datasets = datasets or []\n    kwargs = kwargs or {}\n    axis_map = self._axis_map\n    for axis_name, data in datasets:\n        try:\n            axis = axis_map[axis_name]\n        except KeyError:\n            raise ValueError(f\"Invalid axis name: {axis_name!r}\") from None\n        # Update from data if axis is already set but no unit is set yet.\n        if axis is not None and data is not None and not axis.have_units():\n            axis.update_units(data)\n    for axis_name, axis in axis_map.items():\n        # Return if no axis is set.\n        if axis is None:\n            continue\n        # Check for units in the kwargs, and if present update axis.\n        units = kwargs.pop(f\"{axis_name}units\", axis.units)\n        if self.name == \"polar\":\n            # Special case: polar supports \"thetaunits\"/\"runits\".\n            polar_units = {\"x\": \"thetaunits\", \"y\": \"runits\"}\n            units = kwargs.pop(polar_units[axis_name], units)\n        if units != axis.units and units is not None:\n            axis.set_units(units)\n            # If the units being set imply a different converter,\n            # we need to update again.\n            for dataset_axis_name, data in datasets:\n                if dataset_axis_name == axis_name and data is not None:\n                    axis.update_units(data)\n    return [axis_map[axis_name].convert_units(data)\n            if convert and data is not None else data\n            for axis_name, data in datasets]",
    "matplotlib.lib.matplotlib.axes._base._plot_args": "def _plot_args(self, axes, tup, kwargs, *,\n               return_kwargs=False, ambiguous_fmt_datakey=False):\n    \"\"\"\n    Process the arguments of ``plot([x], y, [fmt], **kwargs)`` calls.\n\n    This processes a single set of ([x], y, [fmt]) parameters; i.e. for\n    ``plot(x, y, x2, y2)`` it will be called twice. Once for (x, y) and\n    once for (x2, y2).\n\n    x and y may be 2D and thus can still represent multiple datasets.\n\n    For multiple datasets, if the keyword argument *label* is a list, this\n    will unpack the list and assign the individual labels to the datasets.\n\n    Parameters\n    ----------\n    tup : tuple\n        A tuple of the positional parameters. This can be one of\n\n        - (y,)\n        - (x, y)\n        - (y, fmt)\n        - (x, y, fmt)\n\n    kwargs : dict\n        The keyword arguments passed to ``plot()``.\n\n    return_kwargs : bool\n        Whether to also return the effective keyword arguments after label\n        unpacking as well.\n\n    ambiguous_fmt_datakey : bool\n        Whether the format string in *tup* could also have been a\n        misspelled data key.\n\n    Returns\n    -------\n    result\n        If *return_kwargs* is false, a list of Artists representing the\n        dataset(s).\n        If *return_kwargs* is true, a list of (Artist, effective_kwargs)\n        representing the dataset(s). See *return_kwargs*.\n        The Artist is either `.Line2D` (if called from ``plot()``) or\n        `.Polygon` otherwise.\n    \"\"\"\n    if len(tup) > 1 and isinstance(tup[-1], str):\n        # xy is tup with fmt stripped (could still be (y,) only)\n        *xy, fmt = tup\n        linestyle, marker, color = _process_plot_format(\n            fmt, ambiguous_fmt_datakey=ambiguous_fmt_datakey)\n    elif len(tup) == 3:\n        raise ValueError('third arg must be a format string')\n    else:\n        xy = tup\n        linestyle, marker, color = None, None, None\n\n    # Don't allow any None value; these would be up-converted to one\n    # element array of None which causes problems downstream.\n    if any(v is None for v in tup):\n        raise ValueError(\"x, y, and format string must not be None\")\n\n    kw = {}\n    for prop_name, val in zip(('linestyle', 'marker', 'color'),\n                              (linestyle, marker, color)):\n        if val is not None:\n            # check for conflicts between fmt and kwargs\n            if (fmt.lower() != 'none'\n                    and prop_name in kwargs\n                    and val != 'None'):\n                # Technically ``plot(x, y, 'o', ls='--')`` is a conflict\n                # because 'o' implicitly unsets the linestyle\n                # (linestyle='None').\n                # We'll gracefully not warn in this case because an\n                # explicit set via kwargs can be seen as intention to\n                # override an implicit unset.\n                # Note: We don't val.lower() != 'none' because val is not\n                # necessarily a string (can be a tuple for colors). This\n                # is safe, because *val* comes from _process_plot_format()\n                # which only returns 'None'.\n                _api.warn_external(\n                    f\"{prop_name} is redundantly defined by the \"\n                    f\"'{prop_name}' keyword argument and the fmt string \"\n                    f'\"{fmt}\" (-> {prop_name}={val!r}). The keyword '\n                    f\"argument will take precedence.\")\n            kw[prop_name] = val\n\n    if len(xy) == 2:\n        x = _check_1d(xy[0])\n        y = _check_1d(xy[1])\n    else:\n        x, y = index_of(xy[-1])\n\n    if axes.xaxis is not None:\n        axes.xaxis.update_units(x)\n    if axes.yaxis is not None:\n        axes.yaxis.update_units(y)\n\n    if x.shape[0] != y.shape[0]:\n        raise ValueError(f\"x and y must have same first dimension, but \"\n                         f\"have shapes {x.shape} and {y.shape}\")\n    if x.ndim > 2 or y.ndim > 2:\n        raise ValueError(f\"x and y can be no greater than 2D, but have \"\n                         f\"shapes {x.shape} and {y.shape}\")\n    if x.ndim == 1:\n        x = x[:, np.newaxis]\n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n\n    if self.output == 'Line2D':\n        make_artist = self._make_line\n    elif self.output == 'Polygon':\n        kw['closed'] = kwargs.get('closed', True)\n        make_artist = self._make_polygon\n    elif self.output == 'coordinates':\n        make_artist = self._make_coordinates\n    else:\n        _api.check_in_list(['Line2D', 'Polygon', 'coordinates'], output=self.output)\n\n    ncx, ncy = x.shape[1], y.shape[1]\n    if ncx > 1 and ncy > 1 and ncx != ncy:\n        raise ValueError(f\"x has {ncx} columns but y has {ncy} columns\")\n    if ncx == 0 or ncy == 0:\n        return []\n\n    label = kwargs.get('label')\n    n_datasets = max(ncx, ncy)\n\n    if cbook.is_scalar_or_string(label):\n        labels = [label] * n_datasets\n    elif len(label) == n_datasets:\n        labels = label\n    else:\n        raise ValueError(\n            f\"label must be scalar or have the same length as the input \"\n            f\"data, but found {len(label)} for {n_datasets} datasets.\")\n\n    result = (make_artist(axes, x[:, j % ncx], y[:, j % ncy], kw,\n                          {**kwargs, 'label': label})\n              for j, label in enumerate(labels))\n\n    if return_kwargs:\n        return list(result)\n    else:\n        return [l[0] for l in result]",
    "matplotlib.lib.matplotlib.cbook.is_scalar_or_string": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)"
}