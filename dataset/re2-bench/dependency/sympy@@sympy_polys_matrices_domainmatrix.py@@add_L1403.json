{
    "sympy.sympy.polys.matrices.ddm.add": "def add(a, b):\n    \"\"\"a + b\"\"\"\n    a._check(a, '+', b, a.shape, b.shape)\n    c = a.copy()\n    ddm_iadd(c, b)\n    return c",
    "sympy.sympy.polys.matrices.domainmatrix._check": "def _check(a, op, b, ashape, bshape):\n    if a.domain != b.domain:\n        msg = \"Domain mismatch: %s %s %s\" % (a.domain, op, b.domain)\n        raise DMDomainError(msg)\n    if ashape != bshape:\n        msg = \"Shape mismatch: %s %s %s\" % (a.shape, op, b.shape)\n        raise DMShapeError(msg)\n    if a.rep.fmt != b.rep.fmt:\n        msg = \"Format mismatch: %s %s %s\" % (a.rep.fmt, op, b.rep.fmt)\n        raise DMFormatError(msg)\n    if type(a.rep) != type(b.rep):\n        msg = \"Type mismatch: %s %s %s\" % (type(a.rep), op, type(b.rep))\n        raise DMFormatError(msg)",
    "sympy.sympy.polys.matrices.domainmatrix.from_rep": "@classmethod\ndef from_rep(cls, rep):\n    \"\"\"Create a new DomainMatrix efficiently from DDM/SDM.\n\n    Examples\n    ========\n\n    Create a :py:class:`~.DomainMatrix` with an dense internal\n    representation as :py:class:`~.DDM`:\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.ddm import DDM\n    >>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n    Create a :py:class:`~.DomainMatrix` with a sparse internal\n    representation as :py:class:`~.SDM`:\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import ZZ\n    >>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)\n\n    Parameters\n    ==========\n\n    rep: SDM or DDM\n        The internal sparse or dense representation of the matrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        A :py:class:`~.DomainMatrix` wrapping *rep*.\n\n    Notes\n    =====\n\n    This takes ownership of rep as its internal representation. If rep is\n    being mutated elsewhere then a copy should be provided to\n    ``from_rep``. Only minimal verification or checking is done on *rep*\n    as this is supposed to be an efficient internal routine.\n\n    \"\"\"\n    if not (isinstance(rep, (DDM, SDM)) or (DFM is not None and isinstance(rep, DFM))):\n        raise TypeError(\"rep should be of type DDM or SDM\")\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    "sympy.sympy.polys.matrices.sdm.add": "def add(A, B):\n    \"\"\"\n\n    Adds two :py:class:`~.SDM` matrices\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n    >>> B = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)\n    >>> A.add(B)\n    {0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}}\n\n    \"\"\"\n    Csdm = binop_dict(A, B, add, pos, pos)\n    return A.new(Csdm, A.shape, A.domain)"
}