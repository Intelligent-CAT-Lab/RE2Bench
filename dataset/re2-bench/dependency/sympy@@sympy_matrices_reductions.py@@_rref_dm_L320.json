{
    "sympy.sympy.polys.matrices.domainmatrix.__truediv__": "def __truediv__(A, lamda):\n    \"\"\" Method for Scalar Division\"\"\"\n    if isinstance(lamda, int) or ZZ.of_type(lamda):\n        lamda = DomainScalar(ZZ(lamda), ZZ)\n    elif A.domain.is_Field and lamda in A.domain:\n        K = A.domain\n        lamda = DomainScalar(K.convert(lamda), K)\n\n    if not isinstance(lamda, DomainScalar):\n        return NotImplemented\n\n    A, lamda = A.to_field().unify(lamda)\n    if lamda.element == lamda.domain.zero:\n        raise ZeroDivisionError\n    if lamda.element == lamda.domain.one:\n        return A\n\n    return A.mul(1 / lamda.element)",
    "sympy.sympy.polys.matrices.domainmatrix.rref": "def rref(self, *, method='auto'):\n    r\"\"\"\n    Returns reduced-row echelon form (RREF) and list of pivots.\n\n    If the domain is not a field then it will be converted to a field. See\n    :meth:`rref_den` for the fraction-free version of this routine that\n    returns RREF with denominator instead.\n\n    The domain must either be a field or have an associated fraction field\n    (see :meth:`to_field`).\n\n    Examples\n    ========\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...     [QQ(2), QQ(-1), QQ(0)],\n    ...     [QQ(-1), QQ(2), QQ(-1)],\n    ...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)\n\n    >>> rref_matrix, rref_pivots = A.rref()\n    >>> rref_matrix\n    DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)\n    >>> rref_pivots\n    (0, 1, 2)\n\n    Parameters\n    ==========\n\n    method : str, optional (default: 'auto')\n        The method to use to compute the RREF. The default is ``'auto'``,\n        which will attempt to choose the fastest method. The other options\n        are:\n\n        - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with\n          division. If the domain is not a field then it will be converted\n          to a field with :meth:`to_field` first and RREF will be computed\n          by inverting the pivot elements in each row. This is most\n          efficient for very sparse matrices or for matrices whose elements\n          have complex denominators.\n\n        - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan\n          elimination. Elimination is performed using exact division\n          (``exquo``) to control the growth of the coefficients. In this\n          case the current domain is always used for elimination but if\n          the domain is not a field then it will be converted to a field\n          at the end and divided by the denominator. This is most efficient\n          for dense matrices or for matrices with simple denominators.\n\n        - ``A.rref(method='CD')`` clears the denominators before using\n          fraction-free Gauss-Jordan elimination in the associated ring.\n          This is most efficient for dense matrices with very simple\n          denominators.\n\n        - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and\n          ``A.rref(method='CD_dense')`` are the same as the above methods\n          except that the dense implementations of the algorithms are used.\n          By default ``A.rref(method='auto')`` will usually choose the\n          sparse implementations for RREF.\n\n        Regardless of which algorithm is used the returned matrix will\n        always have the same format (sparse or dense) as the input and its\n        domain will always be the field of fractions of the input domain.\n\n    Returns\n    =======\n\n    (DomainMatrix, list)\n        reduced-row echelon form and list of pivots for the DomainMatrix\n\n    See Also\n    ========\n\n    rref_den\n        RREF with denominator\n    sympy.polys.matrices.sdm.sdm_irref\n        Sparse implementation of ``method='GJ'``.\n    sympy.polys.matrices.sdm.sdm_rref_den\n        Sparse implementation of ``method='FF'`` and ``method='CD'``.\n    sympy.polys.matrices.dense.ddm_irref\n        Dense implementation of ``method='GJ'``.\n    sympy.polys.matrices.dense.ddm_irref_den\n        Dense implementation of ``method='FF'`` and ``method='CD'``.\n    clear_denoms\n        Clear denominators from a matrix, used by ``method='CD'`` and\n        by ``method='GJ'`` when the original domain is not a field.\n\n    \"\"\"\n    return _dm_rref(self, method=method)",
    "sympy.sympy.polys.matrices.domainmatrix.rref_den": "def rref_den(self, *, method='auto', keep_domain=True):\n    r\"\"\"\n    Returns reduced-row echelon form with denominator and list of pivots.\n\n    Requires exact division in the ground domain (``exquo``).\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ, QQ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...     [ZZ(2), ZZ(-1), ZZ(0)],\n    ...     [ZZ(-1), ZZ(2), ZZ(-1)],\n    ...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)\n\n    >>> A_rref, denom, pivots = A.rref_den()\n    >>> A_rref\n    DomainMatrix([[6, 0, 0], [0, 6, 0], [0, 0, 6]], (3, 3), ZZ)\n    >>> denom\n    6\n    >>> pivots\n    (0, 1, 2)\n    >>> A_rref.to_field() / denom\n    DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)\n    >>> A_rref.to_field() / denom == A.convert_to(QQ).rref()[0]\n    True\n\n    Parameters\n    ==========\n\n    method : str, optional (default: 'auto')\n        The method to use to compute the RREF. The default is ``'auto'``,\n        which will attempt to choose the fastest method. The other options\n        are:\n\n        - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan\n          elimination. Elimination is performed using exact division\n          (``exquo``) to control the growth of the coefficients. In this\n          case the current domain is always used for elimination and the\n          result is always returned as a matrix over the current domain.\n          This is most efficient for dense matrices or for matrices with\n          simple denominators.\n\n        - ``A.rref(method='CD')`` clears denominators before using\n          fraction-free Gauss-Jordan elimination in the associated ring.\n          The result will be converted back to the original domain unless\n          ``keep_domain=False`` is passed in which case the result will be\n          over the ring used for elimination. This is most efficient for\n          dense matrices with very simple denominators.\n\n        - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with\n          division. If the domain is not a field then it will be converted\n          to a field with :meth:`to_field` first and RREF will be computed\n          by inverting the pivot elements in each row. The result is\n          converted back to the original domain by clearing denominators\n          unless ``keep_domain=False`` is passed in which case the result\n          will be over the field used for elimination. This is most\n          efficient for very sparse matrices or for matrices whose elements\n          have complex denominators.\n\n        - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and\n          ``A.rref(method='CD_dense')`` are the same as the above methods\n          except that the dense implementations of the algorithms are used.\n          By default ``A.rref(method='auto')`` will usually choose the\n          sparse implementations for RREF.\n\n        Regardless of which algorithm is used the returned matrix will\n        always have the same format (sparse or dense) as the input and if\n        ``keep_domain=True`` its domain will always be the same as the\n        input.\n\n    keep_domain : bool, optional\n        If True (the default), the domain of the returned matrix and\n        denominator are the same as the domain of the input matrix. If\n        False, the domain of the returned matrix might be changed to an\n        associated ring or field if the algorithm used a different domain.\n        This is useful for efficiency if the caller does not need the\n        result to be in the original domain e.g. it avoids clearing\n        denominators in the case of ``A.rref(method='GJ')``.\n\n    Returns\n    =======\n\n    (DomainMatrix, scalar, list)\n        Reduced-row echelon form, denominator and list of pivot indices.\n\n    See Also\n    ========\n\n    rref\n        RREF without denominator for field domains.\n    sympy.polys.matrices.sdm.sdm_irref\n        Sparse implementation of ``method='GJ'``.\n    sympy.polys.matrices.sdm.sdm_rref_den\n        Sparse implementation of ``method='FF'`` and ``method='CD'``.\n    sympy.polys.matrices.dense.ddm_irref\n        Dense implementation of ``method='GJ'``.\n    sympy.polys.matrices.dense.ddm_irref_den\n        Dense implementation of ``method='FF'`` and ``method='CD'``.\n    clear_denoms\n        Clear denominators from a matrix, used by ``method='CD'``.\n\n    \"\"\"\n    return _dm_rref_den(self, method=method, keep_domain=keep_domain)",
    "sympy.sympy.polys.matrices.domainmatrix.to_field": "def to_field(self):\n    r\"\"\"\n    Returns a DomainMatrix with the appropriate field\n\n    Returns\n    =======\n\n    DomainMatrix\n        DomainMatrix with the appropriate field\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n    >>> A.to_field()\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)\n\n    \"\"\"\n    K = self.domain.get_field()\n    return self.convert_to(K)",
    "sympy.sympy.polys.matrices.domainmatrix.to_Matrix": "def to_Matrix(self):\n    r\"\"\"\n    Convert DomainMatrix to Matrix\n\n    Returns\n    =======\n\n    Matrix\n        MutableDenseMatrix for the DomainMatrix\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n    >>> A.to_Matrix()\n    Matrix([\n        [1, 2],\n        [3, 4]])\n\n    See Also\n    ========\n\n    from_Matrix\n\n    \"\"\"\n    from sympy.matrices.dense import MutableDenseMatrix\n\n    # XXX: If the internal representation of RepMatrix changes then this\n    # might need to be changed also.\n    if self.domain in (ZZ, QQ, EXRAW):\n        if self.rep.fmt == \"sparse\":\n            rep = self.copy()\n        else:\n            rep = self.to_sparse()\n    else:\n        rep = self.convert_to(EXRAW).to_sparse()\n\n    return MutableDenseMatrix._fromrep(rep)"
}