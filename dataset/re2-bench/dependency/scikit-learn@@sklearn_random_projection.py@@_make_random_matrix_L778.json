{
    "scikit-learn.sklearn.random_projection._check_density": "def _check_density(density, n_features):\n    \"\"\"Factorize density check according to Li et al.\"\"\"\n    if density == \"auto\":\n        density = 1 / np.sqrt(n_features)\n\n    elif density <= 0 or density > 1:\n        raise ValueError(\"Expected density in range ]0, 1], got: %r\" % density)\n    return density",
    "scikit-learn.sklearn.random_projection._sparse_random_matrix": "def _sparse_random_matrix(n_components, n_features, density=\"auto\", random_state=None):\n    \"\"\"Generalized Achlioptas random sparse matrix for random projection.\n\n    Setting density to 1 / 3 will yield the original matrix by Dimitris\n    Achlioptas while setting a lower value will yield the generalization\n    by Ping Li et al.\n\n    If we note :math:`s = 1 / density`, the components of the random matrix are\n    drawn from:\n\n      - -sqrt(s) / sqrt(n_components)   with probability 1 / 2s\n      -  0                              with probability 1 - 1 / s\n      - +sqrt(s) / sqrt(n_components)   with probability 1 / 2s\n\n    Read more in the :ref:`User Guide <sparse_random_matrix>`.\n\n    Parameters\n    ----------\n    n_components : int,\n        Dimensionality of the target projection space.\n\n    n_features : int,\n        Dimensionality of the original source space.\n\n    density : float or 'auto', default='auto'\n        Ratio of non-zero component in the random projection matrix in the\n        range `(0, 1]`\n\n        If density = 'auto', the value is set to the minimum density\n        as recommended by Ping Li et al.: 1 / sqrt(n_features).\n\n        Use density = 1 / 3.0 if you want to reproduce the results from\n        Achlioptas, 2001.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the pseudo random number generator used to generate the matrix\n        at fit time.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Returns\n    -------\n    components : {ndarray, sparse matrix} of shape (n_components, n_features)\n        The generated Gaussian random matrix. Sparse matrix will be of CSR\n        format.\n\n    See Also\n    --------\n    SparseRandomProjection\n\n    References\n    ----------\n\n    .. [1] Ping Li, T. Hastie and K. W. Church, 2006,\n           \"Very Sparse Random Projections\".\n           https://web.stanford.edu/~hastie/Papers/Ping/KDD06_rp.pdf\n\n    .. [2] D. Achlioptas, 2001, \"Database-friendly random projections\",\n           https://cgi.di.uoa.gr/~optas/papers/jl.pdf\n\n    \"\"\"\n    _check_input_size(n_components, n_features)\n    density = _check_density(density, n_features)\n    rng = check_random_state(random_state)\n\n    if density == 1:\n        # skip index generation if totally dense\n        components = rng.binomial(1, 0.5, (n_components, n_features)) * 2 - 1\n        return 1 / np.sqrt(n_components) * components\n\n    else:\n        # Generate location of non zero elements\n        indices = []\n        offset = 0\n        indptr = [offset]\n        for _ in range(n_components):\n            # find the indices of the non-zero components for row i\n            n_nonzero_i = rng.binomial(n_features, density)\n            indices_i = sample_without_replacement(\n                n_features, n_nonzero_i, random_state=rng\n            )\n            indices.append(indices_i)\n            offset += n_nonzero_i\n            indptr.append(offset)\n\n        indices = np.concatenate(indices)\n\n        # Among non zero components the probability of the sign is 50%/50%\n        data = rng.binomial(1, 0.5, size=np.size(indices)) * 2 - 1\n\n        # build the CSR structure by concatenating the rows\n        components = sp.csr_matrix(\n            (data, indices, indptr), shape=(n_components, n_features)\n        )\n\n        return np.sqrt(1 / density) / np.sqrt(n_components) * components",
    "scikit-learn.sklearn.utils.validation.check_random_state": "def check_random_state(seed):\n    \"\"\"Turn seed into an np.random.RandomState instance.\n\n    Parameters\n    ----------\n    seed : None, int or instance of RandomState\n        If seed is None, return the RandomState singleton used by np.random.\n        If seed is an int, return a new RandomState instance seeded with seed.\n        If seed is already a RandomState instance, return it.\n        Otherwise raise ValueError.\n\n    Returns\n    -------\n    :class:`numpy:numpy.random.RandomState`\n        The random state object based on `seed` parameter.\n\n    Examples\n    --------\n    >>> from sklearn.utils.validation import check_random_state\n    >>> check_random_state(42)\n    RandomState(MT19937) at 0x...\n    \"\"\"\n    if seed is None or seed is np.random:\n        return np.random.mtrand._rand\n    if isinstance(seed, numbers.Integral):\n        return np.random.RandomState(seed)\n    if isinstance(seed, np.random.RandomState):\n        return seed\n    raise ValueError(\n        \"%r cannot be used to seed a numpy.random.RandomState instance\" % seed\n    )"
}