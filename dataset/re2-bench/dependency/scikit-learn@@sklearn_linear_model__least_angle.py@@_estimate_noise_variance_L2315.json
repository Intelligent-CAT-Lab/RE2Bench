{
    "scikit-learn.sklearn.base.wrapper": "@functools.wraps(fit_method)\ndef wrapper(estimator, *args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n\n    # we don't want to validate again for each call to partial_fit\n    partial_fit_and_fitted = (\n        fit_method.__name__ == \"partial_fit\" and _is_fitted(estimator)\n    )\n\n    if not global_skip_validation and not partial_fit_and_fitted:\n        estimator._validate_params()\n\n    with config_context(\n        skip_parameter_validation=(\n            prefer_skip_nested_validation or global_skip_validation\n        )\n    ):\n        return fit_method(estimator, *args, **kwargs)",
    "scikit-learn.sklearn.linear_model._base.predict": "def predict(self, X):\n    \"\"\"\n    Predict using the linear model.\n\n    Parameters\n    ----------\n    X : array-like or sparse matrix, shape (n_samples, n_features)\n        Samples.\n\n    Returns\n    -------\n    C : array, shape (n_samples,)\n        Returns predicted values.\n    \"\"\"\n    return self._decision_function(X)",
    "scikit-learn.sklearn.linear_model._base.__init__": "def __init__(\n    self,\n    *,\n    fit_intercept=True,\n    copy_X=True,\n    tol=1e-6,\n    n_jobs=None,\n    positive=False,\n):\n    self.fit_intercept = fit_intercept\n    self.copy_X = copy_X\n    self.tol = tol\n    self.n_jobs = n_jobs\n    self.positive = positive"
}