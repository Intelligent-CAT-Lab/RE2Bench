{
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.printing.pretty.pretty.<lambda>": "parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))\n\n",
    "sympy.sympy.printing.pretty.stringpict.parens": "def parens(self, left='(', right=')', ifascii_nougly=False):\n    \"\"\"Put parentheses around self.\n    Returns string, baseline arguments for stringPict.\n\n    left or right can be None or empty string which means 'no paren from\n    that side'\n    \"\"\"\n    h = self.height()\n    b = self.baseline\n\n    # XXX this is a hack -- ascii parens are ugly!\n    if ifascii_nougly and not pretty_use_unicode():\n        h = 1\n        b = 0\n\n    res = self\n\n    if left:\n        lparen = stringPict(vobj(left, h), baseline=b)\n        res = stringPict(*lparen.right(self))\n    if right:\n        rparen = stringPict(vobj(right, h), baseline=b)\n        res = stringPict(*res.right(rparen))\n\n    return ('\\n'.join(res.picture), res.baseline)",
    "sympy.sympy.printing.pretty.stringpict.__init__": "def __init__(self, s, baseline=0, binding=0, unicode=None):\n    \"\"\"Initialize from stringPict and binding power.\"\"\"\n    stringPict.__init__(self, s, baseline)\n    self.binding = binding\n    if unicode is not None:\n        sympy_deprecation_warning(\n            \"\"\"\n            The unicode argument to prettyForm is deprecated. Only the s\n            argument (the first positional argument) should be passed.\n            \"\"\",\n            deprecated_since_version=\"1.7\",\n            active_deprecations_target=\"deprecated-pretty-printing-functions\")\n    self._unicode = unicode or s",
    "sympy.sympy.printing.pretty.stringpict.__getitem__": "def __getitem__(self, index):\n    return self.picture[index]",
    "sympy.sympy.printing.pretty.stringpict.next": "@staticmethod\ndef next(*args):\n    \"\"\"Put a string of stringPicts next to each other.\n    Returns string, baseline arguments for stringPict.\n    \"\"\"\n    #convert everything to stringPicts\n    objects = []\n    for arg in args:\n        if isinstance(arg, str):\n            arg = stringPict(arg)\n        objects.append(arg)\n\n    #make a list of pictures, with equal height and baseline\n    newBaseline = max(obj.baseline for obj in objects)\n    newHeightBelowBaseline = max(\n        obj.height() - obj.baseline\n        for obj in objects)\n    newHeight = newBaseline + newHeightBelowBaseline\n\n    pictures = []\n    for obj in objects:\n        oneEmptyLine = [' '*obj.width()]\n        basePadding = newBaseline - obj.baseline\n        totalPadding = newHeight - obj.height()\n        pictures.append(\n            oneEmptyLine * basePadding +\n            obj.picture +\n            oneEmptyLine * (totalPadding - basePadding))\n\n    result = [''.join(lines) for lines in zip(*pictures)]\n    return '\\n'.join(result), newBaseline",
    "sympy.sympy.printing.printer._print": "def _print(self, expr, **kwargs) -> str:\n    \"\"\"Internal dispatcher\n\n    Tries the following concepts to print an expression:\n        1. Let the object print itself if it knows how.\n        2. Take the best fitting method defined in the printer.\n        3. As fall-back use the emptyPrinter method for the printer.\n    \"\"\"\n    self._print_level += 1\n    try:\n        # If the printer defines a name for a printing method\n        # (Printer.printmethod) and the object knows for itself how it\n        # should be printed, use that method.\n        if self.printmethod and hasattr(expr, self.printmethod):\n            if not (isinstance(expr, type) and issubclass(expr, Basic)):\n                return getattr(expr, self.printmethod)(self, **kwargs)\n\n        # See if the class of expr is known, or if one of its super\n        # classes is known, and use that print function\n        # Exception: ignore the subclasses of Undefined, so that, e.g.,\n        # Function('gamma') does not get dispatched to _print_gamma\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        # Another exception: if someone subclasses a known function, e.g.,\n        # gamma, and changes the name, then ignore _print_gamma\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple(c for c in classes[:i] if \\\n                c.__name__ == classes[0].__name__ or \\\n                c.__name__.endswith(\"Base\")) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        # Unknown object, fall back to the emptyPrinter.\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1"
}