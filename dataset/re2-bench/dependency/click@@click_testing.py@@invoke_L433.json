{
    "click.src.click.core.main": "def main(\n    self,\n    args: cabc.Sequence[str] | None = None,\n    prog_name: str | None = None,\n    complete_var: str | None = None,\n    standalone_mode: bool = True,\n    windows_expand_args: bool = True,\n    **extra: t.Any,\n) -> t.Any:\n    \"\"\"This is the way to invoke a script with all the bells and\n    whistles as a command line application.  This will always terminate\n    the application after a call.  If this is not wanted, ``SystemExit``\n    needs to be caught.\n\n    This method is also available by directly calling the instance of\n    a :class:`Command`.\n\n    :param args: the arguments that should be used for parsing.  If not\n                 provided, ``sys.argv[1:]`` is used.\n    :param prog_name: the program name that should be used.  By default\n                      the program name is constructed by taking the file\n                      name from ``sys.argv[0]``.\n    :param complete_var: the environment variable that controls the\n                         bash completion support.  The default is\n                         ``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                         uppercase.\n    :param standalone_mode: the default behavior is to invoke the script\n                            in standalone mode.  Click will then\n                            handle exceptions and convert them into\n                            error messages and the function will never\n                            return but shut down the interpreter.  If\n                            this is set to `False` they will be\n                            propagated to the caller and the return\n                            value of this function is the return value\n                            of :meth:`invoke`.\n    :param windows_expand_args: Expand glob patterns, user dir, and\n        env vars in command line args on Windows.\n    :param extra: extra keyword arguments are forwarded to the context\n                  constructor.  See :class:`Context` for more information.\n\n    .. versionchanged:: 8.0.1\n        Added the ``windows_expand_args`` parameter to allow\n        disabling command line arg expansion on Windows.\n\n    .. versionchanged:: 8.0\n        When taking arguments from ``sys.argv`` on Windows, glob\n        patterns, user dir, and env vars are expanded.\n\n    .. versionchanged:: 3.0\n       Added the ``standalone_mode`` parameter.\n    \"\"\"\n    if args is None:\n        args = sys.argv[1:]\n\n        if os.name == \"nt\" and windows_expand_args:\n            args = _expand_args(args)\n    else:\n        args = list(args)\n\n    if prog_name is None:\n        prog_name = _detect_program_name()\n\n    # Process shell completion requests and exit early.\n    self._main_shell_completion(extra, prog_name, complete_var)\n\n    try:\n        try:\n            with self.make_context(prog_name, args, **extra) as ctx:\n                rv = self.invoke(ctx)\n                if not standalone_mode:\n                    return rv\n                # it's not safe to `ctx.exit(rv)` here!\n                # note that `rv` may actually contain data like \"1\" which\n                # has obvious effects\n                # more subtle case: `rv=[None, None]` can come out of\n                # chained commands which all returned `None` -- so it's not\n                # even always obvious that `rv` indicates success/failure\n                # by its truthiness/falsiness\n                ctx.exit()\n        except (EOFError, KeyboardInterrupt) as e:\n            echo(file=sys.stderr)\n            raise Abort() from e\n        except ClickException as e:\n            if not standalone_mode:\n                raise\n            e.show()\n            sys.exit(e.exit_code)\n        except OSError as e:\n            if e.errno == errno.EPIPE:\n                sys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))\n                sys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))\n                sys.exit(1)\n            else:\n                raise\n    except Exit as e:\n        if standalone_mode:\n            sys.exit(e.exit_code)\n        else:\n            # in non-standalone mode, return the exit code\n            # note that this is only reached if `self.invoke` above raises\n            # an Exit explicitly -- thus bypassing the check there which\n            # would return its result\n            # the results of non-standalone execution may therefore be\n            # somewhat ambiguous: if there are codepaths which lead to\n            # `ctx.exit(1)` and to `return 1`, the caller won't be able to\n            # tell the difference between the two\n            return e.exit_code\n    except Abort:\n        if not standalone_mode:\n            raise\n        echo(_(\"Aborted!\"), file=sys.stderr)\n        sys.exit(1)",
    "click.src.click.testing.__init__": "def __init__(\n    self,\n    runner: CliRunner,\n    stdout_bytes: bytes,\n    stderr_bytes: bytes,\n    output_bytes: bytes,\n    return_value: t.Any,\n    exit_code: int,\n    exception: BaseException | None,\n    exc_info: tuple[type[BaseException], BaseException, TracebackType]\n    | None = None,\n):\n    self.runner = runner\n    self.stdout_bytes = stdout_bytes\n    self.stderr_bytes = stderr_bytes\n    self.output_bytes = output_bytes\n    self.return_value = return_value\n    self.exit_code = exit_code\n    self.exception = exception\n    self.exc_info = exc_info",
    "click.src.click.testing.get_default_prog_name": "def get_default_prog_name(self, cli: Command) -> str:\n    \"\"\"Given a command object it will return the default program name\n    for it.  The default is the `name` attribute or ``\"root\"`` if not\n    set.\n    \"\"\"\n    return cli.name or \"root\"",
    "click.src.click.testing.flush": "def flush(self) -> None:\n    super().flush()\n    self.copy_to.flush()",
    "click.src.click.testing.write": "def write(self, b: ReadableBuffer) -> int:\n    self.copy_to.write(b)\n    return super().write(b)"
}