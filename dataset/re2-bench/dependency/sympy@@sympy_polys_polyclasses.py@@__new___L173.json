{
    "sympy.sympy.polys.densebasic.dmp_validate": "def dmp_validate(\n    f: dmp[Er], K: Domain[Er] | None = None, *, strict: bool = False\n) -> tuple[dmp[Er], int]:\n    \"\"\"\n    Return the number of levels in ``f`` and recursively strip it.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dmp_validate\n\n    >>> dmp_validate([[], [ZZ(0), ZZ(1), ZZ(2)], [ZZ(1)]], ZZ)\n    ([[1, 2], [1]], 1)\n\n    >>> dmp_validate([[ZZ(1)], ZZ(1)], ZZ)\n    Traceback (most recent call last):\n    ...\n    ValueError: invalid data structure for a multivariate polynomial\n\n    >>> dmp_validate([['invalid'], [1]], ZZ, strict=True)\n    Traceback (most recent call last):\n    ...\n    TypeError: 1 in [1] is not of type ZZ\n\n    \"\"\"\n    levels = _rec_validate(f, f, 0, K, strict)\n\n    u = levels.pop()\n\n    if not levels:\n        return _rec_strip(f, u, K), u\n    else:\n        raise ValueError(\"invalid data structure for a multivariate polynomial\")",
    "sympy.sympy.polys.polyclasses.new": "@classmethod\ndef new(cls, rep: dmp[Er], dom: Domain[Er], lev: int) -> DMP_Python[Er] | DUP_Flint[Er]:\n    # It would be too slow to call _validate_args always at runtime.\n    # Ideally this checking would be handled by a static type checker.\n    #\n    #cls._validate_args(rep, dom, lev)\n    if flint is not None:\n        if lev == 0 and _supported_flint_domain(dom):\n            return DUP_Flint._new(rep, dom, lev)\n\n    return DMP_Python._new(rep, dom, lev)"
}