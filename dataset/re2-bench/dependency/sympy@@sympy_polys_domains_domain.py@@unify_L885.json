{
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.sorting.ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    \"\"\"Return an iterator of the seq where keys are used to break ties\n    in a conservative fashion: if, after applying a key, there are no\n    ties then no other keys will be computed.\n\n    Two default keys will be applied if 1) keys are not provided or\n    2) the given keys do not resolve all ties (but only if ``default``\n    is True). The two keys are ``_nodes`` (which places smaller\n    expressions before large) and ``default_sort_key`` which (if the\n    ``sort_key`` for an object is defined properly) should resolve\n    any ties. This strategy is similar to sorting done by\n    ``Basic.compare``, but differs in that ``ordered`` never makes a\n    decision based on an objects name.\n\n    If ``warn`` is True then an error will be raised if there were no\n    keys remaining to break ties. This can be used if it was expected that\n    there should be no ties between items that are not identical.\n\n    Examples\n    ========\n\n    >>> from sympy import ordered, count_ops\n    >>> from sympy.abc import x, y\n\n    The count_ops is not sufficient to break ties in this list and the first\n    two items appear in their original order (i.e. the sorting is stable):\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n    ...    count_ops, default=False, warn=False))\n    ...\n    [y + 2, x + 2, x**2 + y + 3]\n\n    The default_sort_key allows the tie to be broken:\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n    ...\n    [x + 2, y + 2, x**2 + y + 3]\n\n    Here, sequences are sorted by length, then sum:\n\n    >>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n    ...    lambda x: len(x),\n    ...    lambda x: sum(x)]]\n    ...\n    >>> list(ordered(seq, keys, default=False, warn=False))\n    [[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]\n\n    If ``warn`` is True, an error will be raised if there were not\n    enough keys to break ties:\n\n    >>> list(ordered(seq, keys, default=False, warn=True))\n    Traceback (most recent call last):\n    ...\n    ValueError: not enough keys to break ties\n\n\n    Notes\n    =====\n\n    The decorated sort is one of the fastest ways to sort a sequence for\n    which special item comparison is desired: the sequence is decorated,\n    sorted on the basis of the decoration (e.g. making all letters lower\n    case) and then undecorated. If one wants to break ties for items that\n    have the same decorated value, a second key can be used. But if the\n    second key is expensive to compute then it is inefficient to decorate\n    all items with both keys: only those items having identical first key\n    values need to be decorated. This function applies keys successively\n    only when needed to break ties. By yielding an iterator, use of the\n    tie-breaker is delayed as long as possible.\n\n    This function is best used in cases when use of the first key is\n    expected to be a good hashing function; if there are no unique hashes\n    from application of a key, then that key should not have been used. The\n    exception, however, is that even if there are many collisions, if the\n    first group is small and one does not need to process all items in the\n    list then time will not be wasted sorting what one was not interested\n    in. For example, if one were looking for the minimum in a list and\n    there were several criteria used to define the sort order, then this\n    function would be good at returning that quickly if the first group\n    of candidates is small relative to the number of items being processed.\n\n    \"\"\"\n\n    d = defaultdict(list)\n    if keys:\n        if isinstance(keys, (list, tuple)):\n            keys = list(keys)\n            f = keys.pop(0)\n        else:\n            f = keys\n            keys = []\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n\n    for k, value in sorted(d.items()):\n        if len(value) > 1:\n            if keys:\n                value = ordered(value, keys, default, warn)\n            elif default:\n                value = ordered(value, (_nodes, default_sort_key,),\n                               default=False, warn=warn)\n            elif warn:\n                u = list(uniq(value))\n                if len(u) > 1:\n                    raise ValueError(\n                        'not enough keys to break ties: %s' % u)\n        yield from value",
    "sympy.sympy.polys.agca.extensions.__eq__": "def __eq__(self, other):\n    if not isinstance(other, FiniteExtension):\n        return False\n    return self.modulus == other.modulus",
    "sympy.sympy.polys.agca.extensions.has_CharacteristicZero": "@property\ndef has_CharacteristicZero(self):\n    return self.domain.has_CharacteristicZero",
    "sympy.sympy.polys.agca.extensions.set_domain": "def set_domain(self, K):\n    mod = self.modulus.set_domain(K)\n    return self.__class__(mod)",
    "sympy.sympy.polys.domains.algebraicfield.__init__": "def __init__(self, dom: Domain[MPQ], *ext: Expr, alias: str | None = None) -> None:\n    r\"\"\"\n    Parameters\n    ==========\n\n    dom : :py:class:`~.Domain`\n        The base field over which this is an extension field.\n        Currently only :ref:`QQ` is accepted.\n\n    *ext : One or more :py:class:`~.Expr`\n        Generators of the extension. These should be expressions that are\n        algebraic over `\\mathbb{Q}`.\n\n    alias : str, :py:class:`~.Symbol`, None, optional (default=None)\n        If provided, this will be used as the alias symbol for the\n        primitive element of the :py:class:`~.AlgebraicField`.\n        If ``None``, while ``ext`` consists of exactly one\n        :py:class:`~.AlgebraicNumber`, its alias (if any) will be used.\n    \"\"\"\n    if not dom.is_QQ:\n        raise DomainError(\"ground domain must be a rational field\")\n\n    from sympy.polys.numberfields import to_number_field\n    if len(ext) == 1 and isinstance(ext[0], tuple):\n        orig_ext = ext[0][1:]\n    else:\n        orig_ext = ext\n\n    if alias is None and len(ext) == 1:\n        alias = getattr(ext[0], 'alias', None)\n\n    self.orig_ext = orig_ext\n    \"\"\"\n    Original elements given to generate the extension.\n\n    >>> from sympy import QQ, sqrt\n    >>> K = QQ.algebraic_field(sqrt(2), sqrt(3))\n    >>> K.orig_ext\n    (sqrt(2), sqrt(3))\n    \"\"\"\n\n    self.ext = to_number_field(ext, alias=alias)\n    \"\"\"\n    Primitive element used for the extension.\n\n    >>> from sympy import QQ, sqrt\n    >>> K = QQ.algebraic_field(sqrt(2), sqrt(3))\n    >>> K.ext\n    sqrt(2) + sqrt(3)\n    \"\"\"\n\n    self.mod = self.ext.minpoly.rep\n    \"\"\"\n    Minimal polynomial for the primitive element of the extension.\n\n    >>> from sympy import QQ, sqrt\n    >>> K = QQ.algebraic_field(sqrt(2))\n    >>> K.mod\n    DMP([1, 0, -2], QQ)\n    \"\"\"\n\n    self.domain = self.dom = dom\n\n    self.ngens = 1\n    self.symbols = self.gens = (self.ext,)\n    self.unit = self([dom(1), dom(0)])\n\n    self.zero = self.dtype.zero(self.mod.to_list(), dom)\n    self.one = self.dtype.one(self.mod.to_list(), dom)\n\n    self._maximal_order = None\n    self._discriminant = None\n    self._nilradicals_mod_p: dict = {}",
    "sympy.sympy.polys.domains.algebraicfield.__str__": "def __str__(self):\n    return str(self.dom) + '<' + str(self.ext) + '>'",
    "sympy.sympy.polys.domains.algebraicfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, AlgebraicField):\n        return self.dtype == other.dtype and self.ext == other.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.characteristiczero.characteristic": "def characteristic(self):\n    \"\"\"Return the characteristic of this domain. \"\"\"\n    return 0",
    "sympy.sympy.polys.domains.complexfield.precision": "@property\ndef precision(self):\n    return self._context.prec",
    "sympy.sympy.polys.domains.complexfield.__init__": "def __init__(self, prec=None, dps=None, tol=None):\n    # XXX: The tolerance parameter is ignored but is kept for backward\n    # compatibility for now.\n\n    context = MPContext()\n\n    if prec is None and dps is None:\n        context.prec = self._default_precision\n    elif dps is None:\n        context.prec = prec\n    elif prec is None:\n        context.dps = dps\n    else:\n        raise TypeError(\"Cannot set both prec and dps\")\n\n    self._context = context\n\n    self._dtype = context.mpc\n    self.zero = self.dtype(0)\n    self.one = self.dtype(1)\n\n    # XXX: Neither of these is actually used anywhere.\n    self._max_denom = max(2**context.prec // 200, 99)\n    self._tolerance = self.one / self._max_denom",
    "sympy.sympy.polys.domains.complexfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, ComplexField) and self.precision == other.precision",
    "sympy.sympy.polys.domains.compositedomain.drop": "def drop(self, *symbols):\n    \"\"\"Drop generators from this domain. \"\"\"\n    symset = set(symbols)\n    newsyms = tuple(s for s in self.symbols if s not in symset)\n    domain = self.domain.drop(*symbols)\n    if not newsyms:\n        return domain\n    else:\n        return self.__class__(domain, newsyms, self.order)",
    "sympy.sympy.polys.domains.compositedomain.has_CharacteristicZero": "@property\ndef has_CharacteristicZero(self):\n    return self.domain.has_CharacteristicZero",
    "sympy.sympy.polys.domains.compositedomain.characteristic": "def characteristic(self):\n    return self.domain.characteristic()",
    "sympy.sympy.polys.domains.domain.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    # XXX: Remove this.\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    "sympy.sympy.polys.domains.domain.drop": "def drop(self, *symbols: Expr | str) -> Domain:\n    \"\"\"Drop generators from this domain. \"\"\"\n    if self.is_Simple:\n        return self\n    raise NotImplementedError  # pragma: no cover",
    "sympy.sympy.polys.domains.domain.__str__": "def __str__(self) -> str:\n    return self.rep",
    "sympy.sympy.polys.domains.domain.unify_with_symbols": "def unify_with_symbols(K0, K1, symbols):\n    if (K0.is_Composite and (set(K0.symbols) & set(symbols))) or (K1.is_Composite and (set(K1.symbols) & set(symbols))):\n        raise UnificationFailed(\"Cannot unify %s with %s, given %s generators\" % (K0, K1, tuple(symbols)))\n\n    return K0.unify(K1)",
    "sympy.sympy.polys.domains.domain.unify_composite": "def unify_composite(K0, K1):\n    \"\"\"Unify two domains where at least one is composite.\"\"\"\n    K0_ground = K0.dom if K0.is_Composite else K0\n    K1_ground = K1.dom if K1.is_Composite else K1\n\n    K0_symbols = K0.symbols if K0.is_Composite else ()\n    K1_symbols = K1.symbols if K1.is_Composite else ()\n\n    domain = K0_ground.unify(K1_ground)\n    symbols = _unify_gens(K0_symbols, K1_symbols)\n    order = K0.order if K0.is_Composite else K1.order\n\n    # E.g. ZZ[x].unify(QQ.frac_field(x)) -> ZZ.frac_field(x)\n    if ((K0.is_FractionField and K1.is_PolynomialRing or\n         K1.is_FractionField and K0.is_PolynomialRing) and\n         (not K0_ground.is_Field or not K1_ground.is_Field) and domain.is_Field\n         and domain.has_assoc_Ring):\n        domain = domain.get_ring()\n\n    if K0.is_Composite and (not K1.is_Composite or K0.is_FractionField or K1.is_PolynomialRing):\n        cls = K0.__class__\n    else:\n        cls = K1.__class__\n\n    # Here cls might be PolynomialRing, FractionField, GlobalPolynomialRing\n    # (dense/old Polynomialring) or dense/old FractionField.\n\n    from sympy.polys.domains.old_polynomialring import GlobalPolynomialRing\n    if cls == GlobalPolynomialRing:\n        return cls(domain, symbols)\n\n    return cls(domain, symbols, order)",
    "sympy.sympy.polys.domains.domain.unify": "def unify(K0, K1, symbols=None):\n    \"\"\"\n    Construct a minimal domain that contains elements of ``K0`` and ``K1``.\n\n    Known domains (from smallest to largest):\n\n    - ``GF(p)``\n    - ``ZZ``\n    - ``QQ``\n    - ``RR(prec, tol)``\n    - ``CC(prec, tol)``\n    - ``ALG(a, b, c)``\n    - ``K[x, y, z]``\n    - ``K(x, y, z)``\n    - ``EX``\n\n    \"\"\"\n    if symbols is not None:\n        return K0.unify_with_symbols(K1, symbols)\n\n    if K0 == K1:\n        return K0\n\n    if not (K0.has_CharacteristicZero and K1.has_CharacteristicZero):\n        # Reject unification of domains with different characteristics.\n        if K0.characteristic() != K1.characteristic():\n            raise UnificationFailed(\"Cannot unify %s with %s\" % (K0, K1))\n\n        # We do not get here if K0 == K1. The two domains have the same\n        # characteristic but are unequal so at least one is composite and\n        # we are unifying something like GF(3).unify(GF(3)[x]).\n        return K0.unify_composite(K1)\n\n    # From here we know both domains have characteristic zero and it can be\n    # acceptable to fall back on EX.\n\n    if K0.is_EXRAW:\n        return K0\n    if K1.is_EXRAW:\n        return K1\n\n    if K0.is_EX:\n        return K0\n    if K1.is_EX:\n        return K1\n\n    if K0.is_FiniteExtension or K1.is_FiniteExtension:\n        if K1.is_FiniteExtension:\n            K0, K1 = K1, K0\n        if K1.is_FiniteExtension:\n            # Unifying two extensions.\n            # Try to ensure that K0.unify(K1) == K1.unify(K0)\n            if list(ordered([K0.modulus, K1.modulus]))[1] == K0.modulus:\n                K0, K1 = K1, K0\n            return K1.set_domain(K0)\n        else:\n            # Drop the generator from other and unify with the base domain\n            K1 = K1.drop(K0.symbol)\n            K1 = K0.domain.unify(K1)\n            return K0.set_domain(K1)\n\n    if K0.is_Composite or K1.is_Composite:\n        return K0.unify_composite(K1)\n\n    if K1.is_ComplexField:\n        K0, K1 = K1, K0\n    if K0.is_ComplexField:\n        if K1.is_ComplexField or K1.is_RealField:\n            if K0.precision >= K1.precision:\n                return K0\n            else:\n                from sympy.polys.domains.complexfield import ComplexField\n                return ComplexField(prec=K1.precision)\n        else:\n            return K0\n\n    if K1.is_RealField:\n        K0, K1 = K1, K0\n    if K0.is_RealField:\n        if K1.is_RealField:\n            if K0.precision >= K1.precision:\n                return K0\n            else:\n                return K1\n        elif K1.is_GaussianRing or K1.is_GaussianField:\n            from sympy.polys.domains.complexfield import ComplexField\n            return ComplexField(prec=K0.precision)\n        else:\n            return K0\n\n    if K1.is_AlgebraicField:\n        K0, K1 = K1, K0\n    if K0.is_AlgebraicField:\n        if K1.is_GaussianRing:\n            K1 = K1.get_field()\n        if K1.is_GaussianField:\n            K1 = K1.as_AlgebraicField()\n        if K1.is_AlgebraicField:\n            return K0.__class__(K0.dom.unify(K1.dom), *_unify_gens(K0.orig_ext, K1.orig_ext))\n        else:\n            return K0\n\n    if K0.is_GaussianField:\n        return K0\n    if K1.is_GaussianField:\n        return K1\n\n    if K0.is_GaussianRing:\n        if K1.is_RationalField:\n            K0 = K0.get_field()\n        return K0\n    if K1.is_GaussianRing:\n        if K0.is_RationalField:\n            K1 = K1.get_field()\n        return K1\n\n    if K0.is_RationalField:\n        return K0\n    if K1.is_RationalField:\n        return K1\n\n    if K0.is_IntegerRing:\n        return K0\n    if K1.is_IntegerRing:\n        return K1\n\n    from sympy.polys.domains import EX\n    return EX",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(self, other):\n    if isinstance(other, ExpressionDomain):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.finitefield.__str__": "def __str__(self):\n    return 'GF(%s)' % self.mod",
    "sympy.sympy.polys.domains.finitefield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FiniteField) and \\\n        self.mod == other.mod and self.dom == other.dom",
    "sympy.sympy.polys.domains.finitefield.characteristic": "def characteristic(self):\n    \"\"\"Return the characteristic of this domain. \"\"\"\n    return self.mod",
    "sympy.sympy.polys.domains.fractionfield.__str__": "def __str__(self):\n    return str(self.domain) + '(' + ','.join(map(str, self.symbols)) + ')'",
    "sympy.sympy.polys.domains.fractionfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if not isinstance(other, FractionField):\n        return NotImplemented\n    return self.field == other.field",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, GaussianRationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.gaussiandomains.has_CharacteristicZero": "@property\ndef has_CharacteristicZero(self) -> bool: # type: ignore\n    return True",
    "sympy.sympy.polys.domains.gaussiandomains.characteristic": "def characteristic(self) -> int:\n    return 0",
    "sympy.sympy.polys.domains.gaussiandomains.get_field": "def get_field(self) -> GaussianRationalField:\n    \"\"\"Returns a field associated with ``self``. \"\"\"\n    return QQ_I",
    "sympy.sympy.polys.domains.gaussiandomains.as_AlgebraicField": "def as_AlgebraicField(self) -> AlgebraicField:\n    \"\"\"Get equivalent domain as an ``AlgebraicField``. \"\"\"\n    return AlgebraicField(self.dom, I)",
    "sympy.sympy.polys.domains.integerring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, IntegerRing):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.__str__": "def __str__(self):\n    return str(self.domain) + '[' + ','.join(map(str, self.symbols)) + ']'",
    "sympy.sympy.polys.domains.polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns `True` if two domains are equivalent. \"\"\"\n    if not isinstance(other, PolynomialRing):\n        return NotImplemented\n    return self.ring == other.ring",
    "sympy.sympy.polys.domains.rationalfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, RationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.realfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, RealField) and self.precision == other.precision",
    "sympy.sympy.polys.domains.realfield.precision": "@property\ndef precision(self):\n    return self._context.prec",
    "sympy.sympy.polys.polyutils._unify_gens": "def _unify_gens(f_gens, g_gens):\n    \"\"\"Unify generators in a reasonably intelligent way. \"\"\"\n    f_gens = list(f_gens)\n    g_gens = list(g_gens)\n\n    if f_gens == g_gens:\n        return tuple(f_gens)\n\n    gens, common, k = [], [], 0\n\n    for gen in f_gens:\n        if gen in g_gens:\n            common.append(gen)\n\n    for i, gen in enumerate(g_gens):\n        if gen in common:\n            g_gens[i], k = common[k], k + 1\n\n    for gen in common:\n        i = f_gens.index(gen)\n\n        gens.extend(f_gens[:i])\n        f_gens = f_gens[i + 1:]\n\n        i = g_gens.index(gen)\n\n        gens.extend(g_gens[:i])\n        g_gens = g_gens[i + 1:]\n\n        gens.append(gen)\n\n    gens.extend(f_gens)\n    gens.extend(g_gens)\n\n    return tuple(gens)"
}