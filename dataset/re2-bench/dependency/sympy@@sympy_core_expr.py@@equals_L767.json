{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.basic.is_comparable": "@property\ndef is_comparable(self):\n    \"\"\"Return True if self can be computed to a real number\n    (or already is a real number) with precision, else False.\n\n    Examples\n    ========\n\n    >>> from sympy import exp_polar, pi, I\n    >>> (I*exp_polar(I*pi/2)).is_comparable\n    True\n    >>> (I*exp_polar(I*pi*2)).is_comparable\n    False\n\n    A False result does not mean that `self` cannot be rewritten\n    into a form that would be comparable. For example, the\n    difference computed below is zero but without simplification\n    it does not evaluate to a zero with precision:\n\n    >>> e = 2**pi*(1 + 2**pi)\n    >>> dif = e - e.expand()\n    >>> dif.is_comparable\n    False\n    >>> dif.n(2)._prec\n    1\n\n    \"\"\"\n    return self._eval_is_comparable()",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs) -> tuple[Expr, tuple[Expr, ...]]:\n    \"\"\"Return the tuple (c, args) where self is written as a Mul, ``m``.\n\n    c should be a Rational multiplied by any factors of the Mul that are\n    independent of deps.\n\n    args should be a tuple of all other factors of m; args is empty\n    if self is a Number or if self is independent of deps (when given).\n\n    This should be used when you do not know if self is a Mul or not but\n    you want to treat self as a Mul or if you want to process the\n    individual arguments of the tail of self as a Mul.\n\n    - if you know self is a Mul and want only the head, use self.args[0];\n    - if you do not want to process the arguments of the tail but need the\n      tail then use self.as_two_terms() which gives the head and tail;\n    - if you want to split self into an independent and dependent parts\n      use ``self.as_independent(*deps)``\n\n    >>> from sympy import S\n    >>> from sympy.abc import x, y\n    >>> (S(3)).as_coeff_mul()\n    (3, ())\n    >>> (3*x*y).as_coeff_mul()\n    (3, (x, y))\n    >>> (3*x*y).as_coeff_mul(x)\n    (3*y, (x,))\n    >>> (3*y).as_coeff_mul(x)\n    (3*y, ())\n    \"\"\"\n    if deps:\n        if not self.has(*deps):\n            return self, ()\n    return S.One, (self,)",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.expr._random": "def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):\n    \"\"\"Return self evaluated, if possible, replacing free symbols with\n    random complex values, if necessary.\n\n    Explanation\n    ===========\n\n    The random complex value for each free symbol is generated\n    by the random_complex_number routine giving real and imaginary\n    parts in the range given by the re_min, re_max, im_min, and im_max\n    values. The returned value is evaluated to a precision of n\n    (if given) else the maximum of 15 and the precision needed\n    to get more than 1 digit of precision. If the expression\n    could not be evaluated to a number, or could not be evaluated\n    to more than 1 digit of precision, then None is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import x, y\n    >>> x._random()                         # doctest: +SKIP\n    0.0392918155679172 + 0.916050214307199*I\n    >>> x._random(2)                        # doctest: +SKIP\n    -0.77 - 0.87*I\n    >>> (x + y/2)._random(2)                # doctest: +SKIP\n    -0.57 + 0.16*I\n    >>> sqrt(2)._random(2)\n    1.4\n\n    See Also\n    ========\n\n    sympy.core.random.random_complex_number\n    \"\"\"\n\n    free = self.free_symbols\n    prec = 1\n    if free:\n        from sympy.core.random import random_complex_number\n        a, c, b, d = re_min, re_max, im_min, im_max\n        reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)\n                       for zi in free])))\n        try:\n            nmag = abs(self.evalf(2, subs=reps))\n        except (ValueError, TypeError):\n            # if an out of range value resulted in evalf problems\n            # then return None -- XXX is there a way to know how to\n            # select a good random number for a given expression?\n            # e.g. when calculating n! negative values for n should not\n            # be used\n            return None\n    else:\n        reps = {}\n        nmag = abs(self.evalf(2))\n\n    if not hasattr(nmag, '_prec'):\n        # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True\n        return None\n\n    if nmag._prec == 1:\n        # increase the precision up to the default maximum\n        # precision to see if we can get any significance\n\n        # evaluate\n        for prec in giant_steps(2, DEFAULT_MAXPREC):\n            nmag = abs(self.evalf(prec, subs=reps))\n            if nmag._prec != 1:\n                break\n\n    if nmag._prec != 1:\n        if n is None:\n            n = max(prec, 15)\n        return self.evalf(n, subs=reps)\n\n    # never got any significance\n    return None",
    "sympy.sympy.core.expr.is_constant": "def is_constant(self, *wrt, **flags):\n    \"\"\"Return True if self is constant, False if not, or None if\n    the constancy could not be determined conclusively.\n\n    Explanation\n    ===========\n\n    If an expression has no free symbols then it is a constant. If\n    there are free symbols it is possible that the expression is a\n    constant, perhaps (but not necessarily) zero. To test such\n    expressions, a few strategies are tried:\n\n    1) numerical evaluation at two random points. If two such evaluations\n    give two different values and the values have a precision greater than\n    1 then self is not constant. If the evaluations agree or could not be\n    obtained with any precision, no decision is made. The numerical testing\n    is done only if ``wrt`` is different than the free symbols.\n\n    2) differentiation with respect to variables in 'wrt' (or all free\n    symbols if omitted) to see if the expression is constant or not. This\n    will not always lead to an expression that is zero even though an\n    expression is constant (see added test in test_expr.py). If\n    all derivatives are zero then self is constant with respect to the\n    given symbols.\n\n    3) finding out zeros of denominator expression with free_symbols.\n    It will not be constant if there are zeros. It gives more negative\n    answers for expression that are not constant.\n\n    If neither evaluation nor differentiation can prove the expression is\n    constant, None is returned unless two numerical values happened to be\n    the same and the flag ``failing_number`` is True -- in that case the\n    numerical value will be returned.\n\n    If flag simplify=False is passed, self will not be simplified;\n    the default is True since self should be simplified before testing.\n\n    Examples\n    ========\n\n    >>> from sympy import cos, sin, Sum, S, pi\n    >>> from sympy.abc import a, n, x, y\n    >>> x.is_constant()\n    False\n    >>> S(2).is_constant()\n    True\n    >>> Sum(x, (x, 1, 10)).is_constant()\n    True\n    >>> Sum(x, (x, 1, n)).is_constant()\n    False\n    >>> Sum(x, (x, 1, n)).is_constant(y)\n    True\n    >>> Sum(x, (x, 1, n)).is_constant(n)\n    False\n    >>> Sum(x, (x, 1, n)).is_constant(x)\n    True\n    >>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n    >>> eq.is_constant()\n    True\n    >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\n    True\n\n    >>> (0**x).is_constant()\n    False\n    >>> x.is_constant()\n    False\n    >>> (x**x).is_constant()\n    False\n    >>> one = cos(x)**2 + sin(x)**2\n    >>> one.is_constant()\n    True\n    >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\n    True\n    \"\"\"\n\n    simplify = flags.get('simplify', True)\n\n    if self.is_number:\n        return True\n    free = self.free_symbols\n    if not free:\n        return True  # assume f(1) is some constant\n\n    # if we are only interested in some symbols and they are not in the\n    # free symbols then this expression is constant wrt those symbols\n    wrt = set(wrt)\n    if wrt and not wrt & free:\n        return True\n    wrt = wrt or free\n\n    # simplify unless this has already been done\n    expr = self\n    if simplify:\n        expr = expr.simplify()\n\n    # is_zero should be a quick assumptions check; it can be wrong for\n    # numbers (see test_is_not_constant test), giving False when it\n    # shouldn't, but hopefully it will never give True unless it is sure.\n    if expr.is_zero:\n        return True\n\n    # Don't attempt substitution or differentiation with non-number symbols\n    wrt_number = {sym for sym in wrt if sym.kind is NumberKind}\n\n    # try numerical evaluation to see if we get two different values\n    failing_number = None\n    if wrt_number == free:\n        # try 0 (for a) and 1 (for b)\n        try:\n            a = expr.subs(list(zip(free, [0]*len(free))),\n                simultaneous=True)\n            if a is S.NaN:\n                # evaluation may succeed when substitution fails\n                a = expr._random(None, 0, 0, 0, 0)\n        except ZeroDivisionError:\n            a = None\n        if a is not None and a is not S.NaN:\n            try:\n                b = expr.subs(list(zip(free, [1]*len(free))),\n                    simultaneous=True)\n                if b is S.NaN:\n                    # evaluation may succeed when substitution fails\n                    b = expr._random(None, 1, 0, 1, 0)\n            except ZeroDivisionError:\n                b = None\n            if b is not None and b is not S.NaN and b.equals(a) is False:\n                return False\n            # try random real\n            b = expr._random(None, -1, 0, 1, 0)\n            if b is not None and b is not S.NaN and b.equals(a) is False:\n                return False\n            # try random complex\n            b = expr._random()\n            if b is not None and b is not S.NaN:\n                if b.equals(a) is False:\n                    return False\n                failing_number = a if a.is_number else b\n\n    # now we will test each wrt symbol (or all free symbols) to see if the\n    # expression depends on them or not using differentiation. This is\n    # not sufficient for all expressions, however, so we don't return\n    # False if we get a derivative other than 0 with free symbols.\n    for w in wrt_number:\n        deriv = expr.diff(w)\n        if simplify:\n            deriv = deriv.simplify()\n        if deriv != 0:\n            if not (pure_complex(deriv, or_real=True)):\n                if flags.get('failing_number', False):\n                    return failing_number\n            return False\n    from sympy.solvers.solvers import denoms\n    return fuzzy_not(fuzzy_or(den.is_zero for den in denoms(self)))",
    "sympy.sympy.core.expr.<listcomp>": "surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n# it seems to work better to try big ones first\n",
    "sympy.sympy.core.expr.<lambda>": "surds.sort(key=lambda x: -x.args[0])\n",
    "sympy.sympy.core.expr.<genexpr>": "if any(nsimplify(si, [s]) == s and simplify(si) == s\n        for si in sol):\n    return True\n",
    "sympy.sympy.core.exprtools.factor_terms": "def factor_terms(expr: Expr | complex, radical=False, clear=False, fraction=False, sign=True) -> Expr:\n    \"\"\"Remove common factors from terms in all arguments without\n    changing the underlying structure of the expr. No expansion or\n    simplification (and no processing of non-commutatives) is performed.\n\n    Parameters\n    ==========\n\n    radical: bool, optional\n        If radical=True then a radical common to all terms will be factored\n        out of any Add sub-expressions of the expr.\n\n    clear : bool, optional\n        If clear=False (default) then coefficients will not be separated\n        from a single Add if they can be distributed to leave one or more\n        terms with integer coefficients.\n\n    fraction : bool, optional\n        If fraction=True (default is False) then a common denominator will be\n        constructed for the expression.\n\n    sign : bool, optional\n        If sign=True (default) then even if the only factor in common is a -1,\n        it will be factored out of the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_terms, Symbol\n    >>> from sympy.abc import x, y\n    >>> factor_terms(x + x*(2 + 4*y)**3)\n    x*(8*(2*y + 1)**3 + 1)\n    >>> A = Symbol('A', commutative=False)\n    >>> factor_terms(x*A + x*A + x*y*A)\n    x*(y*A + 2*A)\n\n    When ``clear`` is False, a rational will only be factored out of an\n    Add expression if all terms of the Add have coefficients that are\n    fractions:\n\n    >>> factor_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> factor_terms(x/2 + 1, clear=True)\n    (x + 2)/2\n\n    If a -1 is all that can be factored out, to *not* factor it out, the\n    flag ``sign`` must be False:\n\n    >>> factor_terms(-x - y)\n    -(x + y)\n    >>> factor_terms(-x - y, sign=False)\n    -x - y\n    >>> factor_terms(-2*x - 2*y, sign=False)\n    -2*(x + y)\n\n    See Also\n    ========\n\n    gcd_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.integrals.integrals import Integral\n        is_iterable = iterable(expr)\n\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n\n        if expr.is_Pow or expr.is_Function or \\\n                is_iterable or not hasattr(expr, 'args_cnc'):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n\n        if isinstance(expr, (Sum, Integral)):\n            return _factor_sum_int(expr,\n                radical=radical, clear=clear,\n                fraction=fraction, sign=sign)\n\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            # get a common negative (if there) which gcd_terms does not remove\n            if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None\n                       for a in list_args):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            # rebuild p not worrying about the order which gcd_terms will fix\n            p = Add._from_args(list_args)\n            p = gcd_terms(p,\n                isprimitive=True,\n                clear=clear,\n                fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(\n                *[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr2 = sympify(expr)\n    return do(expr2)",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.power.is_constant": "def is_constant(self, *wrt, **flags):\n    expr = self\n    if flags.get('simplify', True):\n        expr = expr.simplify()\n    b, e = expr.as_base_exp()\n    bz = b.equals(0)\n    if bz:  # recalculate with assumptions in case it's unevaluated\n        new = b**e\n        if new != expr:\n            return new.is_constant()\n    econ = e.is_constant(*wrt)\n    bcon = b.is_constant(*wrt)\n    if bcon:\n        if econ:\n            return True\n        bz = b.equals(0)\n        if bz is False:\n            return False\n    elif bcon is None:\n        return None\n\n    return e.equals(0)",
    "sympy.sympy.core.sympify.sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    \"\"\"\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n\n    Explanation\n    ===========\n\n    It will convert Python ints into instances of :class:`~.Integer`, floats\n    into instances of :class:`~.Float`, etc. It is also able to coerce\n    symbolic expressions which inherit from :class:`~.Basic`. This can be\n    useful in cooperation with SAGE.\n\n    .. warning::\n        Note that this function uses ``eval``, and thus shouldn't be used on\n        unsanitized input.\n\n    If the argument is already a type that SymPy understands, it will do\n    nothing but return that value. This can be used at the beginning of a\n    function to ensure you are working with the correct type.\n\n    Examples\n    ========\n\n    >>> from sympy import sympify\n\n    >>> sympify(2).is_integer\n    True\n    >>> sympify(2).is_real\n    True\n\n    >>> sympify(2.0).is_real\n    True\n    >>> sympify(\"2.0\").is_real\n    True\n    >>> sympify(\"2e-45\").is_real\n    True\n\n    If the expression could not be converted, a SympifyError is raised.\n\n    >>> sympify(\"x***2\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: \"could not parse 'x***2'\"\n\n    When attempting to parse non-Python syntax using ``sympify``, it raises a\n    ``SympifyError``:\n\n    >>> sympify(\"2x+1\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: Sympify of expression 'could not parse '2x+1'' failed\n\n    To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"2x+1\", transformations=\"all\")\n    2*x + 1\n\n    For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`\n\n    Locals\n    ------\n\n    The sympification happens with access to everything that is loaded\n    by ``from sympy import *``; anything used in a string that is not\n    defined by that import will be converted to a symbol. In the following,\n    the ``bitcount`` function is treated as a symbol and the ``O`` is\n    interpreted as the :class:`~.Order` object (used with series) and it raises\n    an error when used improperly:\n\n    >>> s = 'bitcount(42)'\n    >>> sympify(s)\n    bitcount(42)\n    >>> sympify(\"O(x)\")\n    O(x)\n    >>> sympify(\"O + 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: unbound method...\n\n    In order to have ``bitcount`` be recognized it can be defined in a\n    namespace dictionary and passed as locals:\n\n    >>> ns = {}\n    >>> exec('bitcount = lambda n: int(n).bit_length()', ns)\n    >>> sympify(s, locals=ns)\n    6\n\n    In order to have the ``O`` interpreted as a Symbol, identify it as such\n    in the namespace dictionary. This can be done in a variety of ways; all\n    three of the following are possibilities:\n\n    >>> from sympy import Symbol\n    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n    >>> exec('from sympy.abc import O', ns)  # method 2\n    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n    >>> sympify(\"O + 1\", locals=ns)\n    O + 1\n\n    If you want *all* single-letter and Greek-letter variables to be symbols\n    then you can use the clashing-symbols dictionaries that have been defined\n    there as private variables: ``_clash1`` (single-letter variables),\n    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n    multi-letter names that are defined in ``abc``).\n\n    >>> from sympy.abc import _clash1\n    >>> set(_clash1)  # if this fails, see issue #23903\n    {'E', 'I', 'N', 'O', 'Q', 'S'}\n    >>> sympify('I & Q', _clash1)\n    I & Q\n\n    Strict\n    ------\n\n    If the option ``strict`` is set to ``True``, only the types for which an\n    explicit conversion has been defined are converted. In the other\n    cases, a SympifyError is raised.\n\n    >>> print(sympify(None))\n    None\n    >>> sympify(None, strict=True)\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: None\n\n    .. deprecated:: 1.6\n\n       ``sympify(obj)`` automatically falls back to ``str(obj)`` when all\n       other conversion methods fail, but this is deprecated. ``strict=True``\n       will disable this deprecated behavior. See\n       :ref:`deprecated-sympify-string-fallback`.\n\n    Evaluation\n    ----------\n\n    If the option ``evaluate`` is set to ``False``, then arithmetic and\n    operators will be converted into their SymPy equivalents and the\n    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n    be denested first. This is done via an AST transformation that replaces\n    operators with their SymPy equivalents, so if an operand redefines any\n    of those operations, the redefined operators will not be used. If\n    argument a is not a string, the mathematical expression is evaluated\n    before being passed to sympify, so adding ``evaluate=False`` will still\n    return the evaluated result of expression.\n\n    >>> sympify('2**2 / 3 + 5')\n    19/3\n    >>> sympify('2**2 / 3 + 5', evaluate=False)\n    2**2/3 + 5\n    >>> sympify('4/2+7', evaluate=True)\n    9\n    >>> sympify('4/2+7', evaluate=False)\n    4/2 + 7\n    >>> sympify(4/2+7, evaluate=False)\n    9.00000000000000\n\n    Extending\n    ---------\n\n    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n    just define a ``_sympy_`` method to your class. You can do that even to\n    classes that you do not own by subclassing or adding the method at runtime.\n\n    >>> from sympy import Matrix\n    >>> class MyList1(object):\n    ...     def __iter__(self):\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    ...     def _sympy_(self): return Matrix(self)\n    >>> sympify(MyList1())\n    Matrix([\n    [1],\n    [2]])\n\n    If you do not have control over the class definition you could also use the\n    ``converter`` global dictionary. The key is the class and the value is a\n    function that takes a single argument and returns the desired SymPy\n    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n\n    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n    ...     def __iter__(self):  #     Use _sympy_!\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    >>> from sympy.core.sympify import converter\n    >>> converter[MyList2] = lambda x: Matrix(x)\n    >>> sympify(MyList2())\n    Matrix([\n    [1],\n    [2]])\n\n    Notes\n    =====\n\n    The keywords ``rational`` and ``convert_xor`` are only used\n    when the input is a string.\n\n    convert_xor\n    -----------\n\n    >>> sympify('x^y',convert_xor=True)\n    x**y\n    >>> sympify('x^y',convert_xor=False)\n    x ^ y\n\n    rational\n    --------\n\n    >>> sympify('0.1',rational=False)\n    0.1\n    >>> sympify('0.1',rational=True)\n    1/10\n\n    Sometimes autosimplification during sympification results in expressions\n    that are very different in structure than what was entered. Until such\n    autosimplification is no longer done, the ``kernS`` function might be of\n    some use. In the example below you can see how an expression reduces to\n    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n\n    >>> from sympy.core.sympify import kernS\n    >>> from sympy.abc import x\n    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n    -1\n    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n    >>> sympify(s)\n    -1\n    >>> kernS(s)\n    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n\n    Parameters\n    ==========\n\n    a :\n        - any object defined in SymPy\n        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n        - booleans, including ``None`` (will leave ``None`` unchanged)\n        - dicts, lists, sets or tuples containing any of the above\n\n    convert_xor : bool, optional\n        If true, treats ``^`` as exponentiation.\n        If False, treats ``^`` as XOR itself.\n        Used only when input is a string.\n\n    locals : any object defined in SymPy, optional\n        In order to have strings be recognized it can be imported\n        into a namespace dictionary and passed as locals.\n\n    strict : bool, optional\n        If the option strict is set to ``True``, only the types for which\n        an explicit conversion has been defined are converted. In the\n        other cases, a SympifyError is raised.\n\n    rational : bool, optional\n        If ``True``, converts floats into :class:`~.Rational`.\n        If ``False``, it lets floats remain as it is.\n        Used only when input is a string.\n\n    evaluate : bool, optional\n        If False, then arithmetic and operators will be converted into\n        their SymPy equivalents. If True the expression will be evaluated\n        and the result will be returned.\n\n    \"\"\"\n    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n    # was used for a long time we allow it to pass. However if strict=True as\n    # is the case in internal calls to _sympify then we only allow\n    # is_sympy=True.\n    #\n    # https://github.com/sympy/sympy/issues/20124\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n\n    cls = getattr(a, \"__class__\", None)\n\n    #Check if there exists a converter for any of the types in the mro\n    for superclass in getmro(cls):\n        #First check for user defined converters\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            #if none exists, check for SymPy defined converters\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    # Support for basic numpy datatypes\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals,\n                convert_xor=convert_xor, strict=strict, rational=rational,\n                evaluate=evaluate)\n\n    _sympy_ = getattr(a, \"_sympy_\", None)\n    if _sympy_ is not None:\n        return a._sympy_()\n\n    if not strict:\n        # Put numpy array conversion _before_ float/int, see\n        # <https://github.com/sympy/sympy/issues/13924>.\n        flat = getattr(a, \"flat\", None)\n        if flat is not None:\n            shape = getattr(a, \"shape\", None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                # Scalar arrays (those with zero dimensions) have sympify\n                # called on the scalar element.\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(),\n                                       locals=locals,\n                                       convert_xor=convert_xor,\n                                       strict=strict,\n                                       rational=rational,\n                                       evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        elif hasattr(a, '__float__'):\n            # float and int can coerce size-one numpy arrays to their lone\n            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n            return sympify(float(a))\n        elif hasattr(a, '__int__'):\n            return sympify(int(a))\n\n    if strict:\n        raise SympifyError(a)\n\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n                rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            # Not all iterables are rebuildable with their type.\n            pass\n\n    if not isinstance(a, str):\n        raise SympifyError('cannot sympify object of type %r' % type(a))\n\n    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n                                            standard_transformations)\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n\n    transformations = standard_transformations\n\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n\n    return expr",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.polys.numberfields.minpoly.minimal_polynomial": "@public\ndef minimal_polynomial(ex, x=None, compose=True, polys=False, domain=None):\n    \"\"\"\n    Computes the minimal polynomial of an algebraic element.\n\n    Parameters\n    ==========\n\n    ex : Expr\n        Element or expression whose minimal polynomial is to be calculated.\n\n    x : Symbol, optional\n        Independent variable of the minimal polynomial\n\n    compose : boolean, optional (default=True)\n        Method to use for computing minimal polynomial. If ``compose=True``\n        (default) then ``_minpoly_compose`` is used, if ``compose=False`` then\n        groebner bases are used.\n\n    polys : boolean, optional (default=False)\n        If ``True`` returns a ``Poly`` object else an ``Expr`` object.\n\n    domain : Domain, optional\n        Ground domain\n\n    Notes\n    =====\n\n    By default ``compose=True``, the minimal polynomial of the subexpressions of ``ex``\n    are computed, then the arithmetic operations on them are performed using the resultant\n    and factorization.\n    If ``compose=False``, a bottom-up algorithm is used with ``groebner``.\n    The default algorithm stalls less frequently.\n\n    If no ground domain is given, it will be generated automatically from the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import minimal_polynomial, sqrt, solve, QQ\n    >>> from sympy.abc import x, y\n\n    >>> minimal_polynomial(sqrt(2), x)\n    x**2 - 2\n    >>> minimal_polynomial(sqrt(2), x, domain=QQ.algebraic_field(sqrt(2)))\n    x - sqrt(2)\n    >>> minimal_polynomial(sqrt(2) + sqrt(3), x)\n    x**4 - 10*x**2 + 1\n    >>> minimal_polynomial(solve(x**3 + x + 3)[0], x)\n    x**3 + x + 3\n    >>> minimal_polynomial(sqrt(y), x)\n    x**2 - y\n\n    \"\"\"\n\n    ex = sympify(ex)\n    if ex.is_number:\n        # not sure if it's always needed but try it for numbers (issue 8354)\n        ex = _mexpand(ex, recursive=True)\n    for expr in preorder_traversal(ex):\n        if expr.is_AlgebraicNumber:\n            compose = False\n            break\n\n    if x is not None:\n        x, cls = sympify(x), Poly\n    else:\n        x, cls = Dummy('x'), PurePoly\n\n    if not domain:\n        if ex.free_symbols:\n            domain = FractionField(QQ, list(ex.free_symbols))\n        else:\n            domain = QQ\n    if hasattr(domain, 'symbols') and x in domain.symbols:\n        raise GeneratorsError(\"the variable %s is an element of the ground \"\n                              \"domain %s\" % (x, domain))\n\n    if compose:\n        result = _minpoly_compose(ex, x, domain)\n        result = result.primitive()[1]\n        c = result.coeff(x**degree(result, x))\n        if c.is_negative:\n            result = expand_mul(-result)\n        return cls(result, x, field=True) if polys else result.collect(x)\n\n    if not domain.is_QQ:\n        raise NotImplementedError(\"groebner method only works for QQ\")\n\n    result = _minpoly_groebner(ex, x, cls)\n    return cls(result, x, field=True) if polys else result.collect(x)",
    "sympy.sympy.simplify.simplify.simplify": "def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):\n    \"\"\"Simplifies the given expression.\n\n    Explanation\n    ===========\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you do not know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`~.count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output cannot be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you do not\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(1 - log(a)))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If ``rational=True``, Floats will be recast as Rationals before simplification.\n    If ``rational=None``, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n\n    If ``inverse=True``, it will be assumed that a composition of inverse\n    functions, such as sin and asin, can be cancelled in any order.\n    For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n    x belongs to the set where this relation is true. The default is\n    False.\n\n    Note that ``simplify()`` automatically calls ``doit()`` on the final\n    expression. You can avoid this behavior by passing ``doit=False`` as\n    an argument.\n\n    Also, it should be noted that simplifying a boolean expression is not\n    well defined. If the expression prefers automatic evaluation (such as\n    :obj:`~.Eq()` or :obj:`~.Or()`), simplification will return ``True`` or\n    ``False`` if truth value can be determined. If the expression is not\n    evaluated by default (such as :obj:`~.Predicate()`), simplification will\n    not reduce it and you should use :func:`~.refine` or :func:`~.ask`\n    function. This inconsistency will be resolved in future version.\n\n    See Also\n    ========\n\n    sympy.assumptions.refine.refine : Simplification using assumptions.\n    sympy.assumptions.ask.ask : Query for boolean expressions using assumptions.\n    \"\"\"\n\n    def shorter(*choices):\n        \"\"\"\n        Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.\n        \"\"\"\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    def done(e):\n        rv = e.doit() if doit else e\n        return shorter(rv, collect_abs(rv))\n\n    expr = sympify(expr, rational=rational)\n    kwargs = {\n        \"ratio\": kwargs.get('ratio', ratio),\n        \"measure\": kwargs.get('measure', measure),\n        \"rational\": kwargs.get('rational', rational),\n        \"inverse\": kwargs.get('inverse', inverse),\n        \"doit\": kwargs.get('doit', doit)}\n    # no routine for Expr needs to check for is_zero\n    if isinstance(expr, Expr) and expr.is_zero:\n        return S.Zero if not expr.is_Number else expr\n\n    _eval_simplify = getattr(expr, '_eval_simplify', None)\n    if _eval_simplify is not None:\n        return _eval_simplify(**kwargs)\n\n    original_expr = expr = collect_abs(signsimp(expr))\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if inverse and expr.has(Function):\n        expr = inversecombine(expr)\n        if not expr.args:  # simplified to atomic\n            return expr\n\n    # do deep simplification\n    handled = Add, Mul, Pow, ExpBase\n    expr = expr.replace(\n        # here, checking for x.args is not enough because Basic has\n        # args but Basic does not always play well with replace, e.g.\n        # when simultaneous is True found expressions will be masked\n        # off with a Dummy but not all Basic objects in an expression\n        # can be replaced with a Dummy\n        lambda x: isinstance(x, Expr) and x.args and not isinstance(\n            x, handled),\n        lambda x: x.func(*[simplify(i, **kwargs) for i in x.args]),\n        simultaneous=False)\n    if not isinstance(expr, handled):\n        return done(expr)\n\n    if not expr.is_commutative:\n        expr = nc_simplify(expr)\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = _bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # must come before `Piecewise` since this introduces more `Piecewise` terms\n    if expr.has(sign):\n        expr = expr.rewrite(Abs)\n\n    # Deal with Piecewise separately to avoid recursive growth of expressions\n    if expr.has(Piecewise):\n        # Fold into a single Piecewise\n        expr = piecewise_fold(expr)\n        # Apply doit, if doit=True\n        expr = done(expr)\n        # Still a Piecewise?\n        if expr.has(Piecewise):\n            # Fold into a single Piecewise, in case doit lead to some\n            # expressions being Piecewise\n            expr = piecewise_fold(expr)\n            # kroneckersimp also affects Piecewise\n            if expr.has(KroneckerDelta):\n                expr = kroneckersimp(expr)\n            # Still a Piecewise?\n            if expr.has(Piecewise):\n                # Do not apply doit on the segments as it has already\n                # been done above, but simplify\n                expr = piecewise_simplify(expr, deep=True, doit=False)\n                # Still a Piecewise?\n                if expr.has(Piecewise):\n                    # Try factor common terms\n                    expr = shorter(expr, factor_terms(expr))\n                    # As all expressions have been simplified above with the\n                    # complete simplify, nothing more needs to be done here\n                    return expr\n\n    # hyperexpand automatically only works on hypergeometric terms\n    # Do this after the Piecewise part to avoid recursive expansion\n    expr = hyperexpand(expr)\n\n    if expr.has(KroneckerDelta):\n        expr = kroneckersimp(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr, **kwargs)\n\n    if expr.has(Integral):\n        expr = expr.xreplace({\n            i: factor_terms(i) for i in expr.atoms(Integral)})\n\n    if expr.has(Product):\n        expr = product_simplify(expr, **kwargs)\n\n    from sympy.physics.units import Quantity\n\n    if expr.has(Quantity):\n        from sympy.physics.units.util import quantity_simplify\n        expr = quantity_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase, exp):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return done(expr)",
    "sympy.sympy.solvers.solvers.solve": "def solve(f, *symbols, **flags):\n    r\"\"\"\n    Algebraically solves equations and systems of equations.\n\n    Explanation\n    ===========\n\n    Currently supported:\n        - polynomial\n        - transcendental\n        - piecewise combinations of the above\n        - systems of linear and polynomial equations\n        - systems containing relational expressions\n        - systems implied by undetermined coefficients\n\n    Examples\n    ========\n\n    The default output varies according to the input and might\n    be a list (possibly empty), a dictionary, a list of\n    dictionaries or tuples, or an expression involving relationals.\n    For specifics regarding different forms of output that may appear, see :ref:`solve_output`.\n    Let it suffice here to say that to obtain a uniform output from\n    `solve` use ``dict=True`` or ``set=True`` (see below).\n\n        >>> from sympy import solve, Poly, Eq, Matrix, Symbol\n        >>> from sympy.abc import x, y, z, a, b\n\n    The expressions that are passed can be Expr, Equality, or Poly\n    classes (or lists of the same); a Matrix is considered to be a\n    list of all the elements of the matrix:\n\n        >>> solve(x - 3, x)\n        [3]\n        >>> solve(Eq(x, 3), x)\n        [3]\n        >>> solve(Poly(x - 3), x)\n        [3]\n        >>> solve(Matrix([[x, x + y]]), x, y) == solve([x, x + y], x, y)\n        True\n\n    If no symbols are indicated to be of interest and the equation is\n    univariate, a list of values is returned; otherwise, the keys in\n    a dictionary will indicate which (of all the variables used in\n    the expression(s)) variables and solutions were found:\n\n        >>> solve(x**2 - 4)\n        [-2, 2]\n        >>> solve((x - a)*(y - b))\n        [{a: x}, {b: y}]\n        >>> solve([x - 3, y - 1])\n        {x: 3, y: 1}\n        >>> solve([x - 3, y**2 - 1])\n        [{x: 3, y: -1}, {x: 3, y: 1}]\n\n    If you pass symbols for which solutions are sought, the output will vary\n    depending on the number of symbols you passed, whether you are passing\n    a list of expressions or not, and whether a linear system was solved.\n    Uniform output is attained by using ``dict=True`` or ``set=True``.\n\n        >>> #### *** feel free to skip to the stars below *** ####\n        >>> from sympy import TableForm\n        >>> h = [None, ';|;'.join(['e', 's', 'solve(e, s)', 'solve(e, s, dict=True)',\n        ... 'solve(e, s, set=True)']).split(';')]\n        >>> t = []\n        >>> for e, s in [\n        ...         (x - y, y),\n        ...         (x - y, [x, y]),\n        ...         (x**2 - y, [x, y]),\n        ...         ([x - 3, y -1], [x, y]),\n        ...         ]:\n        ...     how = [{}, dict(dict=True), dict(set=True)]\n        ...     res = [solve(e, s, **f) for f in how]\n        ...     t.append([e, '|', s, '|'] + [res[0], '|', res[1], '|', res[2]])\n        ...\n        >>> # ******************************************************* #\n        >>> TableForm(t, headings=h, alignments=\"<\")\n        e              | s      | solve(e, s)  | solve(e, s, dict=True) | solve(e, s, set=True)\n        ---------------------------------------------------------------------------------------\n        x - y          | y      | [x]          | [{y: x}]               | ([y], {(x,)})\n        x - y          | [x, y] | [(y, y)]     | [{x: y}]               | ([x, y], {(y, y)})\n        x**2 - y       | [x, y] | [(x, x**2)]  | [{y: x**2}]            | ([x, y], {(x, x**2)})\n        [x - 3, y - 1] | [x, y] | {x: 3, y: 1} | [{x: 3, y: 1}]         | ([x, y], {(3, 1)})\n\n        * If any equation does not depend on the symbol(s) given, it will be\n          eliminated from the equation set and an answer may be given\n          implicitly in terms of variables that were not of interest:\n\n            >>> solve([x - y, y - 3], x)\n            {x: y}\n\n    When you pass all but one of the free symbols, an attempt\n    is made to find a single solution based on the method of\n    undetermined coefficients. If it succeeds, a dictionary of values\n    is returned. If you want an algebraic solutions for one\n    or more of the symbols, pass the expression to be solved in a list:\n\n        >>> e = a*x + b - 2*x - 3\n        >>> solve(e, [a, b])\n        {a: 2, b: 3}\n        >>> solve([e], [a, b])\n        {a: -b/x + (2*x + 3)/x}\n\n    When there is no solution for any given symbol which will make all\n    expressions zero, the empty list is returned (or an empty set in\n    the tuple when ``set=True``):\n\n        >>> from sympy import sqrt\n        >>> solve(3, x)\n        []\n        >>> solve(x - 3, y)\n        []\n        >>> solve(sqrt(x) + 1, x, set=True)\n        ([x], set())\n\n    When an object other than a Symbol is given as a symbol, it is\n    isolated algebraically and an implicit solution may be obtained.\n    This is mostly provided as a convenience to save you from replacing\n    the object with a Symbol and solving for that Symbol. It will only\n    work if the specified object can be replaced with a Symbol using the\n    subs method:\n\n        >>> from sympy import exp, Function\n        >>> f = Function('f')\n\n        >>> solve(f(x) - x, f(x))\n        [x]\n        >>> solve(f(x).diff(x) - f(x) - x, f(x).diff(x))\n        [x + f(x)]\n        >>> solve(f(x).diff(x) - f(x) - x, f(x))\n        [-x + Derivative(f(x), x)]\n        >>> solve(x + exp(x)**2, exp(x), set=True)\n        ([exp(x)], {(-sqrt(-x),), (sqrt(-x),)})\n\n        >>> from sympy import Indexed, IndexedBase, Tuple\n        >>> A = IndexedBase('A')\n        >>> eqs = Tuple(A[1] + A[2] - 3, A[1] - A[2] + 1)\n        >>> solve(eqs, eqs.atoms(Indexed))\n        {A[1]: 1, A[2]: 2}\n\n        * To solve for a function within a derivative, use :func:`~.dsolve`.\n\n    To solve for a symbol implicitly, use implicit=True:\n\n        >>> solve(x + exp(x), x)\n        [-LambertW(1)]\n        >>> solve(x + exp(x), x, implicit=True)\n        [-exp(x)]\n\n    It is possible to solve for anything in an expression that can be\n    replaced with a symbol using :obj:`~sympy.core.basic.Basic.subs`:\n\n        >>> solve(x + 2 + sqrt(3), x + 2)\n        [-sqrt(3)]\n        >>> solve((x + 2 + sqrt(3), x + 4 + y), y, x + 2)\n        {y: -2 + sqrt(3), x + 2: -sqrt(3)}\n\n        * Nothing heroic is done in this implicit solving so you may end up\n          with a symbol still in the solution:\n\n            >>> eqs = (x*y + 3*y + sqrt(3), x + 4 + y)\n            >>> solve(eqs, y, x + 2)\n            {y: -sqrt(3)/(x + 3), x + 2: -2*x/(x + 3) - 6/(x + 3) + sqrt(3)/(x + 3)}\n            >>> solve(eqs, y*x, x)\n            {x: -y - 4, x*y: -3*y - sqrt(3)}\n\n        * If you attempt to solve for a number, remember that the number\n          you have obtained does not necessarily mean that the value is\n          equivalent to the expression obtained:\n\n            >>> solve(sqrt(2) - 1, 1)\n            [sqrt(2)]\n            >>> solve(x - y + 1, 1)  # /!\\ -1 is targeted, too\n            [x/(y - 1)]\n            >>> [_.subs(z, -1) for _ in solve((x - y + 1).subs(-1, z), 1)]\n            [-x + y]\n\n    **Additional Examples**\n\n    ``solve()`` with check=True (default) will run through the symbol tags to\n    eliminate unwanted solutions. If no assumptions are included, all possible\n    solutions will be returned:\n\n        >>> x = Symbol(\"x\")\n        >>> solve(x**2 - 1)\n        [-1, 1]\n\n    By setting the ``positive`` flag, only one solution will be returned:\n\n        >>> pos = Symbol(\"pos\", positive=True)\n        >>> solve(pos**2 - 1)\n        [1]\n\n    When the solutions are checked, those that make any denominator zero\n    are automatically excluded. If you do not want to exclude such solutions,\n    then use the check=False option:\n\n        >>> from sympy import sin, limit\n        >>> solve(sin(x)/x)  # 0 is excluded\n        [pi]\n\n    If ``check=False``, then a solution to the numerator being zero is found\n    but the value of $x = 0$ is a spurious solution since $\\sin(x)/x$ has the well\n    known limit (without discontinuity) of 1 at $x = 0$:\n\n        >>> solve(sin(x)/x, check=False)\n        [0, pi]\n\n    In the following case, however, the limit exists and is equal to the\n    value of $x = 0$ that is excluded when check=True:\n\n        >>> eq = x**2*(1/x - z**2/x)\n        >>> solve(eq, x)\n        []\n        >>> solve(eq, x, check=False)\n        [0]\n        >>> limit(eq, x, 0, '-')\n        0\n        >>> limit(eq, x, 0, '+')\n        0\n\n    **Solving Relationships**\n\n    When one or more expressions passed to ``solve`` is a relational,\n    a relational result is returned (and the ``dict`` and ``set`` flags\n    are ignored):\n\n        >>> solve(x < 3)\n        (-oo < x) & (x < 3)\n        >>> solve([x < 3, x**2 > 4], x)\n        ((-oo < x) & (x < -2)) | ((2 < x) & (x < 3))\n        >>> solve([x + y - 3, x > 3], x)\n        (3 < x) & (x < oo) & Eq(x, 3 - y)\n\n    Although checking of assumptions on symbols in relationals\n    is not done, setting assumptions will affect how certain\n    relationals might automatically simplify:\n\n        >>> solve(x**2 > 4)\n        ((-oo < x) & (x < -2)) | ((2 < x) & (x < oo))\n\n        >>> r = Symbol('r', real=True)\n        >>> solve(r**2 > 4)\n        (2 < r) | (r < -2)\n\n    There is currently no algorithm in SymPy that allows you to use\n    relationships to resolve more than one variable. So the following\n    does not determine that ``q < 0`` (and trying to solve for ``r``\n    and ``q`` will raise an error):\n\n        >>> from sympy import symbols\n        >>> r, q = symbols('r, q', real=True)\n        >>> solve([r + q - 3, r > 3], r)\n        (3 < r) & Eq(r, 3 - q)\n\n    You can directly call the routine that ``solve`` calls\n    when it encounters a relational: :func:`~.reduce_inequalities`.\n    It treats Expr like Equality.\n\n        >>> from sympy import reduce_inequalities\n        >>> reduce_inequalities([x**2 - 4])\n        Eq(x, -2) | Eq(x, 2)\n\n    If each relationship contains only one symbol of interest,\n    the expressions can be processed for multiple symbols:\n\n        >>> reduce_inequalities([0 <= x  - 1, y < 3], [x, y])\n        (-oo < y) & (1 <= x) & (x < oo) & (y < 3)\n\n    But an error is raised if any relationship has more than one\n    symbol of interest:\n\n        >>> reduce_inequalities([0 <= x*y  - 1, y < 3], [x, y])\n        Traceback (most recent call last):\n        ...\n        NotImplementedError:\n        inequality has more than one symbol of interest.\n\n    **Disabling High-Order Explicit Solutions**\n\n    When solving polynomial expressions, you might not want explicit solutions\n    (which can be quite long). If the expression is univariate, ``CRootOf``\n    instances will be returned instead:\n\n        >>> solve(x**3 - x + 1)\n        [-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) -\n        (-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3,\n        -(-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 -\n        1/((-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)),\n        -(3*sqrt(69)/2 + 27/2)**(1/3)/3 -\n        1/(3*sqrt(69)/2 + 27/2)**(1/3)]\n        >>> solve(x**3 - x + 1, cubics=False)\n        [CRootOf(x**3 - x + 1, 0),\n         CRootOf(x**3 - x + 1, 1),\n         CRootOf(x**3 - x + 1, 2)]\n\n    If the expression is multivariate, no solution might be returned:\n\n        >>> solve(x**3 - x + a, x, cubics=False)\n        []\n\n    Sometimes solutions will be obtained even when a flag is False because the\n    expression could be factored. In the following example, the equation can\n    be factored as the product of a linear and a quadratic factor so explicit\n    solutions (which did not require solving a cubic expression) are obtained:\n\n        >>> eq = x**3 + 3*x**2 + x - 1\n        >>> solve(eq, cubics=False)\n        [-1, -1 + sqrt(2), -sqrt(2) - 1]\n\n    **Solving Equations Involving Radicals**\n\n    Because of SymPy's use of the principle root, some solutions\n    to radical equations will be missed unless check=False:\n\n        >>> from sympy import root\n        >>> eq = root(x**3 - 3*x**2, 3) + 1 - x\n        >>> solve(eq)\n        []\n        >>> solve(eq, check=False)\n        [1/3]\n\n    In the above example, there is only a single solution to the\n    equation. Other expressions will yield spurious roots which\n    must be checked manually; roots which give a negative argument\n    to odd-powered radicals will also need special checking:\n\n        >>> from sympy import real_root, S\n        >>> eq = root(x, 3) - root(x, 5) + S(1)/7\n        >>> solve(eq)  # this gives 2 solutions but misses a 3rd\n        [CRootOf(7*x**5 - 7*x**3 + 1, 1)**15,\n        CRootOf(7*x**5 - 7*x**3 + 1, 2)**15]\n        >>> sol = solve(eq, check=False)\n        >>> [abs(eq.subs(x,i).n(2)) for i in sol]\n        [0.48, 0.e-110, 0.e-110, 0.052, 0.052]\n\n    The first solution is negative so ``real_root`` must be used to see that it\n    satisfies the expression:\n\n        >>> abs(real_root(eq.subs(x, sol[0])).n(2))\n        0.e-110\n\n    If the roots of the equation are not real then more care will be\n    necessary to find the roots, especially for higher order equations.\n    Consider the following expression:\n\n        >>> expr = root(x, 3) - root(x, 5)\n\n    We will construct a known value for this expression at x = 3 by selecting\n    the 1-th root for each radical:\n\n        >>> expr1 = root(x, 3, 1) - root(x, 5, 1)\n        >>> v = expr1.subs(x, -3)\n\n    The ``solve`` function is unable to find any exact roots to this equation:\n\n        >>> eq = Eq(expr, v); eq1 = Eq(expr1, v)\n        >>> solve(eq, check=False), solve(eq1, check=False)\n        ([], [])\n\n    The function ``unrad``, however, can be used to get a form of the equation\n    for which numerical roots can be found:\n\n        >>> from sympy.solvers.solvers import unrad\n        >>> from sympy import nroots\n        >>> e, (p, cov) = unrad(eq)\n        >>> pvals = nroots(e)\n        >>> inversion = solve(cov, x)[0]\n        >>> xvals = [inversion.subs(p, i) for i in pvals]\n\n    Although ``eq`` or ``eq1`` could have been used to find ``xvals``, the\n    solution can only be verified with ``expr1``:\n\n        >>> z = expr - v\n        >>> [xi.n(chop=1e-9) for xi in xvals if abs(z.subs(x, xi).n()) < 1e-9]\n        []\n        >>> z1 = expr1 - v\n        >>> [xi.n(chop=1e-9) for xi in xvals if abs(z1.subs(x, xi).n()) < 1e-9]\n        [-3.0]\n\n    Parameters\n    ==========\n\n    f :\n        - a single Expr or Poly that must be zero\n        - an Equality\n        - a Relational expression\n        - a Boolean\n        - iterable of one or more of the above\n\n    symbols : (object(s) to solve for) specified as\n        - none given (other non-numeric objects will be used)\n        - single symbol\n        - denested list of symbols\n          (e.g., ``solve(f, x, y)``)\n        - ordered iterable of symbols\n          (e.g., ``solve(f, [x, y])``)\n\n    flags :\n        dict=True (default is False)\n            Return list (perhaps empty) of solution mappings.\n        set=True (default is False)\n            Return list of symbols and set of tuple(s) of solution(s).\n        exclude=[] (default)\n            Do not try to solve for any of the free symbols in exclude;\n            if expressions are given, the free symbols in them will\n            be extracted automatically.\n        check=True (default)\n            If False, do not do any testing of solutions. This can be\n            useful if you want to include solutions that make any\n            denominator zero.\n        numerical=True (default)\n            Do a fast numerical check if *f* has only one symbol.\n        minimal=True (default is False)\n            A very fast, minimal testing.\n        warn=True (default is False)\n            Show a warning if ``checksol()`` could not conclude.\n        simplify=True (default)\n            Simplify all but polynomials of order 3 or greater before\n            returning them and (if check is not False) use the\n            general simplify function on the solutions and the\n            expression obtained when they are substituted into the\n            function which should be zero.\n        force=True (default is False)\n            Make positive all symbols without assumptions regarding sign.\n        rational=True (default)\n            Recast Floats as Rational; if this option is not used, the\n            system containing Floats may fail to solve because of issues\n            with polys. If rational=None, Floats will be recast as\n            rationals but the answer will be recast as Floats. If the\n            flag is False then nothing will be done to the Floats.\n        manual=True (default is False)\n            Do not use the polys/matrix method to solve a system of\n            equations, solve them one at a time as you might \"manually.\"\n        implicit=True (default is False)\n            Allows ``solve`` to return a solution for a pattern in terms of\n            other functions that contain that pattern; this is only\n            needed if the pattern is inside of some invertible function\n            like cos, exp, etc.\n        particular=True (default is False)\n            Instructs ``solve`` to try to find a particular solution to\n            a linear system with as many zeros as possible; this is very\n            expensive.\n        quick=True (default is False; ``particular`` must be True)\n            Selects a fast heuristic to find a solution with many zeros\n            whereas a value of False uses the very slow method guaranteed\n            to find the largest number of zeros possible.\n        cubics=True (default)\n            Return explicit solutions when cubic expressions are encountered.\n            When False, quartics and quintics are disabled, too.\n        quartics=True (default)\n            Return explicit solutions when quartic expressions are encountered.\n            When False, quintics are disabled, too.\n        quintics=True (default)\n            Return explicit solutions (if possible) when quintic expressions\n            are encountered.\n\n    See Also\n    ========\n\n    rsolve: For solving recurrence relationships\n    sympy.solvers.ode.dsolve: For solving differential equations\n\n    \"\"\"\n    from .inequalities import reduce_inequalities\n\n    # checking/recording flags\n    ###########################################################################\n\n    # set solver types explicitly; as soon as one is False\n    # all the rest will be False\n    hints = ('cubics', 'quartics', 'quintics')\n    default = True\n    for k in hints:\n        default = flags.setdefault(k, bool(flags.get(k, default)))\n\n    # allow solution to contain symbol if True:\n    implicit = flags.get('implicit', False)\n\n    # record desire to see warnings\n    warn = flags.get('warn', False)\n\n    # this flag will be needed for quick exits below, so record\n    # now -- but don't record `dict` yet since it might change\n    as_set = flags.get('set', False)\n\n    # keeping track of how f was passed\n    bare_f = not iterable(f)\n\n    # check flag usage for particular/quick which should only be used\n    # with systems of equations\n    if flags.get('quick', None) is not None:\n        if not flags.get('particular', None):\n            raise ValueError('when using `quick`, `particular` should be True')\n    if flags.get('particular', False) and bare_f:\n        raise ValueError(filldedent(\"\"\"\n            The 'particular/quick' flag is usually used with systems of\n            equations. Either pass your equation in a list or\n            consider using a solver like `diophantine` if you are\n            looking for a solution in integers.\"\"\"))\n\n    # sympify everything, creating list of expressions and list of symbols\n    ###########################################################################\n\n    def _sympified_list(w):\n        return list(map(sympify, w if iterable(w) else [w]))\n    f, symbols = (_sympified_list(w) for w in [f, symbols])\n\n    # preprocess symbol(s)\n    ###########################################################################\n\n    ordered_symbols = None  # were the symbols in a well defined order?\n    if not symbols:\n        # get symbols from equations\n        symbols = set().union(*[fi.free_symbols for fi in f])\n        if len(symbols) < len(f):\n            for fi in f:\n                pot = preorder_traversal(fi)\n                for p in pot:\n                    if isinstance(p, AppliedUndef):\n                        if not as_set:\n                            flags['dict'] = True  # better show symbols\n                        symbols.add(p)\n                        pot.skip()  # don't go any deeper\n        ordered_symbols = False\n        symbols = list(ordered(symbols))  # to make it canonical\n    else:\n        if len(symbols) == 1 and iterable(symbols[0]):\n            symbols = symbols[0]\n        ordered_symbols = symbols and is_sequence(symbols,\n                        include=GeneratorType)\n        _symbols = list(uniq(symbols))\n        if len(_symbols) != len(symbols):\n            ordered_symbols = False\n            symbols = list(ordered(symbols))\n        else:\n            symbols = _symbols\n\n    # check for duplicates\n    if len(symbols) != len(set(symbols)):\n        raise ValueError('duplicate symbols given')\n    # remove those not of interest\n    exclude = flags.pop('exclude', set())\n    if exclude:\n        if isinstance(exclude, Expr):\n            exclude = [exclude]\n        exclude = set().union(*[e.free_symbols for e in sympify(exclude)])\n        symbols = [s for s in symbols if s not in exclude]\n\n    # preprocess equation(s)\n    ###########################################################################\n\n    # automatically ignore True values\n    if isinstance(f, list):\n        f = [s for s in f if s is not S.true]\n\n    # handle canonicalization of equation types\n    for i, fi in enumerate(f):\n        if isinstance(fi, (Eq, Ne)):\n            if 'ImmutableDenseMatrix' in [type(a).__name__ for a in fi.args]:\n                fi = fi.lhs - fi.rhs\n            else:\n                L, R = fi.args\n                if isinstance(R, BooleanAtom):\n                    L, R = R, L\n                if isinstance(L, BooleanAtom):\n                    if isinstance(fi, Ne):\n                        L = ~L\n                    if R.is_Relational:\n                        fi = ~R if L is S.false else R\n                    elif R.is_Symbol:\n                        return L\n                    elif R.is_Boolean and (~R).is_Symbol:\n                        return ~L\n                    else:\n                        raise NotImplementedError(filldedent('''\n                            Unanticipated argument of Eq when other arg\n                            is True or False.\n                        '''))\n                elif isinstance(fi, Eq):\n                    fi = Add(fi.lhs, -fi.rhs, evaluate=False)\n            f[i] = fi\n\n        # *** dispatch and handle as a system of relationals\n        # **************************************************\n        if fi.is_Relational:\n            if len(symbols) != 1:\n                raise ValueError(\"can only solve for one symbol at a time\")\n            if warn and symbols[0].assumptions0:\n                warnings.warn(filldedent(\"\"\"\n                    \\tWarning: assumptions about variable '%s' are\n                    not handled currently.\"\"\" % symbols[0]))\n            return reduce_inequalities(f, symbols=symbols)\n\n        # convert Poly to expression\n        if isinstance(fi, Poly):\n            f[i] = fi.as_expr()\n\n        # rewrite hyperbolics in terms of exp if they have symbols of\n        # interest\n        f[i] = f[i].replace(lambda w: isinstance(w, HyperbolicFunction) and \\\n            w.has_free(*symbols), lambda w: w.rewrite(exp))\n\n        # if we have a Matrix, we need to iterate over its elements again\n        if f[i].is_Matrix:\n            try:\n                f[i] = f[i].as_explicit()\n            except ValueError:\n                raise ValueError(\n                    \"solve cannot handle matrices with symbolic shape.\"\n                )\n            bare_f = False\n            f.extend(list(f[i]))\n            f[i] = S.Zero\n\n        # if we can split it into real and imaginary parts then do so\n        freei = f[i].free_symbols\n        if freei and all(s.is_extended_real or s.is_imaginary for s in freei):\n            fr, fi = f[i].as_real_imag()\n            # accept as long as new re, im, arg or atan2 are not introduced\n            had = f[i].atoms(re, im, arg, atan2)\n            if fr and fi and fr != fi and not any(\n                    i.atoms(re, im, arg, atan2) - had for i in (fr, fi)):\n                if bare_f:\n                    bare_f = False\n                f[i: i + 1] = [fr, fi]\n\n    # real/imag handling -----------------------------\n    if any(isinstance(fi, (bool, BooleanAtom)) for fi in f):\n        if as_set:\n            return [], set()\n        return []\n\n    repl_funcs = (Abs, Min, Max)\n    for i, fi in enumerate(f):\n        # Abs / Max / Min\n        # Rewrites as piecewise functions prior to solving\n        while True:\n            was = fi\n            fi = fi.replace(lambda ex: type(ex) in repl_funcs,\n                       lambda ex: separatevars(ex).rewrite(Piecewise) if any(\n                           arg.has(*symbols) for arg in ex.args) else ex)\n            if was == fi:\n                break\n\n        for e in fi.find(lambda ex: type(ex) in repl_funcs):\n            if e.has(*symbols):\n                raise NotImplementedError('solving %s when the argument '\n                    'is not real or imaginary.' % e)\n\n        # arg\n        fi = fi.replace(arg, lambda a: arg(a).rewrite(atan2).rewrite(atan))\n\n        # save changes\n        f[i] = fi\n\n    # see if re(s) or im(s) appear\n    freim = [fi for fi in f if fi.has(re, im)]\n    if freim:\n        irf = []\n        for s in symbols:\n            if s.is_real or s.is_imaginary:\n                continue  # neither re(x) nor im(x) will appear\n            # if re(s) or im(s) appear, the auxiliary equation must be present\n            if any(fi.has(re(s), im(s)) for fi in freim):\n                irf.append((s, re(s) + S.ImaginaryUnit*im(s)))\n        if irf:\n            for s, rhs in irf:\n                f = [fi.xreplace({s: rhs}) for fi in f] + [s - rhs]\n                symbols.extend([re(s), im(s)])\n            if bare_f:\n                bare_f = False\n            flags['dict'] = True\n    # end of real/imag handling  -----------------------------\n\n    # we can solve for non-symbol entities by replacing them with Dummy symbols\n    f, symbols, swap_sym = recast_to_symbols(f, symbols)\n    # this set of symbols (perhaps recast) is needed below\n    symset = set(symbols)\n\n    # get rid of equations that have no symbols of interest; we don't\n    # try to solve them because the user didn't ask and they might be\n    # hard to solve; this means that solutions may be given in terms\n    # of the eliminated equations e.g. solve((x-y, y-3), x) -> {x: y}\n    newf = []\n    for fi in f:\n        # let the solver handle equations that..\n        # - have no symbols but are expressions\n        # - have symbols of interest\n        # - have no symbols of interest but are constant\n        # but when an expression is not constant and has no symbols of\n        # interest, it can't change what we obtain for a solution from\n        # the remaining equations so we don't include it; and if it's\n        # zero it can be removed and if it's not zero, there is no\n        # solution for the equation set as a whole\n        #\n        # The reason for doing this filtering is to allow an answer\n        # to be obtained to queries like solve((x - y, y), x); without\n        # this mod the return value is []\n        ok = False\n        if fi.free_symbols & symset:\n            ok = True\n        else:\n            if fi.is_number:\n                if fi.is_Number:\n                    if fi.is_zero:\n                        continue\n                    return []\n                ok = True\n            else:\n                if fi.is_constant():\n                    ok = True\n        if ok:\n            newf.append(fi)\n    if not newf:\n        if as_set:\n            return symbols, set()\n        return []\n    f = newf\n    del newf\n\n    # mask off any Object that we aren't going to invert: Derivative,\n    # Integral, etc... so that solving for anything that they contain will\n    # give an implicit solution\n    seen = set()\n    non_inverts = set()\n    for fi in f:\n        pot = preorder_traversal(fi)\n        for p in pot:\n            if not isinstance(p, Expr) or isinstance(p, Piecewise):\n                pass\n            elif (isinstance(p, bool) or\n                    not p.args or\n                    p in symset or\n                    p.is_Add or p.is_Mul or\n                    p.is_Pow and not implicit or\n                    p.is_Function and not implicit) and p.func not in (re, im):\n                continue\n            elif p not in seen:\n                seen.add(p)\n                if p.free_symbols & symset:\n                    non_inverts.add(p)\n                else:\n                    continue\n            pot.skip()\n    del seen\n    non_inverts = dict(list(zip(non_inverts, [Dummy() for _ in non_inverts])))\n    f = [fi.subs(non_inverts) for fi in f]\n\n    # Both xreplace and subs are needed below: xreplace to force substitution\n    # inside Derivative, subs to handle non-straightforward substitutions\n    non_inverts = [(v, k.xreplace(swap_sym).subs(swap_sym)) for k, v in non_inverts.items()]\n\n    # rationalize Floats\n    floats = False\n    if flags.get('rational', True) is not False:\n        for i, fi in enumerate(f):\n            if fi.has(Float):\n                floats = True\n                f[i] = nsimplify(fi, rational=True)\n\n    # capture any denominators before rewriting since\n    # they may disappear after the rewrite, e.g. issue 14779\n    flags['_denominators'] = _simple_dens(f[0], symbols)\n\n    # Any embedded piecewise functions need to be brought out to the\n    # top level so that the appropriate strategy gets selected.\n    # However, this is necessary only if one of the piecewise\n    # functions depends on one of the symbols we are solving for.\n    def _has_piecewise(e):\n        if e.is_Piecewise:\n            return e.has(*symbols)\n        return any(_has_piecewise(a) for a in e.args)\n    for i, fi in enumerate(f):\n        if _has_piecewise(fi):\n            f[i] = piecewise_fold(fi)\n\n    # expand angles of sums; in general, expand_trig will allow\n    # more roots to be found but this is not a great solultion\n    # to not returning a parametric solution, otherwise\n    # many values can be returned that have a simple\n    # relationship between values\n    targs = {t for fi in f for t in fi.atoms(TrigonometricFunction)}\n    if len(targs) > 1:\n        add, other = sift(targs, lambda x: x.args[0].is_Add, binary=True)\n        add, other = [[i for i in l if i.has_free(*symbols)] for l in (add, other)]\n        trep = {}\n        for t in add:\n            a = t.args[0]\n            ind, dep = a.as_independent(*symbols)\n            if dep in symbols or -dep in symbols:\n                # don't let expansion expand wrt anything in ind\n                n = Dummy() if not ind.is_Number else ind\n                trep[t] = TR10(t.func(dep + n)).xreplace({n: ind})\n        if other and len(other) <= 2:\n            base = gcd(*[i.args[0] for i in other]) if len(other) > 1 else other[0].args[0]\n            for i in other:\n                trep[i] = TR11(i, base)\n        f = [fi.xreplace(trep) for fi in f]\n\n    #\n    # try to get a solution\n    ###########################################################################\n    if bare_f:\n        solution = None\n        if len(symbols) != 1:\n            solution = _solve_undetermined(f[0], symbols, flags)\n        if not solution:\n            solution = _solve(f[0], *symbols, **flags)\n    else:\n        linear, solution = _solve_system(f, symbols, **flags)\n    assert type(solution) is list\n    assert not solution or type(solution[0]) is dict, solution\n    #\n    # postprocessing\n    ###########################################################################\n    # capture as_dict flag now (as_set already captured)\n    as_dict = flags.get('dict', False)\n\n    # define how solution will get unpacked\n    tuple_format = lambda s: [tuple([i.get(x, x) for x in symbols]) for i in s]\n    if as_dict or as_set:\n        unpack = None\n    elif bare_f:\n        if len(symbols) == 1:\n            unpack = lambda s: [i[symbols[0]] for i in s]\n        elif len(solution) == 1 and len(solution[0]) == len(symbols):\n            # undetermined linear coeffs solution\n            unpack = lambda s: s[0]\n        elif ordered_symbols:\n            unpack = tuple_format\n        else:\n            unpack = lambda s: s\n    else:\n        if solution:\n            if linear and len(solution) == 1:\n                # if you want the tuple solution for the linear\n                # case, use `set=True`\n                unpack = lambda s: s[0]\n            elif ordered_symbols:\n                unpack = tuple_format\n            else:\n                unpack = lambda s: s\n        else:\n            unpack = None\n\n    # Restore masked-off objects\n    if non_inverts and type(solution) is list:\n        solution = [{k: v.subs(non_inverts) for k, v in s.items()}\n            for s in solution]\n\n    # Restore original \"symbols\" if a dictionary is returned.\n    # This is not necessary for\n    #   - the single univariate equation case\n    #     since the symbol will have been removed from the solution;\n    #   - the nonlinear poly_system since that only supports zero-dimensional\n    #     systems and those results come back as a list\n    #\n    # ** unless there were Derivatives with the symbols, but those were handled\n    #    above.\n    if swap_sym:\n        symbols = [swap_sym.get(k, k) for k in symbols]\n        for i, sol in enumerate(solution):\n            solution[i] = {swap_sym.get(k, k): v.subs(swap_sym)\n                      for k, v in sol.items()}\n\n    # Get assumptions about symbols, to filter solutions.\n    # Note that if assumptions about a solution can't be verified, it is still\n    # returned.\n    check = flags.get('check', True)\n\n    # restore floats\n    if floats and solution and flags.get('rational', None) is None:\n        solution = nfloat(solution, exponent=False)\n        # nfloat might reveal more duplicates\n        solution = _remove_duplicate_solutions(solution)\n\n    if check and solution:  # assumption checking\n        warn = flags.get('warn', False)\n        got_None = []  # solutions for which one or more symbols gave None\n        no_False = []  # solutions for which no symbols gave False\n        for sol in solution:\n            v = fuzzy_and(check_assumptions(val, **symb.assumptions0)\n                          for symb, val in sol.items())\n            if v is False:\n                continue\n            no_False.append(sol)\n            if v is None:\n                got_None.append(sol)\n\n        solution = no_False\n        if warn and got_None:\n            warnings.warn(filldedent(\"\"\"\n                \\tWarning: assumptions concerning following solution(s)\n                cannot be checked:\"\"\" + '\\n\\t' +\n                ', '.join(str(s) for s in got_None)))\n\n    #\n    # done\n    ###########################################################################\n\n    if not solution:\n        if as_set:\n            return symbols, set()\n        return []\n\n    # make orderings canonical for list of dictionaries\n    if not as_set:  # for set, no point in ordering\n        solution = [{k: s[k] for k in ordered(s)} for s in solution]\n        solution.sort(key=default_sort_key)\n\n    if not (as_set or as_dict):\n        return unpack(solution)\n\n    if as_dict:\n        return solution\n\n    # set output: (symbols, {t1, t2, ...}) from list of dictionaries;\n    # include all symbols for those that like a verbose solution\n    # and to resolve any differences in dictionary keys.\n    #\n    # The set results can easily be used to make a verbose dict as\n    #   k, v = solve(eqs, syms, set=True)\n    #   sol = [dict(zip(k,i)) for i in v]\n    #\n    if ordered_symbols:\n        k = symbols  # keep preferred order\n    else:\n        # just unify the symbols for which solutions were found\n        k = list(ordered(set(flatten(tuple(i.keys()) for i in solution))))\n    return k, {tuple([s.get(ki, ki) for ki in k]) for s in solution}"
}