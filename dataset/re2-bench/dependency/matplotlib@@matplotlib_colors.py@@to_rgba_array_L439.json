{
    "matplotlib.lib.matplotlib.cbook._str_lower_equal": "def _str_lower_equal(obj, s):\n    \"\"\"\n    Return whether *obj* is a string equal, when lowercased, to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj.lower() == s",
    "matplotlib.lib.matplotlib.colors.to_rgba": "def to_rgba(c, alpha=None):\n    \"\"\"\n    Convert *c* to an RGBA color.\n\n    Parameters\n    ----------\n    c : :mpltype:`color` or ``np.ma.masked``\n\n    alpha : float, optional\n        If *alpha* is given, force the alpha value of the returned RGBA tuple\n        to *alpha*.\n\n        If None, the alpha value from *c* is used. If *c* does not have an\n        alpha channel, then alpha defaults to 1.\n\n        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n        which always maps to ``(0, 0, 0, 0)``.\n\n    Returns\n    -------\n    tuple\n        Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,\n        alpha) can assume values between 0 and 1.\n    \"\"\"\n    if isinstance(c, tuple) and len(c) == 2:\n        if alpha is None:\n            c, alpha = c\n        else:\n            c = c[0]\n    # Special-case nth color syntax because it should not be cached.\n    if _is_nth_color(c):\n        prop_cycler = mpl.rcParams['axes.prop_cycle']\n        colors = prop_cycler.by_key().get('color', ['k'])\n        c = colors[int(c[1:]) % len(colors)]\n    try:\n        rgba = _colors_full_map.cache[c, alpha]\n    except (KeyError, TypeError):  # Not in cache, or unhashable.\n        rgba = None\n    if rgba is None:  # Suppress exception chaining of cache lookup failure.\n        rgba = _to_rgba_no_colorcycle(c, alpha)\n        try:\n            _colors_full_map.cache[c, alpha] = rgba\n        except TypeError:\n            pass\n    return rgba",
    "matplotlib.lib.matplotlib.colors.<listcomp>": "none_mask = [cbook._str_equal(cc, \"none\") for cc in c]\n",
    "matplotlib.lib.matplotlib.colors.<setcomp>": "lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n"
}