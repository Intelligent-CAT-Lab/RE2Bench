{
    "sympy.sympy.assumptions.ask.ask": "def ask(proposition, assumptions=True, context=global_assumptions):\n    \"\"\"\n    Function to evaluate the proposition with assumptions.\n\n    Explanation\n    ===========\n\n    This function evaluates the proposition to ``True`` or ``False`` if\n    the truth value can be determined. If not, it returns ``None``.\n\n    It should be discerned from :func:`~.refine` which, when applied to a\n    proposition, simplifies the argument to symbolic ``Boolean`` instead of\n    Python built-in ``True``, ``False`` or ``None``.\n\n    **Syntax**\n\n        * ask(proposition)\n            Evaluate the *proposition* in global assumption context.\n\n        * ask(proposition, assumptions)\n            Evaluate the *proposition* with respect to *assumptions* in\n            global assumption context.\n\n    Parameters\n    ==========\n\n    proposition : Boolean\n        Proposition which will be evaluated to boolean value. If this is\n        not ``AppliedPredicate``, it will be wrapped by ``Q.is_true``.\n\n    assumptions : Boolean, optional\n        Local assumptions to evaluate the *proposition*.\n\n    context : AssumptionsContext, optional\n        Default assumptions to evaluate the *proposition*. By default,\n        this is ``sympy.assumptions.global_assumptions`` variable.\n\n    Returns\n    =======\n\n    ``True``, ``False``, or ``None``\n\n    Raises\n    ======\n\n    TypeError : *proposition* or *assumptions* is not valid logical expression.\n\n    ValueError : assumptions are inconsistent.\n\n    Examples\n    ========\n\n    >>> from sympy import ask, Q, pi\n    >>> from sympy.abc import x, y\n    >>> ask(Q.rational(pi))\n    False\n    >>> ask(Q.even(x*y), Q.even(x) & Q.integer(y))\n    True\n    >>> ask(Q.prime(4*x), Q.integer(x))\n    False\n\n    If the truth value cannot be determined, ``None`` will be returned.\n\n    >>> print(ask(Q.odd(3*x))) # cannot determine unless we know x\n    None\n\n    ``ValueError`` is raised if assumptions are inconsistent.\n\n    >>> ask(Q.integer(x), Q.even(x) & Q.odd(x))\n    Traceback (most recent call last):\n      ...\n    ValueError: inconsistent assumptions Q.even(x) & Q.odd(x)\n\n    Notes\n    =====\n\n    Relations in assumptions are not implemented (yet), so the following\n    will not give a meaningful result.\n\n    >>> ask(Q.positive(x), x > 0)\n\n    It is however a work in progress.\n\n    See Also\n    ========\n\n    sympy.assumptions.refine.refine : Simplification using assumptions.\n        Proposition is not reduced to ``None`` if the truth value cannot\n        be determined.\n    \"\"\"\n    from sympy.assumptions.satask import satask\n    from sympy.assumptions.lra_satask import lra_satask\n    from sympy.logic.algorithms.lra_theory import UnhandledInput\n\n    proposition = sympify(proposition)\n    assumptions = sympify(assumptions)\n\n    if isinstance(proposition, Predicate) or proposition.kind is not BooleanKind:\n        raise TypeError(\"proposition must be a valid logical expression\")\n\n    if isinstance(assumptions, Predicate) or assumptions.kind is not BooleanKind:\n        raise TypeError(\"assumptions must be a valid logical expression\")\n\n    # Normalize both proposition and assumptions\n    proposition = _normalize_expr(proposition)\n    assumptions = _normalize_expr(assumptions)\n\n    if isinstance(proposition, AppliedPredicate):\n        key, args = proposition.function, proposition.arguments\n    else:\n        key, args = Q.is_true, (proposition,)\n\n    # convert local and global assumptions to CNF\n    assump_cnf = CNF.from_prop(assumptions)\n    assump_cnf.extend(context)\n\n    # extract the relevant facts from assumptions with respect to args\n    local_facts = _extract_all_facts(assump_cnf, args)\n\n    # convert default facts and assumed facts to encoded CNF\n    known_facts_cnf = get_all_known_facts()\n    enc_cnf = EncodedCNF()\n    enc_cnf.from_cnf(CNF(known_facts_cnf))\n    enc_cnf.add_from_cnf(local_facts)\n\n    # check the satisfiability of given assumptions\n    if local_facts.clauses and satisfiable(enc_cnf) is False:\n        raise ValueError(f\"inconsistent assumptions {assumptions}\")\n\n    # quick computation for single fact\n    res = _ask_single_fact(key, local_facts)\n    if res is not None:\n        return res\n\n    # direct resolution method, no logic\n    res = key(*args)._eval_ask(assumptions)\n    if res is not None:\n        return bool(res)\n\n    # using satask (still costly)\n    res = satask(proposition, assumptions=assumptions, context=context)\n    if res is not None:\n        return res\n\n    try:\n        res = lra_satask(proposition, assumptions=assumptions, context=context)\n    except UnhandledInput:\n        return None\n\n    return res",
    "sympy.sympy.assumptions.assume.__call__": "def __call__(self, *args):\n    return AppliedPredicate(self, *args)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.utilities.decorator.accessor": "@wraps(propfunc)\ndef accessor(self):\n    val = getattr(self, attrname, sentinel)\n    if val is sentinel:\n        val = propfunc(self)\n        setattr(self, attrname, val)\n    return val"
}