{
    "sympy.sympy.core.add.<listcomp>": "dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n\n",
    "sympy.sympy.core.add._addsort": "def _addsort(args):\n    # in-place sorting of args\n    args.sort(key=_args_sortkey)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.intfunc.igcd": "@lru_cache(1024)\ndef igcd(*args):\n    \"\"\"Computes nonnegative integer greatest common divisor.\n\n    Explanation\n    ===========\n\n    The algorithm is based on the well known Euclid's algorithm [1]_. To\n    improve speed, ``igcd()`` has its own caching mechanism.\n    If you do not need the cache mechanism, using ``sympy.external.gmpy.gcd``.\n\n    Examples\n    ========\n\n    >>> from sympy import igcd\n    >>> igcd(2, 4)\n    2\n    >>> igcd(5, 10, 15)\n    5\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euclidean_algorithm\n\n    \"\"\"\n    if len(args) < 2:\n        raise TypeError(\"igcd() takes at least 2 arguments (%s given)\" % len(args))\n    return int(number_gcd(*map(as_int, args)))",
    "sympy.sympy.core.intfunc.ilcm": "def ilcm(*args):\n    \"\"\"Computes integer least common multiple.\n\n    Examples\n    ========\n\n    >>> from sympy import ilcm\n    >>> ilcm(5, 10)\n    10\n    >>> ilcm(7, 3)\n    21\n    >>> ilcm(5, 10, 15)\n    30\n\n    \"\"\"\n    if len(args) < 2:\n        raise TypeError(\"ilcm() takes at least 2 arguments (%s given)\" % len(args))\n    return int(number_lcm(*map(as_int, args)))",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    if not rational:\n        return self, S.One\n    return S.One, self",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.operations._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    \"\"\"Create new instance of own class with args exactly as provided by\n    caller but returning the self class identity if args is empty.\n\n    Examples\n    ========\n\n       This is handy when we want to optimize things, e.g.\n\n           >>> from sympy import Mul, S\n           >>> from sympy.abc import x, y\n           >>> e = Mul(3, x, y)\n           >>> e.args\n           (3, x, y)\n           >>> Mul(*e.args[1:])\n           x*y\n           >>> e._new_rawargs(*e.args[1:])  # the same as above, but faster\n           x*y\n\n       Note: use this with caution. There is no checking of arguments at\n       all. This is best used when you are rebuilding an Add or Mul after\n       simply removing one or more args. If, for example, modifications,\n       result in extra 1s being inserted they will show up in the result:\n\n           >>> m = (x*y)._new_rawargs(S.One, x); m\n           1*x\n           >>> m == x\n           False\n           >>> m.is_Mul\n           True\n\n       Another issue to be aware of is that the commutativity of the result\n       is based on the commutativity of self. If you are rebuilding the\n       terms that came from a commutative object then there will be no\n       problem, but if self was non-commutative then what you are\n       rebuilding may now be commutative.\n\n       Although this routine tries to do as little as possible with the\n       input, getting the commutativity right is important, so this level\n       of safety is enforced: commutativity will always be recomputed if\n       self is non-commutative and kwarg `reeval=False` has not been\n       passed.\n    \"\"\"\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    "sympy.sympy.matrices.expressions.matexpr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self"
}