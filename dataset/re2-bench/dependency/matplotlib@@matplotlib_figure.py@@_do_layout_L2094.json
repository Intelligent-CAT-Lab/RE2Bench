{
    "matplotlib.lib.matplotlib.figure._identify_keys_and_nested": "def _identify_keys_and_nested(mosaic):\n    \"\"\"\n    Given a 2D object array, identify unique IDs and nested mosaics\n\n    Parameters\n    ----------\n    mosaic : 2D object array\n\n    Returns\n    -------\n    unique_ids : tuple\n        The unique non-sub mosaic entries in this mosaic\n    nested : dict[tuple[int, int], 2D object array]\n    \"\"\"\n    # make sure we preserve the user supplied order\n    unique_ids = cbook._OrderedSet()\n    nested = {}\n    for j, row in enumerate(mosaic):\n        for k, v in enumerate(row):\n            if v == empty_sentinel:\n                continue\n            elif not cbook.is_scalar_or_string(v):\n                nested[(j, k)] = _make_array(v)\n            else:\n                unique_ids.add(v)\n\n    return tuple(unique_ids), nested",
    "matplotlib.lib.matplotlib.figure._do_layout": "def _do_layout(gs, mosaic, unique_ids, nested):\n    \"\"\"\n    Recursively do the mosaic.\n\n    Parameters\n    ----------\n    gs : GridSpec\n    mosaic : 2D object array\n        The input converted to a 2D array for this level.\n    unique_ids : tuple\n        The identified scalar labels at this level of nesting.\n    nested : dict[tuple[int, int]], 2D object array\n        The identified nested mosaics, if any.\n\n    Returns\n    -------\n    dict[label, Axes]\n        A flat dict of all of the Axes created.\n    \"\"\"\n    output = dict()\n\n    # we need to merge together the Axes at this level and the Axes\n    # in the (recursively) nested sub-mosaics so that we can add\n    # them to the figure in the \"natural\" order if you were to\n    # ravel in c-order all of the Axes that will be created\n    #\n    # This will stash the upper left index of each object (axes or\n    # nested mosaic) at this level\n    this_level = dict()\n\n    # go through the unique keys,\n    for name in unique_ids:\n        # sort out where each axes starts/ends\n        index = np.argwhere(mosaic == name)\n        start_row, start_col = np.min(index, axis=0)\n        end_row, end_col = np.max(index, axis=0) + 1\n        # and construct the slice object\n        slc = (slice(start_row, end_row), slice(start_col, end_col))\n        # some light error checking\n        if (mosaic[slc] != name).any():\n            raise ValueError(\n                f\"While trying to layout\\n{mosaic!r}\\n\"\n                f\"we found that the label {name!r} specifies a \"\n                \"non-rectangular or non-contiguous area.\")\n        # and stash this slice for later\n        this_level[(start_row, start_col)] = (name, slc, 'axes')\n\n    # do the same thing for the nested mosaics (simpler because these\n    # cannot be spans yet!)\n    for (j, k), nested_mosaic in nested.items():\n        this_level[(j, k)] = (None, nested_mosaic, 'nested')\n\n    # now go through the things in this level and add them\n    # in order left-to-right top-to-bottom\n    for key in sorted(this_level):\n        name, arg, method = this_level[key]\n        # we are doing some hokey function dispatch here based\n        # on the 'method' string stashed above to sort out if this\n        # element is an Axes or a nested mosaic.\n        if method == 'axes':\n            slc = arg\n            # add a single Axes\n            if name in output:\n                raise ValueError(f\"There are duplicate keys {name} \"\n                                 f\"in the layout\\n{mosaic!r}\")\n            ax = self.add_subplot(\n                gs[slc], **{\n                    'label': str(name),\n                    **subplot_kw,\n                    **per_subplot_kw.get(name, {})\n                }\n            )\n            output[name] = ax\n        elif method == 'nested':\n            nested_mosaic = arg\n            j, k = key\n            # recursively add the nested mosaic\n            rows, cols = nested_mosaic.shape\n            nested_output = _do_layout(\n                gs[j, k].subgridspec(rows, cols),\n                nested_mosaic,\n                *_identify_keys_and_nested(nested_mosaic)\n            )\n            overlap = set(output) & set(nested_output)\n            if overlap:\n                raise ValueError(\n                    f\"There are duplicate keys {overlap} \"\n                    f\"between the outer layout\\n{mosaic!r}\\n\"\n                    f\"and the nested layout\\n{nested_mosaic}\"\n                )\n            output.update(nested_output)\n        else:\n            raise RuntimeError(\"This should never happen\")\n    return output",
    "matplotlib.lib.matplotlib.figure.add_subplot": "    @_docstring.interpd\n    def add_subplot(self, *args, **kwargs):\n        \"\"\"\n        Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n\n        Call signatures::\n\n           add_subplot(nrows, ncols, index, **kwargs)\n           add_subplot(pos, **kwargs)\n           add_subplot(ax)\n           add_subplot()\n\n        Parameters\n        ----------\n        *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n            The position of the subplot described by one of\n\n            - Three integers (*nrows*, *ncols*, *index*). The subplot will\n              take the *index* position on a grid with *nrows* rows and\n              *ncols* columns. *index* starts at 1 in the upper left corner\n              and increases to the right.  *index* can also be a two-tuple\n              specifying the (*first*, *last*) indices (1-based, and including\n              *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``\n              makes a subplot that spans the upper 2/3 of the figure.\n            - A 3-digit integer. The digits are interpreted as if given\n              separately as three single-digit integers, i.e.\n              ``fig.add_subplot(235)`` is the same as\n              ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n              if there are no more than 9 subplots.\n            - A `.SubplotSpec`.\n\n            In rare circumstances, `.add_subplot` may be called with a single\n            argument, a subplot Axes instance already created in the\n            present figure but not in the figure's list of Axes.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the subplot (`~.axes.Axes`). *str* is the\n            name of a custom projection, see `~matplotlib.projections`. The\n            default None results in a 'rectilinear' projection.\n\n        polar : bool, default: False\n            If True, equivalent to projection='polar'.\n\n        axes_class : subclass type of `~.axes.Axes`, optional\n            The `.axes.Axes` subclass that is instantiated.  This parameter\n            is incompatible with *projection* and *polar*.  See\n            :ref:`axisartist_users-guide-index` for examples.\n\n        sharex, sharey : `~matplotlib.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared Axes.\n\n        label : str\n            A label for the returned Axes.\n\n        Returns\n        -------\n        `~.axes.Axes`\n\n            The Axes of the subplot. The returned Axes can actually be an\n            instance of a subclass, such as `.projections.polar.PolarAxes` for\n            polar projections.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for the returned Axes\n            base class; except for the *figure* argument. The keyword arguments\n            for the rectilinear base class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used.\n\n            %(Axes:kwdoc)s\n\n        See Also\n        --------\n        .Figure.add_axes\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        ::\n\n            fig = plt.figure()\n\n            fig.add_subplot(231)\n            ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general\n\n            fig.add_subplot(232, frameon=False)  # subplot with no frame\n            fig.add_subplot(233, projection='polar')  # polar subplot\n            fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1\n            fig.add_subplot(235, facecolor=\"red\")  # red subplot\n\n            ax1.remove()  # delete ax1 from the figure\n            fig.add_subplot(ax1)  # add ax1 back to the figure\n        \"\"\"\n        if 'figure' in kwargs:\n            # Axes itself allows for a 'figure' kwarg, but since we want to\n            # bind the created Axes to self, it is not allowed here.\n            raise _api.kwarg_error(\"add_subplot\", \"figure\")\n\n        if (len(args) == 1\n                and isinstance(args[0], mpl.axes._base._AxesBase)\n                and args[0].get_subplotspec()):\n            ax = args[0]\n            key = ax._projection_init\n            if ax.get_figure(root=False) is not self:\n                raise ValueError(\"The Axes must have been created in \"\n                                 \"the present figure\")\n        else:\n            if not args:\n                args = (1, 1, 1)\n            # Normalize correct ijk values to (i, j, k) here so that\n            # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will\n            # trigger errors later (via SubplotSpec._from_subplot_args).\n            if (len(args) == 1 and isinstance(args[0], Integral)\n                    and 100 <= args[0] <= 999):\n                args = tuple(map(int, str(args[0])))\n            projection_class, pkw = self._process_projection_requirements(**kwargs)\n            ax = projection_class(self, *args, **pkw)\n            key = (projection_class, pkw)\n        return self._add_axes_internal(ax, key)",
    "matplotlib.lib.matplotlib.gridspec.__getitem__": "def __getitem__(self, key):\n    \"\"\"Create and return a `.SubplotSpec` instance.\"\"\"\n    nrows, ncols = self.get_geometry()\n\n    def _normalize(key, size, axis):  # Includes last index.\n        orig_key = key\n        if isinstance(key, slice):\n            start, stop, _ = key.indices(size)\n            if stop > start:\n                return start, stop - 1\n            raise IndexError(\"GridSpec slice would result in no space \"\n                             \"allocated for subplot\")\n        else:\n            if key < 0:\n                key = key + size\n            if 0 <= key < size:\n                return key, key\n            elif axis is not None:\n                raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                 f\"axis {axis} with size {size}\")\n            else:  # flat index\n                raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                 f\"GridSpec with size {size}\")\n\n    if isinstance(key, tuple):\n        try:\n            k1, k2 = key\n        except ValueError as err:\n            raise ValueError(\"Unrecognized subplot spec\") from err\n        num1, num2 = np.ravel_multi_index(\n            [_normalize(k1, nrows, 0), _normalize(k2, ncols, 1)],\n            (nrows, ncols))\n    else:  # Single key\n        num1, num2 = _normalize(key, nrows * ncols, None)\n\n    return SubplotSpec(self, num1, num2)",
    "matplotlib.lib.matplotlib.gridspec.subgridspec": "def subgridspec(self, nrows, ncols, **kwargs):\n    \"\"\"\n    Create a GridSpec within this subplot.\n\n    The created `.GridSpecFromSubplotSpec` will have this `SubplotSpec` as\n    a parent.\n\n    Parameters\n    ----------\n    nrows : int\n        Number of rows in grid.\n\n    ncols : int\n        Number of columns in grid.\n\n    Returns\n    -------\n    `.GridSpecFromSubplotSpec`\n\n    Other Parameters\n    ----------------\n    **kwargs\n        All other parameters are passed to `.GridSpecFromSubplotSpec`.\n\n    See Also\n    --------\n    matplotlib.pyplot.subplots\n\n    Examples\n    --------\n    Adding three subplots in the space occupied by a single subplot::\n\n        fig = plt.figure()\n        gs0 = fig.add_gridspec(3, 1)\n        ax1 = fig.add_subplot(gs0[0])\n        ax2 = fig.add_subplot(gs0[1])\n        gssub = gs0[2].subgridspec(1, 3)\n        for i in range(3):\n            fig.add_subplot(gssub[0, i])\n    \"\"\"\n    return GridSpecFromSubplotSpec(nrows, ncols, self, **kwargs)"
}