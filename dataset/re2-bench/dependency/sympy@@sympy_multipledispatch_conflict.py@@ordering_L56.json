{
    "sympy.sympy.multipledispatch.conflict.<listcomp>": "edges = [(a, b) for a in signatures for b in signatures if edge(a, b)]\n",
    "sympy.sympy.multipledispatch.conflict.<dictcomp>": "edges = {k: [b for a, b in v] for k, v in edges.items()}\n",
    "sympy.sympy.multipledispatch.utils._toposort": "def _toposort(edges):\n    \"\"\" Topological sort algorithm by Kahn [1] - O(nodes + vertices)\n\n    inputs:\n        edges - a dict of the form {a: {b, c}} where b and c depend on a\n    outputs:\n        L - an ordered list of nodes that satisfy the dependencies of edges\n\n    >>> from sympy.multipledispatch.utils import _toposort\n    >>> _toposort({1: (2, 3), 2: (3, )})\n    [1, 2, 3]\n\n    Closely follows the wikipedia page [2]\n\n    [1] Kahn, Arthur B. (1962), \"Topological sorting of large networks\",\n    Communications of the ACM\n    [2] https://en.wikipedia.org/wiki/Toposort#Algorithms\n    \"\"\"\n    incoming_edges = reverse_dict(edges)\n    incoming_edges = {k: set(val) for k, val in incoming_edges.items()}\n    S = OrderedDict.fromkeys(v for v in edges if v not in incoming_edges)\n    L = []\n\n    while S:\n        n, _ = S.popitem()\n        L.append(n)\n        for m in edges.get(n, ()):\n            assert n in incoming_edges[m]\n            incoming_edges[m].remove(n)\n            if not incoming_edges[m]:\n                S[m] = None\n    if any(incoming_edges.get(v, None) for v in edges):\n        raise ValueError(\"Input has cycles\")\n    return L",
    "sympy.sympy.multipledispatch.utils.groupby": "def groupby(func, seq):\n    \"\"\" Group a collection by a key function\n\n    >>> from sympy.multipledispatch.utils import groupby\n    >>> names = ['Alice', 'Bob', 'Charlie', 'Dan', 'Edith', 'Frank']\n    >>> groupby(len, names)  # doctest: +SKIP\n    {3: ['Bob', 'Dan'], 5: ['Alice', 'Edith', 'Frank'], 7: ['Charlie']}\n\n    >>> iseven = lambda x: x % 2 == 0\n    >>> groupby(iseven, [1, 2, 3, 4, 5, 6, 7, 8])  # doctest: +SKIP\n    {False: [1, 3, 5, 7], True: [2, 4, 6, 8]}\n\n    See Also:\n        ``countby``\n    \"\"\"\n\n    d = {}\n    for item in seq:\n        key = func(item)\n        if key not in d:\n            d[key] = []\n        d[key].append(item)\n    return d"
}