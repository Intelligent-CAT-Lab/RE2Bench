{
    "matplotlib.lib.matplotlib.colors._get_rgba_and_mask": "def _get_rgba_and_mask(self, X, alpha=None, bytes=False):\n    r\"\"\"\n    Parameters\n    ----------\n    X : float or int or array-like\n        The data value(s) to convert to RGBA.\n        For floats, *X* should be in the interval ``[0.0, 1.0]`` to\n        return the RGBA values ``X*100`` percent along the Colormap line.\n        For integers, *X* should be in the interval ``[0, Colormap.N)`` to\n        return RGBA values *indexed* from the Colormap with index ``X``.\n    alpha : float or array-like or None\n        Alpha must be a scalar between 0 and 1, a sequence of such\n        floats with shape matching X, or None.\n    bytes : bool, default: False\n        If False (default), the returned RGBA values will be floats in the\n        interval ``[0, 1]`` otherwise they will be `numpy.uint8`\\s in the\n        interval ``[0, 255]``.\n\n    Returns\n    -------\n    colors : np.ndarray\n        Array of RGBA values with a shape of ``X.shape + (4, )``.\n    mask : np.ndarray\n        Boolean array with True where the input is ``np.nan`` or masked.\n    \"\"\"\n    self._ensure_inited()\n\n    xa = np.array(X, copy=True)\n    if not xa.dtype.isnative:\n        # Native byteorder is faster.\n        xa = xa.byteswap().view(xa.dtype.newbyteorder())\n    if xa.dtype.kind == \"f\":\n        xa *= self.N\n        # xa == 1 (== N after multiplication) is not out of range.\n        xa[xa == self.N] = self.N - 1\n    # Pre-compute the masks before casting to int (which can truncate\n    # negative values to zero or wrap large floats to negative ints).\n    mask_under = xa < 0\n    mask_over = xa >= self.N\n    # If input was masked, get the bad mask from it; else mask out nans.\n    mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)\n    with np.errstate(invalid=\"ignore\"):\n        # We need this cast for unsigned ints as well as floats\n        xa = xa.astype(int)\n    xa[mask_under] = self._i_under\n    xa[mask_over] = self._i_over\n    xa[mask_bad] = self._i_bad\n\n    lut = self._lut\n    if bytes:\n        lut = (lut * 255).astype(np.uint8)\n\n    rgba = lut.take(xa, axis=0, mode='clip')\n\n    if alpha is not None:\n        alpha = np.clip(alpha, 0, 1)\n        if bytes:\n            alpha *= 255  # Will be cast to uint8 upon assignment.\n        if alpha.shape not in [(), xa.shape]:\n            raise ValueError(\n                f\"alpha is array-like but its shape {alpha.shape} does \"\n                f\"not match that of X {xa.shape}\")\n        rgba[..., -1] = alpha\n        # If the \"bad\" color is all zeros, then ignore alpha input.\n        if (lut[-1] == 0).all():\n            rgba[mask_bad] = (0, 0, 0, 0)\n\n    return rgba, mask_bad"
}