{
    "sympy.sympy.polys.densebasic.dup_convert": "def dup_convert(f: dup[Er], K0: Domain[Er] | None, K1: Domain[Es]) -> dup[Es]:\n    \"\"\"\n    Convert the ground domain of ``f`` from ``K0`` to ``K1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_convert\n\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> dup_convert([R(1), R(2)], R.to_domain(), ZZ)\n    [1, 2]\n    >>> dup_convert([ZZ(1), ZZ(2)], ZZ, R.to_domain())\n    [1, 2]\n\n    \"\"\"\n    if K0 is not None and K0 == K1:\n        return cast('dup[Es]', f)\n    else:\n        return dup_strip([K1.convert(c, K0) for c in f], K1)",
    "sympy.sympy.polys.domains.complexfield.get_exact": "def get_exact(self):\n    \"\"\"Returns an exact domain associated with ``self``. \"\"\"\n    return QQ_I",
    "sympy.sympy.polys.domains.finitefield.is_Field": "@property\ndef is_Field(self):\n    is_field = getattr(self, '_is_field', None)\n    if is_field is None:\n        from sympy.ntheory.primetest import isprime\n        self._is_field = is_field = isprime(self.mod)\n    return is_field",
    "sympy.sympy.polys.domains.realfield.get_exact": "def get_exact(self):\n    \"\"\"Returns an exact domain associated with ``self``. \"\"\"\n    from sympy.polys.domains import QQ\n    return QQ",
    "sympy.sympy.polys.euclidtools.dup_ff_prs_gcd": "def dup_ff_prs_gcd(f, g, K):\n    \"\"\"\n    Computes polynomial GCD using subresultants over a field.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``, ``cff = quo(f, h)``,\n    and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x = ring(\"x\", QQ)\n\n    >>> R.dup_ff_prs_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    \"\"\"\n    result = _dup_ff_trivial_gcd(f, g, K)\n\n    if result is not None:\n        return result\n\n    h = dup_subresultants(f, g, K)[-1]\n    h = dup_monic(h, K)\n\n    cff = dup_quo(f, h, K)\n    cfg = dup_quo(g, h, K)\n\n    return h, cff, cfg",
    "sympy.sympy.polys.euclidtools.dup_zz_heu_gcd": "def dup_zz_heu_gcd(f, g, K):\n    \"\"\"\n    Heuristic polynomial GCD in `Z[x]`.\n\n    Given univariate polynomials `f` and `g` in `Z[x]`, returns\n    their GCD and cofactors, i.e. polynomials ``h``, ``cff`` and ``cfg``\n    such that::\n\n          h = gcd(f, g), cff = quo(f, h) and cfg = quo(g, h)\n\n    The algorithm is purely heuristic which means it may fail to compute\n    the GCD. This will be signaled by raising an exception. In this case\n    you will need to switch to another GCD method.\n\n    The algorithm computes the polynomial GCD by evaluating polynomials\n    f and g at certain points and computing (fast) integer GCD of those\n    evaluations. The polynomial GCD is recovered from the integer image\n    by interpolation.  The final step is to verify if the result is the\n    correct GCD. This gives cofactors as a side effect.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_zz_heu_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    References\n    ==========\n\n    .. [1] [Liao95]_\n\n    \"\"\"\n    result = _dup_rr_trivial_gcd(f, g, K)\n\n    if result is not None:\n        return result\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    gcd, f, g = dup_extract(f, g, K)\n\n    if df == 0 or dg == 0:\n        return [gcd], f, g\n\n    f_norm = dup_max_norm(f, K)\n    g_norm = dup_max_norm(g, K)\n\n    B = K(2*min(f_norm, g_norm) + 29)\n\n    x = max(min(B, 99*K.sqrt(B)),\n            2*min(f_norm // abs(dup_LC(f, K)),\n                  g_norm // abs(dup_LC(g, K))) + 4)\n\n    for i in range(0, HEU_GCD_MAX):\n        ff = dup_eval(f, x, K)\n        gg = dup_eval(g, x, K)\n\n        if ff and gg:\n            h = K.gcd(ff, gg)\n\n            cff = ff // h\n            cfg = gg // h\n\n            h = _dup_zz_gcd_interpolate(h, x, K)\n            h = dup_primitive(h, K)[1]\n\n            cff_, r = dup_div(f, h, K)\n\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return h, cff_, cfg_\n\n            cff = _dup_zz_gcd_interpolate(cff, x, K)\n\n            h, r = dup_div(f, cff, K)\n\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return h, cff, cfg_\n\n            cfg = _dup_zz_gcd_interpolate(cfg, x, K)\n\n            h, r = dup_div(g, cfg, K)\n\n            if not r:\n                cff_, r = dup_div(f, h, K)\n\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return h, cff_, cfg\n\n        x = 73794*x * K.sqrt(K.sqrt(x)) // 27011\n\n    raise HeuristicGCDFailed('no luck')",
    "sympy.sympy.polys.euclidtools.dup_qq_heu_gcd": "def dup_qq_heu_gcd(f, g, K0):\n    \"\"\"\n    Heuristic polynomial GCD in `Q[x]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x = ring(\"x\", QQ)\n\n    >>> f = QQ(1,2)*x**2 + QQ(7,4)*x + QQ(3,2)\n    >>> g = QQ(1,2)*x**2 + x\n\n    >>> R.dup_qq_heu_gcd(f, g)\n    (x + 2, 1/2*x + 3/4, 1/2*x)\n\n    \"\"\"\n    result = _dup_ff_trivial_gcd(f, g, K0)\n\n    if result is not None:\n        return result\n\n    K1 = K0.get_ring()\n\n    cf, f = dup_clear_denoms(f, K0, K1)\n    cg, g = dup_clear_denoms(g, K0, K1)\n\n    f = dup_convert(f, K0, K1)\n    g = dup_convert(g, K0, K1)\n\n    h, cff, cfg = dup_zz_heu_gcd(f, g, K1)\n\n    h = dup_convert(h, K1, K0)\n\n    c = dup_LC(h, K0)\n    h = dup_monic(h, K0)\n\n    cff = dup_convert(cff, K1, K0)\n    cfg = dup_convert(cfg, K1, K0)\n\n    cff = dup_mul_ground(cff, K0.quo(c, cf), K0)\n    cfg = dup_mul_ground(cfg, K0.quo(c, cg), K0)\n\n    return h, cff, cfg",
    "sympy.sympy.polys.euclidtools.dup_inner_gcd": "def dup_inner_gcd(f, g, K):\n    \"\"\"\n    Computes polynomial GCD and cofactors of `f` and `g` in `K[x]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_inner_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    \"\"\"\n    # XXX: This used to check for K.is_Exact but leads to awkward results when\n    # the domain is something like RR[z] e.g.:\n    #\n    # >>> g, p, q = Poly(1, x).cancel(Poly(51.05*x*y - 1.0, x))\n    # >>> g\n    # 1.0\n    # >>> p\n    # Poly(17592186044421.0, x, domain='RR[y]')\n    # >>> q\n    # Poly(898081097567692.0*y*x - 17592186044421.0, x, domain='RR[y]'))\n    #\n    # Maybe it would be better to flatten into multivariate polynomials first.\n    if K.is_RR or K.is_CC:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return [K.one], f, g\n\n        f = dup_convert(f, K, exact)\n        g = dup_convert(g, K, exact)\n\n        h, cff, cfg = dup_inner_gcd(f, g, exact)\n\n        h = dup_convert(h, exact, K)\n        cff = dup_convert(cff, exact, K)\n        cfg = dup_convert(cfg, exact, K)\n\n        return h, cff, cfg\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dup_qq_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dup_ff_prs_gcd(f, g, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dup_zz_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n\n        return dup_rr_prs_gcd(f, g, K)",
    "sympy.sympy.polys.euclidtools.dup_rr_prs_gcd": "def dup_rr_prs_gcd(f, g, K):\n    \"\"\"\n    Computes polynomial GCD using subresultants over a ring.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``, ``cff = quo(f, h)``,\n    and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_rr_prs_gcd(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    \"\"\"\n    result = _dup_rr_trivial_gcd(f, g, K)\n\n    if result is not None:\n        return result\n\n    fc, F = dup_primitive(f, K)\n    gc, G = dup_primitive(g, K)\n\n    c = K.gcd(fc, gc)\n\n    h = dup_subresultants(F, G, K)[-1]\n    _, h = dup_primitive(h, K)\n\n    c *= K.canonical_unit(dup_LC(h, K))\n\n    h = dup_mul_ground(h, c, K)\n\n    cff = dup_quo(f, h, K)\n    cfg = dup_quo(g, h, K)\n\n    return h, cff, cfg",
    "sympy.sympy.polys.polyconfig.query": "def query(key: str) -> bool | int | str | None:\n    \"\"\"Ask for a value of the given configuration item. \"\"\"\n    return _current_config.get(key.upper(), None)"
}