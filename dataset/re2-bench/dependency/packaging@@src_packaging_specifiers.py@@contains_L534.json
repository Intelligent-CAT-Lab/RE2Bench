{
    "packaging.src.packaging.specifiers.filter": "def filter(\n    self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n) -> Iterator[UnparsedVersionVar]:\n    \"\"\"Filter items in the given iterable, that match the specifier.\n\n    :param iterable:\n        An iterable that can contain version strings and :class:`Version` instances.\n        The items in the iterable will be filtered according to the specifier.\n    :param prereleases:\n        Whether or not to allow prereleases in the returned iterator. If set to\n        ``None`` (the default), it will follow the recommendation from :pep:`440`\n        and match prereleases if there are no other versions.\n\n    >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n    ['1.3']\n    >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n    ['1.2.3', '1.3', <Version('1.4')>]\n    >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n    ['1.5a1']\n    >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n    ['1.3', '1.5a1']\n    >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n    ['1.3', '1.5a1']\n    \"\"\"\n    prereleases_versions = []\n    found_non_prereleases = False\n\n    # Determine if to include prereleases by default\n    include_prereleases = (\n        prereleases if prereleases is not None else self.prereleases\n    )\n\n    # Get the matching operator\n    operator_callable = self._get_operator(self.operator)\n\n    # Filter versions\n    for version in iterable:\n        parsed_version = _coerce_version(version)\n        if parsed_version is None:\n            continue\n\n        if operator_callable(parsed_version, self.version):\n            # If it's not a prerelease or prereleases are allowed, yield it directly\n            if not parsed_version.is_prerelease or include_prereleases:\n                found_non_prereleases = True\n                yield version\n            # Otherwise collect prereleases for potential later use\n            elif prereleases is None and self._prereleases is not False:\n                prereleases_versions.append(version)\n\n    # If no non-prereleases were found and prereleases weren't\n    # explicitly forbidden, yield the collected prereleases\n    if (\n        not found_non_prereleases\n        and prereleases is None\n        and self._prereleases is not False\n    ):\n        yield from prereleases_versions"
}