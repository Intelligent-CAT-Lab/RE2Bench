{
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule):\n    \"\"\"\n    Replace occurrences of objects within the expression.\n\n    Parameters\n    ==========\n\n    rule : dict-like\n        Expresses a replacement rule\n\n    Returns\n    =======\n\n    xreplace : the result of the replacement\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, pi, exp\n    >>> x, y, z = symbols('x y z')\n    >>> (1 + x*y).xreplace({x: pi})\n    pi*y + 1\n    >>> (1 + x*y).xreplace({x: pi, y: 2})\n    1 + 2*pi\n\n    Replacements occur only if an entire node in the expression tree is\n    matched:\n\n    >>> (x*y + z).xreplace({x*y: pi})\n    z + pi\n    >>> (x*y*z).xreplace({x*y: pi})\n    x*y*z\n    >>> (2*x).xreplace({2*x: y, x: z})\n    y\n    >>> (2*2*x).xreplace({2*x: y, x: z})\n    4*z\n    >>> (x + y + 2).xreplace({x + y: 2})\n    x + y + 2\n    >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n    x + exp(y) + 2\n\n    xreplace does not differentiate between free and bound symbols. In the\n    following, subs(x, y) would not change x since it is a bound symbol,\n    but xreplace does:\n\n    >>> from sympy import Integral\n    >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n    Integral(y, (y, 1, 2*y))\n\n    Trying to replace x with an expression raises an error:\n\n    >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n    ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n\n    \"\"\"\n    value, _ = self._xreplace(rule)\n    return value",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.is_polynomial": "def is_polynomial(self, *syms):\n    r\"\"\"\n    Return True if self is a polynomial in syms and False otherwise.\n\n    This checks if self is an exact polynomial in syms.  This function\n    returns False for expressions that are \"polynomials\" with symbolic\n    exponents.  Thus, you should be able to apply polynomial algorithms to\n    expressions for which this returns True, and Poly(expr, \\*syms) should\n    work if and only if expr.is_polynomial(\\*syms) returns True. The\n    polynomial does not have to be in expanded form.  If no symbols are\n    given, all free symbols in the expression will be used.\n\n    This is not part of the assumptions system.  You cannot do\n    Symbol('z', polynomial=True).\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Function\n    >>> x = Symbol('x')\n    >>> ((x**2 + 1)**4).is_polynomial(x)\n    True\n    >>> ((x**2 + 1)**4).is_polynomial()\n    True\n    >>> (2**x + 1).is_polynomial(x)\n    False\n    >>> (2**x + 1).is_polynomial(2**x)\n    True\n    >>> f = Function('f')\n    >>> (f(x) + 1).is_polynomial(x)\n    False\n    >>> (f(x) + 1).is_polynomial(f(x))\n    True\n    >>> (1/f(x) + 1).is_polynomial(f(x))\n    False\n\n    >>> n = Symbol('n', nonnegative=True, integer=True)\n    >>> (x**n + 1).is_polynomial(x)\n    False\n\n    This function does not attempt any nontrivial simplifications that may\n    result in an expression that does not appear to be a polynomial to\n    become one.\n\n    >>> from sympy import sqrt, factor, cancel\n    >>> y = Symbol('y', positive=True)\n    >>> a = sqrt(y**2 + 2*y + 1)\n    >>> a.is_polynomial(y)\n    False\n    >>> factor(a)\n    y + 1\n    >>> factor(a).is_polynomial(y)\n    True\n\n    >>> b = (y**2 + 2*y + 1)/(y + 1)\n    >>> b.is_polynomial(y)\n    False\n    >>> cancel(b)\n    y + 1\n    >>> cancel(b).is_polynomial(y)\n    True\n\n    See also .is_rational_function()\n\n    \"\"\"\n    if syms:\n        syms = set(map(sympify, syms))\n    else:\n        syms = self.free_symbols\n        if not syms:\n            return True\n\n    return self._eval_is_polynomial(syms)",
    "sympy.sympy.core.expr.as_coeff_Add": "def as_coeff_Add(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return S.Zero, self",
    "sympy.sympy.core.expr.diff": "def diff(self, *symbols, **assumptions) -> Expr:\n    assumptions.setdefault(\"evaluate\", True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.exprtools.<listcomp>": "currentroots = [r for r in roots(d, x) if r.is_extended_real]\n",
    "sympy.sympy.core.exprtools.<genexpr>": "if not any(p for p in a.atoms(Pow) if not p.is_number) and (a.is_nonpositive or a.is_nonnegative):\n    free = list(a.free_symbols)\n    p = {}\n    for i in free:\n        v = _monotonic_sign(i)\n        if v is None:\n            return\n        p[i] = v or (_eps if i.is_nonnegative else -_eps)\n    v = a.xreplace(p)\n",
    "sympy.sympy.core.exprtools._monotonic_sign": "def _monotonic_sign(self):\n    \"\"\"Return the value closest to 0 that ``self`` may have if all symbols\n    are signed and the result is uniformly the same sign for all values of symbols.\n    If a symbol is only signed but not known to be an\n    integer or the result is 0 then a symbol representative of the sign of self\n    will be returned. Otherwise, None is returned if a) the sign could be positive\n    or negative or b) self is not in one of the following forms:\n\n    - L(x, y, ...) + A: a function linear in all symbols x, y, ... with an\n      additive constant; if A is zero then the function can be a monomial whose\n      sign is monotonic over the range of the variables, e.g. (x + 1)**3 if x is\n      nonnegative.\n    - A/L(x, y, ...) + B: the inverse of a function linear in all symbols x, y, ...\n      that does not have a sign change from positive to negative for any set\n      of values for the variables.\n    - M(x, y, ...) + A: a monomial M whose factors are all signed and a constant, A.\n    - A/M(x, y, ...) + B: the inverse of a monomial and constants A and B.\n    - P(x): a univariate polynomial\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import _monotonic_sign as F\n    >>> from sympy import Dummy\n    >>> nn = Dummy(integer=True, nonnegative=True)\n    >>> p = Dummy(integer=True, positive=True)\n    >>> p2 = Dummy(integer=True, positive=True)\n    >>> F(nn + 1)\n    1\n    >>> F(p - 1)\n    _nneg\n    >>> F(nn*p + 1)\n    1\n    >>> F(p2*p + 1)\n    2\n    >>> F(nn - 1)  # could be negative, zero or positive\n    \"\"\"\n    if not self.is_extended_real:\n        return\n\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return Integer(3)\n            else:\n                return Integer(2)\n        elif s.is_composite:\n            if s.is_odd:\n                return Integer(9)\n            else:\n                return Integer(4)\n        elif s.is_positive:\n            if s.is_even:\n                if s.is_prime is False:\n                    return Integer(4)\n                else:\n                    return Integer(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_extended_negative:\n            if s.is_even:\n                return Integer(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:\n            return S.Zero\n        return None\n\n    # univariate polynomial\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 in (_eps, -_eps):\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    currentroots = []\n                else:\n                    try:\n                        currentroots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        currentroots = [r for r in roots(d, x) if r.is_extended_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all(\n                        (r - x0).is_nonpositive for r in currentroots):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all(\n                        (r - x0).is_nonnegative for r in currentroots):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n*den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n\n    # multivariate\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        # F/A or A/F where A is a number and F is a signed, rational monomial\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (\n                a.is_Mul or a.is_Pow) and \\\n                a.is_rational and \\\n                all(p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow) and \\\n                (a.is_positive or a.is_negative):\n            v = S.One\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        # signed linear expression\n        if not any(p for p in a.atoms(Pow) if not p.is_number) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str | None = None,\n                 dummy_index: int | None = None,\n                 **assumptions: bool | None) -> Self:\n    if dummy_index is not None:\n        assert name is not None, \"If you specify a dummy_index, you must also provide a name\"\n\n    if name is None:\n        name = \"Dummy_\" + str(Dummy._count)\n\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n\n    obj.dummy_index = dummy_index\n\n    return obj",
    "sympy.sympy.functions.elementary.exponential.as_numer_denom": "def as_numer_denom(self):\n    \"\"\"\n    Returns this with a positive exponent as a 2-tuple (a fraction).\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.abc import x\n    >>> exp(-x).as_numer_denom()\n    (1, exp(x))\n    >>> exp(x).as_numer_denom()\n    (exp(x), 1)\n    \"\"\"\n    # this should be the same as Pow.as_numer_denom wrt\n    # exponent handling\n    if not self.is_commutative:\n        return self, S.One\n    exp = self.exp\n    neg_exp = exp.is_negative\n    if not neg_exp and not (-exp).is_negative:\n        neg_exp = exp.could_extract_minus_sign()\n    if neg_exp:\n        return S.One, self.func(-exp)\n    return self, S.One",
    "sympy.sympy.polys.polyroots.roots": "@public\ndef roots(f, *gens,\n        auto=True,\n        cubics=True,\n        trig=False,\n        quartics=True,\n        quintics=False,\n        multiple=False,\n        filter=None,\n        predicate=None,\n        strict=False,\n        **flags):\n    \"\"\"\n    Computes symbolic roots of a univariate polynomial.\n\n    Given a univariate polynomial f with symbolic coefficients (or\n    a list of the polynomial's coefficients), returns a dictionary\n    with its roots and their multiplicities.\n\n    Only roots expressible via radicals will be returned.  To get\n    a complete set of roots use RootOf class or numerical methods\n    instead. By default cubic and quartic formulas are used in\n    the algorithm. To disable them because of unreadable output\n    set ``cubics=False`` or ``quartics=False`` respectively. If cubic\n    roots are real but are expressed in terms of complex numbers\n    (casus irreducibilis [1]) the ``trig`` flag can be set to True to\n    have the solutions returned in terms of cosine and inverse cosine\n    functions.\n\n    To get roots from a specific domain set the ``filter`` flag with\n    one of the following specifiers: Z, Q, R, I, C. By default all\n    roots are returned (this is equivalent to setting ``filter='C'``).\n\n    By default a dictionary is returned giving a compact result in\n    case of multiple roots.  However to get a list containing all\n    those roots set the ``multiple`` flag to True; the list will\n    have identical roots appearing next to each other in the result.\n    (For a given Poly, the all_roots method will give the roots in\n    sorted numerical order.)\n\n    If the ``strict`` flag is True, ``UnsolvableFactorError`` will be\n    raised if the roots found are known to be incomplete (because\n    some roots are not expressible in radicals).\n\n    Examples\n    ========\n\n    >>> from sympy import Poly, roots, degree\n    >>> from sympy.abc import x, y\n\n    >>> roots(x**2 - 1, x)\n    {-1: 1, 1: 1}\n\n    >>> p = Poly(x**2-1, x)\n    >>> roots(p)\n    {-1: 1, 1: 1}\n\n    >>> p = Poly(x**2-y, x, y)\n\n    >>> roots(Poly(p, x))\n    {-sqrt(y): 1, sqrt(y): 1}\n\n    >>> roots(x**2 - y, x)\n    {-sqrt(y): 1, sqrt(y): 1}\n\n    >>> roots([1, 0, -1])\n    {-1: 1, 1: 1}\n\n    ``roots`` will only return roots expressible in radicals. If\n    the given polynomial has some or all of its roots inexpressible in\n    radicals, the result of ``roots`` will be incomplete or empty\n    respectively.\n\n    Example where result is incomplete:\n\n    >>> roots((x-1)*(x**5-x+1), x)\n    {1: 1}\n\n    In this case, the polynomial has an unsolvable quintic factor\n    whose roots cannot be expressed by radicals. The polynomial has a\n    rational root (due to the factor `(x-1)`), which is returned since\n    ``roots`` always finds all rational roots.\n\n    Example where result is empty:\n\n    >>> roots(x**7-3*x**2+1, x)\n    {}\n\n    Here, the polynomial has no roots expressible in radicals, so\n    ``roots`` returns an empty dictionary.\n\n    The result produced by ``roots`` is complete if and only if the\n    sum of the multiplicity of each root is equal to the degree of\n    the polynomial. If strict=True, UnsolvableFactorError will be\n    raised if the result is incomplete.\n\n    The result can be be checked for completeness as follows:\n\n    >>> f = x**3-2*x**2+1\n    >>> sum(roots(f, x).values()) == degree(f, x)\n    True\n    >>> f = (x-1)*(x**5-x+1)\n    >>> sum(roots(f, x).values()) == degree(f, x)\n    False\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions\n\n    \"\"\"\n    from sympy.polys.polytools import to_rational_coeffs\n    flags = dict(flags)\n\n    if isinstance(f, list):\n        if gens:\n            raise ValueError('redundant generators given')\n\n        x = Dummy('x')\n\n        poly, i = {}, len(f) - 1\n\n        for coeff in f:\n            poly[i], i = sympify(coeff), i - 1\n\n        f = Poly(poly, x, field=True)\n    else:\n        try:\n            F = Poly(f, *gens, **flags)\n            if not isinstance(f, Poly) and not F.gen.is_Symbol:\n                raise PolynomialError(\"generator must be a Symbol\")\n            f = F\n        except GeneratorsNeeded:\n            if multiple:\n                return []\n            else:\n                return {}\n        else:\n            n = f.degree()\n            if f.length() == 2 and n > 2:\n                # check for foo**n in constant if dep is c*gen**m\n                con, dep = f.as_expr().as_independent(*f.gens)\n                fcon = -(-con).factor()\n                if fcon != con:\n                    con = fcon\n                    bases = []\n                    for i in Mul.make_args(con):\n                        if i.is_Pow:\n                            b, e = i.as_base_exp()\n                            if e.is_Integer and b.is_Add:\n                                bases.append((b, Dummy(positive=True)))\n                    if bases:\n                        rv = roots(Poly((dep + con).xreplace(dict(bases)),\n                            *f.gens), *F.gens,\n                            auto=auto,\n                            cubics=cubics,\n                            trig=trig,\n                            quartics=quartics,\n                            quintics=quintics,\n                            multiple=multiple,\n                            filter=filter,\n                            predicate=predicate,\n                            **flags)\n                        return {factor_terms(k.xreplace(\n                            {v: k for k, v in bases})\n                        ): v for k, v in rv.items()}\n\n        if f.is_multivariate:\n            raise PolynomialError('multivariate polynomials are not supported')\n\n    def _update_dict(result, zeros, currentroot, k):\n        if currentroot == S.Zero:\n            if S.Zero in zeros:\n                zeros[S.Zero] += k\n            else:\n                zeros[S.Zero] = k\n        if currentroot in result:\n            result[currentroot] += k\n        else:\n            result[currentroot] = k\n\n    def _try_decompose(f):\n        \"\"\"Find roots using functional decomposition. \"\"\"\n        factors, roots = f.decompose(), []\n\n        for currentroot in _try_heuristics(factors[0]):\n            roots.append(currentroot)\n\n        for currentfactor in factors[1:]:\n            previous, roots = list(roots), []\n\n            for currentroot in previous:\n                g = currentfactor - Poly(currentroot, f.gen)\n\n                for currentroot in _try_heuristics(g):\n                    roots.append(currentroot)\n\n        return roots\n\n    def _try_heuristics(f):\n        \"\"\"Find roots using formulas and some tricks. \"\"\"\n        if f.is_ground:\n            return []\n        if f.is_monomial:\n            return [S.Zero]*f.degree()\n\n        if f.length() == 2:\n            if f.degree() == 1:\n                return list(map(cancel, roots_linear(f)))\n            else:\n                return roots_binomial(f)\n\n        result = []\n\n        for i in [-1, 1]:\n            if not f.eval(i):\n                f = f.quo(Poly(f.gen - i, f.gen))\n                result.append(i)\n                break\n\n        n = f.degree()\n\n        if n == 1:\n            result += list(map(cancel, roots_linear(f)))\n        elif n == 2:\n            result += list(map(cancel, roots_quadratic(f)))\n        elif f.is_cyclotomic:\n            result += roots_cyclotomic(f)\n        elif n == 3 and cubics:\n            result += roots_cubic(f, trig=trig)\n        elif n == 4 and quartics:\n            result += roots_quartic(f)\n        elif n == 5 and quintics:\n            result += roots_quintic(f)\n\n        return result\n\n    # Convert the generators to symbols\n    dumgens = symbols('x:%d' % len(f.gens), cls=Dummy)\n    f = f.per(f.rep, dumgens)\n\n    (k,), f = f.terms_gcd()\n\n    if not k:\n        zeros = {}\n    else:\n        zeros = {S.Zero: k}\n\n    coeff, f = preprocess_roots(f)\n\n    if auto and f.get_domain().is_Ring:\n        f = f.to_field()\n\n    # Use EX instead of ZZ_I or QQ_I\n    if f.get_domain().is_QQ_I:\n        f = f.per(f.rep.convert(EX))\n\n    rescale_x = None\n    translate_x = None\n\n    result = {}\n\n    if not f.is_ground:\n        dom = f.get_domain()\n        if not dom.is_Exact and dom.is_Numerical:\n            for r in f.nroots():\n                _update_dict(result, zeros, r, 1)\n        elif f.degree() == 1:\n            _update_dict(result, zeros, roots_linear(f)[0], 1)\n        elif f.length() == 2:\n            roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial\n            for r in roots_fun(f):\n                _update_dict(result, zeros, r, 1)\n        else:\n            _, factors = Poly(f.as_expr()).factor_list()\n            if len(factors) == 1 and f.degree() == 2:\n                for r in roots_quadratic(f):\n                    _update_dict(result, zeros, r, 1)\n            else:\n                if len(factors) == 1 and factors[0][1] == 1:\n                    if f.get_domain().is_EX:\n                        res = to_rational_coeffs(f)\n                        if res:\n                            if res[0] is None:\n                                translate_x, f = res[2:]\n                            else:\n                                rescale_x, f = res[1], res[-1]\n                            result = roots(f)\n                            if not result:\n                                for currentroot in _try_decompose(f):\n                                    _update_dict(result, zeros, currentroot, 1)\n                        else:\n                            for r in _try_heuristics(f):\n                                _update_dict(result, zeros, r, 1)\n                    else:\n                        for currentroot in _try_decompose(f):\n                            _update_dict(result, zeros, currentroot, 1)\n                else:\n                    for currentfactor, k in factors:\n                        for r in _try_heuristics(Poly(currentfactor, f.gen, field=True)):\n                            _update_dict(result, zeros, r, k)\n\n    if coeff is not S.One:\n        _result, result, = result, {}\n\n        for currentroot, k in _result.items():\n            result[coeff*currentroot] = k\n\n    if filter not in [None, 'C']:\n        handlers = {\n            'Z': lambda r: r.is_Integer,\n            'Q': lambda r: r.is_Rational,\n            'R': lambda r: all(a.is_real for a in r.as_numer_denom()),\n            'I': lambda r: r.is_imaginary,\n        }\n\n        try:\n            query = handlers[filter]\n        except KeyError:\n            raise ValueError(\"Invalid filter: %s\" % filter)\n\n        for zero in dict(result).keys():\n            if not query(zero):\n                del result[zero]\n\n    if predicate is not None:\n        for zero in dict(result).keys():\n            if not predicate(zero):\n                del result[zero]\n    if rescale_x:\n        result1 = {}\n        for k, v in result.items():\n            result1[k*rescale_x] = v\n        result = result1\n    if translate_x:\n        result1 = {}\n        for k, v in result.items():\n            result1[k + translate_x] = v\n        result = result1\n\n    # adding zero roots after non-trivial roots have been translated\n    result.update(zeros)\n\n    if strict and sum(result.values()) < f.degree():\n        raise UnsolvableFactorError(filldedent('''\n            Strict mode: some factors cannot be solved in radicals, so\n            a complete list of solutions cannot be returned. Call\n            roots with strict=False to get solutions expressible in\n            radicals (if there are any).\n            '''))\n\n    if not multiple:\n        return result\n    else:\n        zeros = []\n\n        for zero in ordered(result):\n            zeros.extend([zero]*result[zero])\n\n        return zeros",
    "sympy.sympy.polys.polytools.real_roots": "@public\ndef real_roots(f, multiple=True, radicals=True, extension=False):\n    \"\"\"\n    Returns the real roots of ``f`` with multiplicities.\n\n    Explanation\n    ===========\n\n    Finds all real roots of a univariate polynomial with rational coefficients\n    of any degree exactly. The roots are represented in the form given by\n    :func:`~.rootof`. This is equivalent to using :func:`~.rootof` or\n    :func:`~.all_roots` and filtering out only the real roots. However if only\n    the real roots are needed then :func:`real_roots` is more efficient than\n    :func:`~.all_roots` because it computes only the real roots and avoids\n    costly complex root isolation routines.\n\n    Examples\n    ========\n\n    >>> from sympy import real_roots\n    >>> from sympy.abc import x, y\n\n    >>> real_roots(2*x**3 - 7*x**2 + 4*x + 4)\n    [-1/2, 2, 2]\n    >>> real_roots(2*x**3 - 7*x**2 + 4*x + 4, multiple=False)\n    [(-1/2, 1), (2, 2)]\n\n    Real roots of any polynomial with rational coefficients of any degree can\n    be represented using :py:class:`~.ComplexRootOf`:\n\n    >>> p = x**9 + 2*x + 2\n    >>> print(real_roots(p))\n    [CRootOf(x**9 + 2*x + 2, 0)]\n    >>> [r.evalf(3) for r in real_roots(p)]\n    [-0.865]\n\n    All rational roots will be returned as rational numbers. Roots of some\n    simple factors will be expressed using radical or other formulae (unless\n    ``radicals=False`` is passed). All other roots will be expressed as\n    :class:`~.ComplexRootOf`.\n\n    >>> p = (x + 7)*(x**2 - 2)*(x**3 + x + 1)\n    >>> print(real_roots(p))\n    [-7, -sqrt(2), CRootOf(x**3 + x + 1, 0), sqrt(2)]\n    >>> print(real_roots(p, radicals=False))\n    [-7, CRootOf(x**2 - 2, 0), CRootOf(x**3 + x + 1, 0), CRootOf(x**2 - 2, 1)]\n\n    All returned root expressions will numerically evaluate to real numbers\n    with no imaginary part. This is in contrast to the expressions generated by\n    the cubic or quartic formulae as used by :func:`~.roots` which suffer from\n    casus irreducibilis [1]_:\n\n    >>> from sympy import roots\n    >>> p = 2*x**3 - 9*x**2 - 6*x + 3\n    >>> [r.evalf(5) for r in roots(p, multiple=True)]\n    [5.0365 - 0.e-11*I, 0.33984 + 0.e-13*I, -0.87636 + 0.e-10*I]\n    >>> [r.evalf(5) for r in real_roots(p, x)]\n    [-0.87636, 0.33984, 5.0365]\n    >>> [r.is_real for r in roots(p, multiple=True)]\n    [None, None, None]\n    >>> [r.is_real for r in real_roots(p)]\n    [True, True, True]\n\n    Using :func:`real_roots` is equivalent to using :func:`~.all_roots` (or\n    :func:`~.rootof`) and filtering out only the real roots:\n\n    >>> from sympy import all_roots\n    >>> r = [r for r in all_roots(p) if r.is_real]\n    >>> real_roots(p) == r\n    True\n\n    If only the real roots are wanted then using :func:`real_roots` is faster\n    than using :func:`~.all_roots`. Using :func:`real_roots` avoids complex root\n    isolation which can be a lot slower than real root isolation especially for\n    polynomials of high degree which typically have many more complex roots\n    than real roots.\n\n    Irrational algebraic coefficients are handled by :func:`real_roots`\n    if `extension=True` is set.\n\n    >>> from sympy import sqrt, expand\n    >>> p = expand((x - sqrt(2))*(x - sqrt(3)))\n    >>> print(p)\n    x**2 - sqrt(3)*x - sqrt(2)*x + sqrt(6)\n    >>> real_roots(p)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError: sorted roots not supported over EX\n    >>> real_roots(p, extension=True)\n    [sqrt(2), sqrt(3)]\n\n    Transcendental coefficients cannot currently be handled by\n    :func:`real_roots`. In the case of algebraic or transcendental coefficients\n    :func:`~.ground_roots` might be able to find some roots by factorisation:\n\n    >>> from sympy import ground_roots\n    >>> ground_roots(p, x, extension=True)\n    {sqrt(2): 1, sqrt(3): 1}\n\n    If the coefficients are numeric then :func:`~.nroots` can be used to find\n    all roots approximately:\n\n    >>> from sympy import nroots\n    >>> nroots(p, 5)\n    [1.4142, 1.732]\n\n    If the coefficients are symbolic then :func:`sympy.polys.polyroots.roots`\n    or :func:`~.ground_roots` should be used instead.\n\n    >>> from sympy import roots, ground_roots\n    >>> p = x**2 - 3*x*y + 2*y**2\n    >>> roots(p, x)\n    {y: 1, 2*y: 1}\n    >>> ground_roots(p, x)\n    {y: 1, 2*y: 1}\n\n    Parameters\n    ==========\n\n    f : :class:`~.Expr` or :class:`~.Poly`\n        A univariate polynomial with rational (or ``Float``) coefficients.\n    multiple : ``bool`` (default ``True``).\n        Whether to return a ``list`` of roots or a list of root/multiplicity\n        pairs.\n    radicals : ``bool`` (default ``True``)\n        Use simple radical formulae rather than :py:class:`~.ComplexRootOf` for\n        some irrational roots.\n    extension: ``bool`` (default ``False``)\n        Whether to construct an algebraic extension domain before computing\n        the roots. Setting to ``True`` is necessary for finding roots of a\n        polynomial with (irrational) algebraic coefficients but can be slow.\n\n    Returns\n    =======\n\n    A list of :class:`~.Expr` (usually :class:`~.ComplexRootOf`) representing\n    the real roots is returned. The roots are arranged in increasing order and\n    are repeated according to their multiplicities as roots of ``f``.\n\n    If ``multiple=False`` is passed then a list of root/multiplicity pairs is\n    returned instead.\n\n    If ``radicals=False`` is passed then all roots will be represented as\n    either rational numbers or :class:`~.ComplexRootOf`.\n\n    See also\n    ========\n\n    Poly.real_roots:\n        The underlying :class:`Poly` method used by :func:`real_roots`.\n    rootof:\n        Compute a single numbered root of a univariate polynomial.\n    all_roots:\n        Compute all real and non-real roots using :func:`~.rootof`.\n    ground_roots:\n        Compute some roots in the ground domain by factorisation.\n    nroots:\n        Compute all roots using approximate numerical techniques.\n    sympy.polys.polyroots.roots:\n        Compute symbolic expressions for roots using radical formulae.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Casus_irreducibilis\n    \"\"\"\n    try:\n        if isinstance(f, Poly):\n            if extension and not f.domain.is_AlgebraicField:\n                F = Poly(f.expr, extension=True)\n            else:\n                F = f\n        else:\n            if extension:\n                F = Poly(f, extension=True)\n            else:\n                F = Poly(f, greedy=False)\n\n        if not isinstance(f, Poly) and not F.gen.is_Symbol:\n            # root of sin(x) + 1 is -1 but when someone\n            # passes an Expr instead of Poly they may not expect\n            # that the generator will be sin(x), not x\n            raise PolynomialError(\"generator must be a Symbol\")\n    except GeneratorsNeeded:\n        raise PolynomialError(\n            \"Cannot compute real roots of %s, not a polynomial\" % f)\n\n    return F.real_roots(multiple=multiple, radicals=radicals)"
}