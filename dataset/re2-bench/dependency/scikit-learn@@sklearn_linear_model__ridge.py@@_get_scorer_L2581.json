{
    "scikit-learn.sklearn.linear_model._ridge._get_scorer_instance": "def _get_scorer_instance(self):\n    \"\"\"Return a scorer which corresponds to what's defined in RegressorMixin\n    parent class. This is used for routing `sample_weight`.\n    \"\"\"\n    return get_scorer(\"r2\")",
    "scikit-learn.sklearn.metrics._scorer.set_score_request": "def set_score_request(self, **kwargs):\n    \"\"\"Set requested parameters by the scorer.\n\n    Please see :ref:`User Guide <metadata_routing>` on how the routing\n    mechanism works.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    kwargs : dict\n        Arguments should be of the form ``param_name=alias``, and `alias`\n        can be one of ``{True, False, None, str}``.\n    \"\"\"\n    if not _routing_enabled():\n        raise RuntimeError(\n            \"This method is only available when metadata routing is enabled.\"\n            \" You can enable it using\"\n            \" sklearn.set_config(enable_metadata_routing=True).\"\n        )\n\n    self._warn_overlap(\n        message=(\n            \"You are setting metadata request for parameters which are \"\n            \"already set as kwargs for this metric. These set values will be \"\n            \"overridden by passed metadata if provided. Please pass them either \"\n            \"as metadata or kwargs to `make_scorer`.\"\n        ),\n        kwargs=kwargs,\n    )\n    self._metadata_request = MetadataRequest(owner=self)\n    for param, alias in kwargs.items():\n        self._metadata_request.score.add_request(param=param, alias=alias)\n    return self",
    "scikit-learn.sklearn.utils._metadata_requests._routing_enabled": "def _routing_enabled():\n    \"\"\"Return whether metadata routing is enabled.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    enabled : bool\n        Whether metadata routing is enabled. If the config is not set, it\n        defaults to False.\n    \"\"\"\n    return get_config().get(\"enable_metadata_routing\", False)",
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e"
}