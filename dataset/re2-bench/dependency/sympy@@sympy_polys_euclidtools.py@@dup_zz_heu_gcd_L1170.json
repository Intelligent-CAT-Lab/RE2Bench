{
    "sympy.sympy.polys.densearith.dup_div": "def dup_div(f: dup[Er], g: dup[Er], K: Domain[Er]) -> tuple[dup[Er], dup[Er]]:\n    \"\"\"\n    Polynomial division with remainder in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> R.dup_div(x**2 + 1, 2*x - 4)\n    (0, x**2 + 1)\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> R.dup_div(x**2 + 1, 2*x - 4)\n    (1/2*x + 1, 5)\n\n    \"\"\"\n    if K.is_Field:\n        return dup_ff_div(f, g, K) # type: ignore\n    else:\n        return dup_rr_div(f, g, K) # type: ignore",
    "sympy.sympy.polys.densearith.dup_max_norm": "def dup_max_norm(f: dup[Eordered], K: Domain[Eordered]) -> Eordered:\n    \"\"\"\n    Returns maximum norm of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_max_norm(-x**2 + 2*x - 3)\n    3\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return max(dup_abs(f, K))",
    "sympy.sympy.polys.densearith.dup_mul_ground": "def dup_mul_ground(f: dup[Er], c: Er, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply ``f`` by a constant value in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul_ground(x**2 + 2*x - 1, ZZ(3))\n    3*x**2 + 6*x - 3\n\n    \"\"\"\n    if not c or not f:\n        return []\n    else:\n        return [ cf * c for cf in f ]",
    "sympy.sympy.polys.densebasic.dup_LC": "def dup_LC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_LC\n\n    >>> dup_LC([1, 2, 3], ZZ)\n    1\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    "sympy.sympy.polys.densebasic.dup_degree": "def dup_degree(f: dup[Er]) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``K[x]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_degree\n\n    >>> f = ZZ.map([1, 2, 0, 3])\n\n    >>> dup_degree(f)\n    3\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.densetools.dup_eval": "def dup_eval(f: dup[Er], a: Er, K: Domain[Er]) -> Er:\n    \"\"\"\n    Evaluate a polynomial at ``x = a`` in ``K[x]`` using Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_eval(x**2 + 2*x + 3, 2)\n    11\n\n    \"\"\"\n    if not a:\n        return K.convert(dup_TC(f, K))\n\n    result = K.zero\n\n    for c in f:\n        result *= a\n        result += c\n\n    return result",
    "sympy.sympy.polys.densetools.dup_primitive": "def dup_primitive(f: dup[Er], K: Domain[Er]) -> tuple[Er, dup[Er]]:\n    \"\"\"\n    Compute content and the primitive form of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    \"\"\"\n    if not f:\n        return K.zero, f\n\n    cont = dup_content(f, K)\n\n    if K.is_one(cont):\n        return cont, f\n    else:\n        return cont, dup_quo_ground(f, cont, K)",
    "sympy.sympy.polys.densetools.dup_extract": "def dup_extract(f: dup[Er], g: dup[Er], K: Domain[Er]) -> tuple[Er, dup[Er], dup[Er]]:\n    \"\"\"\n    Extract common content from a pair of polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_extract(6*x**2 + 12*x + 18, 4*x**2 + 8*x + 12)\n    (2, 3*x**2 + 6*x + 9, 2*x**2 + 4*x + 6)\n\n    \"\"\"\n    fc = dup_content(f, K)\n    gc = dup_content(g, K)\n\n    gcd = K.gcd(fc, gc)\n\n    if not K.is_one(gcd):\n        f = dup_quo_ground(f, gcd, K)\n        g = dup_quo_ground(g, gcd, K)\n\n    return gcd, f, g",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.integerring.gcd": "def gcd(self, a, b):\n    \"\"\"Compute GCD of ``a`` and ``b``. \"\"\"\n    return gcd(a, b)",
    "sympy.sympy.polys.domains.integerring.sqrt": "def sqrt(self, a):\n    \"\"\"Compute square root of ``a``. \"\"\"\n    return sqrt(a)",
    "sympy.sympy.polys.euclidtools._dup_zz_gcd_interpolate": "def _dup_zz_gcd_interpolate(h, x, K):\n    \"\"\"Interpolate polynomial GCD from integer GCD. \"\"\"\n    f = []\n\n    while h:\n        g = h % x\n\n        if g > x // 2:\n            g -= x\n\n        f.insert(0, g)\n        h = (h - g) // x\n\n    return f",
    "sympy.sympy.polys.euclidtools._dup_rr_trivial_gcd": "def _dup_rr_trivial_gcd(f, g, K):\n    \"\"\"Handle trivial cases in GCD algorithm over a ring. \"\"\"\n    if not (f or g):\n        return [], [], []\n    elif not f:\n        if K.is_nonnegative(dup_LC(g, K)):\n            return g, [], [K.one]\n        else:\n            return dup_neg(g, K), [], [-K.one]\n    elif not g:\n        if K.is_nonnegative(dup_LC(f, K)):\n            return f, [K.one], []\n        else:\n            return dup_neg(f, K), [-K.one], []\n\n    return None"
}