{
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.numbers.as_numer_denom": "def as_numer_denom(self):\n    return self, S.One",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.polys.polytools.cancel": "@public\ndef cancel(f, *gens, _signsimp=True, **args):\n    \"\"\"\n    Cancel common factors in a rational function ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import cancel, sqrt, Symbol, together\n    >>> from sympy.abc import x\n    >>> A = Symbol('A', commutative=False)\n\n    >>> cancel((2*x**2 - 2)/(x**2 - 2*x + 1))\n    (2*x + 2)/(x - 1)\n    >>> cancel((sqrt(3) + sqrt(15)*A)/(sqrt(2) + sqrt(10)*A))\n    sqrt(6)/2\n\n    Note: due to automatic distribution of Rationals, a sum divided by an integer\n    will appear as a sum. To recover a rational form use `together` on the result:\n\n    >>> cancel(x/2 + 1)\n    x/2 + 1\n    >>> together(_)\n    (x + 2)/2\n    \"\"\"\n    from sympy.simplify.simplify import signsimp\n    from sympy.polys.rings import sring\n    options.allowed_flags(args, ['polys'])\n\n    f = sympify(f)\n    if _signsimp:\n        f = signsimp(f)\n    opt = {}\n    if 'polys' in args:\n        opt['polys'] = args['polys']\n\n    if not isinstance(f, Tuple):\n        if f.is_Number or isinstance(f, Relational) or not isinstance(f, Expr):\n            return f\n        f = factor_terms(f, radical=True)\n        p, q = f.as_numer_denom()\n\n    elif len(f) == 2:\n        p, q = f\n        if isinstance(p, Poly) and isinstance(q, Poly):\n            opt['gens'] = p.gens\n            opt['domain'] = p.domain\n            opt['polys'] = opt.get('polys', True)\n        p, q = p.as_expr(), q.as_expr()\n    else:\n        raise ValueError('unexpected argument: %s' % f)\n\n    from sympy.functions.elementary.piecewise import Piecewise\n    try:\n        if f.has(Piecewise):\n            raise PolynomialError()\n        R, (F, G) = sring((p, q), *gens, **args)\n        if not R.ngens:\n            if not isinstance(f, Tuple):\n                return f.expand()\n            else:\n                return S.One, p, q\n    except PolynomialError as msg:\n        if f.is_commutative and not f.has(Piecewise):\n            raise PolynomialError(msg)\n        # Handling of noncommutative and/or piecewise expressions\n        if f.is_Add or f.is_Mul:\n            c, nc = sift(f.args, lambda x:\n                x.is_commutative is True and not x.has(Piecewise),\n                binary=True)\n            nc = [cancel(i) for i in nc]\n            return f.func(cancel(f.func(*c)), *nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                if isinstance(e, BooleanAtom) or not isinstance(e, Expr):\n                    continue\n                try:\n                    reps.append((e, cancel(e)))\n                    pot.skip()  # this was handled successfully\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n\n    c, (P, Q) = 1, F.cancel(G)\n    if opt.get('polys', False) and 'gens' not in opt:\n        opt['gens'] = R.symbols\n\n    if not isinstance(f, Tuple):\n        return c*(P.as_expr()/Q.as_expr())\n    else:\n        P, Q = P.as_expr(), Q.as_expr()\n        if not opt.get('polys', False):\n            return c, P, Q\n        else:\n            return c, Poly(P, *gens, **opt), Poly(Q, *gens, **opt)",
    "sympy.sympy.polys.polytools.reduced": "@public\ndef reduced(f, G, *gens, **args):\n    \"\"\"\n    Reduces a polynomial ``f`` modulo a set of polynomials ``G``.\n\n    Given a polynomial ``f`` and a set of polynomials ``G = (g_1, ..., g_n)``,\n    computes a set of quotients ``q = (q_1, ..., q_n)`` and the remainder ``r``\n    such that ``f = q_1*g_1 + ... + q_n*g_n + r``, where ``r`` vanishes or ``r``\n    is a completely reduced polynomial with respect to ``G``.\n\n    Examples\n    ========\n\n    >>> from sympy import reduced\n    >>> from sympy.abc import x, y\n\n    >>> reduced(2*x**4 + y**2 - x**2 + y**3, [x**3 - x, y**3 - y])\n    ([2*x, 1], x**2 + y**2 + y)\n\n    \"\"\"\n    options.allowed_flags(args, ['polys', 'auto'])\n\n    try:\n        polys, opt = parallel_poly_from_expr([f] + list(G), *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('reduced', 0, exc)\n\n    domain = opt.domain\n    retract = False\n\n    if opt.auto and domain.is_Ring and not domain.is_Field:\n        opt = opt.clone({\"domain\": domain.get_field()})\n        retract = True\n\n    from sympy.polys.rings import xring\n    _ring, _ = xring(opt.gens, opt.domain, opt.order)\n\n    for i, poly in enumerate(polys):\n        poly = poly.set_domain(opt.domain).rep.to_dict()\n        polys[i] = _ring.from_dict(poly)\n\n    Q, r = polys[0].div(polys[1:])\n\n    Q = [Poly._from_dict(dict(q), opt) for q in Q]\n    r = Poly._from_dict(dict(r), opt)\n\n    if retract:\n        try:\n            _Q, _r = [q.to_ring() for q in Q], r.to_ring()\n        except CoercionFailed:\n            pass\n        else:\n            Q, r = _Q, _r\n\n    if not opt.polys:\n        return [q.as_expr() for q in Q], r.as_expr()\n    else:\n        return Q, r"
}