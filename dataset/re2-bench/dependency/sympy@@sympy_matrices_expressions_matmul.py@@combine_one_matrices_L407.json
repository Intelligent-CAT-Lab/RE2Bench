{
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.matrices.expressions.matmul.as_coeff_matrices": "def as_coeff_matrices(self):\n    scalars = [x for x in self.args if not x.is_Matrix]\n    matrices = [x for x in self.args if x.is_Matrix]\n    coeff = Mul(*scalars)\n    if coeff.is_commutative is False:\n        raise NotImplementedError(\"noncommutative scalars in MatMul are not supported.\")\n\n    return coeff, matrices",
    "sympy.sympy.matrices.expressions.matmul.newmul": "def newmul(*args):\n    if args[0] == 1:\n        args = args[1:]\n    return new(MatMul, *args)",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, m, n, evaluate=False):\n    m, n = _sympify(m), _sympify(n)\n    cls._check_dim(m)\n    cls._check_dim(n)\n\n    if evaluate:\n        condition = Eq(m, 1) & Eq(n, 1)\n        if condition == True:\n            return Identity(1)\n\n    obj = super().__new__(cls, m, n)\n    return obj",
    "sympy.sympy.matrices.expressions.special.shape": "@property\ndef shape(self):\n    return self._args"
}