{
    "matplotlib.lib.matplotlib.style.__init__._read_style_directory": "def _read_style_directory(style_dir):\n    \"\"\"Return dictionary of styles defined in *style_dir*.\"\"\"\n    styles = dict()\n    for path in Path(style_dir).glob(f\"*.{_STYLE_EXTENSION}\"):\n        with warnings.catch_warnings(record=True) as warns:\n            styles[path.stem] = rc_params_from_file(path, use_default_template=False)\n        for w in warns:\n            _log.warning('In %s: %s', path, w.message)\n    return styles",
    "matplotlib.lib.matplotlib.style.__init__._update_nested_dict": "def _update_nested_dict(main_dict, new_dict):\n    \"\"\"\n    Update nested dict (only level of nesting) with new values.\n\n    Unlike `dict.update`, this assumes that the values of the parent dict are\n    dicts (or dict-like), so you shouldn't replace the nested dict if it\n    already exists. Instead you should update the sub-dict.\n    \"\"\"\n    # update named styles specified by user\n    for name, rc_dict in new_dict.items():\n        main_dict.setdefault(name, {}).update(rc_dict)\n    return main_dict"
}