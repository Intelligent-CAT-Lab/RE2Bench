{
    "sympy.sympy.algebras.quaternion.<listcomp>": "e1, e2, e3, e4 = [i.subs(old, new) for i in self.args]\n",
    "sympy.sympy.algebras.quaternion.__new__": "def __new__(cls, a: SExpr = 0, b: SExpr = 0, c: SExpr = 0, d: SExpr = 0,\n                 real_field: bool = True,\n                 norm: SExpr | None = None) -> Quaternion:\n\n    a, b, c, d = map(sympify, (a, b, c, d))\n\n    if any(i.is_commutative is False for i in [a, b, c, d]):\n        raise ValueError(\"arguments have to be commutative\")\n\n    obj = super().__new__(cls, a, b, c, d)\n    obj._real_field = real_field\n    obj.set_norm(norm)\n    return obj",
    "sympy.sympy.algebras.quaternion._check_norm": "def _check_norm(elements: Iterable[Expr], norm: Expr | None) -> None:\n    \"\"\"validate if input norm is consistent\"\"\"\n    if norm is not None and norm.is_number:\n        if norm.is_positive is False:\n            raise ValueError(\"Input norm must be positive.\")\n\n        numerical = all(i.is_number and i.is_real is True for i in elements)\n        if numerical and is_eq(norm**2, sum((i**2 for i in elements), S.Zero)) is False:\n            raise ValueError(\"Incompatible value for norm.\")",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args"
}