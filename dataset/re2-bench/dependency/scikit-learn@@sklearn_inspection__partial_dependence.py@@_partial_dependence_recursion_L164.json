{
    "scikit-learn.sklearn.ensemble._forest._compute_partial_dependence_recursion": "def _compute_partial_dependence_recursion(self, grid, target_features):\n    \"\"\"Fast partial dependence computation.\n\n    Parameters\n    ----------\n    grid : ndarray of shape (n_samples, n_target_features), dtype=DTYPE\n        The grid points on which the partial dependence should be\n        evaluated.\n    target_features : ndarray of shape (n_target_features), dtype=np.intp\n        The set of target features for which the partial dependence\n        should be evaluated.\n\n    Returns\n    -------\n    averaged_predictions : ndarray of shape (n_samples,)\n        The value of the partial dependence function on each grid point.\n    \"\"\"\n    grid = np.asarray(grid, dtype=DTYPE, order=\"C\")\n    target_features = np.asarray(target_features, dtype=np.intp, order=\"C\")\n    averaged_predictions = np.zeros(\n        shape=grid.shape[0], dtype=np.float64, order=\"C\"\n    )\n\n    for tree in self.estimators_:\n        # Note: we don't sum in parallel because the GIL isn't released in\n        # the fast method.\n        tree.tree_.compute_partial_dependence(\n            grid, target_features, averaged_predictions\n        )\n    # Average over the forest\n    averaged_predictions /= len(self.estimators_)\n\n    return averaged_predictions",
    "scikit-learn.sklearn.ensemble._gb._compute_partial_dependence_recursion": "def _compute_partial_dependence_recursion(self, grid, target_features):\n    \"\"\"Fast partial dependence computation.\n\n    Parameters\n    ----------\n    grid : ndarray of shape (n_samples, n_target_features), dtype=np.float32\n        The grid points on which the partial dependence should be\n        evaluated.\n    target_features : ndarray of shape (n_target_features,), dtype=np.intp\n        The set of target features for which the partial dependence\n        should be evaluated.\n\n    Returns\n    -------\n    averaged_predictions : ndarray of shape \\\n            (n_trees_per_iteration_, n_samples)\n        The value of the partial dependence function on each grid point.\n    \"\"\"\n    if self.init is not None:\n        warnings.warn(\n            \"Using recursion method with a non-constant init predictor \"\n            \"will lead to incorrect partial dependence values. \"\n            \"Got init=%s.\" % self.init,\n            UserWarning,\n        )\n    grid = np.asarray(grid, dtype=DTYPE, order=\"C\")\n    n_estimators, n_trees_per_stage = self.estimators_.shape\n    averaged_predictions = np.zeros(\n        (n_trees_per_stage, grid.shape[0]), dtype=np.float64, order=\"C\"\n    )\n    target_features = np.asarray(target_features, dtype=np.intp, order=\"C\")\n\n    for stage in range(n_estimators):\n        for k in range(n_trees_per_stage):\n            tree = self.estimators_[stage, k].tree_\n            tree.compute_partial_dependence(\n                grid, target_features, averaged_predictions[k]\n            )\n    averaged_predictions *= self.learning_rate\n\n    return averaged_predictions",
    "scikit-learn.sklearn.ensemble._hist_gradient_boosting.gradient_boosting._compute_partial_dependence_recursion": "def _compute_partial_dependence_recursion(self, grid, target_features):\n    \"\"\"Fast partial dependence computation.\n\n    Parameters\n    ----------\n    grid : ndarray, shape (n_samples, n_target_features), dtype=np.float32\n        The grid points on which the partial dependence should be\n        evaluated.\n    target_features : ndarray, shape (n_target_features), dtype=np.intp\n        The set of target features for which the partial dependence\n        should be evaluated.\n\n    Returns\n    -------\n    averaged_predictions : ndarray, shape \\\n            (n_trees_per_iteration, n_samples)\n        The value of the partial dependence function on each grid point.\n    \"\"\"\n\n    if getattr(self, \"_fitted_with_sw\", False):\n        raise NotImplementedError(\n            \"{} does not support partial dependence \"\n            \"plots with the 'recursion' method when \"\n            \"sample weights were given during fit \"\n            \"time.\".format(self.__class__.__name__)\n        )\n\n    grid = np.asarray(grid, dtype=X_DTYPE, order=\"C\")\n    averaged_predictions = np.zeros(\n        (self.n_trees_per_iteration_, grid.shape[0]), dtype=Y_DTYPE\n    )\n    target_features = np.asarray(target_features, dtype=np.intp, order=\"C\")\n\n    for predictors_of_ith_iteration in self._predictors:\n        for k, predictor in enumerate(predictors_of_ith_iteration):\n            predictor.compute_partial_dependence(\n                grid, target_features, averaged_predictions[k]\n            )\n    # Note that the learning rate is already accounted for in the leaves\n    # values.\n\n    return averaged_predictions",
    "scikit-learn.sklearn.tree._classes._compute_partial_dependence_recursion": "def _compute_partial_dependence_recursion(self, grid, target_features):\n    \"\"\"Fast partial dependence computation.\n\n    Parameters\n    ----------\n    grid : ndarray of shape (n_samples, n_target_features), dtype=np.float32\n        The grid points on which the partial dependence should be\n        evaluated.\n    target_features : ndarray of shape (n_target_features), dtype=np.intp\n        The set of target features for which the partial dependence\n        should be evaluated.\n\n    Returns\n    -------\n    averaged_predictions : ndarray of shape (n_samples,), dtype=np.float64\n        The value of the partial dependence function on each grid point.\n    \"\"\"\n    grid = np.asarray(grid, dtype=DTYPE, order=\"C\")\n    averaged_predictions = np.zeros(\n        shape=grid.shape[0], dtype=np.float64, order=\"C\"\n    )\n    target_features = np.asarray(target_features, dtype=np.intp, order=\"C\")\n\n    self.tree_.compute_partial_dependence(\n        grid, target_features, averaged_predictions\n    )\n    return averaged_predictions"
}