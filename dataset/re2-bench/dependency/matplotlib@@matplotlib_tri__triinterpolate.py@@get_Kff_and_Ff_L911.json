{
    "matplotlib.lib.matplotlib.tri._triinterpolate._transpose_vectorized": "def _transpose_vectorized(M):\n    \"\"\"\n    Transposition of an array of matrices *M*.\n    \"\"\"\n    return np.transpose(M, [0, 2, 1])",
    "matplotlib.lib.matplotlib.tri._triinterpolate._to_matrix_vectorized": "def _to_matrix_vectorized(M):\n    \"\"\"\n    Build an array of matrices from individuals np.arrays of identical shapes.\n\n    Parameters\n    ----------\n    M\n        ncols-list of nrows-lists of shape sh.\n\n    Returns\n    -------\n    M_res : np.array of shape (sh, nrow, ncols)\n        *M_res* satisfies ``M_res[..., i, j] = M[i][j]``.\n    \"\"\"\n    assert isinstance(M, (tuple, list))\n    assert all(isinstance(item, (tuple, list)) for item in M)\n    c_vec = np.asarray([len(item) for item in M])\n    assert np.all(c_vec-c_vec[0] == 0)\n    r = len(M)\n    c = c_vec[0]\n    M00 = np.asarray(M[0][0])\n    dt = M00.dtype\n    sh = [M00.shape[0], r, c]\n    M_ret = np.empty(sh, dtype=dt)\n    for irow in range(r):\n        for icol in range(c):\n            M_ret[:, irow, icol] = np.asarray(M[irow][icol])\n    return M_ret",
    "matplotlib.lib.matplotlib.tri._triinterpolate.get_bending_matrices": "def get_bending_matrices(self, J, ecc):\n    \"\"\"\n    Parameters\n    ----------\n    *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n    triangle first apex)\n    *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n    eccentricities\n\n    Returns\n    -------\n    Returns the element K matrices for bending energy expressed in\n    GLOBAL nodal coordinates.\n    K_ij = integral [ (d2zi/dx2 + d2zi/dy2) * (d2zj/dx2 + d2zj/dy2) dA]\n    tri_J is needed to rotate dofs from local basis to global basis\n    \"\"\"\n    n = np.size(ecc, 0)\n\n    # 1) matrix to rotate dofs in global coordinates\n    J1 = self.J0_to_J1 @ J\n    J2 = self.J0_to_J2 @ J\n    DOF_rot = np.zeros([n, 9, 9], dtype=np.float64)\n    DOF_rot[:, 0, 0] = 1\n    DOF_rot[:, 3, 3] = 1\n    DOF_rot[:, 6, 6] = 1\n    DOF_rot[:, 1:3, 1:3] = J\n    DOF_rot[:, 4:6, 4:6] = J1\n    DOF_rot[:, 7:9, 7:9] = J2\n\n    # 2) matrix to rotate Hessian in global coordinates.\n    H_rot, area = self.get_Hrot_from_J(J, return_area=True)\n\n    # 3) Computes stiffness matrix\n    # Gauss quadrature.\n    K = np.zeros([n, 9, 9], dtype=np.float64)\n    weights = self.gauss_w\n    pts = self.gauss_pts\n    for igauss in range(self.n_gauss):\n        alpha = np.tile(pts[igauss, :], n).reshape(n, 3)\n        alpha = np.expand_dims(alpha, 2)\n        weight = weights[igauss]\n        d2Skdksi2 = self.get_d2Sidksij2(alpha, ecc)\n        d2Skdx2 = d2Skdksi2 @ H_rot\n        K += weight * (d2Skdx2 @ self.E @ _transpose_vectorized(d2Skdx2))\n\n    # 4) With nodal (not elem) dofs\n    K = _transpose_vectorized(DOF_rot) @ K @ DOF_rot\n\n    # 5) Need the area to compute total element energy\n    return _scalar_vectorized(area, K)"
}