{
    "sympy.sympy.polys.densearith.dmp_quo_ground": "def dmp_quo_ground(\n    f: dmp[Er], c: Er, u: int, K: Domain[Er]\n) -> dmp[Er]:\n    \"\"\"\n    Quotient by a constant in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, ZZ(2))\n    x**2*y + x\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, QQ(2))\n    x**2*y + 3/2*x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_quo_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_quo_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densearith.dmp_neg": "def dmp_neg(f: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Negate a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_neg(x**2*y - x)\n    -x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_neg(_dup(f), K))\n\n    v = u - 1\n\n    return [ dmp_neg(cf, v, K) for cf in f ]",
    "sympy.sympy.polys.densearith.dmp_sub": "def dmp_sub(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Subtract dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sub(x**2 + y, x**2*y + x)\n    -x**2*y + x**2 - x + y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_sub(_dup(f), _dup(g), K))\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return dmp_neg(g, u, K)\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return f\n\n    v = u - 1\n\n    if df == dg:\n        return dmp_strip([ dmp_sub(a, b, v, K) for a, b in zip(f, g) ], u, K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = dmp_neg(g[:k], u, K), g[k:]\n\n        return h + [ dmp_sub(a, b, v, K) for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densebasic.dmp_ground_LC": "def dmp_ground_LC(f: dmp[Er], u: int, K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the ground leading coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_LC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_LC(f, 2, ZZ)\n    1\n\n    \"\"\"\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n\n    return dup_LC(_dup(f), K)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densetools.dmp_ground_trunc": "def dmp_ground_trunc(f: dmp[Eeuclid], p: Eeuclid, u: int, K: Domain[Eeuclid]) -> dmp[Eeuclid]:\n    \"\"\"\n    Reduce a ``K[X]`` polynomial modulo a constant ``p`` in ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y + 8*x**2 + 5*x*y + 6*x + 2*y + 3\n\n    >>> R.dmp_ground_trunc(f, ZZ(3))\n    -x**2 - x*y - y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_trunc(_dup(f), p, K))\n\n    v = u - 1\n\n    return dmp_strip([ dmp_ground_trunc(c, p, v, K) for c in f ], u, K)",
    "sympy.sympy.polys.domains.domain.is_negative": "def is_negative(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is negative. \"\"\"\n    return a < 0 # type: ignore"
}