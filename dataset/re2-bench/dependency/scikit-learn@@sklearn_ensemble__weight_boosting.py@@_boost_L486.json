{
    "scikit-learn.sklearn.base.wrapper": "@functools.wraps(fit_method)\ndef wrapper(estimator, *args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n\n    # we don't want to validate again for each call to partial_fit\n    partial_fit_and_fitted = (\n        fit_method.__name__ == \"partial_fit\" and _is_fitted(estimator)\n    )\n\n    if not global_skip_validation and not partial_fit_and_fitted:\n        estimator._validate_params()\n\n    with config_context(\n        skip_parameter_validation=(\n            prefer_skip_nested_validation or global_skip_validation\n        )\n    ):\n        return fit_method(estimator, *args, **kwargs)",
    "scikit-learn.sklearn.dummy.predict": "def predict(self, X):\n    \"\"\"Perform classification on test vectors X.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_samples, n_features)\n        Test data.\n\n    Returns\n    -------\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n        Predicted target values for X.\n    \"\"\"\n    check_is_fitted(self)\n\n    # numpy random_state expects Python int and not long as size argument\n    # under Windows\n    n_samples = _num_samples(X)\n    rs = check_random_state(self.random_state)\n\n    n_classes_ = self.n_classes_\n    classes_ = self.classes_\n    class_prior_ = self.class_prior_\n    constant = self.constant\n    if self.n_outputs_ == 1:\n        # Get same type even for self.n_outputs_ == 1\n        n_classes_ = [n_classes_]\n        classes_ = [classes_]\n        class_prior_ = [class_prior_]\n        constant = [constant]\n    # Compute probability only once\n    if self._strategy == \"stratified\":\n        proba = self.predict_proba(X)\n        if self.n_outputs_ == 1:\n            proba = [proba]\n\n    if self.sparse_output_:\n        class_prob = None\n        if self._strategy in (\"most_frequent\", \"prior\"):\n            classes_ = [np.array([cp.argmax()]) for cp in class_prior_]\n\n        elif self._strategy == \"stratified\":\n            class_prob = class_prior_\n\n        elif self._strategy == \"uniform\":\n            raise ValueError(\n                \"Sparse target prediction is not \"\n                \"supported with the uniform strategy\"\n            )\n\n        elif self._strategy == \"constant\":\n            classes_ = [np.array([c]) for c in constant]\n\n        y = _random_choice_csc(n_samples, classes_, class_prob, self.random_state)\n    else:\n        if self._strategy in (\"most_frequent\", \"prior\"):\n            y = np.tile(\n                [\n                    classes_[k][class_prior_[k].argmax()]\n                    for k in range(self.n_outputs_)\n                ],\n                [n_samples, 1],\n            )\n\n        elif self._strategy == \"stratified\":\n            y = np.vstack(\n                [\n                    classes_[k][proba[k].argmax(axis=1)]\n                    for k in range(self.n_outputs_)\n                ]\n            ).T\n\n        elif self._strategy == \"uniform\":\n            ret = [\n                classes_[k][rs.randint(n_classes_[k], size=n_samples)]\n                for k in range(self.n_outputs_)\n            ]\n            y = np.vstack(ret).T\n\n        elif self._strategy == \"constant\":\n            y = np.tile(self.constant, (n_samples, 1))\n\n        if self.n_outputs_ == 1:\n            y = np.ravel(y)\n\n    return y",
    "scikit-learn.sklearn.ensemble._base._make_estimator": "def _make_estimator(self, append=True, random_state=None):\n    \"\"\"Make and configure a copy of the `estimator_` attribute.\n\n    Warning: This method should be used to properly instantiate new\n    sub-estimators.\n    \"\"\"\n    estimator = clone(self.estimator_)\n    estimator.set_params(**{p: getattr(self, p) for p in self.estimator_params})\n\n    if random_state is not None:\n        _set_random_states(estimator, random_state)\n\n    if append:\n        self.estimators_.append(estimator)\n\n    return estimator",
    "scikit-learn.sklearn.ensemble._forest.predict": "def predict(self, X):\n    \"\"\"\n    Predict class for X.\n\n    The predicted class of an input sample is a vote by the trees in\n    the forest, weighted by their probability estimates. That is,\n    the predicted class is the one with highest mean probability\n    estimate across the trees.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The input samples. Internally, its dtype will be converted to\n        ``dtype=np.float32``. If a sparse matrix is provided, it will be\n        converted into a sparse ``csr_matrix``.\n\n    Returns\n    -------\n    y : ndarray of shape (n_samples,) or (n_samples, n_outputs)\n        The predicted classes.\n    \"\"\"\n    proba = self.predict_proba(X)\n\n    if self.n_outputs_ == 1:\n        return self.classes_.take(np.argmax(proba, axis=1), axis=0)\n\n    else:\n        n_samples = proba[0].shape[0]\n        # all dtypes should be the same, so just take the first\n        class_type = self.classes_[0].dtype\n        predictions = np.empty((n_samples, self.n_outputs_), dtype=class_type)\n\n        for k in range(self.n_outputs_):\n            predictions[:, k] = self.classes_[k].take(\n                np.argmax(proba[k], axis=1), axis=0\n            )\n\n        return predictions",
    "scikit-learn.sklearn.svm._base.predict": "def predict(self, X):\n    \"\"\"Perform classification on samples in X.\n\n    For a one-class model, +1 or -1 is returned.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features) or \\\n            (n_samples_test, n_samples_train)\n        For kernel=\"precomputed\", the expected shape of X is\n        (n_samples_test, n_samples_train).\n\n    Returns\n    -------\n    y_pred : ndarray of shape (n_samples,)\n        Class labels for samples in X.\n    \"\"\"\n    check_is_fitted(self)\n    if self.break_ties and self.decision_function_shape == \"ovo\":\n        raise ValueError(\n            \"break_ties must be False when decision_function_shape is 'ovo'\"\n        )\n\n    if (\n        self.break_ties\n        and self.decision_function_shape == \"ovr\"\n        and len(self.classes_) > 2\n    ):\n        y = np.argmax(self.decision_function(X), axis=1)\n    else:\n        y = super().predict(X)\n    return self.classes_.take(np.asarray(y, dtype=np.intp))",
    "scikit-learn.sklearn.tree._classes.predict": "def predict(self, X, check_input=True):\n    \"\"\"Predict class or regression value for X.\n\n    For a classification model, the predicted class for each sample in X is\n    returned. For a regression model, the predicted value based on X is\n    returned.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The input samples. Internally, it will be converted to\n        ``dtype=np.float32`` and if a sparse matrix is provided\n        to a sparse ``csr_matrix``.\n\n    check_input : bool, default=True\n        Allow to bypass several input checking.\n        Don't use this parameter unless you know what you're doing.\n\n    Returns\n    -------\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n        The predicted classes, or the predict values.\n    \"\"\"\n    check_is_fitted(self)\n    X = self._validate_X_predict(X, check_input)\n    proba = self.tree_.predict(X)\n    n_samples = X.shape[0]\n\n    # Classification\n    if is_classifier(self):\n        if self.n_outputs_ == 1:\n            return self.classes_.take(np.argmax(proba, axis=1), axis=0)\n\n        else:\n            class_type = self.classes_[0].dtype\n            predictions = np.zeros((n_samples, self.n_outputs_), dtype=class_type)\n            for k in range(self.n_outputs_):\n                predictions[:, k] = self.classes_[k].take(\n                    np.argmax(proba[:, k], axis=1), axis=0\n                )\n\n            return predictions\n\n    # Regression\n    else:\n        if self.n_outputs_ == 1:\n            return proba[:, 0]\n\n        else:\n            return proba[:, :, 0]"
}