{
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule):\n    \"\"\"\n    Replace occurrences of objects within the expression.\n\n    Parameters\n    ==========\n\n    rule : dict-like\n        Expresses a replacement rule\n\n    Returns\n    =======\n\n    xreplace : the result of the replacement\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, pi, exp\n    >>> x, y, z = symbols('x y z')\n    >>> (1 + x*y).xreplace({x: pi})\n    pi*y + 1\n    >>> (1 + x*y).xreplace({x: pi, y: 2})\n    1 + 2*pi\n\n    Replacements occur only if an entire node in the expression tree is\n    matched:\n\n    >>> (x*y + z).xreplace({x*y: pi})\n    z + pi\n    >>> (x*y*z).xreplace({x*y: pi})\n    x*y*z\n    >>> (2*x).xreplace({2*x: y, x: z})\n    y\n    >>> (2*2*x).xreplace({2*x: y, x: z})\n    4*z\n    >>> (x + y + 2).xreplace({x + y: 2})\n    x + y + 2\n    >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n    x + exp(y) + 2\n\n    xreplace does not differentiate between free and bound symbols. In the\n    following, subs(x, y) would not change x since it is a bound symbol,\n    but xreplace does:\n\n    >>> from sympy import Integral\n    >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n    Integral(y, (y, 1, 2*y))\n\n    Trying to replace x with an expression raises an error:\n\n    >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n    ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n\n    \"\"\"\n    value, _ = self._xreplace(rule)\n    return value",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.operations._from_args": "@classmethod\ndef _from_args(cls, args, is_commutative=None):\n    \"\"\"Create new instance with already-processed args.\n    If the args are not in canonical order, then a non-canonical\n    result will be returned, so use with caution. The order of\n    args may change if the sign of the args is changed.\"\"\"\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and(a.is_commutative for a in args)\n    obj.is_commutative = is_commutative\n    return obj",
    "sympy.sympy.core.traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    "sympy.sympy.core.traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    "sympy.sympy.core.traversal.__iter__": "def __iter__(self) -> Iterator[Basic]:\n    return self"
}