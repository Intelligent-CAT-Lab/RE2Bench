{
    "scikit-learn.sklearn.svm._base._compute_kernel": "def _compute_kernel(self, X):\n    \"\"\"Return the data transformed by a callable kernel\"\"\"\n    if callable(self.kernel):\n        # in the case of precomputed kernel given as a function, we\n        # have to compute explicitly the kernel matrix\n        kernel = self.kernel(X, self.__Xfit)\n        if sp.issparse(kernel):\n            kernel = kernel.toarray()\n        X = np.asarray(kernel, dtype=np.float64, order=\"C\")\n    return X",
    "scikit-learn.sklearn.svm._base._dense_decision_function": "def _dense_decision_function(self, X):\n    X = check_array(X, dtype=np.float64, order=\"C\", accept_large_sparse=False)\n\n    kernel = self.kernel\n    if callable(kernel):\n        kernel = \"precomputed\"\n\n    return libsvm.decision_function(\n        X,\n        self.support_,\n        self.support_vectors_,\n        self._n_support,\n        self._dual_coef_,\n        self._intercept_,\n        self._probA,\n        self._probB,\n        svm_type=LIBSVM_IMPL.index(self._impl),\n        kernel=kernel,\n        degree=self.degree,\n        cache_size=self.cache_size,\n        coef0=self.coef0,\n        gamma=self._gamma,\n    )",
    "scikit-learn.sklearn.svm._base._sparse_decision_function": "def _sparse_decision_function(self, X):\n    X.data = np.asarray(X.data, dtype=np.float64, order=\"C\")\n\n    kernel = self.kernel\n    if hasattr(kernel, \"__call__\"):\n        kernel = \"precomputed\"\n\n    kernel_type = self._sparse_kernels.index(kernel)\n\n    return libsvm_sparse.libsvm_sparse_decision_function(\n        X.data,\n        X.indices,\n        X.indptr,\n        self.support_vectors_.data,\n        self.support_vectors_.indices,\n        self.support_vectors_.indptr,\n        self._dual_coef_.data,\n        self._intercept_,\n        LIBSVM_IMPL.index(self._impl),\n        kernel_type,\n        self.degree,\n        self._gamma,\n        self.coef0,\n        self.tol,\n        self.C,\n        getattr(self, \"class_weight_\", np.empty(0)),\n        self.nu,\n        self.epsilon,\n        self.shrinking,\n        self.probability,\n        self._n_support,\n        self._probA,\n        self._probB,\n    )",
    "scikit-learn.sklearn.svm._base._validate_for_predict": "def _validate_for_predict(self, X):\n    check_is_fitted(self)\n\n    if not callable(self.kernel):\n        X = validate_data(\n            self,\n            X,\n            accept_sparse=\"csr\",\n            dtype=np.float64,\n            order=\"C\",\n            accept_large_sparse=False,\n            reset=False,\n        )\n\n    if self._sparse and not sp.issparse(X):\n        X = sp.csr_matrix(X)\n    if self._sparse:\n        X.sort_indices()\n\n    if sp.issparse(X) and not self._sparse and not callable(self.kernel):\n        raise ValueError(\n            \"cannot use sparse input in %r trained on dense data\"\n            % type(self).__name__\n        )\n\n    if self.kernel == \"precomputed\":\n        if X.shape[1] != self.shape_fit_[0]:\n            raise ValueError(\n                \"X.shape[1] = %d should be equal to %d, \"\n                \"the number of samples at training time\"\n                % (X.shape[1], self.shape_fit_[0])\n            )\n    # Fixes https://nvd.nist.gov/vuln/detail/CVE-2020-28975\n    # Check that _n_support is consistent with support_vectors\n    sv = self.support_vectors_\n    if not self._sparse and sv.size > 0 and self.n_support_.sum() != sv.shape[0]:\n        raise ValueError(\n            f\"The internal representation of {self.__class__.__name__} was altered\"\n        )\n    return X"
}