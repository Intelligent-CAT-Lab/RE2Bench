{
    "scikit-learn.sklearn.model_selection._search._check_scorers_accept_sample_weight": "def _check_scorers_accept_sample_weight(self):\n    # TODO(slep006): remove when metadata routing is the only way\n    scorers, _ = self._get_scorers()\n    # In the multimetric case, warn the user for each scorer separately\n    if isinstance(scorers, _MultimetricScorer):\n        for name, scorer in scorers._scorers.items():\n            if not scorer._accept_sample_weight():\n                warnings.warn(\n                    f\"The scoring {name}={scorer} does not support sample_weight, \"\n                    \"which may lead to statistically incorrect results when \"\n                    f\"fitting {self} with sample_weight. \"\n                )\n        return scorers._accept_sample_weight()\n    # In most cases, scorers is a Scorer object\n    # But it's a function when user passes scoring=function\n    if hasattr(scorers, \"_accept_sample_weight\"):\n        accept = scorers._accept_sample_weight()\n    else:\n        accept = \"sample_weight\" in signature(scorers).parameters\n    if not accept:\n        warnings.warn(\n            f\"The scoring {scorers} does not support sample_weight, \"\n            \"which may lead to statistically incorrect results when \"\n            f\"fitting {self} with sample_weight. \"\n        )\n    return accept",
    "scikit-learn.sklearn.utils._bunch.__init__": "def __init__(self, **kwargs):\n    super().__init__(kwargs)\n\n    # Map from deprecated key to warning message\n    self.__dict__[\"_deprecated_key_to_warnings\"] = {}",
    "scikit-learn.sklearn.utils._bunch.__getattr__": "def __getattr__(self, key):\n    try:\n        return self[key]\n    except KeyError:\n        raise AttributeError(key)",
    "scikit-learn.sklearn.utils._metadata_requests.process_routing": "def process_routing(_obj, _method, /, **kwargs):\n    \"\"\"Validate and route metadata.\n\n    This function is used inside a :term:`router`'s method, e.g. :term:`fit`,\n    to validate the metadata and handle the routing.\n\n    Assuming this signature of a router's fit method:\n    ``fit(self, X, y, sample_weight=None, **fit_params)``,\n    a call to this function would be:\n    ``process_routing(self, \"fit\", sample_weight=sample_weight, **fit_params)``.\n\n    Note that if routing is not enabled and ``kwargs`` is empty, then it\n    returns an empty routing where ``process_routing(...).ANYTHING.ANY_METHOD``\n    is always an empty dictionary.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    _obj : object\n        An object implementing ``get_metadata_routing``. Typically a\n        :term:`meta-estimator`.\n\n    _method : str\n        The name of the router's method in which this function is called.\n\n    **kwargs : dict\n        Metadata to be routed.\n\n    Returns\n    -------\n    routed_params : Bunch\n        A :class:`~utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        A :class:`~sklearn.utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        corresponding methods or corresponding child objects. The object names\n        are those defined in `obj.get_metadata_routing()`.\n    \"\"\"\n    if not kwargs:\n        # If routing is not enabled and kwargs are empty, then we don't have to\n        # try doing any routing, we can simply return a structure which returns\n        # an empty dict on routed_params.ANYTHING.ANY_METHOD.\n        class EmptyRequest:\n            def get(self, name, default=None):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getitem__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getattr__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n        return EmptyRequest()\n\n    if not (hasattr(_obj, \"get_metadata_routing\") or isinstance(_obj, MetadataRouter)):\n        raise AttributeError(\n            f\"The given object ({_routing_repr(_obj)}) needs to either\"\n            \" implement the routing method `get_metadata_routing` or be a\"\n            \" `MetadataRouter` instance.\"\n        )\n    if _method not in METHODS:\n        raise TypeError(\n            f\"Can only route and process input on these methods: {METHODS}, \"\n            f\"while the passed method is: {_method}.\"\n        )\n\n    request_routing = get_routing_for_object(_obj)\n    request_routing.validate_metadata(params=kwargs, method=_method)\n    routed_params = request_routing.route_params(params=kwargs, caller=_method)\n\n    return routed_params",
    "scikit-learn.sklearn.utils._metadata_requests._routing_enabled": "def _routing_enabled():\n    \"\"\"Return whether metadata routing is enabled.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    enabled : bool\n        Whether metadata routing is enabled. If the config is not set, it\n        defaults to False.\n    \"\"\"\n    return get_config().get(\"enable_metadata_routing\", False)"
}