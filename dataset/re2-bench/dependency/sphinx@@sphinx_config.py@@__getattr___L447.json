{
    "sphinx.sphinx.builders.epub3.<lambda>": "lambda self: self.html_use_index,\n",
    "sphinx.sphinx.builders.html.__init__.<lambda>": "'html_short_title', lambda self: self.html_title, 'html', types=frozenset({str})\n",
    "sphinx.sphinx.builders.latex.__init__.default_latex_engine": "def default_latex_engine(config: Config) -> str:\n    \"\"\"Better default latex_engine settings for specific languages.\"\"\"\n    if config.language == 'ja':\n        return 'uplatex'\n    if config.language.startswith('zh'):\n        return 'xelatex'\n    if config.language == 'el':\n        return 'xelatex'\n    return 'pdflatex'",
    "sphinx.sphinx.builders.latex.__init__.default_latex_docclass": "def default_latex_docclass(config: Config) -> dict[str, str]:\n    \"\"\"Better default latex_docclass settings for specific languages.\"\"\"\n    if config.language == 'ja':\n        if config.latex_engine == 'uplatex':\n            return {'manual': 'ujbook', 'howto': 'ujreport'}\n        else:\n            return {'manual': 'jsbook', 'howto': 'jreport'}\n    else:\n        return {}",
    "sphinx.sphinx.builders.latex.__init__.default_latex_use_xindy": "def default_latex_use_xindy(config: Config) -> bool:\n    \"\"\"Better default latex_use_xindy settings for specific engines.\"\"\"\n    return config.latex_engine in {'xelatex', 'lualatex'}",
    "sphinx.sphinx.builders.latex.__init__.default_latex_documents": "def default_latex_documents(config: Config) -> list[tuple[str, str, str, str, str]]:\n    \"\"\"Better default latex_documents settings.\"\"\"\n    project = texescape.escape(config.project, config.latex_engine)\n    author = texescape.escape(config.author, config.latex_engine)\n    return [\n        (\n            config.root_doc,\n            make_filename_from_project(config.project) + '.tex',\n            texescape.escape_abbr(project),\n            texescape.escape_abbr(author),\n            config.latex_theme,\n        )\n    ]",
    "sphinx.sphinx.builders.manpage.default_man_pages": "def default_man_pages(config: Config) -> list[tuple[str, str, str, list[str], int]]:\n    \"\"\"Better default man_pages settings.\"\"\"\n    filename = make_filename_from_project(config.project)\n    return [\n        (\n            config.root_doc,\n            filename,\n            f'{config.project} {config.release}',\n            [config.author],\n            1,\n        )\n    ]",
    "sphinx.sphinx.builders.singlehtml.<lambda>": "lambda self: self.html_sidebars,\n",
    "sphinx.sphinx.builders.texinfo.default_texinfo_documents": "def default_texinfo_documents(\n    config: Config,\n) -> list[tuple[str, str, str, str, str, str, str]]:\n    \"\"\"Better default texinfo_documents settings.\"\"\"\n    filename = make_filename_from_project(config.project)\n    return [\n        (\n            config.root_doc,\n            filename,\n            config.project,\n            config.author,\n            filename,\n            'One line description of project',\n            'Miscellaneous',\n        )\n    ]",
    "sphinx.sphinx.config.<lambda>": "'root_doc': _Opt(lambda config: config.master_doc, 'env', frozenset((str,))),\n# ``source_suffix`` type is actually ``dict[str, str | None]``:\n# see ``convert_source_suffix()`` below.\n",
    "sphinx.sphinx.config.convert_overrides": "def convert_overrides(self, name: str, value: str) -> Any:\n    opt = self._options[name]\n    default = opt.default\n    valid_types = opt.valid_types\n    if valid_types == Any:\n        return value\n    if isinstance(valid_types, ENUM):\n        if False in valid_types._candidates and value == '0':\n            return False\n        if True in valid_types._candidates and value == '1':\n            return True\n        return value\n    elif type(default) is bool or (bool in valid_types):\n        if value == '0':\n            return False\n        if value == '1':\n            return True\n        if len(valid_types) > 1:\n            return value\n        msg = __(\"'%s' must be '0' or '1', got '%s'\") % (name, value)\n        raise ConfigError(msg)\n    if isinstance(default, dict):\n        raise ValueError(  # NoQA: TRY004\n            __(\n                'cannot override dictionary config setting %r, '\n                'ignoring (use %r to set individual elements)'\n            )\n            % (name, f'{name}.key=value')\n        )\n    if isinstance(default, list):\n        return value.split(',')\n    if isinstance(default, int):\n        try:\n            return int(value)\n        except ValueError as exc:\n            raise ValueError(\n                __('invalid number %r for config value %r, ignoring')\n                % (value, name)\n            ) from exc\n    if callable(default):\n        return value\n    if isinstance(default, str) or default is None:\n        return value\n    raise ValueError(\n        __('cannot override config setting %r with unsupported type, ignoring')\n        % name\n    )",
    "sphinx.sphinx.config.__setattr__": "def __setattr__(self, key: str, value: object) -> None:\n    # Ensure aliases update their counterpart.\n    if key == 'master_doc':\n        super().__setattr__('root_doc', value)\n    elif key == 'root_doc':\n        super().__setattr__('master_doc', value)\n    elif key == 'copyright':\n        super().__setattr__('project_copyright', value)\n    elif key == 'project_copyright':\n        super().__setattr__('copyright', value)\n    super().__setattr__(key, value)",
    "sphinx.sphinx.ext.mathjax.<lambda>": "lambda c: c.mathjax_config,\n",
    "sphinx.sphinx.locale.__init__.gettext": "def gettext(message: str) -> str:\n    if not is_translator_registered(catalog, namespace):\n        # not initialized yet\n        return _TranslationProxy(catalog, namespace, message)  # type: ignore[return-value]\n    else:\n        translator = get_translator(catalog, namespace)\n        return translator.gettext(message)",
    "sphinx.sphinx.locale.__init__.__mod__": "def __mod__(self, other: str) -> str:\n    return self.__str__() % other"
}