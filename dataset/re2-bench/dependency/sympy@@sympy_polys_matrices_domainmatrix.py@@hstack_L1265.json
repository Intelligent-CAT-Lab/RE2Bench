{
    "sympy.sympy.polys.matrices.ddm.hstack": "def hstack(A, *B):\n    \"\"\"Horizontally stacks :py:class:`~.DDM` matrices.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices.sdm import DDM\n\n    >>> A = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> B = DDM([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n    >>> A.hstack(B)\n    [[1, 2, 5, 6], [3, 4, 7, 8]]\n\n    >>> C = DDM([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n    >>> A.hstack(B, C)\n    [[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]]\n    \"\"\"\n    Anew = list(A.copy())\n    rows, cols = A.shape\n    domain = A.domain\n\n    for Bk in B:\n        Bkrows, Bkcols = Bk.shape\n        assert Bkrows == rows\n        assert Bk.domain == domain\n\n        cols += Bkcols\n\n        for i, Bki in enumerate(Bk):\n            Anew[i].extend(Bki)\n\n    return DDM(Anew, (rows, cols), A.domain)",
    "sympy.sympy.polys.matrices.domainmatrix.<genexpr>": "return DomainMatrix.from_rep(A.rep.hstack(*(Bk.rep for Bk in B)))\n\n",
    "sympy.sympy.polys.matrices.domainmatrix.from_rep": "@classmethod\ndef from_rep(cls, rep):\n    \"\"\"Create a new DomainMatrix efficiently from DDM/SDM.\n\n    Examples\n    ========\n\n    Create a :py:class:`~.DomainMatrix` with an dense internal\n    representation as :py:class:`~.DDM`:\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.ddm import DDM\n    >>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n    Create a :py:class:`~.DomainMatrix` with a sparse internal\n    representation as :py:class:`~.SDM`:\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import ZZ\n    >>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)\n\n    Parameters\n    ==========\n\n    rep: SDM or DDM\n        The internal sparse or dense representation of the matrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        A :py:class:`~.DomainMatrix` wrapping *rep*.\n\n    Notes\n    =====\n\n    This takes ownership of rep as its internal representation. If rep is\n    being mutated elsewhere then a copy should be provided to\n    ``from_rep``. Only minimal verification or checking is done on *rep*\n    as this is supposed to be an efficient internal routine.\n\n    \"\"\"\n    if not (isinstance(rep, (DDM, SDM)) or (DFM is not None and isinstance(rep, DFM))):\n        raise TypeError(\"rep should be of type DDM or SDM\")\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    "sympy.sympy.polys.matrices.domainmatrix.unify": "def unify(self, *others, fmt=None):\n    \"\"\"\n    Unifies the domains and the format of self and other\n    matrices.\n\n    Parameters\n    ==========\n\n    others : DomainMatrix\n\n    fmt: string 'dense', 'sparse' or `None` (default)\n        The preferred format to convert to if self and other are not\n        already in the same format. If `None` or not specified then no\n        conversion if performed.\n\n    Returns\n    =======\n\n    Tuple[DomainMatrix]\n        Matrices with unified domain and format\n\n    Examples\n    ========\n\n    Unify the domain of DomainMatrix that have different domains:\n\n    >>> from sympy import ZZ, QQ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)\n    >>> Aq, Bq = A.unify(B)\n    >>> Aq\n    DomainMatrix([[1, 2]], (1, 2), QQ)\n    >>> Bq\n    DomainMatrix([[1/2, 2]], (1, 2), QQ)\n\n    Unify the format (dense or sparse):\n\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)\n    >>> B.rep\n    {0: {0: 1}}\n\n    >>> A2, B2 = A.unify(B, fmt='dense')\n    >>> B2.rep\n    [[1, 0], [0, 0]]\n\n    See Also\n    ========\n\n    convert_to, to_dense, to_sparse\n\n    \"\"\"\n    matrices = (self,) + others\n    matrices = DomainMatrix._unify_domain(*matrices)\n    if fmt is not None:\n        matrices = DomainMatrix._unify_fmt(*matrices, fmt=fmt)\n    return matrices",
    "sympy.sympy.polys.matrices.sdm.hstack": "def hstack(A, *B):\n    \"\"\"Horizontally stacks :py:class:`~.SDM` matrices.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices.sdm import SDM\n\n    >>> A = SDM({0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}, (2, 2), ZZ)\n    >>> B = SDM({0: {0: ZZ(5), 1: ZZ(6)}, 1: {0: ZZ(7), 1: ZZ(8)}}, (2, 2), ZZ)\n    >>> A.hstack(B)\n    {0: {0: 1, 1: 2, 2: 5, 3: 6}, 1: {0: 3, 1: 4, 2: 7, 3: 8}}\n\n    >>> C = SDM({0: {0: ZZ(9), 1: ZZ(10)}, 1: {0: ZZ(11), 1: ZZ(12)}}, (2, 2), ZZ)\n    >>> A.hstack(B, C)\n    {0: {0: 1, 1: 2, 2: 5, 3: 6, 4: 9, 5: 10}, 1: {0: 3, 1: 4, 2: 7, 3: 8, 4: 11, 5: 12}}\n    \"\"\"\n    Anew = dict(A.copy())\n    rows, cols = A.shape\n    domain = A.domain\n\n    for Bk in B:\n        Bkrows, Bkcols = Bk.shape\n        assert Bkrows == rows\n        assert Bk.domain == domain\n\n        for i, Bki in Bk.items():\n            Ai = Anew.get(i, None)\n            if Ai is None:\n                Anew[i] = Ai = {}\n            for j, Bkij in Bki.items():\n                Ai[j + cols] = Bkij\n        cols += Bkcols\n\n    return A.new(Anew, (rows, cols), A.domain)"
}