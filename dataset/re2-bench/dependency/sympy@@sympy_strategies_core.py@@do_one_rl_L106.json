{
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.integrals.manualintegrate.fallback_rule": "def fallback_rule(integral):\n    return DontKnowRule(*integral)",
    "sympy.sympy.matrices.expressions.blockmatrix.bc_unpack": "def bc_unpack(expr):\n    if expr.blockshape == (1, 1):\n        return expr.blocks[0, 0]\n    return expr",
    "sympy.sympy.matrices.expressions.blockmatrix.bc_matadd": "def bc_matadd(expr):\n    args = sift(expr.args, lambda M: isinstance(M, BlockMatrix))\n    blocks = args[True]\n    if not blocks:\n        return expr\n\n    nonblocks = args[False]\n    block = blocks[0]\n    for b in blocks[1:]:\n        block = block._blockadd(b)\n    if nonblocks:\n        return MatAdd(*nonblocks) + block\n    else:\n        return block",
    "sympy.sympy.matrices.expressions.blockmatrix.bc_block_plus_ident": "def bc_block_plus_ident(expr):\n    idents = [arg for arg in expr.args if arg.is_Identity]\n    if not idents:\n        return expr\n\n    blocks = [arg for arg in expr.args if isinstance(arg, BlockMatrix)]\n    if (blocks and all(b.structurally_equal(blocks[0]) for b in blocks)\n               and blocks[0].is_structurally_symmetric):\n        block_id = BlockDiagMatrix(*[Identity(k)\n                                        for k in blocks[0].rowblocksizes])\n        rest = [arg for arg in expr.args if not arg.is_Identity and not isinstance(arg, BlockMatrix)]\n        return MatAdd(block_id * len(idents), *blocks, *rest).doit()\n\n    return expr",
    "sympy.sympy.matrices.expressions.blockmatrix.bc_dist": "def bc_dist(expr):\n    \"\"\" Turn  a*[X, Y] into [a*X, a*Y] \"\"\"\n    factor, mat = expr.as_coeff_mmul()\n    if factor == 1:\n        return expr\n\n    unpacked = unpack(mat)\n\n    if isinstance(unpacked, BlockDiagMatrix):\n        B = unpacked.diag\n        new_B = [factor * mat for mat in B]\n        return BlockDiagMatrix(*new_B)\n    elif isinstance(unpacked, BlockMatrix):\n        B = unpacked.blocks\n        new_B = [\n            [factor * B[i, j] for j in range(B.cols)] for i in range(B.rows)]\n        return BlockMatrix(new_B)\n    return expr",
    "sympy.sympy.matrices.expressions.blockmatrix.bc_matmul": "def bc_matmul(expr):\n    if isinstance(expr, MatPow):\n        if expr.args[1].is_Integer and expr.args[1] > 0:\n            factor, matrices = 1, [expr.args[0]]*expr.args[1]\n        else:\n            return expr\n    else:\n        factor, matrices = expr.as_coeff_matrices()\n\n    i = 0\n    while (i+1 < len(matrices)):\n        A, B = matrices[i:i+2]\n        if isinstance(A, BlockMatrix) and isinstance(B, BlockMatrix):\n            matrices[i] = A._blockmul(B)\n            matrices.pop(i+1)\n        elif isinstance(A, BlockMatrix):\n            matrices[i] = A._blockmul(BlockMatrix([[B]]))\n            matrices.pop(i+1)\n        elif isinstance(B, BlockMatrix):\n            matrices[i] = BlockMatrix([[A]])._blockmul(B)\n            matrices.pop(i+1)\n        else:\n            i+=1\n    return MatMul(factor, *matrices).doit()",
    "sympy.sympy.matrices.expressions.blockmatrix.deblock": "def deblock(B):\n    \"\"\" Flatten a BlockMatrix of BlockMatrices \"\"\"\n    if not isinstance(B, BlockMatrix) or not B.blocks.has(BlockMatrix):\n        return B\n    wrap = lambda x: x if isinstance(x, BlockMatrix) else BlockMatrix([[x]])\n    bb = B.blocks.applyfunc(wrap)  # everything is a block\n\n    try:\n        MM = Matrix(0, sum(bb[0, i].blocks.shape[1] for i in range(bb.shape[1])), [])\n        for row in range(0, bb.shape[0]):\n            M = Matrix(bb[row, 0].blocks)\n            for col in range(1, bb.shape[1]):\n                M = M.row_join(bb[row, col].blocks)\n            MM = MM.col_join(M)\n\n        return BlockMatrix(MM)\n    except ShapeError:\n        return B",
    "sympy.sympy.matrices.expressions.kronecker.extract_commutative": "def extract_commutative(kron):\n    c_part = []\n    nc_part = []\n    for arg in kron.args:\n        c, nc = arg.args_cnc()\n        c_part.extend(c)\n        nc_part.append(Mul._from_args(nc))\n\n    c_part = Mul(*c_part)\n    if c_part != 1:\n        return c_part*KroneckerProduct(*nc_part)\n    return kron",
    "sympy.sympy.matrices.expressions.kronecker.explicit_kronecker_product": "def explicit_kronecker_product(kron):\n    # Make sure we have a sequence of Matrices\n    if not all(isinstance(m, MatrixBase) for m in kron.args):\n        return kron\n\n    return matrix_kronecker_product(*kron.args)",
    "sympy.sympy.matrices.expressions.matadd.merge_explicit": "def merge_explicit(matadd):\n    \"\"\" Merge explicit MatrixBase arguments\n\n    Examples\n    ========\n\n    >>> from sympy import MatrixSymbol, eye, Matrix, MatAdd, pprint\n    >>> from sympy.matrices.expressions.matadd import merge_explicit\n    >>> A = MatrixSymbol('A', 2, 2)\n    >>> B = eye(2)\n    >>> C = Matrix([[1, 2], [3, 4]])\n    >>> X = MatAdd(A, B, C)\n    >>> pprint(X)\n        [1  0]   [1  2]\n    A + [    ] + [    ]\n        [0  1]   [3  4]\n    >>> pprint(merge_explicit(X))\n        [2  2]\n    A + [    ]\n        [3  5]\n    \"\"\"\n    groups = sift(matadd.args, lambda arg: isinstance(arg, MatrixBase))\n    if len(groups[True]) > 1:\n        return MatAdd(*(groups[False] + [reduce(operator.add, groups[True])]))\n    else:\n        return matadd",
    "sympy.sympy.matrices.expressions.matmul.any_zeros": "def any_zeros(mul):\n    if any(arg.is_zero or (arg.is_Matrix and arg.is_ZeroMatrix)\n                       for arg in mul.args):\n        matrices = [arg for arg in mul.args if arg.is_Matrix]\n        return ZeroMatrix(matrices[0].rows, matrices[-1].cols)\n    return mul",
    "sympy.sympy.matrices.expressions.matmul.merge_explicit": "def merge_explicit(matmul):\n    \"\"\" Merge explicit MatrixBase arguments\n\n    >>> from sympy import MatrixSymbol, Matrix, MatMul, pprint\n    >>> from sympy.matrices.expressions.matmul import merge_explicit\n    >>> A = MatrixSymbol('A', 2, 2)\n    >>> B = Matrix([[1, 1], [1, 1]])\n    >>> C = Matrix([[1, 2], [3, 4]])\n    >>> X = MatMul(A, B, C)\n    >>> pprint(X)\n      [1  1] [1  2]\n    A*[    ]*[    ]\n      [1  1] [3  4]\n    >>> pprint(merge_explicit(X))\n      [4  6]\n    A*[    ]\n      [4  6]\n\n    >>> X = MatMul(B, A, C)\n    >>> pprint(X)\n    [1  1]   [1  2]\n    [    ]*A*[    ]\n    [1  1]   [3  4]\n    >>> pprint(merge_explicit(X))\n    [1  1]   [1  2]\n    [    ]*A*[    ]\n    [1  1]   [3  4]\n    \"\"\"\n    if not any(isinstance(arg, MatrixBase) for arg in matmul.args):\n        return matmul\n    newargs = []\n    last = matmul.args[0]\n    for arg in matmul.args[1:]:\n        if isinstance(arg, (MatrixBase, Number)) and isinstance(last, (MatrixBase, Number)):\n            last = last * arg\n        else:\n            newargs.append(last)\n            last = arg\n    newargs.append(last)\n\n    return MatMul(*newargs)",
    "sympy.sympy.matrices.expressions.matmul.remove_ids": "def remove_ids(mul):\n    \"\"\" Remove Identities from a MatMul\n\n    This is a modified version of sympy.strategies.rm_id.\n    This is necessary because MatMul may contain both MatrixExprs and Exprs\n    as args.\n\n    See Also\n    ========\n\n    sympy.strategies.rm_id\n    \"\"\"\n    # Separate Exprs from MatrixExprs in args\n    factor, mmul = mul.as_coeff_mmul()\n    # Apply standard rm_id for MatMuls\n    result = rm_id(lambda x: x.is_Identity is True)(mmul)\n    if result != mmul:\n        return newmul(factor, *result.args)  # Recombine and return\n    else:\n        return mul",
    "sympy.sympy.matrices.expressions.matmul.factor_in_front": "def factor_in_front(mul):\n    factor, matrices = mul.as_coeff_matrices()\n    if factor != 1:\n        return newmul(factor, *matrices)\n    return mul",
    "sympy.sympy.matrices.expressions.matmul.combine_powers": "def combine_powers(mul):\n    r\"\"\"Combine consecutive powers with the same base into one, e.g.\n    $$A \\times A^2 \\Rightarrow A^3$$\n\n    This also cancels out the possible matrix inverses using the\n    knowledgebase of :class:`~.Inverse`, e.g.,\n    $$ Y \\times X \\times X^{-1} \\Rightarrow Y $$\n    \"\"\"\n    factor, args = mul.as_coeff_matrices()\n    new_args = [args[0]]\n\n    for i in range(1, len(args)):\n        A = new_args[-1]\n        B = args[i]\n\n        if isinstance(B, Inverse) and isinstance(B.arg, MatMul):\n            Bargs = B.arg.args\n            l = len(Bargs)\n            if list(Bargs) == new_args[-l:]:\n                new_args = new_args[:-l] + [Identity(B.shape[0])]\n                continue\n\n        if isinstance(A, Inverse) and isinstance(A.arg, MatMul):\n            Aargs = A.arg.args\n            l = len(Aargs)\n            if list(Aargs) == args[i:i+l]:\n                identity = Identity(A.shape[0])\n                new_args[-1] = identity\n                for j in range(i, i+l):\n                    args[j] = identity\n                continue\n\n        if A.is_square == False or B.is_square == False:\n            new_args.append(B)\n            continue\n\n        if isinstance(A, MatPow):\n            A_base, A_exp = A.args\n        else:\n            A_base, A_exp = A, S.One\n\n        if isinstance(B, MatPow):\n            B_base, B_exp = B.args\n        else:\n            B_base, B_exp = B, S.One\n\n        if A_base == B_base:\n            new_exp = A_exp + B_exp\n            new_args[-1] = MatPow(A_base, new_exp).doit(deep=False)\n            continue\n        elif not isinstance(B_base, MatrixBase):\n            try:\n                B_base_inv = B_base.inverse()\n            except NonInvertibleMatrixError:\n                B_base_inv = None\n            if B_base_inv is not None and A_base == B_base_inv:\n                new_exp = A_exp - B_exp\n                new_args[-1] = MatPow(A_base, new_exp).doit(deep=False)\n                continue\n        new_args.append(B)\n\n    return newmul(factor, *new_args)",
    "sympy.sympy.matrices.expressions.matmul.combine_permutations": "def combine_permutations(mul):\n    \"\"\"Refine products of permutation matrices as the products of cycles.\n    \"\"\"\n    args = mul.args\n    l = len(args)\n    if l < 2:\n        return mul\n\n    result = [args[0]]\n    for i in range(1, l):\n        A = result[-1]\n        B = args[i]\n        if isinstance(A, PermutationMatrix) and \\\n            isinstance(B, PermutationMatrix):\n            cycle_1 = A.args[0]\n            cycle_2 = B.args[0]\n            result[-1] = PermutationMatrix(cycle_1 * cycle_2)\n        else:\n            result.append(B)\n\n    return MatMul(*result)",
    "sympy.sympy.matrices.expressions.matmul.combine_one_matrices": "def combine_one_matrices(mul):\n    \"\"\"\n    Combine products of OneMatrix\n\n    e.g. OneMatrix(2, 3) * OneMatrix(3, 4) -> 3 * OneMatrix(2, 4)\n    \"\"\"\n    factor, args = mul.as_coeff_matrices()\n    new_args = [args[0]]\n\n    for B in args[1:]:\n        A = new_args[-1]\n        if not isinstance(A, OneMatrix) or not isinstance(B, OneMatrix):\n            new_args.append(B)\n            continue\n        new_args.pop()\n        new_args.append(OneMatrix(A.shape[0], B.shape[1]))\n        factor *= A.shape[1]\n\n    return newmul(factor, *new_args)",
    "sympy.sympy.matrices.expressions.matmul.distribute_monom": "def distribute_monom(mul):\n    \"\"\"\n    Simplify MatMul expressions but distributing\n    rational term to MatMul.\n\n    e.g. 2*(A+B) -> 2*A + 2*B\n    \"\"\"\n    args = mul.args\n    if len(args) == 2:\n        from .matadd import MatAdd\n        if args[0].is_MatAdd and args[1].is_Rational:\n            return MatAdd(*[MatMul(mat, args[1]).doit() for mat in args[0].args])\n        if args[1].is_MatAdd and args[0].is_Rational:\n            return MatAdd(*[MatMul(args[0], mat).doit() for mat in args[1].args])\n    return mul",
    "sympy.sympy.strategies.core.do_one_rl": "def do_one_rl(expr: _T) -> _T:\n    for rl in rules:\n        result = rl(expr)\n        if result != expr:\n            return result\n    return expr",
    "sympy.sympy.strategies.core.switch_rl": "def switch_rl(expr: _S) -> _S:\n    rl = ruledict.get(key(expr), identity)\n    return rl(expr)",
    "sympy.sympy.strategies.core.null_safe_rl": "def null_safe_rl(expr: _T) -> _T:\n    result = rule(expr)\n    if result is None:\n        return expr\n    return result",
    "sympy.sympy.strategies.rl.subs_rl": "def subs_rl(expr):\n    if expr == a:\n        return b\n    else:\n        return expr",
    "sympy.sympy.strategies.rl.unpack": "def unpack(expr):\n    \"\"\" Rule to unpack singleton args\n\n    >>> from sympy.strategies import unpack\n    >>> from sympy import Basic, S\n    >>> unpack(Basic(S(2)))\n    2\n    \"\"\"\n    if len(expr.args) == 1:\n        return expr.args[0]\n    else:\n        return expr",
    "sympy.sympy.strategies.rl.flatten": "def flatten(expr, new=new):\n    \"\"\" Flatten T(a, b, T(c, d), T2(e)) to T(a, b, c, d, T2(e)) \"\"\"\n    cls = expr.__class__\n    args = []\n    for arg in expr.args:\n        if arg.__class__ == cls:\n            args.extend(arg.args)\n        else:\n            args.append(arg)\n    return new(expr.__class__, *args)",
    "sympy.sympy.strategies.rl.ident_remove": "def ident_remove(expr):\n    \"\"\" Remove identities \"\"\"\n    ids = list(map(isid, expr.args))\n    if sum(ids) == 0:           # No identities. Common case\n        return expr\n    elif sum(ids) != len(ids):  # there is at least one non-identity\n        return new(expr.__class__,\n                   *[arg for arg, x in zip(expr.args, ids) if not x])\n    else:\n        return new(expr.__class__, expr.args[0])",
    "sympy.sympy.strategies.rl.conglomerate": "def conglomerate(expr):\n    \"\"\" Conglomerate together identical args x + x -> 2x \"\"\"\n    groups = sift(expr.args, key)\n    counts = {k: sum(map(count, args)) for k, args in groups.items()}\n    newargs = [combine(cnt, mat) for mat, cnt in counts.items()]\n    if set(newargs) != set(expr.args):\n        return new(type(expr), *newargs)\n    else:\n        return expr",
    "sympy.sympy.strategies.rl.sort_rl": "def sort_rl(expr):\n    return new(expr.__class__, *sorted(expr.args, key=key))",
    "sympy.sympy.strategies.traverse.<lambda>": "return do_one(lambda expr: sall(bottom_up(rule, fns), fns)(expr), rule)\n\n\n",
    "<string>.__eq__": "# Could not extract code for <string>.__eq__"
}