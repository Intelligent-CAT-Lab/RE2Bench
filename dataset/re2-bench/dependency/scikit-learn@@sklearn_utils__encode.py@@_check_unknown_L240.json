{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.externals.array_api_extra._lib._funcs.setdiff1d": "def setdiff1d(\n    x1: Array | complex,\n    x2: Array | complex,\n    /,\n    *,\n    assume_unique: bool = False,\n    xp: ModuleType | None = None,\n) -> Array:\n    \"\"\"\n    Find the set difference of two arrays.\n\n    Return the unique values in `x1` that are not in `x2`.\n\n    Parameters\n    ----------\n    x1 : array | int | float | complex | bool\n        Input array.\n    x2 : array\n        Input comparison array.\n    assume_unique : bool\n        If ``True``, the input arrays are both assumed to be unique, which\n        can speed up the calculation. Default is ``False``.\n    xp : array_namespace, optional\n        The standard-compatible namespace for `x1` and `x2`. Default: infer.\n\n    Returns\n    -------\n    array\n        1D array of values in `x1` that are not in `x2`. The result\n        is sorted when `assume_unique` is ``False``, but otherwise only sorted\n        if the input is sorted.\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n\n    >>> x1 = xp.asarray([1, 2, 3, 2, 4, 1])\n    >>> x2 = xp.asarray([3, 4, 5, 6])\n    >>> xpx.setdiff1d(x1, x2, xp=xp)\n    Array([1, 2], dtype=array_api_strict.int64)\n    \"\"\"\n    if xp is None:\n        xp = array_namespace(x1, x2)\n    # https://github.com/microsoft/pyright/issues/10103\n    x1_, x2_ = asarrays(x1, x2, xp=xp)\n\n    if assume_unique:\n        x1_ = xp.reshape(x1_, (-1,))\n        x2_ = xp.reshape(x2_, (-1,))\n    else:\n        x1_ = xp.unique_values(x1_)\n        x2_ = xp.unique_values(x2_)\n\n    return x1_[_helpers.in1d(x1_, x2_, assume_unique=True, invert=True, xp=xp)]",
    "scikit-learn.sklearn.utils._array_api.get_namespace": "def get_namespace(*arrays, remove_none=True, remove_types=(str,), xp=None):\n    \"\"\"Get namespace of arrays.\n\n    Introspect `arrays` arguments and return their common Array API compatible\n    namespace object, if any.\n\n    Note that sparse arrays are filtered by default.\n\n    See: https://numpy.org/neps/nep-0047-array-api-standard.html\n\n    If `arrays` are regular numpy arrays, `array_api_compat.numpy` is returned instead.\n\n    Namespace support is not enabled by default. To enabled it call:\n\n      sklearn.set_config(array_api_dispatch=True)\n\n    or:\n\n      with sklearn.config_context(array_api_dispatch=True):\n          # your code here\n\n    Otherwise `array_api_compat.numpy` is\n    always returned irrespective of the fact that arrays implement the\n    `__array_namespace__` protocol or not.\n\n    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``\n    is returned.\n\n    Parameters\n    ----------\n    *arrays : array objects\n        Array objects.\n\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to the NumPy namespace.\n\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the array API spec (see\n        https://data-apis.org/array-api/latest/index.html).\n        Always False when array_api_dispatch=False.\n    \"\"\"\n    array_api_dispatch = get_config()[\"array_api_dispatch\"]\n    if not array_api_dispatch:\n        if xp is not None:\n            return xp, False\n        else:\n            return np_compat, False\n\n    if xp is not None:\n        return xp, True\n\n    arrays = _remove_non_arrays(\n        *arrays,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n\n    if not arrays:\n        return np_compat, False\n\n    _check_array_api_dispatch(array_api_dispatch)\n\n    namespace, is_array_api_compliant = array_api_compat.get_namespace(*arrays), True\n\n    if namespace.__name__ == \"array_api_strict\" and hasattr(\n        namespace, \"set_array_api_strict_flags\"\n    ):\n        namespace.set_array_api_strict_flags(api_version=\"2024.12\")\n\n    return namespace, is_array_api_compliant",
    "scikit-learn.sklearn.utils._array_api._isin": "def _isin(element, test_elements, xp, assume_unique=False, invert=False):\n    \"\"\"Calculates ``element in test_elements``, broadcasting over `element`\n    only.\n\n    Returns a boolean array of the same shape as `element` that is True\n    where an element of `element` is in `test_elements` and False otherwise.\n    \"\"\"\n    if _is_numpy_namespace(xp):\n        return xp.asarray(\n            numpy.isin(\n                element=element,\n                test_elements=test_elements,\n                assume_unique=assume_unique,\n                invert=invert,\n            )\n        )\n\n    original_element_shape = element.shape\n    element = xp.reshape(element, (-1,))\n    test_elements = xp.reshape(test_elements, (-1,))\n    return xp.reshape(\n        _in1d(\n            ar1=element,\n            ar2=test_elements,\n            xp=xp,\n            assume_unique=assume_unique,\n            invert=invert,\n        ),\n        original_element_shape,\n    )",
    "scikit-learn.sklearn.utils._encode._extract_missing": "def _extract_missing(values):\n    \"\"\"Extract missing values from `values`.\n\n    Parameters\n    ----------\n    values: set\n        Set of values to extract missing from.\n\n    Returns\n    -------\n    output: set\n        Set with missing values extracted.\n\n    missing_values: MissingValues\n        Object with missing value information.\n    \"\"\"\n    missing_values_set = {\n        value for value in values if value is None or is_scalar_nan(value)\n    }\n\n    if not missing_values_set:\n        return values, MissingValues(nan=False, none=False)\n\n    if None in missing_values_set:\n        if len(missing_values_set) == 1:\n            output_missing_values = MissingValues(nan=False, none=True)\n        else:\n            # If there is more than one missing value, then it has to be\n            # float('nan') or np.nan\n            output_missing_values = MissingValues(nan=True, none=True)\n    else:\n        output_missing_values = MissingValues(nan=True, none=False)\n\n    # create set without the missing values\n    output = values - missing_values_set\n    return output, output_missing_values",
    "scikit-learn.sklearn.utils._encode.<listcomp>": "valid_mask = xp.array([is_valid(value) for value in values])\n"
}