{
    "matplotlib.lib.matplotlib.__init__.__getitem__": "def __getitem__(self, key):\n    # In theory, this should only ever be used after the global rcParams\n    # has been set up, but better be safe e.g. in presence of breakpoints.\n    if key == \"backend\" and self is globals().get(\"rcParams\"):\n        val = self._get(key)\n        if val is rcsetup._auto_backend_sentinel:\n            from matplotlib import pyplot as plt\n            plt.switch_backend(rcsetup._auto_backend_sentinel)\n    return self._get(key)",
    "matplotlib.lib.matplotlib.colors._is_nth_color": "def _is_nth_color(c):\n    \"\"\"Return whether *c* can be interpreted as an item in the color cycle.\"\"\"\n    return isinstance(c, str) and _nth_color_re.match(c)",
    "matplotlib.lib.matplotlib.colors._to_rgba_no_colorcycle": "def _to_rgba_no_colorcycle(c, alpha=None):\n    \"\"\"\n    Convert *c* to an RGBA color, with no support for color-cycle syntax.\n\n    If *alpha* is given, force the alpha value of the returned RGBA tuple\n    to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha\n    information, or defaults to 1.\n\n    *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n    which always maps to ``(0, 0, 0, 0)``.\n    \"\"\"\n    if alpha is not None and not 0 <= alpha <= 1:\n        raise ValueError(\"'alpha' must be between 0 and 1, inclusive\")\n    orig_c = c\n    if c is np.ma.masked:\n        return (0., 0., 0., 0.)\n    if isinstance(c, str):\n        if c.lower() == \"none\":\n            return (0., 0., 0., 0.)\n        # Named color.\n        try:\n            # This may turn c into a non-string, so we check again below.\n            c = _colors_full_map[c]\n        except KeyError:\n            if len(c) != 1:\n                try:\n                    c = _colors_full_map[c.lower()]\n                except KeyError:\n                    pass\n    if isinstance(c, str):\n        if re.fullmatch(\"#[a-fA-F0-9]+\", c):\n            if len(c) == 7:  # #rrggbb hex format.\n                return (*[n / 0xff for n in bytes.fromhex(c[1:])],\n                        alpha if alpha is not None else 1.)\n            elif len(c) == 4:  # #rgb hex format, shorthand for #rrggbb.\n                return (*[int(n, 16) / 0xf for n in c[1:]],\n                        alpha if alpha is not None else 1.)\n            elif len(c) == 9:  # #rrggbbaa hex format.\n                color = [n / 0xff for n in bytes.fromhex(c[1:])]\n                if alpha is not None:\n                    color[-1] = alpha\n                return tuple(color)\n            elif len(c) == 5:  # #rgba hex format, shorthand for #rrggbbaa.\n                color = [int(n, 16) / 0xf for n in c[1:]]\n                if alpha is not None:\n                    color[-1] = alpha\n                return tuple(color)\n            else:\n                raise ValueError(f\"Invalid hex color specifier: {orig_c!r}\")\n        # string gray.\n        try:\n            c = float(c)\n        except ValueError:\n            pass\n        else:\n            if not (0 <= c <= 1):\n                raise ValueError(\n                    f\"Invalid string grayscale value {orig_c!r}. \"\n                    f\"Value must be within 0-1 range\")\n            return c, c, c, alpha if alpha is not None else 1.\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    # turn 2-D array into 1-D array\n    if isinstance(c, np.ndarray):\n        if c.ndim == 2 and c.shape[0] == 1:\n            c = c.reshape(-1)\n    # tuple color.\n    if not np.iterable(c):\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    if len(c) not in [3, 4]:\n        raise ValueError(\"RGBA sequence should have length 3 or 4\")\n    if not all(isinstance(x, Real) for x in c):\n        # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and\n        # `np.array(...).astype(float)` would all convert \"0.5\" to 0.5.\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    # Return a tuple to prevent the cached value from being modified.\n    c = tuple(map(float, c))\n    if len(c) == 3 and alpha is None:\n        alpha = 1\n    if alpha is not None:\n        c = c[:3] + (alpha,)\n    if any(elem < 0 or elem > 1 for elem in c):\n        raise ValueError(\"RGBA values should be within 0-1 range\")\n    return c"
}