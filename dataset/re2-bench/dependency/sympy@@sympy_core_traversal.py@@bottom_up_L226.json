{
    "sympy.sympy.algebras.quaternion.__new__": "def __new__(cls, a: SExpr = 0, b: SExpr = 0, c: SExpr = 0, d: SExpr = 0,\n                 real_field: bool = True,\n                 norm: SExpr | None = None) -> Quaternion:\n\n    a, b, c, d = map(sympify, (a, b, c, d))\n\n    if any(i.is_commutative is False for i in [a, b, c, d]):\n        raise ValueError(\"arguments have to be commutative\")\n\n    obj = super().__new__(cls, a, b, c, d)\n    obj._real_field = real_field\n    obj.set_norm(norm)\n    return obj",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.mul.do": "def do(e):\n    if e.is_Mul:\n        c, r = e.as_coeff_Mul()\n        if c.is_Number and r.is_Add:\n            return _unevaluated_Add(*[c*ri for ri in r.args])\n    return e",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.core.traversal.<listcomp>": "args = tuple([bottom_up(a, F, atoms, nonbasic) for a in args])\n",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)",
    "sympy.sympy.polys.polytools._try_factor": "def _try_factor(expr):\n    \"\"\"\n    Factor, but avoid changing the expression when unable to.\n    \"\"\"\n    fac = factor(expr, *gens, **args)\n    if fac.is_Mul or fac.is_Pow:\n        return fac\n    return expr",
    "sympy.sympy.series.gruntz.<lambda>": "f = bottom_up(f, lambda w: getattr(w, 'normal', lambda: w)())\n\n",
    "sympy.sympy.simplify.combsimp.f": "def f(rv):\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []] # numerator, denominator\n\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]]*rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]]*-rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n\n                    rvd[binomial(sum, ai if count_ops(ai) <\n                            count_ops(aj) else aj)] += (\n                            -1 if m == 0 else 1)\n                    break\n            else:\n                i += 1\n\n    if hit:\n        return Mul(*([k**rvd[k] for k in rvd] + [factorial(k)\n                for k in nd_fact_args[0]]))/Mul(*[factorial(k)\n                for k in nd_fact_args[1]])\n    return rv",
    "sympy.sympy.simplify.fu.f": "def f(rv):\n    if not (rv.is_Add or rv.is_Mul or rv.is_Pow):\n        return rv\n\n    n, d = rv.as_numer_denom()\n    if not d.args or not n.args:\n        return rv\n\n    dok = {}\n\n    def ok(di):\n        m = as_f_sign_1(di)\n        if m:\n            g, f, s = m\n            if s is S.NegativeOne and f.is_Mul and len(f.args) == 2 and \\\n                    all(isinstance(fi, tan) for fi in f.args):\n                return g, f\n\n    d_args = list(Mul.make_args(d))\n    for i, di in enumerate(d_args):\n        m = ok(di)\n        if m:\n            g, t = m\n            s = Add(*[_.args[0] for _ in t.args])\n            dok[s] = S.One\n            d_args[i] = g\n            continue\n        if di.is_Add:\n            di = factor(di)\n            if di.is_Mul:\n                d_args.extend(di.args)\n                d_args[i] = S.One\n        elif di.is_Pow and (di.exp.is_integer or di.base.is_positive):\n            m = ok(di.base)\n            if m:\n                g, t = m\n                s = Add(*[_.args[0] for _ in t.args])\n                dok[s] = di.exp\n                d_args[i] = g**di.exp\n            else:\n                di = factor(di)\n                if di.is_Mul:\n                    d_args.extend(di.args)\n                    d_args[i] = S.One\n    if not dok:\n        return rv\n\n    def ok(ni):\n        if ni.is_Add and len(ni.args) == 2:\n            a, b = ni.args\n            if isinstance(a, tan) and isinstance(b, tan):\n                return a, b\n    n_args = list(Mul.make_args(factor_terms(n)))\n    hit = False\n    for i, ni in enumerate(n_args):\n        m = ok(ni)\n        if not m:\n            m = ok(-ni)\n            if m:\n                n_args[i] = S.NegativeOne\n            else:\n                if ni.is_Add:\n                    ni = factor(ni)\n                    if ni.is_Mul:\n                        n_args.extend(ni.args)\n                        n_args[i] = S.One\n                    continue\n                elif ni.is_Pow and (\n                        ni.exp.is_integer or ni.base.is_positive):\n                    m = ok(ni.base)\n                    if m:\n                        n_args[i] = S.One\n                    else:\n                        ni = factor(ni)\n                        if ni.is_Mul:\n                            n_args.extend(ni.args)\n                            n_args[i] = S.One\n                        continue\n                else:\n                    continue\n        else:\n            n_args[i] = S.One\n        hit = True\n        s = Add(*[_.args[0] for _ in m])\n        ed = dok[s]\n        newed = ed.extract_additively(S.One)\n        if newed is not None:\n            if newed:\n                dok[s] = newed\n            else:\n                dok.pop(s)\n        n_args[i] *= -tan(s)\n\n    if hit:\n        rv = Mul(*n_args)/Mul(*d_args)/Mul(*[(Add(*[\n            tan(a) for a in i.args]) - 1)**e for i, e in dok.items()])\n\n    return rv",
    "sympy.sympy.simplify.fu._f": "def _f(rv):\n    # I'm not sure if this transformation should target all even powers\n    # or only those expressible as powers of 2. Also, should it only\n    # make the changes in powers that appear in sums -- making an isolated\n    # change is not going to allow a simplification as far as I can tell.\n    if not (rv.is_Pow and rv.base.func == f):\n        return rv\n    if not rv.exp.is_real:\n        return rv\n\n    if (rv.exp < 0) == True:\n        return rv\n    if (rv.exp > max) == True:\n        return rv\n    if rv.exp == 1:\n        return rv\n    if rv.exp == 2:\n        return h(g(rv.base.args[0])**2)\n    else:\n        if rv.exp % 2 == 1:\n            e = rv.exp//2\n            return f(rv.base.args[0])*h(g(rv.base.args[0])**2)**e\n        elif rv.exp == 4:\n            e = 2\n        elif not pow:\n            if rv.exp % 2:\n                return rv\n            e = rv.exp//2\n        else:\n            p = perfect_power(rv.exp)\n            if not p:\n                return rv\n            e = rv.exp//2\n        return h(g(rv.base.args[0])**2)**e",
    "sympy.sympy.simplify.simplify.f": "def f(rv):\n    if isinstance(rv, log):\n        if isinstance(rv.args[0], exp) or (rv.args[0].is_Pow and rv.args[0].base == S.Exp1):\n            rv = rv.args[0].exp\n    elif rv.is_Function and hasattr(rv, \"inverse\"):\n        if (len(rv.args) == 1 and len(rv.args[0].args) == 1 and\n           isinstance(rv.args[0], rv.inverse(argindex=1))):\n            rv = rv.args[0].args[0]\n    if rv.is_Pow and rv.base == S.Exp1:\n        if isinstance(rv.exp, log):\n            rv = rv.exp.args[0]\n    return rv",
    "sympy.sympy.simplify.simplify.<lambda>": "expr = _bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())\n",
    "sympy.sympy.simplify.trigsimp._futrig": "def _futrig(e):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, _TR11, TR14, TR22,\n        TR12)\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = None\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, _TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR10i,  # sin-cos products > sin-cos of sums\n        TRmorrie,\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    if coeff is not None:\n        e = coeff * e\n\n    return e",
    "sympy.sympy.simplify.trigsimp.f": "def f(rv):\n    if not rv.is_Mul:\n        return rv\n    commutative_part, noncommutative_part = rv.args_cnc()\n    # Since as_powers_dict loses order information,\n    # if there is more than one noncommutative factor,\n    # it should only be used to simplify the commutative part.\n    if (len(noncommutative_part) > 1):\n        return f(Mul(*commutative_part))*Mul(*noncommutative_part)\n    rvd = rv.as_powers_dict()\n    newd = rvd.copy()\n\n    def signlog(expr, sign=S.One):\n        if expr is S.Exp1:\n            return sign, S.One\n        elif isinstance(expr, exp) or (expr.is_Pow and expr.base == S.Exp1):\n            return sign, expr.exp\n        elif sign is S.One:\n            return signlog(-expr, sign=-S.One)\n        else:\n            return None, None\n\n    ee = rvd[S.Exp1]\n    for k in rvd:\n        if k.is_Add and len(k.args) == 2:\n            # k == c*(1 + sign*E**x)\n            c = k.args[0]\n            sign, x = signlog(k.args[1]/c)\n            if not x:\n                continue\n            m = rvd[k]\n            newd[k] -= m\n            if ee == -x*m/2:\n                # sinh and cosh\n                newd[S.Exp1] -= ee\n                ee = 0\n                if sign == 1:\n                    newd[2*c*cosh(x/2)] += m\n                else:\n                    newd[-2*c*sinh(x/2)] += m\n            elif newd[1 - sign*S.Exp1**x] == -m:\n                # tanh\n                del newd[1 - sign*S.Exp1**x]\n                if sign == 1:\n                    newd[-c/tanh(x/2)] += m\n                else:\n                    newd[-c*tanh(x/2)] += m\n            else:\n                newd[1 + sign*S.Exp1**x] += m\n                newd[c] += m\n\n    return Mul(*[k**newd[k] for k in newd])",
    "sympy.sympy.simplify.trigsimp.exp_trig": "def exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        op = e.rewrite(exp)\n        # if e is an Add, we can try to factor it\n        # helps with expressions with leading factors\n        if e.is_Add:\n            choices.append(factor_terms(op))\n        else:\n            choices.append(op)\n    choices.append(e.rewrite(cos))\n    return min(*choices, key=count_ops)",
    "sympy.sympy.vector.coordsysrect.__init__": "def __init__(self, name, location=None, rotation_matrix=None,\n             parent=None, vector_names=None, variable_names=None,\n             latex_vects=None, pretty_vects=None, latex_scalars=None,\n             pretty_scalars=None, transformation=None):\n    # Dummy initializer for setting docstring\n    pass",
    "sympy.sympy.vector.coordsysrect.__new__": "def __new__(cls, name, transformation=None, parent=None, location=None,\n            rotation_matrix=None, vector_names=None, variable_names=None):\n    \"\"\"\n    The orientation/location parameters are necessary if this system\n    is being defined at a certain orientation or location wrt another.\n\n    Parameters\n    ==========\n\n    name : str\n        The name of the new CoordSys3D instance.\n\n    transformation : Lambda, Tuple, str\n        Transformation defined by transformation equations or chosen\n        from predefined ones.\n\n    location : Vector\n        The position vector of the new system's origin wrt the parent\n        instance.\n\n    rotation_matrix : SymPy ImmutableMatrix\n        The rotation matrix of the new coordinate system with respect\n        to the parent. In other words, the output of\n        new_system.rotation_matrix(parent).\n\n    parent : CoordSys3D\n        The coordinate system wrt which the orientation/location\n        (or both) is being defined.\n\n    vector_names, variable_names : iterable(optional)\n        Iterables of 3 strings each, with custom names for base\n        vectors and base scalars of the new system respectively.\n        Used for simple str printing.\n\n    \"\"\"\n\n    name = str(name)\n    Vector = sympy.vector.Vector\n    Point = sympy.vector.Point\n\n    if not isinstance(name, str):\n        raise TypeError(\"name should be a string\")\n\n    if transformation is not None:\n        if (location is not None) or (rotation_matrix is not None):\n            raise ValueError(\"specify either `transformation` or \"\n                             \"`location`/`rotation_matrix`\")\n        if isinstance(transformation, (Tuple, tuple, list)):\n            if isinstance(transformation[0], MatrixBase):\n                rotation_matrix = transformation[0]\n                location = transformation[1]\n            else:\n                transformation = Lambda(transformation[0],\n                                        transformation[1])\n        elif isinstance(transformation, Callable):\n            x1, x2, x3 = symbols('x1 x2 x3', cls=Dummy)\n            transformation = Lambda((x1, x2, x3),\n                                    transformation(x1, x2, x3))\n        elif isinstance(transformation, str):\n            transformation = Str(transformation)\n        elif isinstance(transformation, (Str, Lambda)):\n            pass\n        else:\n            raise TypeError(\"transformation: \"\n                            \"wrong type {}\".format(type(transformation)))\n\n    # If orientation information has been provided, store\n    # the rotation matrix accordingly\n    if rotation_matrix is None:\n        rotation_matrix = ImmutableDenseMatrix(eye(3))\n    else:\n        if not isinstance(rotation_matrix, MatrixBase):\n            raise TypeError(\"rotation_matrix should be an Immutable\" +\n                            \"Matrix instance\")\n        rotation_matrix = rotation_matrix.as_immutable()\n\n    # If location information is not given, adjust the default\n    # location as Vector.zero\n    if parent is not None:\n        if not isinstance(parent, CoordSys3D):\n            raise TypeError(\"parent should be a \" +\n                            \"CoordSys3D/None\")\n        if location is None:\n            location = Vector.zero\n        else:\n            if not isinstance(location, Vector):\n                raise TypeError(\"location should be a Vector\")\n            # Check that location does not contain base\n            # scalars\n            for x in location.free_symbols:\n                if isinstance(x, BaseScalar):\n                    raise ValueError(\"location should not contain\" +\n                                     \" BaseScalars\")\n        origin = parent.origin.locate_new(name + '.origin',\n                                          location)\n    else:\n        location = Vector.zero\n        origin = Point(name + '.origin')\n\n    if transformation is None:\n        transformation = Tuple(rotation_matrix, location)\n\n    if isinstance(transformation, Tuple):\n        lambda_transformation = CoordSys3D._compose_rotation_and_translation(\n            transformation[0],\n            transformation[1],\n            parent\n        )\n        r, l = transformation\n        l = l._projections\n        lambda_lame = CoordSys3D._get_lame_coeff('cartesian')\n        lambda_inverse = lambda x, y, z: r.inv()*Matrix(\n            [x-l[0], y-l[1], z-l[2]])\n    elif isinstance(transformation, Str):\n        trname = transformation.name\n        lambda_transformation = CoordSys3D._get_transformation_lambdas(trname)\n        if parent is not None:\n            if parent.lame_coefficients() != (S.One, S.One, S.One):\n                raise ValueError('Parent for pre-defined coordinate '\n                             'system should be Cartesian.')\n        lambda_lame = CoordSys3D._get_lame_coeff(trname)\n        lambda_inverse = CoordSys3D._set_inv_trans_equations(trname)\n    elif isinstance(transformation, Lambda):\n        if not CoordSys3D._check_orthogonality(transformation):\n            raise ValueError(\"The transformation equation does not \"\n                             \"create orthogonal coordinate system\")\n        lambda_transformation = transformation\n        lambda_lame = CoordSys3D._calculate_lame_coeff(lambda_transformation)\n        lambda_inverse = None\n    else:\n        lambda_transformation = lambda x, y, z: transformation(x, y, z)\n        lambda_lame = CoordSys3D._get_lame_coeff(transformation)\n        lambda_inverse = None\n\n    if variable_names is None:\n        if isinstance(transformation, Lambda):\n            variable_names = [\"x1\", \"x2\", \"x3\"]\n        elif isinstance(transformation, Str):\n            if transformation.name == 'spherical':\n                variable_names = [\"r\", \"theta\", \"phi\"]\n            elif transformation.name == 'cylindrical':\n                variable_names = [\"r\", \"theta\", \"z\"]\n            else:\n                variable_names = [\"x\", \"y\", \"z\"]\n        else:\n            variable_names = [\"x\", \"y\", \"z\"]\n    if vector_names is None:\n        vector_names = [\"i\", \"j\", \"k\"]\n\n    # All systems that are defined as 'roots' are unequal, unless\n    # they have the same name.\n    # Systems defined at same orientation/position wrt the same\n    # 'parent' are equal, irrespective of the name.\n    # This is true even if the same orientation is provided via\n    # different methods like Axis/Body/Space/Quaternion.\n    # However, coincident systems may be seen as unequal if\n    # positioned/oriented wrt different parents, even though\n    # they may actually be 'coincident' wrt the root system.\n    if parent is not None:\n        obj = super().__new__(\n            cls, Str(name), transformation, parent)\n    else:\n        obj = super().__new__(\n            cls, Str(name), transformation)\n    obj._name = name\n    # Initialize the base vectors\n\n    _check_strings('vector_names', vector_names)\n    vector_names = list(vector_names)\n    latex_vects = [(r'\\mathbf{\\hat{%s}_{%s}}' % (x, name)) for\n                       x in vector_names]\n    pretty_vects = ['%s_%s' % (x, name) for x in vector_names]\n\n    obj._vector_names = vector_names\n\n    v1 = BaseVector(0, obj, pretty_vects[0], latex_vects[0])\n    v2 = BaseVector(1, obj, pretty_vects[1], latex_vects[1])\n    v3 = BaseVector(2, obj, pretty_vects[2], latex_vects[2])\n\n    obj._base_vectors = (v1, v2, v3)\n\n    # Initialize the base scalars\n\n    _check_strings('variable_names', vector_names)\n    variable_names = list(variable_names)\n    latex_scalars = [(r\"\\mathbf{{%s}_{%s}}\" % (x, name)) for\n                     x in variable_names]\n    pretty_scalars = ['%s_%s' % (x, name) for x in variable_names]\n\n    obj._variable_names = variable_names\n    obj._vector_names = vector_names\n\n    x1 = BaseScalar(0, obj, pretty_scalars[0], latex_scalars[0])\n    x2 = BaseScalar(1, obj, pretty_scalars[1], latex_scalars[1])\n    x3 = BaseScalar(2, obj, pretty_scalars[2], latex_scalars[2])\n\n    obj._base_scalars = (x1, x2, x3)\n\n    obj._transformation = transformation\n    obj._transformation_lambda = lambda_transformation\n    obj._lame_coefficients = lambda_lame(x1, x2, x3)\n    obj._transformation_from_parent_lambda = lambda_inverse\n\n    setattr(obj, variable_names[0], x1)\n    setattr(obj, variable_names[1], x2)\n    setattr(obj, variable_names[2], x3)\n\n    setattr(obj, vector_names[0], v1)\n    setattr(obj, vector_names[1], v2)\n    setattr(obj, vector_names[2], v3)\n\n    # Assign params\n    obj._parent = parent\n    if obj._parent is not None:\n        obj._root = obj._parent._root\n    else:\n        obj._root = obj\n\n    obj._parent_rotation_matrix = rotation_matrix\n    obj._origin = origin\n\n    # Return the instance\n    return obj",
    "sympy.sympy.vector.scalar.__new__": "def __new__(cls, index, system, pretty_str=None, latex_str=None):\n    from sympy.vector.coordsysrect import CoordSys3D\n    if pretty_str is None:\n        pretty_str = \"x{}\".format(index)\n    elif isinstance(pretty_str, Symbol):\n        pretty_str = pretty_str.name\n    if latex_str is None:\n        latex_str = \"x_{}\".format(index)\n    elif isinstance(latex_str, Symbol):\n        latex_str = latex_str.name\n\n    index = _sympify(index)\n    system = _sympify(system)\n    obj = super().__new__(cls, index, system)\n    if not isinstance(system, CoordSys3D):\n        raise TypeError(\"system should be a CoordSys3D\")\n    if index not in range(0, 3):\n        raise ValueError(\"Invalid index specified.\")\n    # The _id is used for equating purposes, and for hashing\n    obj._id = (index, system)\n    obj._name = obj.name = system._name + '.' + system._variable_names[index]\n    obj._pretty_form = '' + pretty_str\n    obj._latex_form = latex_str\n    obj._system = system\n\n    return obj"
}