{
    "matplotlib.lib.matplotlib.colors.lut": "@property\ndef lut(self):\n    \"\"\"\n    For external access to the lut, i.e. for displaying the cmap.\n    For circular colormaps this returns a lut with a circular mask.\n\n    Internal functions (such as to_rgb()) should use _lut\n    which stores the lut without a circular mask\n    A lut without the circular mask is needed in to_rgb() because the\n    conversion from floats to ints results in some some pixel-requests\n    just outside of the circular mask\n\n    \"\"\"\n    if not self._isinit:\n        self._init()\n    lut = np.copy(self._lut)\n    if self.shape == 'circle' or self.shape == 'circleignore':\n        n = np.linspace(-1, 1, self.N)\n        m = np.linspace(-1, 1, self.M)\n        radii_sqr = (n**2)[:, np.newaxis] + (m**2)[np.newaxis, :]\n        mask_outside = radii_sqr > 1\n        lut[mask_outside, 3] = 0\n    return lut",
    "matplotlib.lib.matplotlib.colors._init": "def _init(self):\n    s = self.patch.shape\n    _patch = np.empty((s[0], s[1], 4))\n    _patch[:, :, :3] = self.patch\n    _patch[:, :, 3] = 1\n    transform = mpl.transforms.Affine2D().translate(-0.5, -0.5)\\\n                            .scale(self.N / (s[1] - 1), self.N / (s[0] - 1))\n    self._lut = np.empty((self.N, self.N, 4))\n\n    _image.resample(_patch, self._lut, transform, _image.BILINEAR,\n                    resample=False, alpha=1)\n    self._isinit = True"
}