{
    "sympy.sympy.core.add.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self. If radical is True (default is False) then\n    common radicals will be removed and included as a factor of the\n    primitive expression.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (3 + 3*sqrt(2)).as_content_primitive()\n    (3, 1 + sqrt(2))\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(\n        radical=radical, clear=clear)) for a in self.args]).primitive()\n    if not clear and not con.is_Integer and prim.is_Add:\n        con, d = con.as_numer_denom()\n        _p = prim/d\n        if any(a.as_coeff_Mul()[0].is_Integer for a in _p.args):\n            prim = _p\n        else:\n            con /= d\n    if radical and prim.is_Add:\n        # look for common radicals that can be removed\n        args = prim.args\n        rads = []\n        common_q = None\n        for m in args:\n            term_rads = defaultdict(list)\n            for ai in Mul.make_args(m):\n                if ai.is_Pow:\n                    b, e = ai.as_base_exp()\n                    if e.is_Rational and b.is_Integer:\n                        term_rads[e.q].append(abs(int(b))**e.p)\n            if not term_rads:\n                break\n            if common_q is None:\n                common_q = set(term_rads.keys())\n            else:\n                common_q = common_q & set(term_rads.keys())\n                if not common_q:\n                    break\n            rads.append(term_rads)\n        else:\n            # process rads\n            # keep only those in common_q\n            for r in rads:\n                for q in list(r.keys()):\n                    if q not in common_q:\n                        r.pop(q)\n                for q in r:\n                    r[q] = Mul(*r[q])\n            # find the gcd of bases for each q\n            G = []\n            for q in common_q:\n                g = reduce(igcd, [r[q] for r in rads], 0)\n                if g != 1:\n                    G.append(g**Rational(1, q))\n            if G:\n                G = Mul(*G)\n                args = [ai/G for ai in args]\n                prim = G*prim.func(*args)\n\n    return con, prim",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"This method should recursively remove a Rational from all arguments\n    and return that (content) and the new self (primitive). The content\n    should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n    The primitive need not be in canonical form and should try to preserve\n    the underlying structure if possible (i.e. expand_mul should not be\n    applied to self).\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import x, y, z\n\n    >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n\n    The as_content_primitive function is recursive and retains structure:\n\n    >>> eq.as_content_primitive()\n    (2, x + 3*y*(y + 1) + 1)\n\n    Integer powers will have Rationals extracted from the base:\n\n    >>> ((2 + 6*x)**2).as_content_primitive()\n    (4, (3*x + 1)**2)\n    >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n    (1, (2*(3*x + 1))**(2*y))\n\n    Terms may end up joining once their as_content_primitives are added:\n\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (11, x*(y + 1))\n    >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (9, x*(y + 1))\n    >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n    (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n    (121, x**2*(y + 1)**2)\n    >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()\n    (1, 4.84*x**2*(y + 1)**2)\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    If clear=False (default is True) then content will not be removed\n    from an Add if it can be distributed to leave one or more\n    terms with integer coefficients.\n\n    >>> (x/2 + y).as_content_primitive()\n    (1/2, x + 2*y)\n    >>> (x/2 + y).as_content_primitive(clear=False)\n    (1, x/2 + y)\n    \"\"\"\n    return S.One, self",
    "sympy.sympy.core.mul.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n    (6, -sqrt(2)*(1 - sqrt(2)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    coef = S.One\n    args = []\n    for a in self.args:\n        c, p = a.as_content_primitive(radical=radical, clear=clear)\n        coef *= c\n        if p is not S.One:\n            args.append(p)\n    # don't use self._from_args here to reconstruct args\n    # since there may be identical args now that should be combined\n    # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n    return coef, self.func(*args)",
    "sympy.sympy.core.numbers.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> (S(-3)/2).as_content_primitive()\n    (3/2, -1)\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    if self:\n        if self.is_positive:\n            return self, S.One\n        return -self, S.NegativeOne\n    return S.One, self",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.power.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()\n    (2, sqrt(1 + sqrt(2)))\n    >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()\n    (1, sqrt(3)*sqrt(1 + sqrt(2)))\n\n    >>> from sympy import expand_power_base, powsimp, Mul\n    >>> from sympy.abc import x, y\n\n    >>> ((2*x + 2)**2).as_content_primitive()\n    (4, (x + 1)**2)\n    >>> (4**((1 + y)/2)).as_content_primitive()\n    (2, 4**(y/2))\n    >>> (3**((1 + y)/2)).as_content_primitive()\n    (1, 3**((y + 1)/2))\n    >>> (3**((5 + y)/2)).as_content_primitive()\n    (9, 3**((y + 1)/2))\n    >>> eq = 3**(2 + 2*x)\n    >>> powsimp(eq) == eq\n    True\n    >>> eq.as_content_primitive()\n    (9, 3**(2*x))\n    >>> powsimp(Mul(*_))\n    3**(2*x + 2)\n\n    >>> eq = (2 + 2*x)**y\n    >>> s = expand_power_base(eq); s.is_Mul, s\n    (False, (2*x + 2)**y)\n    >>> eq.as_content_primitive()\n    (1, (2*(x + 1))**y)\n    >>> s = expand_power_base(_[1]); s.is_Mul, s\n    (True, 2**y*(x + 1)**y)\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    b, e = self.as_base_exp()\n    b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))\n    ce, pe = e.as_content_primitive(radical=radical, clear=clear)\n    if b.is_Rational:\n        #e\n        #= ce*pe\n        #= ce*(h + t)\n        #= ce*h + ce*t\n        #=> self\n        #= b**(ce*h)*b**(ce*t)\n        #= b**(cehp/cehq)*b**(ce*t)\n        #= b**(iceh + r/cehq)*b**(ce*t)\n        #= b**(iceh)*b**(r/cehq)*b**(ce*t)\n        #= b**(iceh)*b**(ce*t + r/cehq)\n        h, t = pe.as_coeff_Add()\n        if h.is_Rational and b != S.Zero:\n            ceh = ce*h\n            c = self.func(b, ceh)\n            r = S.Zero\n            if not c.is_Rational:\n                iceh, r = divmod(ceh.p, ceh.q)\n                c = self.func(b, iceh)\n            return c, self.func(b, _keep_coeff(ce, t + r/ce/ceh.q))\n    e = _keep_coeff(ce, pe)\n    # b**e = (h*t)**e = h**e*t**e = c*m*t**e\n    if e.is_Rational and b.is_Mul:\n        h, t = b.as_content_primitive(radical=radical, clear=clear)  # h is positive\n        c, m = self.func(h, e).as_coeff_Mul()  # so c is positive\n        m, me = m.as_base_exp()\n        if m is S.One or me == e:  # probably always true\n            # return the following, not return c, m*Pow(t, e)\n            # which would change Pow into Mul; we let SymPy\n            # decide what to do by using the unevaluated Mul, e.g\n            # should it stay as sqrt(2 + 2*sqrt(5)) or become\n            # sqrt(2)*sqrt(1 + sqrt(5))\n            return c, self.func(_keep_coeff(m, t), e)\n    return S.One, self.func(b, e)"
}