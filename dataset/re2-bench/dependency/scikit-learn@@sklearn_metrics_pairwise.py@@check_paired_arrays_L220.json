{
    "scikit-learn.sklearn.metrics.pairwise.check_pairwise_arrays": "def check_pairwise_arrays(\n    X,\n    Y,\n    *,\n    precomputed=False,\n    dtype=\"infer_float\",\n    accept_sparse=\"csr\",\n    ensure_all_finite=True,\n    ensure_2d=True,\n    copy=False,\n):\n    \"\"\"Set X and Y appropriately and checks inputs.\n\n    If Y is None, it is set as a pointer to X (i.e. not a copy).\n    If Y is given, this does not happen.\n    All distance metrics should use this function first to assert that the\n    given parameters are correct and safe to use.\n\n    Specifically, this function first ensures that both X and Y are arrays,\n    then checks that they are at least two dimensional while ensuring that\n    their elements are floats (or dtype if provided). Finally, the function\n    checks that the size of the second dimension of the two arrays is equal, or\n    the equivalent check for a precomputed distance matrix.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)\n\n    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)\n\n    precomputed : bool, default=False\n        True if X is to be treated as precomputed distances to the samples in\n        Y.\n\n    dtype : str, type, list of type or None default=\"infer_float\"\n        Data type required for X and Y. If \"infer_float\", the dtype will be an\n        appropriate float type selected by _return_float_dtype. If None, the\n        dtype of the input is preserved.\n\n        .. versionadded:: 0.18\n\n    accept_sparse : str, bool or list/tuple of str, default='csr'\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n\n    ensure_all_finite : bool or 'allow-nan', default=True\n        Whether to raise an error on np.inf, np.nan, pd.NA in array. The\n        possibilities are:\n\n        - True: Force all values of array to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in array.\n        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values\n          cannot be infinite.\n\n        .. versionadded:: 1.6\n           `force_all_finite` was renamed to `ensure_all_finite`.\n\n    ensure_2d : bool, default=True\n        Whether to raise an error when the input arrays are not 2-dimensional. Setting\n        this to `False` is necessary when using a custom metric with certain\n        non-numerical inputs (e.g. a list of strings).\n\n        .. versionadded:: 1.5\n\n    copy : bool, default=False\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n        .. versionadded:: 0.22\n\n    Returns\n    -------\n    safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features)\n        An array equal to X, guaranteed to be a numpy array.\n\n    safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)\n        An array equal to Y if Y was not None, guaranteed to be a numpy array.\n        If Y was None, safe_Y will be a pointer to X.\n    \"\"\"\n    xp, _ = get_namespace(X, Y)\n    X, Y, dtype_float = _find_floating_dtype_allow_sparse(X, Y, xp=xp)\n\n    estimator = \"check_pairwise_arrays\"\n    if dtype == \"infer_float\":\n        dtype = dtype_float\n\n    if Y is X or Y is None:\n        X = Y = check_array(\n            X,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            estimator=estimator,\n            ensure_2d=ensure_2d,\n        )\n    else:\n        X = check_array(\n            X,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            estimator=estimator,\n            ensure_2d=ensure_2d,\n        )\n        Y = check_array(\n            Y,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            estimator=estimator,\n            ensure_2d=ensure_2d,\n        )\n\n    if precomputed:\n        if X.shape[1] != Y.shape[0]:\n            raise ValueError(\n                \"Precomputed metric requires shape \"\n                \"(n_queries, n_indexed). Got (%d, %d) \"\n                \"for %d indexed.\" % (X.shape[0], X.shape[1], Y.shape[0])\n            )\n    elif ensure_2d and X.shape[1] != Y.shape[1]:\n        # Only check the number of features if 2d arrays are enforced. Otherwise,\n        # validation is left to the user for custom metrics.\n        raise ValueError(\n            \"Incompatible dimension for X and Y matrices: \"\n            \"X.shape[1] == %d while Y.shape[1] == %d\" % (X.shape[1], Y.shape[1])\n        )\n\n    return X, Y"
}