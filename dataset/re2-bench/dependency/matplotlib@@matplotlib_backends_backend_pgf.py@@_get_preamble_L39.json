{
    "matplotlib.lib.matplotlib.__init__.__getitem__": "def __getitem__(self, key):\n    # In theory, this should only ever be used after the global rcParams\n    # has been set up, but better be safe e.g. in presence of breakpoints.\n    if key == \"backend\" and self is globals().get(\"rcParams\"):\n        val = self._get(key)\n        if val is rcsetup._auto_backend_sentinel:\n            from matplotlib import pyplot as plt\n            plt.switch_backend(rcsetup._auto_backend_sentinel)\n    return self._get(key)",
    "matplotlib.lib.matplotlib.backends.backend_pgf.<listcomp>": "# Could not extract code for matplotlib.lib.matplotlib.backends.backend_pgf.<listcomp>",
    "matplotlib.lib.matplotlib.font_manager.wrapper": "@functools.wraps(init_method)\ndef wrapper(self, *args, **kwargs):\n    # multiple args with at least some positional ones\n    if len(args) > 1 or len(args) == 1 and kwargs:\n        # Note: Both cases were previously handled as individual properties.\n        # Therefore, we do not mention the case of font properties here.\n        _api.warn_deprecated(\n            \"3.10\",\n            message=\"Passing individual properties to FontProperties() \"\n                    \"positionally was deprecated in Matplotlib %(since)s and \"\n                    \"will be removed in %(removal)s. Please pass all properties \"\n                    \"via keyword arguments.\"\n        )\n    # single non-string arg -> clearly a family not a pattern\n    if len(args) == 1 and not kwargs and not cbook.is_scalar_or_string(args[0]):\n        # Case font-family list passed as single argument\n        _api.warn_deprecated(\n            \"3.10\",\n            message=\"Passing family as positional argument to FontProperties() \"\n                    \"was deprecated in Matplotlib %(since)s and will be removed \"\n                    \"in %(removal)s. Please pass family names as keyword\"\n                    \"argument.\"\n        )\n    # Note on single string arg:\n    # This has been interpreted as pattern so far. We are already raising if a\n    # non-pattern compatible family string was given. Therefore, we do not need\n    # to warn for this case.\n    return init_method(self, *args, **kwargs)",
    "matplotlib.lib.matplotlib.font_manager.get_size": "def get_size(self):\n    \"\"\"\n    Return the font size.\n    \"\"\"\n    return self._size",
    "matplotlib.lib.matplotlib.texmanager._usepackage_if_not_loaded": "def _usepackage_if_not_loaded(package, *, option=None):\n    \"\"\"\n    Output LaTeX code that loads a package (possibly with an option) if it\n    hasn't been loaded yet.\n\n    LaTeX cannot load twice a package with different options, so this helper\n    can be used to protect against users loading arbitrary packages/options in\n    their custom preamble.\n    \"\"\"\n    option = f\"[{option}]\" if option is not None else \"\"\n    return (\n        r\"\\makeatletter\"\n        r\"\\@ifpackageloaded{%(package)s}{}{\\usepackage%(option)s{%(package)s}}\"\n        r\"\\makeatother\"\n    ) % {\"package\": package, \"option\": option}"
}