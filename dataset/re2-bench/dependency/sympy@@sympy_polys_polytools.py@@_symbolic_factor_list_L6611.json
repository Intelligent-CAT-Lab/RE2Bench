{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.core.expr.as_expr": "def as_expr(self, *gens):\n    \"\"\"\n    Convert a polynomial to a SymPy expression.\n\n    Examples\n    ========\n\n    >>> from sympy import sin\n    >>> from sympy.abc import x, y\n\n    >>> f = (x**2 + x*y).as_poly(x, y)\n    >>> f.as_expr()\n    x**2 + x*y\n\n    >>> sin(x).as_expr()\n    sin(x)\n\n    \"\"\"\n    return self",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p + self.p*other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.polys.polytools.as_expr": "def as_expr(f, *gens):\n    \"\"\"\n    Convert a Poly instance to an Expr instance.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n    >>> f.as_expr()\n    x**2 + 2*x*y**2 - y\n    >>> f.as_expr({x: 5})\n    10*y**2 - y + 25\n    >>> f.as_expr(5, 6)\n    379\n\n    \"\"\"\n    if not gens:\n        return f.expr\n\n    if len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\n                    \"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    "sympy.sympy.polys.polytools.sqf_list": "def sqf_list(f, all=False):\n    \"\"\"\n    Returns a list of square-free factors of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x\n\n    >>> f = 2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16\n\n    >>> Poly(f).sqf_list()\n    (2, [(Poly(x + 1, x, domain='ZZ'), 2),\n         (Poly(x + 2, x, domain='ZZ'), 3)])\n\n    >>> Poly(f).sqf_list(all=True)\n    (2, [(Poly(1, x, domain='ZZ'), 1),\n         (Poly(x + 1, x, domain='ZZ'), 2),\n         (Poly(x + 2, x, domain='ZZ'), 3)])\n\n    \"\"\"\n    if hasattr(f.rep, 'sqf_list'):\n        coeff, factors = f.rep.sqf_list(all)\n    else:  # pragma: no cover\n        raise OperationNotSupported(f, 'sqf_list')\n\n    return f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors]",
    "sympy.sympy.polys.polytools.factor_list": "def factor_list(f) -> tuple[Expr, list[tuple[Poly, int]]]:\n    \"\"\"\n    Returns a list of irreducible factors of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = 2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y\n\n    >>> Poly(f).factor_list()\n    (2, [(Poly(x + y, x, y, domain='ZZ'), 1),\n         (Poly(x**2 + 1, x, y, domain='ZZ'), 2)])\n\n    \"\"\"\n    if hasattr(f.rep, 'factor_list'):\n        try:\n            coeff, factors = f.rep.factor_list()\n        except DomainError:\n            if f.degree() == 0:\n                return f.as_expr(), []\n            else:\n                return S.One, [(f, 1)]\n    else:  # pragma: no cover\n        raise OperationNotSupported(f, 'factor_list')\n\n    return f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors]",
    "sympy.sympy.polys.polytools.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.polys.polytools._poly_from_expr": "def _poly_from_expr(expr, opt):\n    \"\"\"Construct a polynomial from an expression. \"\"\"\n    orig, expr = expr, sympify(expr)\n\n    if not isinstance(expr, Basic):\n        raise PolificationFailed(opt, orig, expr)\n    elif expr.is_Poly:\n        poly = expr.__class__._from_poly(expr, opt)\n\n        opt.gens = poly.gens\n        opt.domain = poly.domain\n\n        if opt.polys is None:\n            opt.polys = True\n\n        return poly, opt\n    elif opt.expand:\n        expr = expr.expand()\n\n    rep, opt = _dict_from_expr(expr, opt)\n    if not opt.gens:\n        raise PolificationFailed(opt, orig, expr)\n\n    monoms, coeffs = list(zip(*list(rep.items())))\n    domain = opt.domain\n\n    if domain is None:\n        opt.domain, coeffs = construct_domain(coeffs, opt=opt)\n    else:\n        coeffs = list(map(domain.from_sympy, coeffs))\n\n    rep = dict(list(zip(monoms, coeffs)))\n    poly = Poly._from_dict(rep, opt)\n\n    if opt.polys is None:\n        opt.polys = False\n\n    return poly, opt",
    "sympy.sympy.polys.polytools._factors_product": "def _factors_product(factors):\n    \"\"\"Multiply a list of ``(expr, exp)`` pairs. \"\"\"\n    return Mul(*[f.as_expr()**k for f, k in factors])",
    "sympy.sympy.polys.polytools.<listcomp>": "    factors = [(reduce(mul, (f for f, _ in factors if _ == k)), k)\n               for k in {i for _, i in factors}]\n#collect duplicates\n",
    "sympy.sympy.polys.polytools.<setcomp>": "               for k in {i for _, i in factors}]\n#collect duplicates\n"
}