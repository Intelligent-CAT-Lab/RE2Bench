{
    "scikit-learn.sklearn.feature_selection._from_model.n_features_in_": "@property\ndef n_features_in_(self):\n    \"\"\"Number of features seen during `fit`.\"\"\"\n    # For consistency with other estimators we raise an AttributeError so\n    # that hasattr() fails if the estimator isn't fitted.\n    try:\n        check_is_fitted(self)\n    except NotFittedError as nfe:\n        raise AttributeError(\n            \"{} object has no n_features_in_ attribute.\".format(\n                self.__class__.__name__\n            )\n        ) from nfe\n\n    return self.estimator_.n_features_in_",
    "scikit-learn.sklearn.utils.validation._num_features": "def _num_features(X):\n    \"\"\"Return the number of features in an array-like X.\n\n    This helper function tries hard to avoid to materialize an array version\n    of X unless necessary. For instance, if X is a list of lists,\n    this function will return the length of the first element, assuming\n    that subsequent elements are all lists of the same length without\n    checking.\n    Parameters\n    ----------\n    X : array-like\n        array-like to get the number of features.\n\n    Returns\n    -------\n    features : int\n        Number of features\n    \"\"\"\n    type_ = type(X)\n    if type_.__module__ == \"builtins\":\n        type_name = type_.__qualname__\n    else:\n        type_name = f\"{type_.__module__}.{type_.__qualname__}\"\n    message = f\"Unable to find the number of features from X of type {type_name}\"\n    if not hasattr(X, \"__len__\") and not hasattr(X, \"shape\"):\n        if not hasattr(X, \"__array__\"):\n            raise TypeError(message)\n        # Only convert X to a numpy array if there is no cheaper, heuristic\n        # option.\n        X = np.asarray(X)\n\n    if hasattr(X, \"shape\"):\n        if not hasattr(X.shape, \"__len__\") or len(X.shape) <= 1:\n            message += f\" with shape {X.shape}\"\n            raise TypeError(message)\n        return X.shape[1]\n\n    first_sample = X[0]\n\n    # Do not consider an array-like of strings or dicts to be a 2D array\n    if isinstance(first_sample, (str, bytes, dict)):\n        message += f\" where the samples are of type {type(first_sample).__qualname__}\"\n        raise TypeError(message)\n\n    try:\n        # If X is a list of lists, for instance, we assume that all nested\n        # lists have the same length without checking or converting to\n        # a numpy array to keep this function call as cheap as possible.\n        return len(first_sample)\n    except Exception as err:\n        raise TypeError(message) from err"
}