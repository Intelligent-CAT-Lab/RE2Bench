{
    "attrs.src.attr._make._make_init_script": "def _make_init_script(\n    cls,\n    attrs,\n    pre_init,\n    pre_init_has_args,\n    post_init,\n    frozen,\n    slots,\n    cache_hash,\n    base_attr_map,\n    is_exc,\n    cls_on_setattr,\n    attrs_init,\n) -> tuple[str, dict, dict]:\n    has_cls_on_setattr = (\n        cls_on_setattr is not None and cls_on_setattr is not setters.NO_OP\n    )\n\n    if frozen and has_cls_on_setattr:\n        msg = \"Frozen classes can't use on_setattr.\"\n        raise ValueError(msg)\n\n    needs_cached_setattr = cache_hash or frozen\n    filtered_attrs = []\n    attr_dict = {}\n    for a in attrs:\n        if not a.init and a.default is NOTHING:\n            continue\n\n        filtered_attrs.append(a)\n        attr_dict[a.name] = a\n\n        if a.on_setattr is not None:\n            if frozen is True:\n                msg = \"Frozen classes can't use on_setattr.\"\n                raise ValueError(msg)\n\n            needs_cached_setattr = True\n        elif has_cls_on_setattr and a.on_setattr is not setters.NO_OP:\n            needs_cached_setattr = True\n\n    script, globs, annotations = _attrs_to_init_script(\n        filtered_attrs,\n        frozen,\n        slots,\n        pre_init,\n        pre_init_has_args,\n        post_init,\n        cache_hash,\n        base_attr_map,\n        is_exc,\n        needs_cached_setattr,\n        has_cls_on_setattr,\n        \"__attrs_init__\" if attrs_init else \"__init__\",\n    )\n    if cls.__module__ in sys.modules:\n        # This makes typing.get_type_hints(CLS.__init__) resolve string types.\n        globs.update(sys.modules[cls.__module__].__dict__)\n\n    globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n\n    if needs_cached_setattr:\n        # Save the lookup overhead in __init__ if we need to circumvent\n        # setattr hooks.\n        globs[\"_cached_setattr_get\"] = _OBJ_SETATTR.__get__\n\n    return script, globs, annotations"
}