{
    "sympy.sympy.polys.domains.domain.convert": "def convert(self,\n            element: Es | Expr | complex,\n            base: Domain[Es] | None = None\n            ) -> Er:\n    \"\"\"Convert ``element`` to ``self.dtype``. \"\"\"\n\n    if base is not None:\n        if _not_a_coeff(element):\n            raise CoercionFailed('%s is not in any domain' % element)\n        return self.convert_from(element, base) # type: ignore\n\n    if self.of_type(element):\n        return element\n\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ) # type: ignore\n\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n\n    if GROUND_TYPES != 'python':\n        if isinstance(element, ZZ.tp):\n            return self.convert_from(element, ZZ) # type: ignore\n        if isinstance(element, QQ.tp):\n            return self.convert_from(element, QQ) # type: ignore\n\n    if isinstance(element, float):\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if isinstance(element, complex):\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if type(element).__name__ == 'mpf':\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if type(element).__name__ == 'mpc':\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n\n    # TODO: implement this in from_ methods\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC()) # type: ignore\n\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    else: # TODO: remove this branch\n        if not is_sequence(element):\n            try:\n                element = sympify(element, strict=True) # type: ignore\n                if isinstance(element, Basic):\n                    return self.from_sympy(element) # type: ignore\n            except (TypeError, ValueError):\n                pass\n\n    raise CoercionFailed(\"Cannot convert %s of type %s to %s\" % (element, type(element), self))",
    "sympy.sympy.polys.domains.integerring.get_field": "def get_field(self):\n    r\"\"\"Return the associated field of fractions :ref:`QQ`\n\n    Returns\n    =======\n\n    :ref:`QQ`:\n        The associated field of fractions :ref:`QQ`, a\n        :py:class:`~.Domain` representing the rational numbers\n        `\\mathbb{Q}`.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> ZZ.get_field()\n    QQ\n    \"\"\"\n    from sympy.polys.domains import QQ\n    return QQ",
    "sympy.sympy.polys.domains.rationalfield.numer": "def numer(self, a):\n    \"\"\"Returns numerator of ``a``. \"\"\"\n    return a.numerator",
    "sympy.sympy.polys.domains.rationalfield.denom": "def denom(self, a):\n    \"\"\"Returns denominator of ``a``. \"\"\"\n    return a.denominator",
    "sympy.sympy.polys.fields.raw_new": "def raw_new(self,\n        numer: PolyElement[Er],\n        denom: PolyElement[Er] | None = None) -> FracElement[Er]:\n    return self.dtype(numer, denom)",
    "sympy.sympy.polys.fields.new": "def new(self,\n        numer: PolyElement[Er],\n        denom: PolyElement[Er] | None = None) -> FracElement[Er]:\n    if denom is None:\n        denom = self.ring.one\n    numer, denom = numer.cancel(denom)\n    return self.raw_new(numer, denom)",
    "sympy.sympy.polys.rings.ground_new": "def ground_new(self, coeff) -> PolyElement[Er]:\n    \"\"\"Create a constant polynomial with given coefficient.\"\"\"\n    return self.term_new(self.zero_monom, coeff)"
}