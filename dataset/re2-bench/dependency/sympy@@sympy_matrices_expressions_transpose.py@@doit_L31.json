{
    "sympy.sympy.core.basic.doit": "def doit(self, **hints):\n    return self",
    "sympy.sympy.core.expr._eval_transpose": "def _eval_transpose(self):\n    from sympy.functions.elementary.complexes import conjugate\n    if self.is_commutative:\n        return self\n    elif self.is_hermitian:\n        return conjugate(self)\n    elif self.is_antihermitian:\n        return -conjugate(self)",
    "sympy.sympy.matrices.expressions.applyfunc._eval_transpose": "def _eval_transpose(self):\n    from sympy.matrices.expressions.transpose import Transpose\n    return self.func(self.function, Transpose(self.expr).doit())",
    "sympy.sympy.matrices.expressions.applyfunc.doit": "def doit(self, **hints):\n    deep = hints.get(\"deep\", True)\n    expr = self.expr\n    if deep:\n        expr = expr.doit(**hints)\n    function = self.function\n    if isinstance(function, Lambda) and function.is_identity:\n        # This is a Lambda containing the identity function.\n        return expr\n    if isinstance(expr, MatrixBase):\n        return expr.applyfunc(self.function)\n    elif isinstance(expr, ElementwiseApplyFunction):\n        return ElementwiseApplyFunction(\n            lambda x: self.function(expr.function(x)),\n            expr.expr\n        ).doit(**hints)\n    else:\n        return self",
    "sympy.sympy.matrices.expressions.blockmatrix._eval_transpose": "def _eval_transpose(self):\n    # Flip all the individual matrices\n    matrices = [transpose(matrix) for matrix in self.blocks]\n    # Make a copy\n    M = Matrix(self.blockshape[0], self.blockshape[1], matrices)\n    # Transpose the block structure\n    M = M.transpose()\n    return BlockMatrix(M)",
    "sympy.sympy.matrices.expressions.diagonal._eval_transpose": "def _eval_transpose(self):\n    return self",
    "sympy.sympy.matrices.expressions.diagonal.doit": "def doit(self, **hints):\n    from sympy.assumptions import ask, Q\n    from sympy.matrices.expressions.matmul import MatMul\n    from sympy.matrices.expressions.transpose import Transpose\n    from sympy.matrices.dense import eye\n    from sympy.matrices.matrixbase import MatrixBase\n    vector = self._vector\n    # This accounts for shape (1, 1) and identity matrices, among others:\n    if ask(Q.diagonal(vector)):\n        return vector\n    if isinstance(vector, MatrixBase):\n        ret = eye(max(vector.shape))\n        for i in range(ret.shape[0]):\n            ret[i, i] = vector[i]\n        return type(vector)(ret)\n    if vector.is_MatMul:\n        matrices = [arg for arg in vector.args if arg.is_Matrix]\n        scalars = [arg for arg in vector.args if arg not in matrices]\n        if scalars:\n            return Mul.fromiter(scalars)*DiagMatrix(MatMul.fromiter(matrices).doit()).doit()\n    if isinstance(vector, Transpose):\n        vector = vector.arg\n    return DiagMatrix(vector)",
    "sympy.sympy.matrices.expressions.hadamard._eval_transpose": "def _eval_transpose(self):\n    from sympy.matrices.expressions.transpose import transpose\n    return HadamardProduct(*list(map(transpose, self.args)))",
    "sympy.sympy.matrices.expressions.hadamard.doit": "def doit(self, **hints):\n    expr = self.func(*(i.doit(**hints) for i in self.args))\n    # Check for explicit matrices:\n    from sympy.matrices.matrixbase import MatrixBase\n    from sympy.matrices.immutable import ImmutableMatrix\n\n    explicit = [i for i in expr.args if isinstance(i, MatrixBase)]\n    if explicit:\n        remainder = [i for i in expr.args if i not in explicit]\n        expl_mat = ImmutableMatrix([\n            Mul.fromiter(i) for i in zip(*explicit)\n        ]).reshape(*self.shape)\n        expr = HadamardProduct(*([expl_mat] + remainder))\n\n    return canonicalize(expr)",
    "sympy.sympy.matrices.expressions.inverse._eval_transpose": "def _eval_transpose(self):\n    return Inverse(self.arg.transpose())",
    "sympy.sympy.matrices.expressions.inverse.doit": "def doit(self, **hints):\n    if 'inv_expand' in hints and hints['inv_expand'] == False:\n        return self\n\n    arg = self.arg\n    if hints.get('deep', True):\n        arg = arg.doit(**hints)\n\n    return arg.inverse()",
    "sympy.sympy.matrices.expressions.kronecker._eval_transpose": "def _eval_transpose(self):\n    return KroneckerProduct(*list(map(transpose, self.args))).doit()",
    "sympy.sympy.matrices.expressions.matadd._eval_transpose": "def _eval_transpose(self):\n    return MatAdd(*[transpose(arg) for arg in self.args]).doit()",
    "sympy.sympy.matrices.expressions.matadd.doit": "def doit(self, **hints):\n    deep = hints.get('deep', True)\n    if deep:\n        args = [arg.doit(**hints) for arg in self.args]\n    else:\n        args = self.args\n    return canonicalize(MatAdd(*args))",
    "sympy.sympy.matrices.expressions.matexpr._eval_transpose": "def _eval_transpose(self):\n    return Transpose(self)",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, *args, **kwargs):\n    args = map(_sympify, args)\n    return Basic.__new__(cls, *args, **kwargs)",
    "sympy.sympy.matrices.expressions.matmul._eval_transpose": "def _eval_transpose(self):\n    \"\"\"Transposition of matrix multiplication.\n\n    Notes\n    =====\n\n    The following rules are applied.\n\n    Transposition for matrix multiplied with another matrix:\n    `\\\\left(A B\\\\right)^{T} = B^{T} A^{T}`\n\n    Transposition for matrix multiplied with scalar:\n    `\\\\left(c A\\\\right)^{T} = c A^{T}`\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Transpose\n    \"\"\"\n    coeff, matrices = self.as_coeff_matrices()\n    return MatMul(\n        coeff, *[transpose(arg) for arg in matrices[::-1]]).doit()",
    "sympy.sympy.matrices.expressions.matmul.doit": "def doit(self, **hints):\n    deep = hints.get('deep', True)\n    if deep:\n        args = tuple(arg.doit(**hints) for arg in self.args)\n    else:\n        args = self.args\n\n    # treat scalar*MatrixSymbol or scalar*MatPow separately\n    expr = canonicalize(MatMul(*args))\n    return expr",
    "sympy.sympy.matrices.expressions.matpow.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        base, exp = (arg.doit(**hints) for arg in self.args)\n    else:\n        base, exp = self.args\n\n    # combine all powers, e.g. (A ** 2) ** 3 -> A ** 6\n    while isinstance(base, MatPow):\n        exp *= base.args[1]\n        base = base.args[0]\n\n    if isinstance(base, MatrixBase):\n        # Delegate\n        return base ** exp\n\n    # Handle simple cases so that _eval_power() in MatrixExpr sub-classes can ignore them\n    if exp == S.One:\n        return base\n    if exp == S.Zero:\n        return Identity(base.rows)\n    if exp == S.NegativeOne:\n        from sympy.matrices.expressions import Inverse\n        return Inverse(base).doit(**hints)\n\n    eval_power = getattr(base, '_eval_power', None)\n    if eval_power is not None:\n        return eval_power(exp)\n\n    return MatPow(base, exp)",
    "sympy.sympy.matrices.expressions.matpow._eval_transpose": "def _eval_transpose(self):\n    base, exp = self.args\n    return MatPow(base.transpose(), exp)",
    "sympy.sympy.matrices.expressions.special._eval_transpose": "def _eval_transpose(self):\n    return ZeroMatrix(self.cols, self.rows)",
    "sympy.sympy.matrices.expressions.transpose.doit": "def doit(self, **hints):\n    arg = self.arg\n    if hints.get('deep', True) and isinstance(arg, Basic):\n        arg = arg.doit(**hints)\n    _eval_transpose = getattr(arg, '_eval_transpose', None)\n    if _eval_transpose is not None:\n        result = _eval_transpose()\n        return result if result is not None else Transpose(arg)\n    else:\n        return Transpose(arg)",
    "sympy.sympy.matrices.expressions.transpose.arg": "@property\ndef arg(self):\n    return self.args[0]",
    "sympy.sympy.matrices.expressions.transpose._eval_transpose": "def _eval_transpose(self):\n    return self.arg",
    "sympy.sympy.matrices.matrixbase.doit": "def doit(self, **hints) -> Self:\n    return self.applyfunc(lambda x: x.doit(**hints))",
    "sympy.sympy.matrices.repmatrix._eval_transpose": "def _eval_transpose(self):\n    \"\"\"Returns the transposed SparseMatrix of this SparseMatrix.\n\n    Examples\n    ========\n\n    >>> from sympy import SparseMatrix\n    >>> a = SparseMatrix(((1, 2), (3, 4)))\n    >>> a\n    Matrix([\n    [1, 2],\n    [3, 4]])\n    >>> a.T\n    Matrix([\n    [1, 3],\n    [2, 4]])\n    \"\"\"\n    return self._fromrep(self._rep.transpose())"
}