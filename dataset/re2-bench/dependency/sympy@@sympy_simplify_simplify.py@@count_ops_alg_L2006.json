{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.expr.could_extract_minus_sign": "def could_extract_minus_sign(self) -> bool:\n    \"\"\"Return True if self has -1 as a leading factor or has\n    more literal negative signs than positive signs in a sum,\n    otherwise False.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> e = x - y\n    >>> {i.could_extract_minus_sign() for i in (e, -e)}\n    {False, True}\n\n    Though the ``y - x`` is considered like ``-(x - y)``, since it\n    is in a product without a leading factor of -1, the result is\n    false below:\n\n    >>> (x*(y - x)).could_extract_minus_sign()\n    False\n\n    To put something in canonical form wrt to sign, use `signsimp`:\n\n    >>> from sympy import signsimp\n    >>> signsimp(x*(y - x))\n    -x*(x - y)\n    >>> _.could_extract_minus_sign()\n    True\n    \"\"\"\n    return False",
    "sympy.sympy.core.mul.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    if self == (-self):\n        return False  # e.g. zoo*x == -zoo*x\n    c = self.args[0]\n    return c.is_Number and c.is_extended_negative",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.simplify.radsimp.fraction": "def fraction(expr, exact=False):\n    \"\"\"Returns a pair with expression's numerator and denominator.\n       If the given expression is not a fraction then this function\n       will return the tuple (expr, 1).\n\n       This function will not make any attempt to simplify nested\n       fractions or to do any term rewriting at all.\n\n       If only one of the numerator/denominator pair is needed then\n       use numer(expr) or denom(expr) functions respectively.\n\n       >>> from sympy import fraction, Rational, Symbol\n       >>> from sympy.abc import x, y\n\n       >>> fraction(x/y)\n       (x, y)\n       >>> fraction(x)\n       (x, 1)\n\n       >>> fraction(1/y**2)\n       (1, y**2)\n\n       >>> fraction(x*y/2)\n       (x*y, 2)\n       >>> fraction(Rational(1, 2))\n       (1, 2)\n\n       This function will also work fine with assumptions:\n\n       >>> k = Symbol('k', negative=True)\n       >>> fraction(x * y**k)\n       (x, y**(-k))\n\n       If we know nothing about sign of some exponent and ``exact``\n       flag is unset, then the exponent's structure will\n       be analyzed and pretty fraction will be returned:\n\n       >>> from sympy import exp, Mul\n       >>> fraction(2*x**(-y))\n       (2, x**y)\n\n       >>> fraction(exp(-x))\n       (1, exp(x))\n\n       >>> fraction(exp(-x), exact=True)\n       (exp(-x), 1)\n\n       The ``exact`` flag will also keep any unevaluated Muls from\n       being evaluated:\n\n       >>> u = Mul(2, x + 1, evaluate=False)\n       >>> fraction(u)\n       (2*x + 2, 1)\n       >>> fraction(u, exact=True)\n       (2*(x  + 1), 1)\n    \"\"\"\n    expr = sympify(expr)\n\n    numer, denom = [], []\n\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()  # this will cause evaluation\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and not term.is_Integer:\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact)"
}