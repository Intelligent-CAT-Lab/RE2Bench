{
    "scikit-learn.sklearn.base.set_params": "def set_params(self, **params):\n    \"\"\"Set the parameters of this estimator.\n\n    The method works on simple estimators as well as on nested objects\n    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n    parameters of the form ``<component>__<parameter>`` so that it's\n    possible to update each component of a nested object.\n\n    Parameters\n    ----------\n    **params : dict\n        Estimator parameters.\n\n    Returns\n    -------\n    self : estimator instance\n        Estimator instance.\n    \"\"\"\n    if not params:\n        # Simple optimization to gain speed (inspect is slow)\n        return self\n    valid_params = self.get_params(deep=True)\n\n    nested_params = defaultdict(dict)  # grouped by prefix\n    for key, value in params.items():\n        key, delim, sub_key = key.partition(\"__\")\n        if key not in valid_params:\n            local_valid_params = self._get_param_names()\n            raise ValueError(\n                f\"Invalid parameter {key!r} for estimator {self}. \"\n                f\"Valid parameters are: {local_valid_params!r}.\"\n            )\n\n        if delim:\n            nested_params[key][sub_key] = value\n        else:\n            setattr(self, key, value)\n            valid_params[key] = value\n\n    for key, sub_params in nested_params.items():\n        valid_params[key].set_params(**sub_params)\n\n    return self",
    "scikit-learn.sklearn.base.clone": "def clone(estimator, *, safe=True):\n    \"\"\"Construct a new unfitted estimator with the same parameters.\n\n    Clone does a deep copy of the model in an estimator\n    without actually copying attached data. It returns a new estimator\n    with the same parameters that has not been fitted on any data.\n\n    .. versionchanged:: 1.3\n        Delegates to `estimator.__sklearn_clone__` if the method exists.\n\n    Parameters\n    ----------\n    estimator : {list, tuple, set} of estimator instance or a single \\\n            estimator instance\n        The estimator or group of estimators to be cloned.\n    safe : bool, default=True\n        If safe is False, clone will fall back to a deep copy on objects\n        that are not estimators. Ignored if `estimator.__sklearn_clone__`\n        exists.\n\n    Returns\n    -------\n    estimator : object\n        The deep copy of the input, an estimator if input is an estimator.\n\n    Notes\n    -----\n    If the estimator's `random_state` parameter is an integer (or if the\n    estimator doesn't have a `random_state` parameter), an *exact clone* is\n    returned: the clone and the original estimator will give the exact same\n    results. Otherwise, *statistical clone* is returned: the clone might\n    return different results from the original estimator. More details can be\n    found in :ref:`randomness`.\n\n    Examples\n    --------\n    >>> from sklearn.base import clone\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X = [[-1, 0], [0, 1], [0, -1], [1, 0]]\n    >>> y = [0, 0, 1, 1]\n    >>> classifier = LogisticRegression().fit(X, y)\n    >>> cloned_classifier = clone(classifier)\n    >>> hasattr(classifier, \"classes_\")\n    True\n    >>> hasattr(cloned_classifier, \"classes_\")\n    False\n    >>> classifier is cloned_classifier\n    False\n    \"\"\"\n    if hasattr(estimator, \"__sklearn_clone__\") and not inspect.isclass(estimator):\n        return estimator.__sklearn_clone__()\n    return _clone_parametrized(estimator, safe=safe)",
    "scikit-learn.sklearn.ensemble._base.<dictcomp>": "estimator.set_params(**{p: getattr(self, p) for p in self.estimator_params})\n\n",
    "scikit-learn.sklearn.ensemble._base._set_random_states": "def _set_random_states(estimator, random_state=None):\n    \"\"\"Set fixed random_state parameters for an estimator.\n\n    Finds all parameters ending ``random_state`` and sets them to integers\n    derived from ``random_state``.\n\n    Parameters\n    ----------\n    estimator : estimator supporting get/set_params\n        Estimator with potential randomness managed by random_state\n        parameters.\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo-random number generator to control the generation of the random\n        integers. Pass an int for reproducible output across multiple function\n        calls.\n        See :term:`Glossary <random_state>`.\n\n    Notes\n    -----\n    This does not necessarily set *all* ``random_state`` attributes that\n    control an estimator's randomness, only those accessible through\n    ``estimator.get_params()``.  ``random_state``s not controlled include\n    those belonging to:\n\n        * cross-validation splitters\n        * ``scipy.stats`` rvs\n    \"\"\"\n    random_state = check_random_state(random_state)\n    to_set = {}\n    for key in sorted(estimator.get_params(deep=True)):\n        if key == \"random_state\" or key.endswith(\"__random_state\"):\n            to_set[key] = random_state.randint(np.iinfo(np.int32).max)\n\n    if to_set:\n        estimator.set_params(**to_set)",
    "scikit-learn.sklearn.pipeline.set_params": "def set_params(self, **kwargs):\n    \"\"\"Set the parameters of this estimator.\n\n    Valid parameter keys can be listed with ``get_params()``. Note that\n    you can directly set the parameters of the estimators contained in\n    `steps`.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Parameters of this estimator or parameters of estimators contained\n        in `steps`. Parameters of the steps may be set using its name and\n        the parameter name separated by a '__'.\n\n    Returns\n    -------\n    self : object\n        Pipeline class instance.\n    \"\"\"\n    self._set_params(\"steps\", **kwargs)\n    return self"
}