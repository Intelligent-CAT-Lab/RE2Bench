{
    "sympy.sympy.combinatorics.permutations.__iter__": "def __iter__(self):\n    \"\"\"Yield elements from array form.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Permutation\n    >>> list(Permutation(range(3)))\n    [0, 1, 2]\n    \"\"\"\n    yield from self.array_form",
    "sympy.sympy.combinatorics.permutations.__new__": "def __new__(cls, *args, size=None, **kwargs):\n    \"\"\"\n    Constructor for the Permutation object from a list or a\n    list of lists in which all elements of the permutation may\n    appear only once.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Permutation\n    >>> from sympy import init_printing\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n\n    Permutations entered in array-form are left unaltered:\n\n    >>> Permutation([0, 2, 1])\n    Permutation([0, 2, 1])\n\n    Permutations entered in cyclic form are converted to array form;\n    singletons need not be entered, but can be entered to indicate the\n    largest element:\n\n    >>> Permutation([[4, 5, 6], [0, 1]])\n    Permutation([1, 0, 2, 3, 5, 6, 4])\n    >>> Permutation([[4, 5, 6], [0, 1], [19]])\n    Permutation([1, 0, 2, 3, 5, 6, 4], size=20)\n\n    All manipulation of permutations assumes that the smallest element\n    is 0 (in keeping with 0-based indexing in Python) so if the 0 is\n    missing when entering a permutation in array form, an error will be\n    raised:\n\n    >>> Permutation([2, 1])\n    Traceback (most recent call last):\n    ...\n    ValueError: Integers 0 through 2 must be present.\n\n    If a permutation is entered in cyclic form, it can be entered without\n    singletons and the ``size`` specified so those values can be filled\n    in, otherwise the array form will only extend to the maximum value\n    in the cycles:\n\n    >>> Permutation([[1, 4], [3, 5, 2]], size=10)\n    Permutation([0, 4, 3, 5, 1, 2], size=10)\n    >>> _.array_form\n    [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]\n    \"\"\"\n    if size is not None:\n        size = int(size)\n\n    #a) ()\n    #b) (1) = identity\n    #c) (1, 2) = cycle\n    #d) ([1, 2, 3]) = array form\n    #e) ([[1, 2]]) = cyclic form\n    #f) (Cycle) = conversion to permutation\n    #g) (Permutation) = adjust size or return copy\n    ok = True\n    if not args:  # a\n        return cls._af_new(list(range(size or 0)))\n    elif len(args) > 1:  # c\n        return cls._af_new(Cycle(*args).list(size))\n    if len(args) == 1:\n        a = args[0]\n        if isinstance(a, cls):  # g\n            if size is None or size == a.size:\n                return a\n            return cls(a.array_form, size=size)\n        if isinstance(a, Cycle):  # f\n            return cls._af_new(a.list(size))\n        if not is_sequence(a):  # b\n            if size is not None and a + 1 > size:\n                raise ValueError('size is too small when max is %s' % a)\n            return cls._af_new(list(range(a + 1)))\n        if has_variety(is_sequence(ai) for ai in a):\n            ok = False\n    else:\n        ok = False\n    if not ok:\n        raise ValueError(\"Permutation argument must be a list of ints, \"\n                         \"a list of lists, Permutation or Cycle.\")\n\n    # safe to assume args are valid; this also makes a copy\n    # of the args\n    args = list(args[0])\n\n    is_cycle = args and is_sequence(args[0])\n    if is_cycle:  # e\n        args = [[int(i) for i in c] for c in args]\n    else:  # d\n        args = [int(i) for i in args]\n\n    # if there are n elements present, 0, 1, ..., n-1 should be present\n    # unless a cycle notation has been provided. A 0 will be added\n    # for convenience in case one wants to enter permutations where\n    # counting starts from 1.\n\n    temp = flatten(args)\n    if has_dups(temp) and not is_cycle:\n        raise ValueError('there were repeated elements.')\n    temp = set(temp)\n\n    if not is_cycle:\n        if temp != set(range(len(temp))):\n            raise ValueError('Integers 0 through %s must be present.' %\n            max(temp))\n        if size is not None and temp and max(temp) + 1 > size:\n            raise ValueError('max element should not exceed %s' % (size - 1))\n\n    if is_cycle:\n        # it's not necessarily canonical so we won't store\n        # it -- use the array form instead\n        c = Cycle()\n        for ci in args:\n            c = c(*ci)\n        aform = c.list()\n    else:\n        aform = list(args)\n    if size and size > len(aform):\n        # don't allow for truncation of permutation which\n        # might split a cycle and lead to an invalid aform\n        # but do allow the permutation size to be increased\n        aform.extend(list(range(len(aform), size)))\n\n    return cls._af_new(aform)",
    "sympy.sympy.core.expr.__format__": "def __format__(self, format_spec: str):\n    if self.is_number:\n        mt = re.match(r'\\+?\\d*\\.(\\d+)f', format_spec)\n        if mt:\n            prec = int(mt.group(1))\n            rounded = self.round(prec)\n            if rounded.is_Integer:\n                return format(int(rounded), format_spec)\n            if rounded.is_Float:\n                return format(rounded, format_spec)\n    return super().__format__(format_spec)",
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.matrixbase._eval_permute_cols": "def _eval_permute_cols(self, perm) -> Self:\n    # apply the permutation to a list\n    mapping = list(perm)\n\n    def entry(i, j):\n        return self[i, mapping[j]]\n\n    return self._new(self.rows, self.cols, entry)",
    "sympy.sympy.matrices.matrixbase._eval_permute_rows": "def _eval_permute_rows(self, perm) -> Self:\n    # apply the permutation to a list\n    mapping = list(perm)\n\n    def entry(i, j):\n        return self[mapping[i], j]\n\n    return self._new(self.rows, self.cols, entry)",
    "sympy.sympy.matrices.matrixbase.<genexpr>": "if not all(0 <= t <= max_index for t in flatten(list(perm))):\n    raise IndexError(\"`swap` indices out of range.\")\n\n",
    "sympy.sympy.utilities.iterables.flatten": "def flatten(iterable, levels=None, cls=None):  # noqa: F811\n    \"\"\"\n    Recursively denest iterable containers.\n\n    >>> from sympy import flatten\n\n    >>> flatten([1, 2, 3])\n    [1, 2, 3]\n    >>> flatten([1, 2, [3]])\n    [1, 2, 3]\n    >>> flatten([1, [2, 3], [4, 5]])\n    [1, 2, 3, 4, 5]\n    >>> flatten([1.0, 2, (1, None)])\n    [1.0, 2, 1, None]\n\n    If you want to denest only a specified number of levels of\n    nested containers, then set ``levels`` flag to the desired\n    number of levels::\n\n    >>> ls = [[(-2, -1), (1, 2)], [(0, 0)]]\n\n    >>> flatten(ls, levels=1)\n    [(-2, -1), (1, 2), (0, 0)]\n\n    If cls argument is specified, it will only flatten instances of that\n    class, for example:\n\n    >>> from sympy import Basic, S\n    >>> class MyOp(Basic):\n    ...     pass\n    ...\n    >>> flatten([MyOp(S(1), MyOp(S(2), S(3)))], cls=MyOp)\n    [1, 2, 3]\n\n    adapted from https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks\n    \"\"\"\n    from sympy.tensor.array import NDimArray\n    if levels is not None:\n        if not levels:\n            return iterable\n        elif levels > 0:\n            levels -= 1\n        else:\n            raise ValueError(\n                \"expected non-negative number of levels, got %s\" % levels)\n\n    if cls is None:\n        def reducible(x):\n            return is_sequence(x, set)\n    else:\n        def reducible(x):\n            return isinstance(x, cls)\n\n    result = []\n\n    for el in iterable:\n        if reducible(el):\n            if hasattr(el, 'args') and not isinstance(el, NDimArray):\n                el = el.args\n            result.extend(flatten(el, levels=levels, cls=cls))\n        else:\n            result.append(el)\n\n    return result"
}