{
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.extract_additively": "def extract_additively(self, c):\n    \"\"\"Return self - c if it's possible to subtract c from self and\n    make all matching coefficients move towards zero, else return None.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> e = 2*x + 3\n    >>> e.extract_additively(x + 1)\n    x + 2\n    >>> e.extract_additively(3*x)\n    >>> e.extract_additively(4)\n    >>> (y*(x + 1)).extract_additively(x + 1)\n    >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n    (x + 1)*(x + 2*y) + 3\n\n    See Also\n    ========\n    extract_multiplicatively\n    coeff\n    as_coefficient\n\n    \"\"\"\n\n    c = sympify(c)\n    if self is S.NaN:\n        return None\n    if c.is_zero:\n        return self\n    elif c == self:\n        return S.Zero\n    elif self == S.Zero:\n        return None\n\n    if self.is_Number:\n        if not c.is_Number:\n            return None\n        co = self\n        diff = co - c\n        # XXX should we match types? i.e should 3 - .1 succeed?\n        if (co > 0 and diff >= 0 and diff < co or\n                co < 0 and diff <= 0 and diff > co):\n            return diff\n        return None\n\n    if c.is_Number:\n        co, t = self.as_coeff_Add()\n        xa = co.extract_additively(c)\n        if xa is None:\n            return None\n        return xa + t\n\n    # handle the args[0].is_Number case separately\n    # since we will have trouble looking for the coeff of\n    # a number.\n    if c.is_Add and c.args[0].is_Number:\n        # whole term as a term factor\n        co = self.coeff(c)\n        xa0 = (co.extract_additively(1) or 0)*c\n        if xa0:\n            diff = self - co*c\n            return (xa0 + (diff.extract_additively(c) or diff)) or None\n        # term-wise\n        h, t = c.as_coeff_Add()\n        sh, st = self.as_coeff_Add()\n        xa = sh.extract_additively(h)\n        if xa is None:\n            return None\n        xa2 = st.extract_additively(t)\n        if xa2 is None:\n            return None\n        return xa + xa2\n\n    # whole term as a term factor\n    co, diff = _corem(self, c)\n    xa0 = (co.extract_additively(1) or 0)*c\n    if xa0:\n        return (xa0 + (diff.extract_additively(c) or diff)) or None\n    # term-wise\n    coeffs = []\n    for a in Add.make_args(c):\n        ac, at = a.as_coeff_Mul()\n        co = self.coeff(at)\n        if not co:\n            return None\n        coc, cot = co.as_coeff_Add()\n        xa = coc.extract_additively(ac)\n        if xa is None:\n            return None\n        self -= co*at\n        coeffs.append((cot + xa)*at)\n    coeffs.append(self)\n    return Add(*coeffs)",
    "sympy.sympy.core.expr.as_coeff_Add": "def as_coeff_Add(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return S.Zero, self",
    "sympy.sympy.core.exprtools.__init__": "def __init__(self, factors=None):  # Factors\n    \"\"\"Initialize Factors from dict or expr.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x\n    >>> from sympy import I\n    >>> e = 2*x**3\n    >>> Factors(e)\n    Factors({2: 1, x: 3})\n    >>> Factors(e.as_powers_dict())\n    Factors({2: 1, x: 3})\n    >>> f = _\n    >>> f.factors  # underlying dictionary\n    {2: 1, x: 3}\n    >>> f.gens  # base of each factor\n    frozenset({2, x})\n    >>> Factors(0)\n    Factors({0: 1})\n    >>> Factors(I)\n    Factors({I: 1})\n\n    Notes\n    =====\n\n    Although a dictionary can be passed, only minimal checking is\n    performed: powers of -1 and I are made canonical.\n\n    \"\"\"\n    if isinstance(factors, (SYMPY_INTS, float)):\n        factors = S(factors)\n    if isinstance(factors, Factors):\n        factors = factors.factors.copy()\n    elif factors in (None, S.One):\n        factors = {}\n    elif factors is S.Zero or factors == 0:\n        factors = {S.Zero: S.One}\n    elif isinstance(factors, Number):\n        n = factors\n        factors = {}\n        if n < 0:\n            factors[S.NegativeOne] = S.One\n            n = -n\n        if n is not S.One:\n            if n.is_Float or n.is_Integer or n is S.Infinity:\n                factors[n] = S.One\n            elif n.is_Rational:\n                # since we're processing Numbers, the denominator is\n                # stored with a negative exponent; all other factors\n                # are left .\n                if n.p != 1:\n                    factors[Integer(n.p)] = S.One\n                factors[Integer(n.q)] = S.NegativeOne\n            else:\n                raise ValueError('Expected Float|Rational|Integer, not %s' % n)\n    elif isinstance(factors, Basic) and not factors.args:\n        factors = {factors: S.One}\n    elif isinstance(factors, Expr):\n        c, nc = factors.args_cnc()\n        i = c.count(I)\n        for _ in range(i):\n            c.remove(I)\n        factors = dict(Mul._from_args(c).as_powers_dict())\n        # Handle all rational Coefficients\n        for f in list(factors.keys()):\n            if isinstance(f, Rational) and not isinstance(f, Integer):\n                p, q = Integer(f.p), Integer(f.q)\n                factors[p] = (factors[p] if p in factors else S.Zero) + factors[f]\n                factors[q] = (factors[q] if q in factors else S.Zero) - factors[f]\n                factors.pop(f)\n        if i:\n            factors[I] = factors.get(I, S.Zero) + i\n        if nc:\n            factors[Mul(*nc, evaluate=False)] = S.One\n    else:\n        factors = factors.copy()  # /!\\ should be dict-like\n\n        # tidy up -/+1 and I exponents if Rational\n\n        handle = [k for k in factors if k is I or k in (-1, 1)]\n        if handle:\n            i1 = S.One\n            for k in handle:\n                if not _isnumber(factors[k]):\n                    continue\n                i1 *= k**factors.pop(k)\n            if i1 is not S.One:\n                for a in i1.args if i1.is_Mul else [i1]:  # at worst, -1.0*I*(-1)**e\n                    if a is S.NegativeOne:\n                        factors[a] = S.One\n                    elif a is I:\n                        factors[I] = S.One\n                    elif a.is_Pow:\n                        factors[a.base] = factors.get(a.base, S.Zero) + a.exp\n                    elif equal_valued(a, 1):\n                        factors[a] = S.One\n                    elif equal_valued(a, -1):\n                        factors[-a] = S.One\n                        factors[S.NegativeOne] = S.One\n                    else:\n                        raise ValueError('unexpected factor in i1: %s' % a)\n\n    self.factors = factors\n    keys = getattr(factors, 'keys', None)\n    if keys is None:\n        raise TypeError('expecting Expr or dictionary')\n    self.gens = frozenset(keys())",
    "sympy.sympy.core.exprtools._isnumber": "def _isnumber(i):\n    return isinstance(i, (SYMPY_INTS, float)) or i.is_Number",
    "sympy.sympy.core.exprtools.is_zero": "@property\ndef is_zero(self):  # Factors\n    \"\"\"\n    >>> from sympy.core.exprtools import Factors\n    >>> Factors(0).is_zero\n    True\n    \"\"\"\n    f = self.factors\n    return len(f) == 1 and S.Zero in f",
    "sympy.sympy.core.numbers.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return self, S.Zero",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    "sympy.sympy.core.numbers.__le__": "def __le__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p <= other.p)\n    return Rational.__le__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False"
}