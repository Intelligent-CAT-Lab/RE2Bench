{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.expr._from_mpmath": "@staticmethod\ndef _from_mpmath(x, prec):\n    if hasattr(x, \"_mpf_\"):\n        return Float._new(x._mpf_, prec)\n    elif hasattr(x, \"_mpc_\"):\n        re, im = x._mpc_\n        re = Float._new(re, prec)\n        im = Float._new(im, prec)*S.ImaginaryUnit\n        return re + im\n    else:\n        raise TypeError(\"expected mpmath number (mpf or mpc)\")",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.function._get_mpmath_func": "def _get_mpmath_func(fname):\n    \"\"\"Lookup mpmath function based on name\"\"\"\n    if isinstance(self, AppliedUndef):\n        # Shouldn't lookup in mpmath but might have ._imp_\n        return None\n\n    if not hasattr(mpmath, fname):\n        fname = MPMATH_TRANSLATIONS.get(fname, None)\n        if fname is None:\n            return None\n    return getattr(mpmath, fname)",
    "sympy.sympy.core.function.<listcomp>": "args = [arg._to_mpmath(prec + 5) for arg in args]\n",
    "sympy.sympy.core.function.<genexpr>": "if any(bad(a) for a in args):\n    raise ValueError  # one or more args failed to compute with significance\n",
    "sympy.sympy.core.numbers.__new__": "def __new__(cls, num, dps=None, precision=None):\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. '\n                         'Supply only one. ')\n\n    if isinstance(num, str):\n        _num = num = num.strip()  # Python ignores leading and trailing space\n        num = num.replace(' ', '_').lower()  # Float treats spaces as digit sep; E -> e\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n        elif num in ('inf', '+inf'):\n            return S.Infinity\n        elif num == '-inf':\n            return S.NegativeInfinity\n        elif num == 'nan':\n            return S.NaN\n        elif not _literal_float(num):\n            raise ValueError('string-float not recognized: %s' % _num)\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, float) and num == float('inf'):\n        return S.Infinity\n    elif isinstance(num, float) and num == float('-inf'):\n        return S.NegativeInfinity\n    elif isinstance(num, float) and math.isnan(num):\n        return S.NaN\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity or num is S.NegativeInfinity or num is S.NaN:\n        return num\n    elif _is_numpy_instance(num):  # support for numpy datatypes\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, str):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    # 12e3 is shorthand for int, not float;\n                    # 12.e3 would be the float version\n                    dps = max(dps, num_digits(num))\n                dps = max(15, dps)\n                precision = dps_to_prec(dps)\n    elif precision == '' and dps is None or precision is None and dps == '':\n        if not isinstance(num, str):\n            raise ValueError('The null string can only be used when '\n            'the number to Float is passed as a string or an integer.')\n        try:\n            Num = decimal.Decimal(num)\n        except decimal.InvalidOperation:\n            raise ValueError('string-float not recognized by Decimal: %s' % num)\n        else:\n            isint = '.' not in num\n            num, dps = _decimal_to_Rational_prec(Num)\n            if num.is_Integer and isint:\n                # without dec, e-notation is short for int\n                dps = max(dps, num_digits(num))\n                precision = dps_to_prec(dps)\n\n    # decimal precision(dps) is set and maybe binary precision(precision)\n    # as well.From here on binary precision is used to compute the Float.\n    # Hence, if supplied use binary precision else translate from decimal\n    # precision.\n\n    if precision is None or precision == '':\n        precision = dps_to_prec(dps)\n\n    precision = int(precision)\n\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, str):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            return S.NaN\n        elif num.is_infinite():\n            if num > 0:\n                return S.Infinity\n            return S.NegativeInfinity\n        else:\n            raise ValueError(\"unexpected decimal value %s\" % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if isinstance(num[1], str):\n            # it's a hexadecimal (coming from a pickled object)\n            num = list(num)\n            # If we're loading an object pickled in Python 2 into\n            # Python 3, we may need to strip a tailing 'L' because\n            # of a shim for int on Python 3, see issue #13470.\n            # Strip leading '0x' - gmpy2 only documents such inputs\n            # with base prefix as valid when the 2nd argument (base) is 0.\n            # When mpmath uses Sage as the backend, however, it\n            # ends up including '0x' when preparing the picklable tuple.\n            # See issue #19690.\n            num[1] = num[1].removeprefix('0x').removesuffix('L')\n            # Now we can assume that it is in standard form\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        else:\n            if len(num) == 4:\n                # handle normalization hack\n                return Float._new(num, precision)\n            else:\n                if not all((\n                        num[0] in (0, 1),\n                        num[1] >= 0,\n                        all(type(i) in (int, int) for i in num)\n                        )):\n                    raise ValueError('malformed mpf: %s' % (num,))\n                # don't compute number or else it may\n                # over/underflow\n                return Float._new(\n                    (num[0], num[1], num[2], num[1].bit_length()),\n                    precision)\n    elif isinstance(num, (Number, NumberSymbol)):\n        _mpf_ = num._as_mpf_val(precision)\n    else:\n        _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n\n    return cls._new(_mpf_, precision, zero=False)",
    "sympy.sympy.functions.special.beta_functions._eval_mpmath": "def _eval_mpmath(self):\n    return betainc_mpmath_fix, (*self.args, S(1))",
    "sympy.sympy.functions.special.beta_functions.betainc_mpmath_fix": "def betainc_mpmath_fix(a, b, x1, x2, reg=0):\n    from mpmath import betainc, mpf\n    if x1 == x2:\n        return mpf(0)\n    else:\n        return betainc(a, b, x1, x2, reg)"
}