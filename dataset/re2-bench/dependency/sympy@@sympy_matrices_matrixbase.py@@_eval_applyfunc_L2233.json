{
    "sympy.sympy.concrete.expr_with_limits.<lambda>": "return summand.applyfunc(lambda x: self.func(x, *self.limits))\n",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.exprtools.factor_terms": "def factor_terms(expr: Expr | complex, radical=False, clear=False, fraction=False, sign=True) -> Expr:\n    \"\"\"Remove common factors from terms in all arguments without\n    changing the underlying structure of the expr. No expansion or\n    simplification (and no processing of non-commutatives) is performed.\n\n    Parameters\n    ==========\n\n    radical: bool, optional\n        If radical=True then a radical common to all terms will be factored\n        out of any Add sub-expressions of the expr.\n\n    clear : bool, optional\n        If clear=False (default) then coefficients will not be separated\n        from a single Add if they can be distributed to leave one or more\n        terms with integer coefficients.\n\n    fraction : bool, optional\n        If fraction=True (default is False) then a common denominator will be\n        constructed for the expression.\n\n    sign : bool, optional\n        If sign=True (default) then even if the only factor in common is a -1,\n        it will be factored out of the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_terms, Symbol\n    >>> from sympy.abc import x, y\n    >>> factor_terms(x + x*(2 + 4*y)**3)\n    x*(8*(2*y + 1)**3 + 1)\n    >>> A = Symbol('A', commutative=False)\n    >>> factor_terms(x*A + x*A + x*y*A)\n    x*(y*A + 2*A)\n\n    When ``clear`` is False, a rational will only be factored out of an\n    Add expression if all terms of the Add have coefficients that are\n    fractions:\n\n    >>> factor_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> factor_terms(x/2 + 1, clear=True)\n    (x + 2)/2\n\n    If a -1 is all that can be factored out, to *not* factor it out, the\n    flag ``sign`` must be False:\n\n    >>> factor_terms(-x - y)\n    -(x + y)\n    >>> factor_terms(-x - y, sign=False)\n    -x - y\n    >>> factor_terms(-2*x - 2*y, sign=False)\n    -2*(x + y)\n\n    See Also\n    ========\n\n    gcd_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.integrals.integrals import Integral\n        is_iterable = iterable(expr)\n\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n\n        if expr.is_Pow or expr.is_Function or \\\n                is_iterable or not hasattr(expr, 'args_cnc'):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n\n        if isinstance(expr, (Sum, Integral)):\n            return _factor_sum_int(expr,\n                radical=radical, clear=clear,\n                fraction=fraction, sign=sign)\n\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            # get a common negative (if there) which gcd_terms does not remove\n            if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None\n                       for a in list_args):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            # rebuild p not worrying about the order which gcd_terms will fix\n            p = Add._from_args(list_args)\n            p = gcd_terms(p,\n                isprimitive=True,\n                clear=clear,\n                fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(\n                *[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr2 = sympify(expr)\n    return do(expr2)",
    "sympy.sympy.core.exprtools.factor_nc": "def factor_nc(expr):\n    \"\"\"Return the factored form of ``expr`` while handling non-commutative\n    expressions.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_nc, Symbol\n    >>> from sympy.abc import x\n    >>> A = Symbol('A', commutative=False)\n    >>> B = Symbol('B', commutative=False)\n    >>> factor_nc((x**2 + 2*A*x + A**2).expand())\n    (x + A)**2\n    >>> factor_nc(((x + A)*(x + B)).expand())\n    (x + A)*(x + B)\n    \"\"\"\n    expr = sympify(expr)\n    if not isinstance(expr, Expr) or not expr.args:\n        return expr\n    if not expr.is_Add:\n        return expr.func(*[factor_nc(a) for a in expr.args])\n    expr = expr.func(*[expand_power_exp(i) for i in expr.args])\n\n    from sympy.polys.polytools import gcd, factor\n    expr, rep, nc_symbols = _mask_nc(expr)\n\n    if rep:\n        return factor(expr).subs(rep)\n    else:\n        args = [a.args_cnc() for a in Add.make_args(expr)]\n        c = g = l = r = S.One\n        hit = False\n        # find any commutative gcd term\n        for i, a in enumerate(args):\n            if i == 0:\n                c = Mul._from_args(a[0])\n            elif a[0]:\n                c = gcd(c, Mul._from_args(a[0]))\n            else:\n                c = S.One\n        if c is not S.One:\n            hit = True\n            c, g = c.as_coeff_Mul()\n            if g is not S.One:\n                for i, (cc, _) in enumerate(args):\n                    cc = list(Mul.make_args(Mul._from_args(list(cc))/g))\n                    args[i][0] = cc\n            for i, (cc, _) in enumerate(args):\n                if cc:\n                    cc[0] = cc[0]/c\n                else:\n                    cc = [1/c]\n                args[i][0] = cc\n        # find any noncommutative common prefix\n        for i, a in enumerate(args):\n            if i == 0:\n                n = a[1][:]\n            else:\n                n = common_prefix(n, a[1])\n            if not n:\n                # is there a power that can be extracted?\n                if not args[0][1]:\n                    break\n                b, e = args[0][1][0].as_base_exp()\n                ok = False\n                if e.is_Integer:\n                    for t in args:\n                        if not t[1]:\n                            break\n                        bt, et = t[1][0].as_base_exp()\n                        if et.is_Integer and bt == b:\n                            e = min(e, et)\n                        else:\n                            break\n                    else:\n                        ok = hit = True\n                        l = b**e\n                        il = b**-e\n                        for _ in args:\n                            _[1][0] = il*_[1][0]\n                        break\n                if not ok:\n                    break\n        else:\n            hit = True\n            lenn = len(n)\n            l = Mul(*n)\n            for _ in args:\n                _[1] = _[1][lenn:]\n        # find any noncommutative common suffix\n        for i, a in enumerate(args):\n            if i == 0:\n                n = a[1][:]\n            else:\n                n = common_suffix(n, a[1])\n            if not n:\n                # is there a power that can be extracted?\n                if not args[0][1]:\n                    break\n                b, e = args[0][1][-1].as_base_exp()\n                ok = False\n                if e.is_Integer:\n                    for t in args:\n                        if not t[1]:\n                            break\n                        bt, et = t[1][-1].as_base_exp()\n                        if et.is_Integer and bt == b:\n                            e = min(e, et)\n                        else:\n                            break\n                    else:\n                        ok = hit = True\n                        r = b**e\n                        il = b**-e\n                        for _ in args:\n                            _[1][-1] = _[1][-1]*il\n                        break\n                if not ok:\n                    break\n        else:\n            hit = True\n            lenn = len(n)\n            r = Mul(*n)\n            for _ in args:\n                _[1] = _[1][:len(_[1]) - lenn]\n        if hit:\n            mid = Add(*[Mul(*cc)*Mul(*nc) for cc, nc in args])\n        else:\n            mid = expr\n\n        from sympy.simplify.powsimp import powsimp\n\n        # sort the symbols so the Dummys would appear in the same\n        # order as the original symbols, otherwise you may introduce\n        # a factor of -1, e.g. A**2 - B**2) -- {A:y, B:x} --> y**2 - x**2\n        # and the former factors into two terms, (A - B)*(A + B) while the\n        # latter factors into 3 terms, (-1)*(x - y)*(x + y)\n        rep1 = [(n, Dummy()) for n in sorted(nc_symbols, key=default_sort_key)]\n        unrep1 = [(v, k) for k, v in rep1]\n        unrep1.reverse()\n        new_mid, r2, _ = _mask_nc(mid.subs(rep1))\n        new_mid = powsimp(factor(new_mid))\n\n        new_mid = new_mid.subs(r2).subs(unrep1)\n\n        if new_mid.is_Pow:\n            return _keep_coeff(c, g*l*new_mid*r)\n\n        if new_mid.is_Mul:\n            def _pemexpand(expr):\n                \"Expand with the minimal set of hints necessary to check the result.\"\n                return expr.expand(deep=True, mul=True, power_exp=True,\n                    power_base=False, basic=False, multinomial=True, log=False)\n            # XXX TODO there should be a way to inspect what order the terms\n            # must be in and just select the plausible ordering without\n            # checking permutations\n            cfac = []\n            ncfac = []\n            for f in new_mid.args:\n                if f.is_commutative:\n                    cfac.append(f)\n                else:\n                    b, e = f.as_base_exp()\n                    if e.is_Integer:\n                        ncfac.extend([b]*e)\n                    else:\n                        ncfac.append(f)\n            pre_mid = g*Mul(*cfac)*l\n            target = _pemexpand(expr/c)\n            for s in variations(ncfac, len(ncfac)):\n                ok = pre_mid*Mul(*s)*r\n                if _pemexpand(ok) == target:\n                    return _keep_coeff(c, ok)\n\n        # mid was an Add that didn't factor successfully\n        return _keep_coeff(c, g*l*mid*r)",
    "sympy.sympy.core.function.expand": "def expand(e, deep=True, modulus=None, power_base=True, power_exp=True,\n        mul=True, log=True, multinomial=True, basic=True, **hints):\n    r\"\"\"\n    Expand an expression using methods given as hints.\n\n    Explanation\n    ===========\n\n    Hints evaluated unless explicitly set to False are:  ``basic``, ``log``,\n    ``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following\n    hints are supported but not applied unless set to True:  ``complex``,\n    ``func``, and ``trig``.  In addition, the following meta-hints are\n    supported by some or all of the other hints:  ``frac``, ``numer``,\n    ``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all\n    hints.  Additionally, subclasses of Expr may define their own hints or\n    meta-hints.\n\n    The ``basic`` hint is used for any special rewriting of an object that\n    should be done automatically (along with the other hints like ``mul``)\n    when expand is called. This is a catch-all hint to handle any sort of\n    expansion that may not be described by the existing hint names. To use\n    this hint an object should override the ``_eval_expand_basic`` method.\n    Objects may also define their own expand methods, which are not run by\n    default.  See the API section below.\n\n    If ``deep`` is set to ``True`` (the default), things like arguments of\n    functions are recursively expanded.  Use ``deep=False`` to only expand on\n    the top level.\n\n    If the ``force`` hint is used, assumptions about variables will be ignored\n    in making the expansion.\n\n    Hints\n    =====\n\n    These hints are run by default\n\n    mul\n    ---\n\n    Distributes multiplication over addition:\n\n    >>> from sympy import cos, exp, sin\n    >>> from sympy.abc import x, y, z\n    >>> (y*(x + z)).expand(mul=True)\n    x*y + y*z\n\n    multinomial\n    -----------\n\n    Expand (x + y + ...)**n where n is a positive integer.\n\n    >>> ((x + y + z)**2).expand(multinomial=True)\n    x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n\n    power_exp\n    ---------\n\n    Expand addition in exponents into multiplied bases.\n\n    >>> exp(x + y).expand(power_exp=True)\n    exp(x)*exp(y)\n    >>> (2**(x + y)).expand(power_exp=True)\n    2**x*2**y\n\n    power_base\n    ----------\n\n    Split powers of multiplied bases.\n\n    This only happens by default if assumptions allow, or if the\n    ``force`` meta-hint is used:\n\n    >>> ((x*y)**z).expand(power_base=True)\n    (x*y)**z\n    >>> ((x*y)**z).expand(power_base=True, force=True)\n    x**z*y**z\n    >>> ((2*y)**z).expand(power_base=True)\n    2**z*y**z\n\n    Note that in some cases where this expansion always holds, SymPy performs\n    it automatically:\n\n    >>> (x*y)**2\n    x**2*y**2\n\n    log\n    ---\n\n    Pull out power of an argument as a coefficient and split logs products\n    into sums of logs.\n\n    Note that these only work if the arguments of the log function have the\n    proper assumptions--the arguments must be positive and the exponents must\n    be real--or else the ``force`` hint must be True:\n\n    >>> from sympy import log, symbols\n    >>> log(x**2*y).expand(log=True)\n    log(x**2*y)\n    >>> log(x**2*y).expand(log=True, force=True)\n    2*log(x) + log(y)\n    >>> x, y = symbols('x,y', positive=True)\n    >>> log(x**2*y).expand(log=True)\n    2*log(x) + log(y)\n\n    basic\n    -----\n\n    This hint is intended primarily as a way for custom subclasses to enable\n    expansion by default.\n\n    These hints are not run by default:\n\n    complex\n    -------\n\n    Split an expression into real and imaginary parts.\n\n    >>> x, y = symbols('x,y')\n    >>> (x + y).expand(complex=True)\n    re(x) + re(y) + I*im(x) + I*im(y)\n    >>> cos(x).expand(complex=True)\n    -I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x))\n\n    Note that this is just a wrapper around ``as_real_imag()``.  Most objects\n    that wish to redefine ``_eval_expand_complex()`` should consider\n    redefining ``as_real_imag()`` instead.\n\n    func\n    ----\n\n    Expand other functions.\n\n    >>> from sympy import gamma\n    >>> gamma(x + 1).expand(func=True)\n    x*gamma(x)\n\n    trig\n    ----\n\n    Do trigonometric expansions.\n\n    >>> cos(x + y).expand(trig=True)\n    -sin(x)*sin(y) + cos(x)*cos(y)\n    >>> sin(2*x).expand(trig=True)\n    2*sin(x)*cos(x)\n\n    Note that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)``\n    and ``cos(x)`` are not unique, due to the identity `\\sin^2(x) + \\cos^2(x)\n    = 1`.  The current implementation uses the form obtained from Chebyshev\n    polynomials, but this may change.  See `this MathWorld article\n    <https://mathworld.wolfram.com/Multiple-AngleFormulas.html>`_ for more\n    information.\n\n    Notes\n    =====\n\n    - You can shut off unwanted methods::\n\n        >>> (exp(x + y)*(x + y)).expand()\n        x*exp(x)*exp(y) + y*exp(x)*exp(y)\n        >>> (exp(x + y)*(x + y)).expand(power_exp=False)\n        x*exp(x + y) + y*exp(x + y)\n        >>> (exp(x + y)*(x + y)).expand(mul=False)\n        (x + y)*exp(x)*exp(y)\n\n    - Use deep=False to only expand on the top level::\n\n        >>> exp(x + exp(x + y)).expand()\n        exp(x)*exp(exp(x)*exp(y))\n        >>> exp(x + exp(x + y)).expand(deep=False)\n        exp(x)*exp(exp(x + y))\n\n    - Hints are applied in an arbitrary, but consistent order (in the current\n      implementation, they are applied in alphabetical order, except\n      multinomial comes before mul, but this may change).  Because of this,\n      some hints may prevent expansion by other hints if they are applied\n      first. For example, ``mul`` may distribute multiplications and prevent\n      ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is\n      applied before ``multinomial`, the expression might not be fully\n      distributed. The solution is to use the various ``expand_hint`` helper\n      functions or to use ``hint=False`` to this function to finely control\n      which hints are applied. Here are some examples::\n\n        >>> from sympy import expand, expand_mul, expand_power_base\n        >>> x, y, z = symbols('x,y,z', positive=True)\n\n        >>> expand(log(x*(y + z)))\n        log(x) + log(y + z)\n\n      Here, we see that ``log`` was applied before ``mul``.  To get the mul\n      expanded form, either of the following will work::\n\n        >>> expand_mul(log(x*(y + z)))\n        log(x*y + x*z)\n        >>> expand(log(x*(y + z)), log=False)\n        log(x*y + x*z)\n\n      A similar thing can happen with the ``power_base`` hint::\n\n        >>> expand((x*(y + z))**x)\n        (x*y + x*z)**x\n\n      To get the ``power_base`` expanded form, either of the following will\n      work::\n\n        >>> expand((x*(y + z))**x, mul=False)\n        x**x*(y + z)**x\n        >>> expand_power_base((x*(y + z))**x)\n        x**x*(y + z)**x\n\n        >>> expand((x + y)*y/x)\n        y + y**2/x\n\n      The parts of a rational expression can be targeted::\n\n        >>> expand((x + y)*y/x/(x + 1), frac=True)\n        (x*y + y**2)/(x**2 + x)\n        >>> expand((x + y)*y/x/(x + 1), numer=True)\n        (x*y + y**2)/(x*(x + 1))\n        >>> expand((x + y)*y/x/(x + 1), denom=True)\n        y*(x + y)/(x**2 + x)\n\n    - The ``modulus`` meta-hint can be used to reduce the coefficients of an\n      expression post-expansion::\n\n        >>> expand((3*x + 1)**2)\n        9*x**2 + 6*x + 1\n        >>> expand((3*x + 1)**2, modulus=5)\n        4*x**2 + x + 1\n\n    - Either ``expand()`` the function or ``.expand()`` the method can be\n      used.  Both are equivalent::\n\n        >>> expand((x + 1)**2)\n        x**2 + 2*x + 1\n        >>> ((x + 1)**2).expand()\n        x**2 + 2*x + 1\n\n    API\n    ===\n\n    Objects can define their own expand hints by defining\n    ``_eval_expand_hint()``.  The function should take the form::\n\n        def _eval_expand_hint(self, **hints):\n            # Only apply the method to the top-level expression\n            ...\n\n    See also the example below.  Objects should define ``_eval_expand_hint()``\n    methods only if ``hint`` applies to that specific object.  The generic\n    ``_eval_expand_hint()`` method defined in Expr will handle the no-op case.\n\n    Each hint should be responsible for expanding that hint only.\n    Furthermore, the expansion should be applied to the top-level expression\n    only.  ``expand()`` takes care of the recursion that happens when\n    ``deep=True``.\n\n    You should only call ``_eval_expand_hint()`` methods directly if you are\n    100% sure that the object has the method, as otherwise you are liable to\n    get unexpected ``AttributeError``s.  Note, again, that you do not need to\n    recursively apply the hint to args of your object: this is handled\n    automatically by ``expand()``.  ``_eval_expand_hint()`` should\n    generally not be used at all outside of an ``_eval_expand_hint()`` method.\n    If you want to apply a specific expansion from within another method, use\n    the public ``expand()`` function, method, or ``expand_hint()`` functions.\n\n    In order for expand to work, objects must be rebuildable by their args,\n    i.e., ``obj.func(*obj.args) == obj`` must hold.\n\n    Expand methods are passed ``**hints`` so that expand hints may use\n    'metahints'--hints that control how different expand methods are applied.\n    For example, the ``force=True`` hint described above that causes\n    ``expand(log=True)`` to ignore assumptions is such a metahint.  The\n    ``deep`` meta-hint is handled exclusively by ``expand()`` and is not\n    passed to ``_eval_expand_hint()`` methods.\n\n    Note that expansion hints should generally be methods that perform some\n    kind of 'expansion'.  For hints that simply rewrite an expression, use the\n    .rewrite() API.\n\n    Examples\n    ========\n\n    >>> from sympy import Expr, sympify\n    >>> class MyClass(Expr):\n    ...     def __new__(cls, *args):\n    ...         args = sympify(args)\n    ...         return Expr.__new__(cls, *args)\n    ...\n    ...     def _eval_expand_double(self, *, force=False, **hints):\n    ...         '''\n    ...         Doubles the args of MyClass.\n    ...\n    ...         If there more than four args, doubling is not performed,\n    ...         unless force=True is also used (False by default).\n    ...         '''\n    ...         if not force and len(self.args) > 4:\n    ...             return self\n    ...         return self.func(*(self.args + self.args))\n    ...\n    >>> a = MyClass(1, 2, MyClass(3, 4))\n    >>> a\n    MyClass(1, 2, MyClass(3, 4))\n    >>> a.expand(double=True)\n    MyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))\n    >>> a.expand(double=True, deep=False)\n    MyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4))\n\n    >>> b = MyClass(1, 2, 3, 4, 5)\n    >>> b.expand(double=True)\n    MyClass(1, 2, 3, 4, 5)\n    >>> b.expand(double=True, force=True)\n    MyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n    See Also\n    ========\n\n    expand_log, expand_mul, expand_multinomial, expand_complex, expand_trig,\n    expand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand\n\n    \"\"\"\n    # don't modify this; modify the Expr.expand method\n    hints['power_base'] = power_base\n    hints['power_exp'] = power_exp\n    hints['mul'] = mul\n    hints['log'] = log\n    hints['multinomial'] = multinomial\n    hints['basic'] = basic\n    return sympify(e).expand(deep=deep, modulus=modulus, **hints)",
    "sympy.sympy.core.function.expand_mul": "def expand_mul(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False,\n    power_base=False, basic=False, multinomial=False, log=False)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__abs__": "@staticmethod\ndef __abs__():\n    return S.Zero",
    "sympy.sympy.diffgeom.diffgeom.__call__": "def __call__(self, scalar_field):\n    \"\"\"Apply on a scalar field.\n    The action of a vector field on a scalar field is a directional\n    differentiation.\n    If the argument is not a scalar field an error is raised.\n    \"\"\"\n    if covariant_order(scalar_field) or contravariant_order(scalar_field):\n        raise ValueError('Only scalar fields can be supplied as arguments to vector fields.')\n\n    if scalar_field is None:\n        return self\n\n    base_scalars = list(scalar_field.atoms(BaseScalarField))\n\n    # First step: e_x(x+r**2) -> e_x(x) + 2*r*e_x(r)\n    d_var = self._coord_sys._dummy\n    # TODO: you need a real dummy function for the next line\n    d_funcs = [Function('_#_%s' % i)(d_var) for i,\n               b in enumerate(base_scalars)]\n    d_result = scalar_field.subs(list(zip(base_scalars, d_funcs)))\n    d_result = d_result.diff(d_var)\n\n    # Second step: e_x(x) -> 1 and e_x(r) -> cos(atan2(x, y))\n    coords = self._coord_sys.symbols\n    d_funcs_deriv = [f.diff(d_var) for f in d_funcs]\n    d_funcs_deriv_sub = []\n    for b in base_scalars:\n        jac = self._coord_sys.jacobian(b._coord_sys, coords)\n        d_funcs_deriv_sub.append(jac[b._index, self._index])\n    d_result = d_result.subs(list(zip(d_funcs_deriv, d_funcs_deriv_sub)))\n\n    # Remove the dummies\n    result = d_result.subs(list(zip(d_funcs, base_scalars)))\n    result = result.subs(list(zip(coords, self._coord_sys.coord_functions())))\n    return result.doit()",
    "sympy.sympy.integrals.integrals.<lambda>": "lambda f: self.func(f, *self.limits).doit(**hints))\n\n",
    "sympy.sympy.integrals.prde.<lambda>": "Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.immutable._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    if len(args) == 1 and isinstance(args[0], ImmutableDenseMatrix):\n        return args[0]\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.immutable.cols": "@property\ndef cols(self):\n    return self._cols",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.inverse.<lambda>": "D_pinv = D.applyfunc(lambda x: 0 if _iszero(x) else 1 / x)\n\n",
    "sympy.sympy.matrices.matrixbase.<lambda>": "out = self.applyfunc(lambda i: i / norm)\n",
    "sympy.sympy.matrices.matrixbase.<dictcomp>": "fdok = {ij: valmap[v] for ij, v in dok.items()}\n",
    "sympy.sympy.matrices.matrixbase.todok": "def todok(self) -> dict[tuple[int, int], Expr]:\n    \"\"\"Return the matrix as dictionary of keys.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix.eye(3)\n    >>> M.todok()\n    {(0, 0): 1, (1, 1): 1, (2, 2): 1}\n    \"\"\"\n    return self._eval_todok()",
    "sympy.sympy.matrices.matrixbase.from_dok": "@classmethod\ndef from_dok(cls, rows: int, cols: int, dok: dict[tuple[int, int], Expr], /) -> Self:\n    \"\"\"Create a matrix from a dictionary of keys.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> d = {(0, 0): 1, (1, 2): 3, (2, 1): 4}\n    >>> Matrix.from_dok(3, 3, d)\n    Matrix([\n    [1, 0, 0],\n    [0, 0, 3],\n    [0, 4, 0]])\n    \"\"\"\n    dok = {ij: cls._sympify(val) for ij, val in dok.items()}\n    return cls._eval_from_dok(rows, cols, dok)",
    "sympy.sympy.matrices.normalforms.<lambda>": "m = m.applyfunc(lambda e: e.as_expr() if isinstance(e, Poly) else e)\n\n",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.utilities._simplify": "def _simplify(expr):\n    \"\"\" Wrapper to avoid circular imports. \"\"\"\n    from sympy.simplify.simplify import simplify\n    return simplify(expr)",
    "sympy.sympy.physics.control.lti.<lambda>": "D = self.D.applyfunc(lambda element: element + other)\n",
    "sympy.sympy.physics.mechanics.functions.<lambda>": "return expr.applyfunc(lambda x: func(x, sub_dict))\n",
    "sympy.sympy.polys.polytools.cancel": "@public\ndef cancel(f, *gens, _signsimp=True, **args):\n    \"\"\"\n    Cancel common factors in a rational function ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import cancel, sqrt, Symbol, together\n    >>> from sympy.abc import x\n    >>> A = Symbol('A', commutative=False)\n\n    >>> cancel((2*x**2 - 2)/(x**2 - 2*x + 1))\n    (2*x + 2)/(x - 1)\n    >>> cancel((sqrt(3) + sqrt(15)*A)/(sqrt(2) + sqrt(10)*A))\n    sqrt(6)/2\n\n    Note: due to automatic distribution of Rationals, a sum divided by an integer\n    will appear as a sum. To recover a rational form use `together` on the result:\n\n    >>> cancel(x/2 + 1)\n    x/2 + 1\n    >>> together(_)\n    (x + 2)/2\n    \"\"\"\n    from sympy.simplify.simplify import signsimp\n    from sympy.polys.rings import sring\n    options.allowed_flags(args, ['polys'])\n\n    f = sympify(f)\n    if _signsimp:\n        f = signsimp(f)\n    opt = {}\n    if 'polys' in args:\n        opt['polys'] = args['polys']\n\n    if not isinstance(f, Tuple):\n        if f.is_Number or isinstance(f, Relational) or not isinstance(f, Expr):\n            return f\n        f = factor_terms(f, radical=True)\n        p, q = f.as_numer_denom()\n\n    elif len(f) == 2:\n        p, q = f\n        if isinstance(p, Poly) and isinstance(q, Poly):\n            opt['gens'] = p.gens\n            opt['domain'] = p.domain\n            opt['polys'] = opt.get('polys', True)\n        p, q = p.as_expr(), q.as_expr()\n    else:\n        raise ValueError('unexpected argument: %s' % f)\n\n    from sympy.functions.elementary.piecewise import Piecewise\n    try:\n        if f.has(Piecewise):\n            raise PolynomialError()\n        R, (F, G) = sring((p, q), *gens, **args)\n        if not R.ngens:\n            if not isinstance(f, Tuple):\n                return f.expand()\n            else:\n                return S.One, p, q\n    except PolynomialError as msg:\n        if f.is_commutative and not f.has(Piecewise):\n            raise PolynomialError(msg)\n        # Handling of noncommutative and/or piecewise expressions\n        if f.is_Add or f.is_Mul:\n            c, nc = sift(f.args, lambda x:\n                x.is_commutative is True and not x.has(Piecewise),\n                binary=True)\n            nc = [cancel(i) for i in nc]\n            return f.func(cancel(f.func(*c)), *nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                if isinstance(e, BooleanAtom) or not isinstance(e, Expr):\n                    continue\n                try:\n                    reps.append((e, cancel(e)))\n                    pot.skip()  # this was handled successfully\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n\n    c, (P, Q) = 1, F.cancel(G)\n    if opt.get('polys', False) and 'gens' not in opt:\n        opt['gens'] = R.symbols\n\n    if not isinstance(f, Tuple):\n        return c*(P.as_expr()/Q.as_expr())\n    else:\n        P, Q = P.as_expr(), Q.as_expr()\n        if not opt.get('polys', False):\n            return c, P, Q\n        else:\n            return c, Poly(P, *gens, **opt), Poly(Q, *gens, **opt)",
    "sympy.sympy.simplify.hyperexpand.simp": "def simp(expr):\n    \"\"\" Efficiently simplify the rational function ``expr``. \"\"\"\n    numer, denom = expr.as_numer_denom()\n    numer = numer.expand()\n    # denom = denom.expand()  # is this needed?\n    c, numer, denom = poly(numer, z).cancel(poly(denom, z))\n    return c * numer.as_expr() / denom.as_expr()",
    "sympy.sympy.simplify.ratsimp.ratsimp": "def ratsimp(expr):\n    \"\"\"\n    Put an expression over a common denominator, cancel and reduce.\n\n    Examples\n    ========\n\n    >>> from sympy import ratsimp\n    >>> from sympy.abc import x, y\n    >>> ratsimp(1/x + 1/y)\n    (x + y)/(x*y)\n    \"\"\"\n\n    f, g = cancel(expr).as_numer_denom()\n    try:\n        Q, r = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f/g\n\n    return Add(*Q) + cancel(r/g)",
    "sympy.sympy.simplify.trigsimp.trigsimp": "def trigsimp(expr, inverse=False, **opts):\n    \"\"\"Returns a reduced expression by using known trig identities.\n\n    Parameters\n    ==========\n\n    inverse : bool, optional\n        If ``inverse=True``, it will be assumed that a composition of inverse\n        functions, such as sin and asin, can be cancelled in any order.\n        For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n        x belongs to the set where this relation is true. The default is False.\n        Default : True\n\n    method : string, optional\n        Specifies the method to use. Valid choices are:\n\n        - ``'matching'``, default\n        - ``'groebner'``\n        - ``'combined'``\n        - ``'fu'``\n        - ``'old'``\n\n        If ``'matching'``, simplify the expression recursively by targeting\n        common patterns. If ``'groebner'``, apply an experimental groebner\n        basis algorithm. In this case further options are forwarded to\n        ``trigsimp_groebner``, please refer to\n        its docstring. If ``'combined'``, it first runs the groebner basis\n        algorithm with small default parameters, then runs the ``'matching'``\n        algorithm. If ``'fu'``, run the collection of trigonometric\n        transformations described by Fu, et al. (see the\n        :py:func:`~sympy.simplify.fu.fu` docstring). If ``'old'``, the original\n        SymPy trig simplification function is run.\n    opts :\n        Optional keyword arguments passed to the method. See each method's\n        function docstring for details.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using ``method='groebner'`` (or ``method='combined'``) might lead to\n    greater simplification.\n\n    The old trigsimp routine can be accessed as with method ``method='old'``.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    expr_simplified = trigsimpfunc(expr)\n    if inverse:\n        expr_simplified = _trigsimp_inverse(expr_simplified)\n\n    return expr_simplified",
    "sympy.sympy.solvers.ode.systems.<lambda>": "intx_wrtt = lambda x: Integral(x, t) if x else 0\n",
    "sympy.sympy.utilities.decorator.<lambda>": "return expr.applyfunc(lambda f: func(f, *args, **kwargs))\n"
}