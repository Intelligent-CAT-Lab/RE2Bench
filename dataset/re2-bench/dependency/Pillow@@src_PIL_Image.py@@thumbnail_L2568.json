{
    "Pillow.src.PIL.EpsImagePlugin.load": "def load(self, scale=1, transparency=False):\n    # Load EPS via Ghostscript\n    if self.tile:\n        self.im = Ghostscript(self.tile, self.size, self.fp, scale, transparency)\n        self._mode = self.im.mode\n        self._size = self.im.size\n        self.tile = []\n    return Image.Image.load(self)",
    "Pillow.src.PIL.Image.draft": "def draft(self, mode, size):\n    \"\"\"\n    Configures the image file loader so it returns a version of the\n    image that as closely as possible matches the given mode and\n    size. For example, you can use this method to convert a color\n    JPEG to grayscale while loading it.\n\n    If any changes are made, returns a tuple with the chosen ``mode`` and\n    ``box`` with coordinates of the original image within the altered one.\n\n    Note that this method modifies the :py:class:`~PIL.Image.Image` object\n    in place. If the image has already been loaded, this method has no\n    effect.\n\n    Note: This method is not implemented for most images. It is\n    currently implemented only for JPEG and MPO images.\n\n    :param mode: The requested mode.\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    \"\"\"\n    pass",
    "Pillow.src.PIL.Image.resize": "def resize(self, size, resample=None, box=None, reducing_gap=None) -> Image:\n    \"\"\"\n    Returns a resized copy of this image.\n\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param resample: An optional resampling filter.  This can be\n       one of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n       :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n       :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n       If the image has mode \"1\" or \"P\", it is always set to\n       :py:data:`Resampling.NEAREST`. If the image mode specifies a number\n       of bits, such as \"I;16\", then the default filter is\n       :py:data:`Resampling.NEAREST`. Otherwise, the default filter is\n       :py:data:`Resampling.BICUBIC`. See: :ref:`concept-filters`.\n    :param box: An optional 4-tuple of floats providing\n       the source image region to be scaled.\n       The values must be within (0, 0, width, height) rectangle.\n       If omitted or None, the entire source is used.\n    :param reducing_gap: Apply optimization by resizing the image\n       in two steps. First, reducing the image by integer times\n       using :py:meth:`~PIL.Image.Image.reduce`.\n       Second, resizing using regular resampling. The last step\n       changes size no less than by ``reducing_gap`` times.\n       ``reducing_gap`` may be None (no first step is performed)\n       or should be greater than 1.0. The bigger ``reducing_gap``,\n       the closer the result to the fair resampling.\n       The smaller ``reducing_gap``, the faster resizing.\n       With ``reducing_gap`` greater or equal to 3.0, the result is\n       indistinguishable from fair resampling in most cases.\n       The default value is None (no optimization).\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if resample is None:\n        type_special = \";\" in self.mode\n        resample = Resampling.NEAREST if type_special else Resampling.BICUBIC\n    elif resample not in (\n        Resampling.NEAREST,\n        Resampling.BILINEAR,\n        Resampling.BICUBIC,\n        Resampling.LANCZOS,\n        Resampling.BOX,\n        Resampling.HAMMING,\n    ):\n        msg = f\"Unknown resampling filter ({resample}).\"\n\n        filters = [\n            f\"{filter[1]} ({filter[0]})\"\n            for filter in (\n                (Resampling.NEAREST, \"Image.Resampling.NEAREST\"),\n                (Resampling.LANCZOS, \"Image.Resampling.LANCZOS\"),\n                (Resampling.BILINEAR, \"Image.Resampling.BILINEAR\"),\n                (Resampling.BICUBIC, \"Image.Resampling.BICUBIC\"),\n                (Resampling.BOX, \"Image.Resampling.BOX\"),\n                (Resampling.HAMMING, \"Image.Resampling.HAMMING\"),\n            )\n        ]\n        msg += \" Use \" + \", \".join(filters[:-1]) + \" or \" + filters[-1]\n        raise ValueError(msg)\n\n    if reducing_gap is not None and reducing_gap < 1.0:\n        msg = \"reducing_gap must be 1.0 or greater\"\n        raise ValueError(msg)\n\n    size = tuple(size)\n\n    self.load()\n    if box is None:\n        box = (0, 0) + self.size\n    else:\n        box = tuple(box)\n\n    if self.size == size and box == (0, 0) + self.size:\n        return self.copy()\n\n    if self.mode in (\"1\", \"P\"):\n        resample = Resampling.NEAREST\n\n    if self.mode in [\"LA\", \"RGBA\"] and resample != Resampling.NEAREST:\n        im = self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n        im = im.resize(size, resample, box)\n        return im.convert(self.mode)\n\n    self.load()\n\n    if reducing_gap is not None and resample != Resampling.NEAREST:\n        factor_x = int((box[2] - box[0]) / size[0] / reducing_gap) or 1\n        factor_y = int((box[3] - box[1]) / size[1] / reducing_gap) or 1\n        if factor_x > 1 or factor_y > 1:\n            reduce_box = self._get_safe_box(size, resample, box)\n            factor = (factor_x, factor_y)\n            self = (\n                self.reduce(factor, box=reduce_box)\n                if callable(self.reduce)\n                else Image.reduce(self, factor, box=reduce_box)\n            )\n            box = (\n                (box[0] - reduce_box[0]) / factor_x,\n                (box[1] - reduce_box[1]) / factor_y,\n                (box[2] - reduce_box[0]) / factor_x,\n                (box[3] - reduce_box[1]) / factor_y,\n            )\n\n    return self._new(self.im.resize(size, resample, box))",
    "Pillow.src.PIL.Image.preserve_aspect_ratio": "def preserve_aspect_ratio() -> tuple[int, int] | None:\n    def round_aspect(number, key):\n        return max(min(math.floor(number), math.ceil(number), key=key), 1)\n\n    x, y = provided_size\n    if x >= self.width and y >= self.height:\n        return None\n\n    aspect = self.width / self.height\n    if x / y >= aspect:\n        x = round_aspect(y * aspect, key=lambda n: abs(aspect - n / y))\n    else:\n        y = round_aspect(\n            x / aspect, key=lambda n: 0 if n == 0 else abs(aspect - x / n)\n        )\n    return x, y",
    "Pillow.src.PIL.Image.size": "@property\ndef size(self) -> tuple[int, int]:\n    return self._size",
    "Pillow.src.PIL.Image.load": "def load(self):\n    \"\"\"\n    Allocates storage for the image and loads the pixel data.  In\n    normal cases, you don't need to call this method, since the\n    Image class automatically loads an opened image when it is\n    accessed for the first time.\n\n    If the file associated with the image was opened by Pillow, then this\n    method will close it. The exception to this is if the image has\n    multiple frames, in which case the file will be left open for seek\n    operations. See :ref:`file-handling` for more information.\n\n    :returns: An image access object.\n    :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess`\n    \"\"\"\n    if self.im is not None and self.palette and self.palette.dirty:\n        # realize palette\n        mode, arr = self.palette.getdata()\n        self.im.putpalette(mode, arr)\n        self.palette.dirty = 0\n        self.palette.rawmode = None\n        if \"transparency\" in self.info and mode in (\"LA\", \"PA\"):\n            if isinstance(self.info[\"transparency\"], int):\n                self.im.putpalettealpha(self.info[\"transparency\"], 0)\n            else:\n                self.im.putpalettealphas(self.info[\"transparency\"])\n            self.palette.mode = \"RGBA\"\n        else:\n            palette_mode = \"RGBA\" if mode.startswith(\"RGBA\") else \"RGB\"\n            self.palette.mode = palette_mode\n            self.palette.palette = self.im.getpalette(palette_mode, palette_mode)\n\n    if self.im is not None:\n        if cffi and USE_CFFI_ACCESS:\n            if self.pyaccess:\n                return self.pyaccess\n            from . import PyAccess\n\n            self.pyaccess = PyAccess.new(self, self.readonly)\n            if self.pyaccess:\n                return self.pyaccess\n        return self.im.pixel_access(self.readonly)",
    "Pillow.src.PIL.ImageFile.load": "def load(self):\n    \"\"\"Load image data based on tile list\"\"\"\n\n    if self.tile is None:\n        msg = \"cannot load this image\"\n        raise OSError(msg)\n\n    pixel = Image.Image.load(self)\n    if not self.tile:\n        return pixel\n\n    self.map = None\n    use_mmap = self.filename and len(self.tile) == 1\n    # As of pypy 2.1.0, memory mapping was failing here.\n    use_mmap = use_mmap and not hasattr(sys, \"pypy_version_info\")\n\n    readonly = 0\n\n    # look for read/seek overrides\n    try:\n        read = self.load_read\n        # don't use mmap if there are custom read/seek functions\n        use_mmap = False\n    except AttributeError:\n        read = self.fp.read\n\n    try:\n        seek = self.load_seek\n        use_mmap = False\n    except AttributeError:\n        seek = self.fp.seek\n\n    if use_mmap:\n        # try memory mapping\n        decoder_name, extents, offset, args = self.tile[0]\n        if isinstance(args, str):\n            args = (args, 0, 1)\n        if (\n            decoder_name == \"raw\"\n            and len(args) >= 3\n            and args[0] == self.mode\n            and args[0] in Image._MAPMODES\n        ):\n            try:\n                # use mmap, if possible\n                import mmap\n\n                with open(self.filename) as fp:\n                    self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)\n                if offset + self.size[1] * args[1] > self.map.size():\n                    msg = \"buffer is not large enough\"\n                    raise OSError(msg)\n                self.im = Image.core.map_buffer(\n                    self.map, self.size, decoder_name, offset, args\n                )\n                readonly = 1\n                # After trashing self.im,\n                # we might need to reload the palette data.\n                if self.palette:\n                    self.palette.dirty = 1\n            except (AttributeError, OSError, ImportError):\n                self.map = None\n\n    self.load_prepare()\n    err_code = -3  # initialize to unknown error\n    if not self.map:\n        # sort tiles in file order\n        self.tile.sort(key=_tilesort)\n\n        try:\n            # FIXME: This is a hack to handle TIFF's JpegTables tag.\n            prefix = self.tile_prefix\n        except AttributeError:\n            prefix = b\"\"\n\n        # Remove consecutive duplicates that only differ by their offset\n        self.tile = [\n            list(tiles)[-1]\n            for _, tiles in itertools.groupby(\n                self.tile, lambda tile: (tile[0], tile[1], tile[3])\n            )\n        ]\n        for decoder_name, extents, offset, args in self.tile:\n            seek(offset)\n            decoder = Image._getdecoder(\n                self.mode, decoder_name, args, self.decoderconfig\n            )\n            try:\n                decoder.setimage(self.im, extents)\n                if decoder.pulls_fd:\n                    decoder.setfd(self.fp)\n                    err_code = decoder.decode(b\"\")[1]\n                else:\n                    b = prefix\n                    while True:\n                        try:\n                            s = read(self.decodermaxblock)\n                        except (IndexError, struct.error) as e:\n                            # truncated png/gif\n                            if LOAD_TRUNCATED_IMAGES:\n                                break\n                            else:\n                                msg = \"image file is truncated\"\n                                raise OSError(msg) from e\n\n                        if not s:  # truncated jpeg\n                            if LOAD_TRUNCATED_IMAGES:\n                                break\n                            else:\n                                msg = (\n                                    \"image file is truncated \"\n                                    f\"({len(b)} bytes not processed)\"\n                                )\n                                raise OSError(msg)\n\n                        b = b + s\n                        n, err_code = decoder.decode(b)\n                        if n < 0:\n                            break\n                        b = b[n:]\n            finally:\n                # Need to cleanup here to prevent leaks\n                decoder.cleanup()\n\n    self.tile = []\n    self.readonly = readonly\n\n    self.load_end()\n\n    if self._exclusive_fp and self._close_exclusive_fp_after_loading:\n        self.fp.close()\n    self.fp = None\n\n    if not self.map and not LOAD_TRUNCATED_IMAGES and err_code < 0:\n        # still raised if decoder fails to return anything\n        raise _get_oserror(err_code, encoder=False)\n\n    return Image.Image.load(self)",
    "Pillow.src.PIL.Jpeg2KImagePlugin.load": "def load(self):\n    if self.tile and self._reduce:\n        power = 1 << self._reduce\n        adjust = power >> 1\n        self._size = (\n            int((self.size[0] + adjust) / power),\n            int((self.size[1] + adjust) / power),\n        )\n\n        # Update the reduce and layers settings\n        t = self.tile[0]\n        t3 = (t[3][0], self._reduce, self.layers, t[3][3], t[3][4])\n        self.tile = [(t[0], (0, 0) + self.size, t[2], t3)]\n\n    return ImageFile.ImageFile.load(self)",
    "Pillow.src.PIL.JpegImagePlugin.draft": "def draft(self, mode, size):\n    if len(self.tile) != 1:\n        return\n\n    # Protect from second call\n    if self.decoderconfig:\n        return\n\n    d, e, o, a = self.tile[0]\n    scale = 1\n    original_size = self.size\n\n    if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:\n        self._mode = mode\n        a = mode, \"\"\n\n    if size:\n        scale = min(self.size[0] // size[0], self.size[1] // size[1])\n        for s in [8, 4, 2, 1]:\n            if scale >= s:\n                break\n        e = (\n            e[0],\n            e[1],\n            (e[2] - e[0] + s - 1) // s + e[0],\n            (e[3] - e[1] + s - 1) // s + e[1],\n        )\n        self._size = ((self.size[0] + s - 1) // s, (self.size[1] + s - 1) // s)\n        scale = s\n\n    self.tile = [(d, e, o, a)]\n    self.decoderconfig = (scale, 0)\n\n    box = (0, 0, original_size[0] / scale, original_size[1] / scale)\n    return self.mode, box",
    "Pillow.src.PIL.TiffImagePlugin.load": "def load(self):\n    if self.tile and self.use_load_libtiff:\n        return self._load_libtiff()\n    return super().load()"
}