{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.metrics.pairwise._get_slice": "def _get_slice(array, index):\n    # TODO: below 2 lines can be removed once min scipy >= 1.14. Support for\n    # 1D shapes in scipy sparse arrays (COO, DOK and CSR formats) only\n    # added in 1.14. We must return 2D array until min scipy 1.14.\n    if issparse(array):\n        return array[[index], :]\n    # When `metric` is a callable, 1D input arrays allowed, in which case\n    # scalar should be returned.\n    if array.ndim == 1:\n        return array[index]\n    else:\n        return array[index, ...]",
    "scikit-learn.sklearn.metrics.pairwise._find_floating_dtype_allow_sparse": "def _find_floating_dtype_allow_sparse(X, Y, xp=None):\n    \"\"\"Find matching floating type, allowing for sparse input.\"\"\"\n    if any([issparse(X), issparse(Y)]) or _is_numpy_namespace(xp):\n        X, Y, dtype_float = _return_float_dtype(X, Y)\n    else:\n        dtype_float = _find_matching_floating_dtype(X, Y, xp=xp)\n    return X, Y, dtype_float",
    "scikit-learn.sklearn.metrics.pairwise.check_pairwise_arrays": "def check_pairwise_arrays(\n    X,\n    Y,\n    *,\n    precomputed=False,\n    dtype=\"infer_float\",\n    accept_sparse=\"csr\",\n    ensure_all_finite=True,\n    ensure_2d=True,\n    copy=False,\n):\n    \"\"\"Set X and Y appropriately and checks inputs.\n\n    If Y is None, it is set as a pointer to X (i.e. not a copy).\n    If Y is given, this does not happen.\n    All distance metrics should use this function first to assert that the\n    given parameters are correct and safe to use.\n\n    Specifically, this function first ensures that both X and Y are arrays,\n    then checks that they are at least two dimensional while ensuring that\n    their elements are floats (or dtype if provided). Finally, the function\n    checks that the size of the second dimension of the two arrays is equal, or\n    the equivalent check for a precomputed distance matrix.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)\n\n    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)\n\n    precomputed : bool, default=False\n        True if X is to be treated as precomputed distances to the samples in\n        Y.\n\n    dtype : str, type, list of type or None default=\"infer_float\"\n        Data type required for X and Y. If \"infer_float\", the dtype will be an\n        appropriate float type selected by _return_float_dtype. If None, the\n        dtype of the input is preserved.\n\n        .. versionadded:: 0.18\n\n    accept_sparse : str, bool or list/tuple of str, default='csr'\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n\n    ensure_all_finite : bool or 'allow-nan', default=True\n        Whether to raise an error on np.inf, np.nan, pd.NA in array. The\n        possibilities are:\n\n        - True: Force all values of array to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in array.\n        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values\n          cannot be infinite.\n\n        .. versionadded:: 1.6\n           `force_all_finite` was renamed to `ensure_all_finite`.\n\n    ensure_2d : bool, default=True\n        Whether to raise an error when the input arrays are not 2-dimensional. Setting\n        this to `False` is necessary when using a custom metric with certain\n        non-numerical inputs (e.g. a list of strings).\n\n        .. versionadded:: 1.5\n\n    copy : bool, default=False\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n        .. versionadded:: 0.22\n\n    Returns\n    -------\n    safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features)\n        An array equal to X, guaranteed to be a numpy array.\n\n    safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)\n        An array equal to Y if Y was not None, guaranteed to be a numpy array.\n        If Y was None, safe_Y will be a pointer to X.\n    \"\"\"\n    xp, _ = get_namespace(X, Y)\n    X, Y, dtype_float = _find_floating_dtype_allow_sparse(X, Y, xp=xp)\n\n    estimator = \"check_pairwise_arrays\"\n    if dtype == \"infer_float\":\n        dtype = dtype_float\n\n    if Y is X or Y is None:\n        X = Y = check_array(\n            X,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            estimator=estimator,\n            ensure_2d=ensure_2d,\n        )\n    else:\n        X = check_array(\n            X,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            estimator=estimator,\n            ensure_2d=ensure_2d,\n        )\n        Y = check_array(\n            Y,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            estimator=estimator,\n            ensure_2d=ensure_2d,\n        )\n\n    if precomputed:\n        if X.shape[1] != Y.shape[0]:\n            raise ValueError(\n                \"Precomputed metric requires shape \"\n                \"(n_queries, n_indexed). Got (%d, %d) \"\n                \"for %d indexed.\" % (X.shape[0], X.shape[1], Y.shape[0])\n            )\n    elif ensure_2d and X.shape[1] != Y.shape[1]:\n        # Only check the number of features if 2d arrays are enforced. Otherwise,\n        # validation is left to the user for custom metrics.\n        raise ValueError(\n            \"Incompatible dimension for X and Y matrices: \"\n            \"X.shape[1] == %d while Y.shape[1] == %d\" % (X.shape[1], Y.shape[1])\n        )\n\n    return X, Y",
    "scikit-learn.sklearn.utils._array_api.get_namespace_and_device": "def get_namespace_and_device(\n    *array_list, remove_none=True, remove_types=(str,), xp=None\n):\n    \"\"\"Combination into one single function of `get_namespace` and `device`.\n\n    Parameters\n    ----------\n    *array_list : array objects\n        Array objects.\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to NumPy.\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the Array API spec.\n        Always False when array_api_dispatch=False.\n    device : device\n        `device` object (see the \"Device Support\" section of the array API spec).\n    \"\"\"\n    skip_remove_kwargs = dict(remove_none=False, remove_types=[])\n\n    array_list = _remove_non_arrays(\n        *array_list,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n    arrays_device = device(*array_list, **skip_remove_kwargs)\n\n    if xp is None:\n        xp, is_array_api = get_namespace(*array_list, **skip_remove_kwargs)\n    else:\n        xp, is_array_api = xp, True\n\n    if is_array_api:\n        return xp, is_array_api, arrays_device\n    else:\n        return xp, False, arrays_device"
}