{
    "scikit-learn.sklearn.impute._base._fit_indicator": "def _fit_indicator(self, X):\n    \"\"\"Fit a MissingIndicator.\"\"\"\n    if self.add_indicator:\n        self.indicator_ = MissingIndicator(\n            missing_values=self.missing_values, error_on_new=False\n        )\n        self.indicator_._fit(X, precomputed=True)\n    else:\n        self.indicator_ = None",
    "scikit-learn.sklearn.impute._base._most_frequent": "def _most_frequent(array, extra_value, n_repeat):\n    \"\"\"Compute the most frequent value in a 1d array extended with\n    [extra_value] * n_repeat, where extra_value is assumed to be not part\n    of the array.\"\"\"\n    # Compute the most frequent value in array only\n    if array.size > 0:\n        if array.dtype == object:\n            # scipy.stats.mode is slow with object dtype array.\n            # Python Counter is more efficient\n            counter = Counter(array)\n            most_frequent_count = counter.most_common(1)[0][1]\n            # tie breaking similarly to scipy.stats.mode\n            most_frequent_value = _safe_min(\n                [\n                    value\n                    for value, count in counter.items()\n                    if count == most_frequent_count\n                ]\n            )\n        else:\n            mode = _mode(array)\n            most_frequent_value = mode[0][0]\n            most_frequent_count = mode[1][0]\n    else:\n        most_frequent_value = 0\n        most_frequent_count = 0\n\n    # Compare to array + [extra_value] * n_repeat\n    if most_frequent_count == 0 and n_repeat == 0:\n        return np.nan\n    elif most_frequent_count < n_repeat:\n        return extra_value\n    elif most_frequent_count > n_repeat:\n        return most_frequent_value\n    elif most_frequent_count == n_repeat:\n        # tie breaking similarly to scipy.stats.mode\n        return _safe_min([most_frequent_value, extra_value])",
    "scikit-learn.sklearn.utils._mask._get_mask": "def _get_mask(X, value_to_mask):\n    \"\"\"Compute the boolean mask X == value_to_mask.\n\n    Parameters\n    ----------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Input data, where ``n_samples`` is the number of samples and\n        ``n_features`` is the number of features.\n\n    value_to_mask : {int, float}\n        The value which is to be masked in X.\n\n    Returns\n    -------\n    X_mask : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Missing mask.\n    \"\"\"\n    if not sp.issparse(X):\n        # For all cases apart of a sparse input where we need to reconstruct\n        # a sparse output\n        return _get_dense_mask(X, value_to_mask)\n\n    Xt = _get_dense_mask(X.data, value_to_mask)\n\n    sparse_constructor = sp.csr_matrix if X.format == \"csr\" else sp.csc_matrix\n    Xt_sparse = sparse_constructor(\n        (Xt, X.indices.copy(), X.indptr.copy()), shape=X.shape, dtype=bool\n    )\n\n    return Xt_sparse",
    "scikit-learn.sklearn.utils.sparsefuncs._get_median": "def _get_median(data, n_zeros):\n    \"\"\"Compute the median of data with n_zeros additional zeros.\n\n    This function is used to support sparse matrices; it modifies data\n    in-place.\n    \"\"\"\n    n_elems = len(data) + n_zeros\n    if not n_elems:\n        return np.nan\n    n_negative = np.count_nonzero(data < 0)\n    middle, is_odd = divmod(n_elems, 2)\n    data.sort()\n\n    if is_odd:\n        return _get_elem_at_rank(middle, data, n_negative, n_zeros)\n\n    return (\n        _get_elem_at_rank(middle - 1, data, n_negative, n_zeros)\n        + _get_elem_at_rank(middle, data, n_negative, n_zeros)\n    ) / 2.0"
}