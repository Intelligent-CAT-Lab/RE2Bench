{
    "sympy.sympy.polys.agca.extensions.__eq__": "def __eq__(self, other):\n    if not isinstance(other, FiniteExtension):\n        return False\n    return self.modulus == other.modulus",
    "sympy.sympy.polys.domains.algebraicfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, AlgebraicField):\n        return self.dtype == other.dtype and self.ext == other.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.complexfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, ComplexField) and self.precision == other.precision",
    "sympy.sympy.polys.domains.domain.unify": "def unify(K0, K1, symbols=None):\n    \"\"\"\n    Construct a minimal domain that contains elements of ``K0`` and ``K1``.\n\n    Known domains (from smallest to largest):\n\n    - ``GF(p)``\n    - ``ZZ``\n    - ``QQ``\n    - ``RR(prec, tol)``\n    - ``CC(prec, tol)``\n    - ``ALG(a, b, c)``\n    - ``K[x, y, z]``\n    - ``K(x, y, z)``\n    - ``EX``\n\n    \"\"\"\n    if symbols is not None:\n        return K0.unify_with_symbols(K1, symbols)\n\n    if K0 == K1:\n        return K0\n\n    if not (K0.has_CharacteristicZero and K1.has_CharacteristicZero):\n        # Reject unification of domains with different characteristics.\n        if K0.characteristic() != K1.characteristic():\n            raise UnificationFailed(\"Cannot unify %s with %s\" % (K0, K1))\n\n        # We do not get here if K0 == K1. The two domains have the same\n        # characteristic but are unequal so at least one is composite and\n        # we are unifying something like GF(3).unify(GF(3)[x]).\n        return K0.unify_composite(K1)\n\n    # From here we know both domains have characteristic zero and it can be\n    # acceptable to fall back on EX.\n\n    if K0.is_EXRAW:\n        return K0\n    if K1.is_EXRAW:\n        return K1\n\n    if K0.is_EX:\n        return K0\n    if K1.is_EX:\n        return K1\n\n    if K0.is_FiniteExtension or K1.is_FiniteExtension:\n        if K1.is_FiniteExtension:\n            K0, K1 = K1, K0\n        if K1.is_FiniteExtension:\n            # Unifying two extensions.\n            # Try to ensure that K0.unify(K1) == K1.unify(K0)\n            if list(ordered([K0.modulus, K1.modulus]))[1] == K0.modulus:\n                K0, K1 = K1, K0\n            return K1.set_domain(K0)\n        else:\n            # Drop the generator from other and unify with the base domain\n            K1 = K1.drop(K0.symbol)\n            K1 = K0.domain.unify(K1)\n            return K0.set_domain(K1)\n\n    if K0.is_Composite or K1.is_Composite:\n        return K0.unify_composite(K1)\n\n    if K1.is_ComplexField:\n        K0, K1 = K1, K0\n    if K0.is_ComplexField:\n        if K1.is_ComplexField or K1.is_RealField:\n            if K0.precision >= K1.precision:\n                return K0\n            else:\n                from sympy.polys.domains.complexfield import ComplexField\n                return ComplexField(prec=K1.precision)\n        else:\n            return K0\n\n    if K1.is_RealField:\n        K0, K1 = K1, K0\n    if K0.is_RealField:\n        if K1.is_RealField:\n            if K0.precision >= K1.precision:\n                return K0\n            else:\n                return K1\n        elif K1.is_GaussianRing or K1.is_GaussianField:\n            from sympy.polys.domains.complexfield import ComplexField\n            return ComplexField(prec=K0.precision)\n        else:\n            return K0\n\n    if K1.is_AlgebraicField:\n        K0, K1 = K1, K0\n    if K0.is_AlgebraicField:\n        if K1.is_GaussianRing:\n            K1 = K1.get_field()\n        if K1.is_GaussianField:\n            K1 = K1.as_AlgebraicField()\n        if K1.is_AlgebraicField:\n            return K0.__class__(K0.dom.unify(K1.dom), *_unify_gens(K0.orig_ext, K1.orig_ext))\n        else:\n            return K0\n\n    if K0.is_GaussianField:\n        return K0\n    if K1.is_GaussianField:\n        return K1\n\n    if K0.is_GaussianRing:\n        if K1.is_RationalField:\n            K0 = K0.get_field()\n        return K0\n    if K1.is_GaussianRing:\n        if K0.is_RationalField:\n            K1 = K1.get_field()\n        return K1\n\n    if K0.is_RationalField:\n        return K0\n    if K1.is_RationalField:\n        return K1\n\n    if K0.is_IntegerRing:\n        return K0\n    if K1.is_IntegerRing:\n        return K1\n\n    from sympy.polys.domains import EX\n    return EX",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(self, other):\n    if isinstance(other, ExpressionDomain):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.finitefield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FiniteField) and \\\n        self.mod == other.mod and self.dom == other.dom",
    "sympy.sympy.polys.domains.fractionfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if not isinstance(other, FractionField):\n        return NotImplemented\n    return self.field == other.field",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, GaussianRationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.integerring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, IntegerRing):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.old_fractionfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FractionField) and \\\n        self.dtype == other.dtype and self.dom == other.dom and self.gens == other.gens",
    "sympy.sympy.polys.domains.old_polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, PolynomialRingBase) and \\\n        self.dtype == other.dtype and self.dom == other.dom and \\\n        self.gens == other.gens and self.order == other.order",
    "sympy.sympy.polys.domains.polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns `True` if two domains are equivalent. \"\"\"\n    if not isinstance(other, PolynomialRing):\n        return NotImplemented\n    return self.ring == other.ring",
    "sympy.sympy.polys.domains.rationalfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, RationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.realfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, RealField) and self.precision == other.precision",
    "sympy.sympy.polys.polyclasses.convert": "def convert(f, dom: Domain[Es]) -> DMP[Es]:\n    \"\"\"Convert ``f`` to a ``DMP`` over the new domain. \"\"\"\n    if f.dom == dom:\n        return f # type: ignore\n    elif f.lev or flint is None:\n        return f._convert(dom)\n    elif isinstance(f, DUP_Flint):\n        if _supported_flint_domain(dom):\n            return f._convert(dom)\n        else:\n            return f.to_DMP_Python()._convert(dom)\n    elif isinstance(f, DMP_Python):\n        if _supported_flint_domain(dom):\n            return f._convert(dom).to_DUP_Flint()\n        else:\n            return f._convert(dom)\n    else:\n        raise RuntimeError(\"unreachable code\")",
    "sympy.sympy.polys.polyclasses.__repr__": "def __repr__(f) -> str:\n    return \"%s(%s, %s)\" % (f.__class__.__name__, f.to_list(), f.dom)"
}