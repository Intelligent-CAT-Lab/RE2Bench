{
    "matplotlib.lib.matplotlib.__init__._get": "def _get(self, key):\n    \"\"\"\n    Directly read data bypassing deprecation, backend and validation\n    logic.\n\n    Notes\n    -----\n    As end user or downstream library you almost always should use\n    ``val = rcParams[key]`` and not ``_get()``.\n\n    There are only very few special cases that need direct data access.\n    These cases previously used ``dict.__getitem__(rcParams, key, val)``,\n    which is now deprecated and replaced by ``rcParams._get(key)``.\n\n    Even though private, we guarantee API stability for ``rcParams._get``,\n    i.e. it is subject to Matplotlib's API and deprecation policy.\n\n    :meta public:\n    \"\"\"\n    return dict.__getitem__(self, key)",
    "matplotlib.lib.matplotlib.__init__.__setitem__": "def __setitem__(self, key, val):\n    if (key == \"backend\"\n            and val is rcsetup._auto_backend_sentinel\n            and \"backend\" in self):\n        return\n    valid_key = _api.check_getitem(\n        self.validate, rcParam=key, _error_cls=KeyError\n    )\n    try:\n        cval = valid_key(val)\n    except ValueError as ve:\n        raise ValueError(f\"Key {key}: {ve}\") from None\n    self._set(key, cval)",
    "matplotlib.lib.matplotlib._api.__init__.__get__": "def __get__(self, instance, owner):\n    return self._fget(owner)",
    "matplotlib.lib.matplotlib.backends.registry.load_backend_module": "def load_backend_module(self, backend):\n    \"\"\"\n    Load and return the module containing the specified backend.\n\n    Parameters\n    ----------\n    backend : str\n        Name of backend to load.\n\n    Returns\n    -------\n    Module\n        Module containing backend.\n    \"\"\"\n    module_name = self._backend_module_name(backend)\n    return importlib.import_module(module_name)",
    "matplotlib.lib.matplotlib.pyplot.install_repl_displayhook": "def install_repl_displayhook() -> None:\n    \"\"\"\n    Connect to the display hook of the current shell.\n\n    The display hook gets called when the read-evaluate-print-loop (REPL) of\n    the shell has finished the execution of a command. We use this callback\n    to be able to automatically update a figure in interactive mode.\n\n    This works both with IPython and with vanilla python shells.\n    \"\"\"\n    global _REPL_DISPLAYHOOK\n\n    if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n        return\n\n    # See if we have IPython hooks around, if so use them.\n    # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as\n    # entries can also have been explicitly set to None.\n    mod_ipython = sys.modules.get(\"IPython\")\n    if not mod_ipython:\n        _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n        return\n    ip = mod_ipython.get_ipython()\n    if not ip:\n        _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n        return\n\n    ip.events.register(\"post_execute\", _draw_all_if_interactive)\n    _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON\n\n    if mod_ipython.version_info[:2] < (8, 24):\n        # Use of backend2gui is not needed for IPython >= 8.24 as that functionality\n        # has been moved to Matplotlib.\n        # This code can be removed when Python 3.12, the latest version supported by\n        # IPython < 8.24, reaches end-of-life in late 2028.\n        from IPython.core.pylabtools import backend2gui\n        ipython_gui_name = backend2gui.get(get_backend())\n    else:\n        _, ipython_gui_name = backend_registry.resolve_backend(get_backend())\n    # trigger IPython's eventloop integration, if available\n    if ipython_gui_name:\n        ip.enable_gui(ipython_gui_name)",
    "matplotlib.lib.matplotlib.pyplot.backend_mod": "class backend_mod(matplotlib.backend_bases._Backend):\n    locals().update(vars(module))\n\n# However, the newer approach for defining new_figure_manager and\n# show is to derive them from canvas methods.  In that case, also\n# update backend_mod accordingly; also, per-backend customization of\n# draw_if_interactive is disabled.\n"
}