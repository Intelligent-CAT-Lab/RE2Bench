{
    "scikit-learn.sklearn.compose._column_transformer.named_transformers_": "@property\ndef named_transformers_(self):\n    \"\"\"Access the fitted transformer by name.\n\n    Read-only attribute to access any transformer by given name.\n    Keys are transformer names and values are the fitted transformer\n    objects.\n    \"\"\"\n    # Use Bunch object to improve autocomplete\n    return Bunch(**{name: trans for name, trans, _ in self.transformers_})",
    "scikit-learn.sklearn.utils._bunch.__getitem__": "def __getitem__(self, key):\n    if key in self.__dict__.get(\"_deprecated_key_to_warnings\", {}):\n        warnings.warn(\n            self._deprecated_key_to_warnings[key],\n            FutureWarning,\n        )\n    return super().__getitem__(key)",
    "scikit-learn.sklearn.utils._missing.is_scalar_nan": "def is_scalar_nan(x):\n    \"\"\"Test if x is NaN.\n\n    This function is meant to overcome the issue that np.isnan does not allow\n    non-numerical types as input, and that np.nan is not float('nan').\n\n    Parameters\n    ----------\n    x : any type\n        Any scalar value.\n\n    Returns\n    -------\n    bool\n        Returns true if x is NaN, and false otherwise.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.utils._missing import is_scalar_nan\n    >>> is_scalar_nan(np.nan)\n    True\n    >>> is_scalar_nan(float(\"nan\"))\n    True\n    >>> is_scalar_nan(None)\n    False\n    >>> is_scalar_nan(\"\")\n    False\n    >>> is_scalar_nan([np.nan])\n    False\n    \"\"\"\n    return (\n        not isinstance(x, numbers.Integral)\n        and isinstance(x, numbers.Real)\n        and math.isnan(x)\n    )"
}