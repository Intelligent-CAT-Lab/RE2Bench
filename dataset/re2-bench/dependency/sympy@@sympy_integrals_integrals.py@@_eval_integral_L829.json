{
    "sympy.sympy.core.add.getO": "def getO(self):\n    args = [a for a in self.args if a.is_Order]\n    if args:\n        return self._new_rawargs(*args)",
    "sympy.sympy.core.basic.match": "def match(self, pattern, old=False):\n    \"\"\"\n    Pattern matching.\n\n    Wild symbols match all.\n\n    Return ``None`` when expression (self) does not match with pattern.\n    Otherwise return a dictionary such that::\n\n      pattern.xreplace(self.match(pattern)) == self\n\n    Examples\n    ========\n\n    >>> from sympy import Wild, Sum\n    >>> from sympy.abc import x, y\n    >>> p = Wild(\"p\")\n    >>> q = Wild(\"q\")\n    >>> r = Wild(\"r\")\n    >>> e = (x+y)**(x+y)\n    >>> e.match(p**p)\n    {p_: x + y}\n    >>> e.match(p**q)\n    {p_: x + y, q_: x + y}\n    >>> e = (2*x)**2\n    >>> e.match(p*q**r)\n    {p_: 4, q_: x, r_: 2}\n    >>> (p*q**r).xreplace(e.match(p*q**r))\n    4*x**2\n\n    Since match is purely structural expressions that are equivalent up to\n    bound symbols will not match:\n\n    >>> print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))\n    None\n\n    An expression with bound symbols can be matched if the pattern uses\n    a distinct ``Wild`` for each bound symbol:\n\n    >>> Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))\n    {p_: 2, q_: x}\n\n    The ``old`` flag will give the old-style pattern matching where\n    expressions and patterns are essentially solved to give the match. Both\n    of the following give None unless ``old=True``:\n\n    >>> (x - 2).match(p - x, old=True)\n    {p_: 2*x - 2}\n    >>> (2/x).match(p*x, old=True)\n    {p_: 2/x**2}\n\n    See Also\n    ========\n\n    matches: pattern.matches(expr) is the same as expr.match(pattern)\n    xreplace: exact structural replacement\n    replace: structural replacement with pattern matching\n    Wild: symbolic placeholders for expressions in pattern matching\n    \"\"\"\n    pattern = sympify(pattern)\n    return pattern.matches(self, old=old)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_poly": "def as_poly(self, *gens, **args):\n    \"\"\"Converts ``self`` to a polynomial or returns ``None``.\n\n    Explanation\n    ===========\n\n    >>> from sympy import sin\n    >>> from sympy.abc import x, y\n\n    >>> print((x**2 + x*y).as_poly())\n    Poly(x**2 + x*y, x, y, domain='ZZ')\n\n    >>> print((x**2 + x*y).as_poly(x, y))\n    Poly(x**2 + x*y, x, y, domain='ZZ')\n\n    >>> print((x**2 + sin(y)).as_poly(x, y))\n    None\n\n    \"\"\"\n    from sympy.polys.polyerrors import (\n        PolynomialError,\n        GeneratorsNeeded,\n        CoercionFailed,\n    )\n    from sympy.polys.polytools import Poly\n\n    try:\n        poly = Poly(self, *gens, **args)\n\n        if not poly.is_Poly:\n            return None\n        else:\n            return poly\n    except (PolynomialError, GeneratorsNeeded, CoercionFailed):\n        # PolynomialError is caught for e.g. exp(x).as_poly(x)\n        # GeneratorsNeeded is caught for e.g. S(2).as_poly()\n        # CoercionFailed is caught for e.g. pi.as_poly(x, domain='QQ')\n        return None",
    "sympy.sympy.core.expr.getO": "def getO(self) -> Expr | None:\n    \"\"\"Returns the additive O(..) symbol if there is one, else None.\"\"\"\n    return None",
    "sympy.sympy.core.expr.as_independent": "def as_independent(\n    self,\n    *deps: Basic | type[Basic],\n    as_Add: bool | None = None,\n    strict: bool = True,\n) -> tuple[Expr, Expr]:\n    \"\"\"\n    A mostly naive separation of a Mul or Add into arguments that are not\n    are dependent on deps. To obtain as complete a separation of variables\n    as possible, use a separation method first, e.g.:\n\n    * ``separatevars()`` to change Mul, Add and Pow (including exp) into Mul\n    * ``.expand(mul=True)`` to change Add or Mul into Add\n    * ``.expand(log=True)`` to change log expr into an Add\n\n    The only non-naive thing that is done here is to respect noncommutative\n    ordering of variables and to always return ``(0, 0)`` for ``self`` of\n    zero regardless of hints.\n\n    For nonzero ``self``, the returned tuple ``(i, d)`` has the following\n    interpretation:\n\n    * ``i`` has no variable that appears in deps\n    * ``d`` will either have terms that contain variables that are in deps,\n      or be equal to ``0`` (when ``self`` is an ``Add``) or ``1`` (when\n      ``self`` is a ``Mul``)\n    * if ``self`` is an Add then ``self = i + d``\n    * if ``self`` is a Mul then ``self = i*d``\n    * otherwise ``(self, S.One)`` or ``(S.One, self)`` is returned.\n\n    To force the expression to be treated as an Add, use the argument\n    ``as_Add=True``.\n\n    The ``strict`` argument is deprecated and has no effect.\n\n    Examples\n    ========\n\n    -- ``self`` is an Add\n\n    >>> from sympy import sin, cos, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> (x + x*y).as_independent(x)\n    (0, x*y + x)\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x)\n    (y + z, 2*x*sin(x) + x)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n    (z, 2*x*sin(x) + x + y)\n\n    -- ``self`` is a Mul\n\n    >>> (x*sin(x)*cos(y)).as_independent(x)\n    (cos(y), x*sin(x))\n\n    Non-commutative terms cannot always be separated out when ``self`` is a\n    Mul\n\n    >>> from sympy import symbols\n    >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n    >>> (n1 + n1*n2).as_independent(n2)\n    (n1, n1*n2)\n    >>> (n2*n1 + n1*n2).as_independent(n2)\n    (0, n1*n2 + n2*n1)\n    >>> (n1*n2*n3).as_independent(n1)\n    (1, n1*n2*n3)\n    >>> (n1*n2*n3).as_independent(n2)\n    (n1, n2*n3)\n    >>> ((x-n1)*(x-y)).as_independent(x)\n    (1, (x - y)*(x - n1))\n\n    -- ``self`` is anything else:\n\n    >>> (sin(x)).as_independent(x)\n    (1, sin(x))\n    >>> (sin(x)).as_independent(y)\n    (sin(x), 1)\n    >>> exp(x+y).as_independent(x)\n    (1, exp(x + y))\n\n    -- force ``self`` to be treated as an Add:\n\n    >>> (3*x).as_independent(x, as_Add=True)\n    (0, 3*x)\n\n    -- force ``self`` to be treated as a Mul:\n\n    >>> (3+x).as_independent(x, as_Add=False)\n    (1, x + 3)\n    >>> (-3+x).as_independent(x, as_Add=False)\n    (1, x - 3)\n\n    Note how the below differs from the above in making the\n    constant on the dep term positive.\n\n    >>> (y*(-3+x)).as_independent(x)\n    (y, x - 3)\n\n    -- use ``.as_independent()`` for true independence testing instead of\n       ``.has()``. The former considers only symbols in the free symbols\n       while the latter considers all symbols\n\n    >>> from sympy import Integral\n    >>> I = Integral(x, (x, 1, 2))\n    >>> I.has(x)\n    True\n    >>> x in I.free_symbols\n    False\n    >>> I.as_independent(x) == (I, 1)\n    True\n    >>> (I + x).as_independent(x) == (I, x)\n    True\n\n    Note: when trying to get independent terms, a separation method might\n    need to be used first. In this case, it is important to keep track of\n    what you send to this routine so you know how to interpret the returned\n    values\n\n    >>> from sympy import separatevars, log\n    >>> separatevars(exp(x+y)).as_independent(x)\n    (exp(y), exp(x))\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> separatevars(x + x*y).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n    (x, x*y)\n    >>> a, b=symbols('a b', positive=True)\n    >>> (log(a*b).expand(log=True)).as_independent(b)\n    (log(a), log(b))\n\n    See Also\n    ========\n\n    separatevars\n    expand_log\n    sympy.core.add.Add.as_two_terms\n    sympy.core.mul.Mul.as_two_terms\n    as_coeff_mul\n    \"\"\"\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n\n    if self is S.Zero:\n        return (self, self)\n\n    if as_Add is None:\n        as_Add = self.is_Add\n\n    syms, other = _sift_true_false(deps, lambda d: isinstance(d, Symbol))\n    syms_set = set(syms)\n\n    if other:\n        def has(e):\n            return e.has_xfree(syms_set) or e.has(*other)\n    else:\n        def has(e):\n            return e.has_xfree(syms_set)\n\n    if as_Add:\n        if not self.is_Add:\n            if has(self):\n                return (S.Zero, self)\n            else:\n                return (self, S.Zero)\n\n        depend, indep = _sift_true_false(self.args, has)\n        return (self.func(*indep), _unevaluated_Add(*depend))\n\n    else:\n        if not self.is_Mul:\n            if has(self):\n                return (S.One, self)\n            else:\n                return (self, S.One)\n\n        args, nc = self.args_cnc()\n        depend, indep = _sift_true_false(args, has)\n\n        # handle noncommutative by stopping at first dependent term\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n\n        return self.func(*indep), _unevaluated_Mul(*depend)",
    "sympy.sympy.core.expr.is_rational_function": "def is_rational_function(self, *syms):\n    \"\"\"\n    Test whether function is a ratio of two polynomials in the given\n    symbols, syms. When syms is not given, all free symbols will be used.\n    The rational function does not have to be in expanded or in any kind of\n    canonical form.\n\n    This function returns False for expressions that are \"rational\n    functions\" with symbolic exponents.  Thus, you should be able to call\n    .as_numer_denom() and apply polynomial algorithms to the result for\n    expressions for which this returns True.\n\n    This is not part of the assumptions system.  You cannot do\n    Symbol('z', rational_function=True).\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, sin\n    >>> from sympy.abc import x, y\n\n    >>> (x/y).is_rational_function()\n    True\n\n    >>> (x**2).is_rational_function()\n    True\n\n    >>> (x/sin(y)).is_rational_function(y)\n    False\n\n    >>> n = Symbol('n', integer=True)\n    >>> (x**n + 1).is_rational_function(x)\n    False\n\n    This function does not attempt any nontrivial simplifications that may\n    result in an expression that does not appear to be a rational function\n    to become one.\n\n    >>> from sympy import sqrt, factor\n    >>> y = Symbol('y', positive=True)\n    >>> a = sqrt(y**2 + 2*y + 1)/y\n    >>> a.is_rational_function(y)\n    False\n    >>> factor(a)\n    (y + 1)/y\n    >>> factor(a).is_rational_function(y)\n    True\n\n    See also is_algebraic_expr().\n\n    \"\"\"\n    if syms:\n        syms = set(map(sympify, syms))\n    else:\n        syms = self.free_symbols\n        if not syms:\n            return self not in _illegal\n\n    return self._eval_is_rational_function(syms)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs, rhs, **options) -> Unequality | BooleanFalse | BooleanTrue: # type: ignore\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        val = is_neq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n\n    return Relational.__new__(cls, lhs, rhs, **options)",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str,\n            exclude: Iterable[Expr | complex] = (),\n            properties: Iterable[Callable[[Expr], bool | None]] = (),\n            **assumptions: bool | None,\n        ) -> Self:\n    exclude = tuple([sympify(x) for x in exclude])\n    properties = tuple(properties)\n    cls._sanitize(assumptions, cls)\n    return Wild.__xnew__(cls, name, exclude, properties, **assumptions)",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, *args, **options):\n    if len(args) == 0:\n        raise TypeError(\"At least one (expr, cond) pair expected.\")\n    # (Try to) sympify args first\n    newargs = []\n    for ec in args:\n        # ec could be a ExprCondPair or a tuple\n        pair = ExprCondPair(*getattr(ec, 'args', ec))\n        cond = pair.cond\n        if cond is false:\n            continue\n        newargs.append(pair)\n        if cond is true:\n            break\n\n    eval = options.pop('evaluate', global_parameters.evaluate)\n    if eval:\n        r = cls.eval(*newargs)\n        if r is not None:\n            return r\n    elif len(newargs) == 1 and newargs[0].cond == True:\n        return newargs[0].expr\n\n    return Basic.__new__(cls, *newargs, **options)",
    "sympy.sympy.functions.elementary.piecewise.piecewise_integrate": "def piecewise_integrate(self, x, **kwargs):\n    \"\"\"Return the Piecewise with each expression being\n    replaced with its antiderivative. To obtain a continuous\n    antiderivative, use the :func:`~.integrate` function or method.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise\n    >>> from sympy.abc import x\n    >>> p = Piecewise((0, x < 0), (1, x < 1), (2, True))\n    >>> p.piecewise_integrate(x)\n    Piecewise((0, x < 0), (x, x < 1), (2*x, True))\n\n    Note that this does not give a continuous function, e.g.\n    at x = 1 the 3rd condition applies and the antiderivative\n    there is 2*x so the value of the antiderivative is 2:\n\n    >>> anti = _\n    >>> anti.subs(x, 1)\n    2\n\n    The continuous derivative accounts for the integral *up to*\n    the point of interest, however:\n\n    >>> p.integrate(x)\n    Piecewise((0, x < 0), (x, x < 1), (2*x - 1, True))\n    >>> _.subs(x, 1)\n    1\n\n    See Also\n    ========\n    Piecewise._eval_integral\n    \"\"\"\n    from sympy.integrals import integrate\n    return self.func(*[(integrate(e, x, **kwargs), c) for e, c in self.args])",
    "sympy.sympy.integrals.deltafunctions.deltaintegrate": "def deltaintegrate(f, x):\n    \"\"\"\n    deltaintegrate(f, x)\n\n    Explanation\n    ===========\n\n    The idea for integration is the following:\n\n    - If we are dealing with a DiracDelta expression, i.e. DiracDelta(g(x)),\n      we try to simplify it.\n\n      If we could simplify it, then we integrate the resulting expression.\n      We already know we can integrate a simplified expression, because only\n      simple DiracDelta expressions are involved.\n\n      If we couldn't simplify it, there are two cases:\n\n      1) The expression is a simple expression: we return the integral,\n         taking care if we are dealing with a Derivative or with a proper\n         DiracDelta.\n\n      2) The expression is not simple (i.e. DiracDelta(cos(x))): we can do\n         nothing at all.\n\n    - If the node is a multiplication node having a DiracDelta term:\n\n      First we expand it.\n\n      If the expansion did work, then we try to integrate the expansion.\n\n      If not, we try to extract a simple DiracDelta term, then we have two\n      cases:\n\n      1) We have a simple DiracDelta term, so we return the integral.\n\n      2) We didn't have a simple term, but we do have an expression with\n         simplified DiracDelta terms, so we integrate this expression.\n\n    Examples\n    ========\n\n        >>> from sympy.abc import x, y, z\n        >>> from sympy.integrals.deltafunctions import deltaintegrate\n        >>> from sympy import sin, cos, DiracDelta\n        >>> deltaintegrate(x*sin(x)*cos(x)*DiracDelta(x - 1), x)\n        sin(1)*cos(1)*Heaviside(x - 1)\n        >>> deltaintegrate(y**2*DiracDelta(x - z)*DiracDelta(y - z), y)\n        z**2*DiracDelta(x - z)*Heaviside(y - z)\n\n    See Also\n    ========\n\n    sympy.functions.special.delta_functions.DiracDelta\n    sympy.integrals.integrals.Integral\n    \"\"\"\n    if not f.has(DiracDelta):\n        return None\n\n    # g(x) = DiracDelta(h(x))\n    if f.func == DiracDelta:\n        h = f.expand(diracdelta=True, wrt=x)\n        if h == f:  # can't simplify the expression\n            #FIXME: the second term tells whether is DeltaDirac or Derivative\n            #For integrating derivatives of DiracDelta we need the chain rule\n            if f.is_simple(x):\n                if (len(f.args) <= 1 or f.args[1] == 0):\n                    return Heaviside(f.args[0])\n                else:\n                    return (DiracDelta(f.args[0], f.args[1] - 1) /\n                        f.args[0].as_poly().LC())\n        else:  # let's try to integrate the simplified expression\n            fh = integrate(h, x)\n            return fh\n    elif f.is_Mul or f.is_Pow:  # g(x) = a*b*c*f(DiracDelta(h(x)))*d*e\n        g = f.expand()\n        if f != g:  # the expansion worked\n            fh = integrate(g, x)\n            if fh is not None and not isinstance(fh, Integral):\n                return fh\n        else:\n            # no expansion performed, try to extract a simple DiracDelta term\n            deltaterm, rest_mult = change_mul(f, x)\n\n            if not deltaterm:\n                if rest_mult:\n                    fh = integrate(rest_mult, x)\n                    return fh\n            else:\n                from sympy.solvers import solve\n                deltaterm = deltaterm.expand(diracdelta=True, wrt=x)\n                if deltaterm.is_Mul:  # Take out any extracted factors\n                    deltaterm, rest_mult_2 = change_mul(deltaterm, x)\n                    rest_mult = rest_mult*rest_mult_2\n                point = solve(deltaterm.args[0], x)[0]\n\n                # Return the largest hyperreal term left after\n                # repeated integration by parts.  For example,\n                #\n                #   integrate(y*DiracDelta(x, 1),x) == y*DiracDelta(x,0),  not 0\n                #\n                # This is so Integral(y*DiracDelta(x).diff(x),x).doit()\n                # will return y*DiracDelta(x) instead of 0 or DiracDelta(x),\n                # both of which are correct everywhere the value is defined\n                # but give wrong answers for nested integration.\n                n = (0 if len(deltaterm.args)==1 else deltaterm.args[1])\n                m = 0\n                while n >= 0:\n                    r = S.NegativeOne**n*rest_mult.diff(x, n).subs(x, point)\n                    if r.is_zero:\n                        n -= 1\n                        m += 1\n                    else:\n                        if m == 0:\n                            return r*Heaviside(x - point)\n                        else:\n                            return r*DiracDelta(x,m-1)\n                # In some very weak sense, x=0 is still a singularity,\n                # but we hope will not be of any practical consequence.\n                return S.Zero\n    return None",
    "sympy.sympy.integrals.heurisch.heurisch_wrapper": "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3,\n                     degree_offset=0, unnecessary_permutations=None,\n                     _try_heurisch=None):\n    \"\"\"\n    A wrapper around the heurisch integration algorithm.\n\n    Explanation\n    ===========\n\n    This method takes the result from heurisch and checks for poles in the\n    denominator. For each of these poles, the integral is reevaluated, and\n    the final integration result is given in terms of a Piecewise.\n\n    Examples\n    ========\n\n    >>> from sympy import cos, symbols\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\n    >>> n, x = symbols('n x')\n    >>> heurisch(cos(n*x), x)\n    sin(n*x)/n\n    >>> heurisch_wrapper(cos(n*x), x)\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\n\n    See Also\n    ========\n\n    heurisch\n    \"\"\"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f*x\n\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset,\n                   unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n\n    # We consider each denominator in the expression, and try to find\n    # cases where one or more symbolic denominator might be zero. The\n    # conditions for these cases are stored in the list slns.\n    #\n    # Since denoms returns a set we use ordered. This is important because the\n    # ordering of slns determines the order of the resulting Piecewise so we\n    # need a deterministic order here to make the output deterministic.\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    # Remove the solutions corresponding to poles in the original expression.\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for key, value in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    # For each case listed in the list slns, we reevaluate the integral.\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries,\n                        degree_offset, unnecessary_permutations,\n                        _try_heurisch)\n        cond = And(*[Eq(key, value) for key, value in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for key, value in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict),x)\n        pairs.append((expr, cond))\n    # If there is one condition, put the generic case first. Otherwise,\n    # doing so may lead to longer Piecewise formulas\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries,\n                              degree_offset, unnecessary_permutations,\n                              _try_heurisch),\n                              generic),\n                 (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries,\n                              degree_offset, unnecessary_permutations,\n                              _try_heurisch),\n                              True))\n    return Piecewise(*pairs)",
    "sympy.sympy.integrals.heurisch.heurisch": "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3,\n             degree_offset=0, unnecessary_permutations=None,\n             _try_heurisch=None):\n    \"\"\"\n    Compute indefinite integral using heuristic Risch algorithm.\n\n    Explanation\n    ===========\n\n    This is a heuristic approach to indefinite integration in finite\n    terms using the extended heuristic (parallel) Risch algorithm, based\n    on Manuel Bronstein's \"Poor Man's Integrator\".\n\n    The algorithm supports various classes of functions including\n    transcendental elementary or special functions like Airy,\n    Bessel, Whittaker and Lambert.\n\n    Note that this algorithm is not a decision procedure. If it isn't\n    able to compute the antiderivative for a given function, then this is\n    not a proof that such a functions does not exist.  One should use\n    recursive Risch algorithm in such case.  It's an open question if\n    this algorithm can be made a full decision procedure.\n\n    This is an internal integrator procedure. You should use top level\n    'integrate' function in most cases, as this procedure needs some\n    preprocessing steps and otherwise may fail.\n\n    Specification\n    =============\n\n     heurisch(f, x, rewrite=False, hints=None)\n\n       where\n         f : expression\n         x : symbol\n\n         rewrite -> force rewrite 'f' in terms of 'tan' and 'tanh'\n         hints   -> a list of functions that may appear in anti-derivate\n\n          - hints = None          --> no suggestions at all\n          - hints = [ ]           --> try to figure out\n          - hints = [f1, ..., fn] --> we know better\n\n    Examples\n    ========\n\n    >>> from sympy import tan\n    >>> from sympy.integrals.heurisch import heurisch\n    >>> from sympy.abc import x, y\n\n    >>> heurisch(y*tan(x), x)\n    y*log(tan(x)**2 + 1)/2\n\n    See Manuel Bronstein's \"Poor Man's Integrator\":\n\n    References\n    ==========\n\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\n\n    For more information on the implemented algorithm refer to:\n\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\n       Method and its Implementation in Maple, Proceedings of\n       ISSAC'89, ACM Press, 212-217.\n\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\n       Proceedings of EUROCAM'82, LNCS 144, Springer, 144-157.\n\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\n\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\n       Algorithm (II), ACM Transactions on Mathematical\n       Software 11 (1985), 356-362.\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    sympy.integrals.heurisch.components\n    \"\"\"\n    f = sympify(f)\n\n    # There are some functions that Heurisch cannot currently handle,\n    # so do not even try.\n    # Set _try_heurisch=True to skip this check\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n\n    if not f.has_free(x):\n        return f*x\n\n    if not f.is_Add:\n        indep, f = f.as_independent(x)\n    else:\n        indep = S.One\n\n    rewritables = {\n        (sin, cos, cot): tan,\n        (sinh, cosh, coth): tanh,\n    }\n\n    if rewrite:\n        for candidates, rule in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n\n    terms = components(f, x)\n    dcache = DiffCache(x)\n\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n\n            for g in set(terms):  # using copy of terms\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a*x**b)\n\n                        if M is not None:\n                            terms.add( x*(li(M[a]*x**M[b]) - (M[a]*x**M[b])**(-1/M[b])*Ei((M[b]+1)*log(M[a]*x**M[b])/M[b])) )\n                            #terms.add( x*(li(M[a]*x**M[b]) - (x**M[b])**(-1/M[b])*Ei((M[b]+1)*log(M[a]*x**M[b])/M[b])) )\n                            #terms.add( x*(li(M[a]*x**M[b]) - x*Ei((M[b]+1)*log(M[a]*x**M[b])/M[b])) )\n                            #terms.add( li(M[a]*x**M[b]) - Ei((M[b]+1)*log(M[a]*x**M[b])/M[b]) )\n\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a*x**2)\n\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a])*x))\n                            else: # M[a].is_negative or unknown\n                                terms.add(erf(sqrt(-M[a])*x))\n\n                        M = g.args[0].match(a*x**2 + b*x + c)\n\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi/4*(-M[a]))*exp(M[c] - M[b]**2/(4*M[a]))*\n                                          erfi(sqrt(M[a])*x + M[b]/(2*sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi/4*(-M[a]))*exp(M[c] - M[b]**2/(4*M[a]))*\n                                          erf(sqrt(-M[a])*x - M[b]/(2*sqrt(-M[a]))))\n\n                        M = g.args[0].match(a*log(x)**2)\n\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a])*log(x) + 1/(2*sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a])*log(x) - 1/(2*sqrt(-M[a]))))\n\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a*x**2 + b)\n\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a]/M[b])*x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a]/M[b])*x))\n\n                        M = g.base.match(a*x**2 - b)\n\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1/sqrt(M[a]*x**2 - M[b])\n                                F = log(2*sqrt(M[a])*sqrt(M[a]*x**2 - M[b]) + 2*M[a]*x)/sqrt(M[a])\n                                dcache.cache[F] = dF  # hack: F.diff(x) doesn't automatically simplify to f\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b]/2*sqrt(-M[a])*\n                                           atan(sqrt(-M[a])*x/sqrt(M[a]*x**2 - M[b])))\n\n        else:\n            terms |= set(hints)\n\n    for g in set(terms):  # using copy of terms\n        terms |= components(dcache.get_diff(g), x)\n\n    # XXX: The commented line below makes heurisch more deterministic wrt\n    # PYTHONHASHSEED and the iteration order of sets. There are other places\n    # where sets are iterated over but this one is possibly the most important.\n    # Theoretically the order here should not matter but different orderings\n    # can expose potential bugs in the different code paths so potentially it\n    # is better to keep the non-determinism.\n    #\n    # terms = list(ordered(terms))\n\n    # TODO: caching is significant factor for why permutations work at all. Change this.\n    V = _symbols('x', len(terms))\n\n\n    # sort mapping expressions from largest to smallest (last is always x).\n    mapping = list(reversed(list(zip(*ordered(                          #\n        [(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1])) #\n    rev_mapping = {v: k for k, v in mapping}                            #\n    if mappings is None:                                                #\n        # optimizing the number of permutations of mapping              #\n        assert mapping[-1][0] == x # if not, find it and correct this comment\n        unnecessary_permutations = [mapping.pop(-1)]\n        # permute types of objects\n        types = defaultdict(list)\n        for i in mapping:\n            e, _ = i\n            types[type(e)].append(i)\n        mapping = [types[i] for i in types]\n        def _iter_mappings():\n            for i in permutations(mapping):\n                # make the expression of a given type be ordered\n                yield [j for i in i for j in ordered(i)]\n        mappings = _iter_mappings()\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [ _substitute(dcache.get_diff(g)) for g in terms ]\n        denoms = [ g.as_numer_denom()[1] for g in diffs ]\n        if all(h.is_polynomial(*V) for h in denoms) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints,\n                unnecessary_permutations=unnecessary_permutations)\n\n            if result is not None:\n                return indep*result\n        return None\n\n    numers = [ cancel(denom*g) for g in diffs ]\n    def _derivation(h):\n        return Add(*[ d * h.diff(v) for d, v in zip(numers, V) ])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n\n            if _derivation(p) is not S.Zero:\n                c, q = p.as_poly(y).primitive()\n                return _deflation(c)*gcd(q, q.diff(y)).as_expr()\n\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n\n            if _derivation(y) is not S.Zero:\n                c, q = p.as_poly(y).primitive()\n\n                q = q.as_expr()\n\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n\n                c_split = _splitter(c)\n\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n\n                q_split = _splitter(cancel(q / s))\n\n                return (c_split[0]*q_split[0]*s, c_split[1]*q_split[1])\n\n        return (S.One, p)\n\n    special = {}\n\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term)**2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n\n    F = _substitute(f)\n\n    P, Q = F.as_numer_denom()\n\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n\n    polys = set(list(v_split) + [ u_split[0] ] + list(special.keys()))\n\n    s = u_split[0] * Mul(*[ k for k, v in special.items() if v ])\n    polified = [ p.as_poly(*V) for p in [s, P, Q] ]\n\n    if None in polified:\n        return None\n\n    #--- definitions for _integrate\n    a, b, c = [ p.total_degree() for p in polified ]\n\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max(_exponent(h) for h in g.args)\n        else:\n            return 1\n\n    A, B = _exponent(f), a + max(b, c)\n\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n\n    poly_coeffs = _symbols('A', len(monoms))\n\n    poly_part = Add(*[ poly_coeffs[i]*monomial\n        for i, monomial in enumerate(monoms) ])\n\n    reducibles = set()\n\n    for poly in ordered(polys):\n        coeff, factors = factor_list(poly, *V)\n        reducibles.add(coeff)\n        reducibles.update(fact for fact, mul in factors)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n\n        log_part, atan_part = [], []\n\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue  # nontrivial x + I*y\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n\n        while pairs:\n            x, y = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                # Choosing b with no minus sign\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x*x + y*y)\n                atans.add(atan(x/y))\n            else:\n                irreducibles.add(x + I*y)\n\n\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n\n        # Note: the ordering matters here\n        for poly, b in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n\n        for poly, c in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n\n        # TODO: Currently it's better to use symbolic expressions here instead\n        # of rational functions, because it's simpler and FracElement doesn't\n        # give big speed improvement yet. This is because cancellation is slow\n        # due to slow polynomial GCD algorithms. If this gets improved then\n        # revise this code.\n        candidate = poly_part/poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n\n        # Rewrite raw_numer as a polynomial in K[coeffs][V] where K is a field\n        # that we have to determine. We can't use simply atoms() because log(3),\n        # sqrt(y) and similar expressions can appear, leading to non-trivial\n        # domains.\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass # ignore trivial numbers\n            elif expr in syms:\n                pass # ignore variables\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                # TODO: Non-polynomial expression. This should have been\n                # filtered out at an earlier stage.\n                raise PolynomialError\n\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            ground, _ = construct_domain(non_syms, field=True)\n\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(\n                dict(zip(poly_coeffs, [S.Zero]*len(poly_coeffs))))\n\n    if all(isinstance(_, Symbol) for _ in V):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))\n            ).free_symbols & Fd.free_symbols\n    if not more_free:\n        # all free generators are identified in V\n        solution = _integrate('Q')\n\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n\n        return indep*antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n\n            if result is not None:\n                return indep*result\n\n        return None",
    "sympy.sympy.integrals.heurisch._iter_mappings": "def _iter_mappings():\n    for i in permutations(mapping):\n        # make the expression of a given type be ordered\n        yield [j for i in i for j in ordered(i)]",
    "sympy.sympy.integrals.integrals.<listcomp>": "result = result.func(*[\n    arg.doit(**new_eval_kwargs) if\n    arg.has(Integral) else arg\n    for arg in result.args\n",
    "sympy.sympy.integrals.integrals.doit": "def doit(self, **hints):\n    \"\"\"\n    Perform the integration using any hints given.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, S\n    >>> from sympy.abc import x, t\n    >>> p = x**2 + Piecewise((0, x/t < 0), (1, True))\n    >>> p.integrate((t, S(4)/5, 1), (x, -1, 1))\n    1/3\n\n    See Also\n    ========\n\n    sympy.integrals.trigonometry.trigintegrate\n    sympy.integrals.heurisch.heurisch\n    sympy.integrals.rationaltools.ratint\n    as_sum : Approximate the integral using a sum\n    \"\"\"\n    if not hints.get('integrals', True):\n        return self\n\n    deep = hints.get('deep', True)\n    meijerg = hints.get('meijerg', None)\n    conds = hints.get('conds', 'piecewise')\n    risch = hints.get('risch', None)\n    heurisch = hints.get('heurisch', None)\n    manual = hints.get('manual', None)\n    if len(list(filter(None, (manual, meijerg, risch, heurisch)))) > 1:\n        raise ValueError(\"At most one of manual, meijerg, risch, heurisch can be True\")\n    elif manual:\n        meijerg = risch = heurisch = False\n    elif meijerg:\n        manual = risch = heurisch = False\n    elif risch:\n        manual = meijerg = heurisch = False\n    elif heurisch:\n        manual = meijerg = risch = False\n    eval_kwargs = {\"meijerg\": meijerg, \"risch\": risch, \"manual\": manual, \"heurisch\": heurisch,\n        \"conds\": conds}\n\n    if conds not in ('separate', 'piecewise', 'none'):\n        raise ValueError('conds must be one of \"separate\", \"piecewise\", '\n                         '\"none\", got: %s' % conds)\n\n    if risch and any(len(xab) > 1 for xab in self.limits):\n        raise ValueError('risch=True is only allowed for indefinite integrals.')\n\n    # check for the trivial zero\n    if self.is_zero:\n        return S.Zero\n\n    # hacks to handle integrals of\n    # nested summations\n    from sympy.concrete.summations import Sum\n    if isinstance(self.function, Sum):\n        if any(v in self.function.limits[0] for v in self.variables):\n            raise ValueError('Limit of the sum cannot be an integration variable.')\n        if any(l.is_infinite for l in self.function.limits[0][1:]):\n            return self\n        _i = self\n        _sum = self.function\n        return _sum.func(_i.func(_sum.function, *_i.limits).doit(), *_sum.limits).doit()\n\n    # now compute and check the function\n    function = self.function\n\n    # hack to use a consistent Heaviside(x, 1/2)\n    function = function.replace(\n        lambda x: isinstance(x, Heaviside) and x.args[1]*2 != 1,\n        lambda x: Heaviside(x.args[0]))\n\n    if deep:\n        function = function.doit(**hints)\n    if function.is_zero:\n        return S.Zero\n\n    # hacks to handle special cases\n    if isinstance(function, MatrixBase):\n        return function.applyfunc(\n            lambda f: self.func(f, *self.limits).doit(**hints))\n\n    if isinstance(function, FormalPowerSeries):\n        if len(self.limits) > 1:\n            raise NotImplementedError\n        xab = self.limits[0]\n        if len(xab) > 1:\n            return function.integrate(xab, **eval_kwargs)\n        else:\n            return function.integrate(xab[0], **eval_kwargs)\n\n    # There is no trivial answer and special handling\n    # is done so continue\n\n    # first make sure any definite limits have integration\n    # variables with matching assumptions\n    reps = {}\n    for xab in self.limits:\n        if len(xab) != 3:\n            # it makes sense to just make\n            # all x real but in practice with the\n            # current state of integration...this\n            # doesn't work out well\n            # x = xab[0]\n            # if x not in reps and not x.is_real:\n            #     reps[x] = Dummy(real=True)\n            continue\n        x, a, b = xab\n        l = (a, b)\n        if all(i.is_nonnegative for i in l) and not x.is_nonnegative:\n            d = Dummy(positive=True)\n        elif all(i.is_nonpositive for i in l) and not x.is_nonpositive:\n            d = Dummy(negative=True)\n        elif all(i.is_real for i in l) and not x.is_real:\n            d = Dummy(real=True)\n        else:\n            d = None\n        if d:\n            reps[x] = d\n    if reps:\n        undo = {v: k for k, v in reps.items()}\n        did = self.xreplace(reps).doit(**hints)\n        if isinstance(did, tuple):  # when separate=True\n            did = tuple([i.xreplace(undo) for i in did])\n        else:\n            did = did.xreplace(undo)\n        return did\n\n    # continue with existing assumptions\n    undone_limits = []\n    # ulj = free symbols of any undone limits' upper and lower limits\n    ulj = set()\n    for xab in self.limits:\n        # compute uli, the free symbols in the\n        # Upper and Lower limits of limit I\n        if len(xab) == 1:\n            uli = set(xab[:1])\n        elif len(xab) == 2:\n            uli = xab[1].free_symbols\n        elif len(xab) == 3:\n            uli = xab[1].free_symbols.union(xab[2].free_symbols)\n        # this integral can be done as long as there is no blocking\n        # limit that has been undone. An undone limit is blocking if\n        # it contains an integration variable that is in this limit's\n        # upper or lower free symbols or vice versa\n        if xab[0] in ulj or any(v[0] in uli for v in undone_limits):\n            undone_limits.append(xab)\n            ulj.update(uli)\n            function = self.func(*([function] + [xab]))\n            factored_function = function.factor()\n            if not isinstance(factored_function, Integral):\n                function = factored_function\n            continue\n\n        if function.has(Abs, sign) and (\n            (len(xab) < 3 and all(x.is_extended_real for x in xab)) or\n            (len(xab) == 3 and all(x.is_extended_real and not x.is_infinite for\n             x in xab[1:]))):\n                # some improper integrals are better off with Abs\n                xr = Dummy(\"xr\", real=True)\n                function = (function.xreplace({xab[0]: xr})\n                    .rewrite(Piecewise).xreplace({xr: xab[0]}))\n        elif function.has(Min, Max):\n            function = function.rewrite(Piecewise)\n        if (function.has(Piecewise) and\n            not isinstance(function, Piecewise)):\n                function = piecewise_fold(function)\n        if isinstance(function, Piecewise):\n            if len(xab) == 1:\n                antideriv = function._eval_integral(xab[0],\n                    **eval_kwargs)\n            else:\n                antideriv = self._eval_integral(\n                    function, xab[0], **eval_kwargs)\n        else:\n            # There are a number of tradeoffs in using the\n            # Meijer G method. It can sometimes be a lot faster\n            # than other methods, and sometimes slower. And\n            # there are certain types of integrals for which it\n            # is more likely to work than others. These\n            # heuristics are incorporated in deciding what\n            # integration methods to try, in what order. See the\n            # integrate() docstring for details.\n            def try_meijerg(function, xab):\n                ret = None\n                if len(xab) == 3 and meijerg is not False:\n                    x, a, b = xab\n                    try:\n                        res = meijerint_definite(function, x, a, b)\n                    except NotImplementedError:\n                        _debug('NotImplementedError '\n                            'from meijerint_definite')\n                        res = None\n                    if res is not None:\n                        f, cond = res\n                        if conds == 'piecewise':\n                            u = self.func(function, (x, a, b))\n                            # if Piecewise modifies cond too\n                            # much it may not be recognized by\n                            # _condsimp pattern matching so just\n                            # turn off all evaluation\n                            return Piecewise((f, cond), (u, True),\n                                evaluate=False)\n                        elif conds == 'separate':\n                            if len(self.limits) != 1:\n                                raise ValueError(filldedent('''\n                                    conds=separate not supported in\n                                    multiple integrals'''))\n                            ret = f, cond\n                        else:\n                            ret = f\n                return ret\n\n            meijerg1 = meijerg\n            if (meijerg is not False and\n                    len(xab) == 3 and xab[1].is_extended_real and xab[2].is_extended_real\n                    and not function.is_Poly and\n                    (xab[1].has(oo, -oo) or xab[2].has(oo, -oo))):\n                ret = try_meijerg(function, xab)\n                if ret is not None:\n                    function = ret\n                    continue\n                meijerg1 = False\n            # If the special meijerg code did not succeed in\n            # finding a definite integral, then the code using\n            # meijerint_indefinite will not either (it might\n            # find an antiderivative, but the answer is likely\n            # to be nonsensical). Thus if we are requested to\n            # only use Meijer G-function methods, we give up at\n            # this stage. Otherwise we just disable G-function\n            # methods.\n            if meijerg1 is False and meijerg is True:\n                antideriv = None\n            else:\n                antideriv = self._eval_integral(\n                    function, xab[0], **eval_kwargs)\n                if antideriv is None and meijerg is True:\n                    ret = try_meijerg(function, xab)\n                    if ret is not None:\n                        function = ret\n                        continue\n\n        final = hints.get('final', True)\n        # dotit may be iterated but floor terms making atan and acot\n        # continuous should only be added in the final round\n        if (final and not isinstance(antideriv, Integral) and\n            antideriv is not None):\n            for atan_term in antideriv.atoms(atan):\n                atan_arg = atan_term.args[0]\n                # Checking `atan_arg` to be linear combination of `tan` or `cot`\n                for tan_part in atan_arg.atoms(tan):\n                    x1 = Dummy('x1')\n                    tan_exp1 = atan_arg.subs(tan_part, x1)\n                    # The coefficient of `tan` should be constant\n                    coeff = tan_exp1.diff(x1)\n                    if x1 not in coeff.free_symbols:\n                        a = tan_part.args[0]\n                        antideriv = antideriv.subs(atan_term, Add(atan_term,\n                            sign(coeff)*pi*floor((a-pi/2)/pi)))\n                for cot_part in atan_arg.atoms(cot):\n                    x1 = Dummy('x1')\n                    cot_exp1 = atan_arg.subs(cot_part, x1)\n                    # The coefficient of `cot` should be constant\n                    coeff = cot_exp1.diff(x1)\n                    if x1 not in coeff.free_symbols:\n                        a = cot_part.args[0]\n                        antideriv = antideriv.subs(atan_term, Add(atan_term,\n                            sign(coeff)*pi*floor((a)/pi)))\n\n        if antideriv is None:\n            undone_limits.append(xab)\n            function = self.func(*([function] + [xab])).factor()\n            factored_function = function.factor()\n            if not isinstance(factored_function, Integral):\n                function = factored_function\n            continue\n        else:\n            if len(xab) == 1:\n                function = antideriv\n            else:\n                if len(xab) == 3:\n                    x, a, b = xab\n                elif len(xab) == 2:\n                    x, b = xab\n                    a = None\n                else:\n                    raise NotImplementedError\n\n                if deep:\n                    if isinstance(a, Basic):\n                        a = a.doit(**hints)\n                    if isinstance(b, Basic):\n                        b = b.doit(**hints)\n\n                if antideriv.is_Poly:\n                    gens = list(antideriv.gens)\n                    gens.remove(x)\n\n                    antideriv = antideriv.as_expr()\n\n                    function = antideriv._eval_interval(x, a, b)\n                    function = Poly(function, *gens)\n                else:\n                    def is_indef_int(g, x):\n                        return (isinstance(g, Integral) and\n                                any(i == (x,) for i in g.limits))\n\n                    def eval_factored(f, x, a, b):\n                        # _eval_interval for integrals with\n                        # (constant) factors\n                        # a single indefinite integral is assumed\n                        args = []\n                        for g in Mul.make_args(f):\n                            if is_indef_int(g, x):\n                                args.append(g._eval_interval(x, a, b))\n                            else:\n                                args.append(g)\n                        return Mul(*args)\n\n                    integrals, others, piecewises = [], [], []\n                    for f in Add.make_args(antideriv):\n                        if any(is_indef_int(g, x)\n                               for g in Mul.make_args(f)):\n                            integrals.append(f)\n                        elif any(isinstance(g, Piecewise)\n                                 for g in Mul.make_args(f)):\n                            piecewises.append(piecewise_fold(f))\n                        else:\n                            others.append(f)\n                    uneval = Add(*[eval_factored(f, x, a, b)\n                                   for f in integrals])\n                    try:\n                        evalued = Add(*others)._eval_interval(x, a, b)\n                        evalued_pw = piecewise_fold(Add(*piecewises))._eval_interval(x, a, b)\n                        function = uneval + evalued + evalued_pw\n                    except NotImplementedError:\n                        # This can happen if _eval_interval depends in a\n                        # complicated way on limits that cannot be computed\n                        undone_limits.append(xab)\n                        function = self.func(*([function] + [xab]))\n                        factored_function = function.factor()\n                        if not isinstance(factored_function, Integral):\n                            function = factored_function\n    return function",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.integrals.integrals._eval_integral": "def _eval_integral(self, f, x, meijerg=None, risch=None, manual=None,\n                   heurisch=None, conds='piecewise',final=None):\n    \"\"\"\n    Calculate the anti-derivative to the function f(x).\n\n    Explanation\n    ===========\n\n    The following algorithms are applied (roughly in this order):\n\n    1. Simple heuristics (based on pattern matching and integral table):\n\n       - most frequently used functions (e.g. polynomials, products of\n         trig functions)\n\n    2. Integration of rational functions:\n\n       - A complete algorithm for integrating rational functions is\n         implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm\n         also uses the partial fraction decomposition algorithm\n         implemented in apart() as a preprocessor to make this process\n         faster.  Note that the integral of a rational function is always\n         elementary, but in general, it may include a RootSum.\n\n    3. Full Risch algorithm:\n\n       - The Risch algorithm is a complete decision\n         procedure for integrating elementary functions, which means that\n         given any elementary function, it will either compute an\n         elementary antiderivative, or else prove that none exists.\n         Currently, part of transcendental case is implemented, meaning\n         elementary integrals containing exponentials, logarithms, and\n         (soon!) trigonometric functions can be computed.  The algebraic\n         case, e.g., functions containing roots, is much more difficult\n         and is not implemented yet.\n\n       - If the routine fails (because the integrand is not elementary, or\n         because a case is not implemented yet), it continues on to the\n         next algorithms below.  If the routine proves that the integrals\n         is nonelementary, it still moves on to the algorithms below,\n         because we might be able to find a closed-form solution in terms\n         of special functions.  If risch=True, however, it will stop here.\n\n    4. The Meijer G-Function algorithm:\n\n       - This algorithm works by first rewriting the integrand in terms of\n         very general Meijer G-Function (meijerg in SymPy), integrating\n         it, and then rewriting the result back, if possible.  This\n         algorithm is particularly powerful for definite integrals (which\n         is actually part of a different method of Integral), since it can\n         compute closed-form solutions of definite integrals even when no\n         closed-form indefinite integral exists.  But it also is capable\n         of computing many indefinite integrals as well.\n\n       - Another advantage of this method is that it can use some results\n         about the Meijer G-Function to give a result in terms of a\n         Piecewise expression, which allows to express conditionally\n         convergent integrals.\n\n       - Setting meijerg=True will cause integrate() to use only this\n         method.\n\n    5. The \"manual integration\" algorithm:\n\n       - This algorithm tries to mimic how a person would find an\n         antiderivative by hand, for example by looking for a\n         substitution or applying integration by parts. This algorithm\n         does not handle as many integrands but can return results in a\n         more familiar form.\n\n       - Sometimes this algorithm can evaluate parts of an integral; in\n         this case integrate() will try to evaluate the rest of the\n         integrand using the other methods here.\n\n       - Setting manual=True will cause integrate() to use only this\n         method.\n\n    6. The Heuristic Risch algorithm:\n\n       - This is a heuristic version of the Risch algorithm, meaning that\n         it is not deterministic.  This is tried as a last resort because\n         it can be very slow.  It is still used because not enough of the\n         full Risch algorithm is implemented, so that there are still some\n         integrals that can only be computed using this method.  The goal\n         is to implement enough of the Risch and Meijer G-function methods\n         so that this can be deleted.\n\n         Setting heurisch=True will cause integrate() to use only this\n         method. Set heurisch=False to not use it.\n\n    \"\"\"\n\n    from sympy.integrals.risch import risch_integrate, NonElementaryIntegral\n    from sympy.integrals.manualintegrate import manualintegrate\n\n    if risch:\n        try:\n            return risch_integrate(f, x, conds=conds)\n        except NotImplementedError:\n            return None\n\n    if manual:\n        try:\n            result = manualintegrate(f, x)\n            if result is not None and result.func != Integral:\n                return result\n        except (ValueError, PolynomialError):\n            pass\n\n    eval_kwargs = {\"meijerg\": meijerg, \"risch\": risch, \"manual\": manual,\n        \"heurisch\": heurisch, \"conds\": conds}\n\n    # if it is a poly(x) then let the polynomial integrate itself (fast)\n    #\n    # It is important to make this check first, otherwise the other code\n    # will return a SymPy expression instead of a Polynomial.\n    #\n    # see Polynomial for details.\n    if isinstance(f, Poly) and not (manual or meijerg or risch):\n        # Note: this is deprecated, but the deprecation warning is already\n        # issued in the Integral constructor.\n        return f.integrate(x)\n\n    # Piecewise antiderivatives need to call special integrate.\n    if isinstance(f, Piecewise):\n        return f.piecewise_integrate(x, **eval_kwargs)\n\n    # let's cut it short if `f` does not depend on `x`; if\n    # x is only a dummy, that will be handled below\n    if not f.has(x):\n        return f*x\n\n    # try to convert to poly(x) and then integrate if successful (fast)\n    poly = f.as_poly(x)\n    if poly is not None and not (manual or meijerg or risch):\n        return poly.integrate().as_expr()\n\n    if risch is not False:\n        try:\n            result, i = risch_integrate(f, x, separate_integral=True,\n                conds=conds)\n        except NotImplementedError:\n            pass\n        else:\n            if i:\n                # There was a nonelementary integral. Try integrating it.\n\n                # if no part of the NonElementaryIntegral is integrated by\n                # the Risch algorithm, then use the original function to\n                # integrate, instead of re-written one\n                if result == 0:\n                    return NonElementaryIntegral(f, x).doit(risch=False)\n                else:\n                    return result + i.doit(risch=False)\n            else:\n                return result\n\n    # since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...\n    # we are going to handle Add terms separately,\n    # if `f` is not Add -- we only have one term\n\n    # Note that in general, this is a bad idea, because Integral(g1) +\n    # Integral(g2) might not be computable, even if Integral(g1 + g2) is.\n    # For example, Integral(x**x + x**x*log(x)).  But many heuristics only\n    # work term-wise.  So we compute this step last, after trying\n    # risch_integrate.  We also try risch_integrate again in this loop,\n    # because maybe the integral is a sum of an elementary part and a\n    # nonelementary part (like erf(x) + exp(x)).  risch_integrate() is\n    # quite fast, so this is acceptable.\n    from sympy.simplify.fu import sincos_to_sum\n    parts = []\n    args = Add.make_args(f)\n    for g in args:\n        coeff, g = g.as_independent(x)\n\n        # g(x) = const\n        if g is S.One and not meijerg:\n            parts.append(coeff*x)\n            continue\n\n        # g(x) = expr + O(x**n)\n        order_term = g.getO()\n\n        if order_term is not None:\n            h = self._eval_integral(g.removeO(), x, **eval_kwargs)\n\n            if h is not None:\n                h_order_expr = self._eval_integral(order_term.expr, x, **eval_kwargs)\n\n                if h_order_expr is not None:\n                    h_order_term = order_term.func(\n                        h_order_expr, *order_term.variables)\n                    parts.append(coeff*(h + h_order_term))\n                    continue\n\n            # NOTE: if there is O(x**n) and we fail to integrate then\n            # there is no point in trying other methods because they\n            # will fail, too.\n            return None\n\n        #               c\n        # g(x) = (a*x+b)\n        if g.is_Pow and not g.exp.has(x) and not meijerg:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n\n            M = g.base.match(a*x + b)\n\n            if M is not None:\n                if g.exp == -1:\n                    h = log(g.base)\n                elif conds != 'piecewise':\n                    h = g.base**(g.exp + 1) / (g.exp + 1)\n                else:\n                    h1 = log(g.base)\n                    h2 = g.base**(g.exp + 1) / (g.exp + 1)\n                    h = Piecewise((h2, Ne(g.exp, -1)), (h1, True))\n\n                parts.append(coeff * h / M[a])\n                continue\n\n        #        poly(x)\n        # g(x) = -------\n        #        poly(x)\n        if g.is_rational_function(x) and not (manual or meijerg or risch):\n            parts.append(coeff * ratint(g, x))\n            continue\n\n        if not (manual or meijerg or risch):\n            # g(x) = Mul(trig)\n            h = trigintegrate(g, x, conds=conds)\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n            # g(x) has at least a DiracDelta term\n            h = deltaintegrate(g, x)\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n            from .singularityfunctions import singularityintegrate\n            # g(x) has at least a Singularity Function term\n            h = singularityintegrate(g, x)\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n            # Try risch again.\n            if risch is not False:\n                try:\n                    h, i = risch_integrate(g, x,\n                        separate_integral=True, conds=conds)\n                except NotImplementedError:\n                    h = None\n                else:\n                    if i:\n                        h = h + i.doit(risch=False)\n\n                    parts.append(coeff*h)\n                    continue\n\n            # fall back to heurisch\n            if heurisch is not False:\n                from sympy.integrals.heurisch import (heurisch as heurisch_,\n                                                      heurisch_wrapper)\n                try:\n                    if conds == 'piecewise':\n                        h = heurisch_wrapper(g, x, hints=[])\n                    else:\n                        h = heurisch_(g, x, hints=[])\n                except PolynomialError:\n                    # XXX: this exception means there is a bug in the\n                    # implementation of heuristic Risch integration\n                    # algorithm.\n                    h = None\n        else:\n            h = None\n\n        if meijerg is not False and h is None:\n            # rewrite using G functions\n            try:\n                h = meijerint_indefinite(g, x)\n            except NotImplementedError:\n                _debug('NotImplementedError from meijerint_definite')\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n        if h is None and manual is not False:\n            try:\n                result = manualintegrate(g, x)\n                if result is not None and not isinstance(result, Integral):\n                    if result.has(Integral) and not manual:\n                        # Try to have other algorithms do the integrals\n                        # manualintegrate can't handle,\n                        # unless we were asked to use manual only.\n                        # Keep the rest of eval_kwargs in case another\n                        # method was set to False already\n                        new_eval_kwargs = eval_kwargs\n                        new_eval_kwargs[\"manual\"] = False\n                        new_eval_kwargs[\"final\"] = False\n                        result = result.func(*[\n                            arg.doit(**new_eval_kwargs) if\n                            arg.has(Integral) else arg\n                            for arg in result.args\n                        ]).expand(multinomial=False,\n                                  log=False,\n                                  power_exp=False,\n                                  power_base=False)\n                    if not result.has(Integral):\n                        parts.append(coeff * result)\n                        continue\n            except (ValueError, PolynomialError):\n                # can't handle some SymPy expressions\n                pass\n\n        # if we failed maybe it was because we had\n        # a product that could have been expanded,\n        # so let's try an expansion of the whole\n        # thing before giving up; we don't try this\n        # at the outset because there are things\n        # that cannot be solved unless they are\n        # NOT expanded e.g., x**x*(1+log(x)). There\n        # should probably be a checker somewhere in this\n        # routine to look for such cases and try to do\n        # collection on the expressions if they are already\n        # in an expanded form\n        if not h and len(args) == 1:\n            f = sincos_to_sum(f).expand(mul=True, deep=False)\n            if f.is_Add:\n                # Note: risch will be identical on the expanded\n                # expression, but maybe it will be able to pick out parts,\n                # like x*(exp(x) + erf(x)).\n                return self._eval_integral(f, x, **eval_kwargs)\n\n        if h is not None:\n            parts.append(coeff * h)\n        else:\n            return None\n\n    return Add(*parts)",
    "sympy.sympy.integrals.manualintegrate.manualintegrate": "def manualintegrate(f, var):\n    \"\"\"manualintegrate(f, var)\n\n    Explanation\n    ===========\n\n    Compute indefinite integral of a single variable using an algorithm that\n    resembles what a student would do by hand.\n\n    Unlike :func:`~.integrate`, var can only be a single symbol.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos, tan, exp, log, integrate\n    >>> from sympy.integrals.manualintegrate import manualintegrate\n    >>> from sympy.abc import x\n    >>> manualintegrate(1 / x, x)\n    log(x)\n    >>> integrate(1/x)\n    log(x)\n    >>> manualintegrate(log(x), x)\n    x*log(x) - x\n    >>> integrate(log(x))\n    x*log(x) - x\n    >>> manualintegrate(exp(x) / (1 + exp(2 * x)), x)\n    atan(exp(x))\n    >>> integrate(exp(x) / (1 + exp(2 * x)))\n    RootSum(4*_z**2 + 1, Lambda(_i, _i*log(2*_i + exp(x))))\n    >>> manualintegrate(cos(x)**4 * sin(x), x)\n    -cos(x)**5/5\n    >>> integrate(cos(x)**4 * sin(x), x)\n    -cos(x)**5/5\n    >>> manualintegrate(cos(x)**4 * sin(x)**3, x)\n    cos(x)**7/7 - cos(x)**5/5\n    >>> integrate(cos(x)**4 * sin(x)**3, x)\n    cos(x)**7/7 - cos(x)**5/5\n    >>> manualintegrate(tan(x), x)\n    -log(cos(x))\n    >>> integrate(tan(x), x)\n    -log(cos(x))\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.integrate\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    \"\"\"\n    result = integral_steps(f, var).eval()\n    # Clear the cache of u-parts\n    _parts_u_cache.clear()\n    # If we got Piecewise with two parts, put generic first\n    if isinstance(result, Piecewise) and len(result.args) == 2:\n        cond = result.args[0][1]\n        if isinstance(cond, Eq) and result.args[1][1] == True:\n            result = result.func(\n                (result.args[1][0], Ne(*cond.args)),\n                (result.args[0][0], True))\n    # Factor terms like erf(x)*sin(x) that may have been expanded\n    def _has_erf_trig_mul(expr):\n        for sub in expr.find(Mul):\n            if sub.has(erf, erfc, erfi) and sub.has(sin, cos, sinh, cosh):\n                return True\n        return False\n    if _has_erf_trig_mul(f) and _has_erf_trig_mul(result):\n        result = factor_terms(result)\n    return result",
    "sympy.sympy.integrals.meijerint.meijerint_indefinite": "def meijerint_indefinite(f, x):\n    \"\"\"\n    Compute an indefinite integral of ``f`` by rewriting it as a G function.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import meijerint_indefinite\n    >>> from sympy import sin\n    >>> from sympy.abc import x\n    >>> meijerint_indefinite(sin(x), x)\n    -cos(x)\n    \"\"\"\n    f = sympify(f)\n    results = []\n    for a in sorted(_find_splitting_points(f, x) | {S.Zero}, key=default_sort_key):\n        res = _meijerint_indefinite_1(f.subs(x, x + a), x)\n        if not res:\n            continue\n        res = res.subs(x, x - a)\n        if _has(res, hyper, meijerg):\n            results.append(res)\n        else:\n            return res\n    if f.has(HyperbolicFunction):\n        _debug('Try rewriting hyperbolics in terms of exp.')\n        rv = meijerint_indefinite(\n            _rewrite_hyperbolics_as_exp(f), x)\n        if rv:\n            if not isinstance(rv, list):\n                from sympy.simplify.radsimp import collect\n                return collect(factor_terms(rv), rv.atoms(exp))\n            results.extend(rv)\n    if results:\n        return next(ordered(results))",
    "sympy.sympy.integrals.rationaltools.ratint": "def ratint(f, x, **flags):\n    \"\"\"\n    Performs indefinite integration of rational functions.\n\n    Explanation\n    ===========\n\n    Given a field :math:`K` and a rational function :math:`f = p/q`,\n    where :math:`p` and :math:`q` are polynomials in :math:`K[x]`,\n    returns a function :math:`g` such that :math:`f = g'`.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.rationaltools import ratint\n    >>> from sympy.abc import x\n\n    >>> ratint(36/(x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2), x)\n    (12*x + 6)/(x**2 - 1) + 4*log(x - 2) - 4*log(x + 1)\n\n    References\n    ==========\n\n    .. [1] M. Bronstein, Symbolic Integration I: Transcendental\n       Functions, Second Edition, Springer-Verlag, 2005, pp. 35-70\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.rationaltools.ratint_logpart\n    sympy.integrals.rationaltools.ratint_ratpart\n\n    \"\"\"\n    if isinstance(f, tuple):\n        p, q = f\n    else:\n        p, q = f.as_numer_denom()\n\n    p, q = Poly(p, x, composite=False, field=True), Poly(q, x, composite=False, field=True)\n\n    coeff, p, q = p.cancel(q)\n    poly, p = p.div(q)\n\n    result = poly.integrate(x).as_expr()\n\n    if p.is_zero:\n        return coeff*result\n\n    g, h = ratint_ratpart(p, q, x)\n\n    P, Q = h.as_numer_denom()\n\n    P = Poly(P, x)\n    Q = Poly(Q, x)\n\n    q, r = P.div(Q)\n\n    result += g + q.integrate(x).as_expr()\n\n    if not r.is_zero:\n        symbol = flags.get('symbol', 't')\n\n        if not isinstance(symbol, Symbol):\n            t = Dummy(symbol)\n        else:\n            t = symbol.as_dummy()\n\n        L = ratint_logpart(r, Q, x, t)\n\n        real = flags.get('real')\n\n        if real is None:\n            if isinstance(f, tuple):\n                p, q = f\n                atoms = p.atoms() | q.atoms()\n            else:\n                atoms = f.atoms()\n\n            for elt in atoms - {x}:\n                if not elt.is_extended_real:\n                    real = False\n                    break\n            else:\n                real = True\n\n        eps = S.Zero\n\n        if not real:\n            for h, q in L:\n                _, h = h.primitive()\n                eps += RootSum(\n                    q, Lambda(t, t*log(h.as_expr())), quadratic=True)\n        else:\n            for h, q in L:\n                _, h = h.primitive()\n                R = log_to_real(h, q, x, t)\n\n                if R is not None:\n                    eps += R\n                else:\n                    eps += RootSum(\n                        q, Lambda(t, t*log(h.as_expr())), quadratic=True)\n\n        result += eps\n\n    return coeff*result",
    "sympy.sympy.integrals.risch.risch_integrate": "def risch_integrate(f, x, extension=None, handle_first='log',\n                    separate_integral=False, rewrite_complex=None,\n                    conds='piecewise'):\n    r\"\"\"\n    The Risch Integration Algorithm.\n\n    Explanation\n    ===========\n\n    Only transcendental functions are supported.  Currently, only exponentials\n    and logarithms are supported, but support for trigonometric functions is\n    forthcoming.\n\n    If this function returns an unevaluated Integral in the result, it means\n    that it has proven that integral to be nonelementary.  Any errors will\n    result in raising NotImplementedError.  The unevaluated Integral will be\n    an instance of NonElementaryIntegral, a subclass of Integral.\n\n    handle_first may be either 'exp' or 'log'.  This changes the order in\n    which the extension is built, and may result in a different (but\n    equivalent) solution (for an example of this, see issue 5109).  It is also\n    possible that the integral may be computed with one but not the other,\n    because not all cases have been implemented yet.  It defaults to 'log' so\n    that the outer extension is exponential when possible, because more of the\n    exponential case has been implemented.\n\n    If ``separate_integral`` is ``True``, the result is returned as a tuple (ans, i),\n    where the integral is ans + i, ans is elementary, and i is either a\n    NonElementaryIntegral or 0.  This useful if you want to try further\n    integrating the NonElementaryIntegral part using other algorithms to\n    possibly get a solution in terms of special functions.  It is False by\n    default.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.risch import risch_integrate\n    >>> from sympy import exp, log, pprint\n    >>> from sympy.abc import x\n\n    First, we try integrating exp(-x**2). Except for a constant factor of\n    2/sqrt(pi), this is the famous error function.\n\n    >>> pprint(risch_integrate(exp(-x**2), x))\n      /\n     |\n     |    2\n     |  -x\n     | e    dx\n     |\n    /\n\n    The unevaluated Integral in the result means that risch_integrate() has\n    proven that exp(-x**2) does not have an elementary anti-derivative.\n\n    In many cases, risch_integrate() can split out the elementary\n    anti-derivative part from the nonelementary anti-derivative part.\n    For example,\n\n    >>> pprint(risch_integrate((2*log(x)**2 - log(x) - x**2)/(log(x)**3 -\n    ... x**2*log(x)), x))\n                                             /\n                                            |\n      log(-x + log(x))   log(x + log(x))    |   1\n    - ---------------- + --------------- +  | ------ dx\n             2                  2           | log(x)\n                                            |\n                                           /\n\n    This means that it has proven that the integral of 1/log(x) is\n    nonelementary.  This function is also known as the logarithmic integral,\n    and is often denoted as Li(x).\n\n    risch_integrate() currently only accepts purely transcendental functions\n    with exponentials and logarithms, though note that this can include\n    nested exponentials and logarithms, as well as exponentials with bases\n    other than E.\n\n    >>> pprint(risch_integrate(exp(x)*exp(exp(x)), x))\n     / x\\\n     \\e /\n    e\n    >>> pprint(risch_integrate(exp(exp(x)), x))\n      /\n     |\n     |  / x\\\n     |  \\e /\n     | e     dx\n     |\n    /\n\n    >>> pprint(risch_integrate(x*x**x*log(x) + x**x + x*x**x, x))\n       x\n    x*x\n    >>> pprint(risch_integrate(x**x, x))\n      /\n     |\n     |  x\n     | x  dx\n     |\n    /\n\n    >>> pprint(risch_integrate(-1/(x*log(x)*log(log(x))**2), x))\n         1\n    -----------\n    log(log(x))\n\n    \"\"\"\n    f = S(f)\n\n    DE = extension or DifferentialExtension(f, x, handle_first=handle_first,\n            dummy=True, rewrite_complex=rewrite_complex)\n    fa, fd = DE.fa, DE.fd\n\n    result = S.Zero\n    for case in reversed(DE.cases):\n        if not fa.expr.has(DE.t) and not fd.expr.has(DE.t) and not case == 'base':\n            DE.decrement_level()\n            fa, fd = frac_in((fa, fd), DE.t)\n            continue\n\n        fa, fd = fa.cancel(fd, include=True)\n        if case == 'exp':\n            ans, i, b = integrate_hyperexponential(fa, fd, DE, conds=conds)\n        elif case == 'primitive':\n            ans, i, b = integrate_primitive(fa, fd, DE)\n        elif case == 'base':\n            # XXX: We can't call ratint() directly here because it doesn't\n            # handle polynomials correctly.\n            ans = integrate(fa.as_expr()/fd.as_expr(), DE.x, risch=False)\n            b = False\n            i = S.Zero\n        else:\n            raise NotImplementedError(\"Only exponential and logarithmic \"\n            \"extensions are currently supported.\")\n\n        result += ans\n        if b:\n            DE.decrement_level()\n            fa, fd = frac_in(i, DE.t)\n        else:\n            result = result.subs(DE.backsubs)\n            if not i.is_zero:\n                i = NonElementaryIntegral(i.function.subs(DE.backsubs),i.limits)\n            if not separate_integral:\n                result += i\n                return result\n            else:\n\n                if isinstance(i, NonElementaryIntegral):\n                    return (result, i)\n                else:\n                    return (result, 0)",
    "sympy.sympy.integrals.singularityfunctions.singularityintegrate": "def singularityintegrate(f, x):\n    \"\"\"\n    This function handles the indefinite integrations of Singularity functions.\n    The ``integrate`` function calls this function internally whenever an\n    instance of SingularityFunction is passed as argument.\n\n    Explanation\n    ===========\n\n    The idea for integration is the following:\n\n    - If we are dealing with a SingularityFunction expression,\n      i.e. ``SingularityFunction(x, a, n)``, we just return\n      ``SingularityFunction(x, a, n + 1)/(n + 1)`` if ``n >= 0`` and\n      ``SingularityFunction(x, a, n + 1)`` if ``n < 0``.\n\n    - If the node is a multiplication or power node having a\n      SingularityFunction term we rewrite the whole expression in terms of\n      Heaviside and DiracDelta and then integrate the output. Lastly, we\n      rewrite the output of integration back in terms of SingularityFunction.\n\n    - If none of the above case arises, we return None.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.singularityfunctions import singularityintegrate\n    >>> from sympy import SingularityFunction, symbols, Function\n    >>> x, a, n, y = symbols('x a n y')\n    >>> f = Function('f')\n    >>> singularityintegrate(SingularityFunction(x, a, 3), x)\n    SingularityFunction(x, a, 4)/4\n    >>> singularityintegrate(5*SingularityFunction(x, 5, -2), x)\n    5*SingularityFunction(x, 5, -1)\n    >>> singularityintegrate(6*SingularityFunction(x, 5, -1), x)\n    6*SingularityFunction(x, 5, 0)\n    >>> singularityintegrate(x*SingularityFunction(x, 0, -1), x)\n    0\n    >>> singularityintegrate(SingularityFunction(x, 1, -1) * f(x), x)\n    f(1)*SingularityFunction(x, 1, 0)\n\n    \"\"\"\n\n    if not f.has(SingularityFunction):\n        return None\n\n    if isinstance(f, SingularityFunction):\n        x, a, n = f.args\n        if n.is_positive or n.is_zero:\n            return SingularityFunction(x, a, n + 1)/(n + 1)\n        elif n in (-1, -2, -3, -4):\n            return SingularityFunction(x, a, n + 1)\n\n    if f.is_Mul or f.is_Pow:\n\n        expr = f.rewrite(DiracDelta)\n        expr = integrate(expr, x)\n        return expr.rewrite(SingularityFunction)\n    return None",
    "sympy.sympy.integrals.trigonometry.trigintegrate": "def trigintegrate(f, x, conds='piecewise'):\n    \"\"\"\n    Integrate f = Mul(trig) over x.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos, tan, sec\n    >>> from sympy.integrals.trigonometry import trigintegrate\n    >>> from sympy.abc import x\n\n    >>> trigintegrate(sin(x)*cos(x), x)\n    sin(x)**2/2\n\n    >>> trigintegrate(sin(x)**2, x)\n    x/2 - sin(x)*cos(x)/2\n\n    >>> trigintegrate(tan(x)*sec(x), x)\n    1/cos(x)\n\n    >>> trigintegrate(sin(x)*tan(x), x)\n    -log(sin(x) - 1)/2 + log(sin(x) + 1)/2 - sin(x)\n\n    References\n    ==========\n\n    .. [1] https://en.wikibooks.org/wiki/Calculus/Integration_techniques\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    \"\"\"\n    pat, a, n, m = _pat_sincos(x)\n\n    f = f.rewrite('sincos')\n    M = f.match(pat)\n\n    if M is None:\n        return\n\n    n, m = M[n], M[m]\n    if n.is_zero and m.is_zero:\n        return x\n    zz = x if n.is_zero else S.Zero\n\n    a = M[a]\n\n    if n.is_odd or m.is_odd:\n        u = _u\n        n_, m_ = n.is_odd, m.is_odd\n\n        # take smallest n or m -- to choose simplest substitution\n        if n_ and m_:\n\n            # Make sure to choose the positive one\n            # otherwise an incorrect integral can occur.\n            if n < 0 and m > 0:\n                m_ = True\n                n_ = False\n            elif m < 0 and n > 0:\n                n_ = True\n                m_ = False\n            # Both are negative so choose the smallest n or m\n            # in absolute value for simplest substitution.\n            elif (n < 0 and m < 0):\n                n_ = n > m\n                m_ = not (n > m)\n\n            # Both n and m are odd and positive\n            else:\n                n_ = (n < m)      # NB: careful here, one of the\n                m_ = not (n < m)  # conditions *must* be true\n\n        #  n      m       u=C        (n-1)/2    m\n        # S(x) * C(x) dx  --> -(1-u^2)       * u  du\n        if n_:\n            ff = -(1 - u**2)**((n - 1)/2) * u**m\n            uu = cos(a*x)\n\n        #  n      m       u=S   n         (m-1)/2\n        # S(x) * C(x) dx  -->  u  * (1-u^2)       du\n        elif m_:\n            ff = u**n * (1 - u**2)**((m - 1)/2)\n            uu = sin(a*x)\n\n        fi = integrate(ff, u)  # XXX cyclic deps\n        fx = fi.subs(u, uu)\n        if conds == 'piecewise':\n            return Piecewise((fx / a, Ne(a, 0)), (zz, True))\n        return fx / a\n\n    # n & m are both even\n    #\n    #               2k      2m                         2l       2l\n    # we transform S (x) * C (x) into terms with only S (x) or C (x)\n    #\n    # example:\n    #  100     4       100        2    2    100          4         2\n    # S (x) * C (x) = S (x) * (1-S (x))  = S (x) * (1 + S (x) - 2*S (x))\n    #\n    #                  104       102     100\n    #               = S (x) - 2*S (x) + S (x)\n    #       2k\n    # then S   is integrated with recursive formula\n\n    # take largest n or m -- to choose simplest substitution\n    n_ = (Abs(n) > Abs(m))\n    m_ = (Abs(m) > Abs(n))\n    res = S.Zero\n\n    if n_:\n        #  2k         2 k             i             2i\n        # C   = (1 - S )  = sum(i, (-) * B(k, i) * S  )\n        if m > 0:\n            for i in range(0, m//2 + 1):\n                res += (S.NegativeOne**i * binomial(m//2, i) *\n                        _sin_pow_integrate(n + 2*i, x))\n\n        elif m == 0:\n            res = _sin_pow_integrate(n, x)\n        else:\n\n            # m < 0 , |n| > |m|\n            #  /\n            # |\n            # |    m       n\n            # | cos (x) sin (x) dx =\n            # |\n            # |\n            #/\n            #                                      /\n            #                                     |\n            #   -1        m+1     n-1     n - 1   |     m+2     n-2\n            # ________ cos (x) sin (x) + _______  |  cos (x) sin (x) dx\n            #                                     |\n            #   m + 1                     m + 1   |\n            #                                    /\n\n            res = (Rational(-1, m + 1) * cos(x)**(m + 1) * sin(x)**(n - 1) +\n                   Rational(n - 1, m + 1) *\n                   trigintegrate(cos(x)**(m + 2)*sin(x)**(n - 2), x))\n\n    elif m_:\n        #  2k         2 k            i             2i\n        # S   = (1 - C ) = sum(i, (-) * B(k, i) * C  )\n        if n > 0:\n\n            #      /                            /\n            #     |                            |\n            #     |    m       n               |    -m         n\n            #     | cos (x)*sin (x) dx  or     | cos (x) * sin (x) dx\n            #     |                            |\n            #    /                            /\n            #\n            #    |m| > |n| ; m, n >0 ; m, n belong to Z - {0}\n            #       n                                         2\n            #    sin (x) term is expanded here in terms of cos (x),\n            #    and then integrated.\n            #\n\n            for i in range(0, n//2 + 1):\n                res += (S.NegativeOne**i * binomial(n//2, i) *\n                        _cos_pow_integrate(m + 2*i, x))\n\n        elif n == 0:\n\n            #   /\n            #  |\n            #  |  1\n            #  | _ _ _\n            #  |    m\n            #  | cos (x)\n            # /\n            #\n\n            res = _cos_pow_integrate(m, x)\n        else:\n\n            # n < 0 , |m| > |n|\n            #  /\n            # |\n            # |    m       n\n            # | cos (x) sin (x) dx =\n            # |\n            # |\n            #/\n            #                                      /\n            #                                     |\n            #    1        m-1     n+1     m - 1   |     m-2     n+2\n            #  _______ cos (x) sin (x) + _______  |  cos (x) sin (x) dx\n            #                                     |\n            #   n + 1                     n + 1   |\n            #                                    /\n\n            res = (Rational(1, n + 1) * cos(x)**(m - 1)*sin(x)**(n + 1) +\n                   Rational(m - 1, n + 1) *\n                   trigintegrate(cos(x)**(m - 2)*sin(x)**(n + 2), x))\n\n    else:\n        if m == n:\n            ##Substitute sin(2x)/2 for sin(x)cos(x) and then Integrate.\n            res = integrate((sin(2*x)*S.Half)**m, x)\n        elif (m == -n):\n            if n < 0:\n                # Same as the scheme described above.\n                # the function argument to integrate in the end will\n                # be 1, this cannot be integrated by trigintegrate.\n                # Hence use sympy.integrals.integrate.\n                res = (Rational(1, n + 1) * cos(x)**(m - 1) * sin(x)**(n + 1) +\n                       Rational(m - 1, n + 1) *\n                       integrate(cos(x)**(m - 2) * sin(x)**(n + 2), x))\n            else:\n                res = (Rational(-1, m + 1) * cos(x)**(m + 1) * sin(x)**(n - 1) +\n                       Rational(n - 1, m + 1) *\n                       integrate(cos(x)**(m + 2)*sin(x)**(n - 2), x))\n    if conds == 'piecewise':\n        return Piecewise((res.subs(x, a*x) / a, Ne(a, 0)), (zz, True))\n    return res.subs(x, a*x) / a",
    "sympy.sympy.polys.polytools.as_expr": "def as_expr(f, *gens):\n    \"\"\"\n    Convert a Poly instance to an Expr instance.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n    >>> f.as_expr()\n    x**2 + 2*x*y**2 - y\n    >>> f.as_expr({x: 5})\n    10*y**2 - y + 25\n    >>> f.as_expr(5, 6)\n    379\n\n    \"\"\"\n    if not gens:\n        return f.expr\n\n    if len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\n                    \"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    "sympy.sympy.polys.polytools.integrate": "def integrate(self, *specs, **args):\n    \"\"\"\n    Computes indefinite integral of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> Poly(x**2 + 2*x + 1, x).integrate()\n    Poly(1/3*x**3 + x**2 + x, x, domain='QQ')\n\n    >>> Poly(x*y**2 + x, x, y).integrate((0, 1), (1, 0))\n    Poly(1/2*x**2*y**2 + 1/2*x**2, x, y, domain='QQ')\n\n    \"\"\"\n    f = self\n\n    if args.get('auto', True) and f.rep.dom.is_Ring:\n        f = f.to_field()\n\n    if hasattr(f.rep, 'integrate'):\n        if not specs:\n            return f.per(f.rep.integrate(m=1))\n\n        rep = f.rep\n\n        for spec in specs:\n            if isinstance(spec, tuple):\n                gen, m = spec\n            else:\n                gen, m = spec, 1\n\n            rep = rep.integrate(int(m), f._gen_to_level(gen))\n\n        return f.per(rep)\n    else:  # pragma: no cover\n        raise OperationNotSupported(f, 'integrate')",
    "sympy.sympy.series.order.expr": "@property\ndef expr(self):\n    return self.args[0]",
    "sympy.sympy.series.order.variables": "@property\ndef variables(self):\n    if self.args[1:]:\n        return tuple(x[0] for x in self.args[1:])\n    else:\n        return ()",
    "sympy.sympy.series.order.removeO": "def removeO(self):\n    return S.Zero",
    "sympy.sympy.series.order.getO": "def getO(self):\n    return self",
    "sympy.sympy.simplify.fu.sincos_to_sum": "def sincos_to_sum(expr):\n    \"\"\"Convert products and powers of sin and cos to sums.\n\n    Explanation\n    ===========\n\n    Applied power reduction TRpower first, then expands products, and\n    converts products to sums with TR8.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import sincos_to_sum\n    >>> from sympy.abc import x\n    >>> from sympy import cos, sin\n    >>> sincos_to_sum(16*sin(x)**3*cos(2*x)**2)\n    7*sin(x) - 5*sin(3*x) + 3*sin(5*x) - sin(7*x)\n    \"\"\"\n\n    if not expr.has(cos, sin):\n        return expr\n    else:\n        return TR8(expand_mul(TRpower(expr)))",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1",
    "sympy.sympy.utilities.misc.debug": "def debug(*args):\n    \"\"\"\n    Print ``*args`` if SYMPY_DEBUG is True, else do nothing.\n    \"\"\"\n    from sympy import SYMPY_DEBUG\n    if SYMPY_DEBUG:\n        print(*args, file=sys.stderr)"
}