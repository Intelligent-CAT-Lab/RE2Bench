{
    "sympy.sympy.codegen.numpy_nodes._eval_simplify": "def _eval_simplify(self, *args, **kwargs):\n    a, b = (x.simplify(**kwargs) for x in self.args)\n    candidate = _logaddexp(a, b)\n    if candidate != _logaddexp(a, b, evaluate=False):\n        return candidate\n    else:\n        return logaddexp(a, b)",
    "sympy.sympy.codegen.scipy_nodes._eval_simplify": "def _eval_simplify(self, **kwargs):\n    x, y = self.args\n    candidate = _powm1(x.simplify(**kwargs), y.simplify(**kwargs))\n    if candidate != _powm1(x, y, evaluate=False):\n        return candidate\n    else:\n        return powm1(x, y)",
    "sympy.sympy.concrete.products._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify.simplify import product_simplify\n    rv = product_simplify(self, **kwargs)\n    return rv.doit() if kwargs['doit'] else rv",
    "sympy.sympy.concrete.summations._eval_simplify": "def _eval_simplify(self, **kwargs):\n\n    function = self.function\n\n    if kwargs.get('deep', True):\n        function = function.simplify(**kwargs)\n\n    # split the function into adds\n    terms = Add.make_args(expand(function))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n\n    for term in terms:\n        if term.has(Sum):\n            # if there is an embedded sum here\n            # it is of the form x * (Sum(whatever))\n            # hence we make a Mul out of it, and simplify all interior sum terms\n            subterms = Mul.make_args(expand(term))\n            out_terms = []\n            for subterm in subterms:\n                # go through each term\n                if isinstance(subterm, Sum):\n                    # if it's a sum, simplify it\n                    out_terms.append(subterm._eval_simplify(**kwargs))\n                else:\n                    # otherwise, add it as is\n                    out_terms.append(subterm)\n\n            # turn it back into a Mul\n            s_t.append(Mul(*out_terms))\n        else:\n            o_t.append(term)\n\n    # next try to combine any interior sums for further simplification\n    from sympy.simplify.simplify import factor_sum, sum_combine\n    result = Add(sum_combine(s_t), *o_t)\n\n    return factor_sum(result, limits=self.limits)",
    "sympy.sympy.core.add.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self. If radical is True (default is False) then\n    common radicals will be removed and included as a factor of the\n    primitive expression.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (3 + 3*sqrt(2)).as_content_primitive()\n    (3, 1 + sqrt(2))\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(\n        radical=radical, clear=clear)) for a in self.args]).primitive()\n    if not clear and not con.is_Integer and prim.is_Add:\n        con, d = con.as_numer_denom()\n        _p = prim/d\n        if any(a.as_coeff_Mul()[0].is_Integer for a in _p.args):\n            prim = _p\n        else:\n            con /= d\n    if radical and prim.is_Add:\n        # look for common radicals that can be removed\n        args = prim.args\n        rads = []\n        common_q = None\n        for m in args:\n            term_rads = defaultdict(list)\n            for ai in Mul.make_args(m):\n                if ai.is_Pow:\n                    b, e = ai.as_base_exp()\n                    if e.is_Rational and b.is_Integer:\n                        term_rads[e.q].append(abs(int(b))**e.p)\n            if not term_rads:\n                break\n            if common_q is None:\n                common_q = set(term_rads.keys())\n            else:\n                common_q = common_q & set(term_rads.keys())\n                if not common_q:\n                    break\n            rads.append(term_rads)\n        else:\n            # process rads\n            # keep only those in common_q\n            for r in rads:\n                for q in list(r.keys()):\n                    if q not in common_q:\n                        r.pop(q)\n                for q in r:\n                    r[q] = Mul(*r[q])\n            # find the gcd of bases for each q\n            G = []\n            for q in common_q:\n                g = reduce(igcd, [r[q] for r in rads], 0)\n                if g != 1:\n                    G.append(g**Rational(1, q))\n            if G:\n                G = Mul(*G)\n                args = [ai/G for ai in args]\n                prim = G*prim.func(*args)\n\n    return con, prim",
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.add.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return _could_extract_minus_sign(self)",
    "sympy.sympy.core.add.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"\n    Decomposes an expression to its numerator part and its\n    denominator part.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> (x*y/z).as_numer_denom()\n    (x*y, z)\n    >>> (x*(y + 1)/y**7).as_numer_denom()\n    (x*(y + 1), y**7)\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_numer_denom\n    \"\"\"\n    # clear rational denominator\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n\n    # collect numerators and denominators of the terms\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n\n    # check for quick exit\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return self.func(\n            *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n\n    # sum up the terms having a common denominator\n    nd2 = {d: self.func(*n) if len(n) > 1 else n[0] for d, n in nd.items()}\n\n    # assemble single numerator and denominator\n    denoms, numers = [list(i) for i in zip(*iter(nd2.items()))]\n    n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n               for i in range(len(numers))]), Mul(*denoms)\n\n    return _keep_coeff(ncon, n), _keep_coeff(dcon, d)",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    "sympy.sympy.core.basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None) -> Basic:\n    \"\"\"\n    Replace matching subexpressions of ``self`` with ``value``.\n\n    If ``map = True`` then also return the mapping {old: new} where ``old``\n    was a sub-expression found with query and ``new`` is the replacement\n    value for it. If the expression itself does not match the query, then\n    the returned value will be ``self.xreplace(map)`` otherwise it should\n    be ``self.subs(ordered(map.items()))``.\n\n    Traverses an expression tree and performs replacement of matching\n    subexpressions from the bottom to the top of the tree. The default\n    approach is to do the replacement in a simultaneous fashion so\n    changes made are targeted only once. If this is not desired or causes\n    problems, ``simultaneous`` can be set to False.\n\n    In addition, if an expression containing more than one Wild symbol\n    is being used to match subexpressions and the ``exact`` flag is None\n    it will be set to True so the match will only succeed if all non-zero\n    values are received for each Wild that appears in the match pattern.\n    Setting this to False accepts a match of 0; while setting it True\n    accepts all matches that have a 0 in them. See example below for\n    cautions.\n\n    The list of possible combinations of queries and replacement values\n    is listed below:\n\n    Examples\n    ========\n\n    Initial setup\n\n    >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n    >>> from sympy.abc import x, y\n    >>> f = log(sin(x)) + tan(sin(x**2))\n\n    1.1. type -> type\n        obj.replace(type, newtype)\n\n        When object of type ``type`` is found, replace it with the\n        result of passing its argument(s) to ``newtype``.\n\n        >>> f.replace(sin, cos)\n        log(cos(x)) + tan(cos(x**2))\n        >>> sin(x).replace(sin, cos, map=True)\n        (cos(x), {sin(x): cos(x)})\n        >>> (x*y).replace(Mul, Add)\n        x + y\n\n    1.2. type -> func\n        obj.replace(type, func)\n\n        When object of type ``type`` is found, apply ``func`` to its\n        argument(s). ``func`` must be written to handle the number\n        of arguments of ``type``.\n\n        >>> f.replace(sin, lambda arg: sin(2*arg))\n        log(sin(2*x)) + tan(sin(2*x**2))\n        >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n        sin(2*x*y)\n\n    2.1. pattern -> expr\n        obj.replace(pattern(wild), expr(wild))\n\n        Replace subexpressions matching ``pattern`` with the expression\n        written in terms of the Wild symbols in ``pattern``.\n\n        >>> a, b = map(Wild, 'ab')\n        >>> f.replace(sin(a), tan(a))\n        log(tan(x)) + tan(tan(x**2))\n        >>> f.replace(sin(a), tan(a/2))\n        log(tan(x/2)) + tan(tan(x**2/2))\n        >>> f.replace(sin(a), a)\n        log(x) + tan(x**2)\n        >>> (x*y).replace(a*x, a)\n        y\n\n        Matching is exact by default when more than one Wild symbol\n        is used: matching fails unless the match gives non-zero\n        values for all Wild symbols:\n\n        >>> (2*x + y).replace(a*x + b, b - a)\n        y - 2\n        >>> (2*x).replace(a*x + b, b - a)\n        2*x\n\n        When set to False, the results may be non-intuitive:\n\n        >>> (2*x).replace(a*x + b, b - a, exact=False)\n        2/x\n\n    2.2. pattern -> func\n        obj.replace(pattern(wild), lambda wild: expr(wild))\n\n        All behavior is the same as in 2.1 but now a function in terms of\n        pattern variables is used rather than an expression:\n\n        >>> f.replace(sin(a), lambda a: sin(2*a))\n        log(sin(2*x)) + tan(sin(2*x**2))\n\n    3.1. func -> func\n        obj.replace(filter, func)\n\n        Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n        is True.\n\n        >>> g = 2*sin(x**3)\n        >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n        4*sin(x**9)\n\n    The expression itself is also targeted by the query but is done in\n    such a fashion that changes are not made twice.\n\n        >>> e = x*(x*y + 1)\n        >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n        2*x*(2*x*y + 1)\n\n    When matching a single symbol, `exact` will default to True, but\n    this may or may not be the behavior that is desired:\n\n    Here, we want `exact=False`:\n\n    >>> from sympy import Function\n    >>> f = Function('f')\n    >>> e = f(1) + f(0)\n    >>> q = f(a), lambda a: f(a + 1)\n    >>> e.replace(*q, exact=False)\n    f(1) + f(2)\n    >>> e.replace(*q, exact=True)\n    f(0) + f(2)\n\n    But here, the nature of matching makes selecting\n    the right setting tricky:\n\n    >>> e = x**(1 + y)\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(-x - y + 1)\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(1 - y)\n\n    It is probably better to use a different form of the query\n    that describes the target expression more precisely:\n\n    >>> (1 + x**(1 + y)).replace(\n    ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n    ... lambda x: x.base**(1 - (x.exp - 1)))\n    ...\n    x**(1 - y) + 1\n\n    See Also\n    ========\n\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n\n    \"\"\"\n\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n\n        if isinstance(value, type) or callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError(\n                \"given a type, replace() expects another \"\n                \"type or a callable\")\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            from .symbol import Wild\n            exact = (len(query.atoms(Wild)) > 1)\n\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: (value.subs(result)\n                    if all(result.values()) else expr)\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            # match dictionary keys get the trailing underscore stripped\n            # from them and are then passed as keywords to the callable;\n            # if ``exact`` is True, only accept match if there are no null\n            # values amongst those matched.\n            if exact:\n                _value = lambda expr, result: (value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n                    if all(val for val in result.values()) else expr)\n            else:\n                _value = lambda expr, result: value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError(\n                \"given an expression, replace() expects \"\n                \"another expression or a callable\")\n    elif callable(query):\n        _query = query\n\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError(\n                \"given a callable, replace() expects \"\n                \"another callable\")\n    else:\n        raise TypeError(\n            \"first argument to replace() must be a \"\n            \"type, an expression or a callable\")\n\n    def walk(rv, F):\n        \"\"\"Apply ``F`` to args and then to result.\n        \"\"\"\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        # if rv is something that was already\n                        # matched (that was changed) then skip\n                        # applying F again\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n\n    mapping = {}  # changes that took place\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv # type: ignore",
    "sympy.sympy.core.basic.rewrite": "def rewrite(self, *args, deep=True, **hints):\n    \"\"\"\n    Rewrite *self* using a defined rule.\n\n    Rewriting transforms an expression to another, which is mathematically\n    equivalent but structurally different. For example you can rewrite\n    trigonometric functions as complex exponentials or combinatorial\n    functions as gamma function.\n\n    This method takes a *pattern* and a *rule* as positional arguments.\n    *pattern* is optional parameter which defines the types of expressions\n    that will be transformed. If it is not passed, all possible expressions\n    will be rewritten. *rule* defines how the expression will be rewritten.\n\n    Parameters\n    ==========\n\n    args : Expr\n        A *rule*, or *pattern* and *rule*.\n        - *pattern* is a type or an iterable of types.\n        - *rule* can be any object.\n\n    deep : bool, optional\n        If ``True``, subexpressions are recursively transformed. Default is\n        ``True``.\n\n    Examples\n    ========\n\n    If *pattern* is unspecified, all possible expressions are transformed.\n\n    >>> from sympy import cos, sin, exp, I\n    >>> from sympy.abc import x\n    >>> expr = cos(x) + I*sin(x)\n    >>> expr.rewrite(exp)\n    exp(I*x)\n\n    Pattern can be a type or an iterable of types.\n\n    >>> expr.rewrite(sin, exp)\n    exp(I*x)/2 + cos(x) - exp(-I*x)/2\n    >>> expr.rewrite([cos,], exp)\n    exp(I*x)/2 + I*sin(x) + exp(-I*x)/2\n    >>> expr.rewrite([cos, sin], exp)\n    exp(I*x)\n\n    Rewriting behavior can be implemented by defining ``_eval_rewrite()``\n    method.\n\n    >>> from sympy import Expr, sqrt, pi\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite(self, rule, args, **hints):\n    ...         x, = args\n    ...         if rule == cos:\n    ...             return cos(pi/2 - x, evaluate=False)\n    ...         if rule == sqrt:\n    ...             return sqrt(1 - cos(x)**2)\n    >>> MySin(MySin(x)).rewrite(cos)\n    cos(-cos(-x + pi/2) + pi/2)\n    >>> MySin(x).rewrite(sqrt)\n    sqrt(1 - cos(x)**2)\n\n    Defining ``_eval_rewrite_as_[...]()`` method is supported for backwards\n    compatibility reason. This may be removed in the future and using it is\n    discouraged.\n\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite_as_cos(self, *args, **hints):\n    ...         x, = args\n    ...         return cos(pi/2 - x, evaluate=False)\n    >>> MySin(x).rewrite(cos)\n    cos(-x + pi/2)\n\n    \"\"\"\n    if not args:\n        return self\n\n    hints.update(deep=deep)\n\n    pattern = args[:-1]\n    rule = args[-1]\n\n    # Special case: map `abs` to `Abs`\n    if rule is abs:\n        from sympy.functions.elementary.complexes import Abs\n        rule = Abs\n\n    # support old design by _eval_rewrite_as_[...] method\n    if isinstance(rule, str):\n        method = \"_eval_rewrite_as_%s\" % rule\n    elif hasattr(rule, \"__name__\"):\n        # rule is class or function\n        clsname = rule.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n    else:\n        # rule is instance\n        clsname = rule.__class__.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n\n    if pattern:\n        if iterable(pattern[0]):\n            pattern = pattern[0]\n        pattern = tuple(p for p in pattern if self.has(p))\n        if not pattern:\n            return self\n    # hereafter, empty pattern is interpreted as all pattern.\n\n    return self._rewrite(pattern, rule, method, **hints)",
    "sympy.sympy.core.basic._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"This method should recursively remove a Rational from all arguments\n    and return that (content) and the new self (primitive). The content\n    should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n    The primitive need not be in canonical form and should try to preserve\n    the underlying structure if possible (i.e. expand_mul should not be\n    applied to self).\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import x, y, z\n\n    >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n\n    The as_content_primitive function is recursive and retains structure:\n\n    >>> eq.as_content_primitive()\n    (2, x + 3*y*(y + 1) + 1)\n\n    Integer powers will have Rationals extracted from the base:\n\n    >>> ((2 + 6*x)**2).as_content_primitive()\n    (4, (3*x + 1)**2)\n    >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n    (1, (2*(3*x + 1))**(2*y))\n\n    Terms may end up joining once their as_content_primitives are added:\n\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (11, x*(y + 1))\n    >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (9, x*(y + 1))\n    >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n    (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n    (121, x**2*(y + 1)**2)\n    >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()\n    (1, 4.84*x**2*(y + 1)**2)\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    If clear=False (default is True) then content will not be removed\n    from an Add if it can be distributed to leave one or more\n    terms with integer coefficients.\n\n    >>> (x/2 + y).as_content_primitive()\n    (1/2, x + 2*y)\n    >>> (x/2 + y).as_content_primitive(clear=False)\n    (1, x/2 + y)\n    \"\"\"\n    return S.One, self",
    "sympy.sympy.core.expr.as_numer_denom": "def as_numer_denom(self) -> tuple[Expr, Expr]:\n    \"\"\"Return the numerator and the denominator of an expression.\n\n    expression -> a/b -> a, b\n\n    This is just a stub that should be defined by\n    an object's class methods to get anything else.\n\n    See Also\n    ========\n\n    normal: return ``a/b`` instead of ``(a, b)``\n\n    \"\"\"\n    return self, S.One",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.could_extract_minus_sign": "def could_extract_minus_sign(self) -> bool:\n    \"\"\"Return True if self has -1 as a leading factor or has\n    more literal negative signs than positive signs in a sum,\n    otherwise False.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> e = x - y\n    >>> {i.could_extract_minus_sign() for i in (e, -e)}\n    {False, True}\n\n    Though the ``y - x`` is considered like ``-(x - y)``, since it\n    is in a product without a leading factor of -1, the result is\n    false below:\n\n    >>> (x*(y - x)).could_extract_minus_sign()\n    False\n\n    To put something in canonical form wrt to sign, use `signsimp`:\n\n    >>> from sympy import signsimp\n    >>> signsimp(x*(y - x))\n    -x*(x - y)\n    >>> _.could_extract_minus_sign()\n    True\n    \"\"\"\n    return False",
    "sympy.sympy.core.expr.cancel": "def cancel(self, *gens, **args):\n    \"\"\"See the cancel function in sympy.polys\"\"\"\n    from sympy.polys.polytools import cancel\n    return cancel(self, *gens, **args)",
    "sympy.sympy.core.exprtools.factor_terms": "def factor_terms(expr: Expr | complex, radical=False, clear=False, fraction=False, sign=True) -> Expr:\n    \"\"\"Remove common factors from terms in all arguments without\n    changing the underlying structure of the expr. No expansion or\n    simplification (and no processing of non-commutatives) is performed.\n\n    Parameters\n    ==========\n\n    radical: bool, optional\n        If radical=True then a radical common to all terms will be factored\n        out of any Add sub-expressions of the expr.\n\n    clear : bool, optional\n        If clear=False (default) then coefficients will not be separated\n        from a single Add if they can be distributed to leave one or more\n        terms with integer coefficients.\n\n    fraction : bool, optional\n        If fraction=True (default is False) then a common denominator will be\n        constructed for the expression.\n\n    sign : bool, optional\n        If sign=True (default) then even if the only factor in common is a -1,\n        it will be factored out of the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_terms, Symbol\n    >>> from sympy.abc import x, y\n    >>> factor_terms(x + x*(2 + 4*y)**3)\n    x*(8*(2*y + 1)**3 + 1)\n    >>> A = Symbol('A', commutative=False)\n    >>> factor_terms(x*A + x*A + x*y*A)\n    x*(y*A + 2*A)\n\n    When ``clear`` is False, a rational will only be factored out of an\n    Add expression if all terms of the Add have coefficients that are\n    fractions:\n\n    >>> factor_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> factor_terms(x/2 + 1, clear=True)\n    (x + 2)/2\n\n    If a -1 is all that can be factored out, to *not* factor it out, the\n    flag ``sign`` must be False:\n\n    >>> factor_terms(-x - y)\n    -(x + y)\n    >>> factor_terms(-x - y, sign=False)\n    -x - y\n    >>> factor_terms(-2*x - 2*y, sign=False)\n    -2*(x + y)\n\n    See Also\n    ========\n\n    gcd_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.integrals.integrals import Integral\n        is_iterable = iterable(expr)\n\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n\n        if expr.is_Pow or expr.is_Function or \\\n                is_iterable or not hasattr(expr, 'args_cnc'):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n\n        if isinstance(expr, (Sum, Integral)):\n            return _factor_sum_int(expr,\n                radical=radical, clear=clear,\n                fraction=fraction, sign=sign)\n\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            # get a common negative (if there) which gcd_terms does not remove\n            if not any(a.as_coeff_Mul()[0].extract_multiplicatively(-1) is None\n                       for a in list_args):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            # rebuild p not worrying about the order which gcd_terms will fix\n            p = Add._from_args(list_args)\n            p = gcd_terms(p,\n                isprimitive=True,\n                clear=clear,\n                fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(\n                *[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr2 = sympify(expr)\n    return do(expr2)",
    "sympy.sympy.core.function._mexpand": "def _mexpand(expr, recursive=False):\n    # expand multinomials and then expand products; this may not always\n    # be sufficient to give a fully expanded expression (see\n    # test_issue_8247_8354 in test_arit)\n    if expr is None:\n        return\n    was = None\n    while was != expr:\n        was, expr = expr, expand_mul(expand_multinomial(expr))\n        if not recursive:\n            break\n    return expr",
    "sympy.sympy.core.function.expand_mul": "def expand_mul(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    \"\"\"\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False,\n    power_base=False, basic=False, multinomial=False, log=False)",
    "sympy.sympy.core.function.expand_log": "def expand_log(expr, deep=True, force=False, factor=False):\n    \"\"\"\n    Wrapper around expand that only uses the log hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_log, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_log(exp(x+y)*(x+y)*log(x*y**2))\n    (x + y)*(log(x) + 2*log(y))*exp(x + y)\n\n    \"\"\"\n    from sympy.functions.elementary.exponential import log\n    from sympy.simplify.radsimp import fraction\n    if factor is False:\n        def _handleMul(x):\n            # look for the simple case of expanded log(b**a)/log(b) -> a in args\n            n, d = fraction(x)\n            n = [i for i in n.atoms(log) if i.args[0].is_Integer]\n            d = [i for i in d.atoms(log) if i.args[0].is_Integer]\n            if len(n) == 1 and len(d) == 1:\n                n = n[0]\n                d = d[0]\n                from sympy import multiplicity\n                m = multiplicity(d.args[0], n.args[0])\n                if m:\n                    r = m + log(n.args[0]//d.args[0]**m)/d\n                    x = x.subs(n, d*r)\n            x1 = expand_mul(expand_log(x, deep=deep, force=force, factor=True))\n            if x1.count(log) <= x.count(log):\n                return x1\n            return x\n\n        expr = expr.replace(\n        lambda x: x.is_Mul and all(any(isinstance(i, log) and i.args[0].is_Rational\n        for i in Mul.make_args(j)) for j in x.as_numer_denom()),\n        _handleMul)\n\n    return sympify(expr).expand(deep=deep, log=True, mul=False,\n        power_exp=False, power_base=False, multinomial=False,\n        basic=False, force=force, factor=factor)",
    "sympy.sympy.core.function.expand_power_exp": "def expand_power_exp(expr, deep=True):\n    \"\"\"\n    Wrapper around expand that only uses the power_exp hint.\n\n    See the expand docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import expand_power_exp, Symbol\n    >>> from sympy.abc import x, y\n    >>> expand_power_exp(3**(y + 2))\n    9*3**y\n    >>> expand_power_exp(x**(y + 2))\n    x**(y + 2)\n\n    If ``x = 0`` the value of the expression depends on the\n    value of ``y``; if the expression were expanded the result\n    would be 0. So expansion is only done if ``x != 0``:\n\n    >>> expand_power_exp(Symbol('x', zero=False)**(y + 2))\n    x**2*x**y\n    \"\"\"\n    return sympify(expr).expand(deep=deep, complex=False, basic=False,\n    log=False, mul=False, power_exp=True, power_base=False, multinomial=False)",
    "sympy.sympy.core.function.count_ops": "def count_ops(expr, visual=False):\n    \"\"\"\n    Return a representation (integer or expression) of the operations in expr.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        If expr is an iterable, the sum of the op counts of the\n        items will be returned.\n\n    visual : bool, optional\n        If ``False`` (default) then the sum of the coefficients of the\n        visual expression will be returned.\n        If ``True`` then the number of each type of operation is shown\n        with the core class types (or their virtual equivalent) multiplied by the\n        number of times they occur.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import a, b, x, y\n    >>> from sympy import sin, count_ops\n\n    Although there is not a SUB object, minus signs are interpreted as\n    either negations or subtractions:\n\n    >>> (x - y).count_ops(visual=True)\n    SUB\n    >>> (-x).count_ops(visual=True)\n    NEG\n\n    Here, there are two Adds and a Pow:\n\n    >>> (1 + a + b**2).count_ops(visual=True)\n    2*ADD + POW\n\n    In the following, an Add, Mul, Pow and two functions:\n\n    >>> (sin(x)*x + sin(x)**2).count_ops(visual=True)\n    ADD + MUL + POW + 2*SIN\n\n    for a total of 5:\n\n    >>> (sin(x)*x + sin(x)**2).count_ops(visual=False)\n    5\n\n    Note that \"what you type\" is not always what you get. The expression\n    1/x/y is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather\n    than two DIVs:\n\n    >>> (1/x/y).count_ops(visual=True)\n    DIV + MUL\n\n    The visual option can be used to demonstrate the difference in\n    operations for expressions in different forms. Here, the Horner\n    representation is compared with the expanded form of a polynomial:\n\n    >>> eq=x*(1 + x*(2 + x*(3 + x)))\n    >>> count_ops(eq.expand(), visual=True) - count_ops(eq, visual=True)\n    -MUL + 3*POW\n\n    The count_ops function also handles iterables:\n\n    >>> count_ops([x, sin(x), None, True, x + 2], visual=False)\n    2\n    >>> count_ops([x, sin(x), None, True, x + 2], visual=True)\n    ADD + SIN\n    >>> count_ops({x: sin(x), x + 2: y + 1}, visual=True)\n    2*ADD + SIN\n\n    \"\"\"\n    from .relational import Relational\n    from sympy.concrete.summations import Sum\n    from sympy.integrals.integrals import Integral\n    from sympy.logic.boolalg import BooleanFunction\n    from sympy.simplify.radsimp import fraction\n\n    expr = sympify(expr)\n    if isinstance(expr, Expr) and not expr.is_Relational:\n\n        ops = []\n        args = [expr]\n        NEG = Symbol('NEG')\n        DIV = Symbol('DIV')\n        SUB = Symbol('SUB')\n        ADD = Symbol('ADD')\n        EXP = Symbol('EXP')\n        while args:\n            a = args.pop()\n\n            # if the following fails because the object is\n            # not Basic type, then the object should be fixed\n            # since it is the intention that all args of Basic\n            # should themselves be Basic\n            if a.is_Rational:\n                #-1/3 = NEG + DIV\n                if a is not S.One:\n                    if a.p < 0:\n                        ops.append(NEG)\n                    if a.q != 1:\n                        ops.append(DIV)\n                    continue\n            elif a.is_Mul or a.is_MatMul:\n                if _coeff_isneg(a):\n                    ops.append(NEG)\n                    if a.args[0] is S.NegativeOne:\n                        a = a.as_two_terms()[1]\n                    else:\n                        a = -a\n                n, d = fraction(a)\n                if n.is_Integer:\n                    ops.append(DIV)\n                    if n < 0:\n                        ops.append(NEG)\n                    args.append(d)\n                    continue  # won't be -Mul but could be Add\n                elif d is not S.One:\n                    if not d.is_Integer:\n                        args.append(d)\n                    ops.append(DIV)\n                    args.append(n)\n                    continue  # could be -Mul\n            elif a.is_Add or a.is_MatAdd:\n                aargs = list(a.args)\n                negs = 0\n                for i, ai in enumerate(aargs):\n                    if _coeff_isneg(ai):\n                        negs += 1\n                        args.append(-ai)\n                        if i > 0:\n                            ops.append(SUB)\n                    else:\n                        args.append(ai)\n                        if i > 0:\n                            ops.append(ADD)\n                if negs == len(aargs):  # -x - y = NEG + SUB\n                    ops.append(NEG)\n                elif _coeff_isneg(aargs[0]):  # -x + y = SUB, but already recorded ADD\n                    ops.append(SUB - ADD)\n                continue\n            if a.is_Pow and a.exp is S.NegativeOne:\n                ops.append(DIV)\n                args.append(a.base)  # won't be -Mul but could be Add\n                continue\n            if a == S.Exp1:\n                ops.append(EXP)\n                continue\n            if a.is_Pow and a.base == S.Exp1:\n                ops.append(EXP)\n                args.append(a.exp)\n                continue\n            if a.is_Mul or isinstance(a, LatticeOp):\n                o = Symbol(a.func.__name__.upper())\n                # count the args\n                ops.append(o*(len(a.args) - 1))\n            elif a.args and (\n                    a.is_Pow or a.is_Function or isinstance(a, (Derivative, Integral, Sum))):\n                # if it's not in the list above we don't\n                # consider a.func something to count, e.g.\n                # Tuple, MatrixSymbol, etc...\n                if isinstance(a.func, UndefinedFunction):\n                    o = Symbol(\"FUNC_\" + a.func.__name__.upper())\n                else:\n                    o = Symbol(a.func.__name__.upper())\n                ops.append(o)\n\n            if not a.is_Symbol:\n                args.extend(a.args)\n\n    elif isinstance(expr, Dict):\n        ops = [count_ops(k, visual=visual) +\n               count_ops(v, visual=visual) for k, v in expr.items()]\n    elif iterable(expr):\n        ops = [count_ops(i, visual=visual) for i in expr]\n    elif isinstance(expr, (Relational, BooleanFunction)):\n        ops = []\n        for arg in expr.args:\n            ops.append(count_ops(arg, visual=True))\n        o = Symbol(func_name(expr, short=True).upper())\n        ops.append(o)\n    elif not isinstance(expr, Basic):\n        ops = []\n    else:  # it's Basic not isinstance(expr, Expr):\n        if not isinstance(expr, Basic):\n            raise TypeError(\"Invalid type of expr\")\n        else:\n            ops = []\n            args = [expr]\n            while args:\n                a = args.pop()\n\n                if a.args:\n                    o = Symbol(type(a).__name__.upper())\n                    if a.is_Boolean:\n                        ops.append(o*(len(a.args)-1))\n                    else:\n                        ops.append(o)\n                    args.extend(a.args)\n\n    if not ops:\n        if visual:\n            return S.Zero\n        return 0\n\n    ops = Add(*ops)\n\n    if visual:\n        return ops\n\n    if ops.is_Number:\n        return int(ops)\n\n    return sum(int((a.args or [1])[0]) for a in Add.make_args(ops))",
    "sympy.sympy.core.function.nfloat": "def nfloat(expr, n=15, exponent=False, dkeys=False):\n    \"\"\"Make all Rationals in expr Floats except those in exponents\n    (unless the exponents flag is set to True) and those in undefined\n    functions. When processing dictionaries, do not modify the keys\n    unless ``dkeys=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import nfloat, cos, pi, sqrt\n    >>> from sympy.abc import x, y\n    >>> nfloat(x**4 + x/2 + cos(pi/3) + 1 + sqrt(y))\n    x**4 + 0.5*x + sqrt(y) + 1.5\n    >>> nfloat(x**4 + sqrt(y), exponent=True)\n    x**4.0 + y**0.5\n\n    Container types are not modified:\n\n    >>> type(nfloat((1, 2))) is tuple\n    True\n    \"\"\"\n    from sympy.matrices.matrixbase import MatrixBase\n\n    kw = {\"n\": n, \"exponent\": exponent, \"dkeys\": dkeys}\n\n    if isinstance(expr, MatrixBase):\n        return expr.applyfunc(lambda e: nfloat(e, **kw))\n\n    # handling of iterable containers\n    if iterable(expr, exclude=str):\n        if isinstance(expr, (dict, Dict)):\n            if dkeys:\n                args = [tuple((nfloat(i, **kw) for i in a))\n                    for a in expr.items()]\n            else:\n                args = [(k, nfloat(v, **kw)) for k, v in expr.items()]\n            if isinstance(expr, dict):\n                return type(expr)(args)\n            else:\n                return expr.func(*args)\n        elif isinstance(expr, Basic):\n            return expr.func(*[nfloat(a, **kw) for a in expr.args])\n        return type(expr)([nfloat(a, **kw) for a in expr])\n\n    rv = sympify(expr)\n\n    if rv.is_Number:\n        return Float(rv, n)\n    elif rv.is_number:\n        # evalf doesn't always set the precision\n        rv = rv.n(n)\n        if rv.is_Number:\n            rv = Float(rv.n(n), n)\n        else:\n            pass  # pure_complex(rv) is likely True\n        return rv\n    elif rv.is_Atom:\n        return rv\n    elif rv.is_Relational:\n        args_nfloat = (nfloat(arg, **kw) for arg in rv.args)\n        return rv.func(*args_nfloat)\n\n\n    # watch out for RootOf instances that don't like to have\n    # their exponents replaced with Dummies and also sometimes have\n    # problems with evaluating at low precision (issue 6393)\n    from sympy.polys.rootoftools import RootOf\n    rv = rv.xreplace({ro: ro.n(n) for ro in rv.atoms(RootOf)})\n\n    from .power import Pow\n    if not exponent:\n        reps = [(p, Pow(p.base, Dummy())) for p in rv.atoms(Pow)]\n        rv = rv.xreplace(dict(reps))\n    rv = rv.n(n)\n    if not exponent:\n        rv = rv.xreplace({d.exp: p.exp for p, d in reps})\n    else:\n        # Pow._eval_evalf special cases Integer exponents so if\n        # exponent is suppose to be handled we have to do so here\n        rv = rv.xreplace(Transform(\n            lambda x: Pow(x.base, Float(x.exp, n)),\n            lambda x: x.is_Pow and x.exp.is_Integer))\n\n    return rv.xreplace(Transform(\n        lambda x: x.func(*nfloat(x.args, n, exponent)),\n        lambda x: isinstance(x, Function) and not isinstance(x, AppliedUndef)))",
    "sympy.sympy.core.mul.as_numer_denom": "def as_numer_denom(self):\n    # don't use _from_args to rebuild the numerators and denominators\n    # as the order is not guaranteed to be the same once they have\n    # been separated from each other\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return self.func(*numers), self.func(*denoms)",
    "sympy.sympy.core.mul.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    if self == (-self):\n        return False  # e.g. zoo*x == -zoo*x\n    c = self.args[0]\n    return c.is_Number and c.is_extended_negative",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.mul.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n    (6, -sqrt(2)*(1 - sqrt(2)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    coef = S.One\n    args = []\n    for a in self.args:\n        c, p = a.as_content_primitive(radical=radical, clear=clear)\n        coef *= c\n        if p is not S.One:\n            args.append(p)\n    # don't use self._from_args here to reconstruct args\n    # since there may be identical args now that should be combined\n    # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n    return coef, self.func(*args)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers.as_numer_denom": "def as_numer_denom(self):\n    return self, S.One",
    "sympy.sympy.core.numbers.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> (S(-3)/2).as_content_primitive()\n    (3/2, -1)\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    if self:\n        if self.is_positive:\n            return self, S.One\n        return -self, S.NegativeOne\n    return S.One, self",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.polys.rootoftools import CRootOf\n    from sympy.polys import minpoly\n    measure, ratio = kwargs['measure'], kwargs['ratio']\n    for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:\n        if minpoly(self.root - r).is_Symbol:\n            # use the matching root if it's simpler\n            if measure(r) < ratio*measure(self.root):\n                return AlgebraicNumber(r)\n    return self",
    "sympy.sympy.core.numbers.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    "sympy.sympy.core.power.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return self, S.One\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    # this should be the same as ExpBase.as_numer_denom wrt\n    # exponent handling\n    neg_exp = exp.is_negative\n    if exp.is_Mul and not neg_exp and not exp.is_positive:\n        neg_exp = exp.could_extract_minus_sign()\n    int_exp = exp.is_integer\n    # the denominator cannot be separated from the numerator if\n    # its sign is unknown unless the exponent is an integer, e.g.\n    # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n    # denominator is negative the numerator and denominator can\n    # be negated and the denominator (now positive) separated.\n    if not (d.is_extended_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = -n, -d\n    elif dnonpos is None and not int_exp:\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = d, n\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return n, self.func(d, exp)\n        if n is not S.One and d is S.One:\n            return self.func(n, exp), d\n    return self.func(n, exp), self.func(d, exp)",
    "sympy.sympy.core.power.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()\n    (2, sqrt(1 + sqrt(2)))\n    >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()\n    (1, sqrt(3)*sqrt(1 + sqrt(2)))\n\n    >>> from sympy import expand_power_base, powsimp, Mul\n    >>> from sympy.abc import x, y\n\n    >>> ((2*x + 2)**2).as_content_primitive()\n    (4, (x + 1)**2)\n    >>> (4**((1 + y)/2)).as_content_primitive()\n    (2, 4**(y/2))\n    >>> (3**((1 + y)/2)).as_content_primitive()\n    (1, 3**((y + 1)/2))\n    >>> (3**((5 + y)/2)).as_content_primitive()\n    (9, 3**((y + 1)/2))\n    >>> eq = 3**(2 + 2*x)\n    >>> powsimp(eq) == eq\n    True\n    >>> eq.as_content_primitive()\n    (9, 3**(2*x))\n    >>> powsimp(Mul(*_))\n    3**(2*x + 2)\n\n    >>> eq = (2 + 2*x)**y\n    >>> s = expand_power_base(eq); s.is_Mul, s\n    (False, (2*x + 2)**y)\n    >>> eq.as_content_primitive()\n    (1, (2*(x + 1))**y)\n    >>> s = expand_power_base(_[1]); s.is_Mul, s\n    (True, 2**y*(x + 1)**y)\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    b, e = self.as_base_exp()\n    b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))\n    ce, pe = e.as_content_primitive(radical=radical, clear=clear)\n    if b.is_Rational:\n        #e\n        #= ce*pe\n        #= ce*(h + t)\n        #= ce*h + ce*t\n        #=> self\n        #= b**(ce*h)*b**(ce*t)\n        #= b**(cehp/cehq)*b**(ce*t)\n        #= b**(iceh + r/cehq)*b**(ce*t)\n        #= b**(iceh)*b**(r/cehq)*b**(ce*t)\n        #= b**(iceh)*b**(ce*t + r/cehq)\n        h, t = pe.as_coeff_Add()\n        if h.is_Rational and b != S.Zero:\n            ceh = ce*h\n            c = self.func(b, ceh)\n            r = S.Zero\n            if not c.is_Rational:\n                iceh, r = divmod(ceh.p, ceh.q)\n                c = self.func(b, iceh)\n            return c, self.func(b, _keep_coeff(ce, t + r/ce/ceh.q))\n    e = _keep_coeff(ce, pe)\n    # b**e = (h*t)**e = h**e*t**e = c*m*t**e\n    if e.is_Rational and b.is_Mul:\n        h, t = b.as_content_primitive(radical=radical, clear=clear)  # h is positive\n        c, m = self.func(h, e).as_coeff_Mul()  # so c is positive\n        m, me = m.as_base_exp()\n        if m is S.One or me == e:  # probably always true\n            # return the following, not return c, m*Pow(t, e)\n            # which would change Pow into Mul; we let SymPy\n            # decide what to do by using the unevaluated Mul, e.g\n            # should it stay as sqrt(2 + 2*sqrt(5)) or become\n            # sqrt(2)*sqrt(1 + sqrt(5))\n            return c, self.func(_keep_coeff(m, t), e)\n    return S.One, self.func(b, e)",
    "sympy.sympy.core.relational._eval_simplify": "def _eval_simplify(self, **kwargs):\n    # simplify as an equality\n    eq = Equality(*self.args)._eval_simplify(**kwargs)\n    if isinstance(eq, Equality):\n        # send back Ne with the new args\n        return self.func(*eq.args)\n    return eq.negated  # result of Ne is the negated Eq",
    "sympy.sympy.core.rules.__init__": "def __init__(self, transform, filter=lambda x: True):\n    self._transform = transform\n    self._filter = filter",
    "sympy.sympy.core.sympify.sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    \"\"\"\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n\n    Explanation\n    ===========\n\n    It will convert Python ints into instances of :class:`~.Integer`, floats\n    into instances of :class:`~.Float`, etc. It is also able to coerce\n    symbolic expressions which inherit from :class:`~.Basic`. This can be\n    useful in cooperation with SAGE.\n\n    .. warning::\n        Note that this function uses ``eval``, and thus shouldn't be used on\n        unsanitized input.\n\n    If the argument is already a type that SymPy understands, it will do\n    nothing but return that value. This can be used at the beginning of a\n    function to ensure you are working with the correct type.\n\n    Examples\n    ========\n\n    >>> from sympy import sympify\n\n    >>> sympify(2).is_integer\n    True\n    >>> sympify(2).is_real\n    True\n\n    >>> sympify(2.0).is_real\n    True\n    >>> sympify(\"2.0\").is_real\n    True\n    >>> sympify(\"2e-45\").is_real\n    True\n\n    If the expression could not be converted, a SympifyError is raised.\n\n    >>> sympify(\"x***2\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: \"could not parse 'x***2'\"\n\n    When attempting to parse non-Python syntax using ``sympify``, it raises a\n    ``SympifyError``:\n\n    >>> sympify(\"2x+1\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: Sympify of expression 'could not parse '2x+1'' failed\n\n    To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"2x+1\", transformations=\"all\")\n    2*x + 1\n\n    For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`\n\n    Locals\n    ------\n\n    The sympification happens with access to everything that is loaded\n    by ``from sympy import *``; anything used in a string that is not\n    defined by that import will be converted to a symbol. In the following,\n    the ``bitcount`` function is treated as a symbol and the ``O`` is\n    interpreted as the :class:`~.Order` object (used with series) and it raises\n    an error when used improperly:\n\n    >>> s = 'bitcount(42)'\n    >>> sympify(s)\n    bitcount(42)\n    >>> sympify(\"O(x)\")\n    O(x)\n    >>> sympify(\"O + 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: unbound method...\n\n    In order to have ``bitcount`` be recognized it can be defined in a\n    namespace dictionary and passed as locals:\n\n    >>> ns = {}\n    >>> exec('bitcount = lambda n: int(n).bit_length()', ns)\n    >>> sympify(s, locals=ns)\n    6\n\n    In order to have the ``O`` interpreted as a Symbol, identify it as such\n    in the namespace dictionary. This can be done in a variety of ways; all\n    three of the following are possibilities:\n\n    >>> from sympy import Symbol\n    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n    >>> exec('from sympy.abc import O', ns)  # method 2\n    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n    >>> sympify(\"O + 1\", locals=ns)\n    O + 1\n\n    If you want *all* single-letter and Greek-letter variables to be symbols\n    then you can use the clashing-symbols dictionaries that have been defined\n    there as private variables: ``_clash1`` (single-letter variables),\n    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n    multi-letter names that are defined in ``abc``).\n\n    >>> from sympy.abc import _clash1\n    >>> set(_clash1)  # if this fails, see issue #23903\n    {'E', 'I', 'N', 'O', 'Q', 'S'}\n    >>> sympify('I & Q', _clash1)\n    I & Q\n\n    Strict\n    ------\n\n    If the option ``strict`` is set to ``True``, only the types for which an\n    explicit conversion has been defined are converted. In the other\n    cases, a SympifyError is raised.\n\n    >>> print(sympify(None))\n    None\n    >>> sympify(None, strict=True)\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: None\n\n    .. deprecated:: 1.6\n\n       ``sympify(obj)`` automatically falls back to ``str(obj)`` when all\n       other conversion methods fail, but this is deprecated. ``strict=True``\n       will disable this deprecated behavior. See\n       :ref:`deprecated-sympify-string-fallback`.\n\n    Evaluation\n    ----------\n\n    If the option ``evaluate`` is set to ``False``, then arithmetic and\n    operators will be converted into their SymPy equivalents and the\n    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n    be denested first. This is done via an AST transformation that replaces\n    operators with their SymPy equivalents, so if an operand redefines any\n    of those operations, the redefined operators will not be used. If\n    argument a is not a string, the mathematical expression is evaluated\n    before being passed to sympify, so adding ``evaluate=False`` will still\n    return the evaluated result of expression.\n\n    >>> sympify('2**2 / 3 + 5')\n    19/3\n    >>> sympify('2**2 / 3 + 5', evaluate=False)\n    2**2/3 + 5\n    >>> sympify('4/2+7', evaluate=True)\n    9\n    >>> sympify('4/2+7', evaluate=False)\n    4/2 + 7\n    >>> sympify(4/2+7, evaluate=False)\n    9.00000000000000\n\n    Extending\n    ---------\n\n    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n    just define a ``_sympy_`` method to your class. You can do that even to\n    classes that you do not own by subclassing or adding the method at runtime.\n\n    >>> from sympy import Matrix\n    >>> class MyList1(object):\n    ...     def __iter__(self):\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    ...     def _sympy_(self): return Matrix(self)\n    >>> sympify(MyList1())\n    Matrix([\n    [1],\n    [2]])\n\n    If you do not have control over the class definition you could also use the\n    ``converter`` global dictionary. The key is the class and the value is a\n    function that takes a single argument and returns the desired SymPy\n    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n\n    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n    ...     def __iter__(self):  #     Use _sympy_!\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    >>> from sympy.core.sympify import converter\n    >>> converter[MyList2] = lambda x: Matrix(x)\n    >>> sympify(MyList2())\n    Matrix([\n    [1],\n    [2]])\n\n    Notes\n    =====\n\n    The keywords ``rational`` and ``convert_xor`` are only used\n    when the input is a string.\n\n    convert_xor\n    -----------\n\n    >>> sympify('x^y',convert_xor=True)\n    x**y\n    >>> sympify('x^y',convert_xor=False)\n    x ^ y\n\n    rational\n    --------\n\n    >>> sympify('0.1',rational=False)\n    0.1\n    >>> sympify('0.1',rational=True)\n    1/10\n\n    Sometimes autosimplification during sympification results in expressions\n    that are very different in structure than what was entered. Until such\n    autosimplification is no longer done, the ``kernS`` function might be of\n    some use. In the example below you can see how an expression reduces to\n    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n\n    >>> from sympy.core.sympify import kernS\n    >>> from sympy.abc import x\n    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n    -1\n    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n    >>> sympify(s)\n    -1\n    >>> kernS(s)\n    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n\n    Parameters\n    ==========\n\n    a :\n        - any object defined in SymPy\n        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n        - booleans, including ``None`` (will leave ``None`` unchanged)\n        - dicts, lists, sets or tuples containing any of the above\n\n    convert_xor : bool, optional\n        If true, treats ``^`` as exponentiation.\n        If False, treats ``^`` as XOR itself.\n        Used only when input is a string.\n\n    locals : any object defined in SymPy, optional\n        In order to have strings be recognized it can be imported\n        into a namespace dictionary and passed as locals.\n\n    strict : bool, optional\n        If the option strict is set to ``True``, only the types for which\n        an explicit conversion has been defined are converted. In the\n        other cases, a SympifyError is raised.\n\n    rational : bool, optional\n        If ``True``, converts floats into :class:`~.Rational`.\n        If ``False``, it lets floats remain as it is.\n        Used only when input is a string.\n\n    evaluate : bool, optional\n        If False, then arithmetic and operators will be converted into\n        their SymPy equivalents. If True the expression will be evaluated\n        and the result will be returned.\n\n    \"\"\"\n    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n    # was used for a long time we allow it to pass. However if strict=True as\n    # is the case in internal calls to _sympify then we only allow\n    # is_sympy=True.\n    #\n    # https://github.com/sympy/sympy/issues/20124\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n\n    cls = getattr(a, \"__class__\", None)\n\n    #Check if there exists a converter for any of the types in the mro\n    for superclass in getmro(cls):\n        #First check for user defined converters\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            #if none exists, check for SymPy defined converters\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    # Support for basic numpy datatypes\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals,\n                convert_xor=convert_xor, strict=strict, rational=rational,\n                evaluate=evaluate)\n\n    _sympy_ = getattr(a, \"_sympy_\", None)\n    if _sympy_ is not None:\n        return a._sympy_()\n\n    if not strict:\n        # Put numpy array conversion _before_ float/int, see\n        # <https://github.com/sympy/sympy/issues/13924>.\n        flat = getattr(a, \"flat\", None)\n        if flat is not None:\n            shape = getattr(a, \"shape\", None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                # Scalar arrays (those with zero dimensions) have sympify\n                # called on the scalar element.\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(),\n                                       locals=locals,\n                                       convert_xor=convert_xor,\n                                       strict=strict,\n                                       rational=rational,\n                                       evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        elif hasattr(a, '__float__'):\n            # float and int can coerce size-one numpy arrays to their lone\n            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n            return sympify(float(a))\n        elif hasattr(a, '__int__'):\n            return sympify(int(a))\n\n    if strict:\n        raise SympifyError(a)\n\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n                rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            # Not all iterables are rebuildable with their type.\n            pass\n\n    if not isinstance(a, str):\n        raise SympifyError('cannot sympify object of type %r' % type(a))\n\n    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n                                            standard_transformations)\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n\n    transformations = standard_transformations\n\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n\n    return expr",
    "sympy.sympy.core.traversal.bottom_up": "def bottom_up(rv, F, atoms=False, nonbasic=False):\n    \"\"\"Apply ``F`` to all expressions in an expression tree from the\n    bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n    if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n    \"\"\"\n    args = getattr(rv, 'args', None)\n    if args is not None:\n        if args:\n            args = tuple([bottom_up(a, F, atoms, nonbasic) for a in args])\n            if args != rv.args:\n                rv = rv.func(*args)\n            rv = F(rv)\n        elif atoms:\n            rv = F(rv)\n    else:\n        if nonbasic:\n            try:\n                rv = F(rv)\n            except TypeError:\n                pass\n\n    return rv",
    "sympy.sympy.functions.combinatorial.factorials._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify.combsimp import combsimp\n    # combinatorial function with non-integer arguments is\n    # automatically passed to gammasimp\n    expr = combsimp(self)\n    measure = kwargs['measure']\n    if measure(expr) <= kwargs['ratio']*measure(self):\n        return expr\n    return self",
    "sympy.sympy.functions.elementary.complexes._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self.func(factor_terms(self.args[0]))  # XXX include doit?",
    "sympy.sympy.functions.elementary.exponential.as_numer_denom": "def as_numer_denom(self):\n    \"\"\"\n    Returns this with a positive exponent as a 2-tuple (a fraction).\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.abc import x\n    >>> exp(-x).as_numer_denom()\n    (1, exp(x))\n    >>> exp(x).as_numer_denom()\n    (exp(x), 1)\n    \"\"\"\n    # this should be the same as Pow.as_numer_denom wrt\n    # exponent handling\n    if not self.is_commutative:\n        return self, S.One\n    exp = self.exp\n    neg_exp = exp.is_negative\n    if not neg_exp and not (-exp).is_negative:\n        neg_exp = exp.could_extract_minus_sign()\n    if neg_exp:\n        return S.One, self.func(-exp)\n    return self, S.One",
    "sympy.sympy.functions.elementary.exponential._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify.simplify import expand_log, simplify, inversecombine\n    if len(self.args) == 2:  # it's unevaluated\n        return simplify(self.func(*self.args), **kwargs)\n\n    expr = self.func(simplify(self.args[0], **kwargs))\n    if kwargs['inverse']:\n        expr = inversecombine(expr)\n    expr = expand_log(expr, deep=True)\n    return min([expr, self], key=kwargs['measure'])",
    "sympy.sympy.functions.elementary.piecewise.piecewise_simplify": "def piecewise_simplify(expr, **kwargs):\n    expr = piecewise_simplify_arguments(expr, **kwargs)\n    if not isinstance(expr, Piecewise):\n        return expr\n    args = list(expr.args)\n\n    args = _piecewise_simplify_eq_and(args)\n    args = _piecewise_simplify_equal_to_next_segment(args)\n    return Piecewise(*args)",
    "sympy.sympy.functions.elementary.piecewise._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self.func(*[a.simplify(**kwargs) for a in self.args])",
    "sympy.sympy.functions.elementary.piecewise.piecewise_fold": "def piecewise_fold(expr, evaluate=True):\n    \"\"\"\n    Takes an expression containing a piecewise function and returns the\n    expression in piecewise form. In addition, any ITE conditions are\n    rewritten in negation normal form and simplified.\n\n    The final Piecewise is evaluated (default) but if the raw form\n    is desired, send ``evaluate=False``; if trivial evaluation is\n    desired, send ``evaluate=None`` and duplicate conditions and\n    processing of True and False will be handled.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, piecewise_fold, S\n    >>> from sympy.abc import x\n    >>> p = Piecewise((x, x < 1), (1, S(1) <= x))\n    >>> piecewise_fold(x*p)\n    Piecewise((x**2, x < 1), (x, True))\n\n    See Also\n    ========\n\n    Piecewise\n    piecewise_exclusive\n    \"\"\"\n    if not isinstance(expr, Basic) or not expr.has(Piecewise):\n        return expr\n\n    new_args = []\n    if isinstance(expr, (ExprCondPair, Piecewise)):\n        for e, c in expr.args:\n            if not isinstance(e, Piecewise):\n                e = piecewise_fold(e)\n            # we don't keep Piecewise in condition because\n            # it has to be checked to see that it's complete\n            # and we convert it to ITE at that time\n            assert not c.has(Piecewise)  # pragma: no cover\n            if isinstance(c, ITE):\n                c = c.to_nnf()\n                c = simplify_logic(c, form='cnf')\n            if isinstance(e, Piecewise):\n                new_args.extend([(piecewise_fold(ei), And(ci, c))\n                    for ei, ci in e.args])\n            else:\n                new_args.append((e, c))\n    else:\n        # Given\n        #     P1 = Piecewise((e11, c1), (e12, c2), A)\n        #     P2 = Piecewise((e21, c1), (e22, c2), B)\n        #     ...\n        # the folding of f(P1, P2) is trivially\n        # Piecewise(\n        #   (f(e11, e21), c1),\n        #   (f(e12, e22), c2),\n        #   (f(Piecewise(A), Piecewise(B)), True))\n        # Certain objects end up rewriting themselves as thus, so\n        # we do that grouping before the more generic folding.\n        # The following applies this idea when f = Add or f = Mul\n        # (and the expression is commutative).\n        if expr.is_Add or expr.is_Mul and expr.is_commutative:\n            p, args = sift(expr.args, lambda x: x.is_Piecewise, binary=True)\n            pc = sift(p, lambda x: tuple([c for e,c in x.args]))\n            for c in list(ordered(pc)):\n                if len(pc[c]) > 1:\n                    pargs = [list(i.args) for i in pc[c]]\n                    # the first one is the same; there may be more\n                    com = common_prefix(*[\n                        [i.cond for i in j] for j in pargs])\n                    n = len(com)\n                    collected = []\n                    for i in range(n):\n                        collected.append((\n                            expr.func(*[ai[i].expr for ai in pargs]),\n                            com[i]))\n                    remains = []\n                    for a in pargs:\n                        if n == len(a):  # no more args\n                            continue\n                        if a[n].cond == True:  # no longer Piecewise\n                            remains.append(a[n].expr)\n                        else:  # restore the remaining Piecewise\n                            remains.append(\n                                Piecewise(*a[n:], evaluate=False))\n                    if remains:\n                        collected.append((expr.func(*remains), True))\n                    args.append(Piecewise(*collected, evaluate=False))\n                    continue\n                args.extend(pc[c])\n        else:\n            args = expr.args\n        # fold\n        folded = list(map(piecewise_fold, args))\n        for ec in product(*[\n                (i.args if isinstance(i, Piecewise) else\n                 [(i, true)]) for i in folded]):\n            e, c = zip(*ec)\n            new_args.append((expr.func(*e), And(*c)))\n\n    if evaluate is None:\n        # don't return duplicate conditions, otherwise don't evaluate\n        new_args = list(reversed([(e, c) for c, e in {\n            c: e for e, c in reversed(new_args)}.items()]))\n    rv = Piecewise(*new_args, evaluate=evaluate)\n    if evaluate is None and len(rv.args) == 1 and rv.args[0].cond == True:\n        return rv.args[0].expr\n    if any(s.expr.has(Piecewise) for p in rv.atoms(Piecewise) for s in p.args):\n        return piecewise_fold(rv)\n    return rv",
    "sympy.sympy.functions.special.bessel._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify.simplify import besselsimp\n    return besselsimp(self)",
    "sympy.sympy.functions.special.hyper._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify.hyperexpand import hyperexpand\n    return hyperexpand(self)",
    "sympy.sympy.integrals.integrals._eval_simplify": "def _eval_simplify(self, **kwargs):\n    expr = factor_terms(self)\n    if isinstance(expr, Integral):\n        from sympy.simplify.simplify import simplify\n        return expr.func(*[simplify(i, **kwargs) for i in expr.args])\n    return expr.simplify(**kwargs)",
    "sympy.sympy.logic.boolalg._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.core.relational import Le, Ge, Eq\n    lege = self.atoms(Le, Ge)\n    if lege:\n        reps = {i: self.func(\n            Eq(i.lhs, i.rhs), i.strict) for i in lege}\n        return self.xreplace(reps)._eval_simplify(**kwargs)\n    # standard simplify\n    rv = super()._eval_simplify(**kwargs)\n    if not isinstance(rv, Or):\n        return rv\n    patterns = _simplify_patterns_or()\n    return _apply_patternbased_simplification(rv, patterns,\n                                              kwargs['measure'], true)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.matrices.expressions.matexpr._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self",
    "sympy.sympy.matrices.matrixbase._eval_simplify": "def _eval_simplify(self, **kwargs: Any) -> Self:\n    # XXX: We can't use self.simplify here as mutable subclasses will\n    # override simplify and have it return None\n    return self.applyfunc(lambda x: x.simplify(**kwargs))",
    "sympy.sympy.physics.control.lti._eval_simplify": "def _eval_simplify(self, **kwargs):\n    \"\"\"Simplifies the transfer function matrix\"\"\"\n    simp_mat = self._expr_mat.applyfunc(lambda a: cancel(a, expand=False))\n    return _to_TFM(simp_mat, self.var, self.sampling_time)",
    "sympy.sympy.physics.units.util.quantity_simplify": "def quantity_simplify(expr, across_dimensions: bool=False, unit_system=None):\n    \"\"\"Return an equivalent expression in which prefixes are replaced\n    with numerical values and all units of a given dimension are the\n    unified in a canonical manner by default. `across_dimensions` allows\n    for units of different dimensions to be simplified together.\n\n    `unit_system` must be specified if `across_dimensions` is True.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.units.util import quantity_simplify\n    >>> from sympy.physics.units.prefixes import kilo\n    >>> from sympy.physics.units import foot, inch, joule, coulomb\n    >>> quantity_simplify(kilo*foot*inch)\n    250*foot**2/3\n    >>> quantity_simplify(foot - 6*inch)\n    foot/2\n    >>> quantity_simplify(5*joule/coulomb, across_dimensions=True, unit_system=\"SI\")\n    5*volt\n    \"\"\"\n\n    if expr.is_Atom or not expr.has(Prefix, Quantity):\n        return expr\n\n    # replace all prefixes with numerical values\n    p = expr.atoms(Prefix)\n    expr = expr.xreplace({p: p.scale_factor for p in p})\n\n    # replace all quantities of given dimension with a canonical\n    # quantity, chosen from those in the expression\n    d = sift(expr.atoms(Quantity), lambda i: i.dimension)\n    for k in d:\n        if len(d[k]) == 1:\n            continue\n        v = list(ordered(d[k]))\n        ref = v[0]/v[0].scale_factor\n        expr = expr.xreplace({vi: ref*vi.scale_factor for vi in v[1:]})\n\n    if across_dimensions:\n        # combine quantities of different dimensions into a single\n        # quantity that is equivalent to the original expression\n\n        if unit_system is None:\n            raise ValueError(\"unit_system must be specified if across_dimensions is True\")\n\n        unit_system = UnitSystem.get_unit_system(unit_system)\n        dimension_system: DimensionSystem = unit_system.get_dimension_system()\n        dim_expr = unit_system.get_dimensional_expr(expr)\n        dim_deps = dimension_system.get_dimensional_dependencies(dim_expr, mark_dimensionless=True)\n\n        target_dimension: Optional[Dimension] = None\n        for ds_dim, ds_dim_deps in dimension_system.dimensional_dependencies.items():\n            if ds_dim_deps == dim_deps:\n                target_dimension = ds_dim\n                break\n\n        if target_dimension is None:\n            # if we can't find a target dimension, we can't do anything. unsure how to handle this case.\n            return expr\n\n        target_unit = unit_system.derived_units.get(target_dimension)\n        if target_unit:\n            expr = convert_to(expr, target_unit, unit_system)\n\n    return expr",
    "sympy.sympy.polys.polytools.args": "@property\ndef args(self):\n    return (self.expr,) + self.gens",
    "sympy.sympy.polys.polytools.replace": "def replace(f, x, y=None, **_ignore):\n    # XXX this does not match Basic's signature\n    \"\"\"\n    Replace ``x`` with ``y`` in generators list.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> Poly(x**2 + 1, x).replace(x, y)\n    Poly(y**2 + 1, y, domain='ZZ')\n\n    \"\"\"\n    if y is None:\n        if f.is_univariate:\n            x, y = f.gen, x\n        else:\n            raise PolynomialError(\n                \"syntax supported only in univariate case\")\n\n    if x == y or x not in f.gens:\n        return f\n\n    if x in f.gens and y not in f.gens:\n        dom = f.get_domain()\n\n        if not dom.is_Composite or y not in dom.symbols:\n            gens = list(f.gens)\n            gens[gens.index(x)] = y\n            return f.per(f.rep, gens=gens)\n\n    raise PolynomialError(\"Cannot replace %s with %s in %s\" % (x, y, f))",
    "sympy.sympy.polys.polytools.cancel": "@public\ndef cancel(f, *gens, _signsimp=True, **args):\n    \"\"\"\n    Cancel common factors in a rational function ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import cancel, sqrt, Symbol, together\n    >>> from sympy.abc import x\n    >>> A = Symbol('A', commutative=False)\n\n    >>> cancel((2*x**2 - 2)/(x**2 - 2*x + 1))\n    (2*x + 2)/(x - 1)\n    >>> cancel((sqrt(3) + sqrt(15)*A)/(sqrt(2) + sqrt(10)*A))\n    sqrt(6)/2\n\n    Note: due to automatic distribution of Rationals, a sum divided by an integer\n    will appear as a sum. To recover a rational form use `together` on the result:\n\n    >>> cancel(x/2 + 1)\n    x/2 + 1\n    >>> together(_)\n    (x + 2)/2\n    \"\"\"\n    from sympy.simplify.simplify import signsimp\n    from sympy.polys.rings import sring\n    options.allowed_flags(args, ['polys'])\n\n    f = sympify(f)\n    if _signsimp:\n        f = signsimp(f)\n    opt = {}\n    if 'polys' in args:\n        opt['polys'] = args['polys']\n\n    if not isinstance(f, Tuple):\n        if f.is_Number or isinstance(f, Relational) or not isinstance(f, Expr):\n            return f\n        f = factor_terms(f, radical=True)\n        p, q = f.as_numer_denom()\n\n    elif len(f) == 2:\n        p, q = f\n        if isinstance(p, Poly) and isinstance(q, Poly):\n            opt['gens'] = p.gens\n            opt['domain'] = p.domain\n            opt['polys'] = opt.get('polys', True)\n        p, q = p.as_expr(), q.as_expr()\n    else:\n        raise ValueError('unexpected argument: %s' % f)\n\n    from sympy.functions.elementary.piecewise import Piecewise\n    try:\n        if f.has(Piecewise):\n            raise PolynomialError()\n        R, (F, G) = sring((p, q), *gens, **args)\n        if not R.ngens:\n            if not isinstance(f, Tuple):\n                return f.expand()\n            else:\n                return S.One, p, q\n    except PolynomialError as msg:\n        if f.is_commutative and not f.has(Piecewise):\n            raise PolynomialError(msg)\n        # Handling of noncommutative and/or piecewise expressions\n        if f.is_Add or f.is_Mul:\n            c, nc = sift(f.args, lambda x:\n                x.is_commutative is True and not x.has(Piecewise),\n                binary=True)\n            nc = [cancel(i) for i in nc]\n            return f.func(cancel(f.func(*c)), *nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                if isinstance(e, BooleanAtom) or not isinstance(e, Expr):\n                    continue\n                try:\n                    reps.append((e, cancel(e)))\n                    pot.skip()  # this was handled successfully\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n\n    c, (P, Q) = 1, F.cancel(G)\n    if opt.get('polys', False) and 'gens' not in opt:\n        opt['gens'] = R.symbols\n\n    if not isinstance(f, Tuple):\n        return c*(P.as_expr()/Q.as_expr())\n    else:\n        P, Q = P.as_expr(), Q.as_expr()\n        if not opt.get('polys', False):\n            return c, P, Q\n        else:\n            return c, Poly(P, *gens, **opt), Poly(Q, *gens, **opt)",
    "sympy.sympy.polys.rationaltools.together": "@public\ndef together(expr: Expr, deep: bool = False, fraction: bool = True) -> Expr:\n    \"\"\"\n    Denest and combine rational expressions using symbolic methods.\n\n    This function takes an expression or a container of expressions\n    and puts it (them) together by denesting and combining rational\n    subexpressions. No heroic measures are taken to minimize degree\n    of the resulting numerator and denominator. To obtain completely\n    reduced expression use :func:`~.cancel`. However, :func:`~.together`\n    can preserve as much as possible of the structure of the input\n    expression in the output (no expansion is performed).\n\n    A wide variety of objects can be put together including lists,\n    tuples, sets, relational objects, integrals and others. It is\n    also possible to transform interior of function applications,\n    by setting ``deep`` flag to ``True``.\n\n    By definition, :func:`~.together` is a complement to :func:`~.apart`,\n    so ``apart(together(expr))`` should return expr unchanged. Note\n    however, that :func:`~.together` uses only symbolic methods, so\n    it might be necessary to use :func:`~.cancel` to perform algebraic\n    simplification and minimize degree of the numerator and denominator.\n\n    Examples\n    ========\n\n    >>> from sympy import together, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> together(1/x + 1/y)\n    (x + y)/(x*y)\n    >>> together(1/x + 1/y + 1/z)\n    (x*y + x*z + y*z)/(x*y*z)\n\n    >>> together(1/(x*y) + 1/y**2)\n    (x + y)/(x*y**2)\n\n    >>> together(1/(1 + 1/x) + 1/(1 + 1/y))\n    (x*(y + 1) + y*(x + 1))/((x + 1)*(y + 1))\n\n    >>> together(exp(1/x + 1/y))\n    exp(1/y + 1/x)\n    >>> together(exp(1/x + 1/y), deep=True)\n    exp((x + y)/(x*y))\n\n    >>> together(1/exp(x) + 1/(x*exp(x)))\n    (x + 1)*exp(-x)/x\n\n    >>> together(1/exp(2*x) + 1/(x*exp(3*x)))\n    (x*exp(x) + 1)*exp(-3*x)/x\n\n    \"\"\"\n    def _together(expr):\n        if isinstance(expr, Basic):\n            if expr.is_Atom or (expr.is_Function and not deep):\n                return expr\n            elif expr.is_Add:\n                return gcd_terms(list(map(_together, Add.make_args(expr))), fraction=fraction)\n            elif expr.is_Pow:\n                base = _together(expr.base)\n\n                if deep:\n                    exp = _together(expr.exp)\n                else:\n                    exp = expr.exp\n\n                return expr.func(base, exp)\n            else:\n                return expr.func(*[ _together(arg) for arg in expr.args ])\n        elif iterable(expr):\n            return expr.__class__([ _together(ex) for ex in expr ])\n\n        return expr\n\n    return _together(sympify(expr))",
    "sympy.sympy.sets.sets.args": "@property\ndef args(self):\n    return self._args",
    "sympy.sympy.sets.sets._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify import simplify\n    return FiniteSet(*[simplify(elem, **kwargs) for elem in self])",
    "sympy.sympy.simplify.combsimp.combsimp": "@timethis('combsimp')\ndef combsimp(expr):\n    r\"\"\"\n    Simplify combinatorial expressions.\n\n    Explanation\n    ===========\n\n    This function takes as input an expression containing factorials,\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\n    and tries to minimize the number of those functions and reduce\n    the size of their arguments.\n\n    The algorithm works by rewriting all combinatorial functions as\n    gamma functions and applying gammasimp() except simplification\n    steps that may make an integer argument non-integer. See docstring\n    of gammasimp for more information.\n\n    Then it rewrites expression in terms of factorials and binomials by\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\n    binomials.\n\n    If expression has gamma functions or combinatorial functions\n    with non-integer argument, it is automatically passed to gammasimp.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify import combsimp\n    >>> from sympy import factorial, binomial, symbols\n    >>> n, k = symbols('n k', integer = True)\n\n    >>> combsimp(factorial(n)/factorial(n - 3))\n    n*(n - 2)*(n - 1)\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n    (n + 1)/(k + 1)\n\n    \"\"\"\n\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any(isinstance(node, gamma) and not node.args[0].is_integer\n        for node in preorder_traversal(expr)):\n        return gammasimp(expr)\n\n    expr = _gammasimp(expr, as_comb = True)\n    expr = _gamma_as_comb(expr)\n    return expr",
    "sympy.sympy.simplify.hyperexpand.hyperexpand": "def hyperexpand(f, allow_hyper=False, rewrite='default', place=None):\n    \"\"\"\n    Expand hypergeometric functions. If allow_hyper is True, allow partial\n    simplification (that is a result different from input,\n    but still containing hypergeometric functions).\n\n    If a G-function has expansions both at zero and at infinity,\n    ``place`` can be set to ``0`` or ``zoo`` to indicate the\n    preferred choice.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.hyperexpand import hyperexpand\n    >>> from sympy.functions import hyper\n    >>> from sympy.abc import z\n    >>> hyperexpand(hyper([], [], z))\n    exp(z)\n\n    Non-hyperegeometric parts of the expression and hypergeometric expressions\n    that are not recognised are left unchanged:\n\n    >>> hyperexpand(1 + hyper([1, 1, 1], [], z))\n    hyper((1, 1, 1), (), z) + 1\n    \"\"\"\n    f = sympify(f)\n\n    def do_replace(ap, bq, z):\n        r = _hyperexpand(Hyper_Function(ap, bq), z, rewrite=rewrite)\n        if r is None:\n            return hyper(ap, bq, z)\n        else:\n            return r\n\n    def do_meijer(ap, bq, z):\n        r = _meijergexpand(G_Function(ap[0], ap[1], bq[0], bq[1]), z,\n                   allow_hyper, rewrite=rewrite, place=place)\n        if not r.has(nan, zoo, oo, -oo):\n            return r\n    return f.replace(hyper, do_replace).replace(meijerg, do_meijer)",
    "sympy.sympy.simplify.powsimp.powsimp": "def powsimp(expr, deep=False, combine='all', force=False, measure=count_ops):\n    \"\"\"\n    Reduce expression by combining powers with similar bases and exponents.\n\n    Explanation\n    ===========\n\n    If ``deep`` is ``True`` then powsimp() will also simplify arguments of\n    functions. By default ``deep`` is set to ``False``.\n\n    If ``force`` is ``True`` then bases will be combined without checking for\n    assumptions, e.g. sqrt(x)*sqrt(y) -> sqrt(x*y) which is not true\n    if x and y are both negative.\n\n    You can make powsimp() only combine bases or only combine exponents by\n    changing combine='base' or combine='exp'.  By default, combine='all',\n    which does both.  combine='base' will only combine::\n\n         a   a          a                          2x      x\n        x * y  =>  (x*y)   as well as things like 2   =>  4\n\n    and combine='exp' will only combine\n    ::\n\n         a   b      (a + b)\n        x * x  =>  x\n\n    combine='exp' will strictly only combine exponents in the way that used\n    to be automatic.  Also use deep=True if you need the old behavior.\n\n    When combine='all', 'exp' is evaluated first.  Consider the first\n    example below for when there could be an ambiguity relating to this.\n    This is done so things like the second example can be completely\n    combined.  If you want 'base' combined first, do something like\n    powsimp(powsimp(expr, combine='base'), combine='exp').\n\n    Examples\n    ========\n\n    >>> from sympy import powsimp, exp, log, symbols\n    >>> from sympy.abc import x, y, z, n\n    >>> powsimp(x**y*x**z*y**z, combine='all')\n    x**(y + z)*y**z\n    >>> powsimp(x**y*x**z*y**z, combine='exp')\n    x**(y + z)*y**z\n    >>> powsimp(x**y*x**z*y**z, combine='base', force=True)\n    x**y*(x*y)**z\n\n    >>> powsimp(x**z*x**y*n**z*n**y, combine='all', force=True)\n    (n*x)**(y + z)\n    >>> powsimp(x**z*x**y*n**z*n**y, combine='exp')\n    n**(y + z)*x**(y + z)\n    >>> powsimp(x**z*x**y*n**z*n**y, combine='base', force=True)\n    (n*x)**y*(n*x)**z\n\n    >>> x, y = symbols('x y', positive=True)\n    >>> powsimp(log(exp(x)*exp(y)))\n    log(exp(x)*exp(y))\n    >>> powsimp(log(exp(x)*exp(y)), deep=True)\n    x + y\n\n    Radicals with Mul bases will be combined if combine='exp'\n\n    >>> from sympy import sqrt\n    >>> x, y = symbols('x y')\n\n    Two radicals are automatically joined through Mul:\n\n    >>> a=sqrt(x*sqrt(y))\n    >>> a*a**3 == a**4\n    True\n\n    But if an integer power of that radical has been\n    autoexpanded then Mul does not join the resulting factors:\n\n    >>> a**4 # auto expands to a Mul, no longer a Pow\n    x**2*y\n    >>> _*a # so Mul doesn't combine them\n    x**2*y*sqrt(x*sqrt(y))\n    >>> powsimp(_) # but powsimp will\n    (x*sqrt(y))**(5/2)\n    >>> powsimp(x*y*a) # but won't when doing so would violate assumptions\n    x*y*sqrt(x*sqrt(y))\n\n    \"\"\"\n    def recurse(arg, **kwargs):\n        _deep = kwargs.get('deep', deep)\n        _combine = kwargs.get('combine', combine)\n        _force = kwargs.get('force', force)\n        _measure = kwargs.get('measure', measure)\n        return powsimp(arg, _deep, _combine, _force, _measure)\n\n    expr = sympify(expr)\n\n    if (not isinstance(expr, Basic) or isinstance(expr, MatrixSymbol) or (\n            expr.is_Atom or expr in (exp_polar(0), exp_polar(1)))):\n        return expr\n\n    if deep or expr.is_Add or expr.is_Mul and _y not in expr.args:\n        expr = expr.func(*[recurse(w) for w in expr.args])\n\n    if expr.is_Pow:\n        return recurse(expr*_y, deep=False)/_y\n\n    if not expr.is_Mul:\n        return expr\n\n    # handle the Mul\n    if combine in ('exp', 'all'):\n        # Collect base/exp data, while maintaining order in the\n        # non-commutative parts of the product\n        c_powers = defaultdict(list)\n        nc_part = []\n        newexpr = []\n        coeff = S.One\n        for term in expr.args:\n            if term.is_Rational:\n                coeff *= term\n                continue\n            if term.is_Pow:\n                term = _denest_pow(term)\n            if term.is_commutative:\n                b, e = term.as_base_exp()\n                if deep:\n                    b, e = [recurse(i) for i in [b, e]]\n                if b.is_Pow or isinstance(b, exp):\n                    # don't let smthg like sqrt(x**a) split into x**a, 1/2\n                    # or else it will be joined as x**(a/2) later\n                    b, e = b**e, S.One\n                c_powers[b].append(e)\n            else:\n                # This is the logic that combines exponents for equal,\n                # but non-commutative bases: A**x*A**y == A**(x+y).\n                if nc_part:\n                    b1, e1 = nc_part[-1].as_base_exp()\n                    b2, e2 = term.as_base_exp()\n                    if (b1 == b2 and\n                            e1.is_commutative and e2.is_commutative):\n                        nc_part[-1] = Pow(b1, Add(e1, e2))\n                        continue\n                nc_part.append(term)\n\n        # add up exponents of common bases\n        for b, e in ordered(iter(c_powers.items())):\n            # allow 2**x/4 -> 2**(x - 2); don't do this when b and e are\n            # Numbers since autoevaluation will undo it, e.g.\n            # 2**(1/3)/4 -> 2**(1/3 - 2) -> 2**(1/3)/4\n            if (b and b.is_Rational and not all(ei.is_Number for ei in e) and \\\n                    coeff is not S.One and\n                    b not in (S.One, S.NegativeOne)):\n                m = multiplicity(abs(b), abs(coeff))\n                if m:\n                    e.append(m)\n                    coeff /= b**m\n            c_powers[b] = Add(*e)\n        if coeff is not S.One:\n            if coeff in c_powers:\n                c_powers[coeff] += S.One\n            else:\n                c_powers[coeff] = S.One\n\n        # convert to plain dictionary\n        c_powers = dict(c_powers)\n\n        # check for base and inverted base pairs\n        be = list(c_powers.items())\n        skip = set()  # skip if we already saw them\n        for b, e in be:\n            if b in skip:\n                continue\n            bpos = b.is_positive or b.is_polar\n            if bpos:\n                binv = 1/b\n                #Special case for float 1\n                if b.is_Float and equal_valued(b, 1):\n                    c_powers[b] = S.One\n                    continue\n                if b != binv and binv in c_powers:\n                    if b.as_numer_denom()[0] is S.One:\n                        c_powers.pop(b)\n                        c_powers[binv] -= e\n                    else:\n                        skip.add(binv)\n                        e = c_powers.pop(binv)\n                        c_powers[b] -= e\n\n        # check for base and negated base pairs\n        be = list(c_powers.items())\n        _n = S.NegativeOne\n        for b, e in be:\n            if (b.is_Symbol or b.is_Add) and -b in c_powers and b in c_powers:\n                if (b.is_positive is not None or e.is_integer):\n                    if e.is_integer or b.is_negative:\n                        c_powers[-b] += c_powers.pop(b)\n                    else:  # (-b).is_positive so use its e\n                        e = c_powers.pop(-b)\n                        c_powers[b] += e\n                    if _n in c_powers:\n                        c_powers[_n] += e\n                    else:\n                        c_powers[_n] = e\n\n        # filter c_powers and convert to a list\n        c_powers = [(b, e) for b, e in c_powers.items() if e]\n\n        # ==============================================================\n        # check for Mul bases of Rational powers that can be combined with\n        # separated bases, e.g. x*sqrt(x*y)*sqrt(x*sqrt(x*y)) ->\n        # (x*sqrt(x*y))**(3/2)\n        # ---------------- helper functions\n\n        def ratq(x):\n            '''Return Rational part of x's exponent as it appears in the bkey.\n            '''\n            return bkey(x)[0][1]\n\n        def bkey(b, e=None):\n            '''Return (b**s, c.q), c.p where e -> c*s. If e is not given then\n            it will be taken by using as_base_exp() on the input b.\n            e.g.\n                x**3/2 -> (x, 2), 3\n                x**y -> (x**y, 1), 1\n                x**(2*y/3) -> (x**y, 3), 2\n                exp(x/2) -> (exp(a), 2), 1\n\n            '''\n            if e is not None:  # coming from c_powers or from below\n                if e.is_Integer:\n                    return (b, S.One), e\n                elif e.is_Rational:\n                    return (b, Integer(e.q)), Integer(e.p)\n                else:\n                    c, m = e.as_coeff_Mul(rational=True)\n                    if c is not S.One:\n                        if m.is_integer:\n                            return (b, Integer(c.q)), m*Integer(c.p)\n                        return (b**m, Integer(c.q)), Integer(c.p)\n                    else:\n                        return (b**e, S.One), S.One\n            else:\n                return bkey(*b.as_base_exp())\n\n        def update(b):\n            '''Decide what to do with base, b. If its exponent is now an\n            integer multiple of the Rational denominator, then remove it\n            and put the factors of its base in the common_b dictionary or\n            update the existing bases if necessary. If it has been zeroed\n            out, simply remove the base.\n            '''\n            newe, r = divmod(common_b[b], b[1])\n            if not r:\n                common_b.pop(b)\n                if newe:\n                    for m in Mul.make_args(b[0]**newe):\n                        b, e = bkey(m)\n                        if b not in common_b:\n                            common_b[b] = 0\n                        common_b[b] += e\n                        if b[1] != 1:\n                            bases.append(b)\n        # ---------------- end of helper functions\n\n        # assemble a dictionary of the factors having a Rational power\n        common_b = {}\n        done = []\n        bases = []\n        for b, e in c_powers:\n            b, e = bkey(b, e)\n            if b in common_b:\n                common_b[b] = common_b[b] + e\n            else:\n                common_b[b] = e\n            if b[1] != 1 and b[0].is_Mul:\n                bases.append(b)\n        bases.sort(key=default_sort_key)  # this makes tie-breaking canonical\n        bases.sort(key=measure, reverse=True)  # handle longest first\n        for base in bases:\n            if base not in common_b:  # it may have been removed already\n                continue\n            b, exponent = base\n            last = False  # True when no factor of base is a radical\n            qlcm = 1  # the lcm of the radical denominators\n            while True:\n                bstart = b\n                qstart = qlcm\n\n                bb = []  # list of factors\n                ee = []  # (factor's expo. and it's current value in common_b)\n                for bi in Mul.make_args(b):\n                    bib, bie = bkey(bi)\n                    if bib not in common_b or common_b[bib] < bie:\n                        ee = bb = []  # failed\n                        break\n                    ee.append([bie, common_b[bib]])\n                    bb.append(bib)\n                if ee:\n                    # find the number of integral extractions possible\n                    # e.g. [(1, 2), (2, 2)] -> min(2/1, 2/2) -> 1\n                    min1 = ee[0][1]//ee[0][0]\n                    for i in range(1, len(ee)):\n                        rat = ee[i][1]//ee[i][0]\n                        if rat < 1:\n                            break\n                        min1 = min(min1, rat)\n                    else:\n                        # update base factor counts\n                        # e.g. if ee = [(2, 5), (3, 6)] then min1 = 2\n                        # and the new base counts will be 5-2*2 and 6-2*3\n                        for i in range(len(bb)):\n                            common_b[bb[i]] -= min1*ee[i][0]\n                            update(bb[i])\n                        # update the count of the base\n                        # e.g. x**2*y*sqrt(x*sqrt(y)) the count of x*sqrt(y)\n                        # will increase by 4 to give bkey (x*sqrt(y), 2, 5)\n                        common_b[base] += min1*qstart*exponent\n                if (last  # no more radicals in base\n                    or len(common_b) == 1  # nothing left to join with\n                    or all(k[1] == 1 for k in common_b)  # no rad's in common_b\n                        ):\n                    break\n                # see what we can exponentiate base by to remove any radicals\n                # so we know what to search for\n                # e.g. if base were x**(1/2)*y**(1/3) then we should\n                # exponentiate by 6 and look for powers of x and y in the ratio\n                # of 2 to 3\n                qlcm = lcm([ratq(bi) for bi in Mul.make_args(bstart)])\n                if qlcm == 1:\n                    break  # we are done\n                b = bstart**qlcm\n                qlcm *= qstart\n                if all(ratq(bi) == 1 for bi in Mul.make_args(b)):\n                    last = True  # we are going to be done after this next pass\n            # this base no longer can find anything to join with and\n            # since it was longer than any other we are done with it\n            b, q = base\n            done.append((b, common_b.pop(base)*Rational(1, q)))\n\n        # update c_powers and get ready to continue with powsimp\n        c_powers = done\n        # there may be terms still in common_b that were bases that were\n        # identified as needing processing, so remove those, too\n        for (b, q), e in common_b.items():\n            if (b.is_Pow or isinstance(b, exp)) and \\\n                    q is not S.One and not b.exp.is_Rational:\n                b, be = b.as_base_exp()\n                b = b**(be/q)\n            else:\n                b = root(b, q)\n            c_powers.append((b, e))\n        check = len(c_powers)\n        c_powers = dict(c_powers)\n        assert len(c_powers) == check  # there should have been no duplicates\n        # ==============================================================\n\n        # rebuild the expression\n        newexpr = expr.func(*(newexpr + [Pow(b, e) for b, e in c_powers.items()]))\n        if combine == 'exp':\n            return expr.func(newexpr, expr.func(*nc_part))\n        else:\n            return recurse(expr.func(*nc_part), combine='base') * \\\n                recurse(newexpr, combine='base')\n\n    elif combine == 'base':\n\n        # Build c_powers and nc_part.  These must both be lists not\n        # dicts because exp's are not combined.\n        c_powers = []\n        nc_part = []\n        for term in expr.args:\n            if term.is_commutative:\n                c_powers.append(list(term.as_base_exp()))\n            else:\n                nc_part.append(term)\n\n        # Pull out numerical coefficients from exponent if assumptions allow\n        # e.g., 2**(2*x) => 4**x\n        for i in range(len(c_powers)):\n            b, e = c_powers[i]\n            if not (all(x.is_nonnegative for x in b.as_numer_denom()) or e.is_integer or force or b.is_polar):\n                continue\n            exp_c, exp_t = e.as_coeff_Mul(rational=True)\n            if exp_c is not S.One and exp_t is not S.One:\n                c_powers[i] = [Pow(b, exp_c), exp_t]\n\n        # Combine bases whenever they have the same exponent and\n        # assumptions allow\n        # first gather the potential bases under the common exponent\n        c_exp = defaultdict(list)\n        for b, e in c_powers:\n            if deep:\n                e = recurse(e)\n            if e.is_Add and (b.is_positive or e.is_integer):\n                e = factor_terms(e)\n                if _coeff_isneg(e):\n                    e = -e\n                    b = 1/b\n            c_exp[e].append(b)\n        del c_powers\n\n        # Merge back in the results of the above to form a new product\n        c_powers = defaultdict(list)\n        for e in c_exp:\n            bases = c_exp[e]\n\n            # calculate the new base for e\n\n            if len(bases) == 1:\n                new_base = bases[0]\n            elif e.is_integer or force:\n                new_base = expr.func(*bases)\n            else:\n                # see which ones can be joined\n                unk = []\n                nonneg = []\n                neg = []\n                for bi in bases:\n                    if bi.is_negative:\n                        neg.append(bi)\n                    elif bi.is_nonnegative:\n                        nonneg.append(bi)\n                    elif bi.is_polar:\n                        nonneg.append(\n                            bi)  # polar can be treated like non-negative\n                    else:\n                        unk.append(bi)\n                if len(unk) == 1 and not neg or len(neg) == 1 and not unk:\n                    # a single neg or a single unk can join the rest\n                    nonneg.extend(unk + neg)\n                    unk = neg = []\n                elif neg:\n                    # their negative signs cancel in groups of 2*q if we know\n                    # that e = p/q else we have to treat them as unknown\n                    israt = False\n                    if e.is_Rational:\n                        israt = True\n                    else:\n                        p, d = e.as_numer_denom()\n                        if p.is_integer and d.is_integer:\n                            israt = True\n                    if israt:\n                        neg = [-w for w in neg]\n                        unk.extend([S.NegativeOne]*len(neg))\n                    else:\n                        unk.extend(neg)\n                        neg = []\n                    del israt\n\n                # these shouldn't be joined\n                for b in unk:\n                    c_powers[b].append(e)\n                # here is a new joined base\n                new_base = expr.func(*(nonneg + neg))\n                # if there are positive parts they will just get separated\n                # again unless some change is made\n\n                def _terms(e):\n                    # return the number of terms of this expression\n                    # when multiplied out -- assuming no joining of terms\n                    if e.is_Add:\n                        return sum(_terms(ai) for ai in e.args)\n                    if e.is_Mul:\n                        return prod([_terms(mi) for mi in e.args])\n                    return 1\n                xnew_base = expand_mul(new_base, deep=False)\n                if len(Add.make_args(xnew_base)) < _terms(new_base):\n                    new_base = factor_terms(xnew_base)\n\n            c_powers[new_base].append(e)\n\n        # break out the powers from c_powers now\n        c_part = [Pow(b, ei) for b, e in c_powers.items() for ei in e]\n\n        # we're done\n        return expr.func(*(c_part + nc_part))\n\n    else:\n        raise ValueError(\"combine must be one of ('all', 'exp', 'base').\")",
    "sympy.sympy.simplify.radsimp.fraction": "def fraction(expr, exact=False):\n    \"\"\"Returns a pair with expression's numerator and denominator.\n       If the given expression is not a fraction then this function\n       will return the tuple (expr, 1).\n\n       This function will not make any attempt to simplify nested\n       fractions or to do any term rewriting at all.\n\n       If only one of the numerator/denominator pair is needed then\n       use numer(expr) or denom(expr) functions respectively.\n\n       >>> from sympy import fraction, Rational, Symbol\n       >>> from sympy.abc import x, y\n\n       >>> fraction(x/y)\n       (x, y)\n       >>> fraction(x)\n       (x, 1)\n\n       >>> fraction(1/y**2)\n       (1, y**2)\n\n       >>> fraction(x*y/2)\n       (x*y, 2)\n       >>> fraction(Rational(1, 2))\n       (1, 2)\n\n       This function will also work fine with assumptions:\n\n       >>> k = Symbol('k', negative=True)\n       >>> fraction(x * y**k)\n       (x, y**(-k))\n\n       If we know nothing about sign of some exponent and ``exact``\n       flag is unset, then the exponent's structure will\n       be analyzed and pretty fraction will be returned:\n\n       >>> from sympy import exp, Mul\n       >>> fraction(2*x**(-y))\n       (2, x**y)\n\n       >>> fraction(exp(-x))\n       (1, exp(x))\n\n       >>> fraction(exp(-x), exact=True)\n       (exp(-x), 1)\n\n       The ``exact`` flag will also keep any unevaluated Muls from\n       being evaluated:\n\n       >>> u = Mul(2, x + 1, evaluate=False)\n       >>> fraction(u)\n       (2*x + 2, 1)\n       >>> fraction(u, exact=True)\n       (2*(x  + 1), 1)\n    \"\"\"\n    expr = sympify(expr)\n\n    numer, denom = [], []\n\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()  # this will cause evaluation\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and not term.is_Integer:\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact)",
    "sympy.sympy.simplify.radsimp.collect_abs": "def collect_abs(expr):\n    \"\"\"Return ``expr`` with arguments of multiple Abs in a term collected\n    under a single instance.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.radsimp import collect_abs\n    >>> from sympy.abc import x\n    >>> collect_abs(abs(x + 1)/abs(x**2 - 1))\n    Abs((x + 1)/(x**2 - 1))\n    >>> collect_abs(abs(1/x))\n    Abs(1/x)\n    \"\"\"\n    def _abs(mul):\n        c, nc = mul.args_cnc()\n        a = []\n        o = []\n        for i in c:\n            if isinstance(i, Abs):\n                a.append(i.args[0])\n            elif isinstance(i, Pow) and isinstance(i.base, Abs) and i.exp.is_real:\n                a.append(i.base.args[0]**i.exp)\n            else:\n                o.append(i)\n        if len(a) < 2 and not any(i.exp.is_negative for i in a if isinstance(i, Pow)):\n            return mul\n        absarg = Mul(*a)\n        A = Abs(absarg)\n        args = [A]\n        args.extend(o)\n        if not A.has(Abs):\n            args.extend(nc)\n            return Mul(*args)\n        if not isinstance(A, Abs):\n            # reevaluate and make it unevaluated\n            A = Abs(absarg, evaluate=False)\n        args[0] = A\n        _mulsort(args)\n        args.extend(nc)  # nc always go last\n        return Mul._from_args(args, is_commutative=not nc)\n\n    return expr.replace(\n        lambda x: isinstance(x, Mul),\n        lambda x: _abs(x)).replace(\n            lambda x: isinstance(x, Pow),\n            lambda x: _abs(x))",
    "sympy.sympy.simplify.radsimp.radsimp": "def radsimp(expr, symbolic=True, max_terms=4):\n    r\"\"\"\n    Rationalize the denominator by removing square roots.\n\n    Explanation\n    ===========\n\n    The expression returned from radsimp must be used with caution\n    since if the denominator contains symbols, it will be possible to make\n    substitutions that violate the assumptions of the simplification process:\n    that for a denominator matching a + b*sqrt(c), a != +/-b*sqrt(c). (If\n    there are no symbols, this assumptions is made valid by collecting terms\n    of sqrt(c) so the match variable ``a`` does not contain ``sqrt(c)``.) If\n    you do not want the simplification to occur for symbolic denominators, set\n    ``symbolic`` to False.\n\n    If there are more than ``max_terms`` radical terms then the expression is\n    returned unchanged.\n\n    Examples\n    ========\n\n    >>> from sympy import radsimp, sqrt, Symbol, pprint\n    >>> from sympy import factor_terms, fraction, signsimp\n    >>> from sympy.simplify.radsimp import collect_sqrt\n    >>> from sympy.abc import a, b, c\n\n    >>> radsimp(1/(2 + sqrt(2)))\n    (2 - sqrt(2))/2\n    >>> x,y = map(Symbol, 'xy')\n    >>> e = ((2 + 2*sqrt(2))*x + (2 + sqrt(8))*y)/(2 + sqrt(2))\n    >>> radsimp(e)\n    sqrt(2)*(x + y)\n\n    No simplification beyond removal of the gcd is done. One might\n    want to polish the result a little, however, by collecting\n    square root terms:\n\n    >>> r2 = sqrt(2)\n    >>> r5 = sqrt(5)\n    >>> ans = radsimp(1/(y*r2 + x*r2 + a*r5 + b*r5)); pprint(ans)\n        ___       ___       ___       ___\n      \\/ 5 *a + \\/ 5 *b - \\/ 2 *x - \\/ 2 *y\n    ------------------------------------------\n       2               2      2              2\n    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y\n\n    >>> n, d = fraction(ans)\n    >>> pprint(factor_terms(signsimp(collect_sqrt(n))/d, radical=True))\n            ___             ___\n          \\/ 5 *(a + b) - \\/ 2 *(x + y)\n    ------------------------------------------\n       2               2      2              2\n    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y\n\n    If radicals in the denominator cannot be removed or there is no denominator,\n    the original expression will be returned.\n\n    >>> radsimp(sqrt(2)*x + sqrt(2))\n    sqrt(2)*x + sqrt(2)\n\n    Results with symbols will not always be valid for all substitutions:\n\n    >>> eq = 1/(a + b*sqrt(c))\n    >>> eq.subs(a, b*sqrt(c))\n    1/(2*b*sqrt(c))\n    >>> radsimp(eq).subs(a, b*sqrt(c))\n    nan\n\n    If ``symbolic=False``, symbolic denominators will not be transformed (but\n    numeric denominators will still be processed):\n\n    >>> radsimp(eq, symbolic=False)\n    1/(a + b*sqrt(c))\n\n    \"\"\"\n    from sympy.core.expr import Expr\n    from sympy.simplify.simplify import signsimp\n\n    syms = symbols(\"a:d A:D\")\n    def _num(rterms):\n        # return the multiplier that will simplify the expression described\n        # by rterms [(sqrt arg, coeff), ... ]\n        a, b, c, d, A, B, C, D = syms\n        if len(rterms) == 2:\n            reps = dict(list(zip([A, a, B, b], [j for i in rterms for j in i])))\n            return (\n            sqrt(A)*a - sqrt(B)*b).xreplace(reps)\n        if len(rterms) == 3:\n            reps = dict(list(zip([A, a, B, b, C, c], [j for i in rterms for j in i])))\n            return (\n            (sqrt(A)*a + sqrt(B)*b - sqrt(C)*c)*(2*sqrt(A)*sqrt(B)*a*b - A*a**2 -\n            B*b**2 + C*c**2)).xreplace(reps)\n        elif len(rterms) == 4:\n            reps = dict(list(zip([A, a, B, b, C, c, D, d], [j for i in rterms for j in i])))\n            return ((sqrt(A)*a + sqrt(B)*b - sqrt(C)*c - sqrt(D)*d)*(2*sqrt(A)*sqrt(B)*a*b\n                - A*a**2 - B*b**2 - 2*sqrt(C)*sqrt(D)*c*d + C*c**2 +\n                D*d**2)*(-8*sqrt(A)*sqrt(B)*sqrt(C)*sqrt(D)*a*b*c*d + A**2*a**4 -\n                2*A*B*a**2*b**2 - 2*A*C*a**2*c**2 - 2*A*D*a**2*d**2 + B**2*b**4 -\n                2*B*C*b**2*c**2 - 2*B*D*b**2*d**2 + C**2*c**4 - 2*C*D*c**2*d**2 +\n                D**2*d**4)).xreplace(reps)\n        elif len(rterms) == 1:\n            return sqrt(rterms[0][0])\n        else:\n            raise NotImplementedError\n\n    def ispow2(d, log2=False):\n        if not d.is_Pow:\n            return False\n        e = d.exp\n        if e.is_Rational and e.q == 2 or symbolic and denom(e) == 2:\n            return True\n        if log2:\n            q = 1\n            if e.is_Rational:\n                q = e.q\n            elif symbolic:\n                d = denom(e)\n                if d.is_Integer:\n                    q = d\n            if q != 1 and log(q, 2).is_Integer:\n                return True\n        return False\n\n    def handle(expr):\n        # Handle first reduces to the case\n        # expr = 1/d, where d is an add, or d is base**p/2.\n        # We do this by recursively calling handle on each piece.\n        from sympy.simplify.simplify import nsimplify\n\n        if expr.is_Atom:\n            return expr\n        elif not isinstance(expr, Expr):\n            return expr.func(*[handle(a) for a in expr.args])\n\n        n, d = fraction(expr)\n\n        if d.is_Atom and n.is_Atom:\n            return expr\n        elif not n.is_Atom:\n            n = n.func(*[handle(a) for a in n.args])\n            return _unevaluated_Mul(n, handle(1/d))\n        elif n is not S.One:\n            return _unevaluated_Mul(n, handle(1/d))\n        elif d.is_Mul:\n            return _unevaluated_Mul(*[handle(1/d) for d in d.args])\n\n        # By this step, expr is 1/d, and d is not a mul.\n        if not symbolic and d.free_symbols:\n            return expr\n\n        if ispow2(d):\n            d2 = sqrtdenest(sqrt(d.base))**numer(d.exp)\n            if d2 != d:\n                return handle(1/d2)\n        elif d.is_Pow and (d.exp.is_integer or d.base.is_positive):\n            # (1/d**i) = (1/d)**i\n            return handle(1/d.base)**d.exp\n\n        if not (d.is_Add or ispow2(d)):\n            return 1/d.func(*[handle(a) for a in d.args])\n\n        # handle 1/d treating d as an Add (though it may not be)\n\n        keep = True  # keep changes that are made\n\n        # flatten it and collect radicals after checking for special\n        # conditions\n        d = _mexpand(d)\n\n        # did it change?\n        if d.is_Atom:\n            return 1/d\n\n        # is it a number that might be handled easily?\n        if d.is_number:\n            _d = nsimplify(d)\n            if _d.is_Number and _d.equals(d):\n                return 1/_d\n\n        while True:\n            # collect similar terms\n            collected = defaultdict(list)\n            for m in Add.make_args(d):  # d might have become non-Add\n                p2 = []\n                other = []\n                for i in Mul.make_args(m):\n                    if ispow2(i, log2=True):\n                        p2.append(i.base if i.exp is S.Half else i.base**(2*i.exp))\n                    elif i is S.ImaginaryUnit:\n                        p2.append(S.NegativeOne)\n                    else:\n                        other.append(i)\n                collected[tuple(ordered(p2))].append(Mul(*other))\n            rterms = list(ordered(list(collected.items())))\n            rterms = [(Mul(*i), Add(*j)) for i, j in rterms]\n            nrad = len(rterms) - (1 if rterms[0][0] is S.One else 0)\n            if nrad < 1:\n                break\n            elif nrad > max_terms:\n                # there may have been invalid operations leading to this point\n                # so don't keep changes, e.g. this expression is troublesome\n                # in collecting terms so as not to raise the issue of 2834:\n                # r = sqrt(sqrt(5) + 5)\n                # eq = 1/(sqrt(5)*r + 2*sqrt(5)*sqrt(-sqrt(5) + 5) + 5*r)\n                keep = False\n                break\n            if len(rterms) > 4:\n                # in general, only 4 terms can be removed with repeated squaring\n                # but other considerations can guide selection of radical terms\n                # so that radicals are removed\n                if all(x.is_Integer and (y**2).is_Rational for x, y in rterms):\n                    nd, d = rad_rationalize(S.One, Add._from_args(\n                        [sqrt(x)*y for x, y in rterms]))\n                    n *= nd\n                else:\n                    # is there anything else that might be attempted?\n                    keep = False\n                break\n            from sympy.simplify.powsimp import powsimp, powdenest\n\n            num = powsimp(_num(rterms))\n            n *= num\n            d *= num\n            d = powdenest(_mexpand(d), force=symbolic)\n            if d.has(S.Zero, nan, zoo):\n                return expr\n            if d.is_Atom:\n                break\n\n        if not keep:\n            return expr\n        return _unevaluated_Mul(n, 1/d)\n\n    if not isinstance(expr, Expr):\n        return expr.func(*[radsimp(a, symbolic=symbolic, max_terms=max_terms) for a in expr.args])\n\n    coeff, expr = expr.as_coeff_Add()\n    expr = expr.normal()\n    old = fraction(expr)\n    n, d = fraction(handle(expr))\n    if old != (n, d):\n        if not d.is_Atom:\n            was = (n, d)\n            n = signsimp(n, evaluate=False)\n            d = signsimp(d, evaluate=False)\n            u = Factors(_unevaluated_Mul(n, 1/d))\n            u = _unevaluated_Mul(*[k**v for k, v in u.factors.items()])\n            n, d = fraction(u)\n            if old == (n, d):\n                n, d = was\n        n = expand_mul(n)\n        if d.is_Number or d.is_Add:\n            n2, d2 = fraction(gcd_terms(_unevaluated_Mul(n, 1/d)))\n            if d2.is_Number or (d2.count_ops() <= d.count_ops()):\n                n, d = [signsimp(i) for i in (n2, d2)]\n                if n.is_Mul and n.args[0].is_Number:\n                    n = n.func(*n.args)\n\n    return coeff + _unevaluated_Mul(n, 1/d)",
    "sympy.sympy.simplify.simplify.inversecombine": "def inversecombine(expr):\n    \"\"\"Simplify the composition of a function and its inverse.\n\n    Explanation\n    ===========\n\n    No attention is paid to whether the inverse is a left inverse or a\n    right inverse; thus, the result will in general not be equivalent\n    to the original expression.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.simplify import inversecombine\n    >>> from sympy import asin, sin, log, exp\n    >>> from sympy.abc import x\n    >>> inversecombine(asin(sin(x)))\n    x\n    >>> inversecombine(2*log(exp(3*x)))\n    6*x\n    \"\"\"\n\n    def f(rv):\n        if isinstance(rv, log):\n            if isinstance(rv.args[0], exp) or (rv.args[0].is_Pow and rv.args[0].base == S.Exp1):\n                rv = rv.args[0].exp\n        elif rv.is_Function and hasattr(rv, \"inverse\"):\n            if (len(rv.args) == 1 and len(rv.args[0].args) == 1 and\n               isinstance(rv.args[0], rv.inverse(argindex=1))):\n                rv = rv.args[0].args[0]\n        if rv.is_Pow and rv.base == S.Exp1:\n            if isinstance(rv.exp, log):\n                rv = rv.exp.args[0]\n        return rv\n\n    return _bottom_up(expr, f)",
    "sympy.sympy.simplify.simplify.kroneckersimp": "def kroneckersimp(expr):\n    \"\"\"\n    Simplify expressions with KroneckerDelta.\n\n    The only simplification currently attempted is to identify multiplicative cancellation:\n\n    Examples\n    ========\n\n    >>> from sympy import KroneckerDelta, kroneckersimp\n    >>> from sympy.abc import i\n    >>> kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i))\n    1\n    \"\"\"\n    def args_cancel(args1, args2):\n        for i1 in range(2):\n            for i2 in range(2):\n                a1 = args1[i1]\n                a2 = args2[i2]\n                a3 = args1[(i1 + 1) % 2]\n                a4 = args2[(i2 + 1) % 2]\n                if Eq(a1, a2) is S.true and Eq(a3, a4) is S.false:\n                    return True\n        return False\n\n    def cancel_kronecker_mul(m):\n        args = m.args\n        deltas = [a for a in args if isinstance(a, KroneckerDelta)]\n        for delta1, delta2 in subsets(deltas, 2):\n            args1 = delta1.args\n            args2 = delta2.args\n            if args_cancel(args1, args2):\n                return S.Zero * m # In case of oo etc\n        return m\n\n    if not expr.has(KroneckerDelta):\n        return expr\n\n    if expr.has(Piecewise):\n        expr = expr.rewrite(KroneckerDelta)\n\n    newexpr = expr\n    expr = None\n\n    while newexpr != expr:\n        expr = newexpr\n        newexpr = expr.replace(lambda e: isinstance(e, Mul), cancel_kronecker_mul)\n\n    return expr",
    "sympy.sympy.simplify.simplify.besselsimp": "def besselsimp(expr):\n    \"\"\"\n    Simplify bessel-type functions.\n\n    Explanation\n    ===========\n\n    This routine tries to simplify bessel-type functions. Currently it only\n    works on the Bessel J and I functions, however. It works by looking at all\n    such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually\n    their polar equivalents) in front of the argument. Then, functions of\n    half-integer order are rewritten using trigonometric functions and\n    functions of integer order (> 1) are rewritten using functions\n    of low order.  Finally, if the expression was changed, compute\n    factorization of the result with factor().\n\n    >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S\n    >>> from sympy.abc import z, nu\n    >>> besselsimp(besselj(nu, z*polar_lift(-1)))\n    exp(I*pi*nu)*besselj(nu, z)\n    >>> besselsimp(besseli(nu, z*polar_lift(-I)))\n    exp(-I*pi*nu/2)*besselj(nu, z)\n    >>> besselsimp(besseli(S(-1)/2, z))\n    sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))\n    >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))\n    3*z*besseli(0, z)/2\n    \"\"\"\n    # TODO\n    # - better algorithm?\n    # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...\n    # - use contiguity relations?\n\n    def replacer(fro, to, factors):\n        factors = set(factors)\n\n        def repl(nu, z):\n            if factors.intersection(Mul.make_args(z)):\n                return to(nu, z)\n            return fro(nu, z)\n        return repl\n\n    def torewrite(fro, to):\n        def tofunc(nu, z):\n            return fro(nu, z).rewrite(to)\n        return tofunc\n\n    def tominus(fro):\n        def tofunc(nu, z):\n            return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)\n        return tofunc\n\n    orig_expr = expr\n\n    ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]\n    expr = expr.replace(\n        besselj, replacer(besselj,\n        torewrite(besselj, besseli), ifactors))\n    expr = expr.replace(\n        besseli, replacer(besseli,\n        torewrite(besseli, besselj), ifactors))\n\n    minusfactors = [-1, exp_polar(I*pi)]\n    expr = expr.replace(\n        besselj, replacer(besselj, tominus(besselj), minusfactors))\n    expr = expr.replace(\n        besseli, replacer(besseli, tominus(besseli), minusfactors))\n\n    z0 = Dummy('z')\n\n    def expander(fro):\n        def repl(nu, z):\n            if (nu % 1) == S.Half:\n                return simplify(trigsimp(unpolarify(\n                        fro(nu, z0).rewrite(besselj).rewrite(jn).expand(\n                            func=True)).subs(z0, z)))\n            elif nu.is_Integer and nu > 1:\n                return fro(nu, z).expand(func=True)\n            return fro(nu, z)\n        return repl\n\n    expr = expr.replace(besselj, expander(besselj))\n    expr = expr.replace(bessely, expander(bessely))\n    expr = expr.replace(besseli, expander(besseli))\n    expr = expr.replace(besselk, expander(besselk))\n\n    def _bessel_simp_recursion(expr):\n\n        def _use_recursion(bessel, expr):\n            while True:\n                bessels = expr.find(lambda x: isinstance(x, bessel))\n                try:\n                    for ba in sorted(bessels, key=lambda x: re(x.args[0])):\n                        a, x = ba.args\n                        bap1 = bessel(a+1, x)\n                        bap2 = bessel(a+2, x)\n                        if expr.has(bap1) and expr.has(bap2):\n                            expr = expr.subs(ba, 2*(a+1)/x*bap1 - bap2)\n                            break\n                    else:\n                        return expr\n                except (ValueError, TypeError):\n                    return expr\n        if expr.has(besselj):\n            expr = _use_recursion(besselj, expr)\n        if expr.has(bessely):\n            expr = _use_recursion(bessely, expr)\n        return expr\n\n    expr = _bessel_simp_recursion(expr)\n    if expr != orig_expr:\n        expr = expr.factor()\n\n    return expr",
    "sympy.sympy.simplify.simplify.nsimplify": "def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,\n    rational_conversion='base10'):\n    \"\"\"\n    Find a simple representation for a number or, if there are free symbols or\n    if ``rational=True``, then replace Floats with their Rational equivalents. If\n    no change is made and rational is not False then Floats will at least be\n    converted to Rationals.\n\n    Explanation\n    ===========\n\n    For numerical expressions, a simple formula that numerically matches the\n    given numerical expression is sought (and the input should be possible\n    to evalf to a precision of at least 30 digits).\n\n    Optionally, a list of (rationally independent) constants to\n    include in the formula may be given.\n\n    A lower tolerance may be set to find less exact matches. If no tolerance\n    is given then the least precise value will set the tolerance (e.g. Floats\n    default to 15 digits of precision, so would be tolerance=10**-15).\n\n    With ``full=True``, a more extensive search is performed\n    (this is useful to find simpler numbers when the tolerance\n    is set low).\n\n    When converting to rational, if rational_conversion='base10' (the default), then\n    convert floats to rationals using their base-10 (string) representation.\n    When rational_conversion='exact' it uses the exact, base-2 representation.\n\n    Examples\n    ========\n\n    >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi\n    >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n    -2 + 2*GoldenRatio\n    >>> nsimplify((1/(exp(3*pi*I/5)+1)))\n    1/2 - I*sqrt(sqrt(5)/10 + 1/4)\n    >>> nsimplify(I**I, [pi])\n    exp(-pi/2)\n    >>> nsimplify(pi, tolerance=0.01)\n    22/7\n\n    >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')\n    6004799503160655/18014398509481984\n    >>> nsimplify(0.333333333333333, rational=True)\n    1/3\n\n    See Also\n    ========\n\n    sympy.core.function.nfloat\n\n    \"\"\"\n    try:\n        return sympify(as_int(expr))\n    except (TypeError, ValueError):\n        pass\n    expr = sympify(expr).xreplace({\n        Float('inf'): S.Infinity,\n        Float('-inf'): S.NegativeInfinity,\n        })\n    if expr is S.Infinity or expr is S.NegativeInfinity:\n        return expr\n    if rational or expr.free_symbols:\n        return _real_to_rational(expr, tolerance, rational_conversion)\n\n    # SymPy's default tolerance for Rationals is 15; other numbers may have\n    # lower tolerances set, so use them to pick the largest tolerance if None\n    # was given\n    if tolerance is None:\n        tolerance = 10**-min([15] +\n             [mpmath.libmp.libmpf.prec_to_dps(n._prec)\n             for n in expr.atoms(Float)])\n    # XXX should prec be set independent of tolerance or should it be computed\n    # from tolerance?\n    prec = 30\n    bprec = int(prec*3.33)\n\n    constants_dict = {}\n    for constant in constants:\n        constant = sympify(constant)\n        v = constant.evalf(prec)\n        if not v.is_Float:\n            raise ValueError(\"constants must be real-valued\")\n        constants_dict[str(constant)] = v._to_mpmath(bprec)\n\n    exprval = expr.evalf(prec, chop=True)\n    re, im = exprval.as_real_imag()\n\n    # safety check to make sure that this evaluated to a number\n    if not (re.is_Number and im.is_Number):\n        return expr\n\n    def nsimplify_real(x):\n        orig = mpmath.mp.dps\n        xv = x._to_mpmath(bprec)\n        try:\n            # We'll be happy with low precision if a simple fraction\n            if not (tolerance or full):\n                mpmath.mp.dps = 15\n                rat = mpmath.pslq([xv, 1])\n                if rat is not None:\n                    return Rational(-int(rat[1]), int(rat[0]))\n            mpmath.mp.dps = prec\n            newexpr = mpmath.identify(xv, constants=constants_dict,\n                tol=tolerance, full=full)\n            if not newexpr:\n                raise ValueError\n            if full:\n                newexpr = newexpr[0]\n            expr = sympify(newexpr)\n            if x and not expr:  # don't let x become 0\n                raise ValueError\n            if expr.is_finite is False and xv not in [mpmath.inf, mpmath.ninf]:\n                raise ValueError\n            return expr\n        finally:\n            # even though there are returns above, this is executed\n            # before leaving\n            mpmath.mp.dps = orig\n    try:\n        if re:\n            re = nsimplify_real(re)\n        if im:\n            im = nsimplify_real(im)\n    except ValueError:\n        if rational is None:\n            return _real_to_rational(expr, rational_conversion=rational_conversion)\n        return expr\n\n    rv = re + im*S.ImaginaryUnit\n    # if there was a change or rational is explicitly not wanted\n    # return the value, else return the Rational representation\n    if rv != expr or rational is False:\n        return rv\n    return _real_to_rational(expr, rational_conversion=rational_conversion)",
    "sympy.sympy.simplify.simplify.nc_simplify": "def nc_simplify(expr, deep=True):\n    '''\n    Simplify a non-commutative expression composed of multiplication\n    and raising to a power by grouping repeated subterms into one power.\n    Priority is given to simplifications that give the fewest number\n    of arguments in the end (for example, in a*b*a*b*c*a*b*c simplifying\n    to (a*b)**2*c*a*b*c gives 5 arguments while a*b*(a*b*c)**2 has 3).\n    If ``expr`` is a sum of such terms, the sum of the simplified terms\n    is returned.\n\n    Keyword argument ``deep`` controls whether or not subexpressions\n    nested deeper inside the main expression are simplified. See examples\n    below. Setting `deep` to `False` can save time on nested expressions\n    that do not need simplifying on all levels.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.simplify.simplify import nc_simplify\n    >>> a, b, c = symbols(\"a b c\", commutative=False)\n    >>> nc_simplify(a*b*a*b*c*a*b*c)\n    a*b*(a*b*c)**2\n    >>> expr = a**2*b*a**4*b*a**4\n    >>> nc_simplify(expr)\n    a**2*(b*a**4)**2\n    >>> nc_simplify(a*b*a*b*c**2*(a*b)**2*c**2)\n    ((a*b)**2*c**2)**2\n    >>> nc_simplify(a*b*a*b + 2*a*c*a**2*c*a**2*c*a)\n    (a*b)**2 + 2*(a*c*a)**3\n    >>> nc_simplify(b**-1*a**-1*(a*b)**2)\n    a*b\n    >>> nc_simplify(a**-1*b**-1*c*a)\n    (b*a)**(-1)*c*a\n    >>> expr = (a*b*a*b)**2*a*c*a*c\n    >>> nc_simplify(expr)\n    (a*b)**4*(a*c)**2\n    >>> nc_simplify(expr, deep=False)\n    (a*b*a*b)**2*(a*c)**2\n\n    '''\n    if isinstance(expr, MatrixExpr):\n        expr = expr.doit(inv_expand=False)\n        _Add, _Mul, _Pow, _Symbol = MatAdd, MatMul, MatPow, MatrixSymbol\n    else:\n        _Add, _Mul, _Pow, _Symbol = Add, Mul, Pow, Symbol\n\n    # =========== Auxiliary functions ========================\n    def _overlaps(args):\n        # Calculate a list of lists m such that m[i][j] contains the lengths\n        # of all possible overlaps between args[:i+1] and args[i+1+j:].\n        # An overlap is a suffix of the prefix that matches a prefix\n        # of the suffix.\n        # For example, let expr=c*a*b*a*b*a*b*a*b. Then m[3][0] contains\n        # the lengths of overlaps of c*a*b*a*b with a*b*a*b. The overlaps\n        # are a*b*a*b, a*b and the empty word so that m[3][0]=[4,2,0].\n        # All overlaps rather than only the longest one are recorded\n        # because this information helps calculate other overlap lengths.\n        m = [[([1, 0] if a == args[0] else [0]) for a in args[1:]]]\n        for i in range(1, len(args)):\n            overlaps = []\n            j = 0\n            for j in range(len(args) - i - 1):\n                overlap = []\n                for v in m[i-1][j+1]:\n                    if j + i + 1 + v < len(args) and args[i] == args[j+i+1+v]:\n                        overlap.append(v + 1)\n                overlap += [0]\n                overlaps.append(overlap)\n            m.append(overlaps)\n        return m\n\n    def _reduce_inverses(_args):\n        # replace consecutive negative powers by an inverse\n        # of a product of positive powers, e.g. a**-1*b**-1*c\n        # will simplify to (a*b)**-1*c;\n        # return that new args list and the number of negative\n        # powers in it (inv_tot)\n        inv_tot = 0 # total number of inverses\n        inverses = []\n        args = []\n        for arg in _args:\n            if isinstance(arg, _Pow) and arg.args[1].is_extended_negative:\n                inverses = [arg**-1] + inverses\n                inv_tot += 1\n            else:\n                if len(inverses) == 1:\n                    args.append(inverses[0]**-1)\n                elif len(inverses) > 1:\n                    args.append(_Pow(_Mul(*inverses), -1))\n                    inv_tot -= len(inverses) - 1\n                inverses = []\n                args.append(arg)\n        if inverses:\n            args.append(_Pow(_Mul(*inverses), -1))\n            inv_tot -= len(inverses) - 1\n        return inv_tot, tuple(args)\n\n    def get_score(s):\n        # compute the number of arguments of s\n        # (including in nested expressions) overall\n        # but ignore exponents\n        if isinstance(s, _Pow):\n            return get_score(s.args[0])\n        elif isinstance(s, (_Add, _Mul)):\n            return sum(get_score(a) for a in s.args)\n        return 1\n\n    def compare(s, alt_s):\n        # compare two possible simplifications and return a\n        # \"better\" one\n        if s != alt_s and get_score(alt_s) < get_score(s):\n            return alt_s\n        return s\n    # ========================================================\n\n    if not isinstance(expr, (_Add, _Mul, _Pow)) or expr.is_commutative:\n        return expr\n    args = expr.args[:]\n    if isinstance(expr, _Pow):\n        if deep:\n            return _Pow(nc_simplify(args[0]), args[1]).doit()\n        else:\n            return expr\n    elif isinstance(expr, _Add):\n        return _Add(*[nc_simplify(a, deep=deep) for a in args]).doit()\n    else:\n        # get the non-commutative part\n        c_args, args = expr.args_cnc()\n        com_coeff = Mul(*c_args)\n        if not equal_valued(com_coeff, 1):\n            return com_coeff*nc_simplify(expr/com_coeff, deep=deep)\n\n    inv_tot, args = _reduce_inverses(args)\n    # if most arguments are negative, work with the inverse\n    # of the expression, e.g. a**-1*b*a**-1*c**-1 will become\n    # (c*a*b**-1*a)**-1 at the end so can work with c*a*b**-1*a\n    invert = False\n    if inv_tot > len(args)/2:\n        invert = True\n        args = [a**-1 for a in args[::-1]]\n\n    if deep:\n        args = tuple(nc_simplify(a) for a in args)\n\n    m = _overlaps(args)\n\n    # simps will be {subterm: end} where `end` is the ending\n    # index of a sequence of repetitions of subterm;\n    # this is for not wasting time with subterms that are part\n    # of longer, already considered sequences\n    simps = {}\n\n    post = 1\n    pre = 1\n\n    # the simplification coefficient is the number of\n    # arguments by which contracting a given sequence\n    # would reduce the word; e.g. in a*b*a*b*c*a*b*c,\n    # contracting a*b*a*b to (a*b)**2 removes 3 arguments\n    # while a*b*c*a*b*c to (a*b*c)**2 removes 6. It's\n    # better to contract the latter so simplification\n    # with a maximum simplification coefficient will be chosen\n    max_simp_coeff = 0\n    simp = None # information about future simplification\n\n    for i in range(1, len(args)):\n        simp_coeff = 0\n        l = 0 # length of a subterm\n        p = 0 # the power of a subterm\n        if i < len(args) - 1:\n            rep = m[i][0]\n        start = i # starting index of the repeated sequence\n        end = i+1 # ending index of the repeated sequence\n        if i == len(args)-1 or rep == [0]:\n            # no subterm is repeated at this stage, at least as\n            # far as the arguments are concerned - there may be\n            # a repetition if powers are taken into account\n            if (isinstance(args[i], _Pow) and\n                            not isinstance(args[i].args[0], _Symbol)):\n                subterm = args[i].args[0].args\n                l = len(subterm)\n                # Only apply optimization if power base matches subterm pattern\n                if (args[i-l:i] == subterm and\n                    args[i].args[0] == _Mul(*subterm)):\n                    # e.g. a*b in a*b*(a*b)**2 is not repeated\n                    # in args (= [a, b, (a*b)**2]) but it\n                    # can be matched here\n                    p += 1\n                    start -= l\n                if (args[i+1:i+1+l] == subterm and\n                    args[i].args[0] == _Mul(*subterm)):\n                    # e.g. a*b in (a*b)**2*a*b\n                    p += 1\n                    end += l\n            if p:\n                p += args[i].args[1]\n            else:\n                continue\n        else:\n            l = rep[0] # length of the longest repeated subterm at this point\n            start -= l - 1\n            subterm = args[start:end]\n            p = 2\n            end += l\n\n        if subterm in simps and simps[subterm] >= start:\n            # the subterm is part of a sequence that\n            # has already been considered\n            continue\n\n        # count how many times it's repeated\n        while end < len(args):\n            if l in m[end-1][0]:\n                p += 1\n                end += l\n            elif isinstance(args[end], _Pow) and args[end].args[0].args == subterm:\n                # for cases like a*b*a*b*(a*b)**2*a*b\n                p += args[end].args[1]\n                end += 1\n            else:\n                break\n\n        # see if another match can be made, e.g.\n        # for b*a**2 in b*a**2*b*a**3 or a*b in\n        # a**2*b*a*b\n\n        pre_exp = 0\n        pre_arg = 1\n        if start - l >= 0 and args[start-l+1:start] == subterm[1:]:\n            if isinstance(subterm[0], _Pow):\n                pre_arg = subterm[0].args[0]\n                exp = subterm[0].args[1]\n            else:\n                pre_arg = subterm[0]\n                exp = 1\n            if isinstance(args[start-l], _Pow) and args[start-l].args[0] == pre_arg:\n                pre_exp = args[start-l].args[1] - exp\n                start -= l\n                p += 1\n            elif args[start-l] == pre_arg:\n                pre_exp = 1 - exp\n                start -= l\n                p += 1\n\n        post_exp = 0\n        post_arg = 1\n        if end + l - 1 < len(args) and args[end:end+l-1] == subterm[:-1]:\n            if isinstance(subterm[-1], _Pow):\n                post_arg = subterm[-1].args[0]\n                exp = subterm[-1].args[1]\n            else:\n                post_arg = subterm[-1]\n                exp = 1\n            if isinstance(args[end+l-1], _Pow) and args[end+l-1].args[0] == post_arg:\n                post_exp = args[end+l-1].args[1] - exp\n                end += l\n                p += 1\n            elif args[end+l-1] == post_arg:\n                post_exp = 1 - exp\n                end += l\n                p += 1\n\n        # Consider a*b*a**2*b*a**2*b*a:\n        # b*a**2 is explicitly repeated, but note\n        # that in this case a*b*a is also repeated\n        # so there are two possible simplifications:\n        # a*(b*a**2)**3*a**-1 or (a*b*a)**3\n        # The latter is obviously simpler.\n        # But in a*b*a**2*b**2*a**2 the simplifications are\n        # a*(b*a**2)**2 and (a*b*a)**3*a in which case\n        # it's better to stick with the shorter subterm\n        if post_exp and exp % 2 == 0 and start > 0:\n            exp = exp/2\n            _pre_exp = 1\n            _post_exp = 1\n            if isinstance(args[start-1], _Pow) and args[start-1].args[0] == post_arg:\n                _post_exp = post_exp + exp\n                _pre_exp = args[start-1].args[1] - exp\n            elif args[start-1] == post_arg:\n                _post_exp = post_exp + exp\n                _pre_exp = 1 - exp\n            if _pre_exp == 0 or _post_exp == 0:\n                if not pre_exp:\n                    start -= 1\n                post_exp = _post_exp\n                pre_exp = _pre_exp\n                pre_arg = post_arg\n                subterm = (post_arg**exp,) + subterm[:-1] + (post_arg**exp,)\n\n        simp_coeff += end-start\n\n        if post_exp:\n            simp_coeff -= 1\n        if pre_exp:\n            simp_coeff -= 1\n\n        simps[subterm] = end\n\n        if simp_coeff > max_simp_coeff:\n            max_simp_coeff = simp_coeff\n            simp = (start, _Mul(*subterm), p, end, l)\n            pre = pre_arg**pre_exp\n            post = post_arg**post_exp\n\n    if simp:\n        subterm = _Pow(nc_simplify(simp[1], deep=deep), simp[2])\n        pre = nc_simplify(_Mul(*args[:simp[0]])*pre, deep=deep)\n        post = post*nc_simplify(_Mul(*args[simp[3]:]), deep=deep)\n        simp = pre*subterm*post\n        if pre != 1 or post != 1:\n            # new simplifications may be possible but no need\n            # to recurse over arguments\n            simp = nc_simplify(simp, deep=False)\n    else:\n        simp = _Mul(*args)\n\n    if invert:\n        simp = _Pow(simp, -1)\n\n    # see if factor_nc(expr) is simplified better\n    if not isinstance(expr, MatrixExpr):\n        f_expr = factor_nc(expr)\n        if f_expr != expr:\n            alt_simp = nc_simplify(f_expr, deep=deep)\n            simp = compare(simp, alt_simp)\n    else:\n        simp = simp.doit(inv_expand=False)\n    return simp",
    "sympy.sympy.simplify.simplify.signsimp": "def signsimp(expr, evaluate=None):\n    \"\"\"Make all Add sub-expressions canonical wrt sign.\n\n    Explanation\n    ===========\n\n    If an Add subexpression, ``a``, can have a sign extracted,\n    as determined by could_extract_minus_sign, it is replaced\n    with Mul(-1, a, evaluate=False). This allows signs to be\n    extracted from powers and products.\n\n    Examples\n    ========\n\n    >>> from sympy import signsimp, exp, symbols\n    >>> from sympy.abc import x, y\n    >>> i = symbols('i', odd=True)\n    >>> n = -1 + 1/x\n    >>> n/x/(-n)**2 - 1/n/x\n    (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))\n    >>> signsimp(_)\n    0\n    >>> x*n + x*-n\n    x*(-1 + 1/x) + x*(1 - 1/x)\n    >>> signsimp(_)\n    0\n\n    Since powers automatically handle leading signs\n\n    >>> (-2)**i\n    -2**i\n\n    signsimp can be used to put the base of a power with an integer\n    exponent into canonical form:\n\n    >>> n**i\n    (-1 + 1/x)**i\n\n    By default, signsimp does not leave behind any hollow simplification:\n    if making an Add canonical wrt sign didn't change the expression, the\n    original Add is restored. If this is not desired then the keyword\n    ``evaluate`` can be set to False:\n\n    >>> e = exp(y - x)\n    >>> signsimp(e) == e\n    True\n    >>> signsimp(e, evaluate=False)\n    exp(-(x - y))\n\n    \"\"\"\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    expr = sympify(expr)\n    if not isinstance(expr, (Expr, Relational)) or expr.is_Atom:\n        return expr\n    # get rid of an pre-existing unevaluation regarding sign\n    e = expr.replace(lambda x: x.is_Mul and -(-x) != x, lambda x: -(-x))\n    e = sub_post(sub_pre(e))\n    if not isinstance(e, (Expr, Relational)) or e.is_Atom:\n        return e\n    if e.is_Add:\n        rv = e.func(*[signsimp(a) for a in e.args])\n        if not evaluate and isinstance(rv, Add\n                ) and rv.could_extract_minus_sign():\n            return Mul(S.NegativeOne, -rv, evaluate=False)\n        return rv\n    if evaluate:\n        e = e.replace(lambda x: x.is_Mul and -(-x) != x, lambda x: -(-x))\n    return e",
    "sympy.sympy.simplify.simplify.shorter": "def shorter(*choices):\n    \"\"\"\n    Return the choice that has the fewest ops. In case of a tie,\n    the expression listed first is selected.\n    \"\"\"\n    if not has_variety(choices):\n        return choices[0]\n    return min(choices, key=measure)",
    "sympy.sympy.simplify.simplify.done": "def done(e):\n    rv = e.doit() if doit else e\n    return shorter(rv, collect_abs(rv))",
    "sympy.sympy.simplify.simplify.<dictcomp>": "expr = expr.xreplace({\n    i: factor_terms(i) for i in expr.atoms(Integral)})\n\n",
    "sympy.sympy.simplify.simplify.sum_simplify": "def sum_simplify(s, **kwargs):\n    \"\"\"Main function for Sum simplification\"\"\"\n    if not isinstance(s, Add):\n        s = s.xreplace({a: sum_simplify(a, **kwargs)\n            for a in s.atoms(Add) if a.has(Sum)})\n    s = expand(s)\n    if not isinstance(s, Add):\n        return s\n\n    terms = s.args\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n\n    for term in terms:\n        sum_terms, other = sift(Mul.make_args(term),\n            lambda i: isinstance(i, Sum), binary=True)\n        if not sum_terms:\n            o_t.append(term)\n            continue\n        other = [Mul(*other)]\n        s_t.append(Mul(*(other + [s._eval_simplify(**kwargs) for s in sum_terms])))\n\n    result = Add(sum_combine(s_t), *o_t)\n\n    return result",
    "sympy.sympy.simplify.simplify.product_simplify": "def product_simplify(s, **kwargs):\n    \"\"\"Main function for Product simplification\"\"\"\n    terms = Mul.make_args(s)\n    p_t = [] # Product Terms\n    o_t = [] # Other Terms\n\n    deep = kwargs.get('deep', True)\n    for term in terms:\n        if isinstance(term, Product):\n            if deep:\n                p_t.append(Product(term.function.simplify(**kwargs),\n                                   *term.limits))\n            else:\n                p_t.append(term)\n        else:\n            o_t.append(term)\n\n    used = [False] * len(p_t)\n\n    for method in range(2):\n        for i, p_term1 in enumerate(p_t):\n            if not used[i]:\n                for j, p_term2 in enumerate(p_t):\n                    if not used[j] and i != j:\n                        tmp_prod = product_mul(p_term1, p_term2, method)\n                        if isinstance(tmp_prod, Product):\n                            p_t[i] = tmp_prod\n                            used[j] = True\n\n    result = Mul(*o_t)\n\n    for i, p_term in enumerate(p_t):\n        if not used[i]:\n            result = Mul(result, p_term)\n\n    return result",
    "sympy.sympy.simplify.simplify.logcombine": "def logcombine(expr, force=False):\n    \"\"\"\n    Takes logarithms and combines them using the following rules:\n\n    - log(x) + log(y) == log(x*y) if both are positive\n    - a*log(x) == log(x**a) if x is positive and a is real\n\n    If ``force`` is ``True`` then the assumptions above will be assumed to hold if\n    there is no assumption already in place on a quantity. For example, if\n    ``a`` is imaginary or the argument negative, force will not perform a\n    combination but if ``a`` is a symbol with no assumptions the change will\n    take place.\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, symbols, log, logcombine, I\n    >>> from sympy.abc import a, x, y, z\n    >>> logcombine(a*log(x) + log(y) - log(z))\n    a*log(x) + log(y) - log(z)\n    >>> logcombine(a*log(x) + log(y) - log(z), force=True)\n    log(x**a*y/z)\n    >>> x,y,z = symbols('x,y,z', positive=True)\n    >>> a = Symbol('a', real=True)\n    >>> logcombine(a*log(x) + log(y) - log(z))\n    log(x**a*y/z)\n\n    The transformation is limited to factors and/or terms that\n    contain logs, so the result depends on the initial state of\n    expansion:\n\n    >>> eq = (2 + 3*I)*log(x)\n    >>> logcombine(eq, force=True) == eq\n    True\n    >>> logcombine(eq.expand(), force=True)\n    log(x**2) + I*log(x**3)\n\n    See Also\n    ========\n\n    posify: replace all symbols with symbols having positive assumptions\n    sympy.core.function.expand_log: expand the logarithms of products\n        and powers; the opposite of logcombine\n\n    \"\"\"\n\n    def f(rv):\n        if not (rv.is_Add or rv.is_Mul):\n            return rv\n\n        def gooda(a):\n            # bool to tell whether the leading ``a`` in ``a*log(x)``\n            # could appear as log(x**a)\n            return (a is not S.NegativeOne and  # -1 *could* go, but we disallow\n                (a.is_extended_real or force and a.is_extended_real is not False))\n\n        def goodlog(l):\n            # bool to tell whether log ``l``'s argument can combine with others\n            a = l.args[0]\n            return a.is_positive or force and a.is_nonpositive is not False\n\n        other = []\n        logs = []\n        log1 = defaultdict(list)\n        for a in Add.make_args(rv):\n            if isinstance(a, log) and goodlog(a):\n                log1[()].append(([], a))\n            elif not a.is_Mul:\n                other.append(a)\n            else:\n                ot = []\n                co = []\n                lo = []\n                for ai in a.args:\n                    if ai.is_Rational and ai < 0:\n                        ot.append(S.NegativeOne)\n                        co.append(-ai)\n                    elif isinstance(ai, log) and goodlog(ai):\n                        lo.append(ai)\n                    elif gooda(ai):\n                        co.append(ai)\n                    else:\n                        ot.append(ai)\n                if len(lo) > 1:\n                    logs.append((ot, co, lo))\n                elif lo:\n                    log1[tuple(ot)].append((co, lo[0]))\n                else:\n                    other.append(a)\n\n        # if there is only one log in other, put it with the\n        # good logs\n        if len(other) == 1 and isinstance(other[0], log):\n            log1[()].append(([], other.pop()))\n        # if there is only one log at each coefficient and none have\n        # an exponent to place inside the log then there is nothing to do\n        if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):\n            return rv\n\n        # collapse multi-logs as far as possible in a canonical way\n        # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?\n        # -- in this case, it's unambiguous, but if it were were a log(c) in\n        # each term then it's arbitrary whether they are grouped by log(a) or\n        # by log(c). So for now, just leave this alone; it's probably better to\n        # let the user decide\n        for o, e, l in logs:\n            l = list(ordered(l))\n            e = log(l.pop(0).args[0]**Mul(*e))\n            while l:\n                li = l.pop(0)\n                e = log(li.args[0]**e)\n            c, l = Mul(*o), e\n            if isinstance(l, log):  # it should be, but check to be sure\n                log1[(c,)].append(([], l))\n            else:\n                other.append(c*l)\n\n        # logs that have the same coefficient can multiply\n        for k in list(log1.keys()):\n            log1[Mul(*k)] = log(logcombine(Mul(*[\n                l.args[0]**Mul(*c) for c, l in log1.pop(k)]),\n                force=force), evaluate=False)\n\n        # logs that have oppositely signed coefficients can divide\n        for k in ordered(list(log1.keys())):\n            if k not in log1:  # already popped as -k\n                continue\n            if -k in log1:\n                # figure out which has the minus sign; the one with\n                # more op counts should be the one\n                num, den = k, -k\n                if num.count_ops() > den.count_ops():\n                    num, den = den, num\n                other.append(\n                    num*log(log1.pop(num).args[0]/log1.pop(den).args[0],\n                            evaluate=False))\n            else:\n                other.append(k*log1.pop(k))\n\n        return Add(*other)\n\n    return _bottom_up(expr, f)",
    "sympy.sympy.simplify.trigsimp.trigsimp": "def trigsimp(expr, inverse=False, **opts):\n    \"\"\"Returns a reduced expression by using known trig identities.\n\n    Parameters\n    ==========\n\n    inverse : bool, optional\n        If ``inverse=True``, it will be assumed that a composition of inverse\n        functions, such as sin and asin, can be cancelled in any order.\n        For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n        x belongs to the set where this relation is true. The default is False.\n        Default : True\n\n    method : string, optional\n        Specifies the method to use. Valid choices are:\n\n        - ``'matching'``, default\n        - ``'groebner'``\n        - ``'combined'``\n        - ``'fu'``\n        - ``'old'``\n\n        If ``'matching'``, simplify the expression recursively by targeting\n        common patterns. If ``'groebner'``, apply an experimental groebner\n        basis algorithm. In this case further options are forwarded to\n        ``trigsimp_groebner``, please refer to\n        its docstring. If ``'combined'``, it first runs the groebner basis\n        algorithm with small default parameters, then runs the ``'matching'``\n        algorithm. If ``'fu'``, run the collection of trigonometric\n        transformations described by Fu, et al. (see the\n        :py:func:`~sympy.simplify.fu.fu` docstring). If ``'old'``, the original\n        SymPy trig simplification function is run.\n    opts :\n        Optional keyword arguments passed to the method. See each method's\n        function docstring for details.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using ``method='groebner'`` (or ``method='combined'``) might lead to\n    greater simplification.\n\n    The old trigsimp routine can be accessed as with method ``method='old'``.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    expr_simplified = trigsimpfunc(expr)\n    if inverse:\n        expr_simplified = _trigsimp_inverse(expr_simplified)\n\n    return expr_simplified",
    "sympy.sympy.simplify.trigsimp.exptrigsimp": "def exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            op = e.rewrite(exp)\n            # if e is an Add, we can try to factor it\n            # helps with expressions with leading factors\n            if e.is_Add:\n                choices.append(factor_terms(op))\n            else:\n                choices.append(op)\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        commutative_part, noncommutative_part = rv.args_cnc()\n        # Since as_powers_dict loses order information,\n        # if there is more than one noncommutative factor,\n        # it should only be used to simplify the commutative part.\n        if (len(noncommutative_part) > 1):\n            return f(Mul(*commutative_part))*Mul(*noncommutative_part)\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=S.One):\n            if expr is S.Exp1:\n                return sign, S.One\n            elif isinstance(expr, exp) or (expr.is_Pow and expr.base == S.Exp1):\n                return sign, expr.exp\n            elif sign is S.One:\n                return signlog(-expr, sign=-S.One)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr",
    "sympy.sympy.solvers.solvers.<lambda>": "v = _eval_simplify(ratio=2, measure=lambda x: 1)\n",
    "sympy.sympy.tensor.array.dense_ndim_array._eval_simplify": "def _eval_simplify(self, **kwargs):\n    from sympy.simplify.simplify import simplify\n    return self.applyfunc(simplify)",
    "sympy.sympy.vector.basisdependent._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self.simplify(**kwargs)",
    "sympy.sympy.vector.coordsysrect._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self"
}