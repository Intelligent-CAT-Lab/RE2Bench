{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.expr.as_coefficient": "def as_coefficient(self, expr: Expr) -> Expr | None:\n    \"\"\"\n    Extracts symbolic coefficient at the given expression. In\n    other words, this functions separates 'self' into the product\n    of 'expr' and 'expr'-free coefficient. If such separation\n    is not possible it will return None.\n\n    Examples\n    ========\n\n    >>> from sympy import E, pi, sin, I, Poly\n    >>> from sympy.abc import x\n\n    >>> E.as_coefficient(E)\n    1\n    >>> (2*E).as_coefficient(E)\n    2\n    >>> (2*sin(E)*E).as_coefficient(E)\n\n    Two terms have E in them so a sum is returned. (If one were\n    desiring the coefficient of the term exactly matching E then\n    the constant from the returned expression could be selected.\n    Or, for greater precision, a method of Poly can be used to\n    indicate the desired term from which the coefficient is\n    desired.)\n\n    >>> (2*E + x*E).as_coefficient(E)\n    x + 2\n    >>> _.args[0]  # just want the exact match\n    2\n    >>> p = Poly(2*E + x*E); p\n    Poly(x*E + 2*E, x, E, domain='ZZ')\n    >>> p.coeff_monomial(E)\n    2\n    >>> p.nth(0, 1)\n    2\n\n    Since the following cannot be written as a product containing\n    E as a factor, None is returned. (If the coefficient ``2*x`` is\n    desired then the ``coeff`` method should be used.)\n\n    >>> (2*E*x + x).as_coefficient(E)\n    >>> (2*E*x + x).coeff(E)\n    2*x\n\n    >>> (E*(x + 1) + x).as_coefficient(E)\n\n    >>> (2*pi*I).as_coefficient(pi*I)\n    2\n    >>> (2*I).as_coefficient(pi*I)\n\n    See Also\n    ========\n\n    coeff: return sum of terms have a given factor\n    as_coeff_Add: separate the additive constant from an expression\n    as_coeff_Mul: separate the multiplicative constant from an expression\n    as_independent: separate x-dependent terms/factors from others\n    sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n    sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used\n\n\n    \"\"\"\n\n    r = self.extract_multiplicatively(expr)\n    if r and not r.has(expr):\n        return r\n    else:\n        return None",
    "sympy.sympy.core.expr.as_independent": "def as_independent(\n    self,\n    *deps: Basic | type[Basic],\n    as_Add: bool | None = None,\n    strict: bool = True,\n) -> tuple[Expr, Expr]:\n    \"\"\"\n    A mostly naive separation of a Mul or Add into arguments that are not\n    are dependent on deps. To obtain as complete a separation of variables\n    as possible, use a separation method first, e.g.:\n\n    * ``separatevars()`` to change Mul, Add and Pow (including exp) into Mul\n    * ``.expand(mul=True)`` to change Add or Mul into Add\n    * ``.expand(log=True)`` to change log expr into an Add\n\n    The only non-naive thing that is done here is to respect noncommutative\n    ordering of variables and to always return ``(0, 0)`` for ``self`` of\n    zero regardless of hints.\n\n    For nonzero ``self``, the returned tuple ``(i, d)`` has the following\n    interpretation:\n\n    * ``i`` has no variable that appears in deps\n    * ``d`` will either have terms that contain variables that are in deps,\n      or be equal to ``0`` (when ``self`` is an ``Add``) or ``1`` (when\n      ``self`` is a ``Mul``)\n    * if ``self`` is an Add then ``self = i + d``\n    * if ``self`` is a Mul then ``self = i*d``\n    * otherwise ``(self, S.One)`` or ``(S.One, self)`` is returned.\n\n    To force the expression to be treated as an Add, use the argument\n    ``as_Add=True``.\n\n    The ``strict`` argument is deprecated and has no effect.\n\n    Examples\n    ========\n\n    -- ``self`` is an Add\n\n    >>> from sympy import sin, cos, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> (x + x*y).as_independent(x)\n    (0, x*y + x)\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x)\n    (y + z, 2*x*sin(x) + x)\n    >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n    (z, 2*x*sin(x) + x + y)\n\n    -- ``self`` is a Mul\n\n    >>> (x*sin(x)*cos(y)).as_independent(x)\n    (cos(y), x*sin(x))\n\n    Non-commutative terms cannot always be separated out when ``self`` is a\n    Mul\n\n    >>> from sympy import symbols\n    >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n    >>> (n1 + n1*n2).as_independent(n2)\n    (n1, n1*n2)\n    >>> (n2*n1 + n1*n2).as_independent(n2)\n    (0, n1*n2 + n2*n1)\n    >>> (n1*n2*n3).as_independent(n1)\n    (1, n1*n2*n3)\n    >>> (n1*n2*n3).as_independent(n2)\n    (n1, n2*n3)\n    >>> ((x-n1)*(x-y)).as_independent(x)\n    (1, (x - y)*(x - n1))\n\n    -- ``self`` is anything else:\n\n    >>> (sin(x)).as_independent(x)\n    (1, sin(x))\n    >>> (sin(x)).as_independent(y)\n    (sin(x), 1)\n    >>> exp(x+y).as_independent(x)\n    (1, exp(x + y))\n\n    -- force ``self`` to be treated as an Add:\n\n    >>> (3*x).as_independent(x, as_Add=True)\n    (0, 3*x)\n\n    -- force ``self`` to be treated as a Mul:\n\n    >>> (3+x).as_independent(x, as_Add=False)\n    (1, x + 3)\n    >>> (-3+x).as_independent(x, as_Add=False)\n    (1, x - 3)\n\n    Note how the below differs from the above in making the\n    constant on the dep term positive.\n\n    >>> (y*(-3+x)).as_independent(x)\n    (y, x - 3)\n\n    -- use ``.as_independent()`` for true independence testing instead of\n       ``.has()``. The former considers only symbols in the free symbols\n       while the latter considers all symbols\n\n    >>> from sympy import Integral\n    >>> I = Integral(x, (x, 1, 2))\n    >>> I.has(x)\n    True\n    >>> x in I.free_symbols\n    False\n    >>> I.as_independent(x) == (I, 1)\n    True\n    >>> (I + x).as_independent(x) == (I, x)\n    True\n\n    Note: when trying to get independent terms, a separation method might\n    need to be used first. In this case, it is important to keep track of\n    what you send to this routine so you know how to interpret the returned\n    values\n\n    >>> from sympy import separatevars, log\n    >>> separatevars(exp(x+y)).as_independent(x)\n    (exp(y), exp(x))\n    >>> (x + x*y).as_independent(y)\n    (x, x*y)\n    >>> separatevars(x + x*y).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).as_independent(y)\n    (x, y + 1)\n    >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n    (x, x*y)\n    >>> a, b=symbols('a b', positive=True)\n    >>> (log(a*b).expand(log=True)).as_independent(b)\n    (log(a), log(b))\n\n    See Also\n    ========\n\n    separatevars\n    expand_log\n    sympy.core.add.Add.as_two_terms\n    sympy.core.mul.Mul.as_two_terms\n    as_coeff_mul\n    \"\"\"\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n\n    if self is S.Zero:\n        return (self, self)\n\n    if as_Add is None:\n        as_Add = self.is_Add\n\n    syms, other = _sift_true_false(deps, lambda d: isinstance(d, Symbol))\n    syms_set = set(syms)\n\n    if other:\n        def has(e):\n            return e.has_xfree(syms_set) or e.has(*other)\n    else:\n        def has(e):\n            return e.has_xfree(syms_set)\n\n    if as_Add:\n        if not self.is_Add:\n            if has(self):\n                return (S.Zero, self)\n            else:\n                return (self, S.Zero)\n\n        depend, indep = _sift_true_false(self.args, has)\n        return (self.func(*indep), _unevaluated_Add(*depend))\n\n    else:\n        if not self.is_Mul:\n            if has(self):\n                return (S.One, self)\n            else:\n                return (self, S.One)\n\n        args, nc = self.args_cnc()\n        depend, indep = _sift_true_false(args, has)\n\n        # handle noncommutative by stopping at first dependent term\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n\n        return self.func(*indep), _unevaluated_Mul(*depend)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)"
}