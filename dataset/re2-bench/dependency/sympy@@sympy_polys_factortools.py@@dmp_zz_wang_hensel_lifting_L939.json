{
    "sympy.sympy.polys.densearith.dmp_expand": "def dmp_expand(polys: list[dmp[Er]], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply together several polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_expand([x**2 + y**2, x + 1])\n    x**3 + x**2 + x*y**2 + y**2\n\n    \"\"\"\n    if not polys:\n        return dmp_one(u, K)\n\n    f = polys[0]\n\n    for g in polys[1:]:\n        f = dmp_mul(f, g, u, K)\n\n    return f",
    "sympy.sympy.polys.densearith.dmp_quo_ground": "def dmp_quo_ground(\n    f: dmp[Er], c: Er, u: int, K: Domain[Er]\n) -> dmp[Er]:\n    \"\"\"\n    Quotient by a constant in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, ZZ(2))\n    x**2*y + x\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, QQ(2))\n    x**2*y + 3/2*x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_quo_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_quo_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densearith.dmp_sub": "def dmp_sub(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Subtract dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sub(x**2 + y, x**2*y + x)\n    -x**2*y + x**2 - x + y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_sub(_dup(f), _dup(g), K))\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return dmp_neg(g, u, K)\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return f\n\n    v = u - 1\n\n    if df == dg:\n        return dmp_strip([ dmp_sub(a, b, v, K) for a, b in zip(f, g) ], u, K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = dmp_neg(g[:k], u, K), g[k:]\n\n        return h + [ dmp_sub(a, b, v, K) for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densearith.dmp_add_mul": "def dmp_add_mul(f: dmp[Er], g: dmp[Er], h: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Returns ``f + g*h`` where ``f, g, h`` are in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add_mul(x**2 + y, x, x + 2)\n    2*x**2 + 2*x + y\n\n    \"\"\"\n    return dmp_add(f, dmp_mul(g, h, u, K), u, K)",
    "sympy.sympy.polys.densearith.dmp_mul": "def dmp_mul(f: dmp[Er], g: dmp[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul(x*y + 1, x)\n    x**2*y + x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_mul(_dup(f), _dup(g), K))\n\n    if f == g:\n        return dmp_sqr(f, u, K)\n\n    df = dmp_degree(f, u)\n\n    if df < 0:\n        return f\n\n    dg = dmp_degree(g, u)\n\n    if dg < 0:\n        return g\n\n    h: list[dmp[Er]] = []\n    v = u - 1\n\n    for i in range(0, df + dg + 1):\n        coeff = dmp_zero(v, K)\n\n        for j in range(max(0, i - dg), min(df, i) + 1):\n            coeff = dmp_add(coeff, dmp_mul(f[j], g[i - j], v, K), v, K)\n\n        h.append(coeff)\n\n    return dmp_strip(h, u, K)",
    "sympy.sympy.polys.densebasic.dmp_nest": "def dmp_nest(f: dmp[Er], l: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate value nested ``l``-levels.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_nest\n\n    >>> dmp_nest([[ZZ(1)]], 2, ZZ)\n    [[[[1]]]]\n\n    \"\"\"\n    if not isinstance(f, list):\n        return dmp_ground(f, l, K)\n\n    for i in range(l):\n        f = [f]\n\n    return f",
    "sympy.sympy.polys.densebasic.dmp_raise": "def dmp_raise(f: dmp[Er], l: int, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate polynomial raised ``l``-levels.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_raise\n\n    >>> f = ZZ.map([[], [1, 2]])\n\n    >>> dmp_raise(f, 2, 1, ZZ)\n    [[[[]]], [[[1]], [[2]]]]\n\n    \"\"\"\n    if not l:\n        return f\n\n    if not u:\n        if not f:\n            return dmp_zero(l, K)\n\n        k = l - 1\n\n        return [dmp_ground(c, k, K) for c in _dup(f)]\n\n    v = u - 1\n\n    return [dmp_raise(cp, l, v, K) for cp in f]",
    "sympy.sympy.polys.densebasic.dmp_degree_in": "def dmp_degree_in(f: dmp[Er], j: int, u: int) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``x_j`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree_in\n\n    >>> f = ZZ.map([[2], [1, 2, 3]])\n\n    >>> dmp_degree_in(f, 0, 1)\n    1\n    >>> dmp_degree_in(f, 1, 1)\n    2\n\n    \"\"\"\n    if not j:\n        return dmp_degree(f, u)\n    if j < 0 or j > u:\n        raise IndexError(\"0 <= j <= %s expected, got %s\" % (u, j))\n\n    return _rec_degree_in(f, u, 0, j)",
    "sympy.sympy.polys.densebasic.dmp_degree_list": "def dmp_degree_list(f: dmp[Er], u: int) -> tuple[int, ...]:\n    \"\"\"\n    Return a list of degrees of ``f`` in ``K[X]``.\n\n    The degree of a zero polynomial is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree_list\n\n    >>> f = ZZ.map([[1], [1, 2, 3]])\n\n    >>> dmp_degree_list(f, 1)\n    (1, 2)\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    degs = [-1] * (u + 1)\n    _rec_degree_list(f, u, 0, degs)\n    return tuple(degs)",
    "sympy.sympy.polys.densebasic.dmp_zero_p": "def dmp_zero_p(f: dmp[Er], u: int) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    \"\"\"\n    while u:\n        if len(f) != 1:\n            return False\n\n        f = f[0]\n        u -= 1\n\n    return not f",
    "sympy.sympy.polys.densebasic.dmp_one": "def dmp_one(u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Return a multivariate one over ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one\n\n    >>> dmp_one(2, ZZ)\n    [[[1]]]\n\n    \"\"\"\n    return dmp_ground(K.one, u, K)",
    "sympy.sympy.polys.densetools.dmp_eval_in": "def dmp_eval_in(f: dmp[Er], a: Er, j: int, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Evaluate a polynomial at ``x_j = a`` in ``K[X]`` using the Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 2*x*y + 3*x + y + 2\n\n    >>> R.dmp_eval_in(f, 2, 0)\n    5*y + 8\n    >>> R.dmp_eval_in(f, 2, 1)\n    7*x + 4\n\n    \"\"\"\n    if j < 0 or j > u:\n        raise IndexError(\"0 <= j <= %s expected, got %s\" % (u, j))\n\n    return _rec_eval_in(f, a, u, 0, j, K)",
    "sympy.sympy.polys.densetools.dmp_eval_tail": "def dmp_eval_tail(f: dmp[Er], A: list[Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Evaluate a polynomial at ``x_j = a_j, ...`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 2*x*y + 3*x + y + 2\n\n    >>> R.dmp_eval_tail(f, [2])\n    7*x + 4\n    >>> R.dmp_eval_tail(f, [2, 2])\n    18\n\n    \"\"\"\n    if not A:\n        return f\n\n    if dmp_zero_p(f, u):\n        return dmp_zero(u - len(A), K)\n\n    e = _rec_eval_tail(f, 0, A, u, K)\n\n    if u == len(A) - 1:\n        return e\n    else:\n        return dmp_strip(e, u - len(A), K)",
    "sympy.sympy.polys.densetools.dmp_diff_eval_in": "def dmp_diff_eval_in(f: dmp[Er], m: int, a: Er, j: int, u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Differentiate and evaluate a polynomial in ``x_j`` at ``a`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x*y**2 + 2*x*y + 3*x + 2*y**2 + 3*y + 1\n\n    >>> R.dmp_diff_eval_in(f, 1, 2, 0)\n    y**2 + 2*y + 3\n    >>> R.dmp_diff_eval_in(f, 1, 2, 1)\n    6*x + 11\n\n    \"\"\"\n    if j > u:\n        raise IndexError(\"-%s <= j < %s expected, got %s\" % (u, u, j))\n    if not j:\n        return dmp_eval(dmp_diff(f, m, u, K), a, u, K)\n\n    return _rec_diff_eval(f, m, a, u, 0, j, K)",
    "sympy.sympy.polys.densetools.dmp_ground_trunc": "def dmp_ground_trunc(f: dmp[Eeuclid], p: Eeuclid, u: int, K: Domain[Eeuclid]) -> dmp[Eeuclid]:\n    \"\"\"\n    Reduce a ``K[X]`` polynomial modulo a constant ``p`` in ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y + 8*x**2 + 5*x*y + 6*x + 2*y + 3\n\n    >>> R.dmp_ground_trunc(f, ZZ(3))\n    -x**2 - x*y - y\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_trunc(_dup(f), p, K))\n\n    v = u - 1\n\n    return dmp_strip([ dmp_ground_trunc(c, p, v, K) for c in f ], u, K)",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.integerring.factorial": "def factorial(self, a):\n    \"\"\"Compute factorial of ``a``. \"\"\"\n    return factorial(a)",
    "sympy.sympy.polys.factortools.dmp_zz_diophantine": "def dmp_zz_diophantine(F, c, A, d, p, u, K):\n    \"\"\"Wang/EEZ: Solve multivariate Diophantine equations. \"\"\"\n    if not A:\n        S = [ [] for _ in F ]\n        n = dup_degree(c)\n\n        for i, coeff in enumerate(c):\n            if not coeff:\n                continue\n\n            T = dup_zz_diophantine(F, n - i, p, K)\n\n            for j, (s, t) in enumerate(zip(S, T)):\n                t = dup_mul_ground(t, coeff, K)\n                S[j] = dup_trunc(dup_add(s, t, K), p, K)\n    else:\n        n = len(A)\n        e = dmp_expand(F, u, K)\n\n        a, A = A[-1], A[:-1]\n        B, G = [], []\n\n        for f in F:\n            B.append(dmp_quo(e, f, u, K))\n            G.append(dmp_eval_in(f, a, n, u, K))\n\n        C = dmp_eval_in(c, a, n, u, K)\n\n        v = u - 1\n\n        S = dmp_zz_diophantine(G, C, A, d, p, v, K)\n        S = [ dmp_raise(s, 1, v, K) for s in S ]\n\n        for s, b in zip(S, B):\n            c = dmp_sub_mul(c, s, b, u, K)\n\n        c = dmp_ground_trunc(c, p, u, K)\n\n        m = dmp_nest([K.one, -a], n, K)\n        M = dmp_one(n, K)\n\n        for k in range(0, d):\n            if dmp_zero_p(c, u):\n                break\n\n            M = dmp_mul(M, m, u, K)\n            C = dmp_diff_eval_in(c, k + 1, a, n, u, K)\n\n            if not dmp_zero_p(C, v):\n                C = dmp_quo_ground(C, K.factorial(K(k) + 1), v, K)\n                T = dmp_zz_diophantine(G, C, A, d, p, v, K)\n\n                for i, t in enumerate(T):\n                    T[i] = dmp_mul(dmp_raise(t, 1, v, K), M, u, K)\n\n                for i, (s, t) in enumerate(zip(S, T)):\n                    S[i] = dmp_add(s, t, u, K)\n\n                for t, b in zip(T, B):\n                    c = dmp_sub_mul(c, t, b, u, K)\n\n                c = dmp_ground_trunc(c, p, u, K)\n\n        S = [ dmp_ground_trunc(s, p, u, K) for s in S ]\n\n    return S"
}