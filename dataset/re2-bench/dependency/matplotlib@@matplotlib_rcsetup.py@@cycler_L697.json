{
    "matplotlib.lib.matplotlib._api.__init__.nargs_error": "def nargs_error(name, takes, given):\n    \"\"\"Generate a TypeError to be raised by function calls with wrong arity.\"\"\"\n    return TypeError(f\"{name}() takes {takes} positional arguments but \"\n                     f\"{given} were given\")",
    "matplotlib.lib.matplotlib.rcsetup.<genexpr>": "return reduce(operator.add, (ccycler(k, v) for k, v in validated))\n\n\n",
    "matplotlib.lib.matplotlib.rcsetup.validate_cycler": "def validate_cycler(s):\n    \"\"\"Return a Cycler object from a string repr or the object itself.\"\"\"\n    if isinstance(s, str):\n        # TODO: We might want to rethink this...\n        # While I think I have it quite locked down, it is execution of\n        # arbitrary code without sanitation.\n        # Combine this with the possibility that rcparams might come from the\n        # internet (future plans), this could be downright dangerous.\n        # I locked it down by only having the 'cycler()' function available.\n        # UPDATE: Partly plugging a security hole.\n        # I really should have read this:\n        # https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html\n        # We should replace this eval with a combo of PyParsing and\n        # ast.literal_eval()\n        try:\n            _DunderChecker().visit(ast.parse(s))\n            s = eval(s, {'cycler': cycler, '__builtins__': {}})\n        except BaseException as e:\n            raise ValueError(f\"{s!r} is not a valid cycler construction: {e}\"\n                             ) from e\n    # Should make sure what comes from the above eval()\n    # is a Cycler object.\n    if isinstance(s, Cycler):\n        cycler_inst = s\n    else:\n        raise ValueError(f\"Object is not a string or Cycler instance: {s!r}\")\n\n    unknowns = cycler_inst.keys - (set(_prop_validators) | set(_prop_aliases))\n    if unknowns:\n        raise ValueError(\"Unknown artist properties: %s\" % unknowns)\n\n    # Not a full validation, but it'll at least normalize property names\n    # A fuller validation would require v0.10 of cycler.\n    checker = set()\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        if norm_prop != prop and norm_prop in cycler_inst.keys:\n            raise ValueError(f\"Cannot specify both {norm_prop!r} and alias \"\n                             f\"{prop!r} in the same prop_cycle\")\n        if norm_prop in checker:\n            raise ValueError(f\"Another property was already aliased to \"\n                             f\"{norm_prop!r}. Collision normalizing {prop!r}.\")\n        checker.update([norm_prop])\n\n    # This is just an extra-careful check, just in case there is some\n    # edge-case I haven't thought of.\n    assert len(checker) == len(cycler_inst.keys)\n\n    # Now, it should be safe to mutate this cycler\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        cycler_inst.change_key(prop, norm_prop)\n\n    for key, vals in cycler_inst.by_key().items():\n        _prop_validators[key](vals)\n\n    return cycler_inst",
    "matplotlib.lib.matplotlib.rcsetup.f": "def f(s):\n    if isinstance(s, str):\n        try:\n            val = [scalar_validator(v.strip()) for v in s.split(',')\n                   if v.strip()]\n        except Exception:\n            if allow_stringlist:\n                # Special handling for colors\n                val = _single_string_color_list(s, scalar_validator)\n            else:\n                raise\n    # Allow any ordered sequence type -- generators, np.ndarray, pd.Series\n    # -- but not sets, whose iteration order is non-deterministic.\n    elif np.iterable(s) and not isinstance(s, (set, frozenset)):\n        # The condition on this list comprehension will preserve the\n        # behavior of filtering out any empty strings (behavior was\n        # from the original validate_stringlist()), while allowing\n        # any non-string/text scalar values such as numbers and arrays.\n        val = [scalar_validator(v) for v in s\n               if not isinstance(v, str) or v]\n    else:\n        raise ValueError(\n            f\"Expected str or other non-set iterable, but got {s}\")\n    if n is not None and len(val) != n:\n        raise ValueError(\n            f\"Expected {n} values, but there are {len(val)} values in {s}\")\n    return val"
}