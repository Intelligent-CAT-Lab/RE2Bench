{
    "sympy.sympy.core.add.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self. If radical is True (default is False) then\n    common radicals will be removed and included as a factor of the\n    primitive expression.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (3 + 3*sqrt(2)).as_content_primitive()\n    (3, 1 + sqrt(2))\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(\n        radical=radical, clear=clear)) for a in self.args]).primitive()\n    if not clear and not con.is_Integer and prim.is_Add:\n        con, d = con.as_numer_denom()\n        _p = prim/d\n        if any(a.as_coeff_Mul()[0].is_Integer for a in _p.args):\n            prim = _p\n        else:\n            con /= d\n    if radical and prim.is_Add:\n        # look for common radicals that can be removed\n        args = prim.args\n        rads = []\n        common_q = None\n        for m in args:\n            term_rads = defaultdict(list)\n            for ai in Mul.make_args(m):\n                if ai.is_Pow:\n                    b, e = ai.as_base_exp()\n                    if e.is_Rational and b.is_Integer:\n                        term_rads[e.q].append(abs(int(b))**e.p)\n            if not term_rads:\n                break\n            if common_q is None:\n                common_q = set(term_rads.keys())\n            else:\n                common_q = common_q & set(term_rads.keys())\n                if not common_q:\n                    break\n            rads.append(term_rads)\n        else:\n            # process rads\n            # keep only those in common_q\n            for r in rads:\n                for q in list(r.keys()):\n                    if q not in common_q:\n                        r.pop(q)\n                for q in r:\n                    r[q] = Mul(*r[q])\n            # find the gcd of bases for each q\n            G = []\n            for q in common_q:\n                g = reduce(igcd, [r[q] for r in rads], 0)\n                if g != 1:\n                    G.append(g**Rational(1, q))\n            if G:\n                G = Mul(*G)\n                args = [ai/G for ai in args]\n                prim = G*prim.func(*args)\n\n    return con, prim",
    "sympy.sympy.core.add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None) -> tuple[Number, Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a summation.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number and not rational or coeff.is_Rational:\n        return coeff, self._new_rawargs(*args) # type: ignore\n    return S.Zero, self",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.as_base_exp": "def as_base_exp(self) -> tuple[Expr, Expr]:\n    # a -> b ** e\n    return self, S.One",
    "sympy.sympy.core.expr.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"This method should recursively remove a Rational from all arguments\n    and return that (content) and the new self (primitive). The content\n    should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n    The primitive need not be in canonical form and should try to preserve\n    the underlying structure if possible (i.e. expand_mul should not be\n    applied to self).\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import x, y, z\n\n    >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n\n    The as_content_primitive function is recursive and retains structure:\n\n    >>> eq.as_content_primitive()\n    (2, x + 3*y*(y + 1) + 1)\n\n    Integer powers will have Rationals extracted from the base:\n\n    >>> ((2 + 6*x)**2).as_content_primitive()\n    (4, (3*x + 1)**2)\n    >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n    (1, (2*(3*x + 1))**(2*y))\n\n    Terms may end up joining once their as_content_primitives are added:\n\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (11, x*(y + 1))\n    >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n    (9, x*(y + 1))\n    >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n    (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n    >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n    (121, x**2*(y + 1)**2)\n    >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()\n    (1, 4.84*x**2*(y + 1)**2)\n\n    Radical content can also be factored out of the primitive:\n\n    >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n    (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n    If clear=False (default is True) then content will not be removed\n    from an Add if it can be distributed to leave one or more\n    terms with integer coefficients.\n\n    >>> (x/2 + y).as_content_primitive()\n    (1/2, x + 2*y)\n    >>> (x/2 + y).as_content_primitive(clear=False)\n    (1, x/2 + y)\n    \"\"\"\n    return S.One, self",
    "sympy.sympy.core.expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return S.One, self",
    "sympy.sympy.core.expr.as_coeff_Add": "def as_coeff_Add(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return S.Zero, self",
    "sympy.sympy.core.mul.as_base_exp": "def as_base_exp(self):\n    e1 = None\n    bases = []\n    nc = 0\n    for m in self.args:\n        b, e = m.as_base_exp()\n        if not b.is_commutative:\n            nc += 1\n        if e1 is None:\n            e1 = e\n        elif e != e1 or nc > 1 or not e.is_Integer:\n            return self, S.One\n        bases.append(b)\n    return self.func(*bases), e1",
    "sympy.sympy.core.mul.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n    (6, -sqrt(2)*(1 - sqrt(2)))\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    coef = S.One\n    args = []\n    for a in self.args:\n        c, p = a.as_content_primitive(radical=radical, clear=clear)\n        coef *= c\n        if p is not S.One:\n            args.append(p)\n    # don't use self._from_args here to reconstruct args\n    # since there may be identical args now that should be combined\n    # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n    return coef, self.func(*args)",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False) -> tuple['Number', Expr]:\n    \"\"\"\n    Efficiently extract the coefficient of a product.\n    \"\"\"\n    coeff, args = self.args[0], self.args[1:]\n\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return coeff, args[0] # type: ignore\n            else:\n                return coeff, self._new_rawargs(*args) # type: ignore\n        elif coeff.is_extended_negative:\n            return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n    return S.One, self",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> (S(-3)/2).as_content_primitive()\n    (3/2, -1)\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    if self:\n        if self.is_positive:\n            return self, S.One\n        return -self, S.NegativeOne\n    return S.One, self",
    "sympy.sympy.core.numbers.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a product.\"\"\"\n    return self, S.One",
    "sympy.sympy.core.numbers.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    \"\"\"Efficiently extract the coefficient of a summation.\"\"\"\n    return self, S.Zero",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.power.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n    extracted from self.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()\n    (2, sqrt(1 + sqrt(2)))\n    >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()\n    (1, sqrt(3)*sqrt(1 + sqrt(2)))\n\n    >>> from sympy import expand_power_base, powsimp, Mul\n    >>> from sympy.abc import x, y\n\n    >>> ((2*x + 2)**2).as_content_primitive()\n    (4, (x + 1)**2)\n    >>> (4**((1 + y)/2)).as_content_primitive()\n    (2, 4**(y/2))\n    >>> (3**((1 + y)/2)).as_content_primitive()\n    (1, 3**((y + 1)/2))\n    >>> (3**((5 + y)/2)).as_content_primitive()\n    (9, 3**((y + 1)/2))\n    >>> eq = 3**(2 + 2*x)\n    >>> powsimp(eq) == eq\n    True\n    >>> eq.as_content_primitive()\n    (9, 3**(2*x))\n    >>> powsimp(Mul(*_))\n    3**(2*x + 2)\n\n    >>> eq = (2 + 2*x)**y\n    >>> s = expand_power_base(eq); s.is_Mul, s\n    (False, (2*x + 2)**y)\n    >>> eq.as_content_primitive()\n    (1, (2*(x + 1))**y)\n    >>> s = expand_power_base(_[1]); s.is_Mul, s\n    (True, 2**y*(x + 1)**y)\n\n    See docstring of Expr.as_content_primitive for more examples.\n    \"\"\"\n\n    b, e = self.as_base_exp()\n    b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))\n    ce, pe = e.as_content_primitive(radical=radical, clear=clear)\n    if b.is_Rational:\n        #e\n        #= ce*pe\n        #= ce*(h + t)\n        #= ce*h + ce*t\n        #=> self\n        #= b**(ce*h)*b**(ce*t)\n        #= b**(cehp/cehq)*b**(ce*t)\n        #= b**(iceh + r/cehq)*b**(ce*t)\n        #= b**(iceh)*b**(r/cehq)*b**(ce*t)\n        #= b**(iceh)*b**(ce*t + r/cehq)\n        h, t = pe.as_coeff_Add()\n        if h.is_Rational and b != S.Zero:\n            ceh = ce*h\n            c = self.func(b, ceh)\n            r = S.Zero\n            if not c.is_Rational:\n                iceh, r = divmod(ceh.p, ceh.q)\n                c = self.func(b, iceh)\n            return c, self.func(b, _keep_coeff(ce, t + r/ce/ceh.q))\n    e = _keep_coeff(ce, pe)\n    # b**e = (h*t)**e = h**e*t**e = c*m*t**e\n    if e.is_Rational and b.is_Mul:\n        h, t = b.as_content_primitive(radical=radical, clear=clear)  # h is positive\n        c, m = self.func(h, e).as_coeff_Mul()  # so c is positive\n        m, me = m.as_base_exp()\n        if m is S.One or me == e:  # probably always true\n            # return the following, not return c, m*Pow(t, e)\n            # which would change Pow into Mul; we let SymPy\n            # decide what to do by using the unevaluated Mul, e.g\n            # should it stay as sqrt(2 + 2*sqrt(5)) or become\n            # sqrt(2)*sqrt(1 + sqrt(5))\n            return c, self.func(_keep_coeff(m, t), e)\n    return S.One, self.func(b, e)",
    "sympy.sympy.core.power.as_base_exp": "def as_base_exp(self):\n    \"\"\"Return base and exp of self.\n\n    Explanation\n    ===========\n\n    If base a Rational less than 1, then return 1/Rational, -exp.\n    If this extra processing is not needed, the base and exp\n    properties will give the raw arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import Pow, S\n    >>> p = Pow(S.Half, 2, evaluate=False)\n    >>> p.as_base_exp()\n    (2, -2)\n    >>> p.args\n    (1/2, 2)\n    >>> p.base, p.exp\n    (1/2, 2)\n\n    \"\"\"\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and b.q != 1:\n        return Integer(b.q), -e\n    return b, e"
}