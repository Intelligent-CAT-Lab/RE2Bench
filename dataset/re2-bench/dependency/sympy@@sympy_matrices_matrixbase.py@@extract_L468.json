{
    "sympy.sympy.matrices.matrixbase.<genexpr>": "if colsList and all(isinstance(i, bool) for i in colsList):\n    colsList = [index for index, item in enumerate(colsList) if item]\n\n# ensure everything is in range\n",
    "sympy.sympy.matrices.matrixbase.<listcomp>": "colsList = [a2idx(k, self.cols) for k in colsList]\n\n",
    "sympy.sympy.matrices.repmatrix._eval_extract": "def _eval_extract(self, rowsList, colsList):\n    return self._fromrep(self._rep.extract(rowsList, colsList))",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))"
}