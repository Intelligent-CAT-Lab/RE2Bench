{
    "matplotlib.lib.matplotlib._api.__init__.check_in_list": "def check_in_list(values, /, *, _print_supported_values=True, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is in *values*;\n    if not, raise an appropriate ValueError.\n\n    Parameters\n    ----------\n    values : iterable\n        Sequence of values to check on.\n\n        Note: All values must support == comparisons.\n        This means in particular the entries must not be numpy arrays.\n    _print_supported_values : bool, default: True\n        Whether to print *values* when raising ValueError.\n    **kwargs : dict\n        *key, value* pairs as keyword arguments to find in *values*.\n\n    Raises\n    ------\n    ValueError\n        If any *value* in *kwargs* is not found in *values*.\n\n    Examples\n    --------\n    >>> _api.check_in_list([\"foo\", \"bar\"], arg=arg, other_arg=other_arg)\n    \"\"\"\n    if not kwargs:\n        raise TypeError(\"No argument to check!\")\n    for key, val in kwargs.items():\n        try:\n            exists = val in values\n        except ValueError:\n            # `in` internally uses `val == values[i]`. There are some objects\n            # that do not support == to arbitrary other objects, in particular\n            # numpy arrays.\n            # Since such objects are not allowed in values, we can gracefully\n            # handle the case that val (typically provided by users) is of such\n            # type and directly state it's not in the list instead of letting\n            # the individual `val == values[i]` ValueError surface.\n            exists = False\n        if not exists:\n            msg = f\"{val!r} is not a valid value for {key}\"\n            if _print_supported_values:\n                msg += f\"; supported values are {', '.join(map(repr, values))}\"\n            raise ValueError(msg)",
    "matplotlib.lib.matplotlib.transforms.__add__": "def __add__(self, other):\n    \"\"\"\n    Compose two transforms together so that *self* is followed by *other*.\n\n    ``A + B`` returns a transform ``C`` so that\n    ``C.transform(x) == B.transform(A.transform(x))``.\n    \"\"\"\n    return (composite_transform_factory(self, other)\n            if isinstance(other, Transform) else\n            NotImplemented)",
    "matplotlib.lib.matplotlib.transforms.__init__": "def __init__(self, xt, yt, scale_trans, **kwargs):\n    super().__init__(**kwargs)\n    self._t = (xt, yt)\n    self._scale_trans = scale_trans\n    self.set_children(scale_trans)\n    self._mtx = None\n    self._inverted = None"
}