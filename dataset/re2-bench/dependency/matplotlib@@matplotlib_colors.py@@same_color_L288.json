{
    "matplotlib.lib.matplotlib.colors.to_rgba_array": "def to_rgba_array(c, alpha=None):\n    \"\"\"\n    Convert *c* to a (n, 4) array of RGBA colors.\n\n    Parameters\n    ----------\n    c : :mpltype:`color` or list of :mpltype:`color` or RGB(A) array\n        If *c* is a masked array, an `~numpy.ndarray` is returned with a\n        (0, 0, 0, 0) row for each masked value or row in *c*.\n\n    alpha : float or sequence of floats, optional\n        If *alpha* is given, force the alpha value of the returned RGBA tuple\n        to *alpha*.\n\n        If None, the alpha value from *c* is used. If *c* does not have an\n        alpha channel, then alpha defaults to 1.\n\n        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n        which always maps to ``(0, 0, 0, 0)``.\n\n        If *alpha* is a sequence and *c* is a single color, *c* will be\n        repeated to match the length of *alpha*.\n\n    Returns\n    -------\n    array\n        (n, 4) array of RGBA colors,  where each channel (red, green, blue,\n        alpha) can assume values between 0 and 1.\n    \"\"\"\n    if isinstance(c, tuple) and len(c) == 2 and isinstance(c[1], Real):\n        if alpha is None:\n            c, alpha = c\n        else:\n            c = c[0]\n    # Special-case inputs that are already arrays, for performance.  (If the\n    # array has the wrong kind or shape, raise the error during one-at-a-time\n    # conversion.)\n    if np.iterable(alpha):\n        alpha = np.asarray(alpha).ravel()\n    if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n            and c.ndim == 2 and c.shape[1] in [3, 4]):\n        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n        c = np.ma.getdata(c)\n        if np.iterable(alpha):\n            if c.shape[0] == 1 and alpha.shape[0] > 1:\n                c = np.tile(c, (alpha.shape[0], 1))\n            elif c.shape[0] != alpha.shape[0]:\n                raise ValueError(\"The number of colors must match the number\"\n                                 \" of alpha values if there are more than one\"\n                                 \" of each.\")\n        if c.shape[1] == 3:\n            result = np.column_stack([c, np.zeros(len(c))])\n            result[:, -1] = alpha if alpha is not None else 1.\n        elif c.shape[1] == 4:\n            result = c.copy()\n            if alpha is not None:\n                result[:, -1] = alpha\n        if mask is not None:\n            result[mask] = 0\n        if np.any((result < 0) | (result > 1)):\n            raise ValueError(\"RGBA values should be within 0-1 range\")\n        return result\n    # Handle single values.\n    # Note that this occurs *after* handling inputs that are already arrays, as\n    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n    # to format the array in the ValueError message(!).\n    if cbook._str_lower_equal(c, \"none\"):\n        return np.zeros((0, 4), float)\n    try:\n        if np.iterable(alpha):\n            return np.array([to_rgba(c, a) for a in alpha], float)\n        else:\n            return np.array([to_rgba(c, alpha)], float)\n    except TypeError:\n        pass\n    except ValueError as e:\n        if e.args == (\"'alpha' must be between 0 and 1, inclusive\", ):\n            # ValueError is from _to_rgba_no_colorcycle().\n            raise e\n    if isinstance(c, str):\n        raise ValueError(f\"{c!r} is not a valid color value.\")\n\n    if len(c) == 0:\n        return np.zeros((0, 4), float)\n\n    # Quick path if the whole sequence can be directly converted to a numpy\n    # array in one shot.\n    if isinstance(c, Sequence):\n        lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n        if lens == {3}:\n            rgba = np.column_stack([c, np.ones(len(c))])\n        elif lens == {4}:\n            rgba = np.array(c)\n        else:\n            rgba = np.array([to_rgba(cc) for cc in c])\n    else:\n        rgba = np.array([to_rgba(cc) for cc in c])\n\n    if alpha is not None:\n        rgba[:, 3] = alpha\n        if isinstance(c, Sequence):\n            # ensure that an explicit alpha does not overwrite full transparency\n            # for \"none\"\n            none_mask = [cbook._str_equal(cc, \"none\") for cc in c]\n            rgba[:, 3][none_mask] = 0\n    return rgba"
}