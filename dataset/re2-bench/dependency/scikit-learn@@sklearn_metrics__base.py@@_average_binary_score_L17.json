{
    "scikit-learn.sklearn.metrics._ranking._binary_uninterpolated_average_precision": "def _binary_uninterpolated_average_precision(\n    y_true, y_score, pos_label=1, sample_weight=None\n):\n    precision, recall, _ = precision_recall_curve(\n        y_true, y_score, pos_label=pos_label, sample_weight=sample_weight\n    )\n    # Return the step function integral\n    # The following works because the last entry of precision is\n    # guaranteed to be 1, as returned by precision_recall_curve.\n    # Due to numerical error, we can get `-0.0` and we therefore clip it.\n    return float(max(0.0, -np.sum(np.diff(recall) * np.array(precision)[:-1])))",
    "scikit-learn.sklearn.metrics._ranking._binary_roc_auc_score": "def _binary_roc_auc_score(y_true, y_score, sample_weight=None, max_fpr=None):\n    \"\"\"Binary roc auc score.\"\"\"\n    if len(np.unique(y_true)) != 2:\n        warnings.warn(\n            (\n                \"Only one class is present in y_true. ROC AUC score \"\n                \"is not defined in that case.\"\n            ),\n            UndefinedMetricWarning,\n        )\n        return np.nan\n\n    fpr, tpr, _ = roc_curve(y_true, y_score, sample_weight=sample_weight)\n    if max_fpr is None or max_fpr == 1:\n        return auc(fpr, tpr)\n    if max_fpr <= 0 or max_fpr > 1:\n        raise ValueError(\"Expected max_fpr in range (0, 1], got: %r\" % max_fpr)\n\n    # Add a single point at max_fpr by linear interpolation\n    stop = np.searchsorted(fpr, max_fpr, \"right\")\n    x_interp = [fpr[stop - 1], fpr[stop]]\n    y_interp = [tpr[stop - 1], tpr[stop]]\n    tpr = np.append(tpr[:stop], np.interp(max_fpr, x_interp, y_interp))\n    fpr = np.append(fpr[:stop], max_fpr)\n    partial_auc = auc(fpr, tpr)\n\n    # McClish correction: standardize result to be 0.5 if non-discriminant\n    # and 1 if maximal\n    min_area = 0.5 * max_fpr**2\n    max_area = max_fpr\n    return 0.5 * (1 + (partial_auc - min_area) / (max_area - min_area))",
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e",
    "scikit-learn.sklearn.utils.multiclass.type_of_target": "def type_of_target(y, input_name=\"\", raise_unknown=False):\n    \"\"\"Determine the type of data indicated by the target.\n\n    Note that this type is the most specific type that can be inferred.\n    For example:\n\n    * ``binary`` is more specific but compatible with ``multiclass``.\n    * ``multiclass`` of integers is more specific but compatible with ``continuous``.\n    * ``multilabel-indicator`` is more specific but compatible with\n      ``multiclass-multioutput``.\n\n    Parameters\n    ----------\n    y : {array-like, sparse matrix}\n        Target values. If a sparse matrix, `y` is expected to be a\n        CSR/CSC matrix.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message.\n\n        .. versionadded:: 1.1.0\n\n    raise_unknown : bool, default=False\n        If `True`, raise an error when the type of target returned by\n        :func:`~sklearn.utils.multiclass.type_of_target` is `\"unknown\"`.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    target_type : str\n        One of:\n\n        * 'continuous': `y` is an array-like of floats that are not all\n          integers, and is 1d or a column vector.\n        * 'continuous-multioutput': `y` is a 2d array of floats that are\n          not all integers, and both dimensions are of size > 1.\n        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n          vector.\n        * 'multiclass': `y` contains more than two discrete values, is not a\n          sequence of sequences, and is 1d or a column vector.\n        * 'multiclass-multioutput': `y` is a 2d array that contains more\n          than two discrete values, is not a sequence of sequences, and both\n          dimensions are of size > 1.\n        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n          of two dimensions with at least two columns, and at most 2 unique\n          values.\n        * 'unknown': `y` is array-like but none of the above, such as a 3d\n          array, sequence of sequences, or an array of non-sequence objects.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import type_of_target\n    >>> import numpy as np\n    >>> type_of_target([0.1, 0.6])\n    'continuous'\n    >>> type_of_target([1, -1, -1, 1])\n    'binary'\n    >>> type_of_target(['a', 'b', 'a'])\n    'binary'\n    >>> type_of_target([1.0, 2.0])\n    'binary'\n    >>> type_of_target([1, 0, 2])\n    'multiclass'\n    >>> type_of_target([1.0, 0.0, 3.0])\n    'multiclass'\n    >>> type_of_target(['a', 'b', 'c'])\n    'multiclass'\n    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n    'multiclass-multioutput'\n    >>> type_of_target([[1, 2]])\n    'multilabel-indicator'\n    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n    'continuous-multioutput'\n    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n    'multilabel-indicator'\n    \"\"\"\n    xp, is_array_api_compliant = get_namespace(y)\n\n    def _raise_or_return():\n        \"\"\"Depending on the value of raise_unknown, either raise an error or return\n        'unknown'.\n        \"\"\"\n        if raise_unknown:\n            input = input_name if input_name else \"data\"\n            raise ValueError(f\"Unknown label type for {input}: {y!r}\")\n        else:\n            return \"unknown\"\n\n    valid = (\n        (isinstance(y, Sequence) or issparse(y) or hasattr(y, \"__array__\"))\n        and not isinstance(y, str)\n    ) or is_array_api_compliant\n\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    check_y_kwargs = dict(\n        accept_sparse=True,\n        allow_nd=True,\n        ensure_all_finite=False,\n        ensure_2d=False,\n        ensure_min_samples=0,\n        ensure_min_features=0,\n    )\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                y = check_array(y, dtype=None, **check_y_kwargs)\n            except (VisibleDeprecationWarning, ValueError) as e:\n                if str(e).startswith(\"Complex data not supported\"):\n                    raise\n\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = check_array(y, dtype=object, **check_y_kwargs)\n\n    try:\n        first_row_or_val = y[[0], :] if issparse(y) else y[0]\n        # labels in bytes format\n        if isinstance(first_row_or_val, bytes):\n            raise TypeError(\n                \"Support for labels represented as bytes is not supported. Convert \"\n                \"the labels to a string or integer format.\"\n            )\n        # The old sequence of sequences format\n        if (\n            not hasattr(first_row_or_val, \"__array__\")\n            and isinstance(first_row_or_val, Sequence)\n            and not isinstance(first_row_or_val, str)\n        ):\n            raise ValueError(\n                \"You appear to be using a legacy multi-label data\"\n                \" representation. Sequence of sequences are no\"\n                \" longer supported; use a binary array or sparse\"\n                \" matrix instead - the MultiLabelBinarizer\"\n                \" transformer can convert to this format.\"\n            )\n    except IndexError:\n        pass\n\n    # Invalid inputs\n    if y.ndim not in (1, 2):\n        # Number of dimension greater than 2: [[[1, 2]]]\n        return _raise_or_return()\n    if not min(y.shape):\n        # Empty ndarray: []/[[]]\n        if y.ndim == 1:\n            # 1-D empty array: []\n            return \"binary\"  # []\n        # 2-D empty array: [[]]\n        return _raise_or_return()\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return _raise_or_return()\n\n    # Check if multioutput\n    if y.ndim == 2 and y.shape[1] > 1:\n        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n    else:\n        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n\n    # Check float and contains non-integer float values\n    if xp.isdtype(y.dtype, \"real floating\"):\n        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n        data = y.data if issparse(y) else y\n        integral_data = xp.astype(data, xp.int64)\n        # conversion back to the original float dtype of y is required to\n        # satisfy array-api-strict which does not allow a comparison between\n        # arrays having different dtypes.\n        if xp.any(data != xp.astype(integral_data, y.dtype)):\n            _assert_all_finite(data, input_name=input_name)\n            return \"continuous\" + suffix\n\n    # Check multiclass\n    if issparse(first_row_or_val):\n        first_row_or_val = first_row_or_val.data\n    if cached_unique(y).shape[0] > 2 or (y.ndim == 2 and len(first_row_or_val) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]",
    "scikit-learn.sklearn.utils.validation.check_consistent_length": "def check_consistent_length(*arrays):\n    \"\"\"Check that all arrays have consistent first dimensions.\n\n    Checks whether all objects in arrays have the same shape or length.\n\n    Parameters\n    ----------\n    *arrays : list or tuple of input objects.\n        Objects that will be checked for consistent length.\n\n    Examples\n    --------\n    >>> from sklearn.utils.validation import check_consistent_length\n    >>> a = [1, 2, 3]\n    >>> b = [2, 3, 4]\n    >>> check_consistent_length(a, b)\n    \"\"\"\n    lengths = [_num_samples(X) for X in arrays if X is not None]\n    if len(set(lengths)) > 1:\n        raise ValueError(\n            \"Found input variables with inconsistent numbers of samples: %r\"\n            % [int(l) for l in lengths]\n        )",
    "scikit-learn.sklearn.utils.validation.check_array": "def check_array(\n    array,\n    accept_sparse=False,\n    *,\n    accept_large_sparse=True,\n    dtype=\"numeric\",\n    order=None,\n    copy=False,\n    force_writeable=False,\n    ensure_all_finite=True,\n    ensure_non_negative=False,\n    ensure_2d=True,\n    allow_nd=False,\n    ensure_min_samples=1,\n    ensure_min_features=1,\n    estimator=None,\n    input_name=\"\",\n):\n    \"\"\"Input validation on an array, list, sparse matrix or similar.\n\n    By default, the input is checked to be a non-empty 2D array containing\n    only finite values. If the dtype of the array is object, attempt\n    converting to float, raising on failure.\n\n    Parameters\n    ----------\n    array : object\n        Input object to check / convert.\n\n    accept_sparse : str, bool or list/tuple of str, default=False\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n\n    accept_large_sparse : bool, default=True\n        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by\n        accept_sparse, accept_large_sparse=False will cause it to be accepted\n        only if its indices are stored with a 32-bit dtype.\n\n        .. versionadded:: 0.20\n\n    dtype : 'numeric', type, list of type or None, default='numeric'\n        Data type of result. If None, the dtype of the input is preserved.\n        If \"numeric\", dtype is preserved unless array.dtype is object.\n        If dtype is a list of types, conversion on the first type is only\n        performed if the dtype of the input is not in the list.\n\n    order : {'F', 'C'} or None, default=None\n        Whether an array will be forced to be fortran or c-style.\n        When order is None (default), then if copy=False, nothing is ensured\n        about the memory layout of the output array; otherwise (copy=True)\n        the memory layout of the returned array is kept as close as possible\n        to the original array.\n\n    copy : bool, default=False\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n    force_writeable : bool, default=False\n        Whether to force the output array to be writeable. If True, the returned array\n        is guaranteed to be writeable, which may require a copy. Otherwise the\n        writeability of the input array is preserved.\n\n        .. versionadded:: 1.6\n\n    ensure_all_finite : bool or 'allow-nan', default=True\n        Whether to raise an error on np.inf, np.nan, pd.NA in array. The\n        possibilities are:\n\n        - True: Force all values of array to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in array.\n        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values\n          cannot be infinite.\n\n        .. versionadded:: 1.6\n           `force_all_finite` was renamed to `ensure_all_finite`.\n\n    ensure_non_negative : bool, default=False\n        Make sure the array has only non-negative values. If True, an array that\n        contains negative values will raise a ValueError.\n\n        .. versionadded:: 1.6\n\n    ensure_2d : bool, default=True\n        Whether to raise a value error if array is not 2D.\n\n    allow_nd : bool, default=False\n        Whether to allow array.ndim > 2.\n\n    ensure_min_samples : int, default=1\n        Make sure that the array has a minimum number of samples in its first\n        axis (rows for a 2D array). Setting to 0 disables this check.\n\n    ensure_min_features : int, default=1\n        Make sure that the 2D array has some minimum number of features\n        (columns). The default value of 1 rejects empty datasets.\n        This check is only enforced when the input data has effectively 2\n        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0\n        disables this check.\n\n    estimator : str or estimator instance, default=None\n        If passed, include the name of the estimator in warning messages.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message. In particular\n        if `input_name` is \"X\" and the data has NaN values and\n        allow_nan is False, the error message will link to the imputer\n        documentation.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    array_converted : object\n        The converted and validated array.\n\n    Examples\n    --------\n    >>> from sklearn.utils.validation import check_array\n    >>> X = [[1, 2, 3], [4, 5, 6]]\n    >>> X_checked = check_array(X)\n    >>> X_checked\n    array([[1, 2, 3], [4, 5, 6]])\n    \"\"\"\n    if isinstance(array, np.matrix):\n        raise TypeError(\n            \"np.matrix is not supported. Please convert to a numpy array with \"\n            \"np.asarray. For more information see: \"\n            \"https://numpy.org/doc/stable/reference/generated/numpy.matrix.html\"\n        )\n\n    xp, is_array_api_compliant = get_namespace(array)\n\n    # store reference to original array to check if copy is needed when\n    # function returns\n    array_orig = array\n\n    # store whether originally we wanted numeric dtype\n    dtype_numeric = isinstance(dtype, str) and dtype == \"numeric\"\n\n    dtype_orig = getattr(array, \"dtype\", None)\n    if not is_array_api_compliant and not hasattr(dtype_orig, \"kind\"):\n        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n        dtype_orig = None\n\n    # check if the object contains several dtypes (typically a pandas\n    # DataFrame), and store them. If not, store None.\n    dtypes_orig = None\n    pandas_requires_conversion = False\n    # track if we have a Series-like object to raise a better error message\n    type_if_series = None\n    if hasattr(array, \"dtypes\") and hasattr(array.dtypes, \"__array__\"):\n        # throw warning if columns are sparse. If all columns are sparse, then\n        # array.sparse exists and sparsity will be preserved (later).\n        with suppress(ImportError):\n            from pandas import SparseDtype\n\n            def is_sparse(dtype):\n                return isinstance(dtype, SparseDtype)\n\n            if not hasattr(array, \"sparse\") and array.dtypes.apply(is_sparse).any():\n                warnings.warn(\n                    \"pandas.DataFrame with sparse columns found.\"\n                    \"It will be converted to a dense numpy array.\"\n                )\n\n        dtypes_orig = list(array.dtypes)\n        pandas_requires_conversion = any(\n            _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig\n        )\n        if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):\n            dtype_orig = np.result_type(*dtypes_orig)\n        elif pandas_requires_conversion and any(d == object for d in dtypes_orig):\n            # Force object if any of the dtypes is an object\n            dtype_orig = object\n\n    elif (_is_extension_array_dtype(array) or hasattr(array, \"iloc\")) and hasattr(\n        array, \"dtype\"\n    ):\n        # array is a pandas series\n        type_if_series = type(array)\n        pandas_requires_conversion = _pandas_dtype_needs_early_conversion(array.dtype)\n        if isinstance(array.dtype, np.dtype):\n            dtype_orig = array.dtype\n        else:\n            # Set to None to let array.astype work out the best dtype\n            dtype_orig = None\n\n    if dtype_numeric:\n        if (\n            dtype_orig is not None\n            and hasattr(dtype_orig, \"kind\")\n            and dtype_orig.kind == \"O\"\n        ):\n            # if input is object, convert to float.\n            dtype = xp.float64\n        else:\n            dtype = None\n\n    if isinstance(dtype, (list, tuple)):\n        if dtype_orig is not None and dtype_orig in dtype:\n            # no dtype conversion required\n            dtype = None\n        else:\n            # dtype conversion required. Let's select the first element of the\n            # list of accepted types.\n            dtype = dtype[0]\n\n    if pandas_requires_conversion:\n        # pandas dataframe requires conversion earlier to handle extension dtypes with\n        # nans\n        # Use the original dtype for conversion if dtype is None\n        new_dtype = dtype_orig if dtype is None else dtype\n        array = array.astype(new_dtype)\n        # Since we converted here, we do not need to convert again later\n        dtype = None\n\n    if ensure_all_finite not in (True, False, \"allow-nan\"):\n        raise ValueError(\n            \"ensure_all_finite should be a bool or 'allow-nan'. Got \"\n            f\"{ensure_all_finite!r} instead.\"\n        )\n\n    if dtype is not None and _is_numpy_namespace(xp):\n        # convert to dtype object to conform to Array API to be use `xp.isdtype` later\n        dtype = np.dtype(dtype)\n\n    estimator_name = _check_estimator_name(estimator)\n    context = \" by %s\" % estimator_name if estimator is not None else \"\"\n\n    # When all dataframe columns are sparse, convert to a sparse array\n    if hasattr(array, \"sparse\") and array.ndim > 1:\n        with suppress(ImportError):\n            from pandas import SparseDtype\n\n            def is_sparse(dtype):\n                return isinstance(dtype, SparseDtype)\n\n            if array.dtypes.apply(is_sparse).all():\n                # DataFrame.sparse only supports `to_coo`\n                array = array.sparse.to_coo()\n                if array.dtype == np.dtype(\"object\"):\n                    unique_dtypes = set([dt.subtype.name for dt in array_orig.dtypes])\n                    if len(unique_dtypes) > 1:\n                        raise ValueError(\n                            \"Pandas DataFrame with mixed sparse extension arrays \"\n                            \"generated a sparse matrix with object dtype which \"\n                            \"can not be converted to a scipy sparse matrix.\"\n                            \"Sparse extension arrays should all have the same \"\n                            \"numeric type.\"\n                        )\n\n    if sp.issparse(array):\n        _ensure_no_complex_data(array)\n        array = _ensure_sparse_format(\n            array,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            ensure_all_finite=ensure_all_finite,\n            accept_large_sparse=accept_large_sparse,\n            estimator_name=estimator_name,\n            input_name=input_name,\n        )\n        if ensure_2d and array.ndim < 2:\n            raise ValueError(\n                f\"Expected 2D input, got input with shape {array.shape}.\\n\"\n                \"Reshape your data either using array.reshape(-1, 1) if \"\n                \"your data has a single feature or array.reshape(1, -1) \"\n                \"if it contains a single sample.\"\n            )\n    else:\n        # If np.array(..) gives ComplexWarning, then we convert the warning\n        # to an error. This is needed because specifying a non complex\n        # dtype to the function converts complex to real dtype,\n        # thereby passing the test made in the lines following the scope\n        # of warnings context manager.\n        with warnings.catch_warnings():\n            try:\n                warnings.simplefilter(\"error\", ComplexWarning)\n                if dtype is not None and xp.isdtype(dtype, \"integral\"):\n                    # Conversion float -> int should not contain NaN or\n                    # inf (numpy#14412). We cannot use casting='safe' because\n                    # then conversion float -> int would be disallowed.\n                    array = _asarray_with_order(array, order=order, xp=xp)\n                    if xp.isdtype(array.dtype, (\"real floating\", \"complex floating\")):\n                        _assert_all_finite(\n                            array,\n                            allow_nan=False,\n                            msg_dtype=dtype,\n                            estimator_name=estimator_name,\n                            input_name=input_name,\n                        )\n                    array = xp.astype(array, dtype, copy=False)\n                else:\n                    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n            except ComplexWarning as complex_warning:\n                raise ValueError(\n                    \"Complex data not supported\\n{}\\n\".format(array)\n                ) from complex_warning\n\n        # It is possible that the np.array(..) gave no warning. This happens\n        # when no dtype conversion happened, for example dtype = None. The\n        # result is that np.array(..) produces an array of complex dtype\n        # and we need to catch and raise exception for such cases.\n        _ensure_no_complex_data(array)\n\n        if ensure_2d:\n            # If input is scalar raise error\n            if array.ndim == 0:\n                raise ValueError(\n                    \"Expected 2D array, got scalar array instead:\\narray={}.\\n\"\n                    \"Reshape your data either using array.reshape(-1, 1) if \"\n                    \"your data has a single feature or array.reshape(1, -1) \"\n                    \"if it contains a single sample.\".format(array)\n                )\n            # If input is 1D raise error\n            if array.ndim == 1:\n                # If input is a Series-like object (eg. pandas Series or polars Series)\n                if type_if_series is not None:\n                    msg = (\n                        f\"Expected a 2-dimensional container but got {type_if_series} \"\n                        \"instead. Pass a DataFrame containing a single row (i.e. \"\n                        \"single sample) or a single column (i.e. single feature) \"\n                        \"instead.\"\n                    )\n                else:\n                    msg = (\n                        f\"Expected 2D array, got 1D array instead:\\narray={array}.\\n\"\n                        \"Reshape your data either using array.reshape(-1, 1) if \"\n                        \"your data has a single feature or array.reshape(1, -1) \"\n                        \"if it contains a single sample.\"\n                    )\n                raise ValueError(msg)\n\n        if dtype_numeric and hasattr(array.dtype, \"kind\") and array.dtype.kind in \"USV\":\n            raise ValueError(\n                \"dtype='numeric' is not compatible with arrays of bytes/strings.\"\n                \"Convert your data to numeric values explicitly instead.\"\n            )\n        if not allow_nd and array.ndim >= 3:\n            raise ValueError(\n                f\"Found array with dim {array.ndim},\"\n                f\" while dim <= 2 is required{context}.\"\n            )\n\n        if ensure_all_finite:\n            _assert_all_finite(\n                array,\n                input_name=input_name,\n                estimator_name=estimator_name,\n                allow_nan=ensure_all_finite == \"allow-nan\",\n            )\n\n        if copy:\n            if _is_numpy_namespace(xp):\n                # only make a copy if `array` and `array_orig` may share memory`\n                if np.may_share_memory(array, array_orig):\n                    array = _asarray_with_order(\n                        array, dtype=dtype, order=order, copy=True, xp=xp\n                    )\n            else:\n                # always make a copy for non-numpy arrays\n                array = _asarray_with_order(\n                    array, dtype=dtype, order=order, copy=True, xp=xp\n                )\n\n    if ensure_min_samples > 0:\n        n_samples = _num_samples(array)\n        if n_samples < ensure_min_samples:\n            raise ValueError(\n                \"Found array with %d sample(s) (shape=%s) while a\"\n                \" minimum of %d is required%s.\"\n                % (n_samples, array.shape, ensure_min_samples, context)\n            )\n\n    if ensure_min_features > 0 and array.ndim == 2:\n        n_features = array.shape[1]\n        if n_features < ensure_min_features:\n            raise ValueError(\n                \"Found array with %d feature(s) (shape=%s) while\"\n                \" a minimum of %d is required%s.\"\n                % (n_features, array.shape, ensure_min_features, context)\n            )\n\n    if ensure_non_negative:\n        whom = input_name\n        if estimator_name:\n            whom += f\" in {estimator_name}\"\n        check_non_negative(array, whom)\n\n    if force_writeable:\n        # By default, array.copy() creates a C-ordered copy. We set order=K to\n        # preserve the order of the array.\n        copy_params = {\"order\": \"K\"} if not sp.issparse(array) else {}\n\n        array_data = array.data if sp.issparse(array) else array\n        flags = getattr(array_data, \"flags\", None)\n        if not getattr(flags, \"writeable\", True):\n            # This situation can only happen when copy=False, the array is read-only and\n            # a writeable output is requested. This is an ambiguous setting so we chose\n            # to always (except for one specific setting, see below) make a copy to\n            # ensure that the output is writeable, even if avoidable, to not overwrite\n            # the user's data by surprise.\n\n            if _is_pandas_df_or_series(array_orig):\n                try:\n                    # In pandas >= 3, np.asarray(df), called earlier in check_array,\n                    # returns a read-only intermediate array. It can be made writeable\n                    # safely without copy because if the original DataFrame was backed\n                    # by a read-only array, trying to change the flag would raise an\n                    # error, in which case we make a copy.\n                    array_data.flags.writeable = True\n                except ValueError:\n                    array = array.copy(**copy_params)\n            else:\n                array = array.copy(**copy_params)\n\n    return array"
}