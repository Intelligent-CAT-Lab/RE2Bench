{
    "matplotlib.lib.matplotlib.bezier.split_path_inout": "def split_path_inout(path, inside, tolerance=0.01, reorder_inout=False):\n    \"\"\"\n    Divide a path into two segments at the point where ``inside(x, y)`` becomes\n    False.\n    \"\"\"\n    from .path import Path\n    path_iter = path.iter_segments()\n\n    ctl_points, command = next(path_iter)\n    begin_inside = inside(ctl_points[-2:])  # true if begin point is inside\n\n    ctl_points_old = ctl_points\n\n    iold = 0\n    i = 1\n\n    for ctl_points, command in path_iter:\n        iold = i\n        i += len(ctl_points) // 2\n        if inside(ctl_points[-2:]) != begin_inside:\n            bezier_path = np.concatenate([ctl_points_old[-2:], ctl_points])\n            break\n        ctl_points_old = ctl_points\n    else:\n        raise ValueError(\"The path does not intersect with the patch\")\n\n    bp = bezier_path.reshape((-1, 2))\n    left, right = split_bezier_intersecting_with_closedpath(\n        bp, inside, tolerance)\n    if len(left) == 2:\n        codes_left = [Path.LINETO]\n        codes_right = [Path.MOVETO, Path.LINETO]\n    elif len(left) == 3:\n        codes_left = [Path.CURVE3, Path.CURVE3]\n        codes_right = [Path.MOVETO, Path.CURVE3, Path.CURVE3]\n    elif len(left) == 4:\n        codes_left = [Path.CURVE4, Path.CURVE4, Path.CURVE4]\n        codes_right = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]\n    else:\n        raise AssertionError(\"This should never be reached\")\n\n    verts_left = left[1:]\n    verts_right = right[:]\n\n    if path.codes is None:\n        path_in = Path(np.concatenate([path.vertices[:i], verts_left]))\n        path_out = Path(np.concatenate([verts_right, path.vertices[i:]]))\n\n    else:\n        path_in = Path(np.concatenate([path.vertices[:iold], verts_left]),\n                       np.concatenate([path.codes[:iold], codes_left]))\n\n        path_out = Path(np.concatenate([verts_right, path.vertices[i:]]),\n                        np.concatenate([codes_right, path.codes[i:]]))\n\n    if reorder_inout and not begin_inside:\n        path_in, path_out = path_out, path_in\n\n    return path_in, path_out",
    "matplotlib.lib.matplotlib.path.iter_segments": "def iter_segments(self, transform=None, remove_nans=True, clip=None,\n                  snap=False, stroke_width=1.0, simplify=None,\n                  curves=True, sketch=None):\n    \"\"\"\n    Iterate over all curve segments in the path.\n\n    Each iteration returns a pair ``(vertices, code)``, where ``vertices``\n    is a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\n    Additionally, this method can provide a number of standard cleanups and\n    conversions to the path.\n\n    Parameters\n    ----------\n    transform : None or :class:`~matplotlib.transforms.Transform`\n        If not None, the given affine transformation will be applied to the\n        path.\n    remove_nans : bool, optional\n        Whether to remove all NaNs from the path and skip over them using\n        MOVETO commands.\n    clip : None or (float, float, float, float), optional\n        If not None, must be a four-tuple (x1, y1, x2, y2)\n        defining a rectangle in which to clip the path.\n    snap : None or bool, optional\n        If True, snap all nodes to pixels; if False, don't snap them.\n        If None, snap if the path contains only segments\n        parallel to the x or y axes, and no more than 1024 of them.\n    stroke_width : float, optional\n        The width of the stroke being drawn (used for path snapping).\n    simplify : None or bool, optional\n        Whether to simplify the path by removing vertices\n        that do not affect its appearance.  If None, use the\n        :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n        and :rc:`path.simplify_threshold`.\n    curves : bool, optional\n        If True, curve segments will be returned as curve segments.\n        If False, all curves will be converted to line segments.\n    sketch : None or sequence, optional\n        If not None, must be a 3-tuple of the form\n        (scale, length, randomness), representing the sketch parameters.\n    \"\"\"\n    if not len(self):\n        return\n\n    cleaned = self.cleaned(transform=transform,\n                           remove_nans=remove_nans, clip=clip,\n                           snap=snap, stroke_width=stroke_width,\n                           simplify=simplify, curves=curves,\n                           sketch=sketch)\n\n    # Cache these object lookups for performance in the loop.\n    NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE\n    STOP = self.STOP\n\n    vertices = iter(cleaned.vertices)\n    codes = iter(cleaned.codes)\n    for curr_vertices, code in zip(vertices, codes):\n        if code == STOP:\n            break\n        extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1\n        if extra_vertices:\n            for i in range(extra_vertices):\n                next(codes)\n                curr_vertices = np.append(curr_vertices, next(vertices))\n        yield curr_vertices, code"
}