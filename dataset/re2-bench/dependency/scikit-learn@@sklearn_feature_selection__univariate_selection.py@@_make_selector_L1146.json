{
    "scikit-learn.sklearn.base._get_param_names": "@classmethod\ndef _get_param_names(cls):\n    \"\"\"Get parameter names for the estimator\"\"\"\n    # fetch the constructor or the original constructor before\n    # deprecation wrapping if any\n    init = getattr(cls.__init__, \"deprecated_original\", cls.__init__)\n    if init is object.__init__:\n        # No explicit constructor to introspect\n        return []\n\n    # introspect the constructor arguments to find the model parameters\n    # to represent\n    init_signature = inspect.signature(init)\n    # Consider the constructor parameters excluding 'self'\n    parameters = [\n        p\n        for p in init_signature.parameters.values()\n        if p.name != \"self\" and p.kind != p.VAR_KEYWORD\n    ]\n    for p in parameters:\n        if p.kind == p.VAR_POSITIONAL:\n            raise RuntimeError(\n                \"scikit-learn estimators should always \"\n                \"specify their parameters in the signature\"\n                \" of their __init__ (no varargs).\"\n                \" %s with constructor %s doesn't \"\n                \" follow this convention.\" % (cls, init_signature)\n            )\n    # Extract and sort argument names excluding 'self'\n    return sorted([p.name for p in parameters])",
    "scikit-learn.sklearn.base.set_params": "def set_params(self, **params):\n    \"\"\"Set the parameters of this estimator.\n\n    The method works on simple estimators as well as on nested objects\n    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n    parameters of the form ``<component>__<parameter>`` so that it's\n    possible to update each component of a nested object.\n\n    Parameters\n    ----------\n    **params : dict\n        Estimator parameters.\n\n    Returns\n    -------\n    self : estimator instance\n        Estimator instance.\n    \"\"\"\n    if not params:\n        # Simple optimization to gain speed (inspect is slow)\n        return self\n    valid_params = self.get_params(deep=True)\n\n    nested_params = defaultdict(dict)  # grouped by prefix\n    for key, value in params.items():\n        key, delim, sub_key = key.partition(\"__\")\n        if key not in valid_params:\n            local_valid_params = self._get_param_names()\n            raise ValueError(\n                f\"Invalid parameter {key!r} for estimator {self}. \"\n                f\"Valid parameters are: {local_valid_params!r}.\"\n            )\n\n        if delim:\n            nested_params[key][sub_key] = value\n        else:\n            setattr(self, key, value)\n            valid_params[key] = value\n\n    for key, sub_params in nested_params.items():\n        valid_params[key].set_params(**sub_params)\n\n    return self",
    "scikit-learn.sklearn.feature_selection._univariate_selection.__init__": "def __init__(self, score_func=f_classif, *, alpha=5e-2):\n    super().__init__(score_func=score_func)\n    self.alpha = alpha"
}