{
    "matplotlib.lib.matplotlib.cbook._safe_first_finite": "def _safe_first_finite(obj):\n    \"\"\"\n    Return the first finite element in *obj* if one is available and skip_nonfinite is\n    True. Otherwise, return the first element.\n\n    This is a method for internal use.\n\n    This is a type-independent way of obtaining the first finite element, supporting\n    both index access and the iterator protocol.\n    \"\"\"\n    def safe_isfinite(val):\n        if val is None:\n            return False\n        try:\n            return math.isfinite(val)\n        except (TypeError, ValueError):\n            # if the outer object is 2d, then val is a 1d array, and\n            # - math.isfinite(numpy.zeros(3)) raises TypeError\n            # - math.isfinite(torch.zeros(3)) raises ValueError\n            pass\n        try:\n            return np.isfinite(val) if np.isscalar(val) else True\n        except TypeError:\n            # This is something that NumPy cannot make heads or tails of,\n            # assume \"finite\"\n            return True\n\n    if isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not support generators as input\")\n    else:\n        for val in obj:\n            if safe_isfinite(val):\n                return val\n        return safe_first_element(obj)",
    "matplotlib.lib.matplotlib.cbook._unpack_to_numpy": "def _unpack_to_numpy(x):\n    \"\"\"Internal helper to extract data from e.g. pandas and xarray objects.\"\"\"\n    if isinstance(x, np.ndarray):\n        # If numpy, return directly\n        return x\n    if hasattr(x, 'to_numpy'):\n        # Assume that any to_numpy() method actually returns a numpy array\n        return x.to_numpy()\n    if hasattr(x, 'values'):\n        xtmp = x.values\n        # For example a dict has a 'values' attribute, but it is not a property\n        # so in this case we do not want to return a function\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    if _is_torch_array(x) or _is_jax_array(x) or _is_tensorflow_array(x):\n        # using np.asarray() instead of explicitly __array__(), as the latter is\n        # only _one_ of many methods, and it's the last resort, see also\n        # https://numpy.org/devdocs/user/basics.interoperability.html#using-arbitrary-objects-in-numpy\n        # therefore, let arrays do better if they can\n        xtmp = np.asarray(x)\n\n        # In case np.asarray method does not return a numpy array in future\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    return x",
    "matplotlib.lib.matplotlib.units.get_converter": "def get_converter(self, x):\n    \"\"\"Get the converter interface instance for *x*, or None.\"\"\"\n    # Unpack in case of e.g. Pandas or xarray object\n    x = cbook._unpack_to_numpy(x)\n\n    if isinstance(x, np.ndarray):\n        # In case x in a masked array, access the underlying data (only its\n        # type matters).  If x is a regular ndarray, getdata() just returns\n        # the array itself.\n        x = np.ma.getdata(x).ravel()\n        # If there are no elements in x, infer the units from its dtype\n        if not x.size:\n            return self.get_converter(np.array([0], dtype=x.dtype))\n    for cls in type(x).__mro__:  # Look up in the cache.\n        try:\n            return self[cls]\n        except KeyError:\n            pass\n    try:  # If cache lookup fails, look up based on first element...\n        first = cbook._safe_first_finite(x)\n    except (TypeError, StopIteration):\n        pass\n    else:\n        # ... and avoid infinite recursion for pathological iterables for\n        # which indexing returns instances of the same iterable class.\n        if type(first) is not type(x):\n            return self.get_converter(first)\n    return None"
}