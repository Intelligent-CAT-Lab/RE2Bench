{
    "sympy.sympy.external.pythonmpq.__eq__": "def __eq__(self, other):\n    \"\"\"Compare equal with PythonMPQ, int, float, Decimal or Fraction\"\"\"\n    if isinstance(other, PythonMPQ):\n        return (self.numerator == other.numerator\n            and self.denominator == other.denominator)\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    "sympy.sympy.external.pythonmpq.__neg__": "def __neg__(self):\n    \"\"\"-q\"\"\"\n    return self._new(-self.numerator, self.denominator)",
    "sympy.sympy.polys.domains.domain.cofactors": "def cofactors(self, a: Er, b: Er) -> tuple[Er, Er, Er]:\n    \"\"\"Returns GCD and cofactors of ``a`` and ``b``. \"\"\"\n    gcd = self.gcd(a, b)\n    cfa = self.quo(a, gcd)\n    cfb = self.quo(b, gcd)\n    return gcd, cfa, cfb",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(f, g):\n    return f.ex == f.__class__(g).ex",
    "sympy.sympy.polys.domains.finitefield.is_Field": "@property\ndef is_Field(self):\n    is_field = getattr(self, '_is_field', None)\n    if is_field is None:\n        from sympy.ntheory.primetest import isprime\n        self._is_field = is_field = isprime(self.mod)\n    return is_field",
    "sympy.sympy.polys.domains.fractionfield.get_ring": "def get_ring(self):\n    \"\"\"Returns a field associated with ``self``. \"\"\"\n    return self.field.to_ring().to_domain()",
    "sympy.sympy.polys.domains.fractionfield.one": "@property\ndef one(self):\n    return self.field.one",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, self.__class__):\n        return self.x == other.x and self.y == other.y\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.gaussiandomains.get_ring": "def get_ring(self) -> GaussianIntegerRing:\n    \"\"\"Returns a ring associated with ``self``. \"\"\"\n    return ZZ_I",
    "sympy.sympy.polys.domains.gaussiandomains.__neg__": "def __neg__(self) -> Self:\n    return self.new(-self.x, -self.y)",
    "sympy.sympy.polys.domains.modularinteger.__eq__": "def __eq__(self, other):\n    return self._compare(other, operator.eq)",
    "sympy.sympy.polys.domains.polynomialring.one": "@property\ndef one(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.one",
    "sympy.sympy.polys.domains.rationalfield.get_ring": "def get_ring(self):\n    \"\"\"Returns ring associated with ``self``. \"\"\"\n    from sympy.polys.domains import ZZ\n    return ZZ",
    "sympy.sympy.polys.fields.__eq__": "def __eq__(f, g):\n    if isinstance(g, FracElement) and f.field == g.field:\n        return f.numer == g.numer and f.denom == g.denom\n    else:\n        return f.numer == g and f.denom == f.field.ring.one",
    "sympy.sympy.polys.polyclasses.__eq__": "def __eq__(f, g):\n    try:\n        F, G, _, _ = f.unify_ANP(g)\n    except UnificationFailed:\n        return NotImplemented\n    return F == G",
    "sympy.sympy.polys.rings.set_ring": "def set_ring(self, new_ring: PolyRing[Es]) -> PolyElement[Es]:\n    \"\"\"Change the ring of this polynomial.\"\"\"\n    if self.ring == new_ring:\n        return cast(\"PolyElement[Es]\", self)\n    return self._change_ring(new_ring)",
    "sympy.sympy.polys.rings.canonical_unit": "def canonical_unit(self):\n    domain = self.ring.domain\n    return domain.canonical_unit(self.LC)",
    "sympy.sympy.polys.rings.__eq__": "def __eq__(self, other: object) -> bool:\n    \"\"\"Equality test for polynomials.\n\n    Examples\n    ========\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> p1 = (x + y)**2 + (x - y)**2\n    >>> p1 == 4*x*y\n    False\n    >>> p1 == 2*(x**2 + y**2)\n    True\n    \"\"\"\n    if not other:\n        return not self\n    elif self.ring.is_element(other):\n        return dict.__eq__(self, other)\n    elif len(self) > 1:\n        return False\n    else:\n        return self.get(self.ring.zero_monom) == other",
    "sympy.sympy.polys.rings.__neg__": "def __neg__(self) -> PolyElement[Er]:\n    # Return (-1) * self in case of python-flint\n    return self.new([(monom, -coeff) for monom, coeff in self.iterterms()])",
    "sympy.sympy.polys.rings.mul_ground": "def mul_ground(self, x: Er) -> PolyElement[Er]:\n    if not x:\n        return self.ring.zero\n\n    terms = [(monom, coeff * x) for monom, coeff in self.iterterms()]\n    return self.new(terms)",
    "sympy.sympy.polys.rings.clear_denoms": "def clear_denoms(self) -> tuple[Er, PolyElement[Er]]:\n    \"\"\"Clear denominators from polynomial coefficients.\"\"\"\n    domain = self.ring.domain\n\n    if not domain.is_Field or not domain.has_assoc_Ring:\n        return domain.one, self\n\n    ground_ring = domain.get_ring()\n    common = ground_ring.one\n    lcm = ground_ring.lcm\n    denom = domain.denom\n\n    for coeff in self.values():\n        common = lcm(common, denom(coeff))\n\n    poly = self.new([(monom, coeff * common) for monom, coeff in self.items()])\n    return common, poly",
    "sympy.sympy.polys.rings.cofactors": "def cofactors(\n    self: PolyElement[Er], other: PolyElement[Er]\n) -> tuple[PolyElement[Er], PolyElement[Er], PolyElement[Er]]:\n    if not self and not other:\n        zero = self.ring.zero\n        return zero, zero, zero\n    elif not self:\n        h, cff, cfg = self._gcd_zero(other)\n        return h, cff, cfg\n    elif not other:\n        h, cfg, cff = other._gcd_zero(self)\n        return h, cff, cfg\n    elif len(self) == 1:\n        h, cff, cfg = self._gcd_monom(other)\n        return h, cff, cfg\n    elif len(other) == 1:\n        h, cfg, cff = other._gcd_monom(self)\n        return h, cff, cfg\n\n    J, (self, other) = self.deflate(other)\n    h, cff, cfg = self._gcd(other)\n\n    return (h.inflate(J), cff.inflate(J), cfg.inflate(J))",
    "sympy.sympy.polys.rings.one": "@property\ndef one(self) -> PolyElement[Er]:\n    \"\"\"The unit polynomial.\"\"\"\n    return self.dtype(self._one)",
    "sympy.sympy.polys.rings.clone": "def clone(\n    self,\n    symbols: Expr | list[Expr] | tuple[Expr, ...] | None = None,\n    domain: PolyRing[Es] | Domain[Es] | None = None,\n    order: str | MonomialOrder | None = None,\n) -> PolyRing[Er] | PolyRing[Es] | PolyRing[PolyElement[Es]]:\n    \"\"\"Create a clone with modified parameters.\"\"\"\n    # Convert list to tuple for hashability\n    if symbols is not None and isinstance(symbols, list):\n        symbols = tuple(symbols)\n    return self._clone(symbols, domain, order)"
}