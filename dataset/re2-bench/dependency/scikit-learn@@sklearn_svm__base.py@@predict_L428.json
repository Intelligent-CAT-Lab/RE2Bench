{
    "scikit-learn.sklearn.svm._base._dense_predict": "def _dense_predict(self, X):\n    X = self._compute_kernel(X)\n    if X.ndim == 1:\n        X = check_array(X, order=\"C\", accept_large_sparse=False)\n\n    kernel = self.kernel\n    if callable(self.kernel):\n        kernel = \"precomputed\"\n        if X.shape[1] != self.shape_fit_[0]:\n            raise ValueError(\n                \"X.shape[1] = %d should be equal to %d, \"\n                \"the number of samples at training time\"\n                % (X.shape[1], self.shape_fit_[0])\n            )\n\n    svm_type = LIBSVM_IMPL.index(self._impl)\n\n    return libsvm.predict(\n        X,\n        self.support_,\n        self.support_vectors_,\n        self._n_support,\n        self._dual_coef_,\n        self._intercept_,\n        self._probA,\n        self._probB,\n        svm_type=svm_type,\n        kernel=kernel,\n        degree=self.degree,\n        coef0=self.coef0,\n        gamma=self._gamma,\n        cache_size=self.cache_size,\n    )",
    "scikit-learn.sklearn.svm._base._sparse_predict": "def _sparse_predict(self, X):\n    # Precondition: X is a csr_matrix of dtype np.float64.\n    kernel = self.kernel\n    if callable(kernel):\n        kernel = \"precomputed\"\n\n    kernel_type = self._sparse_kernels.index(kernel)\n\n    C = 0.0  # C is not useful here\n\n    return libsvm_sparse.libsvm_sparse_predict(\n        X.data,\n        X.indices,\n        X.indptr,\n        self.support_vectors_.data,\n        self.support_vectors_.indices,\n        self.support_vectors_.indptr,\n        self._dual_coef_.data,\n        self._intercept_,\n        LIBSVM_IMPL.index(self._impl),\n        kernel_type,\n        self.degree,\n        self._gamma,\n        self.coef0,\n        self.tol,\n        C,\n        getattr(self, \"class_weight_\", np.empty(0)),\n        self.nu,\n        self.epsilon,\n        self.shrinking,\n        self.probability,\n        self._n_support,\n        self._probA,\n        self._probB,\n    )",
    "scikit-learn.sklearn.svm._base._validate_for_predict": "def _validate_for_predict(self, X):\n    check_is_fitted(self)\n\n    if not callable(self.kernel):\n        X = validate_data(\n            self,\n            X,\n            accept_sparse=\"csr\",\n            dtype=np.float64,\n            order=\"C\",\n            accept_large_sparse=False,\n            reset=False,\n        )\n\n    if self._sparse and not sp.issparse(X):\n        X = sp.csr_matrix(X)\n    if self._sparse:\n        X.sort_indices()\n\n    if sp.issparse(X) and not self._sparse and not callable(self.kernel):\n        raise ValueError(\n            \"cannot use sparse input in %r trained on dense data\"\n            % type(self).__name__\n        )\n\n    if self.kernel == \"precomputed\":\n        if X.shape[1] != self.shape_fit_[0]:\n            raise ValueError(\n                \"X.shape[1] = %d should be equal to %d, \"\n                \"the number of samples at training time\"\n                % (X.shape[1], self.shape_fit_[0])\n            )\n    # Fixes https://nvd.nist.gov/vuln/detail/CVE-2020-28975\n    # Check that _n_support is consistent with support_vectors\n    sv = self.support_vectors_\n    if not self._sparse and sv.size > 0 and self.n_support_.sum() != sv.shape[0]:\n        raise ValueError(\n            f\"The internal representation of {self.__class__.__name__} was altered\"\n        )\n    return X"
}