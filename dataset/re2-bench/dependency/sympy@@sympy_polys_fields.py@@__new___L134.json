{
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.domains.algebraicfield.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.dtype, self.dom, self.ext))",
    "sympy.sympy.polys.domains.complexfield.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self._dtype, self.precision))",
    "sympy.sympy.polys.domains.expressiondomain.__hash__": "def __hash__(self):\n    return hash(\"EX\")",
    "sympy.sympy.polys.domains.finitefield.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.dtype, self.mod, self.dom))",
    "sympy.sympy.polys.domains.fractionfield.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.field, self.domain, self.symbols))",
    "sympy.sympy.polys.domains.gaussiandomains.__hash__": "def __hash__(self) -> int:\n    \"\"\"Compute hash code of ``self``. \"\"\"\n    return hash('QQ_I')",
    "sympy.sympy.polys.domains.integerring.__hash__": "def __hash__(self):\n    \"\"\"Compute a hash value for this domain. \"\"\"\n    return hash('ZZ')",
    "sympy.sympy.polys.domains.polynomialring.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.ring, self.domain, self.symbols))",
    "sympy.sympy.polys.domains.rationalfield.__hash__": "def __hash__(self):\n    \"\"\"Returns hash code of ``self``. \"\"\"\n    return hash('QQ')",
    "sympy.sympy.polys.domains.realfield.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self._dtype, self.precision))",
    "sympy.sympy.polys.fields._gens": "def _gens(self):\n    \"\"\"Return a list of polynomial generators. \"\"\"\n    return tuple([ self.dtype(gen) for gen in self.ring.gens ])",
    "sympy.sympy.polys.fields.__init__": "def __init__(self,\n             field: FracField[Er],\n             numer: PolyElement[Er],\n             denom: PolyElement[Er] | None = None) -> None:\n    if denom is None:\n        denom = field.ring.one\n    elif not denom:\n        raise ZeroDivisionError(\"zero denominator\")\n\n    self.field = field\n    self.numer = numer\n    self.denom = denom",
    "sympy.sympy.polys.fields.raw_new": "def raw_new(f, numer: PolyElement[Er],\n               denom: PolyElement[Er] | None = None) -> FracElement[Er]:\n    return f.__class__(f.field, numer, denom)",
    "sympy.sympy.polys.orderings.__hash__": "def __hash__(self):\n    return hash(self.__class__)",
    "sympy.sympy.polys.rings.__new__": "def __new__(  # type: ignore\n    cls,\n    symbols: str | Expr | Sequence[str] | Sequence[Expr],\n    domain: Domain[Er] | PolyRing[Es],\n    order: str | MonomialOrder | None = lex,\n) -> PolyRing[Er] | PolyRing[PolyElement[Es]]:\n    # Create a new ring instance.\n    symbols = tuple(_parse_symbols(symbols))\n    ngens = len(symbols)\n    domain = DomainOpt.preprocess(domain)\n    morder = OrderOpt.preprocess(order)\n\n    # Validate that symbols do not overlap with domain symbols\n    if isinstance(domain, CompositeDomain) and set(symbols) & set(domain.symbols):\n        raise GeneratorsError(\n            \"polynomial ring and it's ground domain share generators\"\n        )\n\n    # Create and initialize instance\n    obj = object.__new__(cls)\n    obj._hash_tuple = (cls.__name__, symbols, ngens, domain, order)\n    obj._hash = hash(obj._hash_tuple)\n    obj.symbols = symbols\n    obj.ngens = ngens\n    obj.domain = domain\n    obj.order = morder\n\n    # Set up polynomial creation and basic elements\n    obj.dtype = PolyElement(obj, ()).new\n    obj.zero_monom = (0,) * ngens\n    obj.gens = obj._gens()\n    obj._gens_set = set(obj.gens)\n    obj._one = [(obj.zero_monom, domain.one)]\n\n    # Initialize monomial operations\n    obj._init_monomial_operations()\n\n    # Set up leading exponent function\n    obj._init_leading_expv_function(order)\n\n    # Add generator attributes for Symbol names\n    obj._add_generator_attributes()\n\n    return obj",
    "sympy.sympy.polys.rings.zero": "@property\ndef zero(self) -> PolyElement[Er]:\n    \"\"\"The zero polynomial.\"\"\"\n    return self.dtype([])",
    "sympy.sympy.polys.rings.one": "@property\ndef one(self) -> PolyElement[Er]:\n    \"\"\"The unit polynomial.\"\"\"\n    return self.dtype(self._one)"
}