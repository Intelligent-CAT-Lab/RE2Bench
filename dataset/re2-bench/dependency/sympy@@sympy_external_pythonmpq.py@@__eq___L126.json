{
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.external.pythonmpq.__eq__": "def __eq__(self, other):\n    \"\"\"Compare equal with PythonMPQ, int, float, Decimal or Fraction\"\"\"\n    if isinstance(other, PythonMPQ):\n        return (self.numerator == other.numerator\n            and self.denominator == other.denominator)\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    "sympy.sympy.external.pythonmpq.__new__": "def __new__(cls, numerator, denominator=None):\n    \"\"\"Construct PythonMPQ with gcd computation and checks\"\"\"\n    if denominator is not None:\n        #\n        # PythonMPQ(n, d): require n and d to be int and d != 0\n        #\n        if isinstance(numerator, int) and isinstance(denominator, int):\n            # This is the slow part:\n            divisor = gcd(numerator, denominator)\n            numerator //= divisor\n            denominator //= divisor\n            return cls._new_check(numerator, denominator)\n    else:\n        #\n        # PythonMPQ(q)\n        #\n        # Here q can be PythonMPQ, int, Decimal, float, Fraction or str\n        #\n        if isinstance(numerator, int):\n            return cls._new(numerator, 1)\n        elif isinstance(numerator, PythonMPQ):\n            return cls._new(numerator.numerator, numerator.denominator)\n\n        # Let Fraction handle Decimal/float conversion and str parsing\n        if isinstance(numerator, (Decimal, float, str)):\n            numerator = Fraction(numerator)\n        if isinstance(numerator, Fraction):\n            return cls._new(numerator.numerator, numerator.denominator)\n    #\n    # Reject everything else. This is more strict than mpq which allows\n    # things like mpq(Fraction, Fraction) or mpq(Decimal, any). The mpq\n    # behaviour is somewhat inconsistent so we choose to accept only a\n    # more strict subset of what mpq allows.\n    #\n    raise TypeError(\"PythonMPQ() requires numeric or string argument\")",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}