{
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.polys.constructor.<lambda>": "is_algebraic = lambda coeff: False\n\n",
    "sympy.sympy.polys.constructor.<genexpr>": "max_prec = max(c._prec for c in float_numbers) if float_numbers else 53\n\n",
    "sympy.sympy.polys.constructor.<listcomp>": "result = [domain.from_sympy(coeff) for coeff in coeffs]\n\n",
    "sympy.sympy.polys.constructor._construct_algebraic": "def _construct_algebraic(coeffs, opt):\n    \"\"\"We know that coefficients are algebraic so construct the extension. \"\"\"\n    from sympy.polys.numberfields import primitive_element\n\n    exts = set()\n\n    def build_trees(args):\n        trees = []\n        for a in args:\n            if a.is_Rational:\n                tree = ('Q', QQ.from_sympy(a))\n            elif a.is_Add:\n                tree = ('+', build_trees(a.args))\n            elif a.is_Mul:\n                tree = ('*', build_trees(a.args))\n            else:\n                tree = ('e', a)\n                exts.add(a)\n            trees.append(tree)\n        return trees\n\n    trees = build_trees(coeffs)\n    exts = list(ordered(exts))\n\n    g, span, H = primitive_element(exts, ex=True, polys=True)\n    root = sum(s*ext for s, ext in zip(span, exts))\n\n    domain, g = QQ.algebraic_field((g, root)), g.rep.to_list()\n\n    exts_dom = [domain.dtype.from_list(h, g, QQ) for h in H]\n    exts_map = dict(zip(exts, exts_dom))\n\n    def convert_tree(tree):\n        op, args = tree\n        if op == 'Q':\n            return domain.dtype.from_list([args], g, QQ)\n        elif op == '+':\n            return sum((convert_tree(a) for a in args), domain.zero)\n        elif op == '*':\n            return prod(convert_tree(a) for a in args)\n        elif op == 'e':\n            return exts_map[args]\n        else:\n            raise RuntimeError\n\n    result = [convert_tree(tree) for tree in trees]\n\n    return domain, result",
    "sympy.sympy.polys.domains.complexfield.__init__": "def __init__(self, prec=None, dps=None, tol=None):\n    # XXX: The tolerance parameter is ignored but is kept for backward\n    # compatibility for now.\n\n    context = MPContext()\n\n    if prec is None and dps is None:\n        context.prec = self._default_precision\n    elif dps is None:\n        context.prec = prec\n    elif prec is None:\n        context.dps = dps\n    else:\n        raise TypeError(\"Cannot set both prec and dps\")\n\n    self._context = context\n\n    self._dtype = context.mpc\n    self.zero = self.dtype(0)\n    self.one = self.dtype(1)\n\n    # XXX: Neither of these is actually used anywhere.\n    self._max_denom = max(2**context.prec // 200, 99)\n    self._tolerance = self.one / self._max_denom",
    "sympy.sympy.polys.domains.realfield.__init__": "def __init__(self, prec=None, dps=None, tol=None):\n    # XXX: The tol parameter is ignored but is kept for now for backwards\n    # compatibility.\n\n    context = MPContext()\n\n    if prec is None and dps is None:\n        context.prec = self._default_precision\n    elif dps is None:\n        context.prec = prec\n    elif prec is None:\n        context.dps = dps\n    else:\n        raise TypeError(\"Cannot set both prec and dps\")\n\n    self._context = context\n\n    self._dtype = context.mpf\n    self.zero = self.dtype(0)\n    self.one = self.dtype(1)\n\n    # Only max_denom here is used for anything and is only used for\n    # to_rational.\n    self._max_denom = max(2**context.prec // 200, 99)\n    self._tolerance = self.one / self._max_denom",
    "sympy.sympy.polys.polyoptions.getter": "@property\ndef getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()"
}