{
    "sympy.sympy.assumptions.wrapper.getit": "def getit(self):\n    pred = getattr(Q, fact)\n    ret = ask(pred(self.expr), self.assumptions)\n    return ret",
    "sympy.sympy.calculus.accumulationbounds._eval_is_real": "def _eval_is_real(self):\n    if self.min.is_real and self.max.is_real:\n        return True",
    "sympy.sympy.codegen.cfunctions._eval_is_real": "def _eval_is_real(self):\n    return self.args[0].is_real",
    "sympy.sympy.codegen.cfunctions._eval_is_finite": "def _eval_is_finite(self):\n    return self.args[0].is_finite",
    "sympy.sympy.codegen.cfunctions._eval_is_positive": "def _eval_is_positive(self):\n    return self.args[0].is_positive",
    "sympy.sympy.codegen.cfunctions._eval_is_zero": "def _eval_is_zero(self):\n    return self.args[0].is_zero",
    "sympy.sympy.codegen.cfunctions._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    return self.args[0].is_nonnegative",
    "sympy.sympy.concrete.products._eval_is_zero": "def _eval_is_zero(self):\n    if self.has_empty_sequence:\n        return False\n\n    z = self.term.is_zero\n    if z is True:\n        return True\n    if self.has_finite_limits:\n        # A Product is zero only if its term is zero assuming finite limits.\n        return z",
    "sympy.sympy.concrete.products._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.has_empty_sequence:\n        return True\n\n    return self.function.is_extended_real",
    "sympy.sympy.concrete.products._eval_is_positive": "def _eval_is_positive(self):\n    if self.has_empty_sequence:\n        return True\n    if self.function.is_positive and self.has_finite_limits:\n        return True",
    "sympy.sympy.concrete.products._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    if self.has_empty_sequence:\n        return True\n    if self.function.is_nonnegative and self.has_finite_limits:\n        return True",
    "sympy.sympy.concrete.products._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    if self.has_empty_sequence:\n        return True\n    if self.function.is_extended_nonnegative:\n        return True",
    "sympy.sympy.concrete.products._eval_is_extended_nonpositive": "def _eval_is_extended_nonpositive(self):\n    if self.has_empty_sequence:\n        return True",
    "sympy.sympy.concrete.products._eval_is_finite": "def _eval_is_finite(self):\n    if self.has_finite_limits and self.function.is_finite:\n        return True",
    "sympy.sympy.concrete.summations._eval_is_zero": "def _eval_is_zero(self):\n    # a Sum is only zero if its function is zero or if all terms\n    # cancel out. This only answers whether the summand is zero; if\n    # not then None is returned since we don't analyze whether all\n    # terms cancel out.\n    if self.function.is_zero or self.has_empty_sequence:\n        return True",
    "sympy.sympy.concrete.summations._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.has_empty_sequence:\n        return True\n    return self.function.is_extended_real",
    "sympy.sympy.concrete.summations._eval_is_positive": "def _eval_is_positive(self):\n    if self.has_finite_limits and self.has_reversed_limits is False:\n        return self.function.is_positive",
    "sympy.sympy.concrete.summations._eval_is_negative": "def _eval_is_negative(self):\n    if self.has_finite_limits and self.has_reversed_limits is False:\n        return self.function.is_negative",
    "sympy.sympy.concrete.summations._eval_is_finite": "def _eval_is_finite(self):\n    if self.has_finite_limits and self.function.is_finite:\n        return True",
    "sympy.sympy.core.add.<lambda>": "_eval_is_commutative = lambda self: _fuzzy_group(\n    a.is_commutative for a in self.args)\n\n",
    "sympy.sympy.core.add._eval_is_infinite": "def _eval_is_infinite(self):\n    sawinf = False\n    for a in self.args:\n        ainf = a.is_infinite\n        if ainf is None:\n            return None\n        elif ainf is True:\n            # infinite+infinite might not be infinite\n            if sawinf is True:\n                return None\n            sawinf = True\n    return sawinf",
    "sympy.sympy.core.add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a*S.ImaginaryUnit)\n        elif a.is_Mul and S.ImaginaryUnit in a.args:\n            coeff, ai = a.as_coeff_mul(S.ImaginaryUnit)\n            if ai == (S.ImaginaryUnit,) and coeff.is_extended_real:\n                im_I.append(-coeff)\n            else:\n                return\n        else:\n            return\n    b = self.func(*nz)\n    if b != self:\n        if b.is_zero:\n            return fuzzy_not(self.func(*im_I).is_zero)\n        elif b.is_zero is False:\n            return False",
    "sympy.sympy.core.add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        # issue 10528: there is no way to know if a nc symbol\n        # is zero or not\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = 0\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im += 1\n        elif a.is_Mul and S.ImaginaryUnit in a.args:\n            coeff, ai = a.as_coeff_mul(S.ImaginaryUnit)\n            if ai == (S.ImaginaryUnit,) and coeff.is_extended_real:\n                im_or_z = True\n            else:\n                return\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) in [0, len(self.args)]:\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z:\n            if im == 0:\n                return True\n            elif im == 1:\n                return False\n    if b.is_zero is False:\n        return False",
    "sympy.sympy.core.add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not (f.is_even is True)]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    "sympy.sympy.core.add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(x.is_rational is True for x in others):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    "sympy.sympy.core.add._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.is_number:\n        return super()._eval_is_extended_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_positive and a.is_extended_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_extended_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n\n        if infinite is None:\n            return\n        unknown_sign = True\n\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif pos and not nonpos:\n        return True\n    elif not pos and not nonneg:\n        return False",
    "sympy.sympy.core.add._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonnegative:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonnegative:\n                        return True",
    "sympy.sympy.core.add._eval_is_extended_nonpositive": "def _eval_is_extended_nonpositive(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonpositive:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonpositive:\n                        return True",
    "sympy.sympy.core.add._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.is_number:\n        return super()._eval_is_extended_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_negative and a.is_extended_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_extended_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n\n        if infinite is None:\n            return\n        unknown_sign = True\n\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif neg and not nonneg:\n        return True\n    elif not neg and not nonpos:\n        return False",
    "sympy.sympy.core.expr._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_is_extended_positive_negative(positive=True)",
    "sympy.sympy.core.expr._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_is_extended_positive_negative(positive=False)",
    "sympy.sympy.core.facts._tell": "def _tell(self, k, v):\n    \"\"\"Add fact k=v to the knowledge base.\n\n    Returns True if the KB has actually been updated, False otherwise.\n    \"\"\"\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    "sympy.sympy.core.facts.deduce_all_facts": "def deduce_all_facts(self, facts):\n    \"\"\"\n    Update the KB with all the implications of a list of facts.\n\n    Facts can be specified as a dictionary or as a list of (key, value)\n    pairs.\n    \"\"\"\n    # keep frequently used attributes locally, so we'll avoid extra\n    # attribute access overhead\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n\n    if isinstance(facts, dict):\n        facts = facts.items()\n\n    while facts:\n        beta_maytrigger = set()\n\n        # --- alpha chains ---\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n\n            # lookup routing tables\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n\n            beta_maytrigger.update(beta_triggers[k, v])\n\n        # --- beta chains ---\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all(self.get(k) is v for k, v in bcond):\n                facts.append(bimpl)",
    "sympy.sympy.core.function._eval_is_commutative": "def _eval_is_commutative(self):\n    return fuzzy_and(a.is_commutative for a in self.args)",
    "sympy.sympy.core.mod._eval_is_integer": "def _eval_is_integer(self):\n    p, q = self.args\n    if fuzzy_and([p.is_integer, q.is_integer, fuzzy_not(q.is_zero)]):\n        return True",
    "sympy.sympy.core.mod._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    if self.args[1].is_positive:\n        return True",
    "sympy.sympy.core.mod._eval_is_nonpositive": "def _eval_is_nonpositive(self):\n    if self.args[1].is_negative:\n        return True",
    "sympy.sympy.core.mul.<lambda>": "_eval_is_commutative = lambda self: _fuzzy_group(\n    a.is_commutative for a in self.args)\n\n",
    "sympy.sympy.core.mul._eval_is_complex": "def _eval_is_complex(self):\n    comp = _fuzzy_group(a.is_complex for a in self.args)\n    if comp is False:\n        if any(a.is_infinite for a in self.args):\n            if any(a.is_zero is not False for a in self.args):\n                return None\n            return False\n    return comp",
    "sympy.sympy.core.mul._eval_is_zero": "def _eval_is_zero(self):\n    # True iff any arg is zero and no arg is infinite but need to handle\n    # three valued logic carefully.\n    seen_zero, seen_infinite = self._eval_is_zero_infinite_helper()\n\n    if seen_zero is False:\n        return False\n    elif seen_zero is True and seen_infinite is False:\n        return True\n    else:\n        return None",
    "sympy.sympy.core.mul._eval_is_infinite": "def _eval_is_infinite(self):\n    # True iff any arg is infinite and no arg is zero but need to handle\n    # three valued logic carefully.\n    seen_zero, seen_infinite = self._eval_is_zero_infinite_helper()\n\n    if seen_infinite is True and seen_zero is False:\n        return True\n    elif seen_infinite is False:\n        return False\n    else:\n        return None",
    "sympy.sympy.core.mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        # All args except one are rational\n        if all(a.is_zero is False for a in self.args):\n            return False",
    "sympy.sympy.core.mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        # All args except one are algebraic\n        if all(a.is_zero is False for a in self.args):\n            return False",
    "sympy.sympy.core.mul._eval_is_integer": "def _eval_is_integer(self):\n    is_rational = self._eval_is_rational()\n    if is_rational is False:\n        return False\n\n    numerators = []\n    denominators = []\n    unknown = False\n    for a in self.args:\n        hit = False\n        if a.is_integer:\n            if abs(a) is not S.One:\n                numerators.append(a)\n        elif a.is_Rational:\n            n, d = a.as_numer_denom()\n            if abs(n) is not S.One:\n                numerators.append(n)\n            if d is not S.One:\n                denominators.append(d)\n        elif a.is_Pow:\n            b, e = a.as_base_exp()\n            if not b.is_integer or not e.is_integer:\n                hit = unknown = True\n            if e.is_negative:\n                denominators.append(2 if a is S.Half else\n                    Pow(a, S.NegativeOne))\n            elif not hit:\n                # int b and pos int e: a = b**e is integer\n                assert not e.is_positive\n                # for rational self and e equal to zero: a = b**e is 1\n                assert not e.is_zero\n                return # sign of e unknown -> self.is_integer unknown\n            else:\n                # x**2, 2**x, or x**y with x and y int-unknown -> unknown\n                return\n        else:\n            return\n\n    if not denominators and not unknown:\n        return True\n\n    allodd = lambda x: all(i.is_odd for i in x)\n    alleven = lambda x: all(i.is_even for i in x)\n    anyeven = lambda x: any(i.is_even for i in x)\n\n    from .relational import is_gt\n    if not numerators and denominators and all(\n            is_gt(_, S.One) for _ in denominators):\n        return False\n    elif unknown:\n        return\n    elif allodd(numerators) and anyeven(denominators):\n        return False\n    elif anyeven(numerators) and denominators == [2]:\n        return True\n    elif alleven(numerators) and allodd(denominators\n            ) and (Mul(*denominators, evaluate=False) - 1\n            ).is_positive:\n        return False\n    if len(denominators) == 1:\n        d = denominators[0]\n        if d.is_Integer:\n            is_power_of_two = d.p & (d.p - 1) == 0\n            # if minimal power of 2 in num vs den is not\n            # negative then we have an integer\n            if is_power_of_two and (Add(*[i.as_base_exp()[1] for i in\n                    numerators if i.is_even]) - trailing(d.p)\n                    ).is_nonnegative:\n                return True\n    if len(numerators) == 1:\n        n = numerators[0]\n        if n.is_Integer and n.is_even:\n            # if minimal power of 2 in den vs num is positive\n            # then we have have a non-integer\n            if (Add(*[i.as_base_exp()[1] for i in\n                    denominators if i.is_even]) - trailing(n.p)\n                    ).is_positive:\n                return False",
    "sympy.sympy.core.mul._eval_is_polar": "def _eval_is_polar(self):\n    has_polar = any(arg.is_polar for arg in self.args)\n    return has_polar and \\\n        all(arg.is_polar or arg.is_positive for arg in self.args)",
    "sympy.sympy.core.mul._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self._eval_real_imag(True)",
    "sympy.sympy.core.mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if all(a.is_zero is False and a.is_finite for a in self.args):\n        return self._eval_real_imag(False)",
    "sympy.sympy.core.mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):\n                return True\n            return\n        if a is None:\n            return\n    if all(x.is_real for x in self.args):\n        return False",
    "sympy.sympy.core.mul._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    \"\"\"Return True if self is positive, False if not, and None if it\n    cannot be determined.\n\n    Explanation\n    ===========\n\n    This algorithm is non-recursive and works by keeping track of the\n    sign which changes when a negative or nonpositive is encountered.\n    Whether a nonpositive or nonnegative is seen is also tracked since\n    the presence of these makes it impossible to return True, but\n    possible to return False if the end result is nonpositive. e.g.\n\n        pos * neg * nonpositive -> pos or zero -> None is returned\n        pos * neg * nonnegative -> neg or zero -> False is returned\n    \"\"\"\n    return self._eval_pos_neg(1)",
    "sympy.sympy.core.mul._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_pos_neg(-1)",
    "sympy.sympy.core.mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self._eval_is_integer()\n    if is_integer is not True:\n        return is_integer\n\n    from sympy.simplify.radsimp import fraction\n    n, d = fraction(self)\n    if d.is_Integer and d.is_even:\n        # if minimal power of 2 in num vs den is\n        # positive then we have an even number\n        if (Add(*[i.as_base_exp()[1] for i in\n                Mul.make_args(n) if i.is_even]) - trailing(d.p)\n                ).is_positive:\n            return False\n        return\n    r, acc = True, 1\n    for t in self.args:\n        if abs(t) is S.One:\n            continue\n        if t.is_even:\n            return False\n        if r is False:\n            pass\n        elif acc != 1 and (acc + t).is_odd:\n            r = False\n        elif t.is_even is None:\n            r = None\n        acc = t\n    return r",
    "sympy.sympy.core.mul._eval_is_even": "def _eval_is_even(self):\n    from sympy.simplify.radsimp import fraction\n    n, d = fraction(self, exact=True)\n    if n.is_Integer and n.is_even:\n        # if minimal power of 2 in den vs num is not\n        # negative then this is not an integer and\n        # can't be even\n        if (Add(*[i.as_base_exp()[1] for i in\n                Mul.make_args(d) if i.is_even]) - trailing(n.p)\n                ).is_nonnegative:\n            return False",
    "sympy.sympy.core.mul._eval_is_composite": "def _eval_is_composite(self):\n    \"\"\"\n    Here we count the number of arguments that have a minimum value\n    greater than two.\n    If there are more than one of such a symbol then the result is composite.\n    Else, the result cannot be determined.\n    \"\"\"\n    number_of_args = 0 # count of symbols with minimum value greater than one\n    for arg in self.args:\n        if not (arg.is_integer and arg.is_positive):\n            return None\n        if (arg-1).is_positive:\n            number_of_args += 1\n\n    if number_of_args > 1:\n        return True",
    "sympy.sympy.core.numbers._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self._mpf_ == _mpf_inf:\n        return True\n    if self._mpf_ == _mpf_ninf:\n        return False\n    return self.num > 0",
    "sympy.sympy.core.numbers._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    "sympy.sympy.core.numbers._eval_is_positive": "def _eval_is_positive(self):\n    if self._mpf_ in (_mpf_ninf, _mpf_inf):\n        return False\n    return self.num > 0",
    "sympy.sympy.core.numbers._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    "sympy.sympy.core.numbers._eval_is_prime": "def _eval_is_prime(self):\n    from sympy.ntheory.primetest import isprime\n\n    return isprime(self)",
    "sympy.sympy.core.numbers._eval_is_composite": "def _eval_is_composite(self):\n    if self > 1:\n        return fuzzy_not(self.is_prime)\n    else:\n        return False",
    "sympy.sympy.core.numbers._eval_is_integer": "def _eval_is_integer(self):\n    if self._mpf_ == fzero:\n        return True\n    if not int_valued(self):\n        return False",
    "sympy.sympy.core.numbers._eval_is_negative": "def _eval_is_negative(self):\n    if self._mpf_ in (_mpf_ninf, _mpf_inf):\n        return False\n    return self.num < 0",
    "sympy.sympy.core.numbers._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self._mpf_ == _mpf_ninf:\n        return True\n    if self._mpf_ == _mpf_inf:\n        return False\n    return self.num < 0",
    "sympy.sympy.core.power._eval_is_rational": "def _eval_is_rational(self):\n    # The evaluation of self.func below can be very expensive in the case\n    # of integer**integer if the exponent is large.  We should try to exit\n    # before that if possible:\n    if (self.exp.is_integer and self.base.is_rational\n            and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero]))):\n        return True\n    p = self.func(*self.as_base_exp())  # in case it's unevaluated\n    if not p.is_Pow:\n        return p.is_rational\n    b, e = p.as_base_exp()\n    if e.is_Rational and b.is_Rational:\n        # we didn't check that e is not an Integer\n        # because Rational**Integer autosimplifies\n        return False\n    if e.is_integer:\n        if b.is_rational:\n            if fuzzy_not(b.is_zero) or e.is_nonnegative:\n                return True\n            if b == e:  # always rational, even for 0**0\n                return True\n        elif b.is_irrational:\n            return e.is_zero\n    if b is S.Exp1:\n        if e.is_rational and e.is_nonzero:\n            return False",
    "sympy.sympy.core.power._eval_is_algebraic": "def _eval_is_algebraic(self):\n    def _is_one(expr):\n        try:\n            return (expr - 1).is_zero\n        except ValueError:\n            # when the operation is not allowed\n            return False\n\n    if self.base.is_zero or _is_one(self.base):\n        return True\n    elif self.base is S.Exp1:\n        s = self.func(*self.args)\n        if s.func == self.func:\n            if self.exp.is_nonzero:\n                if self.exp.is_algebraic:\n                    return False\n                elif (self.exp/S.Pi).is_rational:\n                    return False\n                elif (self.exp/(S.ImaginaryUnit*S.Pi)).is_rational:\n                    return True\n        else:\n            return s.is_algebraic\n    elif self.exp.is_rational:\n        if self.base.is_algebraic is False:\n            return self.exp.is_zero\n        if self.base.is_zero is False:\n            if self.exp.is_nonzero:\n                return self.base.is_algebraic\n            elif self.base.is_algebraic:\n                return True\n        if self.exp.is_positive:\n            return self.base.is_algebraic\n    elif self.base.is_algebraic and self.exp.is_algebraic:\n        if ((fuzzy_not(self.base.is_zero)\n            and fuzzy_not(_is_one(self.base)))\n            or self.base.is_integer is False\n            or self.base.is_irrational):\n            return self.exp.is_rational",
    "sympy.sympy.core.power._eval_is_even": "def _eval_is_even(self):\n    if self.exp.is_integer and self.exp.is_positive:\n        return self.base.is_even",
    "sympy.sympy.core.power._eval_is_negative": "def _eval_is_negative(self):\n    ext_neg = Pow._eval_is_extended_negative(self)\n    if ext_neg is True:\n        return self.is_finite\n    return ext_neg",
    "sympy.sympy.core.power._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.base == self.exp:\n        if self.base.is_extended_nonnegative:\n            return True\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return True\n    elif self.base.is_extended_negative:\n        if self.exp.is_even:\n            return True\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return self.exp.is_zero\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_imaginary:\n        if self.exp.is_integer:\n            m = self.exp % 4\n            if m.is_zero:\n                return True\n            if m.is_integer and m.is_zero is False:\n                return False\n        if self.exp.is_imaginary:\n            from sympy.functions.elementary.exponential import log\n            return log(self.base).is_imaginary",
    "sympy.sympy.core.power._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.exp is S.Half:\n        if self.base.is_complex or self.base.is_extended_real:\n            return False\n    if self.base.is_extended_negative:\n        if self.exp.is_odd and self.base.is_finite:\n            return True\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_positive or self.base.is_zero:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_extended_nonnegative:\n        if self.exp.is_extended_nonnegative:\n            return False\n    elif self.base.is_extended_nonpositive or self.base.is_extended_real:\n        if self.exp.is_even:\n            return False",
    "sympy.sympy.core.power._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_extended_positive:\n            return True\n        elif self.exp.is_extended_nonpositive:\n            return False\n    elif self.base == S.Exp1:\n        return self.exp is S.NegativeInfinity\n    elif self.base.is_zero is False:\n        if self.base.is_finite and self.exp.is_finite:\n            return False\n        elif self.exp.is_negative:\n            return self.base.is_infinite\n        elif self.exp.is_nonnegative:\n            return False\n        elif self.exp.is_infinite and self.exp.is_extended_real:\n            if (1 - abs(self.base)).is_extended_positive:\n                return self.exp.is_extended_positive\n            elif (1 - abs(self.base)).is_extended_negative:\n                return self.exp.is_extended_negative\n    elif self.base.is_finite and self.exp.is_negative:\n        # when self.base.is_zero is None\n        return False",
    "sympy.sympy.core.power._eval_is_integer": "def _eval_is_integer(self):\n    b, e = self.args\n    if b.is_rational:\n        if b.is_integer is False and e.is_positive:\n            return False  # rat**nonneg\n    if b.is_integer and e.is_integer:\n        if b is S.NegativeOne:\n            return True\n        if e.is_nonnegative or e.is_positive:\n            return True\n    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n            return False\n    if b.is_Number and e.is_Number:\n        check = self.func(*self.args)\n        return check.is_Integer\n    if e.is_negative and b.is_positive and (b - 1).is_positive:\n        return False\n    if e.is_negative and b.is_negative and (b + 1).is_negative:\n        return False",
    "sympy.sympy.core.power._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.base is S.Exp1:\n        if self.exp.is_extended_real:\n            return True\n        elif self.exp.is_imaginary:\n            return (2*S.ImaginaryUnit*self.exp/S.Pi).is_even\n\n    from sympy.functions.elementary.exponential import log, exp\n    real_b = self.base.is_extended_real\n    if real_b is None:\n        if self.base.func == exp and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        if self.base.func == Pow and self.base.base is S.Exp1 and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        return\n    real_e = self.exp.is_extended_real\n    if real_e is None:\n        return\n    if real_b and real_e:\n        if self.base.is_extended_positive:\n            return True\n        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:\n            return True\n        elif self.exp.is_integer and self.base.is_extended_nonzero:\n            return True\n        elif self.exp.is_integer and self.exp.is_nonnegative:\n            return True\n        elif self.base.is_extended_negative:\n            if self.exp.is_Rational:\n                return False\n    if real_e and self.exp.is_extended_negative and self.base.is_zero is False:\n        return Pow(self.base, -self.exp).is_extended_real\n    im_b = self.base.is_imaginary\n    im_e = self.exp.is_imaginary\n    if im_b:\n        if self.exp.is_integer:\n            if self.exp.is_even:\n                return True\n            elif self.exp.is_odd:\n                return False\n        elif im_e and log(self.base).is_imaginary:\n            return True\n        elif self.exp.is_Add:\n            c, a = self.exp.as_coeff_Add()\n            if c and c.is_Integer:\n                return Mul(\n                    self.base**c, self.base**a, evaluate=False).is_extended_real\n        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n            if (self.exp/2).is_integer is False:\n                return False\n    if real_b and im_e:\n        if self.base is S.NegativeOne:\n            return True\n        c = self.exp.coeff(S.ImaginaryUnit)\n        if c:\n            if self.base.is_rational and c.is_rational:\n                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:\n                    return False\n            ok = (c*log(self.base)/S.Pi).is_integer\n            if ok is not None:\n                return ok\n\n    if real_b is False and real_e: # we already know it's not imag\n        if isinstance(self.exp, Rational) and self.exp.p == 1:\n            return False\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base)*self.exp/S.Pi\n        if i.is_complex: # finite\n            return i.is_integer",
    "sympy.sympy.core.power._eval_is_complex": "def _eval_is_complex(self):\n\n    if self.base == S.Exp1:\n        return fuzzy_or([self.exp.is_complex, self.exp.is_extended_negative])\n\n    if all(a.is_complex for a in self.args) and self._eval_is_finite():\n        return True",
    "sympy.sympy.core.power._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if self.base.is_commutative is False:\n        return False\n\n    if self.base.is_imaginary:\n        if self.exp.is_integer:\n            odd = self.exp.is_odd\n            if odd is not None:\n                return odd\n            return\n\n    if self.base == S.Exp1:\n        f = 2 * self.exp / (S.Pi*S.ImaginaryUnit)\n        # exp(pi*integer) = 1 or -1, so not imaginary\n        if f.is_even:\n            return False\n        # exp(pi*integer + pi/2) = I or -I, so it is imaginary\n        if f.is_odd:\n            return True\n        return None\n\n    if self.exp.is_imaginary:\n        from sympy.functions.elementary.exponential import log\n        imlog = log(self.base).is_imaginary\n        if imlog is not None:\n            return False  # I**i -> real; (2*I)**i -> complex ==> not imaginary\n\n    if self.base.is_extended_real and self.exp.is_extended_real:\n        if self.base.is_positive:\n            return False\n        else:\n            rat = self.exp.is_rational\n            if not rat:\n                return rat\n            if self.exp.is_integer:\n                return False\n            else:\n                half = (2*self.exp).is_integer\n                if half:\n                    return self.base.is_negative\n                return half\n\n    if self.base.is_extended_real is False:  # we already know it's not imag\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base)*self.exp/S.Pi\n        isodd = (2*i).is_odd\n        if isodd is not None:\n            return isodd",
    "sympy.sympy.core.power._eval_is_odd": "def _eval_is_odd(self):\n    if self.exp.is_integer:\n        if self.exp.is_positive:\n            return self.base.is_odd\n        elif self.exp.is_nonnegative and self.base.is_odd:\n            return True\n        elif self.base is S.NegativeOne:\n            return True",
    "sympy.sympy.core.power._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite or self.base.is_nonzero:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    "sympy.sympy.core.power._eval_is_prime": "def _eval_is_prime(self):\n    '''\n    An integer raised to the n(>=2)-th power cannot be a prime.\n    '''\n    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:\n        return False",
    "sympy.sympy.core.power._eval_is_composite": "def _eval_is_composite(self):\n    \"\"\"\n    A power is composite if both base and exponent are greater than 1\n    \"\"\"\n    if (self.base.is_integer and self.exp.is_integer and\n        ((self.base - 1).is_positive and (self.exp - 1).is_positive or\n        (self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):\n        return True",
    "sympy.sympy.core.power._eval_is_polar": "def _eval_is_polar(self):\n    return self.base.is_polar",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_integer": "def _eval_is_integer(self):\n    return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,\n                      self.args[1].is_nonnegative))",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    if self.args[0].is_integer and self.args[0].is_nonnegative:\n        return True",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_positive": "def _eval_is_positive(self):\n    # Double factorial is positive for every nonnegative input, and for\n    # every odd negative input which is of the form -1-4k for an\n    # nonnegative integer k\n    n = self.args[0]\n    if n.is_integer:\n        if (n + 1).is_nonnegative:\n            return True\n        if n.is_odd:\n            return ((n + 1) / 2).is_even",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_even": "def _eval_is_even(self):\n    # Double factorial is even for every positive even input\n    n = self.args[0]\n    if n.is_integer:\n        if n.is_odd:\n            return False\n        if n.is_even:\n            if n.is_positive:\n                return True\n            if n.is_zero:\n                return False",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_composite": "def _eval_is_composite(self):\n    x = self.args[0]\n    if x.is_integer and x.is_nonnegative:\n        return (x - 3).is_nonnegative",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_real": "def _eval_is_real(self):\n    x = self.args[0]\n    if x.is_nonnegative or x.is_noninteger:\n        return True",
    "sympy.sympy.functions.combinatorial.factorials._eval_is_odd": "def _eval_is_odd(self):\n    # Double factorial is odd for every odd input not smaller than -3, and\n    # for 0\n    n = self.args[0]\n    if n.is_odd:\n        return (n + 3).is_nonnegative\n    if n.is_even:\n        if n.is_positive:\n            return False\n        if n.is_zero:\n            return True",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_integer": "def _eval_is_integer(self):\n    n = self.args[0]\n    if n.is_integer and n.is_nonnegative:\n        return True",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_positive": "def _eval_is_positive(self):\n    if self.args[0].is_nonnegative is True:\n        return True",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_composite": "def _eval_is_composite(self):\n    if self.args[0].is_integer and (self.args[0] - 3).is_positive:\n        return True",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_negative": "def _eval_is_negative(self):\n    if len(self.args) > 1 and self.args[1] != 1:\n        return\n    n = self.args[0]\n    if n.is_integer and n.is_nonnegative:\n        if n.is_odd:\n            return fuzzy_not((n-1).is_positive)\n        return (n/2).is_odd",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_even": "def _eval_is_even(self):\n    if len(self.args) > 1 and self.args[1] != 1:\n        return\n    n = self.args[0]\n    if n.is_integer and n.is_nonnegative:\n        if n.is_even:\n            return n.is_zero\n        return (n-1).is_positive",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_odd": "def _eval_is_odd(self):\n    if len(self.args) > 1 and self.args[1] != 1:\n        return\n    n = self.args[0]\n    if n.is_integer and n.is_nonnegative:\n        if n.is_even:\n            return fuzzy_not(n.is_zero)\n        return fuzzy_not((n-1).is_positive)",
    "sympy.sympy.functions.combinatorial.numbers._eval_is_prime": "def _eval_is_prime(self):\n    if len(self.args) > 1 and self.args[1] != 1:\n        return\n    n = self.args[0]\n    # only G_6 = -3 and G_8 = 17 are prime,\n    # but SymPy does not consider negatives as prime\n    # so only n=8 is tested\n    return (n-8).is_zero",
    "sympy.sympy.functions.elementary.complexes._eval_is_algebraic": "def _eval_is_algebraic(self):\n    return self.args[0].is_algebraic",
    "sympy.sympy.functions.elementary.complexes._eval_is_zero": "def _eval_is_zero(self):\n    return self._args[0].is_zero",
    "sympy.sympy.functions.elementary.complexes._eval_is_finite": "def _eval_is_finite(self):\n    if self.args[0].is_finite:\n        return True",
    "sympy.sympy.functions.elementary.complexes._eval_is_complex": "def _eval_is_complex(self):\n    if self.args[0].is_finite:\n        return True",
    "sympy.sympy.functions.elementary.complexes._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    if self.args[0].is_nonnegative:\n        return True",
    "sympy.sympy.functions.elementary.complexes._eval_is_nonpositive": "def _eval_is_nonpositive(self):\n    if self.args[0].is_nonpositive:\n        return True",
    "sympy.sympy.functions.elementary.complexes._eval_is_imaginary": "def _eval_is_imaginary(self):\n    return self.args[0].is_imaginary",
    "sympy.sympy.functions.elementary.complexes._eval_is_integer": "def _eval_is_integer(self):\n    if self.args[0].is_extended_real:\n        return self.args[0].is_integer",
    "sympy.sympy.functions.elementary.complexes._eval_is_real": "def _eval_is_real(self):\n    if self.args[0].is_finite:\n        return True",
    "sympy.sympy.functions.elementary.complexes._eval_is_extended_nonzero": "def _eval_is_extended_nonzero(self):\n    return fuzzy_not(self._args[0].is_zero)",
    "sympy.sympy.functions.elementary.complexes._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return fuzzy_not(self._args[0].is_zero)",
    "sympy.sympy.functions.elementary.complexes._eval_is_rational": "def _eval_is_rational(self):\n    if self.args[0].is_extended_real:\n        return self.args[0].is_rational",
    "sympy.sympy.functions.elementary.complexes._eval_is_even": "def _eval_is_even(self):\n    if self.args[0].is_extended_real:\n        return self.args[0].is_even",
    "sympy.sympy.functions.elementary.complexes._eval_is_odd": "def _eval_is_odd(self):\n    if self.args[0].is_extended_real:\n        return self.args[0].is_odd",
    "sympy.sympy.functions.elementary.exponential._eval_is_rational": "def _eval_is_rational(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if (self.args[0] - 1).is_zero:\n            return True\n        if s.args[0].is_rational and fuzzy_not((self.args[0] - 1).is_zero):\n            return False\n    else:\n        return s.is_rational",
    "sympy.sympy.functions.elementary.exponential._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self.args[0].is_extended_positive",
    "sympy.sympy.functions.elementary.exponential._eval_is_zero": "def _eval_is_zero(self):\n    return (self.args[0] - 1).is_zero",
    "sympy.sympy.functions.elementary.exponential._eval_is_finite": "def _eval_is_finite(self):\n    arg = self.exp\n    if arg.is_infinite:\n        if arg.is_extended_negative:\n            return True\n        if arg.is_extended_positive:\n            return False\n    if arg.is_finite:\n        return True",
    "sympy.sympy.functions.elementary.exponential._eval_is_algebraic": "def _eval_is_algebraic(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if (self.args[0] - 1).is_zero:\n            return True\n        elif fuzzy_not((self.args[0] - 1).is_zero):\n            if self.args[0].is_algebraic:\n                return False\n    else:\n        return s.is_algebraic",
    "sympy.sympy.functions.elementary.exponential._eval_is_complex": "def _eval_is_complex(self):\n    z = self.args[0]\n    return fuzzy_and([z.is_complex, fuzzy_not(z.is_zero)])",
    "sympy.sympy.functions.elementary.exponential._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return (self.args[0] - 1).is_extended_positive",
    "sympy.sympy.functions.elementary.exponential._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    return (self.args[0] - 1).is_extended_nonnegative",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.args[0].is_extended_real:\n        return True",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_finite": "def _eval_is_finite(self):\n    arg = self.args[0]\n\n    re, im = arg.as_real_imag()\n    denom = cos(im)**2 + sinh(re)**2\n    if denom == 0:\n        return False\n    elif denom.is_number:\n        return True\n    if arg.is_extended_real:\n        return True",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_positive": "def _eval_is_positive(self):\n    if self.args[0].is_extended_real:\n        return self.args[0].is_positive",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_negative": "def _eval_is_negative(self):\n    if self.args[0].is_extended_real:\n        return self.args[0].is_negative",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_zero": "def _eval_is_zero(self):\n    arg = self.args[0]\n    if arg.is_zero:\n        return True",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_imaginary": "def _eval_is_imaginary(self):\n    return self.args[0].is_imaginary",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_real": "def _eval_is_real(self):\n    arg = self.args[0]\n    if arg.is_real:\n        return True\n\n    re, im = arg.as_real_imag()\n\n    # if denom = 0, tanh(arg) = zoo\n    if re == 0 and im % pi == pi/2:\n        return None\n\n    # check if im is of the form n*pi/2 to make sin(2*im) = 0\n    # if not, im could be a number, return False in that case\n    return (im % (pi/2)).is_zero",
    "sympy.sympy.functions.elementary.hyperbolic._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    z = self.args[0]\n\n    x, y = z.as_real_imag()\n    ymod = y % (2*pi)\n\n    yzero = ymod.is_zero\n    # shortcut if ymod is zero\n    if yzero:\n        return True\n\n    xzero = x.is_zero\n    # shortcut x is not zero\n    if xzero is False:\n        return yzero\n\n    return fuzzy_or([\n            # Case 1:\n            yzero,\n            # Case 2:\n            fuzzy_and([\n                xzero,\n                fuzzy_or([ymod <= pi/2, ymod >= 3*pi/2])\n            ])\n        ])",
    "sympy.sympy.functions.elementary.integers._eval_is_negative": "def _eval_is_negative(self):\n    return False",
    "sympy.sympy.functions.elementary.integers._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    return self.args[0].is_nonnegative",
    "sympy.sympy.functions.elementary.integers._eval_is_positive": "def _eval_is_positive(self):\n    return self.args[0].is_positive",
    "sympy.sympy.functions.elementary.integers._eval_is_nonpositive": "def _eval_is_nonpositive(self):\n    return self.args[0].is_nonpositive",
    "sympy.sympy.functions.elementary.integers._eval_is_finite": "def _eval_is_finite(self):\n    return self.args[0].is_finite",
    "sympy.sympy.functions.elementary.integers._eval_is_real": "def _eval_is_real(self):\n    return self.args[0].is_real",
    "sympy.sympy.functions.elementary.integers._eval_is_imaginary": "def _eval_is_imaginary(self):\n    return self.args[0].is_imaginary",
    "sympy.sympy.functions.elementary.integers._eval_is_integer": "def _eval_is_integer(self):\n    return self.args[0].is_real",
    "sympy.sympy.functions.elementary.integers._eval_is_zero": "def _eval_is_zero(self):\n    return fuzzy_or([self.args[0].is_zero, self.args[0].is_integer])",
    "sympy.sympy.functions.elementary.miscellaneous.<lambda>": "_eval_is_zero = lambda s: _torf(i.is_zero for i in s.args)\n\n\n",
    "sympy.sympy.functions.elementary.miscellaneous._eval_is_positive": "def _eval_is_positive(self):\n    return fuzzy_and(a.is_positive for a in self.args)",
    "sympy.sympy.functions.elementary.miscellaneous._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    return fuzzy_and(a.is_nonnegative for a in self.args)",
    "sympy.sympy.functions.elementary.miscellaneous._eval_is_negative": "def _eval_is_negative(self):\n    return fuzzy_or(a.is_negative for a in self.args)",
    "sympy.sympy.functions.elementary.piecewise.<lambda>": "_eval_is_zero = lambda self: self._eval_template_is_attr(\n    'is_zero')\n\n",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.args[0].is_extended_real:\n        return True",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_real": "def _eval_is_real(self):\n    return self.args[0].is_extended_real",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_finite": "def _eval_is_finite(self):\n    arg = self.args[0]\n\n    if arg.is_extended_real:\n        return True",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_zero": "def _eval_is_zero(self):\n    rest, pi_mult = _peeloff_pi(self.args[0])\n    if rest.is_zero and pi_mult:\n        return (pi_mult - S.Half).is_integer",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_complex": "def _eval_is_complex(self):\n    if self.args[0].is_extended_real \\\n        or self.args[0].is_complex:\n        return True",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_rational": "def _eval_is_rational(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):\n            return False\n    else:\n        return s.is_rational",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_positive": "def _eval_is_positive(self):\n    return self.args[0].is_nonnegative",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_negative": "def _eval_is_negative(self):\n    return self.args[0].is_negative",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    return self.args[0].is_extended_nonnegative",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_algebraic": "def _eval_is_algebraic(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:\n            return False\n        pi_coeff = _pi_coeff(self.args[0])\n        if pi_coeff is not None and pi_coeff.is_rational:\n            return True\n    else:\n        return s.is_algebraic",
    "sympy.sympy.functions.special.bessel._eval_is_extended_real": "def _eval_is_extended_real(self):\n    nu, z = self.args\n    if nu.is_integer and z.is_positive:\n        return True",
    "sympy.sympy.functions.special.beta_functions._eval_is_real": "def _eval_is_real(self):\n    if all(arg.is_real for arg in self.args):\n        return True",
    "sympy.sympy.functions.special.elliptic_integrals._eval_is_zero": "def _eval_is_zero(self):\n    m = self.args[0]\n    if m.is_infinite:\n        return True",
    "sympy.sympy.functions.special.error_functions._eval_is_zero": "def _eval_is_zero(self):\n    return (self.args[0] - 1).is_zero",
    "sympy.sympy.functions.special.error_functions._eval_is_real": "def _eval_is_real(self):\n    if self.args[0].is_extended_real is True:\n        return True\n    if self.args[0].is_imaginary is True:\n        return False",
    "sympy.sympy.functions.special.error_functions._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if self.args[0].is_imaginary is True:\n        return True",
    "sympy.sympy.functions.special.error_functions._eval_is_finite": "def _eval_is_finite(self):\n    z = self.args[0]\n    return fuzzy_or([z.is_finite, z.is_extended_real])",
    "sympy.sympy.functions.special.error_functions._eval_is_positive": "def _eval_is_positive(self):\n    if self.args[0].is_extended_real is True:\n        return self.args[0].is_extended_positive",
    "sympy.sympy.functions.special.error_functions._eval_is_negative": "def _eval_is_negative(self):\n    if self.args[0].is_extended_real is True:\n        return self.args[0].is_extended_negative",
    "sympy.sympy.functions.special.error_functions._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self.args[0].is_extended_real and self.args[1].is_extended_real",
    "sympy.sympy.functions.special.error_functions._eval_is_infinite": "def _eval_is_infinite(self):\n    z = self.args[0]\n    return fuzzy_or([z.is_zero, is_eq(z, Integer(2))])",
    "sympy.sympy.functions.special.gamma_functions._eval_is_real": "def _eval_is_real(self):\n    if self.args[0].is_positive and self.args[1].is_positive:\n        return True",
    "sympy.sympy.functions.special.gamma_functions._eval_is_positive": "def _eval_is_positive(self):\n    n, z = self.args\n    if n.is_positive:\n        if n.is_odd and z.is_real:\n            return True\n        if n.is_even and z.is_positive:\n            return False",
    "sympy.sympy.functions.special.gamma_functions._eval_is_negative": "def _eval_is_negative(self):\n    n, z = self.args\n    if n.is_positive:\n        if n.is_even and z.is_positive:\n            return True\n        if n.is_odd and z.is_real:\n            return False",
    "sympy.sympy.functions.special.gamma_functions._eval_is_zero": "def _eval_is_zero(self):\n    x = self.args[1]\n    if x.is_zero:\n        return True",
    "sympy.sympy.functions.special.gamma_functions._eval_is_complex": "def _eval_is_complex(self):\n    z = self.args[1]\n    is_negative_integer = fuzzy_and([z.is_negative, z.is_integer])\n    return fuzzy_and([z.is_complex, fuzzy_not(is_negative_integer)])",
    "sympy.sympy.functions.special.zeta_functions._eval_is_zero": "def _eval_is_zero(self):\n    z = self.args[1]\n    if z.is_zero:\n        return True",
    "sympy.sympy.functions.special.zeta_functions._eval_is_finite": "def _eval_is_finite(self):\n    return fuzzy_not((self.args[0] - 1).is_zero)",
    "sympy.sympy.integrals.integrals._eval_is_zero": "def _eval_is_zero(self):\n    # This is a very naive and quick test, not intended to do the integral to\n    # answer whether it is zero or not, e.g. Integral(sin(x), (x, 0, 2*pi))\n    # is zero but this routine should return None for that case. But, like\n    # Mul, there are trivial situations for which the integral will be\n    # zero so we check for those.\n    if self.function.is_zero:\n        return True\n    got_none = False\n    for l in self.limits:\n        if len(l) == 3:\n            z = (l[1] == l[2]) or (l[1] - l[2]).is_zero\n            if z:\n                return True\n            elif z is None:\n                got_none = True\n    free = self.function.free_symbols\n    for xab in self.limits:\n        if len(xab) == 1:\n            free.add(xab[0])\n            continue\n        if len(xab) == 2 and xab[0] not in free:\n            if xab[1].is_zero:\n                return True\n            elif xab[1].is_zero is None:\n                got_none = True\n        # take integration symbol out of free since it will be replaced\n        # with the free symbols in the limits\n        free.discard(xab[0])\n        # add in the new symbols\n        for i in xab[1:]:\n            free.update(i.free_symbols)\n    if self.function.is_zero is False and got_none is False:\n        return False",
    "sympy.sympy.physics.units.quantities._eval_is_positive": "def _eval_is_positive(self):\n    return True",
    "sympy.sympy.polys.rootoftools._eval_is_real": "def _eval_is_real(self):\n    \"\"\"Return ``True`` if the root is real. \"\"\"\n    self._ensure_reals_init()\n    return self.index < len(_reals_cache[self.poly])",
    "sympy.sympy.polys.rootoftools._eval_is_imaginary": "def _eval_is_imaginary(self):\n    \"\"\"Return ``True`` if the root is imaginary. \"\"\"\n    self._ensure_reals_init()\n    if self.index >= len(_reals_cache[self.poly]):\n        ivl = self._get_interval()\n        return ivl.ax*ivl.bx <= 0  # all others are on one side or the other\n    return False  # XXX is this necessary?",
    "sympy.sympy.printing.rust._eval_is_integer": "def _eval_is_integer(self):\n    return False",
    "sympy.sympy.stats.rv._eval_is_positive": "def _eval_is_positive(self):\n    return self.symbol.is_positive",
    "sympy.sympy.stats.rv._eval_is_integer": "def _eval_is_integer(self):\n    return self.symbol.is_integer",
    "sympy.sympy.stats.rv._eval_is_real": "def _eval_is_real(self):\n    return self.symbol.is_real or self.pspace.is_real",
    "sympy.sympy.stats.symbolic_probability._eval_is_commutative": "def _eval_is_commutative(self):\n    return self.args[0].is_commutative"
}