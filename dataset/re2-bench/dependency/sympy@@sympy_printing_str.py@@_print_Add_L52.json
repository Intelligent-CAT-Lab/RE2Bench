{
    "sympy.sympy.printing.precedence.precedence": "def precedence(item):\n    \"\"\"Returns the precedence of a given object.\n\n    This is the precedence for StrPrinter.\n    \"\"\"\n    if hasattr(item, \"precedence\"):\n        return item.precedence\n    if not isinstance(item, type):\n        for i in type(item).mro():\n            n = i.__name__\n            if n in PRECEDENCE_FUNCTIONS:\n                return PRECEDENCE_FUNCTIONS[n](item)\n            elif n in PRECEDENCE_VALUES:\n                return PRECEDENCE_VALUES[n]\n    return PRECEDENCE[\"Atom\"]",
    "sympy.sympy.printing.printer._print": "def _print(self, expr, **kwargs) -> str:\n    \"\"\"Internal dispatcher\n\n    Tries the following concepts to print an expression:\n        1. Let the object print itself if it knows how.\n        2. Take the best fitting method defined in the printer.\n        3. As fall-back use the emptyPrinter method for the printer.\n    \"\"\"\n    self._print_level += 1\n    try:\n        # If the printer defines a name for a printing method\n        # (Printer.printmethod) and the object knows for itself how it\n        # should be printed, use that method.\n        if self.printmethod and hasattr(expr, self.printmethod):\n            if not (isinstance(expr, type) and issubclass(expr, Basic)):\n                return getattr(expr, self.printmethod)(self, **kwargs)\n\n        # See if the class of expr is known, or if one of its super\n        # classes is known, and use that print function\n        # Exception: ignore the subclasses of Undefined, so that, e.g.,\n        # Function('gamma') does not get dispatched to _print_gamma\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        # Another exception: if someone subclasses a known function, e.g.,\n        # gamma, and changes the name, then ignore _print_gamma\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple(c for c in classes[:i] if \\\n                c.__name__ == classes[0].__name__ or \\\n                c.__name__.endswith(\"Base\")) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        # Unknown object, fall back to the emptyPrinter.\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    "sympy.sympy.printing.printer._as_ordered_terms": "def _as_ordered_terms(self, expr, order=None):\n    \"\"\"A compatibility function for ordering terms in Add. \"\"\"\n    order = order or self.order\n\n    if order == 'old':\n        return sorted(Add.make_args(expr), key=cmp_to_key(self._compare_pretty))\n    elif order == 'none':\n        return list(expr.args)\n    else:\n        return expr.as_ordered_terms(order=order)"
}