{
    "sympy.sympy.concrete.expr_with_limits.function": "@property\ndef function(self):\n    \"\"\"Return the function applied across limits.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x\n    >>> Integral(x**2, (x,)).function\n    x**2\n\n    See Also\n    ========\n\n    limits, variables, free_symbols\n    \"\"\"\n    return self._args[0]",
    "sympy.sympy.concrete.expr_with_limits.limits": "@property\ndef limits(self):\n    \"\"\"Return the limits of expression.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, i\n    >>> Integral(x**i, (i, 1, 3)).limits\n    ((i, 1, 3),)\n\n    See Also\n    ========\n\n    function, variables, free_symbols\n    \"\"\"\n    return self._args[1:]",
    "sympy.sympy.concrete.expr_with_limits.variables": "@property\ndef variables(self):\n    \"\"\"Return a list of the limit variables.\n\n    >>> from sympy import Sum\n    >>> from sympy.abc import x, i\n    >>> Sum(x**i, (i, 1, 3)).variables\n    [i]\n\n    See Also\n    ========\n\n    function, limits, free_symbols\n    as_dummy : Rename dummy variables\n    sympy.integrals.integrals.Integral.transform : Perform mapping on the dummy variable\n    \"\"\"\n    return [l[0] for l in self.limits]",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.concrete.summations.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        f = self.function.doit(**hints)\n    else:\n        f = self.function\n\n    # first make sure any definite limits have summation\n    # variables with matching assumptions\n    reps = {}\n    for xab in self.limits:\n        d = _dummy_with_inherited_properties_concrete(xab)\n        if d:\n            reps[xab[0]] = d\n    if reps:\n        undo = {v: k for k, v in reps.items()}\n        did = self.xreplace(reps).doit(**hints)\n        if isinstance(did, tuple):  # when separate=True\n            did = tuple([i.xreplace(undo) for i in did])\n        elif did is not None:\n            did = did.xreplace(undo)\n        else:\n            did = self\n        return did\n\n\n    if self.function.is_Matrix:\n        expanded = self.expand()\n        if self != expanded:\n            return expanded.doit()\n        return _eval_matrix_sum(self)\n\n    for n, limit in enumerate(self.limits):\n        i, a, b = limit\n        dif = b - a\n        if dif == -1:\n            # Any summation over an empty set is zero\n            return S.Zero\n        if dif.is_integer and dif.is_negative:\n            a, b = b + 1, a - 1\n            f = -f\n\n        newf = eval_sum(f, (i, a, b))\n        if newf is None:\n            if f == self.function:\n                zeta_function = self.eval_zeta_function(f, (i, a, b))\n                if zeta_function is not None:\n                    return zeta_function\n                return self\n            else:\n                return self.func(f, *self.limits[n:])\n        f = newf\n\n    if hints.get('deep', True):\n        # eval_sum could return partially unevaluated\n        # result with Piecewise.  In this case we won't\n        # doit() recursively.\n        if not isinstance(f, Piecewise):\n            return f.doit(**hints)\n\n    return f",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    "sympy.sympy.core.basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None) -> Basic:\n    \"\"\"\n    Replace matching subexpressions of ``self`` with ``value``.\n\n    If ``map = True`` then also return the mapping {old: new} where ``old``\n    was a sub-expression found with query and ``new`` is the replacement\n    value for it. If the expression itself does not match the query, then\n    the returned value will be ``self.xreplace(map)`` otherwise it should\n    be ``self.subs(ordered(map.items()))``.\n\n    Traverses an expression tree and performs replacement of matching\n    subexpressions from the bottom to the top of the tree. The default\n    approach is to do the replacement in a simultaneous fashion so\n    changes made are targeted only once. If this is not desired or causes\n    problems, ``simultaneous`` can be set to False.\n\n    In addition, if an expression containing more than one Wild symbol\n    is being used to match subexpressions and the ``exact`` flag is None\n    it will be set to True so the match will only succeed if all non-zero\n    values are received for each Wild that appears in the match pattern.\n    Setting this to False accepts a match of 0; while setting it True\n    accepts all matches that have a 0 in them. See example below for\n    cautions.\n\n    The list of possible combinations of queries and replacement values\n    is listed below:\n\n    Examples\n    ========\n\n    Initial setup\n\n    >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n    >>> from sympy.abc import x, y\n    >>> f = log(sin(x)) + tan(sin(x**2))\n\n    1.1. type -> type\n        obj.replace(type, newtype)\n\n        When object of type ``type`` is found, replace it with the\n        result of passing its argument(s) to ``newtype``.\n\n        >>> f.replace(sin, cos)\n        log(cos(x)) + tan(cos(x**2))\n        >>> sin(x).replace(sin, cos, map=True)\n        (cos(x), {sin(x): cos(x)})\n        >>> (x*y).replace(Mul, Add)\n        x + y\n\n    1.2. type -> func\n        obj.replace(type, func)\n\n        When object of type ``type`` is found, apply ``func`` to its\n        argument(s). ``func`` must be written to handle the number\n        of arguments of ``type``.\n\n        >>> f.replace(sin, lambda arg: sin(2*arg))\n        log(sin(2*x)) + tan(sin(2*x**2))\n        >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n        sin(2*x*y)\n\n    2.1. pattern -> expr\n        obj.replace(pattern(wild), expr(wild))\n\n        Replace subexpressions matching ``pattern`` with the expression\n        written in terms of the Wild symbols in ``pattern``.\n\n        >>> a, b = map(Wild, 'ab')\n        >>> f.replace(sin(a), tan(a))\n        log(tan(x)) + tan(tan(x**2))\n        >>> f.replace(sin(a), tan(a/2))\n        log(tan(x/2)) + tan(tan(x**2/2))\n        >>> f.replace(sin(a), a)\n        log(x) + tan(x**2)\n        >>> (x*y).replace(a*x, a)\n        y\n\n        Matching is exact by default when more than one Wild symbol\n        is used: matching fails unless the match gives non-zero\n        values for all Wild symbols:\n\n        >>> (2*x + y).replace(a*x + b, b - a)\n        y - 2\n        >>> (2*x).replace(a*x + b, b - a)\n        2*x\n\n        When set to False, the results may be non-intuitive:\n\n        >>> (2*x).replace(a*x + b, b - a, exact=False)\n        2/x\n\n    2.2. pattern -> func\n        obj.replace(pattern(wild), lambda wild: expr(wild))\n\n        All behavior is the same as in 2.1 but now a function in terms of\n        pattern variables is used rather than an expression:\n\n        >>> f.replace(sin(a), lambda a: sin(2*a))\n        log(sin(2*x)) + tan(sin(2*x**2))\n\n    3.1. func -> func\n        obj.replace(filter, func)\n\n        Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n        is True.\n\n        >>> g = 2*sin(x**3)\n        >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n        4*sin(x**9)\n\n    The expression itself is also targeted by the query but is done in\n    such a fashion that changes are not made twice.\n\n        >>> e = x*(x*y + 1)\n        >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n        2*x*(2*x*y + 1)\n\n    When matching a single symbol, `exact` will default to True, but\n    this may or may not be the behavior that is desired:\n\n    Here, we want `exact=False`:\n\n    >>> from sympy import Function\n    >>> f = Function('f')\n    >>> e = f(1) + f(0)\n    >>> q = f(a), lambda a: f(a + 1)\n    >>> e.replace(*q, exact=False)\n    f(1) + f(2)\n    >>> e.replace(*q, exact=True)\n    f(0) + f(2)\n\n    But here, the nature of matching makes selecting\n    the right setting tricky:\n\n    >>> e = x**(1 + y)\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(-x - y + 1)\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n    x\n    >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n    x**(1 - y)\n\n    It is probably better to use a different form of the query\n    that describes the target expression more precisely:\n\n    >>> (1 + x**(1 + y)).replace(\n    ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n    ... lambda x: x.base**(1 - (x.exp - 1)))\n    ...\n    x**(1 - y) + 1\n\n    See Also\n    ========\n\n    subs: substitution of subexpressions as defined by the objects\n          themselves.\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n\n    \"\"\"\n\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n\n        if isinstance(value, type) or callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError(\n                \"given a type, replace() expects another \"\n                \"type or a callable\")\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            from .symbol import Wild\n            exact = (len(query.atoms(Wild)) > 1)\n\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: (value.subs(result)\n                    if all(result.values()) else expr)\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            # match dictionary keys get the trailing underscore stripped\n            # from them and are then passed as keywords to the callable;\n            # if ``exact`` is True, only accept match if there are no null\n            # values amongst those matched.\n            if exact:\n                _value = lambda expr, result: (value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n                    if all(val for val in result.values()) else expr)\n            else:\n                _value = lambda expr, result: value(**\n                    {str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError(\n                \"given an expression, replace() expects \"\n                \"another expression or a callable\")\n    elif callable(query):\n        _query = query\n\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError(\n                \"given a callable, replace() expects \"\n                \"another callable\")\n    else:\n        raise TypeError(\n            \"first argument to replace() must be a \"\n            \"type, an expression or a callable\")\n\n    def walk(rv, F):\n        \"\"\"Apply ``F`` to args and then to result.\n        \"\"\"\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        # if rv is something that was already\n                        # matched (that was changed) then skip\n                        # applying F again\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n\n    mapping = {}  # changes that took place\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv # type: ignore",
    "sympy.sympy.core.basic.doit": "def doit(self, **hints):\n    return self",
    "sympy.sympy.core.basic.rewrite": "def rewrite(self, *args, deep=True, **hints):\n    \"\"\"\n    Rewrite *self* using a defined rule.\n\n    Rewriting transforms an expression to another, which is mathematically\n    equivalent but structurally different. For example you can rewrite\n    trigonometric functions as complex exponentials or combinatorial\n    functions as gamma function.\n\n    This method takes a *pattern* and a *rule* as positional arguments.\n    *pattern* is optional parameter which defines the types of expressions\n    that will be transformed. If it is not passed, all possible expressions\n    will be rewritten. *rule* defines how the expression will be rewritten.\n\n    Parameters\n    ==========\n\n    args : Expr\n        A *rule*, or *pattern* and *rule*.\n        - *pattern* is a type or an iterable of types.\n        - *rule* can be any object.\n\n    deep : bool, optional\n        If ``True``, subexpressions are recursively transformed. Default is\n        ``True``.\n\n    Examples\n    ========\n\n    If *pattern* is unspecified, all possible expressions are transformed.\n\n    >>> from sympy import cos, sin, exp, I\n    >>> from sympy.abc import x\n    >>> expr = cos(x) + I*sin(x)\n    >>> expr.rewrite(exp)\n    exp(I*x)\n\n    Pattern can be a type or an iterable of types.\n\n    >>> expr.rewrite(sin, exp)\n    exp(I*x)/2 + cos(x) - exp(-I*x)/2\n    >>> expr.rewrite([cos,], exp)\n    exp(I*x)/2 + I*sin(x) + exp(-I*x)/2\n    >>> expr.rewrite([cos, sin], exp)\n    exp(I*x)\n\n    Rewriting behavior can be implemented by defining ``_eval_rewrite()``\n    method.\n\n    >>> from sympy import Expr, sqrt, pi\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite(self, rule, args, **hints):\n    ...         x, = args\n    ...         if rule == cos:\n    ...             return cos(pi/2 - x, evaluate=False)\n    ...         if rule == sqrt:\n    ...             return sqrt(1 - cos(x)**2)\n    >>> MySin(MySin(x)).rewrite(cos)\n    cos(-cos(-x + pi/2) + pi/2)\n    >>> MySin(x).rewrite(sqrt)\n    sqrt(1 - cos(x)**2)\n\n    Defining ``_eval_rewrite_as_[...]()`` method is supported for backwards\n    compatibility reason. This may be removed in the future and using it is\n    discouraged.\n\n    >>> class MySin(Expr):\n    ...     def _eval_rewrite_as_cos(self, *args, **hints):\n    ...         x, = args\n    ...         return cos(pi/2 - x, evaluate=False)\n    >>> MySin(x).rewrite(cos)\n    cos(-x + pi/2)\n\n    \"\"\"\n    if not args:\n        return self\n\n    hints.update(deep=deep)\n\n    pattern = args[:-1]\n    rule = args[-1]\n\n    # Special case: map `abs` to `Abs`\n    if rule is abs:\n        from sympy.functions.elementary.complexes import Abs\n        rule = Abs\n\n    # support old design by _eval_rewrite_as_[...] method\n    if isinstance(rule, str):\n        method = \"_eval_rewrite_as_%s\" % rule\n    elif hasattr(rule, \"__name__\"):\n        # rule is class or function\n        clsname = rule.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n    else:\n        # rule is instance\n        clsname = rule.__class__.__name__\n        method = \"_eval_rewrite_as_%s\" % clsname\n\n    if pattern:\n        if iterable(pattern[0]):\n            pattern = pattern[0]\n        pattern = tuple(p for p in pattern if self.has(p))\n        if not pattern:\n            return self\n    # hereafter, empty pattern is interpreted as all pattern.\n\n    return self._rewrite(pattern, rule, method, **hints)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    "sympy.sympy.core.containers.__len__": "def __len__(self):\n    return len(self.args)",
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.diff": "def diff(self, *symbols, **assumptions) -> Expr:\n    assumptions.setdefault(\"evaluate\", True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    "sympy.sympy.core.expr.factor": "def factor(self, *gens, **args):\n    \"\"\"See the factor() function in sympy.polys.polytools\"\"\"\n    from sympy.polys.polytools import factor\n    return factor(self, *gens, **args)",
    "sympy.sympy.core.expr._eval_interval": "def _eval_interval(self, x, a, b):\n    \"\"\"\n    Returns evaluation over an interval.  For most functions this is:\n\n    self.subs(x, b) - self.subs(x, a),\n\n    possibly using limit() if NaN is returned from subs, or if\n    singularities are found between a and b.\n\n    If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),\n    respectively.\n\n    \"\"\"\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.functions.elementary.exponential import log\n    from sympy.series.limits import limit, Limit\n    from sympy.sets.sets import Interval\n    from sympy.solvers.solveset import solveset\n\n    if (a is None and b is None):\n        raise ValueError('Both interval ends cannot be None.')\n\n    def _eval_endpoint(left):\n        c = a if left else b\n        if c is None:\n            return S.Zero\n        else:\n            C = self.subs(x, c)\n            if C.has(S.NaN, S.Infinity, S.NegativeInfinity,\n                     S.ComplexInfinity, AccumBounds):\n                if (a < b) != False:\n                    C = limit(self, x, c, \"+\" if left else \"-\")\n                else:\n                    C = limit(self, x, c, \"-\" if left else \"+\")\n\n                if isinstance(C, Limit):\n                    raise NotImplementedError(\"Could not compute limit\")\n        return C\n\n    if a == b:\n        return S.Zero\n\n    A = _eval_endpoint(left=True)\n    if A is S.NaN:\n        return A\n\n    B = _eval_endpoint(left=False)\n\n    if (a and b) is None:\n        return B - A\n\n    value = B - A\n\n    if a.is_comparable and b.is_comparable:\n        if a < b:\n            domain = Interval(a, b)\n        else:\n            domain = Interval(b, a)\n        # check the singularities of self within the interval\n        # if singularities is a ConditionSet (not iterable), catch the exception and pass\n        singularities = solveset(self.cancel().as_numer_denom()[1], x,\n            domain=domain)\n        for logterm in self.atoms(log):\n            singularities = singularities | solveset(logterm.args[0], x,\n                domain=domain)\n        try:\n            for s in singularities:\n                if value is S.NaN:\n                    # no need to keep adding, it will stay NaN\n                    break\n                if not s.is_comparable:\n                    continue\n                if (a < s) == (s < b) == True:\n                    value += -limit(self, x, s, \"+\") + limit(self, x, s, \"-\")\n                elif (b < s) == (s < a) == True:\n                    value += limit(self, x, s, \"+\") - limit(self, x, s, \"-\")\n        except TypeError:\n            pass\n\n    return value",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p + self.p*other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__neg__": "def __neg__(self):\n    return S.NegativeInfinity",
    "sympy.sympy.core.operations.make_args": "@classmethod\ndef make_args(cls: type[Basic], expr: Basic) -> tuple[Basic, ...]:\n    \"\"\"\n    Return a sequence of elements `args` such that cls(*args) == expr\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Mul, Add\n    >>> x, y = map(Symbol, 'xy')\n\n    >>> Mul.make_args(x*y)\n    (x, y)\n    >>> Add.make_args(x*y)\n    (x*y,)\n    >>> set(Add.make_args(x*y + y)) == set([y, x*y])\n    True\n\n    \"\"\"\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    "sympy.sympy.core.operations.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        terms = [term.doit(**hints) for term in self.args]\n    else:\n        terms = self.args\n    return self.func(*terms, evaluate=True)",
    "sympy.sympy.core.symbol.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    return {self}",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str | None = None,\n                 dummy_index: int | None = None,\n                 **assumptions: bool | None) -> Self:\n    if dummy_index is not None:\n        assert name is not None, \"If you specify a dummy_index, you must also provide a name\"\n\n    if name is None:\n        name = \"Dummy_\" + str(Dummy._count)\n\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n\n    obj.dummy_index = dummy_index\n\n    return obj",
    "sympy.sympy.functions.elementary.piecewise.doit": "def doit(self, **hints):\n    \"\"\"\n    Evaluate this piecewise function.\n    \"\"\"\n    newargs = []\n    for e, c in self.args:\n        if hints.get('deep', True):\n            if isinstance(e, Basic):\n                newe = e.doit(**hints)\n                if newe != self:\n                    e = newe\n            if isinstance(c, Basic):\n                c = c.doit(**hints)\n        newargs.append((e, c))\n    return self.func(*newargs)",
    "sympy.sympy.functions.elementary.piecewise._eval_integral": "def _eval_integral(self, x, _first=True, **kwargs):\n    \"\"\"Return the indefinite integral of the\n    Piecewise such that subsequent substitution of x with a\n    value will give the value of the integral (not including\n    the constant of integration) up to that point. To only\n    integrate the individual parts of Piecewise, use the\n    ``piecewise_integrate`` method.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise\n    >>> from sympy.abc import x\n    >>> p = Piecewise((0, x < 0), (1, x < 1), (2, True))\n    >>> p.integrate(x)\n    Piecewise((0, x < 0), (x, x < 1), (2*x - 1, True))\n    >>> p.piecewise_integrate(x)\n    Piecewise((0, x < 0), (x, x < 1), (2*x, True))\n\n    See Also\n    ========\n    Piecewise.piecewise_integrate\n    \"\"\"\n    from sympy.integrals.integrals import integrate\n\n    if _first:\n        def handler(ipw):\n            if isinstance(ipw, self.func):\n                return ipw._eval_integral(x, _first=False, **kwargs)\n            else:\n                return ipw.integrate(x, **kwargs)\n        irv = self._handle_irel(x, handler)\n        if irv is not None:\n            return irv\n\n    # handle a Piecewise from -oo to oo with and no x-independent relationals\n    # -----------------------------------------------------------------------\n    ok, abei = self._intervals(x)\n    if not ok:\n        from sympy.integrals.integrals import Integral\n        return Integral(self, x)  # unevaluated\n\n    pieces = [(a, b) for a, b, _, _ in abei]\n    oo = S.Infinity\n    done = [(-oo, oo, -1)]\n    for k, p in enumerate(pieces):\n        if p == (-oo, oo):\n            # all undone intervals will get this key\n            for j, (a, b, i) in enumerate(done):\n                if i == -1:\n                    done[j] = a, b, k\n            break  # nothing else to consider\n        N = len(done) - 1\n        for j, (a, b, i) in enumerate(reversed(done)):\n            if i == -1:\n                j = N - j\n                done[j: j + 1] = _clip(p, (a, b), k)\n    done = [(a, b, i) for a, b, i in done if a != b]\n\n    # append an arg if there is a hole so a reference to\n    # argument -1 will give Undefined\n    if any(i == -1 for (a, b, i) in done):\n        abei.append((-oo, oo, Undefined, -1))\n\n    # return the sum of the intervals\n    args = []\n    sum = None\n    for a, b, i in done:\n        anti = integrate(abei[i][-2], x, **kwargs)\n        if sum is None:\n            sum = anti\n        else:\n            sum = sum.subs(x, a)\n            e = anti._eval_interval(x, a, x)\n            if sum.has(*_illegal) or e.has(*_illegal):\n                sum = anti\n            else:\n                sum += e\n        # see if we know whether b is contained in original\n        # condition\n        if b is S.Infinity:\n            cond = True\n        elif self.args[abei[i][-1]].cond.subs(x, b) == False:\n            cond = (x < b)\n        else:\n            cond = (x <= b)\n        args.append((sum, cond))\n    return Piecewise(*args)",
    "sympy.sympy.functions.elementary.piecewise._eval_interval": "def _eval_interval(self, sym, a, b, _first=True):\n    \"\"\"Evaluates the function along the sym in a given interval [a, b]\"\"\"\n    # FIXME: Currently complex intervals are not supported.  A possible\n    # replacement algorithm, discussed in issue 5227, can be found in the\n    # following papers;\n    #     http://portal.acm.org/citation.cfm?id=281649\n    #     http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.4127&rep=rep1&type=pdf\n\n    if a is None or b is None:\n        # In this case, it is just simple substitution\n        return super()._eval_interval(sym, a, b)\n    else:\n        x, lo, hi = map(as_Basic, (sym, a, b))\n\n    if _first:  # get only x-dependent relationals\n        def handler(ipw):\n            if isinstance(ipw, self.func):\n                return ipw._eval_interval(x, lo, hi, _first=None)\n            else:\n                return ipw._eval_interval(x, lo, hi)\n        irv = self._handle_irel(x, handler)\n        if irv is not None:\n            return irv\n\n        if (lo < hi) is S.false or (\n                lo is S.Infinity or hi is S.NegativeInfinity):\n            rv = self._eval_interval(x, hi, lo, _first=False)\n            if isinstance(rv, Piecewise):\n                rv = Piecewise(*[(-e, c) for e, c in rv.args])\n            else:\n                rv = -rv\n            return rv\n\n        if (lo < hi) is S.true or (\n                hi is S.Infinity or lo is S.NegativeInfinity):\n            pass\n        else:\n            _a = Dummy('lo')\n            _b = Dummy('hi')\n            a = lo if lo.is_comparable else _a\n            b = hi if hi.is_comparable else _b\n            pos = self._eval_interval(x, a, b, _first=False)\n            if a == _a and b == _b:\n                # it's purely symbolic so just swap lo and hi and\n                # change the sign to get the value for when lo > hi\n                neg, pos = (-pos.xreplace({_a: hi, _b: lo}),\n                    pos.xreplace({_a: lo, _b: hi}))\n            else:\n                # at least one of the bounds was comparable, so allow\n                # _eval_interval to use that information when computing\n                # the interval with lo and hi reversed\n                neg, pos = (-self._eval_interval(x, hi, lo, _first=False),\n                    pos.xreplace({_a: lo, _b: hi}))\n\n            # allow simplification based on ordering of lo and hi\n            p = Dummy('', positive=True)\n            if lo.is_Symbol:\n                pos = pos.xreplace({lo: hi - p}).xreplace({p: hi - lo})\n                neg = neg.xreplace({lo: hi + p}).xreplace({p: lo - hi})\n            elif hi.is_Symbol:\n                pos = pos.xreplace({hi: lo + p}).xreplace({p: hi - lo})\n                neg = neg.xreplace({hi: lo - p}).xreplace({p: lo - hi})\n            # evaluate limits that may have unevaluate Min/Max\n            touch = lambda _: _.replace(\n                lambda x: isinstance(x, (Min, Max)),\n                lambda x: x.func(*x.args))\n            neg = touch(neg)\n            pos = touch(pos)\n            # assemble return expression; make the first condition be Lt\n            # b/c then the first expression will look the same whether\n            # the lo or hi limit is symbolic\n            if a == _a:  # the lower limit was symbolic\n                rv = Piecewise(\n                    (pos,\n                        lo < hi),\n                    (neg,\n                        True))\n            else:\n                rv = Piecewise(\n                    (neg,\n                        hi < lo),\n                    (pos,\n                        True))\n\n            if rv == Undefined:\n                raise ValueError(\"Can't integrate across undefined region.\")\n            if any(isinstance(i, Piecewise) for i in (pos, neg)):\n                rv = piecewise_fold(rv)\n            return rv\n\n    # handle a Piecewise with lo <= hi and no x-independent relationals\n    # -----------------------------------------------------------------\n    ok, abei = self._intervals(x)\n    if not ok:\n        from sympy.integrals.integrals import Integral\n        # not being able to do the interval of f(x) can\n        # be stated as not being able to do the integral\n        # of f'(x) over the same range\n        return Integral(self.diff(x), (x, lo, hi))  # unevaluated\n\n    pieces = [(a, b) for a, b, _, _ in abei]\n    done = [(lo, hi, -1)]\n    oo = S.Infinity\n    for k, p in enumerate(pieces):\n        if p[:2] == (-oo, oo):\n            # all undone intervals will get this key\n            for j, (a, b, i) in enumerate(done):\n                if i == -1:\n                    done[j] = a, b, k\n            break  # nothing else to consider\n        N = len(done) - 1\n        for j, (a, b, i) in enumerate(reversed(done)):\n            if i == -1:\n                j = N - j\n                done[j: j + 1] = _clip(p, (a, b), k)\n    done = [(a, b, i) for a, b, i in done if a != b]\n\n    # return the sum of the intervals\n    sum = S.Zero\n    upto = None\n    for a, b, i in done:\n        if i == -1:\n            if upto is None:\n                return Undefined\n            # TODO simplify hi <= upto\n            return Piecewise((sum, hi <= upto), (Undefined, True))\n        k = abei[i][-2]._eval_interval(x, a, b)\n        if k is Undefined:\n            return Piecewise((sum, hi <= upto), (Undefined, True))\n        else:\n            sum += k\n            upto = b\n    return sum",
    "sympy.sympy.functions.elementary.piecewise.piecewise_fold": "def piecewise_fold(expr, evaluate=True):\n    \"\"\"\n    Takes an expression containing a piecewise function and returns the\n    expression in piecewise form. In addition, any ITE conditions are\n    rewritten in negation normal form and simplified.\n\n    The final Piecewise is evaluated (default) but if the raw form\n    is desired, send ``evaluate=False``; if trivial evaluation is\n    desired, send ``evaluate=None`` and duplicate conditions and\n    processing of True and False will be handled.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, piecewise_fold, S\n    >>> from sympy.abc import x\n    >>> p = Piecewise((x, x < 1), (1, S(1) <= x))\n    >>> piecewise_fold(x*p)\n    Piecewise((x**2, x < 1), (x, True))\n\n    See Also\n    ========\n\n    Piecewise\n    piecewise_exclusive\n    \"\"\"\n    if not isinstance(expr, Basic) or not expr.has(Piecewise):\n        return expr\n\n    new_args = []\n    if isinstance(expr, (ExprCondPair, Piecewise)):\n        for e, c in expr.args:\n            if not isinstance(e, Piecewise):\n                e = piecewise_fold(e)\n            # we don't keep Piecewise in condition because\n            # it has to be checked to see that it's complete\n            # and we convert it to ITE at that time\n            assert not c.has(Piecewise)  # pragma: no cover\n            if isinstance(c, ITE):\n                c = c.to_nnf()\n                c = simplify_logic(c, form='cnf')\n            if isinstance(e, Piecewise):\n                new_args.extend([(piecewise_fold(ei), And(ci, c))\n                    for ei, ci in e.args])\n            else:\n                new_args.append((e, c))\n    else:\n        # Given\n        #     P1 = Piecewise((e11, c1), (e12, c2), A)\n        #     P2 = Piecewise((e21, c1), (e22, c2), B)\n        #     ...\n        # the folding of f(P1, P2) is trivially\n        # Piecewise(\n        #   (f(e11, e21), c1),\n        #   (f(e12, e22), c2),\n        #   (f(Piecewise(A), Piecewise(B)), True))\n        # Certain objects end up rewriting themselves as thus, so\n        # we do that grouping before the more generic folding.\n        # The following applies this idea when f = Add or f = Mul\n        # (and the expression is commutative).\n        if expr.is_Add or expr.is_Mul and expr.is_commutative:\n            p, args = sift(expr.args, lambda x: x.is_Piecewise, binary=True)\n            pc = sift(p, lambda x: tuple([c for e,c in x.args]))\n            for c in list(ordered(pc)):\n                if len(pc[c]) > 1:\n                    pargs = [list(i.args) for i in pc[c]]\n                    # the first one is the same; there may be more\n                    com = common_prefix(*[\n                        [i.cond for i in j] for j in pargs])\n                    n = len(com)\n                    collected = []\n                    for i in range(n):\n                        collected.append((\n                            expr.func(*[ai[i].expr for ai in pargs]),\n                            com[i]))\n                    remains = []\n                    for a in pargs:\n                        if n == len(a):  # no more args\n                            continue\n                        if a[n].cond == True:  # no longer Piecewise\n                            remains.append(a[n].expr)\n                        else:  # restore the remaining Piecewise\n                            remains.append(\n                                Piecewise(*a[n:], evaluate=False))\n                    if remains:\n                        collected.append((expr.func(*remains), True))\n                    args.append(Piecewise(*collected, evaluate=False))\n                    continue\n                args.extend(pc[c])\n        else:\n            args = expr.args\n        # fold\n        folded = list(map(piecewise_fold, args))\n        for ec in product(*[\n                (i.args if isinstance(i, Piecewise) else\n                 [(i, true)]) for i in folded]):\n            e, c = zip(*ec)\n            new_args.append((expr.func(*e), And(*c)))\n\n    if evaluate is None:\n        # don't return duplicate conditions, otherwise don't evaluate\n        new_args = list(reversed([(e, c) for c, e in {\n            c: e for e, c in reversed(new_args)}.items()]))\n    rv = Piecewise(*new_args, evaluate=evaluate)\n    if evaluate is None and len(rv.args) == 1 and rv.args[0].cond == True:\n        return rv.args[0].expr\n    if any(s.expr.has(Piecewise) for p in rv.atoms(Piecewise) for s in p.args):\n        return piecewise_fold(rv)\n    return rv",
    "sympy.sympy.integrals.integrals.doit": "def doit(self, **hints):\n    \"\"\"\n    Perform the integration using any hints given.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, S\n    >>> from sympy.abc import x, t\n    >>> p = x**2 + Piecewise((0, x/t < 0), (1, True))\n    >>> p.integrate((t, S(4)/5, 1), (x, -1, 1))\n    1/3\n\n    See Also\n    ========\n\n    sympy.integrals.trigonometry.trigintegrate\n    sympy.integrals.heurisch.heurisch\n    sympy.integrals.rationaltools.ratint\n    as_sum : Approximate the integral using a sum\n    \"\"\"\n    if not hints.get('integrals', True):\n        return self\n\n    deep = hints.get('deep', True)\n    meijerg = hints.get('meijerg', None)\n    conds = hints.get('conds', 'piecewise')\n    risch = hints.get('risch', None)\n    heurisch = hints.get('heurisch', None)\n    manual = hints.get('manual', None)\n    if len(list(filter(None, (manual, meijerg, risch, heurisch)))) > 1:\n        raise ValueError(\"At most one of manual, meijerg, risch, heurisch can be True\")\n    elif manual:\n        meijerg = risch = heurisch = False\n    elif meijerg:\n        manual = risch = heurisch = False\n    elif risch:\n        manual = meijerg = heurisch = False\n    elif heurisch:\n        manual = meijerg = risch = False\n    eval_kwargs = {\"meijerg\": meijerg, \"risch\": risch, \"manual\": manual, \"heurisch\": heurisch,\n        \"conds\": conds}\n\n    if conds not in ('separate', 'piecewise', 'none'):\n        raise ValueError('conds must be one of \"separate\", \"piecewise\", '\n                         '\"none\", got: %s' % conds)\n\n    if risch and any(len(xab) > 1 for xab in self.limits):\n        raise ValueError('risch=True is only allowed for indefinite integrals.')\n\n    # check for the trivial zero\n    if self.is_zero:\n        return S.Zero\n\n    # hacks to handle integrals of\n    # nested summations\n    from sympy.concrete.summations import Sum\n    if isinstance(self.function, Sum):\n        if any(v in self.function.limits[0] for v in self.variables):\n            raise ValueError('Limit of the sum cannot be an integration variable.')\n        if any(l.is_infinite for l in self.function.limits[0][1:]):\n            return self\n        _i = self\n        _sum = self.function\n        return _sum.func(_i.func(_sum.function, *_i.limits).doit(), *_sum.limits).doit()\n\n    # now compute and check the function\n    function = self.function\n\n    # hack to use a consistent Heaviside(x, 1/2)\n    function = function.replace(\n        lambda x: isinstance(x, Heaviside) and x.args[1]*2 != 1,\n        lambda x: Heaviside(x.args[0]))\n\n    if deep:\n        function = function.doit(**hints)\n    if function.is_zero:\n        return S.Zero\n\n    # hacks to handle special cases\n    if isinstance(function, MatrixBase):\n        return function.applyfunc(\n            lambda f: self.func(f, *self.limits).doit(**hints))\n\n    if isinstance(function, FormalPowerSeries):\n        if len(self.limits) > 1:\n            raise NotImplementedError\n        xab = self.limits[0]\n        if len(xab) > 1:\n            return function.integrate(xab, **eval_kwargs)\n        else:\n            return function.integrate(xab[0], **eval_kwargs)\n\n    # There is no trivial answer and special handling\n    # is done so continue\n\n    # first make sure any definite limits have integration\n    # variables with matching assumptions\n    reps = {}\n    for xab in self.limits:\n        if len(xab) != 3:\n            # it makes sense to just make\n            # all x real but in practice with the\n            # current state of integration...this\n            # doesn't work out well\n            # x = xab[0]\n            # if x not in reps and not x.is_real:\n            #     reps[x] = Dummy(real=True)\n            continue\n        x, a, b = xab\n        l = (a, b)\n        if all(i.is_nonnegative for i in l) and not x.is_nonnegative:\n            d = Dummy(positive=True)\n        elif all(i.is_nonpositive for i in l) and not x.is_nonpositive:\n            d = Dummy(negative=True)\n        elif all(i.is_real for i in l) and not x.is_real:\n            d = Dummy(real=True)\n        else:\n            d = None\n        if d:\n            reps[x] = d\n    if reps:\n        undo = {v: k for k, v in reps.items()}\n        did = self.xreplace(reps).doit(**hints)\n        if isinstance(did, tuple):  # when separate=True\n            did = tuple([i.xreplace(undo) for i in did])\n        else:\n            did = did.xreplace(undo)\n        return did\n\n    # continue with existing assumptions\n    undone_limits = []\n    # ulj = free symbols of any undone limits' upper and lower limits\n    ulj = set()\n    for xab in self.limits:\n        # compute uli, the free symbols in the\n        # Upper and Lower limits of limit I\n        if len(xab) == 1:\n            uli = set(xab[:1])\n        elif len(xab) == 2:\n            uli = xab[1].free_symbols\n        elif len(xab) == 3:\n            uli = xab[1].free_symbols.union(xab[2].free_symbols)\n        # this integral can be done as long as there is no blocking\n        # limit that has been undone. An undone limit is blocking if\n        # it contains an integration variable that is in this limit's\n        # upper or lower free symbols or vice versa\n        if xab[0] in ulj or any(v[0] in uli for v in undone_limits):\n            undone_limits.append(xab)\n            ulj.update(uli)\n            function = self.func(*([function] + [xab]))\n            factored_function = function.factor()\n            if not isinstance(factored_function, Integral):\n                function = factored_function\n            continue\n\n        if function.has(Abs, sign) and (\n            (len(xab) < 3 and all(x.is_extended_real for x in xab)) or\n            (len(xab) == 3 and all(x.is_extended_real and not x.is_infinite for\n             x in xab[1:]))):\n                # some improper integrals are better off with Abs\n                xr = Dummy(\"xr\", real=True)\n                function = (function.xreplace({xab[0]: xr})\n                    .rewrite(Piecewise).xreplace({xr: xab[0]}))\n        elif function.has(Min, Max):\n            function = function.rewrite(Piecewise)\n        if (function.has(Piecewise) and\n            not isinstance(function, Piecewise)):\n                function = piecewise_fold(function)\n        if isinstance(function, Piecewise):\n            if len(xab) == 1:\n                antideriv = function._eval_integral(xab[0],\n                    **eval_kwargs)\n            else:\n                antideriv = self._eval_integral(\n                    function, xab[0], **eval_kwargs)\n        else:\n            # There are a number of tradeoffs in using the\n            # Meijer G method. It can sometimes be a lot faster\n            # than other methods, and sometimes slower. And\n            # there are certain types of integrals for which it\n            # is more likely to work than others. These\n            # heuristics are incorporated in deciding what\n            # integration methods to try, in what order. See the\n            # integrate() docstring for details.\n            def try_meijerg(function, xab):\n                ret = None\n                if len(xab) == 3 and meijerg is not False:\n                    x, a, b = xab\n                    try:\n                        res = meijerint_definite(function, x, a, b)\n                    except NotImplementedError:\n                        _debug('NotImplementedError '\n                            'from meijerint_definite')\n                        res = None\n                    if res is not None:\n                        f, cond = res\n                        if conds == 'piecewise':\n                            u = self.func(function, (x, a, b))\n                            # if Piecewise modifies cond too\n                            # much it may not be recognized by\n                            # _condsimp pattern matching so just\n                            # turn off all evaluation\n                            return Piecewise((f, cond), (u, True),\n                                evaluate=False)\n                        elif conds == 'separate':\n                            if len(self.limits) != 1:\n                                raise ValueError(filldedent('''\n                                    conds=separate not supported in\n                                    multiple integrals'''))\n                            ret = f, cond\n                        else:\n                            ret = f\n                return ret\n\n            meijerg1 = meijerg\n            if (meijerg is not False and\n                    len(xab) == 3 and xab[1].is_extended_real and xab[2].is_extended_real\n                    and not function.is_Poly and\n                    (xab[1].has(oo, -oo) or xab[2].has(oo, -oo))):\n                ret = try_meijerg(function, xab)\n                if ret is not None:\n                    function = ret\n                    continue\n                meijerg1 = False\n            # If the special meijerg code did not succeed in\n            # finding a definite integral, then the code using\n            # meijerint_indefinite will not either (it might\n            # find an antiderivative, but the answer is likely\n            # to be nonsensical). Thus if we are requested to\n            # only use Meijer G-function methods, we give up at\n            # this stage. Otherwise we just disable G-function\n            # methods.\n            if meijerg1 is False and meijerg is True:\n                antideriv = None\n            else:\n                antideriv = self._eval_integral(\n                    function, xab[0], **eval_kwargs)\n                if antideriv is None and meijerg is True:\n                    ret = try_meijerg(function, xab)\n                    if ret is not None:\n                        function = ret\n                        continue\n\n        final = hints.get('final', True)\n        # dotit may be iterated but floor terms making atan and acot\n        # continuous should only be added in the final round\n        if (final and not isinstance(antideriv, Integral) and\n            antideriv is not None):\n            for atan_term in antideriv.atoms(atan):\n                atan_arg = atan_term.args[0]\n                # Checking `atan_arg` to be linear combination of `tan` or `cot`\n                for tan_part in atan_arg.atoms(tan):\n                    x1 = Dummy('x1')\n                    tan_exp1 = atan_arg.subs(tan_part, x1)\n                    # The coefficient of `tan` should be constant\n                    coeff = tan_exp1.diff(x1)\n                    if x1 not in coeff.free_symbols:\n                        a = tan_part.args[0]\n                        antideriv = antideriv.subs(atan_term, Add(atan_term,\n                            sign(coeff)*pi*floor((a-pi/2)/pi)))\n                for cot_part in atan_arg.atoms(cot):\n                    x1 = Dummy('x1')\n                    cot_exp1 = atan_arg.subs(cot_part, x1)\n                    # The coefficient of `cot` should be constant\n                    coeff = cot_exp1.diff(x1)\n                    if x1 not in coeff.free_symbols:\n                        a = cot_part.args[0]\n                        antideriv = antideriv.subs(atan_term, Add(atan_term,\n                            sign(coeff)*pi*floor((a)/pi)))\n\n        if antideriv is None:\n            undone_limits.append(xab)\n            function = self.func(*([function] + [xab])).factor()\n            factored_function = function.factor()\n            if not isinstance(factored_function, Integral):\n                function = factored_function\n            continue\n        else:\n            if len(xab) == 1:\n                function = antideriv\n            else:\n                if len(xab) == 3:\n                    x, a, b = xab\n                elif len(xab) == 2:\n                    x, b = xab\n                    a = None\n                else:\n                    raise NotImplementedError\n\n                if deep:\n                    if isinstance(a, Basic):\n                        a = a.doit(**hints)\n                    if isinstance(b, Basic):\n                        b = b.doit(**hints)\n\n                if antideriv.is_Poly:\n                    gens = list(antideriv.gens)\n                    gens.remove(x)\n\n                    antideriv = antideriv.as_expr()\n\n                    function = antideriv._eval_interval(x, a, b)\n                    function = Poly(function, *gens)\n                else:\n                    def is_indef_int(g, x):\n                        return (isinstance(g, Integral) and\n                                any(i == (x,) for i in g.limits))\n\n                    def eval_factored(f, x, a, b):\n                        # _eval_interval for integrals with\n                        # (constant) factors\n                        # a single indefinite integral is assumed\n                        args = []\n                        for g in Mul.make_args(f):\n                            if is_indef_int(g, x):\n                                args.append(g._eval_interval(x, a, b))\n                            else:\n                                args.append(g)\n                        return Mul(*args)\n\n                    integrals, others, piecewises = [], [], []\n                    for f in Add.make_args(antideriv):\n                        if any(is_indef_int(g, x)\n                               for g in Mul.make_args(f)):\n                            integrals.append(f)\n                        elif any(isinstance(g, Piecewise)\n                                 for g in Mul.make_args(f)):\n                            piecewises.append(piecewise_fold(f))\n                        else:\n                            others.append(f)\n                    uneval = Add(*[eval_factored(f, x, a, b)\n                                   for f in integrals])\n                    try:\n                        evalued = Add(*others)._eval_interval(x, a, b)\n                        evalued_pw = piecewise_fold(Add(*piecewises))._eval_interval(x, a, b)\n                        function = uneval + evalued + evalued_pw\n                    except NotImplementedError:\n                        # This can happen if _eval_interval depends in a\n                        # complicated way on limits that cannot be computed\n                        undone_limits.append(xab)\n                        function = self.func(*([function] + [xab]))\n                        factored_function = function.factor()\n                        if not isinstance(factored_function, Integral):\n                            function = factored_function\n    return function",
    "sympy.sympy.integrals.integrals.<genexpr>": "elif any(isinstance(g, Piecewise)\n         for g in Mul.make_args(f)):\n    piecewises.append(piecewise_fold(f))\n",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.integrals.integrals.<dictcomp>": "undo = {v: k for k, v in reps.items()}\n",
    "sympy.sympy.integrals.integrals.try_meijerg": "def try_meijerg(function, xab):\n    ret = None\n    if len(xab) == 3 and meijerg is not False:\n        x, a, b = xab\n        try:\n            res = meijerint_definite(function, x, a, b)\n        except NotImplementedError:\n            _debug('NotImplementedError '\n                'from meijerint_definite')\n            res = None\n        if res is not None:\n            f, cond = res\n            if conds == 'piecewise':\n                u = self.func(function, (x, a, b))\n                # if Piecewise modifies cond too\n                # much it may not be recognized by\n                # _condsimp pattern matching so just\n                # turn off all evaluation\n                return Piecewise((f, cond), (u, True),\n                    evaluate=False)\n            elif conds == 'separate':\n                if len(self.limits) != 1:\n                    raise ValueError(filldedent('''\n                        conds=separate not supported in\n                        multiple integrals'''))\n                ret = f, cond\n            else:\n                ret = f\n    return ret",
    "sympy.sympy.integrals.integrals.<listcomp>": "uneval = Add(*[eval_factored(f, x, a, b)\n               for f in integrals])\n",
    "sympy.sympy.integrals.integrals._eval_integral": "def _eval_integral(self, f, x, meijerg=None, risch=None, manual=None,\n                   heurisch=None, conds='piecewise',final=None):\n    \"\"\"\n    Calculate the anti-derivative to the function f(x).\n\n    Explanation\n    ===========\n\n    The following algorithms are applied (roughly in this order):\n\n    1. Simple heuristics (based on pattern matching and integral table):\n\n       - most frequently used functions (e.g. polynomials, products of\n         trig functions)\n\n    2. Integration of rational functions:\n\n       - A complete algorithm for integrating rational functions is\n         implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm\n         also uses the partial fraction decomposition algorithm\n         implemented in apart() as a preprocessor to make this process\n         faster.  Note that the integral of a rational function is always\n         elementary, but in general, it may include a RootSum.\n\n    3. Full Risch algorithm:\n\n       - The Risch algorithm is a complete decision\n         procedure for integrating elementary functions, which means that\n         given any elementary function, it will either compute an\n         elementary antiderivative, or else prove that none exists.\n         Currently, part of transcendental case is implemented, meaning\n         elementary integrals containing exponentials, logarithms, and\n         (soon!) trigonometric functions can be computed.  The algebraic\n         case, e.g., functions containing roots, is much more difficult\n         and is not implemented yet.\n\n       - If the routine fails (because the integrand is not elementary, or\n         because a case is not implemented yet), it continues on to the\n         next algorithms below.  If the routine proves that the integrals\n         is nonelementary, it still moves on to the algorithms below,\n         because we might be able to find a closed-form solution in terms\n         of special functions.  If risch=True, however, it will stop here.\n\n    4. The Meijer G-Function algorithm:\n\n       - This algorithm works by first rewriting the integrand in terms of\n         very general Meijer G-Function (meijerg in SymPy), integrating\n         it, and then rewriting the result back, if possible.  This\n         algorithm is particularly powerful for definite integrals (which\n         is actually part of a different method of Integral), since it can\n         compute closed-form solutions of definite integrals even when no\n         closed-form indefinite integral exists.  But it also is capable\n         of computing many indefinite integrals as well.\n\n       - Another advantage of this method is that it can use some results\n         about the Meijer G-Function to give a result in terms of a\n         Piecewise expression, which allows to express conditionally\n         convergent integrals.\n\n       - Setting meijerg=True will cause integrate() to use only this\n         method.\n\n    5. The \"manual integration\" algorithm:\n\n       - This algorithm tries to mimic how a person would find an\n         antiderivative by hand, for example by looking for a\n         substitution or applying integration by parts. This algorithm\n         does not handle as many integrands but can return results in a\n         more familiar form.\n\n       - Sometimes this algorithm can evaluate parts of an integral; in\n         this case integrate() will try to evaluate the rest of the\n         integrand using the other methods here.\n\n       - Setting manual=True will cause integrate() to use only this\n         method.\n\n    6. The Heuristic Risch algorithm:\n\n       - This is a heuristic version of the Risch algorithm, meaning that\n         it is not deterministic.  This is tried as a last resort because\n         it can be very slow.  It is still used because not enough of the\n         full Risch algorithm is implemented, so that there are still some\n         integrals that can only be computed using this method.  The goal\n         is to implement enough of the Risch and Meijer G-function methods\n         so that this can be deleted.\n\n         Setting heurisch=True will cause integrate() to use only this\n         method. Set heurisch=False to not use it.\n\n    \"\"\"\n\n    from sympy.integrals.risch import risch_integrate, NonElementaryIntegral\n    from sympy.integrals.manualintegrate import manualintegrate\n\n    if risch:\n        try:\n            return risch_integrate(f, x, conds=conds)\n        except NotImplementedError:\n            return None\n\n    if manual:\n        try:\n            result = manualintegrate(f, x)\n            if result is not None and result.func != Integral:\n                return result\n        except (ValueError, PolynomialError):\n            pass\n\n    eval_kwargs = {\"meijerg\": meijerg, \"risch\": risch, \"manual\": manual,\n        \"heurisch\": heurisch, \"conds\": conds}\n\n    # if it is a poly(x) then let the polynomial integrate itself (fast)\n    #\n    # It is important to make this check first, otherwise the other code\n    # will return a SymPy expression instead of a Polynomial.\n    #\n    # see Polynomial for details.\n    if isinstance(f, Poly) and not (manual or meijerg or risch):\n        # Note: this is deprecated, but the deprecation warning is already\n        # issued in the Integral constructor.\n        return f.integrate(x)\n\n    # Piecewise antiderivatives need to call special integrate.\n    if isinstance(f, Piecewise):\n        return f.piecewise_integrate(x, **eval_kwargs)\n\n    # let's cut it short if `f` does not depend on `x`; if\n    # x is only a dummy, that will be handled below\n    if not f.has(x):\n        return f*x\n\n    # try to convert to poly(x) and then integrate if successful (fast)\n    poly = f.as_poly(x)\n    if poly is not None and not (manual or meijerg or risch):\n        return poly.integrate().as_expr()\n\n    if risch is not False:\n        try:\n            result, i = risch_integrate(f, x, separate_integral=True,\n                conds=conds)\n        except NotImplementedError:\n            pass\n        else:\n            if i:\n                # There was a nonelementary integral. Try integrating it.\n\n                # if no part of the NonElementaryIntegral is integrated by\n                # the Risch algorithm, then use the original function to\n                # integrate, instead of re-written one\n                if result == 0:\n                    return NonElementaryIntegral(f, x).doit(risch=False)\n                else:\n                    return result + i.doit(risch=False)\n            else:\n                return result\n\n    # since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...\n    # we are going to handle Add terms separately,\n    # if `f` is not Add -- we only have one term\n\n    # Note that in general, this is a bad idea, because Integral(g1) +\n    # Integral(g2) might not be computable, even if Integral(g1 + g2) is.\n    # For example, Integral(x**x + x**x*log(x)).  But many heuristics only\n    # work term-wise.  So we compute this step last, after trying\n    # risch_integrate.  We also try risch_integrate again in this loop,\n    # because maybe the integral is a sum of an elementary part and a\n    # nonelementary part (like erf(x) + exp(x)).  risch_integrate() is\n    # quite fast, so this is acceptable.\n    from sympy.simplify.fu import sincos_to_sum\n    parts = []\n    args = Add.make_args(f)\n    for g in args:\n        coeff, g = g.as_independent(x)\n\n        # g(x) = const\n        if g is S.One and not meijerg:\n            parts.append(coeff*x)\n            continue\n\n        # g(x) = expr + O(x**n)\n        order_term = g.getO()\n\n        if order_term is not None:\n            h = self._eval_integral(g.removeO(), x, **eval_kwargs)\n\n            if h is not None:\n                h_order_expr = self._eval_integral(order_term.expr, x, **eval_kwargs)\n\n                if h_order_expr is not None:\n                    h_order_term = order_term.func(\n                        h_order_expr, *order_term.variables)\n                    parts.append(coeff*(h + h_order_term))\n                    continue\n\n            # NOTE: if there is O(x**n) and we fail to integrate then\n            # there is no point in trying other methods because they\n            # will fail, too.\n            return None\n\n        #               c\n        # g(x) = (a*x+b)\n        if g.is_Pow and not g.exp.has(x) and not meijerg:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n\n            M = g.base.match(a*x + b)\n\n            if M is not None:\n                if g.exp == -1:\n                    h = log(g.base)\n                elif conds != 'piecewise':\n                    h = g.base**(g.exp + 1) / (g.exp + 1)\n                else:\n                    h1 = log(g.base)\n                    h2 = g.base**(g.exp + 1) / (g.exp + 1)\n                    h = Piecewise((h2, Ne(g.exp, -1)), (h1, True))\n\n                parts.append(coeff * h / M[a])\n                continue\n\n        #        poly(x)\n        # g(x) = -------\n        #        poly(x)\n        if g.is_rational_function(x) and not (manual or meijerg or risch):\n            parts.append(coeff * ratint(g, x))\n            continue\n\n        if not (manual or meijerg or risch):\n            # g(x) = Mul(trig)\n            h = trigintegrate(g, x, conds=conds)\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n            # g(x) has at least a DiracDelta term\n            h = deltaintegrate(g, x)\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n            from .singularityfunctions import singularityintegrate\n            # g(x) has at least a Singularity Function term\n            h = singularityintegrate(g, x)\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n            # Try risch again.\n            if risch is not False:\n                try:\n                    h, i = risch_integrate(g, x,\n                        separate_integral=True, conds=conds)\n                except NotImplementedError:\n                    h = None\n                else:\n                    if i:\n                        h = h + i.doit(risch=False)\n\n                    parts.append(coeff*h)\n                    continue\n\n            # fall back to heurisch\n            if heurisch is not False:\n                from sympy.integrals.heurisch import (heurisch as heurisch_,\n                                                      heurisch_wrapper)\n                try:\n                    if conds == 'piecewise':\n                        h = heurisch_wrapper(g, x, hints=[])\n                    else:\n                        h = heurisch_(g, x, hints=[])\n                except PolynomialError:\n                    # XXX: this exception means there is a bug in the\n                    # implementation of heuristic Risch integration\n                    # algorithm.\n                    h = None\n        else:\n            h = None\n\n        if meijerg is not False and h is None:\n            # rewrite using G functions\n            try:\n                h = meijerint_indefinite(g, x)\n            except NotImplementedError:\n                _debug('NotImplementedError from meijerint_definite')\n            if h is not None:\n                parts.append(coeff * h)\n                continue\n\n        if h is None and manual is not False:\n            try:\n                result = manualintegrate(g, x)\n                if result is not None and not isinstance(result, Integral):\n                    if result.has(Integral) and not manual:\n                        # Try to have other algorithms do the integrals\n                        # manualintegrate can't handle,\n                        # unless we were asked to use manual only.\n                        # Keep the rest of eval_kwargs in case another\n                        # method was set to False already\n                        new_eval_kwargs = eval_kwargs\n                        new_eval_kwargs[\"manual\"] = False\n                        new_eval_kwargs[\"final\"] = False\n                        result = result.func(*[\n                            arg.doit(**new_eval_kwargs) if\n                            arg.has(Integral) else arg\n                            for arg in result.args\n                        ]).expand(multinomial=False,\n                                  log=False,\n                                  power_exp=False,\n                                  power_base=False)\n                    if not result.has(Integral):\n                        parts.append(coeff * result)\n                        continue\n            except (ValueError, PolynomialError):\n                # can't handle some SymPy expressions\n                pass\n\n        # if we failed maybe it was because we had\n        # a product that could have been expanded,\n        # so let's try an expansion of the whole\n        # thing before giving up; we don't try this\n        # at the outset because there are things\n        # that cannot be solved unless they are\n        # NOT expanded e.g., x**x*(1+log(x)). There\n        # should probably be a checker somewhere in this\n        # routine to look for such cases and try to do\n        # collection on the expressions if they are already\n        # in an expanded form\n        if not h and len(args) == 1:\n            f = sincos_to_sum(f).expand(mul=True, deep=False)\n            if f.is_Add:\n                # Note: risch will be identical on the expanded\n                # expression, but maybe it will be able to pick out parts,\n                # like x*(exp(x) + erf(x)).\n                return self._eval_integral(f, x, **eval_kwargs)\n\n        if h is not None:\n            parts.append(coeff * h)\n        else:\n            return None\n\n    return Add(*parts)",
    "sympy.sympy.matrices.matrixbase.applyfunc": "def applyfunc(self, f: Callable[[Expr], Expr]) -> Self:\n    \"\"\"Apply a function to each element of the matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> m = Matrix(2, 2, lambda i, j: i*2+j)\n    >>> m\n    Matrix([\n    [0, 1],\n    [2, 3]])\n    >>> m.applyfunc(lambda i: 2*i)\n    Matrix([\n    [0, 2],\n    [4, 6]])\n\n    \"\"\"\n    if not callable(f):\n        raise TypeError(\"`f` must be callable.\")\n\n    return self._eval_applyfunc(f)",
    "sympy.sympy.matrices.matrixbase.doit": "def doit(self, **hints) -> Self:\n    return self.applyfunc(lambda x: x.doit(**hints))",
    "sympy.sympy.matrices.matrixbase.replace": "def replace(self, F, G, map: bool=False, simultaneous: bool=True, exact=None):\n    \"\"\"Replaces Function F in Matrix entries with Function G.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Function, Matrix\n    >>> F, G = symbols('F, G', cls=Function)\n    >>> M = Matrix(2, 2, lambda i, j: F(i+j)) ; M\n    Matrix([\n    [F(0), F(1)],\n    [F(1), F(2)]])\n    >>> N = M.replace(F,G)\n    >>> N\n    Matrix([\n    [G(0), G(1)],\n    [G(1), G(2)]])\n    \"\"\"\n    kwargs = {'map': map, 'simultaneous': simultaneous, 'exact': exact}\n\n    if map:\n\n        d = {}\n        def func(eij):\n            eij, dij = eij.replace(F, G, **kwargs)\n            d.update(dij)\n            return eij\n\n        M = self.applyfunc(func)\n        return M, d\n\n    else:\n        return self.applyfunc(lambda i: i.replace(F, G, **kwargs)) # type: ignore",
    "sympy.sympy.physics.units.quantities.free_symbols": "@property\ndef free_symbols(self):\n    \"\"\"Return free symbols from quantity.\"\"\"\n    return set()",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.polytools.as_expr": "def as_expr(f, *gens):\n    \"\"\"\n    Convert a Poly instance to an Expr instance.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n    >>> f.as_expr()\n    x**2 + 2*x*y**2 - y\n    >>> f.as_expr({x: 5})\n    10*y**2 - y + 25\n    >>> f.as_expr(5, 6)\n    379\n\n    \"\"\"\n    if not gens:\n        return f.expr\n\n    if len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\n                    \"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    "sympy.sympy.polys.polytools.__new__": "def __new__(cls, rep, *gens, **args) -> Self:\n    \"\"\"Create a new polynomial instance out of something useful. \"\"\"\n    opt = options.build_options(gens, args)\n\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n\n    if isinstance(rep, (DMP, DMF, ANP, DomainElement)):\n        return cls._from_domain_element(rep, opt)\n    elif iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep, evaluate=type(rep) is not str) # type: ignore\n\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    "sympy.sympy.polys.polytools.is_zero": "@property\ndef is_zero(f):\n    \"\"\"\n    Returns ``True`` if ``f`` is a zero polynomial.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x\n\n    >>> Poly(0, x).is_zero\n    True\n    >>> Poly(1, x).is_zero\n    False\n\n    \"\"\"\n    return f.rep.is_zero",
    "sympy.sympy.polys.polytools.replace": "def replace(f, x, y=None, **_ignore):\n    # XXX this does not match Basic's signature\n    \"\"\"\n    Replace ``x`` with ``y`` in generators list.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> Poly(x**2 + 1, x).replace(x, y)\n    Poly(y**2 + 1, y, domain='ZZ')\n\n    \"\"\"\n    if y is None:\n        if f.is_univariate:\n            x, y = f.gen, x\n        else:\n            raise PolynomialError(\n                \"syntax supported only in univariate case\")\n\n    if x == y or x not in f.gens:\n        return f\n\n    if x in f.gens and y not in f.gens:\n        dom = f.get_domain()\n\n        if not dom.is_Composite or y not in dom.symbols:\n            gens = list(f.gens)\n            gens[gens.index(x)] = y\n            return f.per(f.rep, gens=gens)\n\n    raise PolynomialError(\"Cannot replace %s with %s in %s\" % (x, y, f))",
    "sympy.sympy.series.formal.integrate": "def integrate(self, x=None, **kwargs):\n    \"\"\"\n    Integrate Formal Power Series.\n\n    Examples\n    ========\n\n    >>> from sympy import fps, sin, integrate\n    >>> from sympy.abc import x\n    >>> f = fps(sin(x))\n    >>> f.integrate(x).truncate()\n    -1 + x**2/2 - x**4/24 + O(x**6)\n    >>> integrate(f, (x, 0, 1))\n    1 - cos(1)\n    \"\"\"\n    from sympy.integrals import integrate\n\n    if x is None:\n        x = self.x\n    elif iterable(x):\n        return integrate(self.function, x)\n\n    f = integrate(self.function, x)\n    ind = integrate(self.ind, x)\n    ind += (f - ind).limit(x, 0)  # constant of integration\n\n    pow_xk = self._get_pow_x(self.xk.formula)\n    ak = self.ak\n    k = ak.variables[0]\n    if ak.formula.has(x):\n        form = []\n        for e, c in ak.formula.args:\n            temp = S.Zero\n            for t in Add.make_args(e):\n                pow_x = self._get_pow_x(t)\n                temp += t / (pow_xk + pow_x + 1)\n            form.append((temp, c))\n        form = Piecewise(*form)\n        ak = sequence(form.subs(k, k - 1), (k, ak.start + 1, ak.stop))\n    else:\n        ak = sequence((ak.formula / (pow_xk + 1)).subs(k, k - 1),\n                      (k, ak.start + 1, ak.stop))\n\n    return self.func(f, self.x, self.x0, self.dir, (ak, self.xk, ind))"
}