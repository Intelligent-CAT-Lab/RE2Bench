{
    "matplotlib.lib.matplotlib.artist._update_set_signature_and_docstring": "@classmethod\ndef _update_set_signature_and_docstring(cls):\n    \"\"\"\n    Update the signature of the set function to list all properties\n    as keyword arguments.\n\n    Property aliases are not listed in the signature for brevity, but\n    are still accepted as keyword arguments.\n    \"\"\"\n    cls.set.__signature__ = Signature(\n        [Parameter(\"self\", Parameter.POSITIONAL_OR_KEYWORD),\n         *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_api.UNSET)\n           for prop in ArtistInspector(cls).get_setters()\n           if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])\n    cls.set._autogenerated_signature = True\n\n    cls.set.__doc__ = (\n        \"Set multiple properties at once.\\n\\n\"\n        \"Supported properties are\\n\\n\"\n        + kwdoc(cls))",
    "matplotlib.lib.matplotlib.artist._prevent_rasterization": "def _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper"
}