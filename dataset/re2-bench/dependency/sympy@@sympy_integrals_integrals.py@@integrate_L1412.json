{
    "sympy.sympy.algebras.quaternion.__new__": "def __new__(cls, a: SExpr = 0, b: SExpr = 0, c: SExpr = 0, d: SExpr = 0,\n                 real_field: bool = True,\n                 norm: SExpr | None = None) -> Quaternion:\n\n    a, b, c, d = map(sympify, (a, b, c, d))\n\n    if any(i.is_commutative is False for i in [a, b, c, d]):\n        raise ValueError(\"arguments have to be commutative\")\n\n    obj = super().__new__(cls, a, b, c, d)\n    obj._real_field = real_field\n    obj.set_norm(norm)\n    return obj",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs, rhs, **options) -> Equality | BooleanFalse | BooleanTrue: # type: ignore\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    if evaluate:\n        val = is_eq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n\n    return Relational.__new__(cls, lhs, rhs)",
    "sympy.sympy.core.singleton.<lambda>": "cls.__new__ = lambda cls: obj\n",
    "sympy.sympy.integrals.integrals.<listcomp>": "new_args = [a.doit(**doit_flags) if isinstance(a, Integral) else a\n    for a in integral.args]\n",
    "sympy.sympy.integrals.integrals.doit": "def doit(self, **hints):\n    \"\"\"\n    Perform the integration using any hints given.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, S\n    >>> from sympy.abc import x, t\n    >>> p = x**2 + Piecewise((0, x/t < 0), (1, True))\n    >>> p.integrate((t, S(4)/5, 1), (x, -1, 1))\n    1/3\n\n    See Also\n    ========\n\n    sympy.integrals.trigonometry.trigintegrate\n    sympy.integrals.heurisch.heurisch\n    sympy.integrals.rationaltools.ratint\n    as_sum : Approximate the integral using a sum\n    \"\"\"\n    if not hints.get('integrals', True):\n        return self\n\n    deep = hints.get('deep', True)\n    meijerg = hints.get('meijerg', None)\n    conds = hints.get('conds', 'piecewise')\n    risch = hints.get('risch', None)\n    heurisch = hints.get('heurisch', None)\n    manual = hints.get('manual', None)\n    if len(list(filter(None, (manual, meijerg, risch, heurisch)))) > 1:\n        raise ValueError(\"At most one of manual, meijerg, risch, heurisch can be True\")\n    elif manual:\n        meijerg = risch = heurisch = False\n    elif meijerg:\n        manual = risch = heurisch = False\n    elif risch:\n        manual = meijerg = heurisch = False\n    elif heurisch:\n        manual = meijerg = risch = False\n    eval_kwargs = {\"meijerg\": meijerg, \"risch\": risch, \"manual\": manual, \"heurisch\": heurisch,\n        \"conds\": conds}\n\n    if conds not in ('separate', 'piecewise', 'none'):\n        raise ValueError('conds must be one of \"separate\", \"piecewise\", '\n                         '\"none\", got: %s' % conds)\n\n    if risch and any(len(xab) > 1 for xab in self.limits):\n        raise ValueError('risch=True is only allowed for indefinite integrals.')\n\n    # check for the trivial zero\n    if self.is_zero:\n        return S.Zero\n\n    # hacks to handle integrals of\n    # nested summations\n    from sympy.concrete.summations import Sum\n    if isinstance(self.function, Sum):\n        if any(v in self.function.limits[0] for v in self.variables):\n            raise ValueError('Limit of the sum cannot be an integration variable.')\n        if any(l.is_infinite for l in self.function.limits[0][1:]):\n            return self\n        _i = self\n        _sum = self.function\n        return _sum.func(_i.func(_sum.function, *_i.limits).doit(), *_sum.limits).doit()\n\n    # now compute and check the function\n    function = self.function\n\n    # hack to use a consistent Heaviside(x, 1/2)\n    function = function.replace(\n        lambda x: isinstance(x, Heaviside) and x.args[1]*2 != 1,\n        lambda x: Heaviside(x.args[0]))\n\n    if deep:\n        function = function.doit(**hints)\n    if function.is_zero:\n        return S.Zero\n\n    # hacks to handle special cases\n    if isinstance(function, MatrixBase):\n        return function.applyfunc(\n            lambda f: self.func(f, *self.limits).doit(**hints))\n\n    if isinstance(function, FormalPowerSeries):\n        if len(self.limits) > 1:\n            raise NotImplementedError\n        xab = self.limits[0]\n        if len(xab) > 1:\n            return function.integrate(xab, **eval_kwargs)\n        else:\n            return function.integrate(xab[0], **eval_kwargs)\n\n    # There is no trivial answer and special handling\n    # is done so continue\n\n    # first make sure any definite limits have integration\n    # variables with matching assumptions\n    reps = {}\n    for xab in self.limits:\n        if len(xab) != 3:\n            # it makes sense to just make\n            # all x real but in practice with the\n            # current state of integration...this\n            # doesn't work out well\n            # x = xab[0]\n            # if x not in reps and not x.is_real:\n            #     reps[x] = Dummy(real=True)\n            continue\n        x, a, b = xab\n        l = (a, b)\n        if all(i.is_nonnegative for i in l) and not x.is_nonnegative:\n            d = Dummy(positive=True)\n        elif all(i.is_nonpositive for i in l) and not x.is_nonpositive:\n            d = Dummy(negative=True)\n        elif all(i.is_real for i in l) and not x.is_real:\n            d = Dummy(real=True)\n        else:\n            d = None\n        if d:\n            reps[x] = d\n    if reps:\n        undo = {v: k for k, v in reps.items()}\n        did = self.xreplace(reps).doit(**hints)\n        if isinstance(did, tuple):  # when separate=True\n            did = tuple([i.xreplace(undo) for i in did])\n        else:\n            did = did.xreplace(undo)\n        return did\n\n    # continue with existing assumptions\n    undone_limits = []\n    # ulj = free symbols of any undone limits' upper and lower limits\n    ulj = set()\n    for xab in self.limits:\n        # compute uli, the free symbols in the\n        # Upper and Lower limits of limit I\n        if len(xab) == 1:\n            uli = set(xab[:1])\n        elif len(xab) == 2:\n            uli = xab[1].free_symbols\n        elif len(xab) == 3:\n            uli = xab[1].free_symbols.union(xab[2].free_symbols)\n        # this integral can be done as long as there is no blocking\n        # limit that has been undone. An undone limit is blocking if\n        # it contains an integration variable that is in this limit's\n        # upper or lower free symbols or vice versa\n        if xab[0] in ulj or any(v[0] in uli for v in undone_limits):\n            undone_limits.append(xab)\n            ulj.update(uli)\n            function = self.func(*([function] + [xab]))\n            factored_function = function.factor()\n            if not isinstance(factored_function, Integral):\n                function = factored_function\n            continue\n\n        if function.has(Abs, sign) and (\n            (len(xab) < 3 and all(x.is_extended_real for x in xab)) or\n            (len(xab) == 3 and all(x.is_extended_real and not x.is_infinite for\n             x in xab[1:]))):\n                # some improper integrals are better off with Abs\n                xr = Dummy(\"xr\", real=True)\n                function = (function.xreplace({xab[0]: xr})\n                    .rewrite(Piecewise).xreplace({xr: xab[0]}))\n        elif function.has(Min, Max):\n            function = function.rewrite(Piecewise)\n        if (function.has(Piecewise) and\n            not isinstance(function, Piecewise)):\n                function = piecewise_fold(function)\n        if isinstance(function, Piecewise):\n            if len(xab) == 1:\n                antideriv = function._eval_integral(xab[0],\n                    **eval_kwargs)\n            else:\n                antideriv = self._eval_integral(\n                    function, xab[0], **eval_kwargs)\n        else:\n            # There are a number of tradeoffs in using the\n            # Meijer G method. It can sometimes be a lot faster\n            # than other methods, and sometimes slower. And\n            # there are certain types of integrals for which it\n            # is more likely to work than others. These\n            # heuristics are incorporated in deciding what\n            # integration methods to try, in what order. See the\n            # integrate() docstring for details.\n            def try_meijerg(function, xab):\n                ret = None\n                if len(xab) == 3 and meijerg is not False:\n                    x, a, b = xab\n                    try:\n                        res = meijerint_definite(function, x, a, b)\n                    except NotImplementedError:\n                        _debug('NotImplementedError '\n                            'from meijerint_definite')\n                        res = None\n                    if res is not None:\n                        f, cond = res\n                        if conds == 'piecewise':\n                            u = self.func(function, (x, a, b))\n                            # if Piecewise modifies cond too\n                            # much it may not be recognized by\n                            # _condsimp pattern matching so just\n                            # turn off all evaluation\n                            return Piecewise((f, cond), (u, True),\n                                evaluate=False)\n                        elif conds == 'separate':\n                            if len(self.limits) != 1:\n                                raise ValueError(filldedent('''\n                                    conds=separate not supported in\n                                    multiple integrals'''))\n                            ret = f, cond\n                        else:\n                            ret = f\n                return ret\n\n            meijerg1 = meijerg\n            if (meijerg is not False and\n                    len(xab) == 3 and xab[1].is_extended_real and xab[2].is_extended_real\n                    and not function.is_Poly and\n                    (xab[1].has(oo, -oo) or xab[2].has(oo, -oo))):\n                ret = try_meijerg(function, xab)\n                if ret is not None:\n                    function = ret\n                    continue\n                meijerg1 = False\n            # If the special meijerg code did not succeed in\n            # finding a definite integral, then the code using\n            # meijerint_indefinite will not either (it might\n            # find an antiderivative, but the answer is likely\n            # to be nonsensical). Thus if we are requested to\n            # only use Meijer G-function methods, we give up at\n            # this stage. Otherwise we just disable G-function\n            # methods.\n            if meijerg1 is False and meijerg is True:\n                antideriv = None\n            else:\n                antideriv = self._eval_integral(\n                    function, xab[0], **eval_kwargs)\n                if antideriv is None and meijerg is True:\n                    ret = try_meijerg(function, xab)\n                    if ret is not None:\n                        function = ret\n                        continue\n\n        final = hints.get('final', True)\n        # dotit may be iterated but floor terms making atan and acot\n        # continuous should only be added in the final round\n        if (final and not isinstance(antideriv, Integral) and\n            antideriv is not None):\n            for atan_term in antideriv.atoms(atan):\n                atan_arg = atan_term.args[0]\n                # Checking `atan_arg` to be linear combination of `tan` or `cot`\n                for tan_part in atan_arg.atoms(tan):\n                    x1 = Dummy('x1')\n                    tan_exp1 = atan_arg.subs(tan_part, x1)\n                    # The coefficient of `tan` should be constant\n                    coeff = tan_exp1.diff(x1)\n                    if x1 not in coeff.free_symbols:\n                        a = tan_part.args[0]\n                        antideriv = antideriv.subs(atan_term, Add(atan_term,\n                            sign(coeff)*pi*floor((a-pi/2)/pi)))\n                for cot_part in atan_arg.atoms(cot):\n                    x1 = Dummy('x1')\n                    cot_exp1 = atan_arg.subs(cot_part, x1)\n                    # The coefficient of `cot` should be constant\n                    coeff = cot_exp1.diff(x1)\n                    if x1 not in coeff.free_symbols:\n                        a = cot_part.args[0]\n                        antideriv = antideriv.subs(atan_term, Add(atan_term,\n                            sign(coeff)*pi*floor((a)/pi)))\n\n        if antideriv is None:\n            undone_limits.append(xab)\n            function = self.func(*([function] + [xab])).factor()\n            factored_function = function.factor()\n            if not isinstance(factored_function, Integral):\n                function = factored_function\n            continue\n        else:\n            if len(xab) == 1:\n                function = antideriv\n            else:\n                if len(xab) == 3:\n                    x, a, b = xab\n                elif len(xab) == 2:\n                    x, b = xab\n                    a = None\n                else:\n                    raise NotImplementedError\n\n                if deep:\n                    if isinstance(a, Basic):\n                        a = a.doit(**hints)\n                    if isinstance(b, Basic):\n                        b = b.doit(**hints)\n\n                if antideriv.is_Poly:\n                    gens = list(antideriv.gens)\n                    gens.remove(x)\n\n                    antideriv = antideriv.as_expr()\n\n                    function = antideriv._eval_interval(x, a, b)\n                    function = Poly(function, *gens)\n                else:\n                    def is_indef_int(g, x):\n                        return (isinstance(g, Integral) and\n                                any(i == (x,) for i in g.limits))\n\n                    def eval_factored(f, x, a, b):\n                        # _eval_interval for integrals with\n                        # (constant) factors\n                        # a single indefinite integral is assumed\n                        args = []\n                        for g in Mul.make_args(f):\n                            if is_indef_int(g, x):\n                                args.append(g._eval_interval(x, a, b))\n                            else:\n                                args.append(g)\n                        return Mul(*args)\n\n                    integrals, others, piecewises = [], [], []\n                    for f in Add.make_args(antideriv):\n                        if any(is_indef_int(g, x)\n                               for g in Mul.make_args(f)):\n                            integrals.append(f)\n                        elif any(isinstance(g, Piecewise)\n                                 for g in Mul.make_args(f)):\n                            piecewises.append(piecewise_fold(f))\n                        else:\n                            others.append(f)\n                    uneval = Add(*[eval_factored(f, x, a, b)\n                                   for f in integrals])\n                    try:\n                        evalued = Add(*others)._eval_interval(x, a, b)\n                        evalued_pw = piecewise_fold(Add(*piecewises))._eval_interval(x, a, b)\n                        function = uneval + evalued + evalued_pw\n                    except NotImplementedError:\n                        # This can happen if _eval_interval depends in a\n                        # complicated way on limits that cannot be computed\n                        undone_limits.append(xab)\n                        function = self.func(*([function] + [xab]))\n                        factored_function = function.factor()\n                        if not isinstance(factored_function, Integral):\n                            function = factored_function\n    return function",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.vector.vector.__new__": "def __new__(cls, *args, **options):\n    obj = BasisDependentAdd.__new__(cls, *args, **options)\n    return obj"
}