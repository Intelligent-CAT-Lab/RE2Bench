{
    "matplotlib.lib.matplotlib.streamplot.start_trajectory": "def start_trajectory(self, xg, yg, broken_streamlines=True):\n    xm, ym = self.grid2mask(xg, yg)\n    self.mask._start_trajectory(xm, ym, broken_streamlines)",
    "matplotlib.lib.matplotlib.streamplot.reset_start_point": "def reset_start_point(self, xg, yg):\n    xm, ym = self.grid2mask(xg, yg)\n    self.mask._current_xy = (xm, ym)",
    "matplotlib.lib.matplotlib.streamplot.undo_trajectory": "def undo_trajectory(self):\n    self.mask._undo_trajectory()",
    "matplotlib.lib.matplotlib.streamplot._integrate_rk12": "def _integrate_rk12(x0, y0, dmap, f, maxlength, broken_streamlines=True,\n                    integration_max_step_scale=1.0,\n                    integration_max_error_scale=1.0):\n    \"\"\"\n    2nd-order Runge-Kutta algorithm with adaptive step size.\n\n    This method is also referred to as the improved Euler's method, or Heun's\n    method. This method is favored over higher-order methods because:\n\n    1. To get decent looking trajectories and to sample every mask cell\n       on the trajectory we need a small timestep, so a lower order\n       solver doesn't hurt us unless the data is *very* high resolution.\n       In fact, for cases where the user inputs\n       data smaller or of similar grid size to the mask grid, the higher\n       order corrections are negligible because of the very fast linear\n       interpolation used in `interpgrid`.\n\n    2. For high resolution input data (i.e. beyond the mask\n       resolution), we must reduce the timestep. Therefore, an adaptive\n       timestep is more suited to the problem as this would be very hard\n       to judge automatically otherwise.\n\n    This integrator is about 1.5 - 2x as fast as RK4 and RK45 solvers (using\n    similar Python implementations) in most setups.\n    \"\"\"\n    # This error is below that needed to match the RK4 integrator. It\n    # is set for visual reasons -- too low and corners start\n    # appearing ugly and jagged. Can be tuned.\n    maxerror = 0.003 * integration_max_error_scale\n\n    # This limit is important (for all integrators) to avoid the\n    # trajectory skipping some mask cells. We could relax this\n    # condition if we use the code which is commented out below to\n    # increment the location gradually. However, due to the efficient\n    # nature of the interpolation, this doesn't boost speed by much\n    # for quite a bit of complexity.\n    maxds = min(1. / dmap.mask.nx, 1. / dmap.mask.ny, 0.1)\n    maxds *= integration_max_step_scale\n\n    ds = maxds\n    stotal = 0\n    xi = x0\n    yi = y0\n    xyf_traj = []\n\n    while True:\n        try:\n            if dmap.grid.within_grid(xi, yi):\n                xyf_traj.append((xi, yi))\n            else:\n                raise OutOfBounds\n\n            # Compute the two intermediate gradients.\n            # f should raise OutOfBounds if the locations given are\n            # outside the grid.\n            k1x, k1y = f(xi, yi)\n            k2x, k2y = f(xi + ds * k1x, yi + ds * k1y)\n\n        except OutOfBounds:\n            # Out of the domain during this step.\n            # Take an Euler step to the boundary to improve neatness\n            # unless the trajectory is currently empty.\n            if xyf_traj:\n                ds, xyf_traj = _euler_step(xyf_traj, dmap, f)\n                stotal += ds\n            break\n        except TerminateTrajectory:\n            break\n\n        dx1 = ds * k1x\n        dy1 = ds * k1y\n        dx2 = ds * 0.5 * (k1x + k2x)\n        dy2 = ds * 0.5 * (k1y + k2y)\n\n        ny, nx = dmap.grid.shape\n        # Error is normalized to the axes coordinates\n        error = np.hypot((dx2 - dx1) / (nx - 1), (dy2 - dy1) / (ny - 1))\n\n        # Only save step if within error tolerance\n        if error < maxerror:\n            xi += dx2\n            yi += dy2\n            try:\n                dmap.update_trajectory(xi, yi, broken_streamlines)\n            except InvalidIndexError:\n                break\n            if stotal + ds > maxlength:\n                break\n            stotal += ds\n\n        # recalculate stepsize based on step error\n        if error == 0:\n            ds = maxds\n        else:\n            ds = min(maxds, 0.85 * ds * (maxerror / error) ** 0.5)\n\n    return stotal, xyf_traj"
}