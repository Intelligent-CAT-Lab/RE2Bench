{
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n\n    return False    # NumberSymbol != non-(Number|self)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.matrices.expressions.inverse.__new__": "def __new__(cls, mat, exp=S.NegativeOne):\n    # exp is there to make it consistent with\n    # inverse.func(*inverse.args) == inverse\n    mat = _sympify(mat)\n    exp = _sympify(exp)\n    if not mat.is_Matrix:\n        raise TypeError(\"mat should be a matrix\")\n    if mat.is_square is False:\n        raise NonSquareMatrixError(\"Inverse of non-square matrix %s\" % mat)\n    return Basic.__new__(cls, mat, exp)",
    "sympy.sympy.matrices.expressions.inverse.doit": "def doit(self, **hints):\n    if 'inv_expand' in hints and hints['inv_expand'] == False:\n        return self\n\n    arg = self.arg\n    if hints.get('deep', True):\n        arg = arg.doit(**hints)\n\n    return arg.inverse()",
    "sympy.sympy.matrices.expressions.matexpr.rows": "@property\ndef rows(self):\n    return self.shape[0]",
    "sympy.sympy.matrices.expressions.matexpr._eval_power": "def _eval_power(self, exp):\n    \"\"\"\n    Override this in sub-classes to implement simplification of powers.  The cases where the exponent\n    is -1, 0, 1 are already covered in MatPow.doit(), so implementations can exclude these cases.\n    \"\"\"\n    return MatPow(self, exp)",
    "sympy.sympy.matrices.expressions.matpow.<genexpr>": "base, exp = (arg.doit(**hints) for arg in self.args)\n",
    "sympy.sympy.matrices.expressions.permutation._eval_power": "def _eval_power(self, exp):\n    return PermutationMatrix(self.args[0] ** exp).doit()",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, n):\n    n = _sympify(n)\n    cls._check_dim(n)\n\n    return super().__new__(cls, n)",
    "sympy.sympy.matrices.expressions.special.rows": "@property\ndef rows(self):\n    return self.args[0]",
    "sympy.sympy.matrices.expressions.special._eval_power": "def _eval_power(self, exp):\n    # exp = -1, 0, 1 are already handled at this stage\n    if (exp < 0) == True:\n        raise NonInvertibleMatrixError(\"Matrix det == 0; not invertible\")\n    return self"
}