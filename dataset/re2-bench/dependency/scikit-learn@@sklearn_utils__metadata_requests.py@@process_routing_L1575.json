{
    "scikit-learn.sklearn.utils._metadata_requests.route_params": "def route_params(self, *, caller, params):\n    \"\"\"Get the values of metadata requested by :term:`consumers <consumer>`.\n\n    Returns a :class:`~sklearn.utils.Bunch` containing the metadata that this\n    :term:`router`'s `caller` method needs to route, organized by each\n    :term:`consumer` and their corresponding methods.\n\n    This can be used to pass the required metadata to corresponding methods in\n    consumers.\n\n    Parameters\n    ----------\n    caller : str\n        The name of the :term:`router`'s method through which the metadata is\n        routed. For example, if called inside the :term:`fit` method of a router,\n        this would be `\"fit\"`.\n\n    params : dict\n        A dictionary of provided metadata.\n\n    Returns\n    -------\n    params : Bunch\n        A :class:`~sklearn.utils.Bunch` of the form\n        ``{\"object_name\": {\"method_name\": {metadata: value}}}``.\n    \"\"\"\n    if self._self_request:\n        self._self_request._check_warnings(params=params, method=caller)\n\n    res = Bunch()\n    for name, route_mapping in self._route_mappings.items():\n        router, mapping = route_mapping.router, route_mapping.mapping\n\n        res[name] = Bunch()\n        for _caller, _callee in mapping:\n            if _caller == caller:\n                res[name][_callee] = router._route_params(\n                    params=params,\n                    method=_callee,\n                    parent=self.owner,\n                    caller=caller,\n                )\n    return res",
    "scikit-learn.sklearn.utils._metadata_requests.validate_metadata": "def validate_metadata(self, *, method, params):\n    \"\"\"Validate given metadata for a method.\n\n    This raises a ``TypeError`` if some of the passed metadata are not\n    understood by child objects.\n\n    Parameters\n    ----------\n    method : str\n        The name of the :term:`router`'s method through which the metadata is\n        routed. For example, if called inside the :term:`fit` method of a router,\n        this would be `\"fit\"`.\n\n    params : dict\n        A dictionary of provided metadata.\n    \"\"\"\n    param_names = self._get_param_names(\n        method=method, return_alias=False, ignore_self_request=False\n    )\n    if self._self_request:\n        self_params = self._self_request._get_param_names(\n            method=method, return_alias=False\n        )\n    else:\n        self_params = set()\n    extra_keys = set(params.keys()) - param_names - self_params\n    if extra_keys:\n        raise TypeError(\n            f\"{_routing_repr(self.owner)}.{method} got unexpected argument(s)\"\n            f\" {extra_keys}, which are not routed to any object.\"\n        )",
    "scikit-learn.sklearn.utils._metadata_requests.get_routing_for_object": "def get_routing_for_object(obj=None):\n    \"\"\"Get a ``Metadata{Router, Request}`` instance from the given object.\n\n    This function returns a\n    :class:`~sklearn.utils.metadata_routing.MetadataRouter` or a\n    :class:`~sklearn.utils.metadata_routing.MetadataRequest` from the given input.\n\n    This function always returns a copy or an instance constructed from the\n    input, such that changing the output of this function will not change the\n    original object.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    obj : object\n        - If the object provides a `get_metadata_routing` method, return a copy\n            of the output of that method.\n        - If the object is already a\n            :class:`~sklearn.utils.metadata_routing.MetadataRequest` or a\n            :class:`~sklearn.utils.metadata_routing.MetadataRouter`, return a copy\n            of that.\n        - Returns an empty :class:`~sklearn.utils.metadata_routing.MetadataRequest`\n            otherwise.\n\n    Returns\n    -------\n    obj : MetadataRequest or MetadataRouter\n        A ``MetadataRequest`` or a ``MetadataRouter`` taken or created from\n        the given object.\n    \"\"\"\n    # doing this instead of a try/except since an AttributeError could be raised\n    # for other reasons.\n    if hasattr(obj, \"get_metadata_routing\"):\n        return deepcopy(obj.get_metadata_routing())\n\n    elif getattr(obj, \"_type\", None) in [\"metadata_request\", \"metadata_router\"]:\n        return deepcopy(obj)\n\n    return MetadataRequest(owner=None)",
    "scikit-learn.sklearn.utils._metadata_requests._routing_repr": "def _routing_repr(obj):\n    \"\"\"Get a representation suitable for messages printed in the routing machinery.\n\n    This is different than `repr(obj)`, since repr(estimator) can be verbose when\n    there are many constructor arguments set by the user.\n\n    This is most suitable for Scorers as it gives a nice representation of what they\n    are. This is done by implementing a `_routing_repr` method on the object.\n\n    Since the `owner` object could be the type name (str), we return that string if the\n    given `obj` is a string, otherwise we return the object's type name.\n\n    .. versionadded:: 1.8\n    \"\"\"\n    try:\n        return obj._routing_repr()\n    except AttributeError:\n        return obj if isinstance(obj, str) else type(obj).__name__",
    "scikit-learn.sklearn.utils._metadata_requests.EmptyRequest": "class EmptyRequest:\n    def get(self, name, default=None):\n        return Bunch(**{method: dict() for method in METHODS})\n\n    def __getitem__(self, name):\n        return Bunch(**{method: dict() for method in METHODS})\n\n    def __getattr__(self, name):\n        return Bunch(**{method: dict() for method in METHODS})\n\n"
}