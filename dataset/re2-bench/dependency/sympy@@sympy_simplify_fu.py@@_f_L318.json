{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    return (isinstance(other, self.__class__) and\n        self.class_key() == other.class_key() and\n        self._kwargs == other._kwargs)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.power.base": "@property\ndef base(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.core.power.exp": "@property\ndef exp(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.logic.boolalg.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    "sympy.sympy.ntheory.factor_.perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    \"\"\"\n    Return ``(b, e)`` such that ``n`` == ``b**e`` if ``n`` is a unique\n    perfect power with ``e > 1``, else ``False`` (e.g. 1 is not a\n    perfect power). A ValueError is raised if ``n`` is not Rational.\n\n    By default, the base is recursively decomposed and the exponents\n    collected so the largest possible ``e`` is sought. If ``big=False``\n    then the smallest possible ``e`` (thus prime) will be chosen.\n\n    If ``factor=True`` then simultaneous factorization of ``n`` is\n    attempted since finding a factor indicates the only possible root\n    for ``n``. This is True by default since only a few small factors will\n    be tested in the course of searching for the perfect power.\n\n    The use of ``candidates`` is primarily for internal use; if provided,\n    False will be returned if ``n`` cannot be written as a power with one\n    of the candidates as an exponent and factoring (beyond testing for\n    a factor of 2) will not be attempted.\n\n    Examples\n    ========\n\n    >>> from sympy import perfect_power, Rational\n    >>> perfect_power(16)\n    (2, 4)\n    >>> perfect_power(16, big=False)\n    (4, 2)\n\n    Negative numbers can only have odd perfect powers:\n\n    >>> perfect_power(-4)\n    False\n    >>> perfect_power(-8)\n    (-2, 3)\n\n    Rationals are also recognized:\n\n    >>> perfect_power(Rational(1, 2)**3)\n    (1/2, 3)\n    >>> perfect_power(Rational(-3, 2)**3)\n    (-3/2, 3)\n\n    Notes\n    =====\n\n    To know whether an integer is a perfect power of 2 use\n\n        >>> is2pow = lambda n: bool(n and not n & (n - 1))\n        >>> [(i, is2pow(i)) for i in range(5)]\n        [(0, False), (1, True), (2, True), (3, False), (4, True)]\n\n    It is not necessary to provide ``candidates``. When provided\n    it will be assumed that they are ints. The first one that is\n    larger than the computed maximum possible exponent will signal\n    failure for the routine.\n\n        >>> perfect_power(3**8, [9])\n        False\n        >>> perfect_power(3**8, [2, 4, 8])\n        (3, 8)\n        >>> perfect_power(3**8, [4, 8], big=False)\n        (9, 4)\n\n    See Also\n    ========\n    sympy.core.intfunc.integer_nthroot\n    sympy.ntheory.primetest.is_square\n    \"\"\"\n    # negative handling\n    if n < 0:\n        if candidates is None:\n            pp = perfect_power(-n, big=True, factor=factor)\n            if not pp:\n                return False\n\n            b, e = pp\n            e2 = e & (-e)\n            b, e = b ** e2, e // e2\n\n            if e <= 1:\n                return False\n\n            if big or isprime(e):\n                return -b, e\n\n            for p in primerange(3, e + 1):\n                if e % p == 0:\n                    return - b ** (e // p), p\n\n        odd_candidates = {i for i in candidates if i % 2}\n        if not odd_candidates:\n            return False\n\n        pp = perfect_power(-n, odd_candidates, big, factor)\n        if pp:\n            return -pp[0], pp[1]\n\n        return False\n\n    # non-integer handling\n    if isinstance(n, Rational) and not isinstance(n, Integer):\n        p, q = n.p, n.q\n\n        if p == 1:\n            qq = perfect_power(q, candidates, big, factor)\n            return (S.One / qq[0], qq[1]) if qq is not False else False\n\n        if not (pp:=perfect_power(p, factor=factor)):\n            return False\n        if not (qq:=perfect_power(q, factor=factor)):\n            return False\n        (num_base, num_exp), (den_base, den_exp) = pp, qq\n\n        def compute_tuple(exponent):\n            \"\"\"Helper to compute final result given an exponent\"\"\"\n            new_num = num_base ** (num_exp // exponent)\n            new_den = den_base ** (den_exp // exponent)\n            return n.func(new_num, new_den), exponent\n\n        if candidates:\n            valid_candidates = [i for i in candidates\n                                if num_exp % i == 0 and den_exp % i == 0]\n            if not valid_candidates:\n                return False\n\n            e = max(valid_candidates) if big else min(valid_candidates)\n            return compute_tuple(e)\n\n        g = math.gcd(num_exp, den_exp)\n        if g == 1:\n            return False\n\n        if big:\n            return compute_tuple(g)\n\n        e = next(p for p in primerange(2, g + 1) if g % p == 0)\n        return compute_tuple(e)\n\n    if candidates is not None:\n        candidates = set(candidates)\n\n    # positive integer handling\n    n = as_int(n)\n\n    if candidates is None and big:\n        return _perfect_power(n)\n\n    if n <= 3:\n        # no unique exponent for 0, 1\n        # 2 and 3 have exponents of 1\n        return False\n    logn = math.log2(n)\n    max_possible = int(logn) + 2  # only check values less than this\n    not_square = n % 10 in [2, 3, 7, 8]  # squares cannot end in 2, 3, 7, 8\n    min_possible = 2 + not_square\n    if not candidates:\n        candidates = primerange(min_possible, max_possible)\n    else:\n        candidates = sorted([i for i in candidates\n            if min_possible <= i < max_possible])\n        if n%2 == 0:\n            e = bit_scan1(n)\n            candidates = [i for i in candidates if e%i == 0]\n        if big:\n            candidates = reversed(candidates)\n        for e in candidates:\n            r, ok = iroot(n, e)\n            if ok:\n                return int(r), e\n        return False\n\n    def _factors():\n        rv = 2 + n % 2\n        while True:\n            yield rv\n            rv = nextprime(rv)\n\n    for fac, e in zip(_factors(), candidates):\n        # see if there is a factor present\n        if factor and n % fac == 0:\n            # find what the potential power is\n            e = remove(n, fac)[1]\n            # if it's a trivial power we are done\n            if e == 1:\n                return False\n\n            # maybe the e-th root of n is exact\n            r, exact = iroot(n, e)\n            if not exact:\n                # Having a factor, we know that e is the maximal\n                # possible value for a root of n.\n                # If n = fac**e*m can be written as a perfect\n                # power then see if m can be written as r**E where\n                # gcd(e, E) != 1 so n = (fac**(e//E)*r)**E\n                m = n//fac**e\n                rE = perfect_power(m, candidates=divisors(e, generator=True))\n                if not rE:\n                    return False\n                else:\n                    r, E = rE\n                    r, e = fac**(e//E)*r, E\n            if not big:\n                e0 = primefactors(e)\n                if e0[0] != e:\n                    r, e = r**(e//e0[0]), e0[0]\n            return int(r), e\n\n        # Weed out downright impossible candidates\n        if logn/e < 40:\n            b = 2.0**(logn/e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n\n        # now see if the plausible e makes a perfect power\n        r, exact = iroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m:\n                    r, e = m[0], e*m[1]\n            return int(r), e\n\n    return False",
    "sympy.sympy.simplify.fu.<lambda>": "return _TR56(rv, cos, sin, lambda x: 1 - x, max=max, pow=pow)\n\n\n"
}