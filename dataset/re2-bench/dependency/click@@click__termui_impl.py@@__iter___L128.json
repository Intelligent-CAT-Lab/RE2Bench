{
    "click.src.click._termui_impl.render_progress": "def render_progress(self) -> None:\n    if self.hidden:\n        return\n\n    if not self._is_atty:\n        # Only output the label once if the output is not a TTY.\n        if self._last_line != self.label:\n            self._last_line = self.label\n            echo(self.label, file=self.file, color=self.color)\n        return\n\n    buf = []\n    # Update width in case the terminal has been resized\n    if self.autowidth:\n        import shutil\n\n        old_width = self.width\n        self.width = 0\n        clutter_length = term_len(self.format_progress_line())\n        new_width = max(0, shutil.get_terminal_size().columns - clutter_length)\n        if new_width < old_width and self.max_width is not None:\n            buf.append(BEFORE_BAR)\n            buf.append(\" \" * self.max_width)\n            self.max_width = new_width\n        self.width = new_width\n\n    clear_width = self.width\n    if self.max_width is not None:\n        clear_width = self.max_width\n\n    buf.append(BEFORE_BAR)\n    line = self.format_progress_line()\n    line_len = term_len(line)\n    if self.max_width is None or self.max_width < line_len:\n        self.max_width = line_len\n\n    buf.append(line)\n    buf.append(\" \" * (clear_width - line_len))\n    line = \"\".join(buf)\n    # Render the line only if it changed.\n\n    if line != self._last_line:\n        self._last_line = line\n        echo(line, file=self.file, color=self.color, nl=False)\n        self.file.flush()"
}