{
    "matplotlib.lib.matplotlib.dates.<listcomp>": "d = [date2num(dateutil.parser.parse(s, default=default))\n     for s in d]\n",
    "matplotlib.lib.matplotlib.dates.date2num": "def date2num(d):\n    \"\"\"\n    Convert datetime objects to Matplotlib dates.\n\n    Parameters\n    ----------\n    d : `datetime.datetime` or `numpy.datetime64` or sequences of these\n\n    Returns\n    -------\n    float or sequence of floats\n        Number of days since the epoch.  See `.get_epoch` for the\n        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.  If\n        the epoch is \"1970-01-01T00:00:00\" (default) then noon Jan 1 1970\n        (\"1970-01-01T12:00:00\") returns 0.5.\n\n    Notes\n    -----\n    The Gregorian calendar is assumed; this is not universal practice.\n    For details see the module docstring.\n    \"\"\"\n    # Unpack in case of e.g. Pandas or xarray object\n    d = cbook._unpack_to_numpy(d)\n\n    # make an iterable, but save state to unpack later:\n    iterable = np.iterable(d)\n    if not iterable:\n        d = [d]\n\n    masked = np.ma.is_masked(d)\n    mask = np.ma.getmask(d)\n    d = np.asarray(d)\n\n    # convert to datetime64 arrays, if not already:\n    if not np.issubdtype(d.dtype, np.datetime64):\n        # datetime arrays\n        if not d.size:\n            # deals with an empty array...\n            return d\n        tzi = getattr(d[0], 'tzinfo', None)\n        if tzi is not None:\n            # make datetime naive:\n            d = [dt.astimezone(UTC).replace(tzinfo=None) for dt in d]\n            d = np.asarray(d)\n        d = d.astype('datetime64[us]')\n\n    d = np.ma.masked_array(d, mask=mask) if masked else d\n    d = _dt64_to_ordinalf(d)\n\n    return d if iterable else d[0]"
}