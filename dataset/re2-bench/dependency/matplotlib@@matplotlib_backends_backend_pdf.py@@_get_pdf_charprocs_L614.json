{
    "matplotlib.lib.matplotlib.font_manager.get_font": "def get_font(font_filepaths, hinting_factor=None):\n    \"\"\"\n    Get an `.ft2font.FT2Font` object given a list of file paths.\n\n    Parameters\n    ----------\n    font_filepaths : Iterable[str, Path, bytes], str, Path, bytes\n        Relative or absolute paths to the font files to be used.\n\n        If a single string, bytes, or `pathlib.Path`, then it will be treated\n        as a list with that entry only.\n\n        If more than one filepath is passed, then the returned FT2Font object\n        will fall back through the fonts, in the order given, to find a needed\n        glyph.\n\n    Returns\n    -------\n    `.ft2font.FT2Font`\n\n    \"\"\"\n    if isinstance(font_filepaths, (str, Path, bytes)):\n        paths = (_cached_realpath(font_filepaths),)\n    else:\n        paths = tuple(_cached_realpath(fname) for fname in font_filepaths)\n\n    hinting_factor = mpl._val_or_rc(hinting_factor, 'text.hinting_factor')\n\n    return _get_font(\n        # must be a tuple to be cached\n        paths,\n        hinting_factor,\n        _kerning_factor=mpl.rcParams['text.kerning_factor'],\n        # also key on the thread ID to prevent segfaults with multi-threading\n        thread_id=threading.get_ident(),\n        enable_last_resort=mpl.rcParams['font.enable_last_resort'],\n    )",
    "matplotlib.lib.matplotlib.path.vertices": "@property\ndef vertices(self):\n    \"\"\"The vertices of the `Path` as an (N, 2) array.\"\"\"\n    return self._vertices",
    "matplotlib.lib.matplotlib.path.codes": "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1D array.\n\n    Each code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n    `CLOSEPOLY`.  For codes that correspond to more than one vertex\n    (`CURVE3` and `CURVE4`), that code will be repeated so that the length\n    of `vertices` and `codes` is always the same.\n    \"\"\"\n    return self._codes",
    "matplotlib.lib.matplotlib.path.simplify_threshold": "@property\ndef simplify_threshold(self):\n    \"\"\"\n    The fraction of a pixel difference below which vertices will\n    be simplified out.\n    \"\"\"\n    return self._simplify_threshold",
    "matplotlib.lib.matplotlib.path.should_simplify": "@property\ndef should_simplify(self):\n    \"\"\"\n    `True` if the vertices array should be simplified.\n    \"\"\"\n    return self._should_simplify",
    "matplotlib.lib.matplotlib.path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : (N, 2) array-like\n        The path vertices, as an array, masked array or sequence of pairs.\n        Masked values, if any, will be converted to NaNs, which are then\n        handled correctly by the Agg PathIterator and other consumers of\n        path data, such as :meth:`iter_segments`.\n    codes : array-like or None, optional\n        N-length array of integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        `CLOSEPOLY`).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n\n    if codes is not None and len(vertices):\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'. \"\n                             f\"Your vertices have shape {vertices.shape} \"\n                             f\"but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             f\"to 'MOVETO' ({self.MOVETO}).  \"\n                             f\"Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False"
}