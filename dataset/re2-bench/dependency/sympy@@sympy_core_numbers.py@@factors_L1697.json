{
    "sympy.sympy.ntheory.factor_.factorrat": "def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True,\n              verbose=False, visual=None, multiple=False):\n    r\"\"\"\n    Given a Rational ``r``, ``factorrat(r)`` returns a dict containing\n    the prime factors of ``r`` as keys and their respective multiplicities\n    as values. For example:\n\n    >>> from sympy import factorrat, S\n    >>> factorrat(S(8)/9)    # 8/9 = (2**3) * (3**-2)\n    {2: 3, 3: -2}\n    >>> factorrat(S(-1)/987)    # -1/789 = -1 * (3**-1) * (7**-1) * (47**-1)\n    {-1: 1, 3: -1, 7: -1, 47: -1}\n\n    Please see the docstring for ``factorint`` for detailed explanations\n    and examples of the following keywords:\n\n        - ``limit``: Integer limit up to which trial division is done\n        - ``use_trial``: Toggle use of trial division\n        - ``use_rho``: Toggle use of Pollard's rho method\n        - ``use_pm1``: Toggle use of Pollard's p-1 method\n        - ``verbose``: Toggle detailed printing of progress\n        - ``multiple``: Toggle returning a list of factors or dict\n        - ``visual``: Toggle product form of output\n    \"\"\"\n    if multiple:\n        fac = factorrat(rat, limit=limit, use_trial=use_trial,\n                  use_rho=use_rho, use_pm1=use_pm1,\n                  verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One/p]*(-fac[p])\n                               for p, _ in sorted(fac.items(),\n                                                        key=lambda elem: elem[0]\n                                                        if elem[1] > 0\n                                                        else 1/elem[0])), [])\n        return factorlist\n\n    f = factorint(rat.p, limit=limit, use_trial=use_trial,\n                  use_rho=use_rho, use_pm1=use_pm1,\n                  verbose=verbose).copy()\n    f = defaultdict(int, f)\n    for p, e in factorint(rat.q, limit=limit,\n                          use_trial=use_trial,\n                          use_rho=use_rho,\n                          use_pm1=use_pm1,\n                          verbose=verbose).items():\n        f[p] += -e\n\n    if len(f) > 1 and 1 in f:\n        del f[1]\n    if not visual:\n        return dict(f)\n    else:\n        if -1 in f:\n            f.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False)\n                     for i in sorted(f.items())])\n        return Mul(*args, evaluate=False)"
}