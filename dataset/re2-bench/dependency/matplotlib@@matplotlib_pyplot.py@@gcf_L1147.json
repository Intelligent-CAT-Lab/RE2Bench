{
    "matplotlib.lib.matplotlib._pylab_helpers.get_active": "@classmethod\ndef get_active(cls):\n    \"\"\"Return the active manager, or *None* if there is no manager.\"\"\"\n    return next(reversed(cls.figs.values())) if cls.figs else None",
    "matplotlib.lib.matplotlib.pyplot.figure": "def figure(\n    # autoincrement if None, else integer from 1-N\n    num: int | str | Figure | SubFigure | None = None,\n    # defaults to rc figure.figsize\n    figsize: ArrayLike  # a 2-element ndarray is accepted as well\n             | tuple[float, float, Literal[\"in\", \"cm\", \"px\"]]\n             | None = None,\n    # defaults to rc figure.dpi\n    dpi: float | None = None,\n    *,\n    # defaults to rc figure.facecolor\n    facecolor: ColorType | None = None,\n    # defaults to rc figure.edgecolor\n    edgecolor: ColorType | None = None,\n    frameon: bool = True,\n    FigureClass: type[Figure] = Figure,\n    clear: bool = False,\n    **kwargs\n) -> Figure:\n    \"\"\"\n    Create a new figure, or activate an existing figure.\n\n    Parameters\n    ----------\n    num : int or str or `.Figure` or `.SubFigure`, optional\n        A unique identifier for the figure.\n\n        If a figure with that identifier already exists, this figure is made\n        active and returned. An integer refers to the ``Figure.number``\n        attribute, a string refers to the figure label.\n\n        If there is no figure with the identifier or *num* is not given, a new\n        figure is created, made active and returned.  If *num* is an int, it\n        will be used for the ``Figure.number`` attribute, otherwise, an\n        auto-generated integer value is used (starting at 1 and incremented\n        for each new figure). If *num* is a string, the figure label and the\n        window title is set to this value.  If num is a ``SubFigure``, its\n        parent ``Figure`` is activated.\n\n        If *num* is a Figure instance that is already tracked in pyplot, it is\n        activated. If *num* is a Figure instance that is not tracked in pyplot,\n        it is added to the tracked figures and activated.\n\n    figsize : (float, float) or (float, float, str), default: :rc:`figure.figsize`\n        The figure dimensions. This can be\n\n        - a tuple ``(width, height, unit)``, where *unit* is one of \"inch\", \"cm\",\n          \"px\".\n        - a tuple ``(x, y)``, which is interpreted as ``(x, y, \"inch\")``.\n\n    dpi : float, default: :rc:`figure.dpi`\n        The resolution of the figure in dots-per-inch.\n\n    facecolor : :mpltype:`color`, default: :rc:`figure.facecolor`\n        The background color.\n\n    edgecolor : :mpltype:`color`, default: :rc:`figure.edgecolor`\n        The border color.\n\n    frameon : bool, default: True\n        If False, suppress drawing the figure frame.\n\n    FigureClass : subclass of `~matplotlib.figure.Figure`\n        If set, an instance of this subclass will be created, rather than a\n        plain `.Figure`.\n\n    clear : bool, default: False\n        If True and the figure already exists, then it is cleared.\n\n    layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \\\ndefault: None\n        The layout mechanism for positioning of plot elements to avoid\n        overlapping Axes decorations (labels, ticks, etc). Note that layout\n        managers can measurably slow down figure display.\n\n        - 'constrained': The constrained layout solver adjusts Axes sizes\n          to avoid overlapping Axes decorations.  Can handle complex plot\n          layouts and colorbars, and is thus recommended.\n\n          See :ref:`constrainedlayout_guide`\n          for examples.\n\n        - 'compressed': uses the same algorithm as 'constrained', but\n          removes extra space between fixed-aspect-ratio Axes.  Best for\n          simple grids of Axes.\n\n        - 'tight': Use the tight layout mechanism. This is a relatively\n          simple algorithm that adjusts the subplot parameters so that\n          decorations do not overlap. See `.Figure.set_tight_layout` for\n          further details.\n\n        - 'none': Do not use a layout engine.\n\n        - A `.LayoutEngine` instance. Builtin layout classes are\n          `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily\n          accessible by 'constrained' and 'tight'.  Passing an instance\n          allows third parties to provide their own layout engine.\n\n        If not given, fall back to using the parameters *tight_layout* and\n        *constrained_layout*, including their config defaults\n        :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.\n\n    **kwargs\n        Additional keyword arguments are passed to the `.Figure` constructor.\n\n    Returns\n    -------\n    `~matplotlib.figure.Figure`\n\n    Notes\n    -----\n    A newly created figure is passed to the `~.FigureCanvasBase.new_manager`\n    method or the `new_figure_manager` function provided by the current\n    backend, which install a canvas and a manager on the figure.\n\n    Once this is done, :rc:`figure.hooks` are called, one at a time, on the\n    figure; these hooks allow arbitrary customization of the figure (e.g.,\n    attaching callbacks) or of associated elements (e.g., modifying the\n    toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of\n    toolbar customization.\n\n    If you are creating many figures, make sure you explicitly call\n    `.pyplot.close` on the figures you are not using, because this will\n    enable pyplot to properly clean up the memory.\n\n    `~matplotlib.rcParams` defines the default values, which can be modified\n    in the matplotlibrc file.\n    \"\"\"\n    allnums = get_fignums()\n    next_num = max(allnums) + 1 if allnums else 1\n\n    if isinstance(num, FigureBase):\n        # type narrowed to `Figure | SubFigure` by combination of input and isinstance\n        has_figure_property_parameters = (\n            any(param is not None for param in [figsize, dpi, facecolor, edgecolor])\n            or not frameon or kwargs\n        )\n\n        root_fig = num.get_figure(root=True)\n        if root_fig.canvas.manager is None:\n            if has_figure_property_parameters:\n                raise ValueError(\n                    \"You cannot pass figure properties when calling figure() with \"\n                    \"an existing Figure instance\")\n            backend = _get_backend_mod()\n            manager_ = backend.new_figure_manager_given_figure(next_num, root_fig)\n            _pylab_helpers.Gcf._set_new_active_manager(manager_)\n            return manager_.canvas.figure\n        elif has_figure_property_parameters and root_fig.canvas.manager.num in allnums:\n            _api.warn_external(\n                \"Ignoring specified arguments in this call because figure \"\n                f\"with num: {root_fig.canvas.manager.num} already exists\")\n        _pylab_helpers.Gcf.set_active(root_fig.canvas.manager)\n        return root_fig\n\n    fig_label = ''\n    if num is None:\n        num = next_num\n    else:\n        if (any(param is not None for param in [figsize, dpi, facecolor, edgecolor])\n              or not frameon or kwargs) and num in allnums:\n            _api.warn_external(\n                \"Ignoring specified arguments in this call \"\n                f\"because figure with num: {num} already exists\")\n        if isinstance(num, str):\n            fig_label = num\n            all_labels = get_figlabels()\n            if fig_label not in all_labels:\n                if fig_label == 'all':\n                    _api.warn_external(\"close('all') closes all existing figures.\")\n                num = next_num\n            else:\n                inum = all_labels.index(fig_label)\n                num = allnums[inum]\n        else:\n            num = int(num)  # crude validation of num argument\n\n    # Type of \"num\" has narrowed to int, but mypy can't quite see it\n    manager = _pylab_helpers.Gcf.get_fig_manager(num)  # type: ignore[arg-type]\n    if manager is None:\n        max_open_warning = rcParams['figure.max_open_warning']\n        if len(allnums) == max_open_warning >= 1:\n            _api.warn_external(\n                f\"More than {max_open_warning} figures have been opened. \"\n                f\"Figures created through the pyplot interface \"\n                f\"(`matplotlib.pyplot.figure`) are retained until explicitly \"\n                f\"closed and may consume too much memory. (To control this \"\n                f\"warning, see the rcParam `figure.max_open_warning`). \"\n                f\"Consider using `matplotlib.pyplot.close()`.\",\n                RuntimeWarning)\n\n        manager = new_figure_manager(\n            num, figsize=figsize, dpi=dpi,\n            facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,\n            FigureClass=FigureClass, **kwargs)\n        fig = manager.canvas.figure\n        if fig_label:\n            fig.set_label(fig_label)\n\n        for hookspecs in rcParams[\"figure.hooks\"]:\n            module_name, dotted_name = hookspecs.split(\":\")\n            obj: Any = importlib.import_module(module_name)\n            for part in dotted_name.split(\".\"):\n                obj = getattr(obj, part)\n            obj(fig)\n\n        _pylab_helpers.Gcf._set_new_active_manager(manager)\n\n        # make sure backends (inline) that we don't ship that expect this\n        # to be called in plotting commands to make the figure call show\n        # still work.  There is probably a better way to do this in the\n        # FigureManager base class.\n        draw_if_interactive()\n\n        if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:\n            fig.stale_callback = _auto_draw_if_interactive\n\n    if clear:\n        manager.canvas.figure.clear()\n\n    return manager.canvas.figure"
}