{
    "sympy.sympy.algebras.quaternion._eval_evalf": "def _eval_evalf(self, prec: int) -> Quaternion:\n    \"\"\"Returns the floating point approximations (decimal numbers) of the quaternion.\n\n    Returns\n    =======\n\n    Quaternion\n        Floating point approximations of quaternion(self)\n\n    Examples\n    ========\n\n    >>> from sympy import Quaternion\n    >>> from sympy import sqrt\n    >>> q = Quaternion(1/sqrt(1), 1/sqrt(2), 1/sqrt(3), 1/sqrt(4))\n    >>> q.evalf()\n    1.00000000000000\n    + 0.707106781186547*i\n    + 0.577350269189626*j\n    + 0.500000000000000*k\n\n    \"\"\"\n    nprec = prec_to_dps(prec)\n    a, b, c, d = [arg.evalf(n=nprec) for arg in self.args]\n    return Quaternion(a, b, c, d)",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.evalf._eval_evalf": "def _eval_evalf(self, prec: int) -> Expr | None:\n    return None",
    "sympy.sympy.core.expr.round": "def round(self, n=None):\n    \"\"\"Return x rounded to the given decimal place.\n\n    If a complex number would result, apply round to the real\n    and imaginary components of the number.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, E, I, S, Number\n    >>> pi.round()\n    3\n    >>> pi.round(2)\n    3.14\n    >>> (2*pi + E*I).round()\n    6 + 3*I\n\n    The round method has a chopping effect:\n\n    >>> (2*pi + I/10).round()\n    6\n    >>> (pi/10 + 2*I).round()\n    2*I\n    >>> (pi/10 + E*I).round(2)\n    0.31 + 2.72*I\n\n    Notes\n    =====\n\n    The Python ``round`` function uses the SymPy ``round`` method so it\n    will always return a SymPy number (not a Python float or int):\n\n    >>> isinstance(round(S(123), -2), Number)\n    True\n    \"\"\"\n    x = self\n\n    if not x.is_number:\n        raise TypeError(\"Cannot round symbolic expression\")\n    if not x.is_Atom:\n        if not pure_complex(x.n(2), or_real=True):\n            raise TypeError(\n                'Expected a number but got %s:' % func_name(x))\n    elif x in _illegal:\n        return x\n    if not (xr := x.is_extended_real):\n        r, i = x.as_real_imag()\n        if xr is False:\n            return r.round(n) + S.ImaginaryUnit*i.round(n)\n        if i.equals(0):\n            return r.round(n)\n    if not x:\n        return S.Zero if n is None else x\n\n    p = as_int(n or 0)\n\n    if x.is_Integer:\n        return Integer(round(int(x), p))\n\n    digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1\n    allow = digits_to_decimal + p\n    precs = [f._prec for f in x.atoms(Float)]\n    dps = prec_to_dps(max(precs)) if precs else None\n    if dps is None:\n        # assume everything is exact so use the Python\n        # float default or whatever was requested\n        dps = max(15, allow)\n    else:\n        allow = min(allow, dps)\n    # this will shift all digits to right of decimal\n    # and give us dps to work with as an int\n    shift = -digits_to_decimal + dps\n    extra = 1  # how far we look past known digits\n    # NOTE\n    # mpmath will calculate the binary representation to\n    # an arbitrary number of digits but we must base our\n    # answer on a finite number of those digits, e.g.\n    # .575 2589569785738035/2**52 in binary.\n    # mpmath shows us that the first 18 digits are\n    #     >>> Float(.575).n(18)\n    #     0.574999999999999956\n    # The default precision is 15 digits and if we ask\n    # for 15 we get\n    #     >>> Float(.575).n(15)\n    #     0.575000000000000\n    # mpmath handles rounding at the 15th digit. But we\n    # need to be careful since the user might be asking\n    # for rounding at the last digit and our semantics\n    # are to round toward the even final digit when there\n    # is a tie. So the extra digit will be used to make\n    # that decision. In this case, the value is the same\n    # to 15 digits:\n    #     >>> Float(.575).n(16)\n    #     0.5750000000000000\n    # Now converting this to the 15 known digits gives\n    #     575000000000000.0\n    # which rounds to integer\n    #    5750000000000000\n    # And now we can round to the desired digt, e.g. at\n    # the second from the left and we get\n    #    5800000000000000\n    # and rescaling that gives\n    #    0.58\n    # as the final result.\n    # If the value is made slightly less than 0.575 we might\n    # still obtain the same value:\n    #    >>> Float(.575-1e-16).n(16)*10**15\n    #    574999999999999.8\n    # What 15 digits best represents the known digits (which are\n    # to the left of the decimal? 5750000000000000, the same as\n    # before. The only way we will round down (in this case) is\n    # if we declared that we had more than 15 digits of precision.\n    # For example, if we use 16 digits of precision, the integer\n    # we deal with is\n    #    >>> Float(.575-1e-16).n(17)*10**16\n    #    5749999999999998.4\n    # and this now rounds to 5749999999999998 and (if we round to\n    # the 2nd digit from the left) we get 5700000000000000.\n    #\n    xf = x.n(dps + extra)*Pow(10, shift)\n    if xf.is_Number and xf._prec == 1:  # xf.is_Add will raise below\n        # is x == 0?\n        if x.equals(0):\n            return Float(0)\n        raise ValueError('not computing with precision')\n    xi = Integer(xf)\n    # use the last digit to select the value of xi\n    # nearest to x before rounding at the desired digit\n    sign = 1 if x > 0 else -1\n    dif2 = sign*(xf - xi).n(extra)\n    if dif2 < 0:\n        raise NotImplementedError(\n            'not expecting int(x) to round away from 0')\n    if dif2 > .5:\n        xi += sign  # round away from 0\n    elif dif2 == .5:\n        xi += sign if xi%2 else -sign  # round toward even\n    # shift p to the new position\n    ip = p - shift\n    # let Python handle the int rounding then rescale\n    xr = round(xi.p, ip)\n    # restore scale\n    rv = Rational(xr, Pow(10, shift))\n    # return Float or Integer\n    if rv.is_Integer:\n        if n is None:  # the single-arg case\n            return rv\n        # use str or else it won't be a float\n        return Float(str(rv), dps)  # keep same precision\n    else:\n        if not allow and rv > self:\n            allow += 1\n        return Float(rv, allow)",
    "sympy.sympy.core.expr._mag": "def _mag(x):\n    r\"\"\"Return integer $i$ such that $0.1 \\le x/10^i < 1$\n\n    Examples\n    ========\n\n    >>> from sympy.core.expr import _mag\n    >>> from sympy import Float\n    >>> _mag(Float(.1))\n    0\n    >>> _mag(Float(.01))\n    -1\n    >>> _mag(Float(1234))\n    4\n    \"\"\"\n    from math import log10, ceil, log\n    xpos = abs(x.n())\n    if not xpos:\n        return S.Zero\n    try:\n        mag_first_dig = int(ceil(log10(xpos)))\n    except (ValueError, OverflowError):\n        mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53))/log(10)))\n    # check that we aren't off by 1\n    if (xpos/S(10)**mag_first_dig) >= 1:\n        assert 1 <= (xpos/S(10)**mag_first_dig) < 10\n        mag_first_dig += 1\n    return mag_first_dig",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.function._eval_evalf": "def _eval_evalf(self, prec):\n\n    def _get_mpmath_func(fname):\n        \"\"\"Lookup mpmath function based on name\"\"\"\n        if isinstance(self, AppliedUndef):\n            # Shouldn't lookup in mpmath but might have ._imp_\n            return None\n\n        if not hasattr(mpmath, fname):\n            fname = MPMATH_TRANSLATIONS.get(fname, None)\n            if fname is None:\n                return None\n        return getattr(mpmath, fname)\n\n    _eval_mpmath = getattr(self, '_eval_mpmath', None)\n    if _eval_mpmath is None:\n        func = _get_mpmath_func(self.func.__name__)\n        args = self.args\n    else:\n        func, args = _eval_mpmath()\n\n    # Fall-back evaluation\n    if func is None:\n        imp = getattr(self, '_imp_', None)\n        if imp is None:\n            return None\n        try:\n            return Float(imp(*[i.evalf(prec) for i in self.args]), prec)\n        except (TypeError, ValueError):\n            return None\n\n    # Convert all args to mpf or mpc\n    # Convert the arguments to *higher* precision than requested for the\n    # final result.\n    # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should\n    #     we be more intelligent about it?\n    try:\n        args = [arg._to_mpmath(prec + 5) for arg in args]\n        def bad(m):\n            from mpmath import mpf, mpc\n            # the precision of an mpf value is the last element\n            # if that is 1 (and m[1] is not 1 which would indicate a\n            # power of 2), then the eval failed; so check that none of\n            # the arguments failed to compute to a finite precision.\n            # Note: An mpc value has two parts, the re and imag tuple;\n            # check each of those parts, too. Anything else is allowed to\n            # pass\n            if isinstance(m, mpf):\n                m = m._mpf_\n                return m[1] !=1 and m[-1] == 1\n            elif isinstance(m, mpc):\n                m, n = m._mpc_\n                return m[1] !=1 and m[-1] == 1 and \\\n                    n[1] !=1 and n[-1] == 1\n            else:\n                return False\n        if any(bad(a) for a in args):\n            raise ValueError  # one or more args failed to compute with significance\n    except ValueError:\n        return\n\n    with mpmath.workprec(prec):\n        v = func(*args)\n\n    return Expr._from_mpmath(v, prec)",
    "sympy.sympy.core.mul._eval_evalf": "def _eval_evalf(self, prec):\n    c, m = self.as_coeff_Mul()\n    if c is S.NegativeOne:\n        if m.is_Mul:\n            rv = -AssocOp._eval_evalf(m, prec)\n        else:\n            mnew = m._eval_evalf(prec)\n            if mnew is not None:\n                m = mnew\n            rv = -m\n    else:\n        rv = AssocOp._eval_evalf(self, prec)\n    if rv.is_number:\n        return rv.expand()\n    return rv",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    "sympy.sympy.core.numbers._new": "@classmethod\ndef _new(cls, _mpf_, _prec, zero=True):\n    # special cases\n    if zero and _mpf_ == fzero:\n        return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    "sympy.sympy.core.operations._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\"\n    Evaluate the parts of self that are numbers; if the whole thing\n    was a number with no functions it would have been evaluated, but\n    it wasn't so we must judiciously extract the numbers and reconstruct\n    the object. This is *not* simply replacing numbers with evaluated\n    numbers. Numbers should be handled in the largest pure-number\n    expression as possible. So the code below separates ``self`` into\n    number and non-number parts and evaluates the number parts and\n    walks the args of the non-number part recursively (doing the same\n    thing).\n    \"\"\"\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        # if x is an AssocOp Function then the _evalf below will\n        # call _eval_evalf (here) so we must break the recursion\n        if not (tail is self.identity or\n                isinstance(x, AssocOp) and x.is_Function or\n                x is self.identity and isinstance(tail, AssocOp)):\n            # here, we have a number so we just call to _evalf with prec;\n            # prec is not the same as n, it is the binary precision so\n            # that's why we don't call to evalf.\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                # here we call to _eval_evalf since we don't know what we\n                # are dealing with and all other _eval_evalf routines should\n                # be doing the same thing (i.e. taking binary prec and\n                # finding the evalf-able args)\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n\n    # this is the same as above, but there were no pure-number args to\n    # deal with\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    "sympy.sympy.core.power._eval_evalf": "def _eval_evalf(self, prec):\n    base, exp = self.as_base_exp()\n    if base == S.Exp1:\n        # Use mpmath function associated to class \"exp\":\n        from sympy.functions.elementary.exponential import exp as exp_function\n        return exp_function(self.exp, evaluate=False)._eval_evalf(prec)\n    base = base._evalf(prec)\n    if not exp.is_Integer:\n        exp = exp._evalf(prec)\n    if exp.is_negative and base.is_number and base.is_extended_real is False:\n        base = base.conjugate() / (base * base.conjugate())._evalf(prec)\n        exp = -exp\n        return self.func(base, exp).expand()\n    return self.func(base, exp)",
    "sympy.sympy.core.relational._eval_evalf": "def _eval_evalf(self, prec):\n    return self.func(*[s._evalf(prec) for s in self.args])",
    "sympy.sympy.functions.combinatorial.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    if not all(x.is_number for x in self.args):\n        return\n    n = self.args[0]._to_mpmath(prec)\n    x = (self.args[1] if len(self.args) > 1 else S.One)._to_mpmath(prec)\n    with workprec(prec):\n        if n == 0:\n            res = mp.mpf(1)\n        elif n == 1:\n            res = x - mp.mpf(0.5)\n        elif mp.isint(n) and n >= 0:\n            res = mp.bernoulli(n) if x == 1 else mp.bernpoly(n, x)\n        else:\n            res = -n * mp.zeta(1-n, x)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.elementary.exponential._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    i = im(self.args[0])\n    try:\n        bad = (i <= -pi or i > pi)\n    except TypeError:\n        bad = True\n    if bad:\n        return self  # cannot evalf for this argument\n    res = exp(self.args[0])._eval_evalf(prec)\n    if i > 0 and im(res) < 0:\n        # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi\n        return re(res)\n    return res",
    "sympy.sympy.functions.elementary.piecewise._eval_evalf": "def _eval_evalf(self, prec):\n    return self.func(*[(e._evalf(prec), c) for e, c in self.args])",
    "sympy.sympy.functions.special.bessel._eval_evalf": "def _eval_evalf(self, prec):\n    if self.order.is_Integer:\n        return self.rewrite(besselj)._eval_evalf(prec)",
    "sympy.sympy.functions.special.gamma_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if all(x.is_number for x in self.args):\n        a = self.args[0]._to_mpmath(prec)\n        z = self.args[1]._to_mpmath(prec)\n        with workprec(prec):\n            res = mp.gammainc(a, z, mp.inf)\n        return Expr._from_mpmath(res, prec)\n    return self",
    "sympy.sympy.functions.special.zeta_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if all(i.is_number for i in self.args):\n        return self.rewrite(zeta)._eval_evalf(prec)",
    "sympy.sympy.geometry.curve._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    f, (t, a, b) = self.args\n    dps = prec_to_dps(prec)\n    f = tuple([i.evalf(n=dps, **options) for i in f])\n    a, b = [i.evalf(n=dps, **options) for i in (a, b)]\n    return self.func(f, (t, a, b))",
    "sympy.sympy.geometry.ellipse._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    pt, r = self.args\n    dps = prec_to_dps(prec)\n    pt = pt.evalf(n=dps, **options)\n    r = r.evalf(n=dps, **options)\n    return self.func(pt, r, evaluate=False)",
    "sympy.sympy.geometry.plane._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    pt, tup = self.args\n    dps = prec_to_dps(prec)\n    pt = pt.evalf(n=dps, **options)\n    tup = tuple([i.evalf(n=dps, **options) for i in tup])\n    return self.func(pt, normal_vector=tup, evaluate=False)",
    "sympy.sympy.geometry.point._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    \"\"\"Evaluate the coordinates of the point.\n\n    This method will, where possible, create and return a new Point\n    where the coordinates are evaluated as floating point numbers to\n    the precision indicated (default=15).\n\n    Parameters\n    ==========\n\n    prec : int\n\n    Returns\n    =======\n\n    point : Point\n\n    Examples\n    ========\n\n    >>> from sympy import Point, Rational\n    >>> p1 = Point(Rational(1, 2), Rational(3, 2))\n    >>> p1\n    Point2D(1/2, 3/2)\n    >>> p1.evalf()\n    Point2D(0.5, 1.5)\n\n    \"\"\"\n    dps = prec_to_dps(prec)\n    coords = [x.evalf(n=dps, **options) for x in self.args]\n    return Point(*coords, evaluate=False)",
    "sympy.sympy.geometry.polygon._eval_evalf": "def _eval_evalf(self, prec=15, **options):\n    c, r, n, a = self.args\n    dps = prec_to_dps(prec)\n    c, r, a = [i.evalf(n=dps, **options) for i in (c, r, a)]\n    return self.func(c, r, n, a)",
    "sympy.sympy.physics.control.lti._eval_evalf": "def _eval_evalf(self, prec):\n    return create_transfer_function(\n        self.num._eval_evalf(prec),\n        self.den._eval_evalf(prec),\n        self.var, self.sampling_time)",
    "sympy.sympy.physics.vector.dyadic.subs": "def subs(self, *args, **kwargs):\n    \"\"\"Substitution on the Dyadic.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy import Symbol\n    >>> N = ReferenceFrame('N')\n    >>> s = Symbol('s')\n    >>> a = s*(N.x|N.x)\n    >>> a.subs({s: 2})\n    2*(N.x|N.x)\n\n    \"\"\"\n\n    return sum([Dyadic([(v[0].subs(*args, **kwargs), v[1], v[2])])\n                for v in self.args], Dyadic(0))",
    "sympy.sympy.physics.vector.dyadic._eval_evalf": "def _eval_evalf(self, prec):\n    if not self.args:\n        return self\n    new_args = []\n    dps = prec_to_dps(prec)\n    for inlist in self.args:\n        new_inlist = list(inlist)\n        new_inlist[0] = inlist[0].evalf(n=dps)\n        new_args.append(tuple(new_inlist))\n    return Dyadic(new_args)",
    "sympy.sympy.physics.vector.vector.subs": "def subs(self, *args, **kwargs):\n    \"\"\"Substitution on the Vector.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy import Symbol\n    >>> N = ReferenceFrame('N')\n    >>> s = Symbol('s')\n    >>> a = N.x * s\n    >>> a.subs({s: 2})\n    2*N.x\n\n    \"\"\"\n\n    d = {}\n    for v in self.args:\n        d[v[1]] = v[0].subs(*args, **kwargs)\n    return Vector(d)",
    "sympy.sympy.physics.vector.vector._eval_evalf": "def _eval_evalf(self, prec):\n    if not self.args:\n        return self\n    new_args = []\n    dps = prec_to_dps(prec)\n    for mat, frame in self.args:\n        new_args.append([mat.evalf(n=dps), frame])\n    return Vector(new_args)",
    "sympy.sympy.polys.rootoftools._eval_evalf": "def _eval_evalf(self, prec):\n    try:\n        _roots = self.poly.nroots(n=prec_to_dps(prec))\n    except (DomainError, PolynomialError):\n        return self\n    else:\n        return Add(*[self.fun(r) for r in _roots])",
    "sympy.sympy.sets.sets._eval_evalf": "def _eval_evalf(self, prec):\n    dps = prec_to_dps(prec)\n    return self.func(*[arg.evalf(n=dps) for arg in self.args])",
    "sympy.sympy.utilities.iterables.is_sequence": "def is_sequence(i, include=None):\n    \"\"\"\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    \"\"\"\n    return (hasattr(i, '__getitem__') and\n            iterable(i) or\n            bool(include) and\n            isinstance(i, include))"
}