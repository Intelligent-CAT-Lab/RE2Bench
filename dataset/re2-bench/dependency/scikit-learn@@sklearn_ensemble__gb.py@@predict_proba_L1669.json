{
    "scikit-learn.sklearn._loss.loss.predict_proba": "def predict_proba(self, raw_prediction):\n    \"\"\"Predict probabilities.\n\n    Parameters\n    ----------\n    raw_prediction : array of shape (n_samples,) or (n_samples, 1)\n        Raw prediction values (in link space).\n\n    Returns\n    -------\n    proba : array of shape (n_samples, 2)\n        Element-wise class probabilities.\n    \"\"\"\n    # Be graceful to shape (n_samples, 1) -> (n_samples,)\n    if raw_prediction.ndim == 2 and raw_prediction.shape[1] == 1:\n        raw_prediction = raw_prediction.squeeze(1)\n    proba = np.empty((raw_prediction.shape[0], 2), dtype=raw_prediction.dtype)\n    proba[:, 1] = self.link.inverse(raw_prediction)\n    proba[:, 0] = 1 - proba[:, 1]\n    return proba",
    "scikit-learn.sklearn.ensemble._gb.decision_function": "def decision_function(self, X):\n    \"\"\"Compute the decision function of ``X``.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The input samples. Internally, it will be converted to\n        ``dtype=np.float32`` and if a sparse matrix is provided\n        to a sparse ``csr_matrix``.\n\n    Returns\n    -------\n    score : ndarray of shape (n_samples, n_classes) or (n_samples,)\n        The decision function of the input samples, which corresponds to\n        the raw values predicted from the trees of the ensemble . The\n        order of the classes corresponds to that in the attribute\n        :term:`classes_`. Regression and binary classification produce an\n        array of shape (n_samples,).\n    \"\"\"\n    X = validate_data(\n        self, X, dtype=DTYPE, order=\"C\", accept_sparse=\"csr\", reset=False\n    )\n    raw_predictions = self._raw_predict(X)\n    if raw_predictions.shape[1] == 1:\n        return raw_predictions.ravel()\n    return raw_predictions"
}