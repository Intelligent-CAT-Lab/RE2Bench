{
    "sympy.sympy.polys.matrices.ddm.matmul": "def matmul(a, b):\n    \"\"\"a @ b (matrix product)\"\"\"\n    m, o = a.shape\n    o2, n = b.shape\n    a._check(a, '*', b, o, o2)\n    c = a.zeros((m, n), a.domain)\n    ddm_imatmul(c, a, b)\n    return c",
    "sympy.sympy.polys.matrices.domainmatrix._check": "def _check(a, op, b, ashape, bshape):\n    if a.domain != b.domain:\n        msg = \"Domain mismatch: %s %s %s\" % (a.domain, op, b.domain)\n        raise DMDomainError(msg)\n    if ashape != bshape:\n        msg = \"Shape mismatch: %s %s %s\" % (a.shape, op, b.shape)\n        raise DMShapeError(msg)\n    if a.rep.fmt != b.rep.fmt:\n        msg = \"Format mismatch: %s %s %s\" % (a.rep.fmt, op, b.rep.fmt)\n        raise DMFormatError(msg)\n    if type(a.rep) != type(b.rep):\n        msg = \"Type mismatch: %s %s %s\" % (type(a.rep), op, type(b.rep))\n        raise DMFormatError(msg)",
    "sympy.sympy.polys.matrices.domainmatrix.from_rep": "@classmethod\ndef from_rep(cls, rep):\n    \"\"\"Create a new DomainMatrix efficiently from DDM/SDM.\n\n    Examples\n    ========\n\n    Create a :py:class:`~.DomainMatrix` with an dense internal\n    representation as :py:class:`~.DDM`:\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.ddm import DDM\n    >>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n    Create a :py:class:`~.DomainMatrix` with a sparse internal\n    representation as :py:class:`~.SDM`:\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import ZZ\n    >>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n    >>> dM = DomainMatrix.from_rep(drep)\n    >>> dM\n    DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)\n\n    Parameters\n    ==========\n\n    rep: SDM or DDM\n        The internal sparse or dense representation of the matrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        A :py:class:`~.DomainMatrix` wrapping *rep*.\n\n    Notes\n    =====\n\n    This takes ownership of rep as its internal representation. If rep is\n    being mutated elsewhere then a copy should be provided to\n    ``from_rep``. Only minimal verification or checking is done on *rep*\n    as this is supposed to be an efficient internal routine.\n\n    \"\"\"\n    if not (isinstance(rep, (DDM, SDM)) or (DFM is not None and isinstance(rep, DFM))):\n        raise TypeError(\"rep should be of type DDM or SDM\")\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    "sympy.sympy.polys.matrices.sdm.matmul": "def matmul(A, B):\n    \"\"\"\n    Performs matrix multiplication of two SDM matrices\n\n    Parameters\n    ==========\n\n    A, B: SDM to multiply\n\n    Returns\n    =======\n\n    SDM\n        SDM after multiplication\n\n    Raises\n    ======\n\n    DomainError\n        If domain of A does not match\n        with that of B\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n    >>> B = SDM({0:{0:ZZ(2), 1:ZZ(3)}, 1:{0:ZZ(4)}}, (2, 2), ZZ)\n    >>> A.matmul(B)\n    {0: {0: 8}, 1: {0: 2, 1: 3}}\n\n    \"\"\"\n    if A.domain != B.domain:\n        raise DMDomainError\n    m, n = A.shape\n    n2, o = B.shape\n    if n != n2:\n        raise DMShapeError\n    C = sdm_matmul(A, B, A.domain, m, o)\n    return A.new(C, (m, o), A.domain)"
}