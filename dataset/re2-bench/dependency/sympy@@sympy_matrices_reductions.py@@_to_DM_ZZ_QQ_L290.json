{
    "sympy.sympy.matrices.reductions.<genexpr>": "if not all(e.is_Rational for e in M):\n    return None\n",
    "sympy.sympy.polys.matrices.domainmatrix.convert_to": "def convert_to(self, K):\n    r\"\"\"\n    Change the domain of DomainMatrix to desired domain or field\n\n    Parameters\n    ==========\n\n    K : Represents the desired domain or field.\n        Alternatively, ``None`` may be passed, in which case this method\n        just returns a copy of this DomainMatrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        DomainMatrix with the desired domain or field\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ, ZZ_I\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n    >>> A.convert_to(ZZ_I)\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ_I)\n\n    \"\"\"\n    if K == self.domain:\n        return self.copy()\n\n    rep = self.rep\n\n    # The DFM, DDM and SDM types do not do any implicit conversions so we\n    # manage switching between DDM and DFM here.\n    if rep.is_DFM and not DFM._supports_domain(K):\n        rep_K = rep.to_ddm().convert_to(K)\n    elif rep.is_DDM and DFM._supports_domain(K):\n        rep_K = rep.convert_to(K).to_dfm()\n    else:\n        rep_K = rep.convert_to(K)\n\n    return self.from_rep(rep_K)"
}