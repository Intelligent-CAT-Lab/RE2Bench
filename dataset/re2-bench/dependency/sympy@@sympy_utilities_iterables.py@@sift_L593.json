{
    "sympy.sympy.assumptions.handlers.matrices.<lambda>": "d = sift(expr.args, lambda x: isinstance(x, MatrixExpr))\n",
    "sympy.sympy.codegen.ast.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.codegen.rewriting.<lambda>": "func, coeff = sift(with_func.args, lambda arg: arg.func == self.func, binary=True)\n",
    "sympy.sympy.concrete.expr_with_limits.<lambda>": "out = sift(summand.args, lambda w: w.is_commutative \\\n    and not set(self.variables) & w.free_symbols)\n",
    "sympy.sympy.concrete.summations.<lambda>": "roots = sift(roots, lambda x: x.is_integer)\n",
    "sympy.sympy.core.add.<lambda>": "l1, l2 = sift(self.args, lambda x: x.has_free(*deps), binary=True)\n",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.core.function.<lambda>": "lambda p:p.default == p.empty, binary=True))\n",
    "sympy.sympy.core.mul.<lambda>": "l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        other = Float(other)\n    return Basic.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.core.operations.<lambda>": "lambda arg: arg.is_commutative is True, binary=True)\n",
    "sympy.sympy.core.power.<lambda>": "npow, cargs = sift(cargs, lambda x: x.is_Pow and\n    x.exp.is_Rational and x.base.is_number,\n    binary=True)\n",
    "sympy.sympy.core.power.pred": "def pred(x):\n    if x is S.ImaginaryUnit:\n        return S.ImaginaryUnit\n    polar = x.is_polar\n    if polar:\n        return True\n    if polar is None:\n        return fuzzy_bool(x.is_extended_nonnegative)",
    "sympy.sympy.core.relational.<lambda>": "real_imag = lambda t: (\n    'real' if is_extended_real(t, assumptions) else\n    'imag' if is_extended_real(I*t, assumptions) else None)\n",
    "sympy.sympy.core.sorting.ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    \"\"\"Return an iterator of the seq where keys are used to break ties\n    in a conservative fashion: if, after applying a key, there are no\n    ties then no other keys will be computed.\n\n    Two default keys will be applied if 1) keys are not provided or\n    2) the given keys do not resolve all ties (but only if ``default``\n    is True). The two keys are ``_nodes`` (which places smaller\n    expressions before large) and ``default_sort_key`` which (if the\n    ``sort_key`` for an object is defined properly) should resolve\n    any ties. This strategy is similar to sorting done by\n    ``Basic.compare``, but differs in that ``ordered`` never makes a\n    decision based on an objects name.\n\n    If ``warn`` is True then an error will be raised if there were no\n    keys remaining to break ties. This can be used if it was expected that\n    there should be no ties between items that are not identical.\n\n    Examples\n    ========\n\n    >>> from sympy import ordered, count_ops\n    >>> from sympy.abc import x, y\n\n    The count_ops is not sufficient to break ties in this list and the first\n    two items appear in their original order (i.e. the sorting is stable):\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n    ...    count_ops, default=False, warn=False))\n    ...\n    [y + 2, x + 2, x**2 + y + 3]\n\n    The default_sort_key allows the tie to be broken:\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n    ...\n    [x + 2, y + 2, x**2 + y + 3]\n\n    Here, sequences are sorted by length, then sum:\n\n    >>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n    ...    lambda x: len(x),\n    ...    lambda x: sum(x)]]\n    ...\n    >>> list(ordered(seq, keys, default=False, warn=False))\n    [[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]\n\n    If ``warn`` is True, an error will be raised if there were not\n    enough keys to break ties:\n\n    >>> list(ordered(seq, keys, default=False, warn=True))\n    Traceback (most recent call last):\n    ...\n    ValueError: not enough keys to break ties\n\n\n    Notes\n    =====\n\n    The decorated sort is one of the fastest ways to sort a sequence for\n    which special item comparison is desired: the sequence is decorated,\n    sorted on the basis of the decoration (e.g. making all letters lower\n    case) and then undecorated. If one wants to break ties for items that\n    have the same decorated value, a second key can be used. But if the\n    second key is expensive to compute then it is inefficient to decorate\n    all items with both keys: only those items having identical first key\n    values need to be decorated. This function applies keys successively\n    only when needed to break ties. By yielding an iterator, use of the\n    tie-breaker is delayed as long as possible.\n\n    This function is best used in cases when use of the first key is\n    expected to be a good hashing function; if there are no unique hashes\n    from application of a key, then that key should not have been used. The\n    exception, however, is that even if there are many collisions, if the\n    first group is small and one does not need to process all items in the\n    list then time will not be wasted sorting what one was not interested\n    in. For example, if one were looking for the minimum in a list and\n    there were several criteria used to define the sort order, then this\n    function would be good at returning that quickly if the first group\n    of candidates is small relative to the number of items being processed.\n\n    \"\"\"\n\n    d = defaultdict(list)\n    if keys:\n        if isinstance(keys, (list, tuple)):\n            keys = list(keys)\n            f = keys.pop(0)\n        else:\n            f = keys\n            keys = []\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n\n    for k, value in sorted(d.items()):\n        if len(value) > 1:\n            if keys:\n                value = ordered(value, keys, default, warn)\n            elif default:\n                value = ordered(value, (_nodes, default_sort_key,),\n                               default=False, warn=warn)\n            elif warn:\n                u = list(uniq(value))\n                if len(u) > 1:\n                    raise ValueError(\n                        'not enough keys to break ties: %s' % u)\n        yield from value",
    "sympy.sympy.functions.elementary.miscellaneous.<lambda>": "is_other = lambda arg: isinstance(arg, other)\n",
    "sympy.sympy.functions.elementary.piecewise.<lambda>": "lambda i: isinstance(i, Eq), binary=True)\n",
    "sympy.sympy.logic.boolalg.<lambda>": "lambda x: len(x[0]))\n",
    "sympy.sympy.logic.boolalg.__hash__": "def __hash__(self):\n    return hash(True)",
    "sympy.sympy.matrices.expressions.blockmatrix.<lambda>": "args = sift(expr.args, lambda M: isinstance(M, BlockMatrix))\n",
    "sympy.sympy.matrices.expressions.kronecker._kronecker_dims_key": "def _kronecker_dims_key(expr):\n    if isinstance(expr, KroneckerProduct):\n        return tuple(a.shape for a in expr.args)\n    else:\n        return (0,)",
    "sympy.sympy.matrices.expressions.matadd.<lambda>": "groups = sift(matadd.args, lambda arg: isinstance(arg, MatrixBase))\n",
    "sympy.sympy.matrices.immutable.__hash__": "def __hash__(self):\n    return MatrixExpr.__hash__(self)",
    "sympy.sympy.matrices.repmatrix.__eq__": "def __eq__(self, other):\n    # Skip sympify for mutable matrices...\n    if not isinstance(other, RepMatrix):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if not isinstance(other, RepMatrix):\n            return NotImplemented\n\n    return self._rep.unify_eq(other._rep)",
    "sympy.sympy.physics.units.util.<lambda>": "d = sift(expr.atoms(Quantity), lambda i: i.dimension)\n",
    "sympy.sympy.polys.numberfields.minpoly.is_sqrt": "def is_sqrt(expr):\n    return expr.is_Pow and expr.exp is S.Half",
    "sympy.sympy.polys.numberfields.minpoly.<lambda>": "r = sift(f.items(), lambda itx: itx[0].is_Rational and itx[1].is_Rational)\n",
    "sympy.sympy.polys.polytools.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.polys.polytools.<lambda>": "c, nc = sift(f.args, lambda x:\n    x.is_commutative is True and not x.has(Piecewise),\n    binary=True)\n",
    "sympy.sympy.polys.rootoftools.<lambda>": "sifted = sift(complexes, lambda c: c[1])\n",
    "sympy.sympy.printing.latex.<lambda>": "prefixes, units = sift(units, lambda x: hasattr(x, \"_scale_factor\"), binary=True)\n",
    "sympy.sympy.printing.str.<lambda>": "d, n = sift(args, lambda x:\n    isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0),\n    binary=True)\n",
    "sympy.sympy.sets.conditionset.<lambda>": "base_set, lambda _: fuzzy_bool(condition.subs(sym, _)))\n",
    "sympy.sympy.sets.sets.<lambda>": "fs_args, other = sift([x, y], lambda x: isinstance(x, FiniteSet), binary=True)\n",
    "sympy.sympy.sets.sets.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.simplify.cse_main.<lambda>": "d = sift(e, lambda w: w.is_Equality and w.lhs.is_Symbol)\n",
    "sympy.sympy.simplify.gammasimp.gamma_factor": "def gamma_factor(x):\n    # return True if there is a gamma factor in shallow args\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any(gamma_factor(xi) for xi in x.args)\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False",
    "sympy.sympy.simplify.hyperexpand.<lambda>": "symb_a, symb_b = [sift(params, lambda x: _mod1(x.xreplace(repl)))\n    for params in [self.func.ap, self.func.bq]]\n",
    "sympy.sympy.simplify.hyperexpand._mod1": "def _mod1(x):\n    # TODO see if this can work as Mod(x, 1); this will require\n    # different handling of the \"buckets\" since these need to\n    # be sorted and that fails when there is a mixture of\n    # integers and expressions with parameters. With the current\n    # Mod behavior, Mod(k, 1) == Mod(1, 1) == 0 if k is an integer.\n    # Although the sorting can be done with Basic.compare, this may\n    # still require different handling of the sorted buckets.\n    if x.is_Number:\n        return Mod(x, 1)\n    c, x = x.as_coeff_Add()\n    return Mod(c, 1) + x",
    "sympy.sympy.simplify.radsimp.<lambda>": "cond = lambda x: x.is_Symbol or (-x).is_Symbol or bool(\n    x.atoms(Wild))\n",
    "sympy.sympy.simplify.simplify.<lambda>": "lambda i: isinstance(i, Sum), binary=True)\n",
    "sympy.sympy.solvers.inequalities.<lambda>": "sifted = sift(critical_points, lambda x: x.is_extended_real)\n",
    "sympy.sympy.solvers.ode.ode.<lambda>": "f = lambda i: isinstance(i, Number) or i in Cs\n",
    "sympy.sympy.solvers.solvers.<lambda>": "add, other = sift(targs, lambda x: x.args[0].is_Add, binary=True)\n",
    "sympy.sympy.tensor.index_methods.<lambda>": "return sift(uniq, lambda x: uniq[x], binary=True)\n\n",
    "sympy.sympy.tensor.tensor.siftkey": "def siftkey(ind):\n    if isinstance(ind, WildTensorIndex):\n        if ind.ignore_updown:\n            return \"wild, updown\"\n        else:\n            return \"wild\"\n    else:\n        return \"nonwild\"",
    "sympy.sympy.tensor.tensor.<lambda>": "indexless_wilds, wilds = sift(query_sifted[\"WildTensor\"], lambda x: len(x.get_free_indices()) == 0, binary=True)\n\n"
}