{
    "sympy.sympy.matrices.repmatrix._fromrep": "@classmethod\ndef _fromrep(cls, rep):\n    obj = super().__new__(cls)\n    obj.rows, obj.cols = rep.shape # type: ignore\n    obj._rep = rep\n    return obj",
    "sympy.sympy.polys.domains.algebraicfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, AlgebraicField):\n        return self.dtype == other.dtype and self.ext == other.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.domain.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    # XXX: Remove this.\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(self, other):\n    if isinstance(other, ExpressionDomain):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.finitefield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FiniteField) and \\\n        self.mod == other.mod and self.dom == other.dom",
    "sympy.sympy.polys.domains.fractionfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if not isinstance(other, FractionField):\n        return NotImplemented\n    return self.field == other.field",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, GaussianRationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.integerring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, IntegerRing):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns `True` if two domains are equivalent. \"\"\"\n    if not isinstance(other, PolynomialRing):\n        return NotImplemented\n    return self.ring == other.ring",
    "sympy.sympy.polys.domains.rationalfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, RationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.realfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, RealField) and self.precision == other.precision",
    "sympy.sympy.polys.matrices.domainmatrix.copy": "def copy(self):\n    return self.from_rep(self.rep.copy())",
    "sympy.sympy.polys.matrices.domainmatrix.convert_to": "def convert_to(self, K):\n    r\"\"\"\n    Change the domain of DomainMatrix to desired domain or field\n\n    Parameters\n    ==========\n\n    K : Represents the desired domain or field.\n        Alternatively, ``None`` may be passed, in which case this method\n        just returns a copy of this DomainMatrix.\n\n    Returns\n    =======\n\n    DomainMatrix\n        DomainMatrix with the desired domain or field\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ, ZZ_I\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n    >>> A.convert_to(ZZ_I)\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ_I)\n\n    \"\"\"\n    if K == self.domain:\n        return self.copy()\n\n    rep = self.rep\n\n    # The DFM, DDM and SDM types do not do any implicit conversions so we\n    # manage switching between DDM and DFM here.\n    if rep.is_DFM and not DFM._supports_domain(K):\n        rep_K = rep.to_ddm().convert_to(K)\n    elif rep.is_DDM and DFM._supports_domain(K):\n        rep_K = rep.convert_to(K).to_dfm()\n    else:\n        rep_K = rep.convert_to(K)\n\n    return self.from_rep(rep_K)",
    "sympy.sympy.polys.matrices.domainmatrix.to_sparse": "def to_sparse(self):\n    \"\"\"\n    Return a sparse DomainMatrix representation of *self*.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy import QQ\n    >>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n    >>> A.rep\n    [[1, 0], [0, 2]]\n    >>> B = A.to_sparse()\n    >>> B.rep\n    {0: {0: 1}, 1: {1: 2}}\n    \"\"\"\n    if self.rep.fmt == 'sparse':\n        return self\n\n    return self.from_rep(self.rep.to_sdm())"
}