{
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.exprtools.<listcomp>": "return a.func(*[handle(i) for i in a.args])\n",
    "sympy.sympy.core.exprtools.gcd_terms": "def gcd_terms(terms, isprimitive=False, clear=True, fraction=True):\n    \"\"\"Compute the GCD of ``terms`` and put them together.\n\n    Parameters\n    ==========\n\n    terms : Expr\n        Can be an expression or a non-Basic sequence of expressions\n        which will be handled as though they are terms from a sum.\n\n    isprimitive : bool, optional\n        If ``isprimitive`` is True the _gcd_terms will not run the primitive\n        method on the terms.\n\n    clear : bool, optional\n        It controls the removal of integers from the denominator of an Add\n        expression. When True (default), all numerical denominator will be cleared;\n        when False the denominators will be cleared only if all terms had numerical\n        denominators other than 1.\n\n    fraction : bool, optional\n        When True (default), will put the expression over a common\n        denominator.\n\n    Examples\n    ========\n\n    >>> from sympy import gcd_terms\n    >>> from sympy.abc import x, y\n\n    >>> gcd_terms((x + 1)**2*y + (x + 1)*y**2)\n    y*(x + 1)*(x + y + 1)\n    >>> gcd_terms(x/2 + 1)\n    (x + 2)/2\n    >>> gcd_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> gcd_terms(x/2 + y/2, clear=False)\n    (x + y)/2\n    >>> gcd_terms(x/2 + 1/x)\n    (x**2 + 2)/(2*x)\n    >>> gcd_terms(x/2 + 1/x, fraction=False)\n    (x + 2/x)/2\n    >>> gcd_terms(x/2 + 1/x, fraction=False, clear=False)\n    x/2 + 1/x\n\n    >>> gcd_terms(x/2/y + 1/x/y)\n    (x**2 + 2)/(2*x*y)\n    >>> gcd_terms(x/2/y + 1/x/y, clear=False)\n    (x**2/2 + 1)/(x*y)\n    >>> gcd_terms(x/2/y + 1/x/y, clear=False, fraction=False)\n    (x/2 + 1/x)/y\n\n    The ``clear`` flag was ignored in this case because the returned\n    expression was a rational expression, not a simple sum.\n\n    See Also\n    ========\n\n    factor_terms, sympy.polys.polytools.terms_gcd\n\n    \"\"\"\n    def mask(terms):\n        \"\"\"replace nc portions of each term with a unique Dummy symbols\n        and return the replacements to restore them\"\"\"\n        args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]\n        reps = []\n        for i, (c, nc) in enumerate(args):\n            if nc:\n                nc = Mul(*nc)\n                d = Dummy()\n                reps.append((d, nc))\n                c.append(d)\n                args[i] = Mul(*c)\n            else:\n                args[i] = c\n        return args, dict(reps)\n\n    isadd = isinstance(terms, Add)\n    addlike = isadd or not isinstance(terms, Basic) and \\\n        is_sequence(terms, include=set) and \\\n        not isinstance(terms, Dict)\n\n    if addlike:\n        if isadd:  # i.e. an Add\n            terms = list(terms.args)\n        else:\n            terms = sympify(terms)\n        terms, reps = mask(terms)\n        cont, numer, denom = _gcd_terms(terms, isprimitive, fraction)\n        numer = numer.xreplace(reps)\n        coeff, factors = cont.as_coeff_Mul()\n        if not clear:\n            c, _coeff = coeff.as_coeff_Mul()\n            if not c.is_Integer and not clear and numer.is_Add:\n                n, d = c.as_numer_denom()\n                _numer = numer/d\n                if any(a.as_coeff_Mul()[0].is_Integer\n                        for a in _numer.args):\n                    numer = _numer\n                    coeff = n*_coeff\n        return _keep_coeff(coeff, factors*numer/denom, clear=clear)\n\n    if not isinstance(terms, Basic):\n        return terms\n\n    if terms.is_Atom:\n        return terms\n\n    if terms.is_Mul:\n        c, args = terms.as_coeff_mul()\n        return _keep_coeff(c, Mul(*[gcd_terms(i, isprimitive, clear, fraction)\n            for i in args]), clear=clear)\n\n    def handle(a):\n        # don't treat internal args like terms of an Add\n        if not isinstance(a, Expr):\n            if isinstance(a, Basic):\n                if not a.args:\n                    return a\n                return a.func(*[handle(i) for i in a.args])\n            return type(a)([handle(i) for i in a])\n        return gcd_terms(a, isprimitive, clear, fraction)\n\n    if isinstance(terms, Dict):\n        return Dict(*[(k, handle(v)) for k, v in terms.args])\n    return terms.func(*[handle(i) for i in terms.args])"
}