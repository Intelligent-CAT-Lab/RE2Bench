{
    "sympy.sympy.polys.agca.extensions.__eq__": "def __eq__(self, other):\n    if not isinstance(other, FiniteExtension):\n        return False\n    return self.modulus == other.modulus",
    "sympy.sympy.polys.domains.algebraicfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, AlgebraicField):\n        return self.dtype == other.dtype and self.ext == other.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.domain.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    # XXX: Remove this.\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(self, other):\n    if isinstance(other, ExpressionDomain):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.finitefield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FiniteField) and \\\n        self.mod == other.mod and self.dom == other.dom",
    "sympy.sympy.polys.domains.fractionfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if not isinstance(other, FractionField):\n        return NotImplemented\n    return self.field == other.field",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, GaussianRationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.integerring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, IntegerRing):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns `True` if two domains are equivalent. \"\"\"\n    if not isinstance(other, PolynomialRing):\n        return NotImplemented\n    return self.ring == other.ring",
    "sympy.sympy.polys.domains.rationalfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, RationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.realfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, RealField) and self.precision == other.precision",
    "sympy.sympy.polys.matrices.sdm.unop_dict": "def unop_dict(A, f):\n    B = {}\n    for i, Ai in A.items():\n        Bi = {}\n        for j, Aij in Ai.items():\n            Bij = f(Aij)\n            if Bij:\n                Bi[j] = Bij\n        if Bi:\n            B[i] = Bi\n    return B",
    "sympy.sympy.polys.matrices.sdm.new": "@classmethod\ndef new(cls, sdm, shape, domain):\n    \"\"\"\n\n    Parameters\n    ==========\n\n    sdm: A dict of dicts for non-zero elements in SDM\n    shape: tuple representing dimension of SDM\n    domain: Represents :py:class:`~.Domain` of SDM\n\n    Returns\n    =======\n\n    An :py:class:`~.SDM` object\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import QQ\n    >>> elemsdict = {0:{1: QQ(2)}}\n    >>> A = SDM.new(elemsdict, (2, 2), QQ)\n    >>> A\n    {0: {1: 2}}\n\n    \"\"\"\n    return cls(sdm, shape, domain)",
    "sympy.sympy.polys.matrices.sdm.copy": "def copy(A):\n    \"\"\"\n    Returns the copy of a :py:class:`~.SDM` object\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.sdm import SDM\n    >>> from sympy import QQ\n    >>> elemsdict = {0:{1:QQ(2)}, 1:{}}\n    >>> A = SDM(elemsdict, (2, 2), QQ)\n    >>> B = A.copy()\n    >>> B\n    {0: {1: 2}, 1: {}}\n\n    \"\"\"\n    Ac = {i: Ai.copy() for i, Ai in A.items()}\n    return A.new(Ac, A.shape, A.domain)"
}