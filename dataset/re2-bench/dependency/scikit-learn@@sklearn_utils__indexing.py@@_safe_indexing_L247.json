{
    "scikit-learn.sklearn.utils._indexing._determine_key_type": "def _determine_key_type(key, accept_slice=True):\n    \"\"\"Determine the data type of key.\n\n    Parameters\n    ----------\n    key : scalar, slice or array-like\n        The key from which we want to infer the data type.\n\n    accept_slice : bool, default=True\n        Whether or not to raise an error if the key is a slice.\n\n    Returns\n    -------\n    dtype : {'int', 'str', 'bool', None}\n        Returns the data type of key.\n    \"\"\"\n    err_msg = (\n        \"No valid specification of the columns. Only a scalar, list or \"\n        \"slice of all integers or all strings, or boolean mask is \"\n        \"allowed\"\n    )\n\n    dtype_to_str = {int: \"int\", str: \"str\", bool: \"bool\", np.bool_: \"bool\"}\n    array_dtype_to_str = {\n        \"i\": \"int\",\n        \"u\": \"int\",\n        \"b\": \"bool\",\n        \"O\": \"str\",\n        \"U\": \"str\",\n        \"S\": \"str\",\n    }\n\n    if key is None:\n        return None\n    if isinstance(key, tuple(dtype_to_str.keys())):\n        try:\n            return dtype_to_str[type(key)]\n        except KeyError:\n            raise ValueError(err_msg)\n    if isinstance(key, slice):\n        if not accept_slice:\n            raise TypeError(\n                \"Only array-like or scalar are supported. A Python slice was given.\"\n            )\n        if key.start is None and key.stop is None:\n            return None\n        key_start_type = _determine_key_type(key.start)\n        key_stop_type = _determine_key_type(key.stop)\n        if key_start_type is not None and key_stop_type is not None:\n            if key_start_type != key_stop_type:\n                raise ValueError(err_msg)\n        if key_start_type is not None:\n            return key_start_type\n        return key_stop_type\n    # TODO(1.9) remove UserList when the force_int_remainder_cols param\n    # of ColumnTransformer is removed\n    if isinstance(key, (list, tuple, UserList)):\n        unique_key = set(key)\n        key_type = {_determine_key_type(elt) for elt in unique_key}\n        if not key_type:\n            return None\n        if len(key_type) != 1:\n            raise ValueError(err_msg)\n        return key_type.pop()\n    if hasattr(key, \"dtype\"):\n        xp, is_array_api = get_namespace(key)\n        # NumPy arrays are special-cased in their own branch because the Array API\n        # cannot handle object/string-based dtypes that are often used to index\n        # columns of dataframes by names.\n        if is_array_api and not _is_numpy_namespace(xp):\n            if xp.isdtype(key.dtype, \"bool\"):\n                return \"bool\"\n            elif xp.isdtype(key.dtype, \"integral\"):\n                return \"int\"\n            else:\n                raise ValueError(err_msg)\n        else:\n            try:\n                return array_dtype_to_str[key.dtype.kind]\n            except KeyError:\n                raise ValueError(err_msg)\n    raise ValueError(err_msg)",
    "scikit-learn.sklearn.utils._indexing._array_indexing": "def _array_indexing(array, key, key_dtype, axis):\n    \"\"\"Index an array or scipy.sparse consistently across NumPy version.\"\"\"\n    xp, is_array_api, device_ = get_namespace_and_device(array)\n    if is_array_api:\n        key = move_to(key, xp=xp, device=device_)\n        return xp.take(array, key, axis=axis)\n    if issparse(array) and key_dtype == \"bool\":\n        key = np.asarray(key)\n    if isinstance(key, tuple):\n        key = list(key)\n    return array[key, ...] if axis == 0 else array[:, key]",
    "scikit-learn.sklearn.utils._indexing._pandas_indexing": "def _pandas_indexing(X, key, key_dtype, axis):\n    \"\"\"Index a pandas dataframe or a series.\"\"\"\n    if _is_arraylike_not_scalar(key):\n        key = np.asarray(key)\n\n    if key_dtype == \"int\" and not (isinstance(key, slice) or np.isscalar(key)):\n        # using take() instead of iloc[] ensures the return value is a \"proper\"\n        # copy that will not raise SettingWithCopyWarning\n        return X.take(key, axis=axis)\n    else:\n        # check whether we should index with loc or iloc\n        indexer = X.iloc if key_dtype == \"int\" else X.loc\n        return indexer[:, key] if axis else indexer[key]",
    "scikit-learn.sklearn.utils._indexing._list_indexing": "def _list_indexing(X, key, key_dtype):\n    \"\"\"Index a Python list.\"\"\"\n    if np.isscalar(key) or isinstance(key, slice):\n        # key is a slice or a scalar\n        return X[key]\n    if key_dtype == \"bool\":\n        # key is a boolean array-like\n        return list(compress(X, key))\n    # key is an integer array-like of key\n    return [X[idx] for idx in key]",
    "scikit-learn.sklearn.utils.validation._is_pandas_df": "def _is_pandas_df(X):\n    \"\"\"Return True if the X is a pandas dataframe.\"\"\"\n    try:\n        pd = sys.modules[\"pandas\"]\n    except KeyError:\n        return False\n    return isinstance(X, pd.DataFrame)",
    "scikit-learn.sklearn.utils.validation._is_pyarrow_data": "def _is_pyarrow_data(X):\n    \"\"\"Return True if the X is a pyarrow Table, RecordBatch, Array or ChunkedArray.\"\"\"\n    try:\n        pa = sys.modules[\"pyarrow\"]\n    except KeyError:\n        return False\n    return isinstance(X, (pa.Table, pa.RecordBatch, pa.Array, pa.ChunkedArray))",
    "scikit-learn.sklearn.utils.validation._is_polars_df_or_series": "def _is_polars_df_or_series(X):\n    \"\"\"Return True if the X is a polars dataframe or series.\"\"\"\n    try:\n        pl = sys.modules[\"polars\"]\n    except KeyError:\n        return False\n    return isinstance(X, (pl.DataFrame, pl.Series))",
    "scikit-learn.sklearn.utils.validation._use_interchange_protocol": "def _use_interchange_protocol(X):\n    \"\"\"Use interchange protocol for non-pandas dataframes that follow the protocol.\n\n    Note: at this point we chose not to use the interchange API on pandas dataframe\n    to ensure strict behavioral backward compatibility with older versions of\n    scikit-learn.\n    \"\"\"\n    return not _is_pandas_df(X) and hasattr(X, \"__dataframe__\")"
}