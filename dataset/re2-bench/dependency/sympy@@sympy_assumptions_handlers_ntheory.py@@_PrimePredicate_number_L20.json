{
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__int__": "def __int__(self) -> int:\n    if not self.is_number:\n        raise TypeError(\"Cannot convert symbols to int\")\n    if not self.is_comparable:\n        raise TypeError(\"Cannot convert non-comparable expression to int\")\n    r = self.round(2)\n    if not r.is_Number:\n        raise TypeError(\"Cannot convert complex to int\")\n    if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n        raise TypeError(\"Cannot convert %s to int\" % r)\n    i = int(r)\n    if not i:\n        return i\n    if int_valued(r):\n        r = self.round(15)\n        i = int(r)\n    if int_valued(r):\n        # non-integer self should pass one of these tests\n        if (self > i) is S.true:\n            return i\n        if (self < i) is S.true:\n            return i - 1\n        ok = self.equals(i)\n        if ok is None:\n            raise TypeError('cannot compute int value accurately')\n        if ok:\n            return i\n        # off by one\n        return i - (1 if i > 0 else -1)\n    return i",
    "sympy.sympy.core.expr.round": "def round(self, n=None):\n    \"\"\"Return x rounded to the given decimal place.\n\n    If a complex number would result, apply round to the real\n    and imaginary components of the number.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, E, I, S, Number\n    >>> pi.round()\n    3\n    >>> pi.round(2)\n    3.14\n    >>> (2*pi + E*I).round()\n    6 + 3*I\n\n    The round method has a chopping effect:\n\n    >>> (2*pi + I/10).round()\n    6\n    >>> (pi/10 + 2*I).round()\n    2*I\n    >>> (pi/10 + E*I).round(2)\n    0.31 + 2.72*I\n\n    Notes\n    =====\n\n    The Python ``round`` function uses the SymPy ``round`` method so it\n    will always return a SymPy number (not a Python float or int):\n\n    >>> isinstance(round(S(123), -2), Number)\n    True\n    \"\"\"\n    x = self\n\n    if not x.is_number:\n        raise TypeError(\"Cannot round symbolic expression\")\n    if not x.is_Atom:\n        if not pure_complex(x.n(2), or_real=True):\n            raise TypeError(\n                'Expected a number but got %s:' % func_name(x))\n    elif x in _illegal:\n        return x\n    if not (xr := x.is_extended_real):\n        r, i = x.as_real_imag()\n        if xr is False:\n            return r.round(n) + S.ImaginaryUnit*i.round(n)\n        if i.equals(0):\n            return r.round(n)\n    if not x:\n        return S.Zero if n is None else x\n\n    p = as_int(n or 0)\n\n    if x.is_Integer:\n        return Integer(round(int(x), p))\n\n    digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1\n    allow = digits_to_decimal + p\n    precs = [f._prec for f in x.atoms(Float)]\n    dps = prec_to_dps(max(precs)) if precs else None\n    if dps is None:\n        # assume everything is exact so use the Python\n        # float default or whatever was requested\n        dps = max(15, allow)\n    else:\n        allow = min(allow, dps)\n    # this will shift all digits to right of decimal\n    # and give us dps to work with as an int\n    shift = -digits_to_decimal + dps\n    extra = 1  # how far we look past known digits\n    # NOTE\n    # mpmath will calculate the binary representation to\n    # an arbitrary number of digits but we must base our\n    # answer on a finite number of those digits, e.g.\n    # .575 2589569785738035/2**52 in binary.\n    # mpmath shows us that the first 18 digits are\n    #     >>> Float(.575).n(18)\n    #     0.574999999999999956\n    # The default precision is 15 digits and if we ask\n    # for 15 we get\n    #     >>> Float(.575).n(15)\n    #     0.575000000000000\n    # mpmath handles rounding at the 15th digit. But we\n    # need to be careful since the user might be asking\n    # for rounding at the last digit and our semantics\n    # are to round toward the even final digit when there\n    # is a tie. So the extra digit will be used to make\n    # that decision. In this case, the value is the same\n    # to 15 digits:\n    #     >>> Float(.575).n(16)\n    #     0.5750000000000000\n    # Now converting this to the 15 known digits gives\n    #     575000000000000.0\n    # which rounds to integer\n    #    5750000000000000\n    # And now we can round to the desired digt, e.g. at\n    # the second from the left and we get\n    #    5800000000000000\n    # and rescaling that gives\n    #    0.58\n    # as the final result.\n    # If the value is made slightly less than 0.575 we might\n    # still obtain the same value:\n    #    >>> Float(.575-1e-16).n(16)*10**15\n    #    574999999999999.8\n    # What 15 digits best represents the known digits (which are\n    # to the left of the decimal? 5750000000000000, the same as\n    # before. The only way we will round down (in this case) is\n    # if we declared that we had more than 15 digits of precision.\n    # For example, if we use 16 digits of precision, the integer\n    # we deal with is\n    #    >>> Float(.575-1e-16).n(17)*10**16\n    #    5749999999999998.4\n    # and this now rounds to 5749999999999998 and (if we round to\n    # the 2nd digit from the left) we get 5700000000000000.\n    #\n    xf = x.n(dps + extra)*Pow(10, shift)\n    if xf.is_Number and xf._prec == 1:  # xf.is_Add will raise below\n        # is x == 0?\n        if x.equals(0):\n            return Float(0)\n        raise ValueError('not computing with precision')\n    xi = Integer(xf)\n    # use the last digit to select the value of xi\n    # nearest to x before rounding at the desired digit\n    sign = 1 if x > 0 else -1\n    dif2 = sign*(xf - xi).n(extra)\n    if dif2 < 0:\n        raise NotImplementedError(\n            'not expecting int(x) to round away from 0')\n    if dif2 > .5:\n        xi += sign  # round away from 0\n    elif dif2 == .5:\n        xi += sign if xi%2 else -sign  # round toward even\n    # shift p to the new position\n    ip = p - shift\n    # let Python handle the int rounding then rescale\n    xr = round(xi.p, ip)\n    # restore scale\n    rv = Rational(xr, Pow(10, shift))\n    # return Float or Integer\n    if rv.is_Integer:\n        if n is None:  # the single-arg case\n            return rv\n        # use str or else it won't be a float\n        return Float(str(rv), dps)  # keep same precision\n    else:\n        if not allow and rv > self:\n            allow += 1\n        return Float(rv, allow)",
    "sympy.sympy.core.expr.equals": "def equals(self, other, failing_expression=False):\n    \"\"\"Return True if self == other, False if it does not, or None. If\n    failing_expression is True then the expression which did not simplify\n    to a 0 will be returned instead of None.\n\n    Explanation\n    ===========\n\n    If ``self`` is a Number (or complex number) that is not zero, then\n    the result is False.\n\n    If ``self`` is a number and has not evaluated to zero, evalf will be\n    used to test whether the expression evaluates to zero. If it does so\n    and the result has significance (i.e. the precision is either -1, for\n    a Rational result, or is greater than 1) then the evalf value will be\n    used to return True or False.\n\n    \"\"\"\n    from sympy.simplify.simplify import nsimplify, simplify\n    from sympy.solvers.solvers import solve\n    from sympy.polys.polyerrors import NotAlgebraic\n    from sympy.polys.numberfields import minimal_polynomial\n\n    other = sympify(other)\n\n    if not isinstance(other, Expr):\n        return False\n\n    if self == other:\n        return True\n\n    # they aren't the same so see if we can make the difference 0;\n    # don't worry about doing simplification steps one at a time\n    # because if the expression ever goes to 0 then the subsequent\n    # simplification steps that are done will be very fast.\n    diff = factor_terms(simplify(self - other), radical=True)\n\n    if not diff:\n        return True\n\n    if not diff.has(Add, Mod):\n        # if there is no expanding to be done after simplifying\n        # then this can't be a zero\n        return False\n\n    factors = diff.as_coeff_mul()[1]\n    if len(factors) > 1:  # avoid infinity recursion\n        fac_zero = [fac.equals(0) for fac in factors]\n        if None not in fac_zero:  # every part can be decided\n            return any(fac_zero)\n\n    constant = diff.is_constant(simplify=False, failing_number=True)\n\n    if constant is False:\n        return False\n\n    if not diff.is_number:\n        if constant is None:\n            # e.g. unless the right simplification is done, a symbolic\n            # zero is possible (see expression of issue 6829: without\n            # simplification constant will be None).\n            return\n\n    if constant is True:\n        # this gives a number whether there are free symbols or not\n        ndiff = diff._random()\n        # is_comparable will work whether the result is real\n        # or complex; it could be None, however.\n        if ndiff and ndiff.is_comparable:\n            return False\n\n    # sometimes we can use a simplified result to give a clue as to\n    # what the expression should be; if the expression is *not* zero\n    # then we should have been able to compute that and so now\n    # we can just consider the cases where the approximation appears\n    # to be zero -- we try to prove it via minimal_polynomial.\n    #\n    # removed\n    # ns = nsimplify(diff)\n    # if diff.is_number and (not ns or ns == diff):\n    #\n    # The thought was that if it nsimplifies to 0 that's a sure sign\n    # to try the following to prove it; or if it changed but wasn't\n    # zero that might be a sign that it's not going to be easy to\n    # prove. But tests seem to be working without that logic.\n    #\n    if diff.is_number:\n        # try to prove via self-consistency\n        surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n        # it seems to work better to try big ones first\n        surds.sort(key=lambda x: -x.args[0])\n        for s in surds:\n            try:\n                # simplify is False here -- this expression has already\n                # been identified as being hard to identify as zero;\n                # we will handle the checking ourselves using nsimplify\n                # to see if we are in the right ballpark or not and if so\n                # *then* the simplification will be attempted.\n                sol = solve(diff, s, simplify=False)\n                if sol:\n                    if s in sol:\n                        # the self-consistent result is present\n                        return True\n                    if all(si.is_Integer for si in sol):\n                        # perfect powers are removed at instantiation\n                        # so surd s cannot be an integer\n                        return False\n                    if all(i.is_algebraic is False for i in sol):\n                        # a surd is algebraic\n                        return False\n                    if any(si in surds for si in sol):\n                        # it wasn't equal to s but it is in surds\n                        # and different surds are not equal\n                        return False\n                    if any(nsimplify(s - si) == 0 and\n                            simplify(s - si) == 0 for si in sol):\n                        return True\n                    if s.is_real:\n                        if any(nsimplify(si, [s]) == s and simplify(si) == s\n                                for si in sol):\n                            return True\n            except NotImplementedError:\n                pass\n\n        # try to prove with minimal_polynomial but know when\n        # *not* to use this or else it can take a long time. e.g. issue 8354\n        if True:  # change True to condition that assures non-hang\n            try:\n                mp = minimal_polynomial(diff)\n                if mp.is_Symbol:\n                    return True\n                return False\n            except (NotAlgebraic, NotImplementedError):\n                pass\n\n    # diff has not simplified to zero; constant is either None, True\n    # or the number with significance (is_comparable) that was randomly\n    # calculated twice as the same value.\n    if constant not in (True, None) and constant != 0:\n        return False\n\n    if failing_expression:\n        return diff\n    return None",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.ntheory.primetest.isprime": "def isprime(n):\n    \"\"\"\n    Test if n is a prime number (True) or not (False). For n < 2^64 the\n    answer is definitive; larger n values have a small probability of actually\n    being pseudoprimes.\n\n    Negative numbers (e.g. -2) are not considered prime.\n\n    The first step is looking for trivial factors, which if found enables\n    a quick return.  Next, if the sieve is large enough, use bisection search\n    on the sieve.  For small numbers, a set of deterministic Miller-Rabin\n    tests are performed with bases that are known to have no counterexamples\n    in their range.  Finally if the number is larger than 2^64, a strong\n    BPSW test is performed.  While this is a probable prime test and we\n    believe counterexamples exist, there are no known counterexamples.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import isprime\n    >>> isprime(13)\n    True\n    >>> isprime(15)\n    False\n\n    Notes\n    =====\n\n    This routine is intended only for integer input, not numerical\n    expressions which may represent numbers. Floats are also\n    rejected as input because they represent numbers of limited\n    precision. While it is tempting to permit 7.0 to represent an\n    integer there are errors that may \"pass silently\" if this is\n    allowed:\n\n    >>> from sympy import Float, S\n    >>> int(1e3) == 1e3 == 10**3\n    True\n    >>> int(1e23) == 1e23\n    True\n    >>> int(1e23) == 10**23\n    False\n\n    >>> near_int = 1 + S(1)/10**19\n    >>> near_int == int(near_int)\n    False\n    >>> n = Float(near_int, 10)  # truncated by precision\n    >>> n % 1 == 0\n    True\n    >>> n = Float(near_int, 20)\n    >>> n % 1 == 0\n    False\n\n    See Also\n    ========\n\n    sympy.ntheory.generate.primerange : Generates all primes in a given range\n    sympy.functions.combinatorial.numbers.primepi : Return the number of primes less than or equal to n\n    sympy.ntheory.generate.prime : Return the nth prime\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Strong_pseudoprime\n    .. [2] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [3] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n    \"\"\"\n    n = as_int(n)\n\n    # Step 1, do quick composite testing via trial division.  The individual\n    # modulo tests benchmark faster than one or two primorial igcds for me.\n    # The point here is just to speedily handle small numbers and many\n    # composites.  Step 2 only requires that n <= 2 get handled here.\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or (n % 2) == 0 or (n % 3) == 0 or (n % 5) == 0:\n        return False\n    if n < 49:\n        return True\n    if (n %  7) == 0 or (n % 11) == 0 or (n % 13) == 0 or (n % 17) == 0 or \\\n       (n % 19) == 0 or (n % 23) == 0 or (n % 29) == 0 or (n % 31) == 0 or \\\n       (n % 37) == 0 or (n % 41) == 0 or (n % 43) == 0 or (n % 47) == 0:\n        return False\n    if n < 2809:\n        return True\n    if n < 65077:\n        # There are only five Euler pseudoprimes with a least prime factor greater than 47\n        return pow(2, n >> 1, n) in [1, n - 1] and n not in [8321, 31621, 42799, 49141, 49981]\n\n    # bisection search on the sieve if the sieve is large enough\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.ntheory.factor_ import factor_cache\n    if (ret := factor_cache.get(n)) is not None:\n        return ret == n\n\n    # If we have GMPY2, skip straight to step 3 and do a strong BPSW test.\n    # This should be a bit faster than our step 2, and for large values will\n    # be a lot faster than our step 3 (C+GMP vs. Python).\n    if _gmpy is not None:\n        return is_strong_bpsw_prp(n)\n\n\n    # Step 2: deterministic Miller-Rabin testing for numbers < 2^64.  See:\n    #    https://miller-rabin.appspot.com/\n    # for lists.  We have made sure the M-R routine will successfully handle\n    # bases larger than n, so we can use the minimal set.\n    # In September 2015 deterministic numbers were extended to over 2^81.\n    #    https://arxiv.org/pdf/1509.00864.pdf\n    #    https://oeis.org/A014233\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 4296595241:\n        # Michal Forisek and Jakub Jancina,\n        # Fast Primality Testing for Integers That Fit into a Machine Word\n        # https://ceur-ws.org/Vol-1326/020-Forisek.pdf\n        h = ((n >> 16) ^ n) * 0x45d9f3b\n        h = ((h >> 16) ^ h) * 0x45d9f3b\n        h = ((h >> 16) ^ h) & 255\n        return mr(n, [_MR_BASES_32[h]])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    if n < 318665857834031151167461:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37])\n    if n < 3317044064679887385961981:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])\n\n    # We could do this instead at any point:\n    #if n < 18446744073709551616:\n    #   return mr(n, [2]) and is_extra_strong_lucas_prp(n)\n\n    # Here are tests that are safe for MR routines that don't understand\n    # large bases.\n    #if n < 9080191:\n    #    return mr(n, [31, 73])\n    #if n < 19471033:\n    #    return mr(n, [2, 299417])\n    #if n < 38010307:\n    #    return mr(n, [2, 9332593])\n    #if n < 316349281:\n    #    return mr(n, [11000544, 31481107])\n    #if n < 4759123141:\n    #    return mr(n, [2, 7, 61])\n    #if n < 105936894253:\n    #    return mr(n, [2, 1005905886, 1340600841])\n    #if n < 31858317218647:\n    #    return mr(n, [2, 642735, 553174392, 3046413974])\n    #if n < 3071837692357849:\n    #    return mr(n, [2, 75088, 642735, 203659041, 3613982119])\n    #if n < 18446744073709551616:\n    #    return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n\n    # Step 3: BPSW.\n    #\n    #  Time for isprime(10**2000 + 4561), no gmpy or gmpy2 installed\n    #     44.0s   old isprime using 46 bases\n    #      5.3s   strong BPSW + one random base\n    #      4.3s   extra strong BPSW + one random base\n    #      4.1s   strong BPSW\n    #      3.2s   extra strong BPSW\n\n    # Classic BPSW from page 1401 of the paper.  See alternate ideas below.\n    return is_strong_bpsw_prp(n)"
}