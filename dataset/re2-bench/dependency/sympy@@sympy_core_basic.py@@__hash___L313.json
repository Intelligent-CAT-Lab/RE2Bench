{
    "sympy.sympy.assumptions.assume._hashable_content": "def _hashable_content(self):\n    return (self.name,)",
    "sympy.sympy.codegen.ast._hashable_content": "def _hashable_content(self):\n    return ()",
    "sympy.sympy.codegen.ast.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.combinatorics.permutations._hashable_content": "def _hashable_content(self):\n    # the array_form (a list) is the Permutation arg, so we need to\n    # return a tuple, instead\n    return tuple(self.array_form)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic._hashable_content": "def _hashable_content(self) -> tuple[Hashable, ...]:\n    \"\"\"Return a tuple of information about self that can be used to\n    compute the hash. If a class defines additional attributes,\n    like ``name`` in Symbol, then this method should be updated\n    accordingly to return such relevant attributes.\n\n    Defining more than _hashable_content is necessary if __eq__ has\n    been defined by a class. See note about this in Basic.__eq__.\"\"\"\n    return self._args",
    "sympy.sympy.core.containers.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.core.expr._hashable_content": "def _hashable_content(self) -> tuple[Basic, ...] | tuple[Hashable, ...]:\n    \"\"\"Return a tuple of information about self that can be used to\n    compute the hash. If a class defines additional attributes,\n    like ``name`` in Symbol, then this method should be updated\n    accordingly to return such relevant attributes.\n    Defining more than _hashable_content is necessary if __eq__ has\n    been defined by a class. See note about this in Basic.__eq__.\"\"\"\n    return self._args",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return hash((self.class_key(), frozenset(self._kwargs.items())))",
    "sympy.sympy.core.function._hashable_content": "def _hashable_content(self):\n    return (self._expr.xreplace(self.canonical_variables),\n        ) + tuple(ordered([(v, p) for v, p in\n        zip(self.variables, self.point) if not self.expr.has(v)]))",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.numbers._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    "sympy.sympy.core.symbol._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + (self.exclude, self.properties)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.diffgeom.diffgeom._hashable_content": "def _hashable_content(self):\n    return (\n        self.coord_sys, self.index\n    ) + tuple(sorted(self.assumptions0.items()))",
    "sympy.sympy.geometry.point.__hash__": "def __hash__(self):\n    return hash(self.args)",
    "sympy.sympy.geometry.polygon._hashable_content": "def _hashable_content(self):\n\n    D = {}\n    def ref_list(point_list):\n        kee = {}\n        for i, p in enumerate(ordered(set(point_list))):\n            kee[p] = i\n            D[i] = p\n        return [kee[p] for p in point_list]\n\n    S1 = ref_list(self.args)\n    r_nor = rotate_left(S1, least_rotation(S1))\n    S2 = ref_list(list(reversed(self.args)))\n    r_rev = rotate_left(S2, least_rotation(S2))\n    if r_nor < r_rev:\n        r = r_nor\n    else:\n        r = r_rev\n    canonical_args = [ D[order] for order in r ]\n    return tuple(canonical_args)",
    "sympy.sympy.logic.boolalg.__hash__": "def __hash__(self):\n    return hash(False)",
    "sympy.sympy.matrices.immutable.__hash__": "def __hash__(self):\n    return MatrixExpr.__hash__(self)",
    "sympy.sympy.physics.paulialgebra._hashable_content": "def _hashable_content(self):\n    return (self.i, self.label)",
    "sympy.sympy.physics.quantum.grover._hashable_content": "def _hashable_content(self):\n    return type(self), self.function",
    "sympy.sympy.physics.quantum.trace._hashable_content": "def _hashable_content(self):\n    if isinstance(self.args[0], Mul):\n        args = _cycle_permute(_rearrange_args(self.args[0].args))\n    else:\n        args = [self.args[0]]\n\n    return tuple(args) + (self.args[1], )",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.polyclasses.__hash__": "def __hash__(f) -> int:\n    return hash((f.__class__.__name__, f.to_tuple(), f.lev, f.dom))",
    "sympy.sympy.polys.polytools._hashable_content": "def _hashable_content(self):\n    \"\"\"Allow SymPy to hash Poly instances. \"\"\"\n    return (self.rep,)",
    "sympy.sympy.polys.polytools.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.polys.rootoftools._hashable_content": "def _hashable_content(self):\n    return (self.poly, self.index)",
    "sympy.sympy.sets.fancysets.__hash__": "def __hash__(self):\n    return hash(Interval(S.NegativeInfinity, S.Infinity))",
    "sympy.sympy.sets.sets.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.simplify.hyperexpand._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + (self.ap,\n            self.bq)",
    "sympy.sympy.tensor.array.ndim_array.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.tensor.indexed._hashable_content": "def _hashable_content(self):\n    return super()._hashable_content() + tuple(sorted(self.assumptions0.items()))",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1",
    "sympy.sympy.vector.basisdependent.__hash__": "def __hash__(self):\n    return self._hash"
}