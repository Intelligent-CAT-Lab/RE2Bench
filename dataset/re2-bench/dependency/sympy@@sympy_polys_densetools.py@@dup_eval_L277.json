{
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.external.pythonmpq.__add__": "def __add__(self, other):\n    \"\"\"q1 + q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        #\n        # This is much faster than the naive method used in the stdlib\n        # fractions module. Not sure where this method comes from\n        # though...\n        #\n        # Compare timings for something like:\n        #   nums = range(1000)\n        #   rats = [PythonMPQ(n, d) for n, d in zip(nums[:-5], nums[5:])]\n        #   sum(rats) # <-- time this\n        #\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq + aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 + bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__mul__": "def __mul__(self, other):\n    \"\"\"q1 * q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = ((ap//x1)*(bp//x2), (aq//x2)*(bq//x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator*(other//x)\n        q = self.denominator//x\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.polys.densebasic.dup_TC": "def dup_TC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the trailing coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_TC\n\n    >>> dup_TC([1, 2, 3], ZZ)\n    3\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[-1]",
    "sympy.sympy.polys.domains.domain.convert": "def convert(self,\n            element: Es | Expr | complex,\n            base: Domain[Es] | None = None\n            ) -> Er:\n    \"\"\"Convert ``element`` to ``self.dtype``. \"\"\"\n\n    if base is not None:\n        if _not_a_coeff(element):\n            raise CoercionFailed('%s is not in any domain' % element)\n        return self.convert_from(element, base) # type: ignore\n\n    if self.of_type(element):\n        return element\n\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ) # type: ignore\n\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n\n    if GROUND_TYPES != 'python':\n        if isinstance(element, ZZ.tp):\n            return self.convert_from(element, ZZ) # type: ignore\n        if isinstance(element, QQ.tp):\n            return self.convert_from(element, QQ) # type: ignore\n\n    if isinstance(element, float):\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if isinstance(element, complex):\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if type(element).__name__ == 'mpf':\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if type(element).__name__ == 'mpc':\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n\n    # TODO: implement this in from_ methods\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC()) # type: ignore\n\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    else: # TODO: remove this branch\n        if not is_sequence(element):\n            try:\n                element = sympify(element, strict=True) # type: ignore\n                if isinstance(element, Basic):\n                    return self.from_sympy(element) # type: ignore\n            except (TypeError, ValueError):\n                pass\n\n    raise CoercionFailed(\"Cannot convert %s of type %s to %s\" % (element, type(element), self))",
    "sympy.sympy.polys.domains.expressiondomain.__mul__": "def __mul__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n\n    if EX.zero in (f, g):\n        return EX.zero\n    elif f.ex.is_Number and g.ex.is_Number:\n        return f.__class__(f.ex*g.ex)\n\n    return f.simplify(f.ex*g.ex)",
    "sympy.sympy.polys.domains.expressiondomain.__bool__": "def __bool__(f):\n    return not f.ex.is_zero",
    "sympy.sympy.polys.domains.expressiondomain.__add__": "def __add__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n    elif g == EX.zero:\n        return f\n    elif f == EX.zero:\n        return g\n    else:\n        return f.simplify(f.ex + g.ex)",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.gaussiandomains.__mul__": "def __mul__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x*x - self.y*y, self.x*y + self.y*x)",
    "sympy.sympy.polys.domains.gaussiandomains.__bool__": "def __bool__(self) -> bool:\n    return bool(self.x) or bool(self.y)",
    "sympy.sympy.polys.domains.gaussiandomains.__add__": "def __add__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x + x, self.y + y)",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.fields.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    "sympy.sympy.polys.fields.__add__": "def __add__(f, g):\n    \"\"\"Add rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not g:\n        return f\n    elif not f:\n        return g\n    elif field.is_element(g):\n        if f.denom == g.denom:\n            return f.new(f.numer + g.numer, f.denom)\n        else:\n            return f.new(f.numer*g.denom + f.denom*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer + f.denom*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__radd__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__radd__(f)\n\n    return f.__radd__(g)",
    "sympy.sympy.polys.fields.__mul__": "def __mul__(f, g):\n    \"\"\"Multiply rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not f or not g:\n        return field.zero\n    elif field.is_element(g):\n        return f.new(f.numer*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__rmul__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__rmul__(f)\n\n    return f.__rmul__(g)",
    "sympy.sympy.polys.polyclasses.__add__": "def __add__(f, g):\n    if isinstance(g, ANP):\n        return f.add(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.add_ground(g)",
    "sympy.sympy.polys.polyclasses.__mul__": "def __mul__(f, g):\n    if isinstance(g, ANP):\n        return f.mul(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.mul_ground(g)",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)",
    "sympy.sympy.polys.rings.__add__": "def __add__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Add two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> (x + y)**2 + (x - y)**2\n    2*x**2 + 2*y**2\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._add(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._add_ground(self)\n\n    res = self._try_add_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_add_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.polys.rings.__mul__": "def __mul__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Multiply two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', QQ)\n    >>> p1 = x + y\n    >>> p2 = x - y\n    >>> p1*p2\n    x**2 - y**2\n\n    \"\"\"\n    if not self or not other:\n        return self.ring.zero\n\n    if self.ring.is_element(other):\n        return self._mul(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other).mul_ground(self)\n\n    res = self._try_mul_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_mul_ground(self)\n\n    return NotImplemented"
}