{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.logic.fuzzy_not": "def fuzzy_not(v):\n    \"\"\"\n    Not in fuzzy logic\n\n    Return None if `v` is None else `not v`.\n\n    Examples\n    ========\n\n    >>> from sympy.core.logic import fuzzy_not\n    >>> fuzzy_not(True)\n    False\n    >>> fuzzy_not(None)\n    >>> fuzzy_not(False)\n    True\n\n    \"\"\"\n    if v is None:\n        return v\n    else:\n        return not v",
    "sympy.sympy.functions.elementary.trigonometric._pi_coeff": "def _pi_coeff(arg: Expr, cycles: int = 1) -> Expr | None:\n    r\"\"\"\n    When arg is a Number times $\\pi$ (e.g. $3\\pi/2$) then return the Number\n    normalized to be in the range $[0, 2]$, else `None`.\n\n    When an even multiple of $\\pi$ is encountered, if it is multiplying\n    something with known parity then the multiple is returned as 0 otherwise\n    as 2.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.elementary.trigonometric import _pi_coeff\n    >>> from sympy import pi, Dummy\n    >>> from sympy.abc import x\n    >>> _pi_coeff(3*x*pi)\n    3*x\n    >>> _pi_coeff(11*pi/7)\n    11/7\n    >>> _pi_coeff(-11*pi/7)\n    3/7\n    >>> _pi_coeff(4*pi)\n    0\n    >>> _pi_coeff(5*pi)\n    1\n    >>> _pi_coeff(5.0*pi)\n    1\n    >>> _pi_coeff(5.5*pi)\n    3/2\n    >>> _pi_coeff(2 + pi)\n\n    >>> _pi_coeff(2*Dummy(integer=True)*pi)\n    2\n    >>> _pi_coeff(2*Dummy(even=True)*pi)\n    0\n\n    \"\"\"\n    if arg is pi:\n        return S.One\n    elif not arg:\n        return S.Zero\n    elif arg.is_Mul:\n        cx = arg.coeff(pi)\n        if cx:\n            c, x = cx.as_coeff_Mul()  # pi is not included as coeff\n            if c.is_Float:\n                # recast exact binary fractions to Rationals\n                f = abs(c) % 1\n                if f != 0:\n                    p = -int(round(log(f, 2).evalf()))\n                    m = 2**p\n                    cm = c*m\n                    i = int(cm)\n                    if equal_valued(i, cm):\n                        c = Rational(i, m)\n                        cx = c*x\n                else:\n                    c = Rational(int(c))\n                    cx = c*x\n            if x.is_integer:\n                c2 = c % 2\n                if c2 == 1:\n                    return x\n                elif not c2:\n                    if x.is_even is not None:  # known parity\n                        return S.Zero\n                    return Integer(2)\n                else:\n                    return c2*x\n            return cx\n    elif arg.is_zero:\n        return S.Zero\n    return None"
}