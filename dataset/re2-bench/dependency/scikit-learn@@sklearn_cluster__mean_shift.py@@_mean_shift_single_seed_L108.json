{
    "scikit-learn.sklearn.base.get_params": "def get_params(self, deep=True):\n    \"\"\"\n    Get parameters for this estimator.\n\n    Parameters\n    ----------\n    deep : bool, default=True\n        If True, will return the parameters for this estimator and\n        contained subobjects that are estimators.\n\n    Returns\n    -------\n    params : dict\n        Parameter names mapped to their values.\n    \"\"\"\n    out = dict()\n    for key in self._get_param_names():\n        value = getattr(self, key)\n        if deep and hasattr(value, \"get_params\") and not isinstance(value, type):\n            deep_items = value.get_params().items()\n            out.update((key + \"__\" + k, val) for k, val in deep_items)\n        out[key] = value\n    return out",
    "scikit-learn.sklearn.neighbors._base.radius_neighbors": "def radius_neighbors(\n    self, X=None, radius=None, return_distance=True, sort_results=False\n):\n    \"\"\"Find the neighbors within a given radius of a point or points.\n\n    Return the indices and distances of each point from the dataset\n    lying in a ball with size ``radius`` around the points of the query\n    array. Points lying on the boundary are included in the results.\n\n    The result points are *not* necessarily sorted by distance to their\n    query point.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of (n_samples, n_features), default=None\n        The query point or points.\n        If not provided, neighbors of each indexed point are returned.\n        In this case, the query point is not considered its own neighbor.\n\n    radius : float, default=None\n        Limiting distance of neighbors to return. The default is the value\n        passed to the constructor.\n\n    return_distance : bool, default=True\n        Whether or not to return the distances.\n\n    sort_results : bool, default=False\n        If True, the distances and indices will be sorted by increasing\n        distances before being returned. If False, the results may not\n        be sorted. If `return_distance=False`, setting `sort_results=True`\n        will result in an error.\n\n        .. versionadded:: 0.22\n\n    Returns\n    -------\n    neigh_dist : ndarray of shape (n_samples,) of arrays\n        Array representing the distances to each point, only present if\n        `return_distance=True`. The distance values are computed according\n        to the ``metric`` constructor parameter.\n\n    neigh_ind : ndarray of shape (n_samples,) of arrays\n        An array of arrays of indices of the approximate nearest points\n        from the population matrix that lie within a ball of size\n        ``radius`` around the query points.\n\n    Notes\n    -----\n    Because the number of neighbors of each point is not necessarily\n    equal, the results for multiple query points cannot be fit in a\n    standard data array.\n    For efficiency, `radius_neighbors` returns arrays of objects, where\n    each object is a 1D array of indices or distances.\n\n    Examples\n    --------\n    In the following example, we construct a NeighborsClassifier\n    class from an array representing our data set and ask who's\n    the closest point to [1, 1, 1]:\n\n    >>> import numpy as np\n    >>> samples = [[0., 0., 0.], [0., .5, 0.], [1., 1., .5]]\n    >>> from sklearn.neighbors import NearestNeighbors\n    >>> neigh = NearestNeighbors(radius=1.6)\n    >>> neigh.fit(samples)\n    NearestNeighbors(radius=1.6)\n    >>> rng = neigh.radius_neighbors([[1., 1., 1.]])\n    >>> print(np.asarray(rng[0][0]))\n    [1.5 0.5]\n    >>> print(np.asarray(rng[1][0]))\n    [1 2]\n\n    The first array returned contains the distances to all points which\n    are closer than 1.6, while the second array returned contains their\n    indices.  In general, multiple points can be queried at the same time.\n    \"\"\"\n    check_is_fitted(self)\n\n    if sort_results and not return_distance:\n        raise ValueError(\"return_distance must be True if sort_results is True.\")\n\n    ensure_all_finite = \"allow-nan\" if get_tags(self).input_tags.allow_nan else True\n    query_is_train = X is None\n    if query_is_train:\n        X = self._fit_X\n    else:\n        if self.metric == \"precomputed\":\n            X = _check_precomputed(X)\n        else:\n            X = validate_data(\n                self,\n                X,\n                ensure_all_finite=ensure_all_finite,\n                accept_sparse=\"csr\",\n                reset=False,\n                order=\"C\",\n            )\n\n    if radius is None:\n        radius = self.radius\n\n    use_pairwise_distances_reductions = (\n        self._fit_method == \"brute\"\n        and RadiusNeighbors.is_usable_for(\n            X if X is not None else self._fit_X, self._fit_X, self.effective_metric_\n        )\n    )\n\n    if use_pairwise_distances_reductions:\n        results = RadiusNeighbors.compute(\n            X=X,\n            Y=self._fit_X,\n            radius=radius,\n            metric=self.effective_metric_,\n            metric_kwargs=self.effective_metric_params_,\n            strategy=\"auto\",\n            return_distance=return_distance,\n            sort_results=sort_results,\n        )\n\n    elif (\n        self._fit_method == \"brute\" and self.metric == \"precomputed\" and issparse(X)\n    ):\n        results = _radius_neighbors_from_graph(\n            X, radius=radius, return_distance=return_distance\n        )\n\n    elif self._fit_method == \"brute\":\n        # Joblib-based backend, which is used when user-defined callable\n        # are passed for metric.\n\n        # This won't be used in the future once PairwiseDistancesReductions\n        # support:\n        #   - DistanceMetrics which work on supposedly binary data\n        #   - CSR-dense and dense-CSR case if 'euclidean' in metric.\n\n        # for efficiency, use squared euclidean distances\n        if self.effective_metric_ == \"euclidean\":\n            radius *= radius\n            kwds = {\"squared\": True}\n        else:\n            kwds = self.effective_metric_params_\n\n        reduce_func = partial(\n            self._radius_neighbors_reduce_func,\n            radius=radius,\n            return_distance=return_distance,\n        )\n\n        chunked_results = pairwise_distances_chunked(\n            X,\n            self._fit_X,\n            reduce_func=reduce_func,\n            metric=self.effective_metric_,\n            n_jobs=self.n_jobs,\n            **kwds,\n        )\n        if return_distance:\n            neigh_dist_chunks, neigh_ind_chunks = zip(*chunked_results)\n            neigh_dist_list = list(itertools.chain.from_iterable(neigh_dist_chunks))\n            neigh_ind_list = list(itertools.chain.from_iterable(neigh_ind_chunks))\n            neigh_dist = _to_object_array(neigh_dist_list)\n            neigh_ind = _to_object_array(neigh_ind_list)\n            results = neigh_dist, neigh_ind\n        else:\n            neigh_ind_list = list(itertools.chain.from_iterable(chunked_results))\n            results = _to_object_array(neigh_ind_list)\n\n        if sort_results:\n            for ii in range(len(neigh_dist)):\n                order = np.argsort(neigh_dist[ii], kind=\"mergesort\")\n                neigh_ind[ii] = neigh_ind[ii][order]\n                neigh_dist[ii] = neigh_dist[ii][order]\n            results = neigh_dist, neigh_ind\n\n    elif self._fit_method in [\"ball_tree\", \"kd_tree\"]:\n        if issparse(X):\n            raise ValueError(\n                \"%s does not work with sparse matrices. Densify the data, \"\n                \"or set algorithm='brute'\" % self._fit_method\n            )\n\n        n_jobs = effective_n_jobs(self.n_jobs)\n        delayed_query = delayed(self._tree.query_radius)\n        chunked_results = Parallel(n_jobs, prefer=\"threads\")(\n            delayed_query(X[s], radius, return_distance, sort_results=sort_results)\n            for s in gen_even_slices(X.shape[0], n_jobs)\n        )\n        if return_distance:\n            neigh_ind, neigh_dist = tuple(zip(*chunked_results))\n            results = np.hstack(neigh_dist), np.hstack(neigh_ind)\n        else:\n            results = np.hstack(chunked_results)\n    else:\n        raise ValueError(\"internal: _fit_method not recognized\")\n\n    if not query_is_train:\n        return results\n    else:\n        # If the query data is the same as the indexed data, we would like\n        # to ignore the first nearest neighbor of every sample, i.e\n        # the sample itself.\n        if return_distance:\n            neigh_dist, neigh_ind = results\n        else:\n            neigh_ind = results\n\n        for ind, ind_neighbor in enumerate(neigh_ind):\n            mask = ind_neighbor != ind\n\n            neigh_ind[ind] = ind_neighbor[mask]\n            if return_distance:\n                neigh_dist[ind] = neigh_dist[ind][mask]\n\n        if return_distance:\n            return neigh_dist, neigh_ind\n        return neigh_ind"
}