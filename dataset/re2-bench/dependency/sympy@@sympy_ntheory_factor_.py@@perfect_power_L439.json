{
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.numbers.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.external.ntheory.bit_scan1": "def bit_scan1(x, n=0):\n    if not x:\n        return\n    x = abs(x >> n)\n    low_byte = x & 0xFF\n    if low_byte:\n        return _small_trailing[low_byte] + n\n\n    t = 8 + n\n    x >>= 8\n    # 2**m is quick for z up through 2**30\n    z = x.bit_length() - 1\n    if x == 1 << z:\n        return z + t\n\n    if z < 300:\n        # fixed 8-byte reduction\n        while not x & 0xFF:\n            x >>= 8\n            t += 8\n    else:\n        # binary reduction important when there might be a large\n        # number of trailing 0s\n        p = z >> 1\n        while not x & 0xFF:\n            while x & ((1 << p) - 1):\n                p >>= 1\n            x >>= p\n            t += p\n    return t + _small_trailing[x & 0xFF]",
    "sympy.sympy.external.ntheory.iroot": "def iroot(y, n):\n    if y < 0:\n        raise ValueError(\"y must be nonnegative\")\n    if n < 1:\n        raise ValueError(\"n must be positive\")\n    if y in (0, 1):\n        return y, True\n    if n == 1:\n        return y, True\n    if n == 2:\n        x, rem = mlib.sqrtrem(y)\n        return int(x), not rem\n    if n >= y.bit_length():\n        return 1, False\n    # Get initial estimate for Newton's method. Care must be taken to\n    # avoid overflow\n    try:\n        guess = int(y**(1./n) + 0.5)\n    except OverflowError:\n        exp = math.log2(y)/n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0**(exp - shift) + 1) << shift\n        else:\n            guess = int(2.0**exp)\n    if guess > 2**50:\n        # Newton iteration\n        xprev, x = -1, guess\n        while 1:\n            t = x**(n - 1)\n            xprev, x = x, ((n - 1)*x + y//t)//n\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    # Compensate\n    t = x**n\n    while t < y:\n        x += 1\n        t = x**n\n    while t > y:\n        x -= 1\n        t = x**n\n    return x, t == y",
    "sympy.sympy.external.ntheory.remove": "def remove(x, f):\n    if f < 2:\n        raise ValueError(\"factor must be > 1\")\n    if x == 0:\n        return 0, 0\n    if f == 2:\n        b = bit_scan1(x)\n        return x >> b, b\n    m = 0\n    y, rem = divmod(x, f)\n    while not rem:\n        x = y\n        m += 1\n        if m > 5:\n            pow_list = [f**2]\n            while pow_list:\n                _f = pow_list[-1]\n                y, rem = divmod(x, _f)\n                if not rem:\n                    m += 1 << len(pow_list)\n                    x = y\n                    pow_list.append(_f**2)\n                else:\n                    pow_list.pop()\n        y, rem = divmod(x, f)\n    return x, m",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.ntheory.factor_.primefactors": "def primefactors(n, limit=None, verbose=False, **kwargs):\n    \"\"\"Return a sorted list of n's prime factors, ignoring multiplicity\n    and any composite factor that remains if the limit was set too low\n    for complete factorization. Unlike factorint(), primefactors() does\n    not return -1 or 0.\n\n    Parameters\n    ==========\n\n    n : integer\n    limit, verbose, **kwargs :\n        Additional keyword arguments to be passed to ``factorint``.\n        Since ``kwargs`` is new in version 1.13,\n        ``limit`` and ``verbose`` are retained for compatibility purposes.\n\n    Returns\n    =======\n\n    list(int) : List of prime numbers dividing ``n``\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import primefactors, factorint, isprime\n    >>> primefactors(6)\n    [2, 3]\n    >>> primefactors(-5)\n    [5]\n\n    >>> sorted(factorint(123456).items())\n    [(2, 6), (3, 1), (643, 1)]\n    >>> primefactors(123456)\n    [2, 3, 643]\n\n    >>> sorted(factorint(10000000001, limit=200).items())\n    [(101, 1), (99009901, 1)]\n    >>> isprime(99009901)\n    False\n    >>> primefactors(10000000001, limit=300)\n    [101]\n\n    See Also\n    ========\n\n    factorint, divisors\n\n    \"\"\"\n    n = int(n)\n    kwargs.update({\"visual\": None, \"multiple\": False,\n                   \"limit\": limit, \"verbose\": verbose})\n    factors = sorted(factorint(n=n, **kwargs).keys())\n    # We want to calculate\n    # s = [f for f in factors if isprime(f)]\n    s = [f for f in factors[:-1:] if f not in [-1, 0, 1]]\n    if factors and isprime(factors[-1]):\n        s += [factors[-1]]\n    return s",
    "sympy.sympy.ntheory.factor_._divisors": "def _divisors(n, proper=False):\n    \"\"\"Helper function for divisors which generates the divisors.\n\n    Parameters\n    ==========\n\n    n : int\n        a nonnegative integer\n    proper: bool\n        If `True`, returns the generator that outputs only the proper divisor (i.e., excluding n).\n\n    \"\"\"\n    if n <= 1:\n        if not proper and n:\n            yield 1\n        return\n\n    factordict = factorint(n)\n    ps = sorted(factordict.keys())\n\n    def rec_gen(n=0):\n        if n == len(ps):\n            yield 1\n        else:\n            pows = [1]\n            for _ in range(factordict[ps[n]]):\n                pows.append(pows[-1] * ps[n])\n            yield from (p * q for q in rec_gen(n + 1) for p in pows)\n\n    if proper:\n        yield from (p for p in rec_gen() if p != n)\n    else:\n        yield from rec_gen()",
    "sympy.sympy.ntheory.factor_.divisors": "def divisors(n, generator=False, proper=False):\n    r\"\"\"\n    Return all divisors of n sorted from 1..n by default.\n    If generator is ``True`` an unordered generator is returned.\n\n    The number of divisors of n can be quite large if there are many\n    prime factors (counting repeated factors). If only the number of\n    factors is desired use divisor_count(n).\n\n    Examples\n    ========\n\n    >>> from sympy import divisors, divisor_count\n    >>> divisors(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> divisor_count(24)\n    8\n\n    >>> list(divisors(120, generator=True))\n    [1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60, 120]\n\n    Notes\n    =====\n\n    This is a slightly modified version of Tim Peters referenced at:\n    https://stackoverflow.com/questions/1010381/python-factorization\n\n    See Also\n    ========\n\n    primefactors, factorint, divisor_count\n    \"\"\"\n    rv = _divisors(as_int(abs(n)), proper)\n    return rv if generator else sorted(rv)",
    "sympy.sympy.ntheory.factor_._perfect_power": "def _perfect_power(n, next_p=2):\n    \"\"\" Return integers ``(b, e)`` such that ``n == b**e`` if ``n`` is a unique\n    perfect power with ``e > 1``, else ``False`` (e.g. 1 is not a perfect power).\n\n    Explanation\n    ===========\n\n    This is a low-level helper for ``perfect_power``, for internal use.\n\n    Parameters\n    ==========\n\n    n : int\n        assume that n is a nonnegative integer\n    next_p : int\n        Assume that n has no factor less than next_p.\n        i.e., all(n % p for p in range(2, next_p)) is True\n\n    Examples\n    ========\n    >>> from sympy.ntheory.factor_ import _perfect_power\n    >>> _perfect_power(16)\n    (2, 4)\n    >>> _perfect_power(17)\n    False\n\n    \"\"\"\n    if n <= 3:\n        return False\n\n    factors = {}\n    g = 0\n    multi = 1\n\n    def done(n, factors, g, multi):\n        g = gcd(g, multi)\n        if g == 1:\n            return False\n        factors[n] = multi\n        return int(math.prod(p**(e//g) for p, e in factors.items())), int(g)\n\n    # If n is small, only trial factoring is faster\n    if n <= 1_000_000:\n        n = _factorint_small(factors, n, 1_000, 1_000, next_p)[0]\n        if n > 1:\n            return False\n        g = gcd(*factors.values())\n        if g == 1:\n            return False\n        return math.prod(p**(e//g) for p, e in factors.items()), int(g)\n\n    # divide by 2\n    if next_p < 3:\n        g = bit_scan1(n)\n        if g:\n            if g == 1:\n                return False\n            n >>= g\n            factors[2] = g\n            if n == 1:\n                return 2, g\n            else:\n                # If `m**g`, then we have found perfect power.\n                # Otherwise, there is no possibility of perfect power, especially if `g` is prime.\n                m, _exact = iroot(n, g)\n                if _exact:\n                    return int(2*m), g\n                elif isprime(g):\n                    return False\n        next_p = 3\n\n    # square number?\n    while n & 7 == 1: # n % 8 == 1:\n        m, _exact = iroot(n, 2)\n        if _exact:\n            n = m\n            multi <<= 1\n        else:\n            break\n    if n < next_p**3:\n        return done(n, factors, g, multi)\n\n    # trial factoring\n    # Since the maximum value an exponent can take is `log_{next_p}(n)`,\n    # the number of exponents to be checked can be reduced by performing a trial factoring.\n    # The value of `tf_max` needs more consideration.\n    tf_max = n.bit_length()//27 + 24\n    if next_p < tf_max:\n        for p in primerange(next_p, tf_max):\n            m, t = remove(n, p)\n            if t:\n                n = m\n                t *= multi\n                _g = int(gcd(g, t))\n                if _g == 1:\n                    return False\n                factors[p] = t\n                if n == 1:\n                    return int(math.prod(p**(e//_g)\n                                        for p, e in factors.items())), _g\n                elif g == 0 or _g < g: # If g is updated\n                    g = _g\n                    m, _exact = iroot(n**multi, g)\n                    if _exact:\n                        return int(m * math.prod(p**(e//g)\n                                            for p, e in factors.items())), g\n                    elif isprime(g):\n                        return False\n        next_p = tf_max\n    if n < next_p**3:\n        return done(n, factors, g, multi)\n\n    # check iroot\n    if g:\n        # If g is non-zero, the exponent is a divisor of g.\n        # 2 can be omitted since it has already been checked.\n        prime_iter = sorted(factorint(g >> bit_scan1(g)).keys())\n    else:\n        # The maximum possible value of the exponent is `log_{next_p}(n)`.\n        # To compensate for the presence of computational error, 2 is added.\n        prime_iter = primerange(3, int(math.log(n, next_p)) + 2)\n    logn = math.log2(n)\n    threshold = logn / 40 # Threshold for direct calculation\n    for p in prime_iter:\n        if threshold < p:\n            # If p is large, find the power root p directly without `iroot`.\n            while True:\n                b = pow(2, logn / p)\n                rb = int(b + 0.5)\n                if abs(rb - b) < 0.01 and rb**p == n:\n                    n = rb\n                    multi *= p\n                    logn = math.log2(n)\n                else:\n                    break\n        else:\n            while True:\n                m, _exact = iroot(n, p)\n                if _exact:\n                    n = m\n                    multi *= p\n                    logn = math.log2(n)\n                else:\n                    break\n        if n < next_p**(p + 2):\n            break\n    return done(n, factors, g, multi)",
    "sympy.sympy.ntheory.factor_.perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    \"\"\"\n    Return ``(b, e)`` such that ``n`` == ``b**e`` if ``n`` is a unique\n    perfect power with ``e > 1``, else ``False`` (e.g. 1 is not a\n    perfect power). A ValueError is raised if ``n`` is not Rational.\n\n    By default, the base is recursively decomposed and the exponents\n    collected so the largest possible ``e`` is sought. If ``big=False``\n    then the smallest possible ``e`` (thus prime) will be chosen.\n\n    If ``factor=True`` then simultaneous factorization of ``n`` is\n    attempted since finding a factor indicates the only possible root\n    for ``n``. This is True by default since only a few small factors will\n    be tested in the course of searching for the perfect power.\n\n    The use of ``candidates`` is primarily for internal use; if provided,\n    False will be returned if ``n`` cannot be written as a power with one\n    of the candidates as an exponent and factoring (beyond testing for\n    a factor of 2) will not be attempted.\n\n    Examples\n    ========\n\n    >>> from sympy import perfect_power, Rational\n    >>> perfect_power(16)\n    (2, 4)\n    >>> perfect_power(16, big=False)\n    (4, 2)\n\n    Negative numbers can only have odd perfect powers:\n\n    >>> perfect_power(-4)\n    False\n    >>> perfect_power(-8)\n    (-2, 3)\n\n    Rationals are also recognized:\n\n    >>> perfect_power(Rational(1, 2)**3)\n    (1/2, 3)\n    >>> perfect_power(Rational(-3, 2)**3)\n    (-3/2, 3)\n\n    Notes\n    =====\n\n    To know whether an integer is a perfect power of 2 use\n\n        >>> is2pow = lambda n: bool(n and not n & (n - 1))\n        >>> [(i, is2pow(i)) for i in range(5)]\n        [(0, False), (1, True), (2, True), (3, False), (4, True)]\n\n    It is not necessary to provide ``candidates``. When provided\n    it will be assumed that they are ints. The first one that is\n    larger than the computed maximum possible exponent will signal\n    failure for the routine.\n\n        >>> perfect_power(3**8, [9])\n        False\n        >>> perfect_power(3**8, [2, 4, 8])\n        (3, 8)\n        >>> perfect_power(3**8, [4, 8], big=False)\n        (9, 4)\n\n    See Also\n    ========\n    sympy.core.intfunc.integer_nthroot\n    sympy.ntheory.primetest.is_square\n    \"\"\"\n    # negative handling\n    if n < 0:\n        if candidates is None:\n            pp = perfect_power(-n, big=True, factor=factor)\n            if not pp:\n                return False\n\n            b, e = pp\n            e2 = e & (-e)\n            b, e = b ** e2, e // e2\n\n            if e <= 1:\n                return False\n\n            if big or isprime(e):\n                return -b, e\n\n            for p in primerange(3, e + 1):\n                if e % p == 0:\n                    return - b ** (e // p), p\n\n        odd_candidates = {i for i in candidates if i % 2}\n        if not odd_candidates:\n            return False\n\n        pp = perfect_power(-n, odd_candidates, big, factor)\n        if pp:\n            return -pp[0], pp[1]\n\n        return False\n\n    # non-integer handling\n    if isinstance(n, Rational) and not isinstance(n, Integer):\n        p, q = n.p, n.q\n\n        if p == 1:\n            qq = perfect_power(q, candidates, big, factor)\n            return (S.One / qq[0], qq[1]) if qq is not False else False\n\n        if not (pp:=perfect_power(p, factor=factor)):\n            return False\n        if not (qq:=perfect_power(q, factor=factor)):\n            return False\n        (num_base, num_exp), (den_base, den_exp) = pp, qq\n\n        def compute_tuple(exponent):\n            \"\"\"Helper to compute final result given an exponent\"\"\"\n            new_num = num_base ** (num_exp // exponent)\n            new_den = den_base ** (den_exp // exponent)\n            return n.func(new_num, new_den), exponent\n\n        if candidates:\n            valid_candidates = [i for i in candidates\n                                if num_exp % i == 0 and den_exp % i == 0]\n            if not valid_candidates:\n                return False\n\n            e = max(valid_candidates) if big else min(valid_candidates)\n            return compute_tuple(e)\n\n        g = math.gcd(num_exp, den_exp)\n        if g == 1:\n            return False\n\n        if big:\n            return compute_tuple(g)\n\n        e = next(p for p in primerange(2, g + 1) if g % p == 0)\n        return compute_tuple(e)\n\n    if candidates is not None:\n        candidates = set(candidates)\n\n    # positive integer handling\n    n = as_int(n)\n\n    if candidates is None and big:\n        return _perfect_power(n)\n\n    if n <= 3:\n        # no unique exponent for 0, 1\n        # 2 and 3 have exponents of 1\n        return False\n    logn = math.log2(n)\n    max_possible = int(logn) + 2  # only check values less than this\n    not_square = n % 10 in [2, 3, 7, 8]  # squares cannot end in 2, 3, 7, 8\n    min_possible = 2 + not_square\n    if not candidates:\n        candidates = primerange(min_possible, max_possible)\n    else:\n        candidates = sorted([i for i in candidates\n            if min_possible <= i < max_possible])\n        if n%2 == 0:\n            e = bit_scan1(n)\n            candidates = [i for i in candidates if e%i == 0]\n        if big:\n            candidates = reversed(candidates)\n        for e in candidates:\n            r, ok = iroot(n, e)\n            if ok:\n                return int(r), e\n        return False\n\n    def _factors():\n        rv = 2 + n % 2\n        while True:\n            yield rv\n            rv = nextprime(rv)\n\n    for fac, e in zip(_factors(), candidates):\n        # see if there is a factor present\n        if factor and n % fac == 0:\n            # find what the potential power is\n            e = remove(n, fac)[1]\n            # if it's a trivial power we are done\n            if e == 1:\n                return False\n\n            # maybe the e-th root of n is exact\n            r, exact = iroot(n, e)\n            if not exact:\n                # Having a factor, we know that e is the maximal\n                # possible value for a root of n.\n                # If n = fac**e*m can be written as a perfect\n                # power then see if m can be written as r**E where\n                # gcd(e, E) != 1 so n = (fac**(e//E)*r)**E\n                m = n//fac**e\n                rE = perfect_power(m, candidates=divisors(e, generator=True))\n                if not rE:\n                    return False\n                else:\n                    r, E = rE\n                    r, e = fac**(e//E)*r, E\n            if not big:\n                e0 = primefactors(e)\n                if e0[0] != e:\n                    r, e = r**(e//e0[0]), e0[0]\n            return int(r), e\n\n        # Weed out downright impossible candidates\n        if logn/e < 40:\n            b = 2.0**(logn/e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n\n        # now see if the plausible e makes a perfect power\n        r, exact = iroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m:\n                    r, e = m[0], e*m[1]\n            return int(r), e\n\n    return False",
    "sympy.sympy.ntheory.factor_.<setcomp>": "odd_candidates = {i for i in candidates if i % 2}\n",
    "sympy.sympy.ntheory.factor_.compute_tuple": "def compute_tuple(exponent):\n    \"\"\"Helper to compute final result given an exponent\"\"\"\n    new_num = num_base ** (num_exp // exponent)\n    new_den = den_base ** (den_exp // exponent)\n    return n.func(new_num, new_den), exponent",
    "sympy.sympy.ntheory.factor_.<listcomp>": "candidates = [i for i in candidates if e%i == 0]\n",
    "sympy.sympy.ntheory.factor_.<genexpr>": "e = next(p for p in primerange(2, g + 1) if g % p == 0)\n",
    "sympy.sympy.ntheory.factor_._factors": "def _factors():\n    rv = 2 + n % 2\n    while True:\n        yield rv\n        rv = nextprime(rv)",
    "sympy.sympy.ntheory.generate.primerange": "def primerange(a, b=None):\n    \"\"\" Generate a list of all prime numbers in the range [2, a),\n        or [a, b).\n\n        If the range exists in the default sieve, the values will\n        be returned from there; otherwise values will be returned\n        but will not modify the sieve.\n\n        Examples\n        ========\n\n        >>> from sympy import primerange, prime\n\n        All primes less than 19:\n\n        >>> list(primerange(19))\n        [2, 3, 5, 7, 11, 13, 17]\n\n        All primes greater than or equal to 7 and less than 19:\n\n        >>> list(primerange(7, 19))\n        [7, 11, 13, 17]\n\n        All primes through the 10th prime\n\n        >>> list(primerange(prime(10) + 1))\n        [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n        The Sieve method, primerange, is generally faster but it will\n        occupy more memory as the sieve stores values. The default\n        instance of Sieve, named sieve, can be used:\n\n        >>> from sympy import sieve\n        >>> list(sieve.primerange(1, 30))\n        [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n        Notes\n        =====\n\n        Some famous conjectures about the occurrence of primes in a given\n        range are [1]:\n\n        - Twin primes: though often not, the following will give 2 primes\n                    an infinite number of times:\n                        primerange(6*n - 1, 6*n + 2)\n        - Legendre's: the following always yields at least one prime\n                        primerange(n**2, (n+1)**2+1)\n        - Bertrand's (proven): there is always a prime in the range\n                        primerange(n, 2*n)\n        - Brocard's: there are at least four primes in the range\n                        primerange(prime(n)**2, prime(n+1)**2)\n\n        The average gap between primes is log(n) [2]; the gap between\n        primes can be arbitrarily large since sequences of composite\n        numbers are arbitrarily large, e.g. the numbers in the sequence\n        n! + 2, n! + 3 ... n! + n are all composite.\n\n        See Also\n        ========\n\n        prime : Return the nth prime\n        nextprime : Return the ith prime greater than n\n        prevprime : Return the largest prime smaller than n\n        randprime : Returns a random prime in a given range\n        primorial : Returns the product of primes based on condition\n        Sieve.primerange : return range from already computed primes\n                           or extend the sieve to contain the requested\n                           range.\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Prime_number\n        .. [2] https://primes.utm.edu/notes/gaps.html\n    \"\"\"\n    if b is None:\n        a, b = 2, a\n    if a >= b:\n        return\n    # If we already have the range, return it.\n    largest_known_prime = sieve._list[-1]\n    if b <= largest_known_prime:\n        yield from sieve.primerange(a, b)\n        return\n    # If we know some of it, return it.\n    if a <= largest_known_prime:\n        yield from sieve._list[bisect_left(sieve._list, a):]\n        a = largest_known_prime + 1\n    elif a % 2:\n        a -= 1\n    tail = min(b, (largest_known_prime)**2)\n    if a < tail:\n        yield from sieve._primerange(a, tail)\n        a = tail\n    if b <= a:\n        return\n    # otherwise compute, without storing, the desired range.\n    while 1:\n        a = nextprime(a)\n        if a < b:\n            yield a\n        else:\n            return",
    "sympy.sympy.ntheory.primetest.isprime": "def isprime(n):\n    \"\"\"\n    Test if n is a prime number (True) or not (False). For n < 2^64 the\n    answer is definitive; larger n values have a small probability of actually\n    being pseudoprimes.\n\n    Negative numbers (e.g. -2) are not considered prime.\n\n    The first step is looking for trivial factors, which if found enables\n    a quick return.  Next, if the sieve is large enough, use bisection search\n    on the sieve.  For small numbers, a set of deterministic Miller-Rabin\n    tests are performed with bases that are known to have no counterexamples\n    in their range.  Finally if the number is larger than 2^64, a strong\n    BPSW test is performed.  While this is a probable prime test and we\n    believe counterexamples exist, there are no known counterexamples.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import isprime\n    >>> isprime(13)\n    True\n    >>> isprime(15)\n    False\n\n    Notes\n    =====\n\n    This routine is intended only for integer input, not numerical\n    expressions which may represent numbers. Floats are also\n    rejected as input because they represent numbers of limited\n    precision. While it is tempting to permit 7.0 to represent an\n    integer there are errors that may \"pass silently\" if this is\n    allowed:\n\n    >>> from sympy import Float, S\n    >>> int(1e3) == 1e3 == 10**3\n    True\n    >>> int(1e23) == 1e23\n    True\n    >>> int(1e23) == 10**23\n    False\n\n    >>> near_int = 1 + S(1)/10**19\n    >>> near_int == int(near_int)\n    False\n    >>> n = Float(near_int, 10)  # truncated by precision\n    >>> n % 1 == 0\n    True\n    >>> n = Float(near_int, 20)\n    >>> n % 1 == 0\n    False\n\n    See Also\n    ========\n\n    sympy.ntheory.generate.primerange : Generates all primes in a given range\n    sympy.functions.combinatorial.numbers.primepi : Return the number of primes less than or equal to n\n    sympy.ntheory.generate.prime : Return the nth prime\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Strong_pseudoprime\n    .. [2] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [3] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n    \"\"\"\n    n = as_int(n)\n\n    # Step 1, do quick composite testing via trial division.  The individual\n    # modulo tests benchmark faster than one or two primorial igcds for me.\n    # The point here is just to speedily handle small numbers and many\n    # composites.  Step 2 only requires that n <= 2 get handled here.\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or (n % 2) == 0 or (n % 3) == 0 or (n % 5) == 0:\n        return False\n    if n < 49:\n        return True\n    if (n %  7) == 0 or (n % 11) == 0 or (n % 13) == 0 or (n % 17) == 0 or \\\n       (n % 19) == 0 or (n % 23) == 0 or (n % 29) == 0 or (n % 31) == 0 or \\\n       (n % 37) == 0 or (n % 41) == 0 or (n % 43) == 0 or (n % 47) == 0:\n        return False\n    if n < 2809:\n        return True\n    if n < 65077:\n        # There are only five Euler pseudoprimes with a least prime factor greater than 47\n        return pow(2, n >> 1, n) in [1, n - 1] and n not in [8321, 31621, 42799, 49141, 49981]\n\n    # bisection search on the sieve if the sieve is large enough\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.ntheory.factor_ import factor_cache\n    if (ret := factor_cache.get(n)) is not None:\n        return ret == n\n\n    # If we have GMPY2, skip straight to step 3 and do a strong BPSW test.\n    # This should be a bit faster than our step 2, and for large values will\n    # be a lot faster than our step 3 (C+GMP vs. Python).\n    if _gmpy is not None:\n        return is_strong_bpsw_prp(n)\n\n\n    # Step 2: deterministic Miller-Rabin testing for numbers < 2^64.  See:\n    #    https://miller-rabin.appspot.com/\n    # for lists.  We have made sure the M-R routine will successfully handle\n    # bases larger than n, so we can use the minimal set.\n    # In September 2015 deterministic numbers were extended to over 2^81.\n    #    https://arxiv.org/pdf/1509.00864.pdf\n    #    https://oeis.org/A014233\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 4296595241:\n        # Michal Forisek and Jakub Jancina,\n        # Fast Primality Testing for Integers That Fit into a Machine Word\n        # https://ceur-ws.org/Vol-1326/020-Forisek.pdf\n        h = ((n >> 16) ^ n) * 0x45d9f3b\n        h = ((h >> 16) ^ h) * 0x45d9f3b\n        h = ((h >> 16) ^ h) & 255\n        return mr(n, [_MR_BASES_32[h]])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    if n < 318665857834031151167461:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37])\n    if n < 3317044064679887385961981:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])\n\n    # We could do this instead at any point:\n    #if n < 18446744073709551616:\n    #   return mr(n, [2]) and is_extra_strong_lucas_prp(n)\n\n    # Here are tests that are safe for MR routines that don't understand\n    # large bases.\n    #if n < 9080191:\n    #    return mr(n, [31, 73])\n    #if n < 19471033:\n    #    return mr(n, [2, 299417])\n    #if n < 38010307:\n    #    return mr(n, [2, 9332593])\n    #if n < 316349281:\n    #    return mr(n, [11000544, 31481107])\n    #if n < 4759123141:\n    #    return mr(n, [2, 7, 61])\n    #if n < 105936894253:\n    #    return mr(n, [2, 1005905886, 1340600841])\n    #if n < 31858317218647:\n    #    return mr(n, [2, 642735, 553174392, 3046413974])\n    #if n < 3071837692357849:\n    #    return mr(n, [2, 75088, 642735, 203659041, 3613982119])\n    #if n < 18446744073709551616:\n    #    return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n\n    # Step 3: BPSW.\n    #\n    #  Time for isprime(10**2000 + 4561), no gmpy or gmpy2 installed\n    #     44.0s   old isprime using 46 bases\n    #      5.3s   strong BPSW + one random base\n    #      4.3s   extra strong BPSW + one random base\n    #      4.1s   strong BPSW\n    #      3.2s   extra strong BPSW\n\n    # Classic BPSW from page 1401 of the paper.  See alternate ideas below.\n    return is_strong_bpsw_prp(n)",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}