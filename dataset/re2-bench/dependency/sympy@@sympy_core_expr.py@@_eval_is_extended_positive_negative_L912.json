{
    "sympy.sympy.codegen.numpy_nodes._eval_evalf": "def _eval_evalf(self, *args, **kwargs):\n    return self.rewrite(log).evalf(*args, **kwargs)",
    "sympy.sympy.codegen.scipy_nodes._eval_evalf": "def _eval_evalf(self, *args, **kwargs):\n    return self.rewrite(cos).evalf(*args, **kwargs)",
    "sympy.sympy.concrete.expr_with_limits.is_number": "@property\ndef is_number(self):\n    \"\"\"Return True if the Sum has no free symbols, else False.\"\"\"\n    return not self.free_symbols",
    "sympy.sympy.core.add.<lambda>": "_eval_is_algebraic = lambda self: _fuzzy_group(\n    (a.is_algebraic for a in self.args), quick_exit=True)\n",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.evalf._eval_evalf": "def _eval_evalf(self, prec: int) -> Expr | None:\n    return None",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.function._eval_evalf": "def _eval_evalf(self, prec):\n\n    def _get_mpmath_func(fname):\n        \"\"\"Lookup mpmath function based on name\"\"\"\n        if isinstance(self, AppliedUndef):\n            # Shouldn't lookup in mpmath but might have ._imp_\n            return None\n\n        if not hasattr(mpmath, fname):\n            fname = MPMATH_TRANSLATIONS.get(fname, None)\n            if fname is None:\n                return None\n        return getattr(mpmath, fname)\n\n    _eval_mpmath = getattr(self, '_eval_mpmath', None)\n    if _eval_mpmath is None:\n        func = _get_mpmath_func(self.func.__name__)\n        args = self.args\n    else:\n        func, args = _eval_mpmath()\n\n    # Fall-back evaluation\n    if func is None:\n        imp = getattr(self, '_imp_', None)\n        if imp is None:\n            return None\n        try:\n            return Float(imp(*[i.evalf(prec) for i in self.args]), prec)\n        except (TypeError, ValueError):\n            return None\n\n    # Convert all args to mpf or mpc\n    # Convert the arguments to *higher* precision than requested for the\n    # final result.\n    # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should\n    #     we be more intelligent about it?\n    try:\n        args = [arg._to_mpmath(prec + 5) for arg in args]\n        def bad(m):\n            from mpmath import mpf, mpc\n            # the precision of an mpf value is the last element\n            # if that is 1 (and m[1] is not 1 which would indicate a\n            # power of 2), then the eval failed; so check that none of\n            # the arguments failed to compute to a finite precision.\n            # Note: An mpc value has two parts, the re and imag tuple;\n            # check each of those parts, too. Anything else is allowed to\n            # pass\n            if isinstance(m, mpf):\n                m = m._mpf_\n                return m[1] !=1 and m[-1] == 1\n            elif isinstance(m, mpc):\n                m, n = m._mpc_\n                return m[1] !=1 and m[-1] == 1 and \\\n                    n[1] !=1 and n[-1] == 1\n            else:\n                return False\n        if any(bad(a) for a in args):\n            raise ValueError  # one or more args failed to compute with significance\n    except ValueError:\n        return\n\n    with mpmath.workprec(prec):\n        v = func(*args)\n\n    return Expr._from_mpmath(v, prec)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    rv = self._Frel(other, mlib.mpf_gt)\n    if rv is None:\n        return Expr.__gt__(self, other)\n    return rv",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    "sympy.sympy.core.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    "sympy.sympy.core.operations._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\"\n    Evaluate the parts of self that are numbers; if the whole thing\n    was a number with no functions it would have been evaluated, but\n    it wasn't so we must judiciously extract the numbers and reconstruct\n    the object. This is *not* simply replacing numbers with evaluated\n    numbers. Numbers should be handled in the largest pure-number\n    expression as possible. So the code below separates ``self`` into\n    number and non-number parts and evaluates the number parts and\n    walks the args of the non-number part recursively (doing the same\n    thing).\n    \"\"\"\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        # if x is an AssocOp Function then the _evalf below will\n        # call _eval_evalf (here) so we must break the recursion\n        if not (tail is self.identity or\n                isinstance(x, AssocOp) and x.is_Function or\n                x is self.identity and isinstance(tail, AssocOp)):\n            # here, we have a number so we just call to _evalf with prec;\n            # prec is not the same as n, it is the binary precision so\n            # that's why we don't call to evalf.\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                # here we call to _eval_evalf since we don't know what we\n                # are dealing with and all other _eval_evalf routines should\n                # be doing the same thing (i.e. taking binary prec and\n                # finding the evalf-able args)\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n\n    # this is the same as above, but there were no pure-number args to\n    # deal with\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    "sympy.sympy.functions.combinatorial.numbers._eval_evalf": "def _eval_evalf(self, prec):\n    from sympy.functions.special.gamma_functions import gamma\n    if self.args[0].is_number:\n        return self.rewrite(gamma)._eval_evalf(prec)",
    "sympy.sympy.functions.elementary.complexes._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    return self.args[0]._eval_evalf(prec)",
    "sympy.sympy.functions.elementary.exponential._eval_evalf": "def _eval_evalf(self, prec):\n    \"\"\" Careful! any evalf of polar numbers is flaky \"\"\"\n    i = im(self.args[0])\n    try:\n        bad = (i <= -pi or i > pi)\n    except TypeError:\n        bad = True\n    if bad:\n        return self  # cannot evalf for this argument\n    res = exp(self.args[0])._eval_evalf(prec)\n    if i > 0 and im(res) < 0:\n        # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi\n        return re(res)\n    return res",
    "sympy.sympy.functions.elementary.miscellaneous.evalf": "def evalf(self, n=15, **options):\n    return self.func(*[a.evalf(n, **options) for a in self.args])",
    "sympy.sympy.functions.elementary.trigonometric._eval_is_algebraic": "def _eval_is_algebraic(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:\n            return False\n        pi_coeff = _pi_coeff(self.args[0])\n        if pi_coeff is not None and pi_coeff.is_rational:\n            return True\n    else:\n        return s.is_algebraic",
    "sympy.sympy.functions.special.bessel._eval_evalf": "def _eval_evalf(self, prec):\n    if self.order.is_Integer:\n        return self.rewrite(bessely)._eval_evalf(prec)",
    "sympy.sympy.functions.special.error_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if (self.args[0]/polar_lift(-1)).is_positive:\n        return super()._eval_evalf(prec) + (I*pi)._eval_evalf(prec)\n    return super()._eval_evalf(prec)",
    "sympy.sympy.functions.special.gamma_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if not all(i.is_number for i in self.args):\n        return\n    s = self.args[0]._to_mpmath(prec+12)\n    z = self.args[1]._to_mpmath(prec+12)\n    if mp.isint(z) and z <= 0:\n        return S.ComplexInfinity\n    with workprec(prec+12):\n        if mp.isint(s) and s >= 0:\n            res = mp.polygamma(s, z)\n        else:\n            zt = mp.zeta(s+1, z)\n            dzt = mp.zeta(s+1, z, 1)\n            res = (dzt + (mp.euler + mp.digamma(-s)) * zt) * mp.rgamma(-s)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.special.hyper.is_number": "@property\ndef is_number(self):\n    \"\"\" Returns true if expression has numeric data only. \"\"\"\n    return not self.free_symbols",
    "sympy.sympy.functions.special.spherical_harmonics._eval_evalf": "def _eval_evalf(self, prec):\n    # Note: works without this function by just calling\n    #       mpmath for Legendre polynomials. But using\n    #       the dedicated function directly is cleaner.\n    from mpmath import mp, workprec\n    n = self.args[0]._to_mpmath(prec)\n    m = self.args[1]._to_mpmath(prec)\n    theta = self.args[2]._to_mpmath(prec)\n    phi = self.args[3]._to_mpmath(prec)\n    with workprec(prec):\n        res = mp.spherharm(n, m, theta, phi)\n    return Expr._from_mpmath(res, prec)",
    "sympy.sympy.functions.special.zeta_functions._eval_evalf": "def _eval_evalf(self, prec):\n    if all(i.is_number for i in self.args):\n        return self.rewrite(zeta)._eval_evalf(prec)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.physics.quantum.trace.is_number": "@property\ndef is_number(self):\n    # TODO : improve this implementation\n    return True",
    "sympy.sympy.polys.numberfields.minpoly.minimal_polynomial": "@public\ndef minimal_polynomial(ex, x=None, compose=True, polys=False, domain=None):\n    \"\"\"\n    Computes the minimal polynomial of an algebraic element.\n\n    Parameters\n    ==========\n\n    ex : Expr\n        Element or expression whose minimal polynomial is to be calculated.\n\n    x : Symbol, optional\n        Independent variable of the minimal polynomial\n\n    compose : boolean, optional (default=True)\n        Method to use for computing minimal polynomial. If ``compose=True``\n        (default) then ``_minpoly_compose`` is used, if ``compose=False`` then\n        groebner bases are used.\n\n    polys : boolean, optional (default=False)\n        If ``True`` returns a ``Poly`` object else an ``Expr`` object.\n\n    domain : Domain, optional\n        Ground domain\n\n    Notes\n    =====\n\n    By default ``compose=True``, the minimal polynomial of the subexpressions of ``ex``\n    are computed, then the arithmetic operations on them are performed using the resultant\n    and factorization.\n    If ``compose=False``, a bottom-up algorithm is used with ``groebner``.\n    The default algorithm stalls less frequently.\n\n    If no ground domain is given, it will be generated automatically from the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import minimal_polynomial, sqrt, solve, QQ\n    >>> from sympy.abc import x, y\n\n    >>> minimal_polynomial(sqrt(2), x)\n    x**2 - 2\n    >>> minimal_polynomial(sqrt(2), x, domain=QQ.algebraic_field(sqrt(2)))\n    x - sqrt(2)\n    >>> minimal_polynomial(sqrt(2) + sqrt(3), x)\n    x**4 - 10*x**2 + 1\n    >>> minimal_polynomial(solve(x**3 + x + 3)[0], x)\n    x**3 + x + 3\n    >>> minimal_polynomial(sqrt(y), x)\n    x**2 - y\n\n    \"\"\"\n\n    ex = sympify(ex)\n    if ex.is_number:\n        # not sure if it's always needed but try it for numbers (issue 8354)\n        ex = _mexpand(ex, recursive=True)\n    for expr in preorder_traversal(ex):\n        if expr.is_AlgebraicNumber:\n            compose = False\n            break\n\n    if x is not None:\n        x, cls = sympify(x), Poly\n    else:\n        x, cls = Dummy('x'), PurePoly\n\n    if not domain:\n        if ex.free_symbols:\n            domain = FractionField(QQ, list(ex.free_symbols))\n        else:\n            domain = QQ\n    if hasattr(domain, 'symbols') and x in domain.symbols:\n        raise GeneratorsError(\"the variable %s is an element of the ground \"\n                              \"domain %s\" % (x, domain))\n\n    if compose:\n        result = _minpoly_compose(ex, x, domain)\n        result = result.primitive()[1]\n        c = result.coeff(x**degree(result, x))\n        if c.is_negative:\n            result = expand_mul(-result)\n        return cls(result, x, field=True) if polys else result.collect(x)\n\n    if not domain.is_QQ:\n        raise NotImplementedError(\"groebner method only works for QQ\")\n\n    result = _minpoly_groebner(ex, x, cls)\n    return cls(result, x, field=True) if polys else result.collect(x)",
    "sympy.sympy.polys.rootoftools._eval_evalf": "def _eval_evalf(self, prec, **kwargs):\n    \"\"\"Evaluate this complex root to the given precision.\"\"\"\n    # all kwargs are ignored\n    return self.eval_rational(n=prec_to_dps(prec))._evalf(prec)"
}