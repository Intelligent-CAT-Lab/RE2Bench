{
    "sympy.sympy.assumptions.assume.__new__": "def __new__(cls, predicate, *args):\n    if not isinstance(predicate, Predicate):\n        raise TypeError(f\"{predicate} is not a Predicate.\")\n    args = map(_sympify, args)\n    return super().__new__(cls, predicate, *args)",
    "sympy.sympy.calculus.accumulationbounds.__new__": "def __new__(cls, min, max) -> Expr: # type: ignore\n\n    min = _sympify(min)\n    max = _sympify(max)\n\n    # Only allow real intervals (use symbols with 'is_extended_real=True').\n    if not min.is_extended_real or not max.is_extended_real:\n        raise ValueError(\"Only real AccumulationBounds are supported\")\n\n    if max == min:\n        return max\n\n    # Make sure that the created AccumBounds object will be valid.\n    if max.is_number and min.is_number:\n        bad = max.is_comparable and min.is_comparable and max < min\n    else:\n        bad = (max - min).is_extended_negative\n    if bad:\n        raise ValueError(\n            \"Lower limit should be smaller than upper limit\")\n\n    return Basic.__new__(cls, min, max)",
    "sympy.sympy.codegen.ast.__new__": "def __new__(cls, *args, **kwargs):\n    # Pass through existing instances when given as sole argument\n    if len(args) == 1 and not kwargs and isinstance(args[0], cls):\n        return args[0]\n\n    if len(args) > len(cls._fields):\n        raise ValueError(\"Too many arguments (%d), expected at most %d\" % (len(args), len(cls._fields)))\n\n    attrvals = []\n\n    # Process positional arguments\n    for attrname, argval in zip(cls._fields, args):\n        if attrname in kwargs:\n            raise TypeError('Got multiple values for attribute %r' % attrname)\n\n        attrvals.append(cls._construct(attrname, argval))\n\n    # Process keyword arguments\n    for attrname in cls._fields[len(args):]:\n        if attrname in kwargs:\n            argval = kwargs.pop(attrname)\n\n        elif attrname in cls.defaults:\n            argval = cls.defaults[attrname]\n\n        else:\n            raise TypeError('No value for %r given and attribute has no default' % attrname)\n\n        attrvals.append(cls._construct(attrname, argval))\n\n    if kwargs:\n        raise ValueError(\"Unknown keyword arguments: %s\" % ' '.join(kwargs))\n\n    # Parent constructor\n    basic_args = [\n        val for attr, val in zip(cls._fields, attrvals)\n        if attr not in cls.not_in_args\n    ]\n    obj = CodegenAST.__new__(cls, *basic_args)\n\n    # Set attributes\n    for attr, arg in zip(cls._fields, attrvals):\n        setattr(obj, attr, arg)\n\n    return obj",
    "sympy.sympy.codegen.numpy_nodes.__new__": "def __new__(cls, *args):\n    return Function.__new__(cls, *sorted(args, key=default_sort_key))",
    "sympy.sympy.combinatorics.permutations.__new__": "def __new__(cls, perm, x, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    perm = _sympify(perm)\n    x = _sympify(x)\n\n    if not isinstance(perm, Permutation):\n        raise ValueError(\"{} must be a Permutation instance.\"\n            .format(perm))\n\n    if evaluate:\n        if x.is_Integer:\n            return perm.apply(x)\n\n    obj = super().__new__(cls, perm, x)\n    return obj",
    "sympy.sympy.core.basic.is_same": "def is_same(a, b, approx=None):\n    \"\"\"Return True if a and b are structurally the same, else False.\n    If `approx` is supplied, it will be used to test whether two\n    numbers are the same or not. By default, only numbers of the\n    same type will compare equal, so S.Half != Float(0.5).\n\n    Examples\n    ========\n\n    In SymPy (unlike Python) two numbers do not compare the same if they are\n    not of the same type:\n\n    >>> from sympy import S\n    >>> 2.0 == S(2)\n    False\n    >>> 0.5 == S.Half\n    False\n\n    By supplying a function with which to compare two numbers, such\n    differences can be ignored. e.g. `equal_valued` will return True\n    for decimal numbers having a denominator that is a power of 2,\n    regardless of precision.\n\n    >>> from sympy import Float\n    >>> from sympy.core.numbers import equal_valued\n    >>> (S.Half/4).is_same(Float(0.125, 1), equal_valued)\n    True\n    >>> Float(1, 2).is_same(Float(1, 10), equal_valued)\n    True\n\n    But decimals without a power of 2 denominator will compare\n    as not being the same.\n\n    >>> Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)\n    False\n\n    But arbitrary differences can be ignored by supplying a function\n    to test the equivalence of two numbers:\n\n    >>> import math\n    >>> Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)\n    True\n\n    Other objects might compare the same even though types are not the\n    same. This routine will only return True if two expressions are\n    identical in terms of class types.\n\n    >>> from sympy import eye, Basic\n    >>> eye(1) == S(eye(1))  # mutable vs immutable\n    True\n    >>> Basic.is_same(eye(1), S(eye(1)))\n    False\n\n    \"\"\"\n    from .numbers import Number\n    from .traversal import postorder_traversal as pot\n    for t in zip_longest(pot(a), pot(b)):\n        if None in t:\n            return False\n        a, b = t\n        if isinstance(a, Number):\n            if not isinstance(b, Number):\n                return False\n            if approx:\n                return approx(a, b)\n        if not (a == b and a.__class__ == b.__class__):\n            return False\n    return True",
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.functions.elementary.miscellaneous.__new__": "def __new__(cls, *args, **assumptions):\n    from sympy.core.parameters import global_parameters\n    evaluate = assumptions.pop('evaluate', global_parameters.evaluate)\n    args = (sympify(arg) for arg in args)\n\n    # first standard filter, for cls.zero and cls.identity\n    # also reshape Max(a, Max(b, c)) to Max(a, b, c)\n\n    if evaluate:\n        try:\n            args = frozenset(cls._new_args_filter(args))\n        except ShortCircuit:\n            return cls.zero\n        # remove redundant args that are easily identified\n        args = cls._collapse_arguments(args, **assumptions)\n        # find local zeros\n        args = cls._find_localzeros(args, **assumptions)\n    args = frozenset(args)\n\n    if not args:\n        return cls.identity\n\n    if len(args) == 1:\n        return list(args).pop()\n\n    # base creation\n    obj = Expr.__new__(cls, *ordered(args), **assumptions)\n    obj._argset = args\n    return obj",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.functions.special.hyper.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 5:\n        args = [(args[0], args[1]), (args[2], args[3]), args[4]]\n    if len(args) != 3:\n        raise TypeError(\"args must be either as, as', bs, bs', z or \"\n                        \"as, bs, z\")\n\n    def tr(p):\n        if len(p) != 2:\n            raise TypeError(\"wrong argument\")\n        p = [list(ordered(i)) for i in p]\n        return TupleArg(_prep_tuple(p[0]), _prep_tuple(p[1]))\n\n    arg0, arg1 = tr(args[0]), tr(args[1])\n    if Tuple(arg0, arg1).has(oo, zoo, -oo):\n        raise ValueError(\"G-function parameters must be finite\")\n    if any((a - b).is_Integer and a - b > 0\n           for a in arg0[0] for b in arg1[0]):\n        raise ValueError(\"no parameter a1, ..., an may differ from \"\n                     \"any b1, ..., bm by a positive integer\")\n\n    # TODO should we check convergence conditions?\n    return super().__new__(cls, arg0, arg1, args[2], **kwargs)",
    "sympy.sympy.geometry.curve.__new__": "def __new__(cls, function, limits):\n    if not is_sequence(function) or len(function) != 2:\n        raise ValueError(\"Function argument should be (x(t), y(t)) \"\n            \"but got %s\" % str(function))\n    if not is_sequence(limits) or len(limits) != 3:\n        raise ValueError(\"Limit argument should be (t, tmin, tmax) \"\n            \"but got %s\" % str(limits))\n\n    return GeometryEntity.__new__(cls, Tuple(*function), Tuple(*limits))",
    "sympy.sympy.geometry.ellipse.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if len(args) == 1 and isinstance(args[0], (Expr, Eq)):\n        x = kwargs.get('x', 'x')\n        y = kwargs.get('y', 'y')\n        equation = args[0].expand()\n        if isinstance(equation, Eq):\n            equation = equation.lhs - equation.rhs\n        x = find(x, equation)\n        y = find(y, equation)\n\n        try:\n            a, b, c, d, e = linear_coeffs(equation, x**2, y**2, x, y)\n        except ValueError:\n            raise GeometryError(\"The given equation is not that of a circle.\")\n\n        if S.Zero in (a, b) or a != b:\n            raise GeometryError(\"The given equation is not that of a circle.\")\n\n        center_x = -c/a/2\n        center_y = -d/b/2\n        r2 = (center_x**2) + (center_y**2) - e/a\n\n        return Circle((center_x, center_y), sqrt(r2), evaluate=evaluate)\n\n    else:\n        c, r = None, None\n        if len(args) == 3:\n            args = [Point(a, dim=2, evaluate=evaluate) for a in args]\n            t = Triangle(*args)\n            if not isinstance(t, Triangle):\n                return t\n            c = t.circumcenter\n            r = t.circumradius\n        elif len(args) == 2:\n            # Assume (center, radius) pair\n            c = Point(args[0], dim=2, evaluate=evaluate)\n            r = args[1]\n            # this will prohibit imaginary radius\n            try:\n                r = Point(r, 0, evaluate=evaluate).x\n            except ValueError:\n                raise GeometryError(\"Circle with imaginary radius is not permitted\")\n\n        if not (c is None or r is None):\n            if r == 0:\n                return c\n            return GeometryEntity.__new__(cls, c, r, **kwargs)\n\n        raise GeometryError(\"Circle.__new__ received unknown arguments\")",
    "sympy.sympy.geometry.line.__new__": "def __new__(cls, p1, p2, **kwargs):\n    p1 = Point(p1, dim=2)\n    p2 = Point(p2, dim=2)\n\n    if p1 == p2:\n        return p1\n\n    return LinearEntity2D.__new__(cls, p1, p2, **kwargs)",
    "sympy.sympy.geometry.point.__new__": "def __new__(cls, *args, _nocheck=False, **kwargs):\n    if not _nocheck:\n        kwargs['dim'] = 2\n        args = Point(*args, **kwargs)\n    return GeometryEntity.__new__(cls, *args)",
    "sympy.sympy.geometry.polygon.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) != 3:\n        if 'sss' in kwargs:\n            return _sss(*[simplify(a) for a in kwargs['sss']])\n        if 'asa' in kwargs:\n            return _asa(*[simplify(a) for a in kwargs['asa']])\n        if 'sas' in kwargs:\n            return _sas(*[simplify(a) for a in kwargs['sas']])\n        msg = \"Triangle instantiates with three points or a valid keyword.\"\n        raise GeometryError(msg)\n\n    vertices = [Point(a, dim=2, **kwargs) for a in args]\n\n    # remove consecutive duplicates\n    nodup = []\n    for p in vertices:\n        if nodup and p == nodup[-1]:\n            continue\n        nodup.append(p)\n    if len(nodup) > 1 and nodup[-1] == nodup[0]:\n        nodup.pop()  # last point was same as first\n\n    # remove collinear points\n    i = -3\n    while i < len(nodup) - 3 and len(nodup) > 2:\n        a, b, c = sorted(\n            [nodup[i], nodup[i + 1], nodup[i + 2]], key=default_sort_key)\n        if Point.is_collinear(a, b, c):\n            nodup[i] = a\n            nodup[i + 1] = None\n            nodup.pop(i + 1)\n        i += 1\n\n    vertices = list(filter(lambda x: x is not None, nodup))\n\n    if len(vertices) == 3:\n        return GeometryEntity.__new__(cls, *vertices, **kwargs)\n    elif len(vertices) == 2:\n        return Segment(*vertices, **kwargs)\n    else:\n        return Point(*vertices, **kwargs)",
    "sympy.sympy.geometry.polygon.args": "@property\ndef args(self):\n    \"\"\"\n    Returns the center point, the radius,\n    the number of sides, and the orientation angle.\n\n    Examples\n    ========\n\n    >>> from sympy import RegularPolygon, Point\n    >>> r = RegularPolygon(Point(0, 0), 5, 3)\n    >>> r.args\n    (Point2D(0, 0), 5, 3, 0)\n    \"\"\"\n    return self._center, self._radius, self._n, self._rot",
    "sympy.sympy.logic.boolalg.__new__": "def __new__(cls, *args, **kwargs):\n    from sympy.core.relational import Eq, Ne\n    if len(args) != 3:\n        raise ValueError('expecting exactly 3 args')\n    a, b, c = args\n    # check use of binary symbols\n    if isinstance(a, (Eq, Ne)):\n        # in this context, we can evaluate the Eq/Ne\n        # if one arg is a binary symbol and the other\n        # is true/false\n        b, c = map(as_Boolean, (b, c))\n        bin_syms = set().union(*[i.binary_symbols for i in (b, c)])\n        if len(set(a.args) - bin_syms) == 1:\n            # one arg is a binary_symbols\n            _a = a\n            if a.lhs is true:\n                a = a.rhs\n            elif a.rhs is true:\n                a = a.lhs\n            elif a.lhs is false:\n                a = Not(a.rhs)\n            elif a.rhs is false:\n                a = Not(a.lhs)\n            else:\n                # binary can only equal True or False\n                a = false\n            if isinstance(_a, Ne):\n                a = Not(a)\n    else:\n        a, b, c = BooleanFunction.binary_check_and_simplify(\n            a, b, c)\n    rv = None\n    if kwargs.get('evaluate', True):\n        rv = cls.eval(a, b, c)\n    if rv is None:\n        rv = BooleanFunction.__new__(cls, a, b, c, evaluate=False)\n    return rv",
    "sympy.sympy.matrices.expressions.applyfunc.__new__": "def __new__(cls, function, expr):\n    expr = _sympify(expr)\n    if not expr.is_Matrix:\n        raise ValueError(\"{} must be a matrix instance.\".format(expr))\n\n    if expr.shape == (1, 1):\n        # Check if the function returns a matrix, in that case, just apply\n        # the function instead of creating an ElementwiseApplyFunc object:\n        ret = function(expr)\n        if isinstance(ret, MatrixExpr):\n            return ret\n\n    if not isinstance(function, (FunctionClass, Lambda)):\n        d = Dummy('d')\n        function = Lambda(d, function(d))\n\n    function = sympify(function)\n    if not isinstance(function, (FunctionClass, Lambda)):\n        raise ValueError(\n            \"{} should be compatible with SymPy function classes.\"\n            .format(function))\n\n    if 1 not in function.nargs:\n        raise ValueError(\n            '{} should be able to accept 1 arguments.'.format(function))\n\n    if not isinstance(function, Lambda):\n        d = Dummy('d')\n        function = Lambda(d, function(d))\n\n    obj = MatrixExpr.__new__(cls, function, expr)\n    return obj",
    "sympy.sympy.matrices.expressions.determinant.__new__": "def __new__(cls, mat):\n    mat = sympify(mat)\n    if not mat.is_Matrix:\n        raise TypeError(\"Input to Determinant, %s, not a matrix\" % str(mat))\n\n    if mat.is_square is False:\n        raise NonSquareMatrixError(\"Det of a non-square matrix\")\n\n    return Basic.__new__(cls, mat)",
    "sympy.sympy.matrices.expressions.inverse.__new__": "def __new__(cls, mat, exp=S.NegativeOne):\n    # exp is there to make it consistent with\n    # inverse.func(*inverse.args) == inverse\n    mat = _sympify(mat)\n    exp = _sympify(exp)\n    if not mat.is_Matrix:\n        raise TypeError(\"mat should be a matrix\")\n    if mat.is_square is False:\n        raise NonSquareMatrixError(\"Inverse of non-square matrix %s\" % mat)\n    return Basic.__new__(cls, mat, exp)",
    "sympy.sympy.matrices.expressions.kronecker.__new__": "def __new__(cls, *args, check=True):\n    args = list(map(sympify, args))\n    if all(a.is_Identity for a in args):\n        ret = Identity(prod(a.rows for a in args))\n        if all(isinstance(a, MatrixBase) for a in args):\n            return ret.as_explicit()\n        else:\n            return ret\n\n    if check:\n        validate(*args)\n    return super().__new__(cls, *args)",
    "sympy.sympy.matrices.expressions.matadd.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericZeroMatrix().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n\n    if not all(isinstance(arg, MatrixExpr) for arg in args):\n        raise TypeError(\"Mix of Matrix and Scalar symbols\")\n\n    obj = Basic.__new__(cls, *args)\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatAdd is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*args)\n\n    if evaluate:\n        obj = cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, *args, **kwargs):\n    args = map(_sympify, args)\n    return Basic.__new__(cls, *args, **kwargs)",
    "sympy.sympy.matrices.expressions.matmul.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericIdentity().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatMul is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*matrices)\n\n    if not matrices:\n        # Should it be\n        #\n        # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n        return factor\n\n    if evaluate:\n        return cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.matpow.__new__": "def __new__(cls, base, exp, evaluate=False, **options) -> MatrixExpr: # type: ignore\n    base = _sympify(base)\n    if not base.is_Matrix:\n        raise TypeError(\"MatPow base should be a matrix\")\n\n    if base.is_square is False:\n        raise NonSquareMatrixError(\"Power of non-square matrix %s\" % base)\n\n    exp = _sympify(exp)\n    obj = super().__new__(cls, base, exp)\n\n    if evaluate:\n        obj = obj.doit(deep=False)\n\n    return obj",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.physics.control.lti.__new__": "def __new__(cls, A=None, B=None, C=None, D=None, sampling_time=1):\n    if sampling_time == 0:\n        raise ValueError(filldedent(\"\"\"\n            The sampling time cannot be zero.\n            If you want to create a continuous state space,\n            use the StateSpace class instead.\"\"\"))\n\n    sampling_time = sympify(sampling_time)\n    obj = super(DiscreteStateSpace, cls).__new__(cls, A, B, C, D, sampling_time)\n    obj._sampling_time = sampling_time\n\n    return obj",
    "sympy.sympy.physics.quantum.anticommutator.__new__": "def __new__(cls, A, B):\n    r = cls.eval(A, B)\n    if r is not None:\n        return r\n    obj = Expr.__new__(cls, A, B)\n    return obj",
    "sympy.sympy.physics.quantum.cg.__new__": "def __new__(cls, j1, m1, j2, m2, j3, m3):\n    args = map(sympify, (j1, m1, j2, m2, j3, m3))\n    return Expr.__new__(cls, *args)",
    "sympy.sympy.physics.quantum.commutator.__new__": "def __new__(cls, A, B):\n    r = cls.eval(A, B)\n    if r is not None:\n        return r\n    obj = Expr.__new__(cls, A, B)\n    return obj",
    "sympy.sympy.physics.quantum.hilbert.__new__": "def __new__(cls, interval):\n    if not isinstance(interval, Interval):\n        raise TypeError('L2 interval must be an Interval instance: %r'\n        % interval)\n    obj = Basic.__new__(cls, interval)\n    return obj",
    "sympy.sympy.physics.quantum.innerproduct.__new__": "def __new__(cls, bra, ket):\n    # Keep the import of BraBase and KetBase here to avoid problems\n    # with circular imports.\n    from sympy.physics.quantum.state import KetBase, BraBase\n    if not isinstance(ket, KetBase):\n        raise TypeError('KetBase subclass expected, got: %r' % ket)\n    if not isinstance(bra, BraBase):\n        raise TypeError('BraBase subclass expected, got: %r' % ket)\n    obj = Expr.__new__(cls, bra, ket)\n    return obj",
    "sympy.sympy.physics.quantum.operator.__new__": "def __new__(cls, *args, **old_assumptions):\n    from sympy.physics.quantum.state import KetBase, BraBase\n\n    if len(args) != 2:\n        raise ValueError('2 parameters expected, got %d' % len(args))\n\n    ket_expr = expand(args[0])\n    bra_expr = expand(args[1])\n\n    if (isinstance(ket_expr, (KetBase, Mul)) and\n            isinstance(bra_expr, (BraBase, Mul))):\n        ket_c, kets = ket_expr.args_cnc()\n        bra_c, bras = bra_expr.args_cnc()\n\n        if len(kets) != 1 or not isinstance(kets[0], KetBase):\n            raise TypeError('KetBase subclass expected'\n                            ', got: %r' % Mul(*kets))\n\n        if len(bras) != 1 or not isinstance(bras[0], BraBase):\n            raise TypeError('BraBase subclass expected'\n                            ', got: %r' % Mul(*bras))\n\n        if not kets[0].dual_class() == bras[0].__class__:\n            raise TypeError(\n                'ket and bra are not dual classes: %r, %r' %\n                (kets[0].__class__, bras[0].__class__)\n                )\n\n        # TODO: make sure the hilbert spaces of the bra and ket are\n        # compatible\n        obj = Expr.__new__(cls, *(kets[0], bras[0]), **old_assumptions)\n        obj.hilbert_space = kets[0].hilbert_space\n        return Mul(*(ket_c + bra_c)) * obj\n\n    op_terms = []\n    if isinstance(ket_expr, Add) and isinstance(bra_expr, Add):\n        for ket_term in ket_expr.args:\n            for bra_term in bra_expr.args:\n                op_terms.append(OuterProduct(ket_term, bra_term,\n                                             **old_assumptions))\n    elif isinstance(ket_expr, Add):\n        for ket_term in ket_expr.args:\n            op_terms.append(OuterProduct(ket_term, bra_expr,\n                                         **old_assumptions))\n    elif isinstance(bra_expr, Add):\n        for bra_term in bra_expr.args:\n            op_terms.append(OuterProduct(ket_expr, bra_term,\n                                         **old_assumptions))\n    else:\n        raise TypeError(\n            'Expected ket and bra expression, got: %r, %r' %\n            (ket_expr, bra_expr)\n            )\n\n    return Add(*op_terms)",
    "sympy.sympy.physics.quantum.qexpr.__new__": "def __new__(cls, *args, **kwargs):\n    \"\"\"Construct a new quantum object.\n\n    Parameters\n    ==========\n\n    args : tuple\n        The list of numbers or parameters that uniquely specify the\n        quantum object. For a state, this will be its symbol or its\n        set of quantum numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.qexpr import QExpr\n    >>> q = QExpr(0)\n    >>> q\n    0\n    >>> q.label\n    (0,)\n    >>> q.hilbert_space\n    H\n    >>> q.args\n    (0,)\n    >>> q.is_commutative\n    False\n    \"\"\"\n\n    # First compute args and call Expr.__new__ to create the instance\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    # Now set the slots on the instance\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    "sympy.sympy.physics.quantum.spin.__new__": "def __new__(cls, j, m):\n    j = sympify(j)\n    m = sympify(m)\n    if j.is_number:\n        if 2*j != int(2*j):\n            raise ValueError(\n                'j must be integer or half-integer, got: %s' % j)\n        if j < 0:\n            raise ValueError('j must be >= 0, got: %s' % j)\n    if m.is_number:\n        if 2*m != int(2*m):\n            raise ValueError(\n                'm must be integer or half-integer, got: %s' % m)\n    if j.is_number and m.is_number:\n        if abs(m) > j:\n            raise ValueError('Allowed values for m are -j <= m <= j, got j, m: %s, %s' % (j, m))\n        if int(j - m) != j - m:\n            raise ValueError('Both j and m must be integer or half-integer, got j, m: %s, %s' % (j, m))\n    return State.__new__(cls, j, m)",
    "sympy.sympy.physics.quantum.tensorproduct.__new__": "def __new__(cls, *args):\n    if isinstance(args[0], (Matrix, ImmutableMatrix, numpy_ndarray,\n                                                scipy_sparse_matrix)):\n        return matrix_tensor_product(*args)\n    c_part, new_args = cls.flatten(sympify(args))\n    c_part = Mul(*c_part)\n    if len(new_args) == 0:\n        return c_part\n    elif len(new_args) == 1:\n        return c_part * new_args[0]\n    else:\n        tp = Expr.__new__(cls, *new_args)\n        return c_part * tp",
    "sympy.sympy.physics.secondquant.__new__": "def __new__(cls, k):\n    obj = Basic.__new__(cls, sympify(k))\n    return obj",
    "sympy.sympy.polys.rootoftools.__new__": "def __new__(cls, expr, func=None, x=None, auto=True, quadratic=False):\n    \"\"\"Construct a new ``RootSum`` instance of roots of a polynomial.\"\"\"\n    coeff, poly = cls._transform(expr, x)\n\n    if not poly.is_univariate:\n        raise MultivariatePolynomialError(\n            \"only univariate polynomials are allowed\")\n\n    if func is None:\n        func = Lambda(poly.gen, poly.gen)\n    else:\n        is_func = getattr(func, 'is_Function', False)\n\n        if is_func and 1 in func.nargs:\n            if not isinstance(func, Lambda):\n                func = Lambda(poly.gen, func(poly.gen))\n        else:\n            raise ValueError(\n                \"expected a univariate function, got %s\" % func)\n\n    var, expr = func.variables[0], func.expr\n\n    if coeff is not S.One:\n        expr = expr.subs(var, coeff*var)\n\n    deg = poly.degree()\n\n    if not expr.has(var):\n        return deg*expr\n\n    if expr.is_Add:\n        add_const, expr = expr.as_independent(var)\n    else:\n        add_const = S.Zero\n\n    if expr.is_Mul:\n        mul_const, expr = expr.as_independent(var)\n    else:\n        mul_const = S.One\n\n    func = Lambda(var, expr)\n\n    rational = cls._is_func_rational(poly, func)\n    factors, terms = _pure_factors(poly), []\n\n    for poly, k in factors:\n        if poly.is_linear:\n            term = func(roots_linear(poly)[0])\n        elif quadratic and poly.is_quadratic:\n            term = sum(map(func, roots_quadratic(poly)))\n        else:\n            if not rational or not auto:\n                term = cls._new(poly, func, auto)\n            else:\n                term = cls._rational_case(poly, func)\n\n        terms.append(k*term)\n\n    return mul_const*Add(*terms) + deg*add_const",
    "sympy.sympy.polys.rootoftools.args": "@property\ndef args(self):\n    return (self.expr, self.fun, self.poly.gen)",
    "sympy.sympy.series.sequences.__new__": "def __new__(cls, formula, limits=None):\n    formula = sympify(formula)\n\n    def _find_x(formula):\n        free = formula.free_symbols\n        if len(free) == 1:\n            return free.pop()\n        elif not free:\n            return Dummy('k')\n        else:\n            raise ValueError(\n                \" specify dummy variables for %s. If the formula contains\"\n                \" more than one free symbol, a dummy variable should be\"\n                \" supplied explicitly e.g., SeqFormula(m*n**2, (n, 0, 5))\"\n                % formula)\n\n    x, start, stop = None, None, None\n    if limits is None:\n        x, start, stop = _find_x(formula), 0, S.Infinity\n    if is_sequence(limits, Tuple):\n        if len(limits) == 3:\n            x, start, stop = limits\n        elif len(limits) == 2:\n            x = _find_x(formula)\n            start, stop = limits\n\n    if not isinstance(x, (Symbol, Idx)) or start is None or stop is None:\n        raise ValueError('Invalid limits given: %s' % str(limits))\n\n    if start is S.NegativeInfinity and stop is S.Infinity:\n            raise ValueError(\"Both the start and end value \"\n                             \"cannot be unbounded\")\n    limits = sympify((x, start, stop))\n\n    if Interval(limits[1], limits[2]) is S.EmptySet:\n        return S.EmptySequence\n\n    return Basic.__new__(cls, formula, limits)",
    "sympy.sympy.sets.contains.__new__": "def __new__(cls, x, s, evaluate=None):\n    x = sympify(x)\n    s = sympify(s)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not isinstance(s, Set):\n        raise TypeError('expecting Set, not %s' % func_name(s))\n\n    if evaluate:\n        # _contains can return symbolic booleans that would be returned by\n        # s.contains(x) but here for Contains(x, s) we only evaluate to\n        # true, false or return the unevaluated Contains.\n        result = s._contains(x)\n\n        if isinstance(result, Boolean):\n            if result in (S.true, S.false):\n                return result\n        elif result is not None:\n            raise TypeError(\"_contains() should return Boolean or None\")\n\n    return super().__new__(cls, x, s)",
    "sympy.sympy.sets.fancysets.__new__": "def __new__(cls, flambda, *sets):\n    if not isinstance(flambda, Lambda):\n        raise ValueError('First argument must be a Lambda')\n\n    signature = flambda.signature\n\n    if len(signature) != len(sets):\n        raise ValueError('Incompatible signature')\n\n    sets = [_sympify(s) for s in sets]\n\n    if not all(isinstance(s, Set) for s in sets):\n        raise TypeError(\"Set arguments to ImageSet should of type Set\")\n\n    if not all(cls._check_sig(sg, st) for sg, st in zip(signature, sets)):\n        raise ValueError(\"Signature %s does not match sets %s\" % (signature, sets))\n\n    if flambda is S.IdentityFunction and len(sets) == 1:\n        return sets[0]\n\n    if not set(flambda.variables) & flambda.expr.free_symbols:\n        is_empty = fuzzy_or(s.is_empty for s in sets)\n        if is_empty == True:\n            return S.EmptySet\n        elif is_empty == False:\n            return FiniteSet(flambda.expr)\n\n    return Basic.__new__(cls, flambda, *sets)",
    "sympy.sympy.sets.sets.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n\n    # keep the form of the first canonical arg\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                # e.g. i = class without args like `Interval`\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    "sympy.sympy.sets.sets.args": "@property\ndef args(self):\n    return self._args",
    "sympy.sympy.stats.compound_rv.__new__": "def __new__(cls, s, distribution):\n    s = _symbol_converter(s)\n    if isinstance(distribution, ContinuousDistribution):\n        return SingleContinuousPSpace(s, distribution)\n    if isinstance(distribution, DiscreteDistribution):\n        return SingleDiscretePSpace(s, distribution)\n    if isinstance(distribution, SingleFiniteDistribution):\n        return SingleFinitePSpace(s, distribution)\n    if not isinstance(distribution, CompoundDistribution):\n        raise ValueError(\"%s should be an isinstance of \"\n                    \"CompoundDistribution\"%(distribution))\n    return Basic.__new__(cls, s, distribution)",
    "sympy.sympy.stats.crv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.drv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.frv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.rv.__new__": "def __new__(cls, expr, condition = None):\n    expr = _sympify(expr)\n    if condition is None:\n        obj = Basic.__new__(cls, expr)\n    else:\n        condition = _sympify(condition)\n        obj = Basic.__new__(cls, expr, condition)\n    return obj",
    "sympy.sympy.stats.stochastic_process.__new__": "def __new__(cls, sym, process, distribution=None):\n    sym = _symbol_converter(sym)\n    from sympy.stats.stochastic_process_types import StochasticProcess\n    if not isinstance(process, StochasticProcess):\n        raise TypeError(\"`process` must be an instance of StochasticProcess.\")\n    if distribution is None:\n        distribution = Distribution()\n    return Basic.__new__(cls, sym, process, distribution)",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, prob, condition=None, **kwargs):\n    prob = _sympify(prob)\n    if condition is None:\n        obj = Expr.__new__(cls, prob)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, prob, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.tensor.array.array_comprehension.__new__": "def __new__(cls, *args, **kwargs):\n    return ArrayComprehensionMap(self._lambda, *args, **kwargs)",
    "sympy.sympy.tensor.array.array_comprehension.func": "@property\ndef func(self):\n    class _(ArrayComprehensionMap):\n        def __new__(cls, *args, **kwargs):\n            return ArrayComprehensionMap(self._lambda, *args, **kwargs)\n    return _",
    "sympy.sympy.tensor.array.expressions.array_expressions.__new__": "def __new__(cls, symbol, shape: typing.Iterable) -> \"ArraySymbol\":\n    if isinstance(symbol, str):\n        symbol = Symbol(symbol)\n    # symbol = _sympify(symbol)\n    shape = Tuple(*map(_sympify, shape))\n    obj = Expr.__new__(cls, symbol, shape)\n    return obj",
    "sympy.sympy.tensor.indexed.__new__": "def __new__(cls, label, range=None, **kw_args):\n\n    if isinstance(label, str):\n        label = Symbol(label, integer=True)\n    label, range = list(map(sympify, (label, range)))\n\n    if label.is_Number:\n        if not label.is_integer:\n            raise TypeError(\"Index is not an integer number.\")\n        return label\n\n    if not label.is_integer:\n        raise TypeError(\"Idx object requires an integer label.\")\n\n    elif is_sequence(range):\n        if len(range) != 2:\n            raise ValueError(filldedent(f\"\"\"\n                Idx range tuple must have length 2, but got {len(range)}\"\"\"))\n        for bound in range:\n            if (bound.is_integer is False and bound is not S.Infinity\n                    and bound is not S.NegativeInfinity):\n                raise TypeError(\"Idx object requires integer bounds.\")\n        args = label, Tuple(*range)\n    elif isinstance(range, Expr):\n        if range is not S.Infinity and fuzzy_not(range.is_integer):\n            raise TypeError(\"Idx object requires an integer dimension.\")\n        args = label, Tuple(0, range - 1)\n    elif range:\n        raise TypeError(filldedent(\"\"\"\n            The range must be an ordered iterable or\n            integer SymPy expression.\"\"\"))\n    else:\n        args = label,\n\n    obj = Expr.__new__(cls, *args, **kw_args)\n    obj._assumptions[\"finite\"] = True\n    obj._assumptions[\"real\"] = True\n    return obj",
    "sympy.sympy.tensor.tensor.__new__": "def __new__(cls, tensor_head, indices, **kw_args):\n    is_canon_bp = kw_args.pop(\"is_canon_bp\", False)\n\n    if tensor_head.func == TensorHead:\n        \"\"\"\n        If someone tried to call WildTensor by supplying a TensorHead (not a WildTensorHead), return a normal tensor instead. This is helpful when using subs on an expression to replace occurrences of a WildTensorHead with a TensorHead.\n        \"\"\"\n        return Tensor(tensor_head, indices, is_canon_bp=is_canon_bp, **kw_args)\n    elif tensor_head.func == _WildTensExpr:\n        return tensor_head(*indices)\n\n    indices = cls._parse_indices(tensor_head, indices)\n    index_types = [ind.tensor_index_type for ind in indices]\n    tensor_head = tensor_head.func(\n        tensor_head.name,\n        index_types,\n        symmetry=None,\n        comm=tensor_head.comm,\n        unordered_indices=tensor_head.unordered_indices,\n        )\n\n    obj = Basic.__new__(cls, tensor_head, Tuple(*indices))\n    obj.name = tensor_head.name\n    obj._index_structure = _IndexStructure.from_indices(*indices)\n    obj._free = obj._index_structure.free[:]\n    obj._dum = obj._index_structure.dum[:]\n    obj._ext_rank = obj._index_structure._ext_rank\n    obj._coeff = S.One\n    obj._nocoeff = obj\n    obj._component = tensor_head\n    obj._components = [tensor_head]\n    if tensor_head.rank != len(indices):\n        raise ValueError(\"wrong number of indices\")\n    obj.is_canon_bp = is_canon_bp\n    obj._index_map = obj._build_index_map(indices, obj._index_structure)\n\n    return obj",
    "sympy.sympy.vector.vector.__new__": "def __new__(cls, *args, **options):\n    obj = BasisDependentMul.__new__(cls, *args, **options)\n    return obj"
}