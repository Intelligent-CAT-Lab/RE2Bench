{
    "sympy.sympy.core.assumptions.copy": "def copy(self):\n    return self.__class__(self)",
    "sympy.sympy.core.assumptions._ask": "def _ask(fact, obj):\n    \"\"\"\n    Find the truth value for a property of an object.\n\n    This function is called when a request is made to see what a fact\n    value is.\n\n    For this we use several techniques:\n\n    First, the fact-evaluation function is tried, if it exists (for\n    example _eval_is_integer). Then we try related facts. For example\n\n        rational   -->   integer\n\n    another example is joined rule:\n\n        integer & !odd  --> even\n\n    so in the latter case if we are looking at what 'even' value is,\n    'integer' and 'odd' facts will be asked.\n\n    In all cases, when we settle on some fact value, its implications are\n    deduced, and the result is cached in ._assumptions.\n    \"\"\"\n    # FactKB which is dict-like and maps facts to their known values:\n    assumptions = obj._assumptions\n\n    # A dict that maps facts to their handlers:\n    handler_map = obj._prop_handler\n\n    # This is our queue of facts to check:\n    facts_to_check = [fact]\n    facts_queued = {fact}\n\n    # Loop over the queue as it extends\n    for fact_i in facts_to_check:\n\n        # If fact_i has already been determined then we don't need to rerun the\n        # handler. There is a potential race condition for multithreaded code\n        # though because it's possible that fact_i was checked in another\n        # thread. The main logic of the loop below would potentially skip\n        # checking assumptions[fact] in this case so we check it once after the\n        # loop to be sure.\n        if fact_i in assumptions:\n            continue\n\n        # Now we call the associated handler for fact_i if it exists.\n        fact_i_value = None\n        handler_i = handler_map.get(fact_i)\n        if handler_i is not None:\n            fact_i_value = handler_i(obj)\n\n        # If we get a new value for fact_i then we should update our knowledge\n        # of fact_i as well as any related facts that can be inferred using the\n        # inference rules connecting the fact_i and any other fact values that\n        # are already known.\n        if fact_i_value is not None:\n            assumptions.deduce_all_facts(((fact_i, fact_i_value),))\n\n        # Usually if assumptions[fact] is now not None then that is because of\n        # the call to deduce_all_facts above. The handler for fact_i returned\n        # True or False and knowing fact_i (which is equal to fact in the first\n        # iteration) implies knowing a value for fact. It is also possible\n        # though that independent code e.g. called indirectly by the handler or\n        # called in another thread in a multithreaded context might have\n        # resulted in assumptions[fact] being set. Either way we return it.\n        fact_value = assumptions.get(fact)\n        if fact_value is not None:\n            return fact_value\n\n        # Extend the queue with other facts that might determine fact_i. Here\n        # we randomise the order of the facts that are checked. This should not\n        # lead to any non-determinism if all handlers are logically consistent\n        # with the inference rules for the facts. Non-deterministic assumptions\n        # queries can result from bugs in the handlers that are exposed by this\n        # call to shuffle. These are pushed to the back of the queue meaning\n        # that the inference graph is traversed in breadth-first order.\n        new_facts_to_check = list(_assume_rules.prereq[fact_i] - facts_queued)\n        shuffle(new_facts_to_check)\n        facts_to_check.extend(new_facts_to_check)\n        facts_queued.update(new_facts_to_check)\n\n    # The above loop should be able to handle everything fine in a\n    # single-threaded context but in multithreaded code it is possible that\n    # this thread skipped computing a particular fact that was computed in\n    # another thread (due to the continue). In that case it is possible that\n    # fact was inferred and is now stored in the assumptions dict but it wasn't\n    # checked for in the body of the loop. This is an obscure case but to make\n    # sure we catch it we check once here at the end of the loop.\n    if fact in assumptions:\n        return assumptions[fact]\n\n    # This query can not be answered. It's possible that e.g. another thread\n    # has already stored None for fact but assumptions._tell does not mind if\n    # we call _tell twice setting the same value. If this raises\n    # InconsistentAssumptions then it probably means that another thread\n    # attempted to compute this and got a value of True or False rather than\n    # None. In that case there must be a bug in at least one of the handlers.\n    # If the handlers are all deterministic and are consistent with the\n    # inference rules then the same value should be computed for fact in all\n    # threads.\n    assumptions._tell(fact, None)\n    return None",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}