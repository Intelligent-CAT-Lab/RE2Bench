{
    "sympy.sympy.core.add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.NegativeOne",
    "sympy.sympy.core.relational.lhs": "@property\ndef lhs(self) -> Basic:\n    \"\"\"The left-hand side of the relation.\"\"\"\n    return self._args[0]",
    "sympy.sympy.core.relational.rhs": "@property\ndef rhs(self) -> Basic:\n    \"\"\"The right-hand side of the relation.\"\"\"\n    return self._args[1]",
    "sympy.sympy.polys.matrices.linsolve.<dictcomp>": "terms = {k: v for k, v in terms.items() if v}\n",
    "sympy.sympy.polys.matrices.linsolve._lin_eq2dict": "def _lin_eq2dict(a, symset):\n    \"\"\"return (c, d) where c is the sym-independent part of ``a`` and\n    ``d`` is an efficiently calculated dictionary mapping symbols to\n    their coefficients. A PolyNonlinearError is raised if non-linearity\n    is detected.\n\n    The values in the dictionary will be non-zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\n    >>> from sympy.abc import x, y\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\n    (3, {x: 1, y: 2})\n    \"\"\"\n    if a in symset:\n        return S.Zero, {a: S.One}\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            ci, ti = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for mij, cij in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for sym, coeffs in terms_list.items()}\n        return coeff, terms\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            ci, ti = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                # since ti is not null and we already have\n                # a term, this is a cross term\n                raise PolyNonlinearError(filldedent('''\n                    nonlinear cross-term: %s''' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return coeff, {}\n        else:\n            terms = {sym: coeff * c for sym, c in terms.items()}\n            return  coeff * terms_coeff, terms\n    elif not a.has_xfree(symset):\n        return a, {}\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)"
}