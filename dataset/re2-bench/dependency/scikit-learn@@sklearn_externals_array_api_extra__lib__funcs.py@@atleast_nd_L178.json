{
    "scikit-learn.sklearn.externals.array_api_compat.common._helpers.array_namespace": "def array_namespace(\n    *xs: Array | complex | None,\n    api_version: str | None = None,\n    use_compat: bool | None = None,\n) -> Namespace:\n    \"\"\"\n    Get the array API compatible namespace for the arrays `xs`.\n\n    Parameters\n    ----------\n    xs: arrays\n        one or more arrays. xs can also be Python scalars (bool, int, float,\n        complex, or None), which are ignored.\n\n    api_version: str\n        The newest version of the spec that you need support for (currently\n        the compat library wrapped APIs support v2024.12).\n\n    use_compat: bool or None\n        If None (the default), the native namespace will be returned if it is\n        already array API compatible, otherwise a compat wrapper is used. If\n        True, the compat library wrapped library will be returned. If False,\n        the native library namespace is returned.\n\n    Returns\n    -------\n\n    out: namespace\n        The array API compatible namespace corresponding to the arrays in `xs`.\n\n    Raises\n    ------\n    TypeError\n        If `xs` contains arrays from different array libraries or contains a\n        non-array.\n\n\n    Typical usage is to pass the arguments of a function to\n    `array_namespace()` at the top of a function to get the corresponding\n    array API namespace:\n\n    .. code:: python\n\n       def your_function(x, y):\n           xp = array_api_compat.array_namespace(x, y)\n           # Now use xp as the array library namespace\n           return xp.mean(x, axis=0) + 2*xp.std(y, axis=0)\n\n\n    Wrapped array namespaces can also be imported directly. For example,\n    `array_namespace(np.array(...))` will return `array_api_compat.numpy`.\n    This function will also work for any array library not wrapped by\n    array-api-compat if it explicitly defines `__array_namespace__\n    <https://data-apis.org/array-api/latest/API_specification/generated/array_api.array.__array_namespace__.html>`__\n    (the wrapped namespace is always preferred if it exists).\n\n    See Also\n    --------\n\n    is_array_api_obj\n    is_numpy_array\n    is_cupy_array\n    is_torch_array\n    is_dask_array\n    is_jax_array\n    is_pydata_sparse_array\n\n    \"\"\"\n    if use_compat not in [None, True, False]:\n        raise ValueError(\"use_compat must be None, True, or False\")\n\n    _use_compat = use_compat in [None, True]\n\n    namespaces: set[Namespace] = set()\n    for x in xs:\n        if is_numpy_array(x):\n            import numpy as np\n\n            from .. import numpy as numpy_namespace\n\n            if use_compat is True:\n                _check_api_version(api_version)\n                namespaces.add(numpy_namespace)\n            elif use_compat is False:\n                namespaces.add(np)\n            else:\n                # numpy 2.0+ have __array_namespace__, however, they are not yet fully array API\n                # compatible.\n                namespaces.add(numpy_namespace)\n        elif is_cupy_array(x):\n            if _use_compat:\n                _check_api_version(api_version)\n                from .. import cupy as cupy_namespace\n\n                namespaces.add(cupy_namespace)\n            else:\n                import cupy as cp  # pyright: ignore[reportMissingTypeStubs]\n\n                namespaces.add(cp)\n        elif is_torch_array(x):\n            if _use_compat:\n                _check_api_version(api_version)\n                from .. import torch as torch_namespace\n\n                namespaces.add(torch_namespace)\n            else:\n                import torch\n\n                namespaces.add(torch)\n        elif is_dask_array(x):\n            if _use_compat:\n                _check_api_version(api_version)\n                from ..dask import array as dask_namespace\n\n                namespaces.add(dask_namespace)\n            else:\n                import dask.array as da\n\n                namespaces.add(da)\n        elif is_jax_array(x):\n            if use_compat is True:\n                _check_api_version(api_version)\n                raise ValueError(\"JAX does not have an array-api-compat wrapper\")\n            elif use_compat is False:\n                import jax.numpy as jnp\n            else:\n                # JAX v0.4.32 and newer implements the array API directly in jax.numpy.\n                # For older JAX versions, it is available via jax.experimental.array_api.\n                import jax.numpy\n\n                if hasattr(jax.numpy, \"__array_api_version__\"):\n                    jnp = jax.numpy\n                else:\n                    import jax.experimental.array_api as jnp  # pyright: ignore[reportMissingImports]\n            namespaces.add(jnp)\n        elif is_pydata_sparse_array(x):\n            if use_compat is True:\n                _check_api_version(api_version)\n                raise ValueError(\"`sparse` does not have an array-api-compat wrapper\")\n            else:\n                import sparse  # pyright: ignore[reportMissingTypeStubs]\n            # `sparse` is already an array namespace. We do not have a wrapper\n            # submodule for it.\n            namespaces.add(sparse)\n        elif hasattr(x, \"__array_namespace__\"):\n            if use_compat is True:\n                raise ValueError(\n                    \"The given array does not have an array-api-compat wrapper\"\n                )\n            x = cast(\"SupportsArrayNamespace[Any]\", x)\n            namespaces.add(x.__array_namespace__(api_version=api_version))\n        elif isinstance(x, (bool, int, float, complex, type(None))):\n            continue\n        else:\n            # TODO: Support Python scalars?\n            raise TypeError(f\"{type(x).__name__} is not a supported array type\")\n\n    if not namespaces:\n        raise TypeError(\"Unrecognized array input\")\n\n    if len(namespaces) != 1:\n        raise TypeError(f\"Multiple namespaces for array inputs: {namespaces}\")\n\n    (xp,) = namespaces\n\n    return xp",
    "scikit-learn.sklearn.externals.array_api_extra._lib._funcs.atleast_nd": "def atleast_nd(x: Array, /, *, ndim: int, xp: ModuleType | None = None) -> Array:\n    \"\"\"\n    Recursively expand the dimension of an array to at least `ndim`.\n\n    Parameters\n    ----------\n    x : array\n        Input array.\n    ndim : int\n        The minimum number of dimensions for the result.\n    xp : array_namespace, optional\n        The standard-compatible namespace for `x`. Default: infer.\n\n    Returns\n    -------\n    array\n        An array with ``res.ndim`` >= `ndim`.\n        If ``x.ndim`` >= `ndim`, `x` is returned.\n        If ``x.ndim`` < `ndim`, `x` is expanded by prepending new axes\n        until ``res.ndim`` equals `ndim`.\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n    >>> x = xp.asarray([1])\n    >>> xpx.atleast_nd(x, ndim=3, xp=xp)\n    Array([[[1]]], dtype=array_api_strict.int64)\n\n    >>> x = xp.asarray([[[1, 2],\n    ...                  [3, 4]]])\n    >>> xpx.atleast_nd(x, ndim=1, xp=xp) is x\n    True\n    \"\"\"\n    if xp is None:\n        xp = array_namespace(x)\n\n    if x.ndim < ndim:\n        x = xp.expand_dims(x, axis=0)\n        x = atleast_nd(x, ndim=ndim, xp=xp)\n    return x"
}