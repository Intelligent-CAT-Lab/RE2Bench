{
    "scikit-learn.sklearn.externals.array_api_compat._internal.wrapped_f": "@wraps(f)\ndef wrapped_f(*args: object, **kwargs: object) -> object:\n    return f(*args, xp=xp, **kwargs)",
    "scikit-learn.sklearn.utils._array_api.get_namespace_and_device": "def get_namespace_and_device(\n    *array_list, remove_none=True, remove_types=(str,), xp=None\n):\n    \"\"\"Combination into one single function of `get_namespace` and `device`.\n\n    Parameters\n    ----------\n    *array_list : array objects\n        Array objects.\n    remove_none : bool, default=True\n        Whether to ignore None objects passed in arrays.\n    remove_types : tuple or list, default=(str,)\n        Types to ignore in the arrays.\n    xp : module, default=None\n        Precomputed array namespace module. When passed, typically from a caller\n        that has already performed inspection of its own inputs, skips array\n        namespace inspection.\n\n    Returns\n    -------\n    namespace : module\n        Namespace shared by array objects. If any of the `arrays` are not arrays,\n        the namespace defaults to NumPy.\n    is_array_api_compliant : bool\n        True if the arrays are containers that implement the Array API spec.\n        Always False when array_api_dispatch=False.\n    device : device\n        `device` object (see the \"Device Support\" section of the array API spec).\n    \"\"\"\n    skip_remove_kwargs = dict(remove_none=False, remove_types=[])\n\n    array_list = _remove_non_arrays(\n        *array_list,\n        remove_none=remove_none,\n        remove_types=remove_types,\n    )\n    arrays_device = device(*array_list, **skip_remove_kwargs)\n\n    if xp is None:\n        xp, is_array_api = get_namespace(*array_list, **skip_remove_kwargs)\n    else:\n        xp, is_array_api = xp, True\n\n    if is_array_api:\n        return xp, is_array_api, arrays_device\n    else:\n        return xp, False, arrays_device",
    "scikit-learn.sklearn.utils._array_api._max_precision_float_dtype": "def _max_precision_float_dtype(xp, device):\n    \"\"\"Return the float dtype with the highest precision supported by the device.\"\"\"\n    # TODO: Update to use `__array_namespace__info__()` from array-api v2023.12\n    # when/if that becomes more widespread.\n    if _is_xp_namespace(xp, \"torch\") and str(device).startswith(\n        \"mps\"\n    ):  # pragma: no cover\n        return xp.float32\n    return xp.float64",
    "scikit-learn.sklearn.utils._array_api._nansum": "def _nansum(X, axis=None, xp=None, keepdims=False, dtype=None):\n    # TODO: refactor once nan-aware reductions are standardized:\n    # https://github.com/data-apis/array-api/issues/621\n    xp, _, X_device = get_namespace_and_device(X, xp=xp)\n\n    if _is_numpy_namespace(xp):\n        return xp.asarray(numpy.nansum(X, axis=axis, keepdims=keepdims, dtype=dtype))\n\n    mask = xp.isnan(X)\n    masked_arr = xp.where(mask, xp.asarray(0, device=X_device, dtype=X.dtype), X)\n    return xp.sum(masked_arr, axis=axis, keepdims=keepdims, dtype=dtype)",
    "scikit-learn.sklearn.utils.extmath.convert_dtype": "def convert_dtype(arr):\n    return xp.astype(arr, target_dtype, copy=False)",
    "scikit-learn.sklearn.utils.extmath.<listcomp>": "args = [\n    (convert_dtype(arg) if hasattr(arg, \"dtype\") else arg) for arg in args\n"
}