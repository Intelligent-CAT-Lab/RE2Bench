{
    "scikit-learn.sklearn.model_selection._search._check_refit": "def _check_refit(search_cv, attr):\n    if not search_cv.refit:\n        raise AttributeError(\n            f\"This {type(search_cv).__name__} instance was initialized with \"\n            f\"`refit=False`. {attr} is available only after refitting on the best \"\n            \"parameters. You can refit an estimator manually using the \"\n            \"`best_params_` attribute\"\n        )",
    "scikit-learn.sklearn.pipeline.classes_": "@property\ndef classes_(self):\n    \"\"\"The classes labels. Only exist if the last step is a classifier.\"\"\"\n    return self.steps[-1][1].classes_",
    "scikit-learn.sklearn.utils._available_if.__get__": "def __get__(self, obj, owner=None):\n    if obj is not None:\n        # delegate only on instances, not the classes.\n        # this is to allow access to the docstrings.\n        self._check(obj, owner=owner)\n        out = MethodType(self.fn, obj)\n\n    else:\n        # This makes it possible to use the decorated method as an unbound method,\n        # for instance when monkeypatching.\n        @wraps(self.fn)\n        def out(*args, **kwargs):\n            self._check(args[0], owner=owner)\n            return self.fn(*args, **kwargs)\n\n    return out"
}