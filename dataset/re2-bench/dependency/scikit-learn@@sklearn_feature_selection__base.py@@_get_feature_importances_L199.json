{
    "scikit-learn.sklearn.ensemble._forest.feature_importances_": "@property\ndef feature_importances_(self):\n    \"\"\"\n    The impurity-based feature importances.\n\n    The higher, the more important the feature.\n    The importance of a feature is computed as the (normalized)\n    total reduction of the criterion brought by that feature.  It is also\n    known as the Gini importance.\n\n    Warning: impurity-based feature importances can be misleading for\n    high cardinality features (many unique values). See\n    :func:`sklearn.inspection.permutation_importance` as an alternative.\n\n    Returns\n    -------\n    feature_importances_ : ndarray of shape (n_features,)\n        The values of this array sum to 1, unless all trees are single node\n        trees consisting of only the root node, in which case it will be an\n        array of zeros.\n    \"\"\"\n    check_is_fitted(self)\n\n    all_importances = Parallel(n_jobs=self.n_jobs, prefer=\"threads\")(\n        delayed(getattr)(tree, \"feature_importances_\")\n        for tree in self.estimators_\n        if tree.tree_.node_count > 1\n    )\n\n    if not all_importances:\n        return np.zeros(self.n_features_in_, dtype=np.float64)\n\n    all_importances = np.mean(all_importances, axis=0, dtype=np.float64)\n    return all_importances / np.sum(all_importances)",
    "scikit-learn.sklearn.pipeline.named_steps": "@property\ndef named_steps(self):\n    \"\"\"Access the steps by name.\n\n    Read-only attribute to access any step by given name.\n    Keys are steps names and values are the steps objects.\"\"\"\n    # Use Bunch object to improve autocomplete\n    return Bunch(**dict(self.steps))",
    "scikit-learn.sklearn.svm._base.coef_": "@property\ndef coef_(self):\n    \"\"\"Weights assigned to the features when `kernel=\"linear\"`.\n\n    Returns\n    -------\n    ndarray of shape (n_features, n_classes)\n    \"\"\"\n    if self.kernel != \"linear\":\n        raise AttributeError(\"coef_ is only available when using a linear kernel\")\n\n    coef = self._get_coef()\n\n    # coef_ being a read-only property, it's better to mark the value as\n    # immutable to avoid hiding potential bugs for the unsuspecting user.\n    if sp.issparse(coef):\n        # sparse matrix do not have global flags\n        coef.data.flags.writeable = False\n    else:\n        # regular dense array\n        coef.flags.writeable = False\n    return coef",
    "scikit-learn.sklearn.utils._bunch.__getattr__": "def __getattr__(self, key):\n    try:\n        return self[key]\n    except KeyError:\n        raise AttributeError(key)",
    "scikit-learn.sklearn.utils.extmath.safe_sqr": "def safe_sqr(X, *, copy=True):\n    \"\"\"Element wise squaring of array-likes and sparse matrices.\n\n    Parameters\n    ----------\n    X : {array-like, ndarray, sparse matrix}\n\n    copy : bool, default=True\n        Whether to create a copy of X and operate on it or to perform\n        inplace computation (default behaviour).\n\n    Returns\n    -------\n    X ** 2 : element wise square\n         Return the element-wise square of the input.\n\n    Examples\n    --------\n    >>> from sklearn.utils import safe_sqr\n    >>> safe_sqr([1, 2, 3])\n    array([1, 4, 9])\n    \"\"\"\n    X = check_array(X, accept_sparse=[\"csr\", \"csc\", \"coo\"], ensure_2d=False)\n    if sparse.issparse(X):\n        if copy:\n            X = X.copy()\n        X.data **= 2\n    else:\n        if copy:\n            X = X**2\n        else:\n            X **= 2\n    return X"
}