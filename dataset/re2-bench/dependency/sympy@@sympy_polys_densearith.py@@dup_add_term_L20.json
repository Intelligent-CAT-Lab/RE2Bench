{
    "sympy.sympy.external.pythonmpq.__bool__": "def __bool__(self):\n    \"\"\"True/False if nonzero/zero\"\"\"\n    return bool(self.numerator)",
    "sympy.sympy.external.pythonmpq.__add__": "def __add__(self, other):\n    \"\"\"q1 + q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        #\n        # This is much faster than the naive method used in the stdlib\n        # fractions module. Not sure where this method comes from\n        # though...\n        #\n        # Compare timings for something like:\n        #   nums = range(1000)\n        #   rats = [PythonMPQ(n, d) for n, d in zip(nums[:-5], nums[5:])]\n        #   sum(rats) # <-- time this\n        #\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq + aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 + bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.polys.agca.extensions.__bool__": "def __bool__(f):\n    return bool(f.rep)",
    "sympy.sympy.polys.densebasic.dup_strip": "def dup_strip(f: dup[Er], K: Domain[Er] | None = None) -> dup[Er]:\n    \"\"\"\n    Remove leading zeros from ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dup_strip\n\n    >>> dup_strip([0, 0, 1, 2, 3, 0], ZZ)\n    [1, 2, 3, 0]\n\n    \"\"\"\n    if not f or f[0]:\n        return f\n\n    i = 0\n\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n\n    return f[i:]",
    "sympy.sympy.polys.domains.expressiondomain.__bool__": "def __bool__(f):\n    return not f.ex.is_zero",
    "sympy.sympy.polys.domains.expressiondomain.__add__": "def __add__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n    elif g == EX.zero:\n        return f\n    elif f == EX.zero:\n        return g\n    else:\n        return f.simplify(f.ex + g.ex)",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.gaussiandomains.__bool__": "def __bool__(self) -> bool:\n    return bool(self.x) or bool(self.y)",
    "sympy.sympy.polys.domains.gaussiandomains.__add__": "def __add__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x + x, self.y + y)",
    "sympy.sympy.polys.domains.modularinteger.__bool__": "def __bool__(self):\n    return bool(self.val)",
    "sympy.sympy.polys.domains.modularinteger.__add__": "def __add__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val + val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.fields.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    "sympy.sympy.polys.fields.__add__": "def __add__(f, g):\n    \"\"\"Add rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not g:\n        return f\n    elif not f:\n        return g\n    elif field.is_element(g):\n        if f.denom == g.denom:\n            return f.new(f.numer + g.numer, f.denom)\n        else:\n            return f.new(f.numer*g.denom + f.denom*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer + f.denom*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__radd__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__radd__(f)\n\n    return f.__radd__(g)",
    "sympy.sympy.polys.polyclasses.__add__": "def __add__(f, g):\n    if isinstance(g, ANP):\n        return f.add(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.add_ground(g)",
    "sympy.sympy.polys.polyclasses.__bool__": "def __bool__(f):\n    return bool(f._rep)",
    "sympy.sympy.polys.rings.__add__": "def __add__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Add two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> (x + y)**2 + (x - y)**2\n    2*x**2 + 2*y**2\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._add(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._add_ground(self)\n\n    res = self._try_add_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_add_ground(self)\n\n    return NotImplemented"
}