{
    "scikit-learn.sklearn.tree._classes._support_missing_values": "def _support_missing_values(self, X):\n    return (\n        not issparse(X)\n        and self.__sklearn_tags__().input_tags.allow_nan\n        and self.monotonic_cst is None\n    )",
    "scikit-learn.sklearn.utils.validation._assert_all_finite_element_wise": "def _assert_all_finite_element_wise(\n    X, *, xp, allow_nan, msg_dtype=None, estimator_name=None, input_name=\"\"\n):\n    # Cython implementation doesn't support FP16 or complex numbers\n    use_cython = (\n        xp is np and X.data.contiguous and X.dtype.type in {np.float32, np.float64}\n    )\n    if use_cython:\n        out = cy_isfinite(X.reshape(-1), allow_nan=allow_nan)\n        has_nan_error = False if allow_nan else out == FiniteStatus.has_nan\n        has_inf = out == FiniteStatus.has_infinite\n    else:\n        has_inf = xp.any(xp.isinf(X))\n        has_nan_error = False if allow_nan else xp.any(xp.isnan(X))\n    if has_inf or has_nan_error:\n        if has_nan_error:\n            type_err = \"NaN\"\n        else:\n            msg_dtype = msg_dtype if msg_dtype is not None else X.dtype\n            type_err = f\"infinity or a value too large for {msg_dtype!r}\"\n        padded_input_name = input_name + \" \" if input_name else \"\"\n        msg_err = f\"Input {padded_input_name}contains {type_err}.\"\n        if estimator_name and input_name == \"X\" and has_nan_error:\n            # Improve the error message on how to handle missing values in\n            # scikit-learn.\n            msg_err += (\n                f\"\\n{estimator_name} does not accept missing values\"\n                \" encoded as NaN natively. For supervised learning, you might want\"\n                \" to consider sklearn.ensemble.HistGradientBoostingClassifier and\"\n                \" Regressor which accept missing values encoded as NaNs natively.\"\n                \" Alternatively, it is possible to preprocess the data, for\"\n                \" instance by using an imputer transformer in a pipeline or drop\"\n                \" samples with missing values. See\"\n                \" https://scikit-learn.org/stable/modules/impute.html\"\n                \" You can find a list of all estimators that handle NaN values\"\n                \" at the following page:\"\n                \" https://scikit-learn.org/stable/modules/impute.html\"\n                \"#estimators-that-handle-nan-values\"\n            )\n        raise ValueError(msg_err)",
    "scikit-learn.sklearn.utils.validation.assert_all_finite": "def assert_all_finite(\n    X,\n    *,\n    allow_nan=False,\n    estimator_name=None,\n    input_name=\"\",\n):\n    \"\"\"Throw a ValueError if X contains NaN or infinity.\n\n    Parameters\n    ----------\n    X : {ndarray, sparse matrix}\n        The input data.\n\n    allow_nan : bool, default=False\n        If True, do not throw error when `X` contains NaN.\n\n    estimator_name : str, default=None\n        The estimator name, used to construct the error message.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message. In particular\n        if `input_name` is \"X\" and the data has NaN values and\n        allow_nan is False, the error message will link to the imputer\n        documentation.\n\n    Examples\n    --------\n    >>> from sklearn.utils import assert_all_finite\n    >>> import numpy as np\n    >>> array = np.array([1, np.inf, np.nan, 4])\n    >>> try:\n    ...     assert_all_finite(array)\n    ...     print(\"Test passed: Array contains only finite values.\")\n    ... except ValueError:\n    ...     print(\"Test failed: Array contains non-finite values.\")\n    Test failed: Array contains non-finite values.\n    \"\"\"\n    _assert_all_finite(\n        X.data if sp.issparse(X) else X,\n        allow_nan=allow_nan,\n        estimator_name=estimator_name,\n        input_name=input_name,\n    )"
}