{
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.logic.algorithms.lra_theory._assert_upper": "def _assert_upper(self, xi, ci, from_equality=False, from_neg=False):\n    \"\"\"\n    Adjusts the upper bound on variable xi if the new upper bound is\n    more limiting. The assignment of variable xi is adjusted to be\n    within the new bound if needed.\n\n    Also calls `self._update` to update the assignment for slack variables\n    to keep all equalities satisfied.\n    \"\"\"\n    if self.result:\n        assert self.result[0] != False\n    self.result = None\n    if ci >= xi.upper:\n        return None\n    if ci < xi.lower:\n        assert (xi.lower[1] >= 0) is True\n        assert (ci[1] <= 0) is True\n\n        lit1, neg1 = Boundary.from_lower(xi)\n\n        lit2 = Boundary(var=xi, const=ci[0], strict=ci[1] != 0, upper=True, equality=from_equality)\n        if from_neg:\n            lit2 = lit2.get_negated()\n        neg2 = -1 if from_neg else 1\n\n        conflict = [-neg1*self.boundary_to_enc[lit1], -neg2*self.boundary_to_enc[lit2]]\n        self.result = False, conflict\n        return self.result\n    xi.upper = ci\n    xi.upper_from_eq = from_equality\n    xi.upper_from_neg = from_neg\n    if xi in self.nonslack and xi.assign > ci:\n        self._update(xi, ci)\n\n    if self.run_checks and all(v.assign[0] != float(\"inf\") and v.assign[0] != -float(\"inf\")\n                               for v in self.all_var):\n        M = self.A\n        X = Matrix([v.assign[0] for v in self.all_var])\n        assert all(abs(val) < 10 ** (-10) for val in M * X)\n\n    return None",
    "sympy.sympy.logic.algorithms.lra_theory._assert_lower": "def _assert_lower(self, xi, ci, from_equality=False, from_neg=False):\n    \"\"\"\n    Adjusts the lower bound on variable xi if the new lower bound is\n    more limiting. The assignment of variable xi is adjusted to be\n    within the new bound if needed.\n\n    Also calls `self._update` to update the assignment for slack variables\n    to keep all equalities satisfied.\n    \"\"\"\n    if self.result:\n        assert self.result[0] != False\n    self.result = None\n    if ci <= xi.lower:\n        return None\n    if ci > xi.upper:\n        assert (xi.upper[1] <= 0) is True\n        assert (ci[1] >= 0) is True\n\n        lit1, neg1 = Boundary.from_upper(xi)\n\n        lit2 = Boundary(var=xi, const=ci[0], strict=ci[1] != 0, upper=False, equality=from_equality)\n        if from_neg:\n            lit2 = lit2.get_negated()\n        neg2 = -1 if from_neg else 1\n\n        conflict = [-neg1*self.boundary_to_enc[lit1],-neg2*self.boundary_to_enc[lit2]]\n        self.result = False, conflict\n        return self.result\n    xi.lower = ci\n    xi.lower_from_eq = from_equality\n    xi.lower_from_neg = from_neg\n    if xi in self.nonslack and xi.assign < ci:\n        self._update(xi, ci)\n\n    if self.run_checks and all(v.assign[0] != float(\"inf\") and v.assign[0] != -float(\"inf\")\n                               for v in self.all_var):\n        M = self.A\n        X = Matrix([v.assign[0] for v in self.all_var])\n        assert all(abs(val) < 10 ** (-10) for val in M * X)\n\n    return None",
    "sympy.sympy.logic.algorithms.lra_theory.__init__": "def __init__(self, rational, delta):\n    self.value = (rational, delta)",
    "sympy.sympy.logic.algorithms.lra_theory.__hash__": "def __hash__(self):\n    return hash(self.var)"
}