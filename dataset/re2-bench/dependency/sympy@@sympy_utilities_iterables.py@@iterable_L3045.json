{
    "sympy.sympy.core.containers.__iter__": "def __iter__(self):\n    return iter(self.args)",
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.functions.elementary.piecewise.__iter__": "def __iter__(self):\n    yield self.expr\n    yield self.cond",
    "sympy.sympy.geometry.point.__iter__": "def __iter__(self):\n    return self.args.__iter__()",
    "sympy.sympy.polys.agca.modules.__iter__": "def __iter__(self):\n    return self.data.__iter__()",
    "sympy.sympy.polys.monomials.__iter__": "def __iter__(self):\n    return iter(self.exponents)",
    "sympy.sympy.polys.polytools.__iter__": "def __iter__(self):\n    if self._options.polys:\n        return iter(self.polys)\n    else:\n        return iter(self.exprs)",
    "sympy.sympy.polys.puiseux.itermonoms": "def itermonoms(self) -> Iterator[MonQ]:\n    \"\"\"Iterate over the monomials of a Puiseux polynomial.\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.puiseux import puiseux_ring\n    >>> R, x, y = puiseux_ring('x, y', QQ)\n    >>> p = 5*x**2 + 7*y**3\n    >>> list(p.itermonoms())\n    [(2, 0), (0, 3)]\n    >>> p[(2, 0)]\n    5\n    \"\"\"\n    monom, ns = self.monom, self.ns\n    for m in self.poly.itermonoms():\n        yield self._monom_fromint(m, monom, ns)",
    "sympy.sympy.polys.puiseux.__iter__": "def __iter__(self) -> Iterator[MonQ]:\n    return self.itermonoms()",
    "sympy.sympy.sets.fancysets.__iter__": "def __iter__(self):\n    n = self.size  # validate\n    if not (n.has(S.Infinity) or n.has(S.NegativeInfinity) or n.is_Integer):\n        raise TypeError(\"Cannot iterate over symbolic Range\")\n    if self.start in [S.NegativeInfinity, S.Infinity]:\n        raise TypeError(\"Cannot iterate over Range with infinite start\")\n    elif self.start != self.stop:\n        i = self.start\n        if n.is_infinite:\n            while True:\n                yield i\n                i += self.step\n        else:\n            for _ in range(n):\n                yield i\n                i += self.step",
    "sympy.sympy.sets.sets.__iter__": "def __iter__(self):\n    \"\"\"\n    A method which implements is_iterable property method.\n    If self.is_iterable returns True (both constituent sets are iterable),\n    then return the Cartesian Product. Otherwise, raise TypeError.\n    \"\"\"\n    return iproduct(*self.sets)",
    "sympy.sympy.simplify.cse_main.<genexpr>": "symbols = (_ for _ in symbols if _.name not in excluded_symbols)\n\n",
    "sympy.sympy.stats.frv.<lambda>": "__iter__ = property(lambda self: self.dict.__iter__)\n",
    "sympy.sympy.stats.rv.__getattr__": "def __getattr__(self, attr):\n    try:\n        return self.args[self._argnames.index(attr)]\n    except ValueError:\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n            type(self).__name__, attr))",
    "sympy.sympy.tensor.array.ndim_array.__iter__": "def __iter__(self):\n    def iterator():\n        if self._shape:\n            for i in range(self._shape[0]):\n                yield self[i]\n        else:\n            yield self[()]\n\n    return iterator()",
    "sympy.sympy.tensor.array.ndim_array.iterator": "def iterator():\n    if self._shape:\n        for i in range(self._shape[0]):\n            yield self[i]\n    else:\n        yield self[()]",
    "sympy.sympy.utilities.iterables.iproduct": "def iproduct(*iterables):\n    '''\n    Cartesian product of iterables.\n\n    Generator of the Cartesian product of iterables. This is analogous to\n    itertools.product except that it works with infinite iterables and will\n    yield any item from the infinite product eventually.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import iproduct\n    >>> sorted(iproduct([1,2], [3,4]))\n    [(1, 3), (1, 4), (2, 3), (2, 4)]\n\n    With an infinite iterator:\n\n    >>> from sympy import S\n    >>> (3,) in iproduct(S.Integers)\n    True\n    >>> (3, 4) in iproduct(S.Integers, S.Integers)\n    True\n\n    .. seealso::\n\n       `itertools.product\n       <https://docs.python.org/3/library/itertools.html#itertools.product>`_\n    '''\n    if len(iterables) == 0:\n        yield ()\n        return\n    elif len(iterables) == 1:\n        for e in iterables[0]:\n            yield (e,)\n    elif len(iterables) == 2:\n        yield from _iproduct2(*iterables)\n    else:\n        first, others = iterables[0], iterables[1:]\n        for ef, eo in _iproduct2(first, iproduct(*others)):\n            yield (ef,) + eo",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1",
    "sympy.sympy.vector.coordsysrect.__iter__": "def __iter__(self):\n    return iter(self.base_vectors())"
}