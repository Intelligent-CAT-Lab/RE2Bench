{
    "sympy.sympy.external.pythonmpq.__mul__": "def __mul__(self, other):\n    \"\"\"q1 * q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = ((ap//x1)*(bp//x2), (aq//x2)*(bq//x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator*(other//x)\n        q = self.denominator//x\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.polys.densearith.dmp_max_norm": "def dmp_max_norm(f: dmp[Eordered], u: int, K: Domain[Eordered]) -> Eordered:\n    \"\"\"\n    Returns maximum norm of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_max_norm(2*x*y - x - 3)\n    3\n\n    \"\"\"\n    if not u:\n        return dup_max_norm(_dup(f), K)\n\n    v = u - 1\n\n    return max(dmp_max_norm(c, v, K) for c in f)",
    "sympy.sympy.polys.densearith.dmp_quo_ground": "def dmp_quo_ground(\n    f: dmp[Er], c: Er, u: int, K: Domain[Er]\n) -> dmp[Er]:\n    \"\"\"\n    Quotient by a constant in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, ZZ(2))\n    x**2*y + x\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, QQ(2))\n    x**2*y + 3/2*x\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_quo_ground(_dup(f), c, K))\n\n    v = u - 1\n\n    return [ dmp_quo_ground(cf, c, v, K) for cf in f ]",
    "sympy.sympy.polys.densebasic.dmp_from_dict": "def dmp_from_dict(f: dict[tuple[int, ...], Er], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Create a ``K[X]`` polynomial from a ``dict``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_from_dict\n\n    >>> dmp_from_dict({(0, 0): ZZ(3), (0, 1): ZZ(2), (2, 1): ZZ(1)}, 1, ZZ)\n    [[1, 0], [], [2, 3]]\n    >>> dmp_from_dict({}, 0, ZZ)\n    []\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_from_dict(f, K))\n    if not f:\n        return dmp_zero(u, K)\n\n    coeffs: dict[int, dict[monom, Er]] = {}\n\n    for monom, coeff in f.items():\n        head, tail = monom[0], monom[1:]\n\n        if head in coeffs:\n            coeffs[head][tail] = coeff\n        else:\n            coeffs[head] = {tail: coeff}\n\n    n = max(coeffs.keys())\n    v = u - 1\n    h: dmp[Er] = []\n\n    for k in range(n, -1, -1):\n        dcoeff = coeffs.get(k)\n\n        if dcoeff is not None:\n            h.append(dmp_from_dict(dcoeff, v, K))\n        else:\n            h.append(dmp_zero(v, K))\n\n    return dmp_strip(h, u, K)",
    "sympy.sympy.polys.densebasic.dmp_exclude": "def dmp_exclude(f: dmp[Er], u: int, K: Domain[Er]) -> tuple[list[int], dmp[Er], int]:\n    \"\"\"\n    Exclude useless levels from ``f``.\n\n    Return the levels excluded, the new excluded ``f``, and the new ``u``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_exclude\n\n    >>> f = ZZ.map([[[1]], [[1], [2]]])\n\n    >>> dmp_exclude(f, 2, ZZ)\n    ([2], [[1], [1, 2]], 1)\n\n    \"\"\"\n    if not u or dmp_ground_p(f, None, u):\n        return [], f, u\n\n    J: list[int] = []\n    F = dmp_to_dict(f, u, K)\n\n    for j in range(0, u + 1):\n        for monom in F.keys():\n            if monom[j]:\n                break\n        else:\n            J.append(j)\n\n    if not J:\n        return [], f, u\n\n    d: dict[tuple[int, ...], Er] = {}\n\n    for monom, coeff in F.items():\n        lmonom = list(monom)\n\n        for j in reversed(J):\n            del lmonom[j]\n\n        d[tuple(lmonom)] = coeff\n\n    u -= len(J)\n\n    return J, dmp_from_dict(d, u, K), u",
    "sympy.sympy.polys.densebasic.dmp_include": "def dmp_include(f: dmp[Er], J: list[int], u: int, K: Domain[Er]) -> dmp[Er]:\n    \"\"\"\n    Include useless levels in ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_include\n\n    >>> f = ZZ.map([[1], [1, 2]])\n\n    >>> dmp_include(f, [2], 1, ZZ)\n    [[[1]], [[1], [2]]]\n\n    \"\"\"\n    if not J:\n        return f\n\n    F: dict[tuple[int, ...], Er] = dmp_to_dict(f, u, K)\n    d: dict[tuple[int, ...], Er] = {}\n\n    for monom, coeff in F.items():\n        lmonom = list(monom)\n\n        for j in J:\n            lmonom.insert(j, 0)\n\n        d[tuple(lmonom)] = coeff\n\n    u += len(J)\n\n    return dmp_from_dict(d, u, K)",
    "sympy.sympy.polys.densebasic.dmp_inject": "def dmp_inject(\n    f: dmp[Er], u: int, K: RingExtension[Er, Eg], front: bool = False\n) -> tuple[dmp[Eg], int]:\n    \"\"\"\n    Convert ``f`` from ``K[X][Y]`` to ``K[X,Y]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_inject\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> dmp_inject([R(1), x + 2], 0, R.to_domain())\n    ([[[1]], [[1], [2]]], 2)\n    >>> dmp_inject([R(1), x + 2], 0, R.to_domain(), front=True)\n    ([[[1]], [[1, 2]]], 2)\n\n    \"\"\"\n    d: dict[monom, Er]\n    h: dict[monom, Eg]\n\n    d = dmp_to_dict(f, u, K)\n    h = {}\n\n    v = K.ngens - 1\n\n    for f_monom, gd in d.items():\n        g = K.to_dict(gd)\n\n        for g_monom, c in g.items():\n            if front:\n                h[g_monom + f_monom] = c\n            else:\n                h[f_monom + g_monom] = c\n\n    w = u + v + 1\n\n    return dmp_from_dict(h, w, K.dom), w",
    "sympy.sympy.polys.densebasic.dmp_eject": "def dmp_eject(\n    f: dmp[Er], u: int, K: PolynomialRing[Er], front: bool = False\n) -> dmp[PolyElement[Er]]:\n    \"\"\"\n    Convert ``f`` from ``K[X,Y]`` to ``K[X][Y]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_eject\n\n    >>> dmp_eject([[[1]], [[1], [2]]], 2, ZZ['x', 'y'])\n    [1, x + 2]\n\n    \"\"\"\n    d: dict[monom, Er]\n    h: dict[monom, dict[monom, Er]]\n\n    d = dmp_to_dict(f, u, K.dom)\n    h = {}\n\n    n = K.ngens\n    v = u - K.ngens + 1\n\n    for monom, c in d.items():\n        if front:\n            g_monom, f_monom = monom[:n], monom[n:]\n        else:\n            g_monom, f_monom = monom[-n:], monom[:-n]\n\n        if f_monom in h:\n            h[f_monom][g_monom] = c\n        else:\n            h[f_monom] = {g_monom: c}\n\n    g = {monom: K(c) for monom, c in h.items()}\n\n    return dmp_from_dict(g, v - 1, K)",
    "sympy.sympy.polys.densebasic.dmp_terms_gcd": "def dmp_terms_gcd(f: dmp[Er], u: int, K: Domain[Er]) -> tuple[tuple[int, ...], dmp[Er]]:\n    \"\"\"\n    Remove GCD of terms from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_terms_gcd\n\n    >>> f = ZZ.map([[1, 0], [1, 0, 0], [], []])\n\n    >>> dmp_terms_gcd(f, 1, ZZ)\n    ((2, 1), [[1], [1, 0]])\n\n    \"\"\"\n    if dmp_ground_TC(f, u, K) or dmp_zero_p(f, u):\n        return (0,) * (u + 1), f\n\n    F: dict[monom, Er] = dmp_to_dict(f, u, K)\n    G = monomial_min(*list(F.keys()))\n\n    if all(g == 0 for g in G):\n        return G, f\n\n    d: dict[monom, Er] = {}\n\n    for monom, coeff in F.items():\n        d[monomial_ldiv(monom, G)] = coeff\n\n    return G, dmp_from_dict(d, u, K)",
    "sympy.sympy.polys.densebasic.dmp_convert": "def dmp_convert(f: dmp[Er], u: int, K0: Domain[Er] | None, K1: Domain[Es]) -> dmp[Es]:\n    \"\"\"\n    Convert the ground domain of ``f`` from ``K0`` to ``K1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_convert\n\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> dmp_convert([[R(1)], [R(2)]], 1, R.to_domain(), ZZ)\n    [[1], [2]]\n    >>> dmp_convert([[ZZ(1)], [ZZ(2)]], 1, ZZ, R.to_domain())\n    [[1], [2]]\n\n    \"\"\"\n    if not u:\n        return _dmp(dup_convert(_dup(f), K0, K1))\n    if K0 is not None and K0 == K1:\n        return cast('dmp[Es]', f)\n\n    v = u - 1\n\n    return dmp_strip([dmp_convert(c, v, K0, K1) for c in f], u, K1)",
    "sympy.sympy.polys.densetools.dmp_clear_denoms": "def dmp_clear_denoms(f, u, K0, K1=None, convert=False):\n    \"\"\"\n    Clear denominators, i.e. transform ``K_0`` to ``K_1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,2)*x + QQ(1,3)*y + 1\n\n    >>> R.dmp_clear_denoms(f, convert=False)\n    (6, 3*x + 2*y + 6)\n    >>> R.dmp_clear_denoms(f, convert=True)\n    (6, 3*x + 2*y + 6)\n\n    \"\"\"\n    if not u:\n        return dup_clear_denoms(f, K0, K1, convert=convert)\n\n    if K1 is None:\n        if K0.has_assoc_Ring:\n            K1 = K0.get_ring()\n        else:\n            K1 = K0\n\n    common = _rec_clear_denoms(f, u, K0, K1)\n\n    if not K1.is_one(common):\n        f = dmp_mul_ground(f, common, u, K0)\n\n    if not convert:\n        return common, f\n    else:\n        return common, dmp_convert(f, u, K0, K1)",
    "sympy.sympy.polys.densetools.dmp_ground_primitive": "def dmp_ground_primitive(f: dmp[Er], u: int, K: Domain[Er]) -> tuple[Er, dmp[Er]]:\n    \"\"\"\n    Compute content and the primitive form of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    \"\"\"\n    if not u:\n        cont, fu = dup_primitive(_dup(f), K)\n        return cont, _dmp(fu)\n\n    if dmp_zero_p(f, u):\n        return K.zero, f\n\n    cont = dmp_ground_content(f, u, K)\n\n    if K.is_one(cont):\n        return cont, f\n    else:\n        return cont, dmp_quo_ground(f, cont, u, K)",
    "sympy.sympy.polys.domains.compositedomain.is_Exact": "@property\ndef is_Exact(self):\n    \"\"\"Returns ``True`` if this domain is exact. \"\"\"\n    return self.domain.is_Exact",
    "sympy.sympy.polys.domains.domain.mul": "def mul(self, a: Er, b: Er) -> Er:\n    \"\"\"Product of ``a`` and ``b``, implies ``__mul__``.  \"\"\"\n    return a * b",
    "sympy.sympy.polys.domains.domain.pow": "def pow(self, a: Er, b: int) -> Er:\n    \"\"\"Raise ``a`` to power ``b``, implies ``__pow__``.  \"\"\"\n    return a ** b",
    "sympy.sympy.polys.domains.domain.__str__": "def __str__(self) -> str:\n    return self.rep",
    "sympy.sympy.polys.domains.domain.convert": "def convert(self,\n            element: Es | Expr | complex,\n            base: Domain[Es] | None = None\n            ) -> Er:\n    \"\"\"Convert ``element`` to ``self.dtype``. \"\"\"\n\n    if base is not None:\n        if _not_a_coeff(element):\n            raise CoercionFailed('%s is not in any domain' % element)\n        return self.convert_from(element, base) # type: ignore\n\n    if self.of_type(element):\n        return element\n\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ) # type: ignore\n\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n\n    if GROUND_TYPES != 'python':\n        if isinstance(element, ZZ.tp):\n            return self.convert_from(element, ZZ) # type: ignore\n        if isinstance(element, QQ.tp):\n            return self.convert_from(element, QQ) # type: ignore\n\n    if isinstance(element, float):\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if isinstance(element, complex):\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if type(element).__name__ == 'mpf':\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if type(element).__name__ == 'mpc':\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n\n    # TODO: implement this in from_ methods\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC()) # type: ignore\n\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    else: # TODO: remove this branch\n        if not is_sequence(element):\n            try:\n                element = sympify(element, strict=True) # type: ignore\n                if isinstance(element, Basic):\n                    return self.from_sympy(element) # type: ignore\n            except (TypeError, ValueError):\n                pass\n\n    raise CoercionFailed(\"Cannot convert %s of type %s to %s\" % (element, type(element), self))",
    "sympy.sympy.polys.domains.expressiondomain.get_ring": "def get_ring(self):\n    \"\"\"Returns a ring associated with ``self``. \"\"\"\n    return self  # XXX: EX is not a ring but we don't have much choice here.",
    "sympy.sympy.polys.domains.gaussiandomains.__mul__": "def __mul__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x*x - self.y*y, self.x*y + self.y*x)",
    "sympy.sympy.polys.domains.polynomialring.one": "@property\ndef one(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.one",
    "sympy.sympy.polys.domains.rationalfield.quo": "def quo(self, a, b):\n    \"\"\"Quotient of ``a`` and ``b``, implies ``__truediv__``. \"\"\"\n    return MPQ(a) / MPQ(b)",
    "sympy.sympy.polys.domains.rationalfield.get_ring": "def get_ring(self):\n    \"\"\"Returns ring associated with ``self``. \"\"\"\n    from sympy.polys.domains import ZZ\n    return ZZ",
    "sympy.sympy.polys.domains.realfield.get_exact": "def get_exact(self):\n    \"\"\"Returns an exact domain associated with ``self``. \"\"\"\n    from sympy.polys.domains import QQ\n    return QQ",
    "sympy.sympy.polys.factortools.dmp_zz_factor": "def dmp_zz_factor(f, u, K):\n    r\"\"\"\n    Factor (non square-free) polynomials in `Z[X]`.\n\n    Given a multivariate polynomial `f` in `Z[x]` computes its complete\n    factorization `f_1, \\dots, f_n` into irreducibles over integers::\n\n                 f = content(f) f_1**k_1 ... f_n**k_n\n\n    The factorization is computed by reducing the input polynomial\n    into a primitive square-free polynomial and factoring it using\n    Enhanced Extended Zassenhaus (EEZ) algorithm. Trial division\n    is used to recover the multiplicities of factors.\n\n    The result is returned as a tuple consisting of::\n\n             (content(f), [(f_1, k_1), ..., (f_n, k_n))\n\n    Consider polynomial `f = 2*(x**2 - y**2)`::\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x,y = ring(\"x,y\", ZZ)\n\n        >>> R.dmp_zz_factor(2*x**2 - 2*y**2)\n        (2, [(x - y, 1), (x + y, 1)])\n\n    In result we got the following factorization::\n\n                    f = 2 (x - y) (x + y)\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    if not u:\n        return dup_zz_factor(f, K)\n\n    if dmp_zero_p(f, u):\n        return K.zero, []\n\n    cont, g = dmp_ground_primitive(f, u, K)\n\n    if dmp_ground_LC(g, u, K) < 0:\n        cont, g = -cont, dmp_neg(g, u, K)\n\n    if all(d <= 0 for d in dmp_degree_list(g, u)):\n        return cont, []\n\n    G, g = dmp_primitive(g, u, K)\n\n    factors = []\n\n    if dmp_degree(g, u) > 0:\n        g = dmp_sqf_part(g, u, K)\n        H = dmp_zz_wang(g, u, K)\n        factors = dmp_trial_division(f, H, u, K)\n\n    for g, k in dmp_zz_factor(G, u - 1, K)[1]:\n        factors.insert(0, ([g], k))\n\n    _dmp_check_degrees(f, u, factors)\n\n    return cont, _sort_factors(factors)",
    "sympy.sympy.polys.factortools.dmp_qq_i_factor": "def dmp_qq_i_factor(f, u, K0):\n    \"\"\"Factor multivariate polynomials into irreducibles in `QQ_I[X]`. \"\"\"\n    # Factor in QQ<I>\n    K1 = K0.as_AlgebraicField()\n    f = dmp_convert(f, u, K0, K1)\n    coeff, factors = dmp_factor_list(f, u, K1)\n    factors = [(dmp_convert(fac, u, K1, K0), i) for fac, i in factors]\n    coeff = K0.convert(coeff, K1)\n    return coeff, factors",
    "sympy.sympy.polys.factortools.dmp_zz_i_factor": "def dmp_zz_i_factor(f, u, K0):\n    \"\"\"Factor multivariate polynomials into irreducibles in `ZZ_I[X]`. \"\"\"\n    # First factor in QQ_I\n    K1 = K0.get_field()\n    f = dmp_convert(f, u, K0, K1)\n    coeff, factors = dmp_qq_i_factor(f, u, K1)\n\n    new_factors = []\n    for fac, i in factors:\n        # Extract content\n        fac_denom, fac_num = dmp_clear_denoms(fac, u, K1)\n        fac_num_ZZ_I = dmp_convert(fac_num, u, K1, K0)\n        content, fac_prim = dmp_ground_primitive(fac_num_ZZ_I, u, K0)\n\n        coeff = (coeff * content ** i) // fac_denom ** i\n        new_factors.append((fac_prim, i))\n\n    factors = new_factors\n    coeff = K0.convert(coeff, K1)\n    return coeff, factors",
    "sympy.sympy.polys.factortools.dmp_ext_factor": "def dmp_ext_factor(f, u, K):\n    r\"\"\"Factor multivariate polynomials over algebraic number fields.\n\n    The domain `K` must be an algebraic number field `k(a)` (see :ref:`QQ(a)`).\n\n    Examples\n    ========\n\n    First define the algebraic number field `K = \\mathbb{Q}(\\sqrt{2})`:\n\n    >>> from sympy import QQ, sqrt\n    >>> from sympy.polys.factortools import dmp_ext_factor\n    >>> K = QQ.algebraic_field(sqrt(2))\n\n    We can now factorise the polynomial `x^2 y^2 - 2` over `K`:\n\n    >>> p = [[K(1),K(0),K(0)], [], [K(-2)]] # x**2*y**2 - 2\n    >>> p1 = [[K(1),K(0)], [-K.unit]]       # x*y - sqrt(2)\n    >>> p2 = [[K(1),K(0)], [+K.unit]]       # x*y + sqrt(2)\n    >>> dmp_ext_factor(p, 1, K) == (K.one, [(p1, 1), (p2, 1)])\n    True\n\n    Usually this would be done at a higher level:\n\n    >>> from sympy import factor\n    >>> from sympy.abc import x, y\n    >>> factor(x**2*y**2 - 2, extension=sqrt(2))\n    (x*y - sqrt(2))*(x*y + sqrt(2))\n\n    Explanation\n    ===========\n\n    This is Trager's algorithm for multivariate polynomials. In particular this\n    function is algorithm ``alg_factor`` from [Trager76]_.\n\n    See :func:`dup_ext_factor` for explanation.\n\n    See Also\n    ========\n\n    dup_ext_factor:\n        Analogous function for univariate polynomials over ``k(a)``.\n    dmp_sqf_norm:\n        Multivariate version of subroutine ``sqfr_norm`` also from [Trager76]_.\n    sympy.polys.polytools.factor:\n        The high-level function that ultimately uses this function as needed.\n    \"\"\"\n    if not u:\n        return dup_ext_factor(f, K)\n\n    lc = dmp_ground_LC(f, u, K)\n    f = dmp_ground_monic(f, u, K)\n\n    if all(d <= 0 for d in dmp_degree_list(f, u)):\n        return lc, []\n\n    f, F = dmp_sqf_part(f, u, K), f\n    s, g, r = dmp_sqf_norm(f, u, K)\n\n    factors = dmp_factor_list_include(r, u, K.dom)\n\n    if len(factors) == 1:\n        factors = [f]\n    else:\n        for i, (factor, _) in enumerate(factors):\n            h = dmp_convert(factor, u, K.dom, K)\n            h, _, g = dmp_inner_gcd(h, g, u, K)\n            a = [si*K.unit for si in s]\n            h = dmp_shift(h, a, u, K)\n            factors[i] = h\n\n    result = dmp_trial_division(F, factors, u, K)\n\n    _dmp_check_degrees(F, u, result)\n\n    return lc, result",
    "sympy.sympy.polys.factortools.dmp_gf_factor": "def dmp_gf_factor(f, u, K):\n    \"\"\"Factor multivariate polynomials over finite fields. \"\"\"\n    raise NotImplementedError('multivariate polynomials over finite fields')",
    "sympy.sympy.polys.factortools.dup_factor_list": "def dup_factor_list(f, K0):\n    \"\"\"Factor univariate polynomials into irreducibles in `K[x]`. \"\"\"\n    j, f = dup_terms_gcd(f, K0)\n    cont, f = dup_primitive(f, K0)\n\n    if K0.is_FiniteField:\n        coeff, factors = dup_gf_factor(f, K0)\n    elif K0.is_Algebraic:\n        coeff, factors = dup_ext_factor(f, K0)\n    elif K0.is_GaussianRing:\n        coeff, factors = dup_zz_i_factor(f, K0)\n    elif K0.is_GaussianField:\n        coeff, factors = dup_qq_i_factor(f, K0)\n    else:\n        if not K0.is_Exact:\n            K0_inexact, K0 = K0, K0.get_exact()\n            f = dup_convert(f, K0_inexact, K0)\n        else:\n            K0_inexact = None\n\n        if K0.is_Field:\n            K = K0.get_ring()\n\n            denom, f = dup_clear_denoms(f, K0, K)\n            f = dup_convert(f, K0, K)\n        else:\n            K = K0\n\n        if K.is_ZZ:\n            coeff, factors = dup_zz_factor(f, K)\n        elif K.is_Poly:\n            f, u = dmp_inject(f, 0, K)\n\n            coeff, factors = dmp_factor_list(f, u, K.dom)\n\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_eject(f, u, K), k)\n\n            coeff = K.convert(coeff, K.dom)\n        else:  # pragma: no cover\n            raise DomainError('factorization not supported over %s' % K0)\n\n        if K0.is_Field:\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dup_convert(f, K, K0), k)\n\n            coeff = K0.convert(coeff, K)\n            coeff = K0.quo(coeff, denom)\n\n            if K0_inexact:\n                for i, (f, k) in enumerate(factors):\n                    max_norm = dup_max_norm(f, K0)\n                    f = dup_quo_ground(f, max_norm, K0)\n                    f = dup_convert(f, K0, K0_inexact)\n                    factors[i] = (f, k)\n                    coeff = K0.mul(coeff, K0.pow(max_norm, k))\n\n                coeff = K0_inexact.convert(coeff, K0)\n                K0 = K0_inexact\n\n    if j:\n        factors.insert(0, ([K0.one, K0.zero], j))\n\n    return coeff*cont, _sort_factors(factors)",
    "sympy.sympy.polys.factortools.dmp_factor_list": "def dmp_factor_list(f, u, K0):\n    \"\"\"Factor multivariate polynomials into irreducibles in `K[X]`. \"\"\"\n    if not u:\n        return dup_factor_list(f, K0)\n\n    J, f = dmp_terms_gcd(f, u, K0)\n    cont, f = dmp_ground_primitive(f, u, K0)\n\n    if K0.is_FiniteField:  # pragma: no cover\n        coeff, factors = dmp_gf_factor(f, u, K0)\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n    elif K0.is_GaussianRing:\n        coeff, factors = dmp_zz_i_factor(f, u, K0)\n    elif K0.is_GaussianField:\n        coeff, factors = dmp_qq_i_factor(f, u, K0)\n    else:\n        if not K0.is_Exact:\n            K0_inexact, K0 = K0, K0.get_exact()\n            f = dmp_convert(f, u, K0_inexact, K0)\n        else:\n            K0_inexact = None\n\n        if K0.is_Field:\n            K = K0.get_ring()\n\n            denom, f = dmp_clear_denoms(f, u, K0, K)\n            f = dmp_convert(f, u, K0, K)\n        else:\n            K = K0\n\n        if K.is_ZZ:\n            levels, f, v = dmp_exclude(f, u, K)\n            coeff, factors = dmp_zz_factor(f, v, K)\n\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_include(f, levels, v, K), k)\n        elif K.is_Poly:\n            f, v = dmp_inject(f, u, K)\n\n            coeff, factors = dmp_factor_list(f, v, K.dom)\n\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_eject(f, v, K), k)\n\n            coeff = K.convert(coeff, K.dom)\n        else:  # pragma: no cover\n            raise DomainError('factorization not supported over %s' % K0)\n\n        if K0.is_Field:\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_convert(f, u, K, K0), k)\n\n            coeff = K0.convert(coeff, K)\n            coeff = K0.quo(coeff, denom)\n\n            if K0_inexact:\n                for i, (f, k) in enumerate(factors):\n                    max_norm = dmp_max_norm(f, u, K0)\n                    f = dmp_quo_ground(f, max_norm, u, K0)\n                    f = dmp_convert(f, u, K0, K0_inexact)\n                    factors[i] = (f, k)\n                    coeff = K0.mul(coeff, K0.pow(max_norm, k))\n\n                coeff = K0_inexact.convert(coeff, K0)\n                K0 = K0_inexact\n\n    for i, j in enumerate(reversed(J)):\n        if not j:\n            continue\n\n        term = {(0,)*(u - i) + (1,) + (0,)*i: K0.one}\n        factors.insert(0, (dmp_from_dict(term, u, K0), j))\n\n    return coeff*cont, _sort_factors(factors)",
    "sympy.sympy.polys.polyclasses.__mul__": "def __mul__(f, g):\n    if isinstance(g, ANP):\n        return f.mul(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.mul_ground(g)",
    "sympy.sympy.polys.polyutils._sort_factors": "def _sort_factors(factors, **args):\n    \"\"\"Sort low-level factors in increasing 'complexity' order. \"\"\"\n\n    # XXX: GF(p) does not support comparisons so we need a key function to sort\n    # the factors if python-flint is being used. A better solution might be to\n    # add a sort key method to each domain.\n    def order_key(factor):\n        if isinstance(factor, _GF_types):\n            return int(factor)\n        elif isinstance(factor, list):\n            return [order_key(f) for f in factor]\n        else:\n            return factor\n\n    def order_if_multiple_key(factor):\n        (f, n) = factor\n        return (len(f), n, order_key(f))\n\n    def order_no_multiple_key(f):\n        return (len(f), order_key(f))\n\n    if args.get('multiple', True):\n        return sorted(factors, key=order_if_multiple_key)\n    else:\n        return sorted(factors, key=order_no_multiple_key)",
    "sympy.sympy.polys.rings.__mul__": "def __mul__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Multiply two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', QQ)\n    >>> p1 = x + y\n    >>> p2 = x - y\n    >>> p1*p2\n    x**2 - y**2\n\n    \"\"\"\n    if not self or not other:\n        return self.ring.zero\n\n    if self.ring.is_element(other):\n        return self._mul(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other).mul_ground(self)\n\n    res = self._try_mul_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_mul_ground(self)\n\n    return NotImplemented"
}