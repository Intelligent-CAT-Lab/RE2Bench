{
    "scikit-learn.sklearn.utils._encode.to_list": "def to_list(self):\n    \"\"\"Convert tuple to a list where None is always first.\"\"\"\n    output = []\n    if self.none:\n        output.append(None)\n    if self.nan:\n        output.append(np.nan)\n    return output",
    "scikit-learn.sklearn.utils._encode._extract_missing": "def _extract_missing(values):\n    \"\"\"Extract missing values from `values`.\n\n    Parameters\n    ----------\n    values: set\n        Set of values to extract missing from.\n\n    Returns\n    -------\n    output: set\n        Set with missing values extracted.\n\n    missing_values: MissingValues\n        Object with missing value information.\n    \"\"\"\n    missing_values_set = {\n        value for value in values if value is None or is_scalar_nan(value)\n    }\n\n    if not missing_values_set:\n        return values, MissingValues(nan=False, none=False)\n\n    if None in missing_values_set:\n        if len(missing_values_set) == 1:\n            output_missing_values = MissingValues(nan=False, none=True)\n        else:\n            # If there is more than one missing value, then it has to be\n            # float('nan') or np.nan\n            output_missing_values = MissingValues(nan=True, none=True)\n    else:\n        output_missing_values = MissingValues(nan=True, none=False)\n\n    # create set without the missing values\n    output = values - missing_values_set\n    return output, output_missing_values",
    "scikit-learn.sklearn.utils._encode._map_to_integer": "def _map_to_integer(values, uniques):\n    \"\"\"Map values based on its position in uniques.\"\"\"\n    xp, _ = get_namespace(values, uniques)\n    table = _nandict({val: i for i, val in enumerate(uniques)})\n    return xp.asarray([table[v] for v in values], device=device(values))",
    "scikit-learn.sklearn.utils._encode.<genexpr>": "types = sorted(t.__qualname__ for t in set(type(v) for v in values))\n",
    "scikit-learn.sklearn.utils._encode._get_counts": "def _get_counts(values, uniques):\n    \"\"\"Get the count of each of the `uniques` in `values`.\n\n    The counts will use the order passed in by `uniques`. For non-object dtypes,\n    `uniques` is assumed to be sorted and `np.nan` is at the end.\n    \"\"\"\n    if values.dtype.kind in \"OU\":\n        counter = _NaNCounter(values)\n        output = np.zeros(len(uniques), dtype=np.int64)\n        for i, item in enumerate(uniques):\n            with suppress(KeyError):\n                output[i] = counter[item]\n        return output\n\n    unique_values, counts = _unique_np(values, return_counts=True)\n\n    # Recorder unique_values based on input: `uniques`\n    uniques_in_values = np.isin(uniques, unique_values, assume_unique=True)\n    if np.isnan(unique_values[-1]) and np.isnan(uniques[-1]):\n        uniques_in_values[-1] = True\n\n    unique_valid_indices = np.searchsorted(unique_values, uniques[uniques_in_values])\n    output = np.zeros_like(uniques, dtype=np.int64)\n    output[uniques_in_values] = counts[unique_valid_indices]\n    return output"
}