{
    "sympy.sympy.polys.domains.fractionfield.get_ring": "def get_ring(self):\n    \"\"\"Returns a field associated with ``self``. \"\"\"\n    return self.field.to_ring().to_domain()",
    "sympy.sympy.polys.domains.fractionfield.denom": "def denom(self, a):\n    \"\"\"Returns denominator of ``a``. \"\"\"\n    return a.denom",
    "sympy.sympy.polys.domains.gaussiandomains.lcm": "def lcm(self, a: GaussianInteger, b: GaussianInteger) -> GaussianInteger:\n    \"\"\"Least common multiple of a and b over ZZ_I.\"\"\"\n    return (a * b) // self.gcd(a, b)",
    "sympy.sympy.polys.domains.gaussiandomains.get_ring": "def get_ring(self) -> GaussianIntegerRing:\n    \"\"\"Returns a ring associated with ``self``. \"\"\"\n    return ZZ_I",
    "sympy.sympy.polys.domains.gaussiandomains.denom": "def denom(self, a: GaussianRational) -> GaussianInteger:\n    \"\"\"Get the denominator of ``a``.\"\"\"\n    ZZ = self.dom.get_ring()\n    QQ = self.dom\n    ZZ_I = self.get_ring()\n    denom_ZZ = ZZ.lcm(QQ.denom(a.x), QQ.denom(a.y))\n    return ZZ_I(denom_ZZ, ZZ.zero)",
    "sympy.sympy.polys.domains.integerring.lcm": "def lcm(self, a, b):\n    \"\"\"Compute LCM of ``a`` and ``b``. \"\"\"\n    return lcm(a, b)",
    "sympy.sympy.polys.domains.polynomialring.lcm": "def lcm(self, a, b):\n    \"\"\"Returns LCM of `a` and `b`. \"\"\"\n    return a.lcm(b)",
    "sympy.sympy.polys.domains.polynomialring.one": "@property\ndef one(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.one",
    "sympy.sympy.polys.domains.rationalfield.denom": "def denom(self, a):\n    \"\"\"Returns denominator of ``a``. \"\"\"\n    return a.denominator",
    "sympy.sympy.polys.domains.rationalfield.get_ring": "def get_ring(self):\n    \"\"\"Returns ring associated with ``self``. \"\"\"\n    from sympy.polys.domains import ZZ\n    return ZZ",
    "sympy.sympy.polys.rings.new": "def new(self, init) -> PolyElement[Er]:\n    \"\"\"Create a new polynomial element in the same ring.\"\"\"\n    return self.__class__(self.ring, init)",
    "sympy.sympy.polys.rings.<listcomp>": "poly = self.new([(monom, coeff * common) for monom, coeff in self.items()])\n"
}