{
    "scikit-learn.sklearn.neighbors._base._get_weights": "def _get_weights(dist, weights):\n    \"\"\"Get the weights from an array of distances and a parameter ``weights``.\n\n    Assume weights have already been validated.\n\n    Parameters\n    ----------\n    dist : ndarray\n        The input distances.\n\n    weights : {'uniform', 'distance'}, callable or None\n        The kind of weighting used.\n\n    Returns\n    -------\n    weights_arr : array of the same shape as ``dist``\n        If ``weights == 'uniform'``, then returns None.\n    \"\"\"\n    if weights in (None, \"uniform\"):\n        return None\n\n    if weights == \"distance\":\n        # if user attempts to classify a point that was zero distance from one\n        # or more training points, those training points are weighted as 1.0\n        # and the other points as 0.0\n        if dist.dtype is np.dtype(object):\n            for point_dist_i, point_dist in enumerate(dist):\n                # check if point_dist is iterable\n                # (ex: RadiusNeighborClassifier.predict may set an element of\n                # dist to 1e-6 to represent an 'outlier')\n                if hasattr(point_dist, \"__contains__\") and 0.0 in point_dist:\n                    dist[point_dist_i] = point_dist == 0.0\n                else:\n                    dist[point_dist_i] = 1.0 / point_dist\n        else:\n            with np.errstate(divide=\"ignore\"):\n                dist = 1.0 / dist\n            inf_mask = np.isinf(dist)\n            inf_row = np.any(inf_mask, axis=1)\n            dist[inf_row] = inf_mask[inf_row]\n        return dist\n\n    if callable(weights):\n        return weights(dist)"
}