{
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        other = Float(other)\n    return Basic.__eq__(self, other)",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.external.pythonmpq.__eq__": "def __eq__(self, other):\n    \"\"\"Compare equal with PythonMPQ, int, float, Decimal or Fraction\"\"\"\n    if isinstance(other, PythonMPQ):\n        return (self.numerator == other.numerator\n            and self.denominator == other.denominator)\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    "sympy.sympy.external.pythonmpq.__add__": "def __add__(self, other):\n    \"\"\"q1 + q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        #\n        # This is much faster than the naive method used in the stdlib\n        # fractions module. Not sure where this method comes from\n        # though...\n        #\n        # Compare timings for something like:\n        #   nums = range(1000)\n        #   rats = [PythonMPQ(n, d) for n, d in zip(nums[:-5], nums[5:])]\n        #   sum(rats) # <-- time this\n        #\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap*bq + aq*bp\n            q = bq*aq\n        else:\n            q1, q2 = aq//g, bq//g\n            p, q = ap*q2 + bp*q1, q1*q2\n            g2 = gcd(p, g)\n            p, q = (p // g2), q * (g // g2)\n\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.external.pythonmpq.__mul__": "def __mul__(self, other):\n    \"\"\"q1 * q2\"\"\"\n    if isinstance(other, PythonMPQ):\n        ap, aq = self.numerator, self.denominator\n        bp, bq = other.numerator, other.denominator\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = ((ap//x1)*(bp//x2), (aq//x2)*(bq//x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator*(other//x)\n        q = self.denominator//x\n    else:\n        return NotImplemented\n\n    return self._new(p, q)",
    "sympy.sympy.polys.agca.extensions.__eq__": "def __eq__(f, g):\n    if isinstance(g, ExtElem):\n        return f.rep == g.rep and f.ext == g.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.agca.extensions.__add__": "def __add__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem(f.rep + rep, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.agca.extensions.__mul__": "def __mul__(f, g):\n    rep = f._get_rep(g)\n    if rep is not None:\n        return ExtElem((f.rep * rep) % f.ext.mod, f.ext)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.densearith.dup_lshift": "def dup_lshift(f: dup[Er], n: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Efficiently multiply ``f`` by ``x**n`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_lshift(x**2 + 1, 2)\n    x**4 + x**2\n\n    \"\"\"\n    if not f:\n        return f\n    else:\n        return f + [K.zero]*n",
    "sympy.sympy.polys.densearith.dup_rshift": "def dup_rshift(f: dup[Er], n: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Efficiently divide ``f`` by ``x**n`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_rshift(x**4 + x**2, 2)\n    x**2 + 1\n    >>> R.dup_rshift(x**4 + x**2 + 2, 2)\n    x**2 + 1\n\n    \"\"\"\n    return f[:-n]",
    "sympy.sympy.polys.densearith.dup_add": "def dup_add(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Add dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_add(x**2 - 1, x - 2)\n    x**2 + x - 3\n\n    \"\"\"\n    if not f:\n        return g\n    if not g:\n        return f\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    if df == dg:\n        return dup_strip([ a + b for a, b in zip(f, g) ], K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = g[:k], g[k:]\n\n        return h + [ a + b for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densearith.dup_sub": "def dup_sub(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Subtract dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sub(x**2 - 1, x - 2)\n    x**2 - x + 1\n\n    \"\"\"\n    if not f:\n        return dup_neg(g, K)\n    if not g:\n        return f\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    if df == dg:\n        return dup_strip([ a - b for a, b in zip(f, g) ], K)\n    else:\n        k = abs(df - dg)\n\n        if df > dg:\n            h, f = f[:k], f[k:]\n        else:\n            h, g = dup_neg(g[:k], K), g[k:]\n\n        return h + [ a - b for a, b in zip(f, g) ]",
    "sympy.sympy.polys.densearith.dup_mul": "def dup_mul(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul(x - 2, x + 2)\n    x**2 - 4\n\n    \"\"\"\n    if f == g:\n        return dup_sqr(f, K)\n\n    if not (f and g):\n        return []\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    n = max(df, dg) + 1\n\n    if n < 100 or not K.is_Exact:\n        h: list[Er] = []\n\n        for i in range(0, df + dg + 1):\n            coeff = K.zero\n\n            for j in range(max(0, i - dg), min(df, i) + 1):\n                coeff += f[j]*g[i - j]\n\n            h.append(coeff)\n\n        return dup_strip(h, K)\n    else:\n        # Use Karatsuba's algorithm (divide and conquer), see e.g.:\n        # Joris van der Hoeven, Relax But Don't Be Too Lazy,\n        # J. Symbolic Computation, 11 (2002), section 3.1.1.\n        n2 = n//2\n\n        fl, gl = dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K)\n\n        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)\n        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)\n\n        lo, hi = dup_mul(fl, gl, K), dup_mul(fh, gh, K)\n\n        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)\n        mid = dup_sub(mid, dup_add(lo, hi, K), K)\n\n        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K),\n                       dup_lshift(hi, 2*n2, K), K)",
    "sympy.sympy.polys.densearith.dup_sqr": "def dup_sqr(f: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Square dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sqr(x**2 + 1)\n    x**4 + 2*x**2 + 1\n\n    \"\"\"\n    h: list[Er] = []\n    df = len(f) - 1\n\n    for i in range(0, 2*df + 1):\n        c = K.zero\n\n        jmin = max(0, i - df)\n        jmax = min(i, df)\n\n        n = jmax - jmin + 1\n\n        jmax = jmin + n // 2 - 1\n\n        for j in range(jmin, jmax + 1):\n            c += f[j]*f[i - j]\n\n        c += c\n\n        if n & 1:\n            elem = f[jmax + 1]\n            c += elem**2\n\n        h.append(c)\n\n    return dup_strip(h, K)",
    "sympy.sympy.polys.densebasic.dup_slice": "def dup_slice(f: dup[Er], m: int, n: int, K: Domain[Er]) -> dup[Er]:\n    \"\"\"Take a continuous subsequence of terms of ``f`` in ``K[x]``.\"\"\"\n    k = len(f)\n\n    if k >= m:\n        M = k - m\n    else:\n        M = 0\n    if k >= n:\n        N = k - n\n    else:\n        N = 0\n\n    f = f[N:M]\n\n    while f and f[0] == K.zero:\n        f.pop(0)\n\n    if not f:\n        return []\n    else:\n        return f + [K.zero] * m",
    "sympy.sympy.polys.densebasic.dup_degree": "def dup_degree(f: dup[Er]) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``K[x]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_degree\n\n    >>> f = ZZ.map([1, 2, 0, 3])\n\n    >>> dup_degree(f)\n    3\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.densebasic.dup_strip": "def dup_strip(f: dup[Er], K: Domain[Er] | None = None) -> dup[Er]:\n    \"\"\"\n    Remove leading zeros from ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.densebasic import dup_strip\n\n    >>> dup_strip([0, 0, 1, 2, 3, 0], ZZ)\n    [1, 2, 3, 0]\n\n    \"\"\"\n    if not f or f[0]:\n        return f\n\n    i = 0\n\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n\n    return f[i:]",
    "sympy.sympy.polys.domains.expressiondomain.__mul__": "def __mul__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n\n    if EX.zero in (f, g):\n        return EX.zero\n    elif f.ex.is_Number and g.ex.is_Number:\n        return f.__class__(f.ex*g.ex)\n\n    return f.simplify(f.ex*g.ex)",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(f, g):\n    return f.ex == f.__class__(g).ex",
    "sympy.sympy.polys.domains.expressiondomain.__add__": "def __add__(f, g):\n    g = f._to_ex(g)\n\n    if g is None:\n        return NotImplemented\n    elif g == EX.zero:\n        return f\n    elif f == EX.zero:\n        return g\n    else:\n        return f.simplify(f.ex + g.ex)",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.gaussiandomains.__mul__": "def __mul__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x*x - self.y*y, self.x*y + self.y*x)",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, self.__class__):\n        return self.x == other.x and self.y == other.y\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.gaussiandomains.__add__": "def __add__(self, other: Self | int) -> Self:\n    other_conv = self._get_xy(other)\n    if other_conv is None:\n        return NotImplemented\n    x, y = other_conv\n    return self.new(self.x + x, self.y + y)",
    "sympy.sympy.polys.domains.modularinteger.__mul__": "def __mul__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val * val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.modularinteger.__eq__": "def __eq__(self, other):\n    return self._compare(other, operator.eq)",
    "sympy.sympy.polys.domains.modularinteger.__add__": "def __add__(self, other):\n    val = self._get_val(other)\n\n    if val is not None:\n        return self.__class__(self.val + val)\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.fields.__eq__": "def __eq__(f, g):\n    if isinstance(g, FracElement) and f.field == g.field:\n        return f.numer == g.numer and f.denom == g.denom\n    else:\n        return f.numer == g and f.denom == f.field.ring.one",
    "sympy.sympy.polys.fields.__add__": "def __add__(f, g):\n    \"\"\"Add rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not g:\n        return f\n    elif not f:\n        return g\n    elif field.is_element(g):\n        if f.denom == g.denom:\n            return f.new(f.numer + g.numer, f.denom)\n        else:\n            return f.new(f.numer*g.denom + f.denom*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer + f.denom*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__radd__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__radd__(f)\n\n    return f.__radd__(g)",
    "sympy.sympy.polys.fields.__mul__": "def __mul__(f, g):\n    \"\"\"Multiply rational functions ``f`` and ``g``. \"\"\"\n    field = f.field\n\n    if not f or not g:\n        return field.zero\n    elif field.is_element(g):\n        return f.new(f.numer*g.numer, f.denom*g.denom)\n    elif field.ring.is_element(g):\n        return f.new(f.numer*g, f.denom)\n    else:\n        if isinstance(g, FracElement):\n            if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n                pass\n            elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n                return g.__rmul__(f)\n            else:\n                return NotImplemented\n        elif isinstance(g, PolyElement):\n            if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n                pass\n            else:\n                return g.__rmul__(f)\n\n    return f.__rmul__(g)",
    "sympy.sympy.polys.polyclasses.__add__": "def __add__(f, g):\n    if isinstance(g, ANP):\n        return f.add(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.add_ground(g)",
    "sympy.sympy.polys.polyclasses.__mul__": "def __mul__(f, g):\n    if isinstance(g, ANP):\n        return f.mul(g)\n    try:\n        g = f.dom.convert(g)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return f.mul_ground(g)",
    "sympy.sympy.polys.polyclasses.__eq__": "def __eq__(f, g):\n    try:\n        F, G, _, _ = f.unify_ANP(g)\n    except UnificationFailed:\n        return NotImplemented\n    return F == G",
    "sympy.sympy.polys.rings.__eq__": "def __eq__(self, other: object) -> bool:\n    \"\"\"Equality test for polynomials.\n\n    Examples\n    ========\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> p1 = (x + y)**2 + (x - y)**2\n    >>> p1 == 4*x*y\n    False\n    >>> p1 == 2*(x**2 + y**2)\n    True\n    \"\"\"\n    if not other:\n        return not self\n    elif self.ring.is_element(other):\n        return dict.__eq__(self, other)\n    elif len(self) > 1:\n        return False\n    else:\n        return self.get(self.ring.zero_monom) == other",
    "sympy.sympy.polys.rings.__add__": "def __add__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Add two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', ZZ)\n    >>> (x + y)**2 + (x - y)**2\n    2*x**2 + 2*y**2\n\n    \"\"\"\n    if self.ring.is_element(other):\n        return self._add(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other)._add_ground(self)\n\n    res = self._try_add_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_add_ground(self)\n\n    return NotImplemented",
    "sympy.sympy.polys.rings.__mul__": "def __mul__(\n    self, other: PolyElement[Er] | Er | int | PolyElement[PolyElement[Er]], /\n) -> PolyElement[Er] | PolyElement[PolyElement[Er]]:\n    \"\"\"Multiply two polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n\n    >>> _, x, y = ring('x, y', QQ)\n    >>> p1 = x + y\n    >>> p2 = x - y\n    >>> p1*p2\n    x**2 - y**2\n\n    \"\"\"\n    if not self or not other:\n        return self.ring.zero\n\n    if self.ring.is_element(other):\n        return self._mul(other)\n\n    if isinstance(other, PolyElement):\n        domain = other.ring.domain\n        if isinstance(domain, PolynomialRing) and domain.ring.is_element(self):\n            return cast(\"PolyElement[PolyElement[Er]]\", other).mul_ground(self)\n\n    res = self._try_mul_ground(other)\n    if res is not NotImplemented:\n        return res\n\n    if isinstance(other, PolyElement):\n        return other._try_mul_ground(self)\n\n    return NotImplemented"
}