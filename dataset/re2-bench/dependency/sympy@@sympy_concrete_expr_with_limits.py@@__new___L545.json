{
    "sympy.sympy.concrete.expr_with_limits._common_new": "def _common_new(cls, function, *symbols, discrete, **assumptions):\n    \"\"\"Return either a special return value or the tuple,\n    (function, limits, orientation). This code is common to\n    both ExprWithLimits and AddWithLimits.\"\"\"\n    function = sympify(function)\n\n    if isinstance(function, Equality):\n        # This transforms e.g. Integral(Eq(x, y)) to Eq(Integral(x), Integral(y))\n        # but that is only valid for definite integrals.\n        limits, orientation = _process_limits(*symbols, discrete=discrete)\n        if not (limits and all(len(limit) == 3 for limit in limits)):\n            sympy_deprecation_warning(\n                \"\"\"\n                Creating a indefinite integral with an Eq() argument is\n                deprecated.\n\n                This is because indefinite integrals do not preserve equality\n                due to the arbitrary constants. If you want an equality of\n                indefinite integrals, use Eq(Integral(a, x), Integral(b, x))\n                explicitly.\n                \"\"\",\n                deprecated_since_version=\"1.6\",\n                active_deprecations_target=\"deprecated-indefinite-integral-eq\",\n                stacklevel=5,\n            )\n\n        lhs = function.lhs\n        rhs = function.rhs\n        return Equality(cls(lhs, *symbols, **assumptions), \\\n                        cls(rhs, *symbols, **assumptions))\n\n    if function is S.NaN:\n        return S.NaN\n\n    if symbols:\n        limits, orientation = _process_limits(*symbols, discrete=discrete)\n        for i, li in enumerate(limits):\n            if len(li) == 4:\n                function = function.subs(li[0], li[-1])\n                limits[i] = Tuple(*li[:-1])\n    else:\n        # symbol not provided -- we can still try to compute a general form\n        free = function.free_symbols\n        if len(free) != 1:\n            raise ValueError(\n                \"specify dummy variables for %s\" % function)\n        limits, orientation = [Tuple(s) for s in free], 1\n\n    # denest any nested calls\n    while cls == type(function):\n        limits = list(function.limits) + limits\n        function = function.function\n\n    # Any embedded piecewise functions need to be brought out to the\n    # top level. We only fold Piecewise that contain the integration\n    # variable.\n    reps = {}\n    symbols_of_integration = {i[0] for i in limits}\n    for p in function.atoms(Piecewise):\n        if not p.has(*symbols_of_integration):\n            reps[p] = Dummy()\n    # mask off those that don't\n    function = function.xreplace(reps)\n    # do the fold\n    function = piecewise_fold(function)\n    # remove the masking\n    function = function.xreplace({v: k for k, v in reps.items()})\n\n    return function, limits, orientation",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None  # will be set by __hash__ method.\n\n    obj._args = args  # all items in args must be Basic objects\n    return obj",
    "sympy.sympy.core.containers.__mul__": "def __mul__(self, other):\n    try:\n        n = as_int(other)\n    except ValueError:\n        raise TypeError(\"Can't multiply sequence by non-integer of type '%s'\" % type(other))\n    return self.func(*(self.args*n))",
    "sympy.sympy.core.decorators.binary_op_wrapper": "@wraps(func)\ndef binary_op_wrapper(self: T1, other: T2) -> T3:\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:  # type: ignore\n            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.matrices.expressions.matexpr.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        b = _sympify(b)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.polys.polytools.wrapper": "@wraps(func)\ndef wrapper(f, g):\n    g = _sympify(g)\n    if isinstance(g, Poly):\n        return func(f, g)\n    elif isinstance(g, Integer):\n        g = f.from_expr(g, *f.gens, domain=f.domain)\n        return func(f, g)\n    elif isinstance(g, Expr):\n        try:\n            g = f.from_expr(g, *f.gens)\n        except PolynomialError:\n            if g.is_Matrix:\n                return NotImplemented\n            expr_method = getattr(f.as_expr(), func.__name__)\n            result = expr_method(g)\n            if result is not NotImplemented:\n                sympy_deprecation_warning(\n                    \"\"\"\n                    Mixing Poly with non-polynomial expressions in binary\n                    operations is deprecated. Either explicitly convert\n                    the non-Poly operand to a Poly with as_poly() or\n                    convert the Poly to an Expr with as_expr().\n                    \"\"\",\n                    deprecated_since_version=\"1.6\",\n                    active_deprecations_target=\"deprecated-poly-nonpoly-binary-operations\",\n                )\n            return result\n        else:\n            return func(f, g)\n    else:\n        return NotImplemented",
    "sympy.sympy.series.formal.__rmul__": "def __rmul__(self, other):\n    return self.__mul__(other)",
    "sympy.sympy.stats.rv.is_commutative": "@property\ndef is_commutative(self):\n    return self.symbol.is_commutative"
}