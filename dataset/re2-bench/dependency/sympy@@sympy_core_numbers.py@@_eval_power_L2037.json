{
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.intfunc.igcd": "@lru_cache(1024)\ndef igcd(*args):\n    \"\"\"Computes nonnegative integer greatest common divisor.\n\n    Explanation\n    ===========\n\n    The algorithm is based on the well known Euclid's algorithm [1]_. To\n    improve speed, ``igcd()`` has its own caching mechanism.\n    If you do not need the cache mechanism, using ``sympy.external.gmpy.gcd``.\n\n    Examples\n    ========\n\n    >>> from sympy import igcd\n    >>> igcd(2, 4)\n    2\n    >>> igcd(5, 10, 15)\n    5\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euclidean_algorithm\n\n    \"\"\"\n    if len(args) < 2:\n        raise TypeError(\"igcd() takes at least 2 arguments (%s given)\" % len(args))\n    return int(number_gcd(*map(as_int, args)))",
    "sympy.sympy.core.intfunc.integer_nthroot": "def integer_nthroot(y, n):\n    \"\"\"\n    Return a tuple containing x = floor(y**(1/n))\n    and a boolean indicating whether the result is exact (that is,\n    whether x**n == y).\n\n    Examples\n    ========\n\n    >>> from sympy import integer_nthroot\n    >>> integer_nthroot(16, 2)\n    (4, True)\n    >>> integer_nthroot(26, 2)\n    (5, False)\n\n    To simply determine if a number is a perfect square, the is_square\n    function should be used:\n\n    >>> from sympy.ntheory.primetest import is_square\n    >>> is_square(26)\n    False\n\n    See Also\n    ========\n    sympy.ntheory.primetest.is_square\n    integer_log\n    \"\"\"\n    x, b = iroot(as_int(y), as_int(n))\n    return int(x), b",
    "sympy.sympy.core.numbers._new": "@classmethod\ndef _new(cls, p, q, gcd=None):\n    if q == 0:\n        if p == 0:\n            if _errdict[\"divide\"]:\n                raise ValueError(\"Indeterminate 0/0\")\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n\n    if q < 0:\n        q = -q\n        p = -p\n\n    if gcd is None:\n        gcd = igcd(abs(p), q)\n\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n\n    return cls.from_coprime_ints(p, q)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.core.numbers._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Number):\n        if isinstance(expt, Float):\n            return self._eval_evalf(expt._prec)**expt\n        if expt.is_extended_negative:\n            # (3/4)**-2 -> (4/3)**2\n            ne = -expt\n            if (ne is S.One):\n                return Rational(self.q, self.p)\n            if self.is_negative:\n                return S.NegativeOne**expt*Rational(self.q, -self.p)**ne\n            else:\n                return Rational(self.q, self.p)**ne\n        if expt is S.Infinity:  # -oo already caught by test for negative\n            if self.p > self.q:\n                # (3/2)**oo -> oo\n                return S.Infinity\n            if self.p < -self.q:\n                # (-3/2)**oo -> oo + I*oo\n                return S.Infinity + S.Infinity*S.ImaginaryUnit\n            return S.Zero\n        if isinstance(expt, Integer):\n            # (4/3)**2 -> 4**2 / 3**2\n            return Rational._new(self.p**expt.p, self.q**expt.p, 1)\n        if isinstance(expt, Rational):\n            intpart = expt.p // expt.q\n            if intpart:\n                intpart += 1\n                remfracpart = intpart*expt.q - expt.p\n                ratfracpart = Rational(remfracpart, expt.q)\n                if self.p != 1:\n                    return Integer(self.p)**expt*Integer(self.q)**ratfracpart*Rational._new(1, self.q**intpart, 1)\n                return Integer(self.q)**ratfracpart*Rational._new(1, self.q**intpart, 1)\n            else:\n                remfracpart = expt.q - expt.p\n                ratfracpart = Rational(remfracpart, expt.q)\n                if self.p != 1:\n                    return Integer(self.p)**expt*Integer(self.q)**ratfracpart*Rational._new(1, self.q, 1)\n                return Integer(self.q)**ratfracpart*Rational._new(1, self.q, 1)\n\n    if self.is_extended_negative and expt.is_even:\n        return (-self)**expt\n\n    return",
    "sympy.sympy.core.numbers.factors": "def factors(self, limit=None, use_trial=True, use_rho=False,\n            use_pm1=False, verbose=False, visual=False):\n    \"\"\"A wrapper to factorint which return factors of self that are\n    smaller than limit (or cheap to compute). Special methods of\n    factoring are disabled by default so that only trial division is used.\n    \"\"\"\n    from sympy.ntheory.factor_ import factorrat\n\n    return factorrat(self, limit=limit, use_trial=use_trial,\n                  use_rho=use_rho, use_pm1=use_pm1,\n                  verbose=verbose).copy()",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.ntheory.factor_.perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    \"\"\"\n    Return ``(b, e)`` such that ``n`` == ``b**e`` if ``n`` is a unique\n    perfect power with ``e > 1``, else ``False`` (e.g. 1 is not a\n    perfect power). A ValueError is raised if ``n`` is not Rational.\n\n    By default, the base is recursively decomposed and the exponents\n    collected so the largest possible ``e`` is sought. If ``big=False``\n    then the smallest possible ``e`` (thus prime) will be chosen.\n\n    If ``factor=True`` then simultaneous factorization of ``n`` is\n    attempted since finding a factor indicates the only possible root\n    for ``n``. This is True by default since only a few small factors will\n    be tested in the course of searching for the perfect power.\n\n    The use of ``candidates`` is primarily for internal use; if provided,\n    False will be returned if ``n`` cannot be written as a power with one\n    of the candidates as an exponent and factoring (beyond testing for\n    a factor of 2) will not be attempted.\n\n    Examples\n    ========\n\n    >>> from sympy import perfect_power, Rational\n    >>> perfect_power(16)\n    (2, 4)\n    >>> perfect_power(16, big=False)\n    (4, 2)\n\n    Negative numbers can only have odd perfect powers:\n\n    >>> perfect_power(-4)\n    False\n    >>> perfect_power(-8)\n    (-2, 3)\n\n    Rationals are also recognized:\n\n    >>> perfect_power(Rational(1, 2)**3)\n    (1/2, 3)\n    >>> perfect_power(Rational(-3, 2)**3)\n    (-3/2, 3)\n\n    Notes\n    =====\n\n    To know whether an integer is a perfect power of 2 use\n\n        >>> is2pow = lambda n: bool(n and not n & (n - 1))\n        >>> [(i, is2pow(i)) for i in range(5)]\n        [(0, False), (1, True), (2, True), (3, False), (4, True)]\n\n    It is not necessary to provide ``candidates``. When provided\n    it will be assumed that they are ints. The first one that is\n    larger than the computed maximum possible exponent will signal\n    failure for the routine.\n\n        >>> perfect_power(3**8, [9])\n        False\n        >>> perfect_power(3**8, [2, 4, 8])\n        (3, 8)\n        >>> perfect_power(3**8, [4, 8], big=False)\n        (9, 4)\n\n    See Also\n    ========\n    sympy.core.intfunc.integer_nthroot\n    sympy.ntheory.primetest.is_square\n    \"\"\"\n    # negative handling\n    if n < 0:\n        if candidates is None:\n            pp = perfect_power(-n, big=True, factor=factor)\n            if not pp:\n                return False\n\n            b, e = pp\n            e2 = e & (-e)\n            b, e = b ** e2, e // e2\n\n            if e <= 1:\n                return False\n\n            if big or isprime(e):\n                return -b, e\n\n            for p in primerange(3, e + 1):\n                if e % p == 0:\n                    return - b ** (e // p), p\n\n        odd_candidates = {i for i in candidates if i % 2}\n        if not odd_candidates:\n            return False\n\n        pp = perfect_power(-n, odd_candidates, big, factor)\n        if pp:\n            return -pp[0], pp[1]\n\n        return False\n\n    # non-integer handling\n    if isinstance(n, Rational) and not isinstance(n, Integer):\n        p, q = n.p, n.q\n\n        if p == 1:\n            qq = perfect_power(q, candidates, big, factor)\n            return (S.One / qq[0], qq[1]) if qq is not False else False\n\n        if not (pp:=perfect_power(p, factor=factor)):\n            return False\n        if not (qq:=perfect_power(q, factor=factor)):\n            return False\n        (num_base, num_exp), (den_base, den_exp) = pp, qq\n\n        def compute_tuple(exponent):\n            \"\"\"Helper to compute final result given an exponent\"\"\"\n            new_num = num_base ** (num_exp // exponent)\n            new_den = den_base ** (den_exp // exponent)\n            return n.func(new_num, new_den), exponent\n\n        if candidates:\n            valid_candidates = [i for i in candidates\n                                if num_exp % i == 0 and den_exp % i == 0]\n            if not valid_candidates:\n                return False\n\n            e = max(valid_candidates) if big else min(valid_candidates)\n            return compute_tuple(e)\n\n        g = math.gcd(num_exp, den_exp)\n        if g == 1:\n            return False\n\n        if big:\n            return compute_tuple(g)\n\n        e = next(p for p in primerange(2, g + 1) if g % p == 0)\n        return compute_tuple(e)\n\n    if candidates is not None:\n        candidates = set(candidates)\n\n    # positive integer handling\n    n = as_int(n)\n\n    if candidates is None and big:\n        return _perfect_power(n)\n\n    if n <= 3:\n        # no unique exponent for 0, 1\n        # 2 and 3 have exponents of 1\n        return False\n    logn = math.log2(n)\n    max_possible = int(logn) + 2  # only check values less than this\n    not_square = n % 10 in [2, 3, 7, 8]  # squares cannot end in 2, 3, 7, 8\n    min_possible = 2 + not_square\n    if not candidates:\n        candidates = primerange(min_possible, max_possible)\n    else:\n        candidates = sorted([i for i in candidates\n            if min_possible <= i < max_possible])\n        if n%2 == 0:\n            e = bit_scan1(n)\n            candidates = [i for i in candidates if e%i == 0]\n        if big:\n            candidates = reversed(candidates)\n        for e in candidates:\n            r, ok = iroot(n, e)\n            if ok:\n                return int(r), e\n        return False\n\n    def _factors():\n        rv = 2 + n % 2\n        while True:\n            yield rv\n            rv = nextprime(rv)\n\n    for fac, e in zip(_factors(), candidates):\n        # see if there is a factor present\n        if factor and n % fac == 0:\n            # find what the potential power is\n            e = remove(n, fac)[1]\n            # if it's a trivial power we are done\n            if e == 1:\n                return False\n\n            # maybe the e-th root of n is exact\n            r, exact = iroot(n, e)\n            if not exact:\n                # Having a factor, we know that e is the maximal\n                # possible value for a root of n.\n                # If n = fac**e*m can be written as a perfect\n                # power then see if m can be written as r**E where\n                # gcd(e, E) != 1 so n = (fac**(e//E)*r)**E\n                m = n//fac**e\n                rE = perfect_power(m, candidates=divisors(e, generator=True))\n                if not rE:\n                    return False\n                else:\n                    r, E = rE\n                    r, e = fac**(e//E)*r, E\n            if not big:\n                e0 = primefactors(e)\n                if e0[0] != e:\n                    r, e = r**(e//e0[0]), e0[0]\n            return int(r), e\n\n        # Weed out downright impossible candidates\n        if logn/e < 40:\n            b = 2.0**(logn/e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n\n        # now see if the plausible e makes a perfect power\n        r, exact = iroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m:\n                    r, e = m[0], e*m[1]\n            return int(r), e\n\n    return False"
}