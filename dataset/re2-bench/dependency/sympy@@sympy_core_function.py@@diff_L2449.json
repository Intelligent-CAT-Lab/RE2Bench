{
    "sympy.sympy.algebras.quaternion.diff": "def diff(self, *symbols, **kwargs):\n    kwargs.setdefault('evaluate', True)\n    a, b, c, d = [arg.diff(*symbols, **kwargs) for arg in self.args]\n    return self.func(a, b, c, d)",
    "sympy.sympy.core.expr.diff": "def diff(self, *symbols, **assumptions) -> Expr:\n    assumptions.setdefault(\"evaluate\", True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    "sympy.sympy.core.function._derivative_dispatch": "def _derivative_dispatch(expr, *variables, **kwargs):\n    from sympy.matrices.matrixbase import MatrixBase\n    from sympy.matrices.expressions.matexpr import MatrixExpr\n    from sympy.tensor.array import NDimArray\n    array_types = (MatrixBase, MatrixExpr, NDimArray, list, tuple, Tuple)\n    if isinstance(expr, array_types) or any(isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables):\n        from sympy.tensor.array.array_derivatives import ArrayDerivative\n        return ArrayDerivative(expr, *variables, **kwargs)\n    return Derivative(expr, *variables, **kwargs)",
    "sympy.sympy.matrices.matrixbase.diff": "def diff(self, *args: Expr | int | tuple[Expr, int], evaluate: bool = True) -> Self:\n    \"\"\"Calculate the derivative of each element in the matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x, y\n    >>> M = Matrix([[x, y], [1, 0]])\n    >>> M.diff(x)\n    Matrix([\n    [1, 0],\n    [0, 0]])\n\n    See Also\n    ========\n\n    integrate\n    limit\n    \"\"\"\n    # XXX this should be handled here rather than in Derivative\n    from sympy.tensor.array.array_derivatives import ArrayDerivative\n    deriv = ArrayDerivative(self, *args, evaluate=evaluate)\n    # XXX This can rather changed to always return immutable matrix\n    if not isinstance(self, Basic) and evaluate:\n        return deriv.as_mutable() # type: ignore\n    return deriv # type: ignore",
    "sympy.sympy.polys.polytools.diff": "def diff(f, *specs, **kwargs):\n    \"\"\"\n    Computes partial derivative of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> Poly(x**2 + 2*x + 1, x).diff()\n    Poly(2*x + 2, x, domain='ZZ')\n\n    >>> Poly(x*y**2 + x, x, y).diff((0, 0), (1, 1))\n    Poly(2*x*y, x, y, domain='ZZ')\n\n    \"\"\"\n    if not kwargs.get('evaluate', True):\n        return Derivative(f, *specs, **kwargs)\n\n    if hasattr(f.rep, 'diff'):\n        if not specs:\n            return f.per(f.rep.diff(m=1))\n\n        rep = f.rep\n\n        for spec in specs:\n            if isinstance(spec, tuple):\n                gen, m = spec\n            else:\n                gen, m = spec, 1\n\n            rep = rep.diff(int(m), f._gen_to_level(gen))\n\n        return f.per(rep)\n    else:  # pragma: no cover\n        raise OperationNotSupported(f, 'diff')",
    "sympy.sympy.tensor.array.ndim_array.diff": "def diff(self, *args, **kwargs):\n    \"\"\"\n    Calculate the derivative of each element in the array.\n\n    Examples\n    ========\n\n    >>> from sympy import ImmutableDenseNDimArray\n    >>> from sympy.abc import x, y\n    >>> M = ImmutableDenseNDimArray([[x, y], [1, x*y]])\n    >>> M.diff(x)\n    [[1, 0], [0, y]]\n\n    \"\"\"\n    from sympy.tensor.array.array_derivatives import ArrayDerivative\n    kwargs.setdefault('evaluate', True)\n    return ArrayDerivative(self.as_immutable(), *args, **kwargs)",
    "sympy.sympy.vector.basisdependent.diff": "def diff(self, *args, **kwargs):\n    \"\"\"\n    Implements the SymPy diff routine, for vectors.\n\n    diff's documentation\n    ========================\n\n    \"\"\"\n    for x in args:\n        if isinstance(x, BasisDependent):\n            raise TypeError(\"Invalid arg for differentiation\")\n    diff_components = [df(v, *args, **kwargs) * k for\n                       k, v in self.components.items()]\n    return self._add_func(*diff_components)"
}