{
    "sympy.sympy.calculus.accumulationbounds.__new__": "def __new__(cls, min, max) -> Expr: # type: ignore\n\n    min = _sympify(min)\n    max = _sympify(max)\n\n    # Only allow real intervals (use symbols with 'is_extended_real=True').\n    if not min.is_extended_real or not max.is_extended_real:\n        raise ValueError(\"Only real AccumulationBounds are supported\")\n\n    if max == min:\n        return max\n\n    # Make sure that the created AccumBounds object will be valid.\n    if max.is_number and min.is_number:\n        bad = max.is_comparable and min.is_comparable and max < min\n    else:\n        bad = (max - min).is_extended_negative\n    if bad:\n        raise ValueError(\n            \"Lower limit should be smaller than upper limit\")\n\n    return Basic.__new__(cls, min, max)",
    "sympy.sympy.codegen.cfunctions._eval_rewrite_as_log": "def _eval_rewrite_as_log(self, arg, **kwargs):\n    return _log2(arg)",
    "sympy.sympy.codegen.cfunctions._eval_rewrite_as_Pow": "def _eval_rewrite_as_Pow(self, arg, **kwargs):\n    return _exp2(arg)",
    "sympy.sympy.codegen.cfunctions._eval_rewrite_as_exp": "def _eval_rewrite_as_exp(self, arg, **kwargs):\n    return exp(arg) - S.One",
    "sympy.sympy.codegen.numpy_nodes._eval_rewrite_as_log": "def _eval_rewrite_as_log(self, x1, x2, **kwargs):\n    return _logaddexp(x1, x2)",
    "sympy.sympy.codegen.numpy_nodes._eval_rewrite_as_Max": "def _eval_rewrite_as_Max(self, *args):\n    return Max(*self.args)",
    "sympy.sympy.codegen.numpy_nodes._eval_rewrite_as_Min": "def _eval_rewrite_as_Min(self, *args):\n    return Min(*self.args)",
    "sympy.sympy.codegen.scipy_nodes._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, x, **kwargs):\n    return _cosm1(x)",
    "sympy.sympy.codegen.scipy_nodes._eval_rewrite_as_Pow": "def _eval_rewrite_as_Pow(self, x, y, **kwargs):\n    return _powm1(x, y)",
    "sympy.sympy.concrete.products._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, *args, **kwargs):\n    return exp(Sum(log(self.function), *self.limits))",
    "sympy.sympy.concrete.summations.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Sum:\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    if not hasattr(obj, 'limits'):\n        return obj\n    if any(len(l) != 3 or None in l for l in obj.limits):\n        raise ValueError('Sum requires values for lower and upper bounds.')\n\n    return obj",
    "sympy.sympy.concrete.summations._eval_rewrite_as_Product": "def _eval_rewrite_as_Product(self, *args, **kwargs):\n    from sympy.concrete.products import Product\n    if self.function.is_extended_real:\n        return log(Product(exp(self.function), *self.limits))",
    "sympy.sympy.core.basic.<listcomp>": "args = [a._rewrite(pattern, rule, method, **hints)\n        for a in self.args]\n",
    "sympy.sympy.core.basic.<genexpr>": "if not pattern or any(isinstance(self, p) for p in pattern):\n    meth = getattr(self, method, None)\n    if meth is not None:\n        rewritten = meth(*args, **hints)\n    else:\n        rewritten = self._eval_rewrite(rule, args, **hints)\n    if rewritten is not None:\n        return rewritten\n",
    "sympy.sympy.core.basic._eval_rewrite": "def _eval_rewrite(self, rule, args, **hints):\n    return None",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.containers.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    "sympy.sympy.core.function.__new__": "def __new__(cls, *args, **options) -> Expr:  # type: ignore\n    args = tuple(map(sympify, args))\n    u = [a.name for a in args if isinstance(a, UndefinedFunction)]\n    if u:\n        raise TypeError('Invalid argument: expecting an expression, not UndefinedFunction%s: %s' % (\n            's'*(len(u) > 1), ', '.join(u)))\n    obj: Expr = super().__new__(cls, *args, **options)  # type: ignore\n    return obj",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.mod._eval_rewrite_as_floor": "def _eval_rewrite_as_floor(self, a, b, **kwargs):\n    from sympy.functions.elementary.integers import floor\n    return a - b*floor(a/b)",
    "sympy.sympy.core.numbers._eval_rewrite_as_sin": "def _eval_rewrite_as_sin(self, **kwargs):\n    from sympy.functions.elementary.trigonometric import sin\n    return sin(I + S.Pi/2) - I*sin(I)",
    "sympy.sympy.core.numbers._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, **kwargs):\n    from sympy.functions.elementary.trigonometric import cos\n    return cos(I) + I*cos(I + S.Pi/2)",
    "sympy.sympy.core.numbers._eval_expand_func": "def _eval_expand_func(self, **hints):\n    from sympy.functions.elementary.miscellaneous import cbrt, sqrt\n    return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3",
    "sympy.sympy.core.numbers._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, k_sym=None, symbols=None, **hints):\n    if (k_sym is not None) or (symbols is not None):\n        return self\n    from .symbol import Dummy\n    from sympy.concrete.summations import Sum\n    k = Dummy('k', integer=True, nonnegative=True)\n    return Sum(S.NegativeOne**k / (2*k+1)**2, (k, 0, S.Infinity))",
    "sympy.sympy.core.operations.__new__": "def __new__(cls, *args, evaluate=None, **options):\n    args = (_sympify_(arg) for arg in args)\n\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n\n    if not evaluate:\n        obj = super().__new__(cls, *args, evaluate=False, **options)\n        obj._argset = frozenset(args)\n        return obj\n\n    try:\n        # /!\\ args is a generator and _new_args_filter\n        # must be careful to handle as such; this\n        # is done so short-circuiting can be done\n        # without having to sympify all values\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        # XXX in almost every other case for __new__, *_args is\n        # passed along, but the expectation here is for _args\n        obj = super(AssocOp, cls).__new__(cls, *ordered(_args))\n        obj._argset = _args\n        return obj",
    "sympy.sympy.core.power._eval_rewrite_as_exp": "def _eval_rewrite_as_exp(self, base, expo, **kwargs):\n    from sympy.functions.elementary.exponential import exp, log\n\n    if base.is_zero or base.has(exp) or expo.has(exp):\n        return base**expo\n\n    evaluate = expo.has(Symbol)\n\n    if base.has(Symbol):\n        # delay evaluation if expo is non symbolic\n        # (as exp(x*log(5)) automatically reduces to x**5)\n        if global_parameters.exp_is_pow:\n            return Pow(S.Exp1, log(base)*expo, evaluate=evaluate)\n        else:\n            return exp(log(base)*expo, evaluate=evaluate)\n\n    else:\n        from sympy.functions.elementary.complexes import arg, Abs\n        return exp((log(Abs(base)) + S.ImaginaryUnit*arg(base))*expo)",
    "sympy.sympy.core.power._eval_rewrite_as_sin": "def _eval_rewrite_as_sin(self, base, exp, **hints):\n    if self.base is S.Exp1:\n        from sympy.functions.elementary.trigonometric import sin\n        return sin(S.ImaginaryUnit*self.exp + S.Pi/2) - S.ImaginaryUnit*sin(S.ImaginaryUnit*self.exp)",
    "sympy.sympy.core.power._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, base, exp, **hints):\n    if self.base is S.Exp1:\n        from sympy.functions.elementary.trigonometric import cos\n        return cos(S.ImaginaryUnit*self.exp) + S.ImaginaryUnit*cos(S.ImaginaryUnit*self.exp + S.Pi/2)",
    "sympy.sympy.core.power._eval_rewrite_as_tanh": "def _eval_rewrite_as_tanh(self, base, exp, **hints):\n    if self.base is S.Exp1:\n        from sympy.functions.elementary.hyperbolic import tanh\n        return (1 + tanh(self.exp/2))/(1 - tanh(self.exp/2))",
    "sympy.sympy.core.power._eval_rewrite_as_sqrt": "def _eval_rewrite_as_sqrt(self, base, exp, **kwargs):\n    from sympy.functions.elementary.trigonometric import sin, cos\n    if base is not S.Exp1:\n        return None\n    if exp.is_Mul:\n        coeff = exp.coeff(S.Pi * S.ImaginaryUnit)\n        if coeff and coeff.is_number:\n            cosine, sine = cos(S.Pi*coeff), sin(S.Pi*coeff)\n            if not isinstance(cosine, cos) and not isinstance (sine, sin):\n                return cosine + S.ImaginaryUnit*sine",
    "sympy.sympy.core.relational.__new__": "def __new__(cls, lhs: Expr | complex, rhs: Expr | complex, **options) -> Self | BooleanTrue | BooleanFalse: # type: ignore\n\n    try:\n        lhs_e = _sympify(lhs)\n        rhs_e = _sympify(rhs)\n    except SympifyError:\n        return NotImplemented\n\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    if evaluate:\n        for me in (lhs_e, rhs_e):\n            if me.is_extended_real is False:\n                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n            if me is S.NaN:\n                raise TypeError(\"Invalid NaN comparison\")\n        # First we invoke the appropriate inequality method of `lhs`\n        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n        # boolean or raise an exception.  It may keep calling\n        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n        # In some cases, `Expr` will just invoke us again (if neither it\n        # nor a subclass was able to reduce to boolean or raise an\n        # exception).  In that case, it must call us with\n        # `evaluate=False` to prevent infinite recursion.\n        return cls._eval_relation(lhs_e, rhs_e, **options)\n\n    # make a \"non-evaluated\" Expr for the inequality\n    return Relational.__new__(cls, lhs_e, rhs_e, **options)",
    "sympy.sympy.core.relational._eval_rewrite_as_Add": "def _eval_rewrite_as_Add(self, L, R, evaluate=True, **kwargs):\n    \"\"\"\n    return Eq(L, R) as L - R. To control the evaluation of\n    the result set pass `evaluate=True` to give L - R;\n    if `evaluate=None` then terms in L and R will not cancel\n    but they will be listed in canonical order; otherwise\n    non-canonical args will be returned. If one side is 0, the\n    non-zero side will be returned.\n\n    .. deprecated:: 1.13\n\n       The method ``Eq.rewrite(Add)`` is deprecated.\n       See :ref:`eq-rewrite-Add` for details.\n\n    Examples\n    ========\n\n    >>> from sympy import Eq, Add\n    >>> from sympy.abc import b, x\n    >>> eq = Eq(x + b, x - b)\n    >>> eq.rewrite(Add)  #doctest: +SKIP\n    2*b\n    >>> eq.rewrite(Add, evaluate=None).args  #doctest: +SKIP\n    (b, b, x, -x)\n    >>> eq.rewrite(Add, evaluate=False).args  #doctest: +SKIP\n    (b, x, b, -x)\n    \"\"\"\n    sympy_deprecation_warning(\"\"\"\n    Eq.rewrite(Add) is deprecated.\n\n    For ``eq = Eq(a, b)`` use ``eq.lhs - eq.rhs`` to obtain\n    ``a - b``.\n    \"\"\",\n        deprecated_since_version=\"1.13\",\n        active_deprecations_target=\"eq-rewrite-Add\",\n        stacklevel=5,\n    )\n    from .add import _unevaluated_Add, Add\n    if L == 0:\n        return R\n    if R == 0:\n        return L\n    if evaluate:\n        # allow cancellation of args\n        return L - R\n    args = Add.make_args(L) + Add.make_args(-R)\n    if evaluate is None:\n        # no cancellation, but canonical\n        return _unevaluated_Add(*args)\n    # no cancellation, not canonical\n    return Add._from_args(args)",
    "sympy.sympy.diffgeom.diffgeom.__new__": "def __new__(cls, coord_sys, index, **kwargs):\n    index = _sympify(index)\n    obj = super().__new__(cls, coord_sys, index)\n    obj._coord_sys = coord_sys\n    obj._index = index\n    return obj",
    "sympy.sympy.diffgeom.diffgeom._eval_rewrite": "def _eval_rewrite(self, rule, args, **hints):\n    if isinstance(rule, CoordSystem):\n        return rule.transform(self.coord_sys)[self.index]\n    return super()._eval_rewrite(rule, args, **hints)",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_factorial": "def _eval_rewrite_as_factorial(self, x, k, **kwargs):\n    from sympy.functions.elementary.piecewise import Piecewise\n    if x.is_integer and k.is_integer:\n        return Piecewise(\n            (factorial(x)/factorial(-k + x), x >= 0),\n            (S.NegativeOne**k*factorial(k - x - 1)/factorial(-x - 1), True))",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_gamma": "def _eval_rewrite_as_gamma(self, x, k, piecewise=True, **kwargs):\n    from sympy.functions.elementary.piecewise import Piecewise\n    from sympy.functions.special.gamma_functions import gamma\n    if not piecewise:\n        if (x < 0) == True:\n            return S.NegativeOne**k*gamma(k - x) / gamma(-x)\n        return gamma(x + 1) / gamma(x - k + 1)\n    return Piecewise(\n        (gamma(x + 1) / gamma(x - k + 1), x >= 0),\n        (S.NegativeOne**k*gamma(k - x) / gamma(-x), True))",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_tractable": "def _eval_rewrite_as_tractable(self, x, k, limitvar=None, **kwargs):\n    from sympy.functions.special.gamma_functions import gamma\n    if limitvar:\n        k_lim = k.subs(limitvar, S.Infinity)\n        if k_lim is S.Infinity:\n            return (gamma(x + k).rewrite('tractable', deep=True) / gamma(x))\n        elif k_lim is S.NegativeInfinity:\n            return (S.NegativeOne**k*gamma(1 - x) / gamma(-k - x + 1).rewrite('tractable', deep=True))\n    return self.rewrite(gamma).rewrite('tractable', deep=True)",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_FallingFactorial": "def _eval_rewrite_as_FallingFactorial(self, x, k, **kwargs):\n    return FallingFactorial(x + k - 1, k)",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_Product": "def _eval_rewrite_as_Product(self, n, **kwargs):\n    from sympy.concrete.products import Product\n    if n.is_nonnegative and n.is_integer:\n        i = Dummy('i', integer=True)\n        return Product(i, (i, 1, n))",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_uppergamma": "def _eval_rewrite_as_uppergamma(self, arg, **kwargs):\n    from sympy.functions.special.gamma_functions import uppergamma\n    return uppergamma(arg + 1, -1)/S.Exp1",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_binomial": "def _eval_rewrite_as_binomial(self, x, k, **kwargs):\n    if k.is_integer:\n        return factorial(k) * binomial(x, k)",
    "sympy.sympy.functions.combinatorial.factorials._eval_rewrite_as_RisingFactorial": "def _eval_rewrite_as_RisingFactorial(self, x, k, **kwargs):\n    return rf(x - k + 1, k)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, n, m=None, **kwargs):\n    from sympy.concrete.summations import Sum\n    k = Dummy(\"k\", integer=True)\n    if m is None:\n        m = S.One\n    return Sum(k**(-m), (k, 1, n))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_binomial": "def _eval_rewrite_as_binomial(self, n, **kwargs):\n    return binomial(2*n, n)/(n + 1)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_factorial": "def _eval_rewrite_as_factorial(self, n, **kwargs):\n    return factorial(2*n) / (factorial(n+1) * factorial(n))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_gamma": "def _eval_rewrite_as_gamma(self, n, piecewise=True, **kwargs):\n    from sympy.functions.special.gamma_functions import gamma\n    # The gamma function allows to generalize Catalan numbers to complex n\n    return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_hyper": "def _eval_rewrite_as_hyper(self, n, **kwargs):\n    from sympy.functions.special.hyper import hyper\n    return hyper([1 - n, -n], [2], 1)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_Product": "def _eval_rewrite_as_Product(self, n, **kwargs):\n    from sympy.concrete.products import Product\n    if not (n.is_integer and n.is_nonnegative):\n        return self\n    k = Dummy('k', integer=True, positive=True)\n    return Product((n + k) / k, (k, 2, n))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_bernoulli": "def _eval_rewrite_as_bernoulli(self, n, x=1, **kwargs):\n    if x == 1 and n.is_integer and n.is_nonnegative:\n        return 2 * (1-S(2)**n) * bernoulli(n)\n    return 2 * (bernoulli(n, x) - 2**n * bernoulli(n, (x+1) / 2))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_dirichlet_eta": "def _eval_rewrite_as_dirichlet_eta(self, n, x=1, **kwargs):\n    from sympy.functions.special.zeta_functions import dirichlet_eta\n    return -2*n * dirichlet_eta(1-n, x)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_zeta": "def _eval_rewrite_as_zeta(self, n, x=1, **kwargs):\n    from sympy.functions.special.zeta_functions import zeta\n    return Piecewise((1, Eq(n, 0)), (-n * zeta(1-n, x), True))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_polylog": "def _eval_rewrite_as_polylog(self, s, **kwargs):\n    from sympy.functions.special.zeta_functions import polylog\n    return (-I)**(s+1) * polylog(-s, I) + I**(s+1) * polylog(-s, -I)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_tractable": "def _eval_rewrite_as_tractable(self, n, m=1, limitvar=None, **kwargs):\n    from sympy.functions.special.zeta_functions import zeta\n    from sympy.functions.special.gamma_functions import polygamma\n    pg = self.rewrite(polygamma)\n    if not isinstance(pg, harmonic):\n        return pg.rewrite(\"tractable\", deep=True)\n    arg = m - S.One\n    if arg.is_nonzero:\n        return (zeta(m) - zeta(m, n+1)).rewrite(\"tractable\", deep=True)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_sqrt": "def _eval_rewrite_as_sqrt(self, n, **kwargs):\n    from sympy.functions.elementary.miscellaneous import cbrt, sqrt\n    w = (-1 + S.ImaginaryUnit * sqrt(3)) / 2\n    a = (1 + cbrt(19 + 3*sqrt(33)) + cbrt(19 - 3*sqrt(33))) / 3\n    b = (1 + w*cbrt(19 + 3*sqrt(33)) + w**2*cbrt(19 - 3*sqrt(33))) / 3\n    c = (1 + w**2*cbrt(19 + 3*sqrt(33)) + w*cbrt(19 - 3*sqrt(33))) / 3\n    Tn = (a**(n + 1)/((a - b)*(a - c))\n        + b**(n + 1)/((b - a)*(b - c))\n        + c**(n + 1)/((c - a)*(c - b)))\n    return Tn",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_GoldenRatio": "def _eval_rewrite_as_GoldenRatio(self,n, **kwargs):\n    return (S.GoldenRatio**n - 1/(-S.GoldenRatio)**n)/(2*S.GoldenRatio-1)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_TribonacciConstant": "def _eval_rewrite_as_TribonacciConstant(self, n, **kwargs):\n    from sympy.functions.elementary.integers import floor\n    from sympy.functions.elementary.miscellaneous import cbrt, sqrt\n    b = cbrt(586 + 102*sqrt(33))\n    Tn = 3 * b * S.TribonacciConstant**n / (b**2 - 2*b + 4)\n    return floor(Tn + S.Half)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_polygamma": "def _eval_rewrite_as_polygamma(self, n, m=S.One, **kwargs):\n    from sympy.functions.special.gamma_functions import gamma, polygamma\n    if m.is_integer and m.is_positive:\n        return Piecewise((polygamma(0, n+1) + S.EulerGamma, Eq(m, 1)),\n                (S.NegativeOne**m * (polygamma(m-1, 1) - polygamma(m-1, n+1)) /\n                gamma(m), True))",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_digamma": "def _eval_rewrite_as_digamma(self, n, m=1, **kwargs):\n    from sympy.functions.special.gamma_functions import polygamma\n    return self.rewrite(polygamma)",
    "sympy.sympy.functions.combinatorial.numbers._eval_rewrite_as_trigamma": "def _eval_rewrite_as_trigamma(self, n, m=1, **kwargs):\n    from sympy.functions.special.gamma_functions import polygamma\n    return self.rewrite(polygamma)",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_im": "def _eval_rewrite_as_im(self, arg, **kwargs):\n    return self.args[0] - I*im(self.args[0])",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_re": "def _eval_rewrite_as_re(self, arg, **kwargs):\n    return -I*(self.args[0] - re(self.args[0]))",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_Piecewise": "def _eval_rewrite_as_Piecewise(self, arg, **kwargs):\n    if arg.is_extended_real:\n        return Piecewise((arg, arg >= 0), (-arg, True))\n    elif arg.is_imaginary:\n        return Piecewise((I*arg, I*arg >= 0), (-I*arg, True))",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_Heaviside": "def _eval_rewrite_as_Heaviside(self, arg, **kwargs):\n    # Note this only holds for real arg (since Heaviside is not defined\n    # for complex arguments).\n    from sympy.functions.special.delta_functions import Heaviside\n    if arg.is_extended_real:\n        return arg*(Heaviside(arg) - Heaviside(-arg))",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_Abs": "def _eval_rewrite_as_Abs(self, arg, **kwargs):\n    return Piecewise((0, Eq(arg, 0)), (arg / Abs(arg), True))",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_sign": "def _eval_rewrite_as_sign(self, arg, **kwargs):\n    return arg/sign(arg)",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_conjugate": "def _eval_rewrite_as_conjugate(self, arg, **kwargs):\n    return sqrt(arg*conjugate(arg))",
    "sympy.sympy.functions.elementary.complexes._eval_rewrite_as_atan2": "def _eval_rewrite_as_atan2(self, arg, **kwargs):\n    from sympy.functions.elementary.trigonometric import atan2\n    x, y = self.args[0].as_real_imag()\n    return atan2(y, x)",
    "sympy.sympy.functions.elementary.exponential._eval_rewrite_as_sin": "def _eval_rewrite_as_sin(self, arg, **kwargs):\n    from sympy.functions.elementary.trigonometric import sin\n    return sin(I*arg + pi/2) - I*sin(I*arg)",
    "sympy.sympy.functions.elementary.exponential._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, arg, **kwargs):\n    from sympy.functions.elementary.trigonometric import cos\n    return cos(I*arg) + I*cos(I*arg + pi/2)",
    "sympy.sympy.functions.elementary.exponential._eval_rewrite_as_tanh": "def _eval_rewrite_as_tanh(self, arg, **kwargs):\n    from sympy.functions.elementary.hyperbolic import tanh\n    return (1 + tanh(arg/2))/(1 - tanh(arg/2))",
    "sympy.sympy.functions.elementary.exponential._eval_rewrite_as_sqrt": "def _eval_rewrite_as_sqrt(self, arg, **kwargs):\n    from sympy.functions.elementary.trigonometric import sin, cos\n    if arg.is_Mul:\n        coeff = arg.coeff(pi*I)\n        if coeff and coeff.is_number:\n            cosine, sine = cos(pi*coeff), sin(pi*coeff)\n            if not isinstance(cosine, cos) and not isinstance (sine, sin):\n                return cosine + I*sine",
    "sympy.sympy.functions.elementary.exponential._eval_rewrite_as_Pow": "def _eval_rewrite_as_Pow(self, arg, **kwargs):\n    if arg.is_Mul:\n        logs = [a for a in arg.args if isinstance(a, log) and len(a.args) == 1]\n        if logs:\n            return Pow(logs[0].args[0], arg.coeff(logs[0]))",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_exp": "def _eval_rewrite_as_exp(self, arg, **kwargs):\n    neg_exp, pos_exp = exp(-arg), exp(arg)\n    return (pos_exp + neg_exp)/(pos_exp - neg_exp)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_tractable": "def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):\n    neg_exp, pos_exp = exp(-arg), exp(arg)\n    return (pos_exp + neg_exp)/(pos_exp - neg_exp)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_tanh": "def _eval_rewrite_as_tanh(self, arg, **kwargs):\n    return 1/tanh(arg)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_coth": "def _eval_rewrite_as_coth(self, arg, **kwargs):\n    return 1/coth(arg)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_cosh": "def _eval_rewrite_as_cosh(self, arg, **kwargs):\n    return -I*cosh(arg)/cosh(pi*I/2 - arg, evaluate=False)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_sinh": "def _eval_rewrite_as_sinh(self, arg, **kwargs):\n    return -I*sinh(pi*I/2 - arg, evaluate=False)/sinh(arg)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_log": "def _eval_rewrite_as_log(self, arg, **kwargs):\n    return log(1/arg + sqrt(1/arg**2 + 1))",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_atanh": "def _eval_rewrite_as_atanh(self, arg, **kwargs):\n    arg2 = arg**2\n    arg2p1 = arg2 + 1\n    return sqrt(-arg2)/arg*(pi*S.Half -\n                            sqrt(-arg2p1**2)/arg2p1*atanh(sqrt(arg2p1)))",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_asin": "def _eval_rewrite_as_asin(self, x, **kwargs):\n    return sqrt(x - 1)/sqrt(1 - x) * (pi/2 - asin(x))",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_acos": "def _eval_rewrite_as_acos(self, x, **kwargs):\n    return I * acos(I * x, evaluate=False) - I*pi/2",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_asinh": "def _eval_rewrite_as_asinh(self, arg, **kwargs):\n    return asinh(1/arg)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_acosh": "def _eval_rewrite_as_acosh(self, arg, **kwargs):\n    return acosh(1/arg)",
    "sympy.sympy.functions.elementary.hyperbolic._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, arg, **kwargs):\n    return cos(I * arg, evaluate=False)",
    "sympy.sympy.functions.elementary.integers._eval_rewrite_as_ceiling": "def _eval_rewrite_as_ceiling(self, arg, **kwargs):\n    return arg + ceiling(-arg)",
    "sympy.sympy.functions.elementary.integers._eval_rewrite_as_frac": "def _eval_rewrite_as_frac(self, arg, **kwargs):\n    return arg + frac(-arg)",
    "sympy.sympy.functions.elementary.integers._eval_rewrite_as_floor": "def _eval_rewrite_as_floor(self, arg, **kwargs):\n    return arg - floor(arg)",
    "sympy.sympy.functions.elementary.miscellaneous._eval_rewrite_as_Abs": "def _eval_rewrite_as_Abs(self, *args, **kwargs):\n    from sympy.functions.elementary.complexes import Abs\n    s = (args[0] + self.func(*args[1:]))/2\n    d = abs(args[0] - self.func(*args[1:]))/2\n    return (s + d if isinstance(self, Max) else s - d).rewrite(Abs)",
    "sympy.sympy.functions.elementary.miscellaneous._eval_rewrite_as_Heaviside": "def _eval_rewrite_as_Heaviside(self, *args, **kwargs):\n    from sympy.functions.special.delta_functions import Heaviside\n    return Add(*[j*Mul(*[Heaviside(i-j) for i in args if i!=j]) \\\n            for j in args])",
    "sympy.sympy.functions.elementary.miscellaneous._eval_rewrite_as_Piecewise": "def _eval_rewrite_as_Piecewise(self, *args, **kwargs):\n    return _minmax_as_Piecewise('<=', *args)",
    "sympy.sympy.functions.elementary.piecewise.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('''\n            Second argument must be a Boolean,\n            not `%s`''' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    "sympy.sympy.functions.elementary.piecewise._eval_rewrite_as_ITE": "def _eval_rewrite_as_ITE(self, *args, **kwargs):\n    byfree = {}\n    args = list(args)\n    default = any(c == True for b, c in args)\n    for i, (b, c) in enumerate(args):\n        if not isinstance(b, Boolean) and b != True:\n            raise TypeError(filldedent('''\n                Expecting Boolean or bool but got `%s`\n                ''' % func_name(b)))\n        if c == True:\n            break\n        # loop over independent conditions for this b\n        for c in c.args if isinstance(c, Or) else [c]:\n            free = c.free_symbols\n            x = free.pop()\n            try:\n                byfree[x] = byfree.setdefault(\n                    x, S.EmptySet).union(c.as_set())\n            except NotImplementedError:\n                if not default:\n                    raise NotImplementedError(filldedent('''\n                        A method to determine whether a multivariate\n                        conditional is consistent with a complete coverage\n                        of all variables has not been implemented so the\n                        rewrite is being stopped after encountering `%s`.\n                        This error would not occur if a default expression\n                        like `(foo, True)` were given.\n                        ''' % c))\n            if byfree[x] in (S.UniversalSet, S.Reals):\n                # collapse the ith condition to True and break\n                args[i] = list(args[i])\n                c = args[i][1] = True\n                break\n        if c == True:\n            break\n    if c != True:\n        raise ValueError(filldedent('''\n            Conditions must cover all reals or a final default\n            condition `(foo, True)` must be given.\n            '''))\n    last, _ = args[i]  # ignore all past ith arg\n    for a, c in reversed(args[:i]):\n        last = ITE(c, a, last)\n    return _canonical(last)",
    "sympy.sympy.functions.elementary.piecewise._eval_rewrite_as_KroneckerDelta": "def _eval_rewrite_as_KroneckerDelta(self, *args, **kwargs):\n    from sympy.functions.special.tensor_functions import KroneckerDelta\n\n    rules = {\n        And: [False, False],\n        Or: [True, True],\n        Not: [True, False],\n        Eq: [None, None],\n        Ne: [None, None]\n    }\n\n    class UnrecognizedCondition(Exception):\n        pass\n\n    def rewrite(cond):\n        if isinstance(cond, Eq):\n            return KroneckerDelta(*cond.args)\n        if isinstance(cond, Ne):\n            return 1 - KroneckerDelta(*cond.args)\n\n        cls, args = type(cond), cond.args\n        if cls not in rules:\n            raise UnrecognizedCondition(cls)\n\n        b1, b2 = rules[cls]\n        k = Mul(*[1 - rewrite(c) for c in args]) if b1 else Mul(*[rewrite(c) for c in args])\n\n        if b2:\n            return 1 - k\n        return k\n\n    conditions = []\n    true_value = None\n    for value, cond in args:\n        if type(cond) in rules:\n            conditions.append((value, cond))\n        elif cond is S.true:\n            if true_value is None:\n                true_value = value\n        else:\n            return\n\n    if true_value is not None:\n        result = true_value\n\n        for value, cond in conditions[::-1]:\n            try:\n                k = rewrite(cond)\n                result = k * value + (1 - k) * result\n            except UnrecognizedCondition:\n                return\n\n        return result",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_Pow": "def _eval_rewrite_as_Pow(self, arg, **kwargs):\n    if isinstance(arg, log):\n        I = S.ImaginaryUnit\n        x = arg.args[0]\n        return x**I/2 + x**-I/2",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_exp": "def _eval_rewrite_as_exp(self, arg, **kwargs):\n    I = S.ImaginaryUnit\n    from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n    if isinstance(arg, (TrigonometricFunction, HyperbolicFunction)):\n        arg = arg.func(arg.args[0]).rewrite(exp, **kwargs)\n    return (exp(arg*I) + exp(-arg*I))/2",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_sin": "def _eval_rewrite_as_sin(self, arg, **kwargs):\n    return sin(arg + pi/2, evaluate=False)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, arg, **kwargs):\n    return cos(arg - pi/2, evaluate=False)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_sincos": "def _eval_rewrite_as_sincos(self, arg, **kwargs):\n    return sin(arg)*cos(arg)/sin(arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_cot": "def _eval_rewrite_as_cot(self, arg, **kwargs):\n    cot_half = cot(S.Half*arg)**2\n    return Piecewise((1, And(Eq(im(arg), 0), Eq(Mod(arg, 2*pi), 0))),\n                     ((cot_half - 1)/(cot_half + 1), True))",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_sec": "def _eval_rewrite_as_sec(self, arg, **kwargs):\n    return 1/sec(arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_csc": "def _eval_rewrite_as_csc(self, arg, **kwargs):\n    return 1/sec(arg).rewrite(csc, **kwargs)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_sqrt": "def _eval_rewrite_as_sqrt(self, arg: Expr, **kwargs):\n    from sympy.functions.special.polynomials import chebyshevt\n\n    pi_coeff = _pi_coeff(arg)\n    if pi_coeff is None:\n        return None\n\n    if isinstance(pi_coeff, Integer):\n        return None\n\n    if not isinstance(pi_coeff, Rational):\n        return None\n\n    cst_table_some = cos_table()\n\n    if pi_coeff.q in cst_table_some:\n        rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q]())\n        if pi_coeff.q < 257:\n            rv = rv.expand()\n        return rv\n\n    if not pi_coeff.q % 2:  # recursively remove factors of 2\n        pico2 = pi_coeff * 2\n        nval = cos(pico2 * pi).rewrite(sqrt, **kwargs)\n        x = (pico2 + 1) / 2\n        sign_cos = -1 if int(x) % 2 else 1\n        return sign_cos * sqrt((1 + nval) / 2)\n\n    FC = fermat_coords(pi_coeff.q)\n    if FC:\n        denoms = FC\n    else:\n        denoms = [b**e for b, e in factorint(pi_coeff.q).items()]\n\n    apart = ipartfrac(*denoms)\n    decomp = (pi_coeff.p * Rational(n, d) for n, d in zip(apart, denoms))\n    X = [(x[1], x[0]*pi) for x in zip(decomp, numbered_symbols('z'))]\n    pcls = cos(sum(x[0] for x in X))._eval_expand_trig().subs(X)\n\n    if not FC or len(FC) == 1:\n        return pcls\n    return pcls.rewrite(sqrt, **kwargs)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_besselj": "def _eval_rewrite_as_besselj(self, arg, **kwargs):\n    from sympy.functions.special.bessel import besselj\n    return Piecewise(\n            (sqrt(pi*arg/2)*besselj(-S.Half, arg), Ne(arg, 0)),\n            (1, True)\n        )",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_tan": "def _eval_rewrite_as_tan(self, arg, **kwargs):\n    tan_half = tan(S.Half*arg)**2\n    return (1 - tan_half)/(1 + tan_half)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_pow": "def _eval_rewrite_as_pow(self, arg, **kwargs):\n    return self._eval_rewrite_as_sqrt(arg, **kwargs)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_jn": "def _eval_rewrite_as_jn(self, arg, **kwargs):\n    from sympy.functions.special.bessel import jn\n    return jn(0, arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_acos": "def _eval_rewrite_as_acos(self, arg, **kwargs):\n    return pi/2 - acos(1/arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_atan": "def _eval_rewrite_as_atan(self, y, x, **kwargs):\n    return Piecewise((2*atan(y/(x + sqrt(x**2 + y**2))), Ne(y, 0)),\n                     (pi, re(x) < 0),\n                     (0, Ne(x, 0)),\n                     (S.NaN, True))",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_log": "def _eval_rewrite_as_log(self, y, x, **kwargs):\n    return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_acot": "def _eval_rewrite_as_acot(self, arg, **kwargs):\n    return sqrt(arg**2)/arg*(pi/2 - acot(1/sqrt(arg**2 - 1)))",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_asec": "def _eval_rewrite_as_asec(self, arg, **kwargs):\n    return pi/2 - asec(arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_acsc": "def _eval_rewrite_as_acsc(self, arg, **kwargs):\n    return pi/2 - acsc(arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_asin": "def _eval_rewrite_as_asin(self, arg, **kwargs):\n    return asin(1/arg)",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_arg": "def _eval_rewrite_as_arg(self, y, x, **kwargs):\n    if x.is_extended_real and y.is_extended_real:\n        return arg_f(x + y*S.ImaginaryUnit)\n    n = x + S.ImaginaryUnit*y\n    d = x**2 + y**2\n    return arg_f(n/sqrt(d)) - S.ImaginaryUnit*log(abs(n)/sqrt(abs(d)))",
    "sympy.sympy.functions.elementary.trigonometric._eval_rewrite_as_sinc": "def _eval_rewrite_as_sinc(self, arg, **kwargs):\n    return arg*sinc(arg)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_besselj": "def _eval_rewrite_as_besselj(self, nu, z, **kwargs):\n    ai = self._eval_rewrite_as_besseli(*self.args)\n    if ai:\n        return ai.rewrite(besselj)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_bessely": "def _eval_rewrite_as_bessely(self, nu, z, **kwargs):\n    aj = self._eval_rewrite_as_besselj(*self.args)\n    if aj:\n        return aj.rewrite(bessely)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_yn": "def _eval_rewrite_as_yn(self, nu, z, **kwargs):\n    return sqrt(2*z/pi) * yn(nu - S.Half, self.argument)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_jn": "def _eval_rewrite_as_jn(self, nu, z, **kwargs):\n    return self._eval_rewrite_as_besselj(*self.args).rewrite(jn)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_besseli": "def _eval_rewrite_as_besseli(self, nu, z, **kwargs):\n    if nu.is_integer is False:\n        return pi*csc(pi*nu)*(besseli(-nu, z) - besseli(nu, z))/2",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_hyper": "def _eval_rewrite_as_hyper(self, z, **kwargs):\n    pf1 = z**2 / (2*root(3, 6)*gamma(Rational(2, 3)))\n    pf2 = root(3, 6) / gamma(Rational(1, 3))\n    return pf1 * hyper([], [Rational(5, 3)], z**3/9) + pf2 * hyper([], [Rational(1, 3)], z**3/9)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_Integral": "def _eval_rewrite_as_Integral(self, m, a, b, **kwargs):\n    from sympy.integrals.integrals import Integral\n    x = kwargs.get('x', Dummy(uniquely_named_symbol('x').name))\n    return a ** (1 - m) * \\\n           Integral(x**m * exp(-(x**2 + a**2)/2) * besseli(m-1, a*x), [x, b, S.Infinity])",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, m, a, b, **kwargs):\n    from sympy.concrete.summations import Sum\n    k = kwargs.get('k', Dummy('k'))\n    return exp(-(a**2 + b**2) / 2) * Sum((a/b)**k * besseli(k, a*b), [k, 1-m, S.Infinity])",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_intractable": "def _eval_rewrite_as_intractable(self, nu, z, **kwargs):\n    return exp(-z)*besseli(nu, z)",
    "sympy.sympy.functions.special.bessel._eval_rewrite_as_tractable": "def _eval_rewrite_as_tractable(self, nu, z, limitvar=None, **kwargs):\n    if z.is_extended_real:\n        return exp(-z)*_besselk(nu, z)",
    "sympy.sympy.functions.special.bessel.g": "@wraps(fn)\ndef g(self, nu, z):\n    if nu.is_integer:\n        return fn(self, nu, z)",
    "sympy.sympy.functions.special.beta_functions._eval_rewrite_as_gamma": "def _eval_rewrite_as_gamma(self, x, y, piecewise=True, **kwargs):\n    return self._eval_expand_func(**kwargs)",
    "sympy.sympy.functions.special.beta_functions._eval_rewrite_as_Integral": "def _eval_rewrite_as_Integral(self, a, b, x1, x2, **kwargs):\n    from sympy.integrals.integrals import Integral\n    t = Dummy(uniquely_named_symbol('t', [a, b, x1, x2]).name)\n    integrand = t**(a - 1)*(1 - t)**(b - 1)\n    expr = Integral(integrand, (t, x1, x2))\n    return expr / Integral(integrand, (t, 0, 1))",
    "sympy.sympy.functions.special.beta_functions._eval_rewrite_as_hyper": "def _eval_rewrite_as_hyper(self, a, b, x1, x2, **kwargs):\n    from sympy.functions.special.hyper import hyper\n    expr = (x2**a * hyper((a, 1 - b), (a + 1,), x2) - x1**a * hyper((a, 1 - b), (a + 1,), x1)) / a\n    return expr / beta(a, b)",
    "sympy.sympy.functions.special.delta_functions._eval_rewrite_as_Piecewise": "def _eval_rewrite_as_Piecewise(self, arg, H0=None, **kwargs):\n    \"\"\"\n    Represents Heaviside in a Piecewise form.\n\n    Examples\n    ========\n\n    >>> from sympy import Heaviside, Piecewise, Symbol, nan\n    >>> x = Symbol('x')\n\n    >>> Heaviside(x).rewrite(Piecewise)\n    Piecewise((0, x < 0), (1/2, Eq(x, 0)), (1, True))\n\n    >>> Heaviside(x,nan).rewrite(Piecewise)\n    Piecewise((0, x < 0), (nan, Eq(x, 0)), (1, True))\n\n    >>> Heaviside(x - 5).rewrite(Piecewise)\n    Piecewise((0, x < 5), (1/2, Eq(x, 5)), (1, True))\n\n    >>> Heaviside(x**2 - 1).rewrite(Piecewise)\n    Piecewise((0, x**2 < 1), (1/2, Eq(x**2, 1)), (1, True))\n\n    \"\"\"\n    if H0 == 0:\n        return Piecewise((0, arg <= 0), (1, True))\n    if H0 == 1:\n        return Piecewise((0, arg < 0), (1, True))\n    return Piecewise((0, arg < 0), (H0, Eq(arg, 0)), (1, True))",
    "sympy.sympy.functions.special.delta_functions._eval_rewrite_as_SingularityFunction": "def _eval_rewrite_as_SingularityFunction(self, args, H0=S.Half, **kwargs):\n    \"\"\"\n    Returns the Heaviside expression written in the form of Singularity\n    Functions.\n\n    \"\"\"\n    from sympy.solvers import solve\n    from sympy.functions.special.singularity_functions import SingularityFunction\n    if self == Heaviside(0):\n        return SingularityFunction(0, 0, 0)\n    free = self.free_symbols\n    if len(free) == 1:\n        x = (free.pop())\n        return SingularityFunction(x, solve(args, x)[0], 0)\n        # TODO\n        # ((x - 5)**3*Heaviside(x - 5)).rewrite(SingularityFunction) should output\n        # SingularityFunction(x, 5, 0) instead of (x - 5)**3*SingularityFunction(x, 5, 0)\n    else:\n        # I don't know how to handle the case for Heaviside expressions\n        # having arguments with more than one variable.\n        raise TypeError(filldedent('''\n            rewrite(SingularityFunction) does not\n            support arguments with more that one variable.'''))",
    "sympy.sympy.functions.special.delta_functions.__new__": "def __new__(cls, arg, H0=S.Half, **options):\n    if isinstance(H0, Heaviside) and len(H0.args) == 1:\n        H0 = S.Half\n    return super(cls, cls).__new__(cls, arg, H0, **options)",
    "sympy.sympy.functions.special.delta_functions._eval_rewrite_as_sign": "def _eval_rewrite_as_sign(self, arg, H0=S.Half, **kwargs):\n    \"\"\"\n    Represents the Heaviside function in the form of sign function.\n\n    Explanation\n    ===========\n\n    The value of Heaviside(0) must be 1/2 for rewriting as sign to be\n    strictly equivalent. For easier usage, we also allow this rewriting\n    when Heaviside(0) is undefined.\n\n    Examples\n    ========\n\n    >>> from sympy import Heaviside, Symbol, sign, nan\n    >>> x = Symbol('x', real=True)\n    >>> y = Symbol('y')\n\n    >>> Heaviside(x).rewrite(sign)\n    sign(x)/2 + 1/2\n\n    >>> Heaviside(x, 0).rewrite(sign)\n    Piecewise((sign(x)/2 + 1/2, Ne(x, 0)), (0, True))\n\n    >>> Heaviside(x, nan).rewrite(sign)\n    Piecewise((sign(x)/2 + 1/2, Ne(x, 0)), (nan, True))\n\n    >>> Heaviside(x - 2).rewrite(sign)\n    sign(x - 2)/2 + 1/2\n\n    >>> Heaviside(x**2 - 2*x + 1).rewrite(sign)\n    sign(x**2 - 2*x + 1)/2 + 1/2\n\n    >>> Heaviside(y).rewrite(sign)\n    Heaviside(y)\n\n    >>> Heaviside(y**2 - 2*y + 1).rewrite(sign)\n    Heaviside(y**2 - 2*y + 1)\n\n    See Also\n    ========\n\n    sign\n\n    \"\"\"\n    if arg.is_extended_real:\n        pw1 = Piecewise(\n            ((sign(arg) + 1)/2, Ne(arg, 0)),\n            (Heaviside(0, H0=H0), True))\n        pw2 = Piecewise(\n            ((sign(arg) + 1)/2, Eq(Heaviside(0, H0=H0), S.Half)),\n            (pw1, True))\n        return pw2",
    "sympy.sympy.functions.special.elliptic_integrals._eval_rewrite_as_Integral": "def _eval_rewrite_as_Integral(self, *args, **kwargs):\n    from sympy.integrals.integrals import Integral\n    t = Dummy(uniquely_named_symbol('t', args).name)\n    m = self.args[0]\n    return Integral(1/sqrt(1 - m*sin(t)**2), (t, 0, pi/2))",
    "sympy.sympy.functions.special.elliptic_integrals._eval_rewrite_as_hyper": "def _eval_rewrite_as_hyper(self, m, **kwargs):\n    return pi*S.Half*hyper((S.Half, S.Half), (S.One,), m)",
    "sympy.sympy.functions.special.elliptic_integrals._eval_rewrite_as_meijerg": "def _eval_rewrite_as_meijerg(self, m, **kwargs):\n    return meijerg(((S.Half, S.Half), []), ((S.Zero,), (S.Zero,)), -m)/2",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_uppergamma": "def _eval_rewrite_as_uppergamma(self, x, y, **kwargs):\n    from sympy.functions.special.gamma_functions import uppergamma\n    return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(pi)) -\n        sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(pi)))",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_expint": "def _eval_rewrite_as_expint(self, x, y, **kwargs):\n    return erf(y).rewrite(expint) - erf(x).rewrite(expint)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_li": "def _eval_rewrite_as_li(self, z, **kwargs):\n    return li(z) - li(2)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_Si": "def _eval_rewrite_as_Si(self, z, **kwargs):\n    return (Ci(I*log(z)) - I*Si(I*log(z)) -\n            S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_tractable": "def _eval_rewrite_as_tractable(self, z, limitvar=None, **kwargs):\n    return self.rewrite(erf).rewrite(\"tractable\", deep=True, limitvar=limitvar)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_Integral": "def _eval_rewrite_as_Integral(self, z, **kwargs):\n    from sympy.integrals.integrals import Integral\n    t = Dummy(uniquely_named_symbol('t', [z]).name)\n    return Integral(cos(pi*t**2/2), (t, 0, z))",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_Ei": "def _eval_rewrite_as_Ei(self, z, **kwargs):\n    return self._eval_rewrite_as_expint(z).rewrite(Ei)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_Li": "def _eval_rewrite_as_Li(self, z, **kwargs):\n    return Li(z) + li(2)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_Shi": "def _eval_rewrite_as_Shi(self, z, **kwargs):\n    return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_hyper": "def _eval_rewrite_as_hyper(self, x, y, **kwargs):\n    return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_meijerg": "def _eval_rewrite_as_meijerg(self, x, y, **kwargs):\n    return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_fresnels": "def _eval_rewrite_as_fresnels(self, x, y, **kwargs):\n    return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_fresnelc": "def _eval_rewrite_as_fresnelc(self, x, y, **kwargs):\n    return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_erfc": "def _eval_rewrite_as_erfc(self, x, y, **kwargs):\n    return erfc(x) - erfc(y)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_erf": "def _eval_rewrite_as_erf(self, x, y, **kwargs):\n    return erf(y) - erf(x)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_erfi": "def _eval_rewrite_as_erfi(self, x, y, **kwargs):\n    return I*(erfi(I*x)-erfi(I*y))",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_intractable": "def _eval_rewrite_as_intractable(self, z, **kwargs):\n    return exp(-z)*Ei(z)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_erfcinv": "def _eval_rewrite_as_erfcinv(self, z, **kwargs):\n    return erfcinv(1-z)",
    "sympy.sympy.functions.special.error_functions._eval_rewrite_as_erfinv": "def _eval_rewrite_as_erfinv(self, z, **kwargs):\n    return erfinv(1-z)",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_intractable": "def _eval_rewrite_as_intractable(self, z, **kwargs):\n    return log(gamma(z))",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_polygamma": "def _eval_rewrite_as_polygamma(self, z, **kwargs):\n    return polygamma(1, z)",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_zeta": "def _eval_rewrite_as_zeta(self, n, z, **kwargs):\n    if n.is_integer and n.is_positive:\n        return S.NegativeOne**(n + 1)*factorial(n)*zeta(n + 1, z)",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_harmonic": "def _eval_rewrite_as_harmonic(self, n, z, **kwargs):\n    if n.is_integer:\n        if n.is_zero:\n            return harmonic(z - 1) - S.EulerGamma\n        else:\n            return S.NegativeOne**(n+1) * factorial(n) * (zeta(n+1) - harmonic(z-1, n+1))",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_tractable": "def _eval_rewrite_as_tractable(self, s, x, **kwargs):\n    return exp(loggamma(s)) - lowergamma(s, x)",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_factorial": "def _eval_rewrite_as_factorial(self, z, **kwargs):\n    return factorial(z - 1)",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_uppergamma": "def _eval_rewrite_as_uppergamma(self, s, x, **kwargs):\n    return gamma(s) - uppergamma(s, x)",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_expint": "def _eval_rewrite_as_expint(self, s, x, **kwargs):\n    from sympy.functions.special.error_functions import expint\n    return expint(1 - s, x)*x**s",
    "sympy.sympy.functions.special.gamma_functions._eval_rewrite_as_lowergamma": "def _eval_rewrite_as_lowergamma(self, s, x, **kwargs):\n    return gamma(s) - lowergamma(s, x)",
    "sympy.sympy.functions.special.hyper.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 5:\n        args = [(args[0], args[1]), (args[2], args[3]), args[4]]\n    if len(args) != 3:\n        raise TypeError(\"args must be either as, as', bs, bs', z or \"\n                        \"as, bs, z\")\n\n    def tr(p):\n        if len(p) != 2:\n            raise TypeError(\"wrong argument\")\n        p = [list(ordered(i)) for i in p]\n        return TupleArg(_prep_tuple(p[0]), _prep_tuple(p[1]))\n\n    arg0, arg1 = tr(args[0]), tr(args[1])\n    if Tuple(arg0, arg1).has(oo, zoo, -oo):\n        raise ValueError(\"G-function parameters must be finite\")\n    if any((a - b).is_Integer and a - b > 0\n           for a in arg0[0] for b in arg1[0]):\n        raise ValueError(\"no parameter a1, ..., an may differ from \"\n                     \"any b1, ..., bm by a positive integer\")\n\n    # TODO should we check convergence conditions?\n    return super().__new__(cls, arg0, arg1, args[2], **kwargs)",
    "sympy.sympy.functions.special.hyper._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, ap, bq, z, **kwargs):\n    from sympy.concrete.summations import Sum\n    n = Dummy(\"n\", integer=True)\n    rfap = [RisingFactorial(a, n) for a in ap]\n    rfbq = [RisingFactorial(b, n) for b in bq]\n    coeff = Mul(*rfap) / Mul(*rfbq)\n    return Piecewise((Sum(coeff * z**n / factorial(n), (n, 0, oo)),\n                     self.convergence_statement), (self, True))",
    "sympy.sympy.functions.special.hyper._eval_rewrite_as_nonrep": "def _eval_rewrite_as_nonrep(self, *args, **kwargs):\n    x, n = self.args[-1].extract_branch_factor(allow_half=True)\n    minus = False\n    newargs = self.args[:-1] + (x,)\n    if not n.is_Integer:\n        minus = True\n        n -= S.Half\n    newerargs = newargs + (n,)\n    if minus:\n        small = self._expr_small_minus(*newargs)\n        big = self._expr_big_minus(*newerargs)\n    else:\n        small = self._expr_small(*newargs)\n        big = self._expr_big(*newerargs)\n\n    if big == small:\n        return small\n    return Piecewise((big, abs(x) > 1), (small, True))",
    "sympy.sympy.functions.special.hyper._eval_rewrite_as_nonrepsmall": "def _eval_rewrite_as_nonrepsmall(self, *args, **kwargs):\n    x, n = self.args[-1].extract_branch_factor(allow_half=True)\n    args = self.args[:-1] + (x,)\n    if not n.is_Integer:\n        return self._expr_small_minus(*args)\n    return self._expr_small(*args)",
    "sympy.sympy.functions.special.polynomials._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, n, m, x, **kwargs):\n    from sympy.concrete.summations import Sum\n    k = Dummy(\"k\")\n    kern = factorial(2*n - 2*k)/(2**n*factorial(n - k)*factorial(\n        k)*factorial(n - 2*k - m))*S.NegativeOne**k*x**(n - m - 2*k)\n    return (1 - x**2)**(m/2) * Sum(kern, (k, 0, floor((n - m)*S.Half)))",
    "sympy.sympy.functions.special.polynomials._eval_rewrite_as_polynomial": "def _eval_rewrite_as_polynomial(self, n, m, x, **kwargs):\n    # This function is just kept for backwards compatibility\n    # but should not be used\n    return self._eval_rewrite_as_Sum(n, m, x, **kwargs)",
    "sympy.sympy.functions.special.polynomials._eval_rewrite_as_hermite_prob": "def _eval_rewrite_as_hermite_prob(self, n, x, **kwargs):\n    return sqrt(2)**n * hermite_prob(n, x*sqrt(2))",
    "sympy.sympy.functions.special.polynomials._eval_rewrite_as_hermite": "def _eval_rewrite_as_hermite(self, n, x, **kwargs):\n    return sqrt(2)**(-n) * hermite(n, x/sqrt(2))",
    "sympy.sympy.functions.special.singularity_functions._eval_rewrite_as_Piecewise": "def _eval_rewrite_as_Piecewise(self, *args, **kwargs):\n    '''\n    Converts a Singularity Function expression into its Piecewise form.\n\n    '''\n    x, a, n = self.args\n\n    if n in (S.NegativeOne, S(-2), S(-3), S(-4)):\n        return Piecewise((oo, Eq(x - a, 0)), (0, True))\n    elif n.is_nonnegative:\n        return Piecewise(((x - a)**n, x - a >= 0), (0, True))",
    "sympy.sympy.functions.special.singularity_functions._eval_rewrite_as_Heaviside": "def _eval_rewrite_as_Heaviside(self, *args, **kwargs):\n    '''\n    Rewrites a Singularity Function expression using Heavisides and DiracDeltas.\n\n    '''\n    x, a, n = self.args\n\n    if n == -4:\n        return diff(Heaviside(x - a), x.free_symbols.pop(), 4)\n    if n == -3:\n        return diff(Heaviside(x - a), x.free_symbols.pop(), 3)\n    if n == -2:\n        return diff(Heaviside(x - a), x.free_symbols.pop(), 2)\n    if n == -1:\n        return diff(Heaviside(x - a), x.free_symbols.pop(), 1)\n    if n.is_nonnegative:\n        return (x - a)**n*Heaviside(x - a, 1)",
    "sympy.sympy.functions.special.tensor_functions._eval_rewrite_as_Piecewise": "def _eval_rewrite_as_Piecewise(self, *args, **kwargs):\n    i, j = args\n    return Piecewise((0, Ne(i, j)), (1, True))",
    "sympy.sympy.functions.special.zeta_functions._eval_rewrite_as_zeta": "def _eval_rewrite_as_zeta(self, s, **kwargs):\n    from sympy.functions.special.gamma_functions import gamma\n    return s*(s - 1)*gamma(s/2)*zeta(s)/(2*pi**(s/2))",
    "sympy.sympy.functions.special.zeta_functions._eval_rewrite_as_polylog": "def _eval_rewrite_as_polylog(self, z, s, a, **kwargs):\n    return self._eval_rewrite_helper(polylog)",
    "sympy.sympy.functions.special.zeta_functions._eval_rewrite_as_lerchphi": "def _eval_rewrite_as_lerchphi(self, s, a=1, **kwargs):\n    return lerchphi(1, s, a)",
    "sympy.sympy.functions.special.zeta_functions._eval_rewrite_as_bernoulli": "def _eval_rewrite_as_bernoulli(self, s, a=1, **kwargs):\n    if a == 1 and s.is_integer and s.is_nonnegative and s.is_even:\n        return -(2*pi*I)**s * bernoulli(s) / (2*factorial(s))\n    return bernoulli(1-s, a) / (s-1)",
    "sympy.sympy.functions.special.zeta_functions._eval_rewrite_as_dirichlet_eta": "def _eval_rewrite_as_dirichlet_eta(self, s, a=1, **kwargs):\n    if a != 1:\n        return self\n    s = self.args[0]\n    return dirichlet_eta(s)/(1 - 2**(1 - s))",
    "sympy.sympy.functions.special.zeta_functions._eval_rewrite_as_genocchi": "def _eval_rewrite_as_genocchi(self, s, a=S.One, **kwargs):\n    from sympy.functions.special.gamma_functions import digamma\n    return Piecewise((log(2) - digamma(a) + digamma((a+1)/2), Eq(s, 1)),\n            (genocchi(1-s, a) / (2 * (s-1)), True))",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.integrals.transforms._eval_rewrite_as_Integral": "def _eval_rewrite_as_Integral(self, *args, **kwargs):\n    return self.as_integral",
    "sympy.sympy.logic.boolalg._eval_rewrite_as_Or": "def _eval_rewrite_as_Or(self, *args, **kwargs):\n    a = self.args\n    return Or(*[_convert_to_varsSOP(x, self.args)\n                for x in _get_odd_parity_terms(len(a))])",
    "sympy.sympy.logic.boolalg._eval_rewrite_as_And": "def _eval_rewrite_as_And(self, *args, **kwargs):\n    a = self.args\n    return And(*[_convert_to_varsPOS(x, self.args)\n                 for x in _get_even_parity_terms(len(a))])",
    "sympy.sympy.logic.boolalg._eval_rewrite_as_Piecewise": "def _eval_rewrite_as_Piecewise(self, *args, **kwargs):\n    from sympy.functions.elementary.piecewise import Piecewise\n    return Piecewise((args[1], args[0]), (args[2], True))",
    "sympy.sympy.logic.boolalg._eval_rewrite_as_Nor": "def _eval_rewrite_as_Nor(self, *args, **kwargs):\n    return Nor(*[Not(arg) for arg in self.args])",
    "sympy.sympy.logic.boolalg._eval_rewrite_as_Nand": "def _eval_rewrite_as_Nand(self, *args, **kwargs):\n    return Nand(*[Not(arg) for arg in self.args])",
    "sympy.sympy.matrices.expressions.funcmatrix.__new__": "def __new__(cls, rows, cols, lamda):\n    rows, cols = _sympify(rows), _sympify(cols)\n    cls._check_dim(rows)\n    cls._check_dim(cols)\n\n    lamda = sympify(lamda)\n    if not isinstance(lamda, (FunctionClass, Lambda)):\n        raise ValueError(\n            \"{} should be compatible with SymPy function classes.\"\n            .format(lamda))\n\n    if 2 not in lamda.nargs:\n        raise ValueError(\n            '{} should be able to accept 2 arguments.'.format(lamda))\n\n    if not isinstance(lamda, Lambda):\n        i, j = Dummy('i'), Dummy('j')\n        lamda = Lambda((i, j), lamda(i, j))\n\n    return super().__new__(cls, rows, cols, lamda)",
    "sympy.sympy.matrices.expressions.matexpr.__new__": "def __new__(cls, name, n, m):\n    n, m = _sympify(n), _sympify(m)\n\n    cls._check_dim(m)\n    cls._check_dim(n)\n\n    if isinstance(name, str):\n        name = Str(name)\n    obj = Basic.__new__(cls, name, n, m)\n    return obj",
    "sympy.sympy.matrices.expressions.matmul.__new__": "def __new__(cls, *args, evaluate=False, check=None, _sympify=True):\n    if not args:\n        return cls.identity\n\n    # This must be removed aggressively in the constructor to avoid\n    # TypeErrors from GenericIdentity().shape\n    args = list(filter(lambda i: cls.identity != i, args))\n    if _sympify:\n        args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n\n    if check is not None:\n        sympy_deprecation_warning(\n            \"Passing check to MatMul is deprecated and the check argument will be removed in a future version.\",\n            deprecated_since_version=\"1.11\",\n            active_deprecations_target='remove-check-argument-from-matrix-operations')\n\n    if check is not False:\n        validate(*matrices)\n\n    if not matrices:\n        # Should it be\n        #\n        # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n        return factor\n\n    if evaluate:\n        return cls._evaluate(obj)\n\n    return obj",
    "sympy.sympy.matrices.expressions.permutation._eval_rewrite_as_BlockDiagMatrix": "def _eval_rewrite_as_BlockDiagMatrix(self, *args, **kwargs):\n    from sympy.combinatorics.permutations import Permutation\n    from .blockmatrix import BlockDiagMatrix\n\n    perm = self.args[0]\n    full_cyclic_form = perm.full_cyclic_form\n\n    cycles_picks = []\n\n    # Stage 1. Decompose the cycles into the blockable form.\n    a, b, c = 0, 0, 0\n    flag = False\n    for cycle in full_cyclic_form:\n        l = len(cycle)\n        m = max(cycle)\n\n        if not flag:\n            if m + 1 > a + l:\n                flag = True\n                temp = [cycle]\n                b = m\n                c = l\n            else:\n                cycles_picks.append([cycle])\n                a += l\n\n        else:\n            if m > b:\n                if m + 1 == a + c + l:\n                    temp.append(cycle)\n                    cycles_picks.append(temp)\n                    flag = False\n                    a = m+1\n                else:\n                    b = m\n                    temp.append(cycle)\n                    c += l\n            else:\n                if b + 1 == a + c + l:\n                    temp.append(cycle)\n                    cycles_picks.append(temp)\n                    flag = False\n                    a = b+1\n                else:\n                    temp.append(cycle)\n                    c += l\n\n    # Stage 2. Normalize each decomposed cycles and build matrix.\n    p = 0\n    args = []\n    for pick in cycles_picks:\n        new_cycles = []\n        l = 0\n        for cycle in pick:\n            new_cycle = [i - p for i in cycle]\n            new_cycles.append(new_cycle)\n            l += len(cycle)\n        p += l\n        perm = Permutation(new_cycles)\n        mat = PermutationMatrix(perm)\n        args.append(mat)\n\n    return BlockDiagMatrix(*args)",
    "sympy.sympy.matrices.expressions.permutation._eval_rewrite_as_MatMul": "def _eval_rewrite_as_MatMul(self, *args, **kwargs):\n    from .matmul import MatMul\n\n    mat, perm, axis = self.args\n\n    deep = kwargs.get(\"deep\", True)\n\n    if deep:\n        mat = mat.rewrite(MatMul)\n\n    if axis == 0:\n        return MatMul(PermutationMatrix(perm), mat)\n    elif axis == 1:\n        return MatMul(mat, PermutationMatrix(perm**-1))",
    "sympy.sympy.matrices.expressions.trace._eval_rewrite_as_Sum": "def _eval_rewrite_as_Sum(self, expr, **kwargs):\n    from sympy.concrete.summations import Sum\n    i = uniquely_named_symbol('i', [expr])\n    s = Sum(self.arg[i, i], (i, 0, self.arg.rows - 1))\n    return s.doit()",
    "sympy.sympy.matrices.immutable.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    "sympy.sympy.physics.control.lti.__new__": "def __new__(cls, A=None, B=None, C=None, D=None, sampling_time=1):\n    if sampling_time == 0:\n        raise ValueError(filldedent(\"\"\"\n            The sampling time cannot be zero.\n            If you want to create a continuous state space,\n            use the StateSpace class instead.\"\"\"))\n\n    sampling_time = sympify(sampling_time)\n    obj = super(DiscreteStateSpace, cls).__new__(cls, A, B, C, D, sampling_time)\n    obj._sampling_time = sampling_time\n\n    return obj",
    "sympy.sympy.physics.control.lti._eval_rewrite_as_StateSpace": "def _eval_rewrite_as_StateSpace(self, *args):\n    raise TypeError(\"\"\"\n        The discrete transfer function model cannot be rewritten as a\n        continuous-time state space model.\n        \"\"\")",
    "sympy.sympy.physics.control.lti._eval_rewrite_as_DiscreteStateSpace": "def _eval_rewrite_as_DiscreteStateSpace(self, *args):\n    \"\"\"\n    Returns the equivalent space model of the transfer function model.\n    The state space model will be returned in the controllable canonical\n    form.\n\n    Unlike the space state to transfer function model conversion, the\n    transfer function to state space model conversion is not unique.\n    There can be multiple state space representations of a given transfer function model.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import z\n    >>> from sympy.physics.control import DiscreteTransferFunction, DiscreteStateSpace\n    >>> dtf = DiscreteTransferFunction(z**2 + 1, z**3 + z*2 + 10, z, 0.1)\n    >>> dtf.rewrite(DiscreteStateSpace)\n    DiscreteStateSpace(Matrix([\n    [  0,  1, 0],\n    [  0,  0, 1],\n    [-10, -2, 0]]), Matrix([\n    [0],\n    [0],\n    [1]]), Matrix([[1, 0, 1]]), Matrix([[0]]), 0.1)\n\n    \"\"\"\n    A, B, C, D = self._StateSpace_matrices_equivalent()\n    return DiscreteStateSpace(A, B, C, D, self.sampling_time)",
    "sympy.sympy.physics.control.lti._eval_rewrite_as_TransferFunction": "def _eval_rewrite_as_TransferFunction(self, *args):\n    raise TypeError(\"\"\"\n        The discrete state space model cannot be rewritten as a\n        continuous-time transfer function model.\n        \"\"\")",
    "sympy.sympy.physics.control.lti._eval_rewrite_as_DiscreteTransferFunction": "def _eval_rewrite_as_DiscreteTransferFunction(self, *args):\n    \"\"\"\n    Returns the equivalent :class:`~.DiscreteTransferFunction` of the state\n    space model.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.physics.control import DiscreteTransferFunction, DiscreteStateSpace\n    >>> A = Matrix([[-5, -1], [3, -1]])\n    >>> B = Matrix([2, 5])\n    >>> C = Matrix([[1, 2]])\n    >>> D = Matrix([0])\n    >>> ss = DiscreteStateSpace(A, B, C, D)\n    >>> ss.rewrite(DiscreteTransferFunction)\n    [[DiscreteTransferFunction(12*z + 59, z**2 + 6*z + 8, z, 1)]]\n\n    \"\"\"\n    z = Symbol('z')\n    n = self.A.shape[0]\n    I = eye(n)\n    G = self.C*(z*I - self.A).solve(self.B) + self.D\n    G = G.simplify()\n    to_tf = lambda expr: DiscreteTransferFunction.\\\n        from_rational_expression(expr, z, self.sampling_time)\n    tf_mat = [[to_tf(expr) for expr in sublist] for sublist in G.tolist()]\n    return tf_mat",
    "sympy.sympy.physics.control.lti._eval_rewrite_as_TransferFunctionMatrix": "def _eval_rewrite_as_TransferFunctionMatrix(self, sys1, sys2, sign, **kwargs):\n    return self.doit()",
    "sympy.sympy.physics.optics.waves._eval_rewrite_as_sin": "def _eval_rewrite_as_sin(self, *args, **kwargs):\n    return self.amplitude*sin(self.wavenumber*Symbol('x')\n        - self.angular_velocity*Symbol('t') + self.phase + pi/2, evaluate=False)",
    "sympy.sympy.physics.optics.waves._eval_rewrite_as_cos": "def _eval_rewrite_as_cos(self, *args, **kwargs):\n    return self.amplitude*cos(self.wavenumber*Symbol('x')\n        - self.angular_velocity*Symbol('t') + self.phase)",
    "sympy.sympy.physics.optics.waves._eval_rewrite_as_pde": "def _eval_rewrite_as_pde(self, *args, **kwargs):\n    mu, epsilon, x, t = symbols('mu, epsilon, x, t')\n    E = Function('E')\n    return Derivative(E(x, t), x, 2) + mu*epsilon*Derivative(E(x, t), t, 2)",
    "sympy.sympy.physics.optics.waves._eval_rewrite_as_exp": "def _eval_rewrite_as_exp(self, *args, **kwargs):\n    return self.amplitude*exp(I*(self.wavenumber*Symbol('x')\n        - self.angular_velocity*Symbol('t') + self.phase))",
    "sympy.sympy.physics.quantum.qexpr.__new__": "def __new__(cls, *args, **kwargs):\n    \"\"\"Construct a new quantum object.\n\n    Parameters\n    ==========\n\n    args : tuple\n        The list of numbers or parameters that uniquely specify the\n        quantum object. For a state, this will be its symbol or its\n        set of quantum numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.qexpr import QExpr\n    >>> q = QExpr(0)\n    >>> q\n    0\n    >>> q.label\n    (0,)\n    >>> q.hilbert_space\n    H\n    >>> q.args\n    (0,)\n    >>> q.is_commutative\n    False\n    \"\"\"\n\n    # First compute args and call Expr.__new__ to create the instance\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    # Now set the slots on the instance\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    "sympy.sympy.physics.quantum.sho1d._eval_rewrite_as_xp": "def _eval_rewrite_as_xp(self, *args, **kwargs):\n    return (S.One/(Integer(2)*m))*(Px**2 + (m*omega*X)**2)",
    "sympy.sympy.physics.quantum.sho1d._eval_rewrite_as_a": "def _eval_rewrite_as_a(self, *args, **kwargs):\n    return hbar*omega*(ad*a + S.Half)",
    "sympy.sympy.physics.quantum.sho1d._eval_rewrite_as_H": "def _eval_rewrite_as_H(self, *args, **kwargs):\n    return H/(hbar*omega) - S.Half",
    "sympy.sympy.physics.quantum.sho1d._eval_rewrite_as_N": "def _eval_rewrite_as_N(self, *args, **kwargs):\n    return hbar*omega*(N + S.Half)",
    "sympy.sympy.physics.quantum.spin._eval_rewrite_as_Jx": "def _eval_rewrite_as_Jx(self, *args, **options):\n    if isinstance(self, Bra):\n        return self._rewrite_basis(Jx, JxBra, **options)\n    return self._rewrite_basis(Jx, JxKet, **options)",
    "sympy.sympy.physics.quantum.spin._eval_rewrite_as_Jy": "def _eval_rewrite_as_Jy(self, *args, **options):\n    if isinstance(self, Bra):\n        return self._rewrite_basis(Jy, JyBra, **options)\n    return self._rewrite_basis(Jy, JyKet, **options)",
    "sympy.sympy.physics.quantum.spin._eval_rewrite_as_Jz": "def _eval_rewrite_as_Jz(self, *args, **options):\n    if isinstance(self, Bra):\n        return self._rewrite_basis(Jz, JzBra, **options)\n    return self._rewrite_basis(Jz, JzKet, **options)",
    "sympy.sympy.physics.quantum.spin._eval_rewrite_as_xyz": "def _eval_rewrite_as_xyz(self, *args, **kwargs):\n    return JxOp(args[0]) - I*JyOp(args[0])",
    "sympy.sympy.physics.quantum.spin._eval_rewrite_as_plusminus": "def _eval_rewrite_as_plusminus(self, *args, **kwargs):\n    return (JplusOp(args[0]) - JminusOp(args[0]))/(2*I)",
    "sympy.sympy.physics.quantum.spin.__new__": "def __new__(cls, *args, **hints):\n    if not len(args) == 6:\n        raise ValueError('6 parameters expected, got %s' % args)\n    args = sympify(args)\n    evaluate = hints.get('evaluate', False)\n    if evaluate:\n        return Expr.__new__(cls, *args)._eval_wignerd()\n    return Expr.__new__(cls, *args)",
    "sympy.sympy.physics.quantum.tensorproduct._eval_rewrite": "def _eval_rewrite(self, rule, args, **hints):\n    return TensorProduct(*args).expand(tensorproduct=True)",
    "sympy.sympy.physics.units.quantities.__new__": "def __new__(cls, name, abbrev=None,\n            latex_repr=None, pretty_unicode_repr=None,\n            pretty_ascii_repr=None, mathml_presentation_repr=None,\n            is_prefixed=False,\n            **assumptions):\n\n    if not isinstance(name, Symbol):\n        name = Symbol(name)\n\n    if abbrev is None:\n        abbrev = name\n    elif isinstance(abbrev, str):\n        abbrev = Symbol(abbrev)\n\n    # HACK: These are here purely for type checking. They actually get assigned below.\n    cls._is_prefixed = is_prefixed\n\n    obj = AtomicExpr.__new__(cls, name, abbrev)\n    obj._name = name\n    obj._abbrev = abbrev\n    obj._latex_repr = latex_repr\n    obj._unicode_repr = pretty_unicode_repr\n    obj._ascii_repr = pretty_ascii_repr\n    obj._mathml_repr = mathml_presentation_repr\n    obj._is_prefixed = is_prefixed\n    return obj",
    "sympy.sympy.sets.powerset.__new__": "def __new__(cls, arg, evaluate=None):\n    if evaluate is None:\n        evaluate=global_parameters.evaluate\n\n    arg = _sympify(arg)\n\n    if not isinstance(arg, Set):\n        raise ValueError('{} must be a set.'.format(arg))\n\n    return super().__new__(cls, arg)",
    "sympy.sympy.sets.powerset._eval_rewrite_as_FiniteSet": "def _eval_rewrite_as_FiniteSet(self, *args, **kwargs):\n    arg = self.arg\n    if arg.is_FiniteSet:\n        return arg.powerset()\n    return None",
    "sympy.sympy.sets.sets.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n\n    # keep the form of the first canonical arg\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                # e.g. i = class without args like `Interval`\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    "sympy.sympy.sets.sets._eval_rewrite_as_PowerSet": "def _eval_rewrite_as_PowerSet(self, *args, **kwargs):\n    \"\"\"Rewriting method for a finite set to a power set.\"\"\"\n    from .powerset import PowerSet\n\n    is2pow = lambda n: bool(n and not n & (n - 1))\n    if not is2pow(len(self)):\n        return None\n\n    fs_test = lambda arg: isinstance(arg, Set) and arg.is_FiniteSet\n    if not all(fs_test(arg) for arg in args):\n        return None\n\n    biggest = max(args, key=len)\n    for arg in subsets(biggest.args):\n        arg_set = FiniteSet(*arg)\n        if arg_set not in args:\n            return None\n    return PowerSet(biggest)",
    "sympy.sympy.sets.sets._eval_rewrite_as_Union": "def _eval_rewrite_as_Union(self, *sets, **kwargs):\n    \"\"\"\n    Rewrites the disjoint union as the union of (``set`` x {``i``})\n    where ``set`` is the element in ``sets`` at index = ``i``\n    \"\"\"\n\n    dj_union = S.EmptySet\n    index = 0\n    for set_i in sets:\n        if isinstance(set_i, Set):\n            cross = ProductSet(set_i, FiniteSet(index))\n            dj_union = Union(dj_union, cross)\n            index = index + 1\n    return dj_union",
    "sympy.sympy.stats.compound_rv.__new__": "def __new__(cls, s, distribution):\n    s = _symbol_converter(s)\n    if isinstance(distribution, ContinuousDistribution):\n        return SingleContinuousPSpace(s, distribution)\n    if isinstance(distribution, DiscreteDistribution):\n        return SingleDiscretePSpace(s, distribution)\n    if isinstance(distribution, SingleFiniteDistribution):\n        return SingleFinitePSpace(s, distribution)\n    if not isinstance(distribution, CompoundDistribution):\n        raise ValueError(\"%s should be an isinstance of \"\n                    \"CompoundDistribution\"%(distribution))\n    return Basic.__new__(cls, s, distribution)",
    "sympy.sympy.stats.crv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.crv_types.__new__": "def __new__(cls, pdf, set=Interval(-oo, oo)):\n    return Basic.__new__(cls, pdf, set)",
    "sympy.sympy.stats.drv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.frv.__new__": "def __new__(cls, *args):\n    args = list(map(sympify, args))\n    return Basic.__new__(cls, *args)",
    "sympy.sympy.stats.rv.__getattr__": "def __getattr__(self, attr):\n    try:\n        return self.args[self._argnames.index(attr)]\n    except ValueError:\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n            type(self).__name__, attr))",
    "sympy.sympy.stats.rv.__new__": "def __new__(cls, idx_obj, pspace=None):\n    if pspace is None:\n        # Allow single arg, representing pspace == PSpace()\n        pspace = PSpace()\n    if not isinstance(idx_obj, (Indexed, Function)):\n        raise TypeError(\"An Function or Indexed object is expected not %s\"%(idx_obj))\n    return Basic.__new__(cls, idx_obj, pspace)",
    "sympy.sympy.stats.stochastic_process.__new__": "def __new__(cls, sym, process, distribution=None):\n    sym = _symbol_converter(sym)\n    from sympy.stats.stochastic_process_types import StochasticProcess\n    if not isinstance(process, StochasticProcess):\n        raise TypeError(\"`process` must be an instance of StochasticProcess.\")\n    if distribution is None:\n        distribution = Distribution()\n    return Basic.__new__(cls, sym, process, distribution)",
    "sympy.sympy.stats.stochastic_process_types.__new__": "def __new__(cls, sym, state_space=None, trans_probs=None):\n    sym = _symbol_converter(sym)\n\n    state_space, trans_probs = MarkovProcess._sanity_checks(state_space, trans_probs)\n\n    obj = Basic.__new__(cls, sym, state_space, trans_probs) # type: ignore\n    indices = {}\n    if isinstance(obj.number_of_states, Integer):\n        for index, state in enumerate(obj._state_index):\n            indices[state] = index\n    obj.index_of = indices\n    return obj",
    "sympy.sympy.stats.symbolic_probability._eval_rewrite_as_Integral": "def _eval_rewrite_as_Integral(self, X, n, condition=None, **kwargs):\n    return self.rewrite(Expectation).rewrite(Integral)",
    "sympy.sympy.stats.symbolic_probability.__new__": "def __new__(cls, arg, condition=None, **kwargs):\n    arg = _sympify(arg)\n\n    if arg.is_Matrix:\n        from sympy.stats.symbolic_multivariate_probability import VarianceMatrix\n        return VarianceMatrix(arg, condition)\n    if condition is None:\n        obj = Expr.__new__(cls, arg)\n    else:\n        condition = _sympify(condition)\n        obj = Expr.__new__(cls, arg, condition)\n    obj._condition = condition\n    return obj",
    "sympy.sympy.stats.symbolic_probability._eval_rewrite_as_Probability": "def _eval_rewrite_as_Probability(self, X, n, condition=None, **kwargs):\n    return self.rewrite(Expectation).rewrite(Probability)",
    "sympy.sympy.stats.symbolic_probability._eval_rewrite_as_Expectation": "def _eval_rewrite_as_Expectation(self, X, n, condition=None, **kwargs):\n    mu = Expectation(X, condition, **kwargs)\n    return Moment(X, n, mu, condition, **kwargs).rewrite(Expectation)",
    "sympy.sympy.tensor.indexed.__new__": "def __new__(cls, label, range=None, **kw_args):\n\n    if isinstance(label, str):\n        label = Symbol(label, integer=True)\n    label, range = list(map(sympify, (label, range)))\n\n    if label.is_Number:\n        if not label.is_integer:\n            raise TypeError(\"Index is not an integer number.\")\n        return label\n\n    if not label.is_integer:\n        raise TypeError(\"Idx object requires an integer label.\")\n\n    elif is_sequence(range):\n        if len(range) != 2:\n            raise ValueError(filldedent(f\"\"\"\n                Idx range tuple must have length 2, but got {len(range)}\"\"\"))\n        for bound in range:\n            if (bound.is_integer is False and bound is not S.Infinity\n                    and bound is not S.NegativeInfinity):\n                raise TypeError(\"Idx object requires integer bounds.\")\n        args = label, Tuple(*range)\n    elif isinstance(range, Expr):\n        if range is not S.Infinity and fuzzy_not(range.is_integer):\n            raise TypeError(\"Idx object requires an integer dimension.\")\n        args = label, Tuple(0, range - 1)\n    elif range:\n        raise TypeError(filldedent(\"\"\"\n            The range must be an ordered iterable or\n            integer SymPy expression.\"\"\"))\n    else:\n        args = label,\n\n    obj = Expr.__new__(cls, *args, **kw_args)\n    obj._assumptions[\"finite\"] = True\n    obj._assumptions[\"real\"] = True\n    return obj",
    "sympy.sympy.tensor.tensor.__new__": "def __new__(cls, name, index_types, symmetry=None, comm=0):\n    if isinstance(name, str):\n        name_symbol = Symbol(name)\n    elif isinstance(name, Symbol):\n        name_symbol = name\n    else:\n        raise ValueError(\"invalid name\")\n\n    if symmetry is None:\n        symmetry = TensorSymmetry.no_symmetry(len(index_types))\n    else:\n        assert symmetry.rank == len(index_types)\n\n    obj = Basic.__new__(cls, name_symbol, Tuple(*index_types), symmetry, sympify(comm))\n    return obj",
    "sympy.sympy.tensor.tensor._eval_rewrite_as_Indexed": "def _eval_rewrite_as_Indexed(self, *args, **kwargs):\n    from sympy.concrete.summations import Sum\n    index_symbols = [i.args[0] for i in self.get_indices()]\n    args = [arg.args[0] if isinstance(arg, Sum) else arg for arg in args]\n    expr = Mul.fromiter(args)\n    return self._check_add_Sum(expr, index_symbols)",
    "sympy.sympy.vector.coordsysrect.__init__": "def __init__(self, name, location=None, rotation_matrix=None,\n             parent=None, vector_names=None, variable_names=None,\n             latex_vects=None, pretty_vects=None, latex_scalars=None,\n             pretty_scalars=None, transformation=None):\n    # Dummy initializer for setting docstring\n    pass",
    "sympy.sympy.vector.coordsysrect.__new__": "def __new__(cls, name, transformation=None, parent=None, location=None,\n            rotation_matrix=None, vector_names=None, variable_names=None):\n    \"\"\"\n    The orientation/location parameters are necessary if this system\n    is being defined at a certain orientation or location wrt another.\n\n    Parameters\n    ==========\n\n    name : str\n        The name of the new CoordSys3D instance.\n\n    transformation : Lambda, Tuple, str\n        Transformation defined by transformation equations or chosen\n        from predefined ones.\n\n    location : Vector\n        The position vector of the new system's origin wrt the parent\n        instance.\n\n    rotation_matrix : SymPy ImmutableMatrix\n        The rotation matrix of the new coordinate system with respect\n        to the parent. In other words, the output of\n        new_system.rotation_matrix(parent).\n\n    parent : CoordSys3D\n        The coordinate system wrt which the orientation/location\n        (or both) is being defined.\n\n    vector_names, variable_names : iterable(optional)\n        Iterables of 3 strings each, with custom names for base\n        vectors and base scalars of the new system respectively.\n        Used for simple str printing.\n\n    \"\"\"\n\n    name = str(name)\n    Vector = sympy.vector.Vector\n    Point = sympy.vector.Point\n\n    if not isinstance(name, str):\n        raise TypeError(\"name should be a string\")\n\n    if transformation is not None:\n        if (location is not None) or (rotation_matrix is not None):\n            raise ValueError(\"specify either `transformation` or \"\n                             \"`location`/`rotation_matrix`\")\n        if isinstance(transformation, (Tuple, tuple, list)):\n            if isinstance(transformation[0], MatrixBase):\n                rotation_matrix = transformation[0]\n                location = transformation[1]\n            else:\n                transformation = Lambda(transformation[0],\n                                        transformation[1])\n        elif isinstance(transformation, Callable):\n            x1, x2, x3 = symbols('x1 x2 x3', cls=Dummy)\n            transformation = Lambda((x1, x2, x3),\n                                    transformation(x1, x2, x3))\n        elif isinstance(transformation, str):\n            transformation = Str(transformation)\n        elif isinstance(transformation, (Str, Lambda)):\n            pass\n        else:\n            raise TypeError(\"transformation: \"\n                            \"wrong type {}\".format(type(transformation)))\n\n    # If orientation information has been provided, store\n    # the rotation matrix accordingly\n    if rotation_matrix is None:\n        rotation_matrix = ImmutableDenseMatrix(eye(3))\n    else:\n        if not isinstance(rotation_matrix, MatrixBase):\n            raise TypeError(\"rotation_matrix should be an Immutable\" +\n                            \"Matrix instance\")\n        rotation_matrix = rotation_matrix.as_immutable()\n\n    # If location information is not given, adjust the default\n    # location as Vector.zero\n    if parent is not None:\n        if not isinstance(parent, CoordSys3D):\n            raise TypeError(\"parent should be a \" +\n                            \"CoordSys3D/None\")\n        if location is None:\n            location = Vector.zero\n        else:\n            if not isinstance(location, Vector):\n                raise TypeError(\"location should be a Vector\")\n            # Check that location does not contain base\n            # scalars\n            for x in location.free_symbols:\n                if isinstance(x, BaseScalar):\n                    raise ValueError(\"location should not contain\" +\n                                     \" BaseScalars\")\n        origin = parent.origin.locate_new(name + '.origin',\n                                          location)\n    else:\n        location = Vector.zero\n        origin = Point(name + '.origin')\n\n    if transformation is None:\n        transformation = Tuple(rotation_matrix, location)\n\n    if isinstance(transformation, Tuple):\n        lambda_transformation = CoordSys3D._compose_rotation_and_translation(\n            transformation[0],\n            transformation[1],\n            parent\n        )\n        r, l = transformation\n        l = l._projections\n        lambda_lame = CoordSys3D._get_lame_coeff('cartesian')\n        lambda_inverse = lambda x, y, z: r.inv()*Matrix(\n            [x-l[0], y-l[1], z-l[2]])\n    elif isinstance(transformation, Str):\n        trname = transformation.name\n        lambda_transformation = CoordSys3D._get_transformation_lambdas(trname)\n        if parent is not None:\n            if parent.lame_coefficients() != (S.One, S.One, S.One):\n                raise ValueError('Parent for pre-defined coordinate '\n                             'system should be Cartesian.')\n        lambda_lame = CoordSys3D._get_lame_coeff(trname)\n        lambda_inverse = CoordSys3D._set_inv_trans_equations(trname)\n    elif isinstance(transformation, Lambda):\n        if not CoordSys3D._check_orthogonality(transformation):\n            raise ValueError(\"The transformation equation does not \"\n                             \"create orthogonal coordinate system\")\n        lambda_transformation = transformation\n        lambda_lame = CoordSys3D._calculate_lame_coeff(lambda_transformation)\n        lambda_inverse = None\n    else:\n        lambda_transformation = lambda x, y, z: transformation(x, y, z)\n        lambda_lame = CoordSys3D._get_lame_coeff(transformation)\n        lambda_inverse = None\n\n    if variable_names is None:\n        if isinstance(transformation, Lambda):\n            variable_names = [\"x1\", \"x2\", \"x3\"]\n        elif isinstance(transformation, Str):\n            if transformation.name == 'spherical':\n                variable_names = [\"r\", \"theta\", \"phi\"]\n            elif transformation.name == 'cylindrical':\n                variable_names = [\"r\", \"theta\", \"z\"]\n            else:\n                variable_names = [\"x\", \"y\", \"z\"]\n        else:\n            variable_names = [\"x\", \"y\", \"z\"]\n    if vector_names is None:\n        vector_names = [\"i\", \"j\", \"k\"]\n\n    # All systems that are defined as 'roots' are unequal, unless\n    # they have the same name.\n    # Systems defined at same orientation/position wrt the same\n    # 'parent' are equal, irrespective of the name.\n    # This is true even if the same orientation is provided via\n    # different methods like Axis/Body/Space/Quaternion.\n    # However, coincident systems may be seen as unequal if\n    # positioned/oriented wrt different parents, even though\n    # they may actually be 'coincident' wrt the root system.\n    if parent is not None:\n        obj = super().__new__(\n            cls, Str(name), transformation, parent)\n    else:\n        obj = super().__new__(\n            cls, Str(name), transformation)\n    obj._name = name\n    # Initialize the base vectors\n\n    _check_strings('vector_names', vector_names)\n    vector_names = list(vector_names)\n    latex_vects = [(r'\\mathbf{\\hat{%s}_{%s}}' % (x, name)) for\n                       x in vector_names]\n    pretty_vects = ['%s_%s' % (x, name) for x in vector_names]\n\n    obj._vector_names = vector_names\n\n    v1 = BaseVector(0, obj, pretty_vects[0], latex_vects[0])\n    v2 = BaseVector(1, obj, pretty_vects[1], latex_vects[1])\n    v3 = BaseVector(2, obj, pretty_vects[2], latex_vects[2])\n\n    obj._base_vectors = (v1, v2, v3)\n\n    # Initialize the base scalars\n\n    _check_strings('variable_names', vector_names)\n    variable_names = list(variable_names)\n    latex_scalars = [(r\"\\mathbf{{%s}_{%s}}\" % (x, name)) for\n                     x in variable_names]\n    pretty_scalars = ['%s_%s' % (x, name) for x in variable_names]\n\n    obj._variable_names = variable_names\n    obj._vector_names = vector_names\n\n    x1 = BaseScalar(0, obj, pretty_scalars[0], latex_scalars[0])\n    x2 = BaseScalar(1, obj, pretty_scalars[1], latex_scalars[1])\n    x3 = BaseScalar(2, obj, pretty_scalars[2], latex_scalars[2])\n\n    obj._base_scalars = (x1, x2, x3)\n\n    obj._transformation = transformation\n    obj._transformation_lambda = lambda_transformation\n    obj._lame_coefficients = lambda_lame(x1, x2, x3)\n    obj._transformation_from_parent_lambda = lambda_inverse\n\n    setattr(obj, variable_names[0], x1)\n    setattr(obj, variable_names[1], x2)\n    setattr(obj, variable_names[2], x3)\n\n    setattr(obj, vector_names[0], v1)\n    setattr(obj, vector_names[1], v2)\n    setattr(obj, vector_names[2], v3)\n\n    # Assign params\n    obj._parent = parent\n    if obj._parent is not None:\n        obj._root = obj._parent._root\n    else:\n        obj._root = obj\n\n    obj._parent_rotation_matrix = rotation_matrix\n    obj._origin = origin\n\n    # Return the instance\n    return obj",
    "sympy.sympy.vector.scalar.__new__": "def __new__(cls, index, system, pretty_str=None, latex_str=None):\n    from sympy.vector.coordsysrect import CoordSys3D\n    if pretty_str is None:\n        pretty_str = \"x{}\".format(index)\n    elif isinstance(pretty_str, Symbol):\n        pretty_str = pretty_str.name\n    if latex_str is None:\n        latex_str = \"x_{}\".format(index)\n    elif isinstance(latex_str, Symbol):\n        latex_str = latex_str.name\n\n    index = _sympify(index)\n    system = _sympify(system)\n    obj = super().__new__(cls, index, system)\n    if not isinstance(system, CoordSys3D):\n        raise TypeError(\"system should be a CoordSys3D\")\n    if index not in range(0, 3):\n        raise ValueError(\"Invalid index specified.\")\n    # The _id is used for equating purposes, and for hashing\n    obj._id = (index, system)\n    obj._name = obj.name = system._name + '.' + system._variable_names[index]\n    obj._pretty_form = '' + pretty_str\n    obj._latex_form = latex_str\n    obj._system = system\n\n    return obj"
}