{
    "attrs.src.attr._make._make_hash_script": "def _make_hash_script(\n    cls: type, attrs: list[Attribute], frozen: bool, cache_hash: bool\n) -> tuple[str, dict]:\n    attrs = tuple(\n        a for a in attrs if a.hash is True or (a.hash is None and a.eq is True)\n    )\n\n    tab = \"        \"\n\n    type_hash = hash(_generate_unique_filename(cls, \"hash\"))\n    # If eq is custom generated, we need to include the functions in globs\n    globs = {}\n\n    hash_def = \"def __hash__(self\"\n    hash_func = \"hash((\"\n    closing_braces = \"))\"\n    if not cache_hash:\n        hash_def += \"):\"\n    else:\n        hash_def += \", *\"\n\n        hash_def += \", _cache_wrapper=__import__('attr._make')._make._CacheHashWrapper):\"\n        hash_func = \"_cache_wrapper(\" + hash_func\n        closing_braces += \")\"\n\n    method_lines = [hash_def]\n\n    def append_hash_computation_lines(prefix, indent):\n        \"\"\"\n        Generate the code for actually computing the hash code.\n        Below this will either be returned directly or used to compute\n        a value which is then cached, depending on the value of cache_hash\n        \"\"\"\n\n        method_lines.extend(\n            [\n                indent + prefix + hash_func,\n                indent + f\"        {type_hash},\",\n            ]\n        )\n\n        for a in attrs:\n            if a.eq_key:\n                cmp_name = f\"_{a.name}_key\"\n                globs[cmp_name] = a.eq_key\n                method_lines.append(\n                    indent + f\"        {cmp_name}(self.{a.name}),\"\n                )\n            else:\n                method_lines.append(indent + f\"        self.{a.name},\")\n\n        method_lines.append(indent + \"    \" + closing_braces)\n\n    if cache_hash:\n        method_lines.append(tab + f\"if self.{_HASH_CACHE_FIELD} is None:\")\n        if frozen:\n            append_hash_computation_lines(\n                f\"object.__setattr__(self, '{_HASH_CACHE_FIELD}', \", tab * 2\n            )\n            method_lines.append(tab * 2 + \")\")  # close __setattr__\n        else:\n            append_hash_computation_lines(\n                f\"self.{_HASH_CACHE_FIELD} = \", tab * 2\n            )\n        method_lines.append(tab + f\"return self.{_HASH_CACHE_FIELD}\")\n    else:\n        append_hash_computation_lines(\"return \", tab)\n\n    script = \"\\n\".join(method_lines)\n    return script, globs"
}