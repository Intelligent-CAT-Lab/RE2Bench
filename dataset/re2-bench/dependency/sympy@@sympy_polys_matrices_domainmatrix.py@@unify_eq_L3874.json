{
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.polys.domains.domain.__ne__": "def __ne__(self, other):\n    \"\"\"Returns ``False`` if two domains are equivalent. \"\"\"\n    return not self == other",
    "sympy.sympy.polys.matrices.domainmatrix.__eq__": "def __eq__(A, B):\n    r\"\"\"\n    Checks for two DomainMatrix matrices to be equal or not\n\n    Parameters\n    ==========\n\n    A, B: DomainMatrix\n        to check equality\n\n    Returns\n    =======\n\n    Boolean\n        True for equal, else False\n\n    Raises\n    ======\n\n    NotImplementedError\n        If B is not a DomainMatrix\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([\n    ...    [ZZ(1), ZZ(2)],\n    ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n    >>> B = DomainMatrix([\n    ...    [ZZ(1), ZZ(1)],\n    ...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n    >>> A.__eq__(A)\n    True\n    >>> A.__eq__(B)\n    False\n\n    \"\"\"\n    if not isinstance(A, type(B)):\n        return NotImplemented\n    return A.domain == B.domain and A.rep == B.rep",
    "sympy.sympy.polys.matrices.domainmatrix.unify": "def unify(self, *others, fmt=None):\n    \"\"\"\n    Unifies the domains and the format of self and other\n    matrices.\n\n    Parameters\n    ==========\n\n    others : DomainMatrix\n\n    fmt: string 'dense', 'sparse' or `None` (default)\n        The preferred format to convert to if self and other are not\n        already in the same format. If `None` or not specified then no\n        conversion if performed.\n\n    Returns\n    =======\n\n    Tuple[DomainMatrix]\n        Matrices with unified domain and format\n\n    Examples\n    ========\n\n    Unify the domain of DomainMatrix that have different domains:\n\n    >>> from sympy import ZZ, QQ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)\n    >>> Aq, Bq = A.unify(B)\n    >>> Aq\n    DomainMatrix([[1, 2]], (1, 2), QQ)\n    >>> Bq\n    DomainMatrix([[1/2, 2]], (1, 2), QQ)\n\n    Unify the format (dense or sparse):\n\n    >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n    >>> B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)\n    >>> B.rep\n    {0: {0: 1}}\n\n    >>> A2, B2 = A.unify(B, fmt='dense')\n    >>> B2.rep\n    [[1, 0], [0, 0]]\n\n    See Also\n    ========\n\n    convert_to, to_dense, to_sparse\n\n    \"\"\"\n    matrices = (self,) + others\n    matrices = DomainMatrix._unify_domain(*matrices)\n    if fmt is not None:\n        matrices = DomainMatrix._unify_fmt(*matrices, fmt=fmt)\n    return matrices"
}