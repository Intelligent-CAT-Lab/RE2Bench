{
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.core.intfunc.num_digits": "def num_digits(n, base=10):\n    \"\"\"Return the number of digits needed to express n in give base.\n\n    Examples\n    ========\n\n    >>> from sympy.core.intfunc import num_digits\n    >>> num_digits(10)\n    2\n    >>> num_digits(10, 2)  # 1010 -> 4 digits\n    4\n    >>> num_digits(-100, 16)  # -64 -> 2 digits\n    2\n\n\n    Parameters\n    ==========\n\n    n: integer\n        The number whose digits are counted.\n\n    b: integer\n        The base in which digits are computed.\n\n    See Also\n    ========\n    sympy.ntheory.digits.digits, sympy.ntheory.digits.count_digits\n    \"\"\"\n    if base < 0:\n        raise ValueError('base must be int greater than 1')\n    if not n:\n        return 1\n    e, t = integer_log(abs(n), base)\n    return 1 + e",
    "sympy.sympy.core.numbers._as_mpf_val": "def _as_mpf_val(self, prec):\n    rv = mpf_norm(self._mpf_, prec)\n    if rv != self._mpf_ and self._prec == prec:\n        debug(self._mpf_, rv)\n    return rv",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers._decimal_to_Rational_prec": "def _decimal_to_Rational_prec(dec):\n    \"\"\"Convert an ordinary decimal instance to a Rational.\"\"\"\n    if not dec.is_finite():\n        raise TypeError(\"dec must be finite, got %s.\" % dec)\n    s, d, e = dec.as_tuple()\n    prec = len(d)\n    if e >= 0:  # it's an integer\n        rv = Integer(int(dec))\n    else:\n        s = (-1)**s\n        d = sum(di*10**i for i, di in enumerate(reversed(d)))\n        rv = Rational(s*d, 10**-e)\n    return rv, prec",
    "sympy.sympy.core.numbers._literal_float": "def _literal_float(s):\n    \"\"\"return True if s is space-trimmed number literal else False\n\n    Python allows underscore as digit separators: there must be a\n    digit on each side. So neither a leading underscore nor a\n    double underscore are valid as part of a number. A number does\n    not have to precede the decimal point, but there must be a\n    digit before the optional \"e\" or \"E\" that begins the signs\n    exponent of the number which must be an integer, perhaps with\n    underscore separators.\n\n    SymPy allows space as a separator; if the calling routine replaces\n    them with underscores then the same semantics will be enforced\n    for them as for underscores: there can only be 1 *between* digits.\n\n    We don't check for error from float(s) because we don't know\n    whether s is malicious or not. A regex for this could maybe\n    be written but will it be understood by most who read it?\n    \"\"\"\n    # mantissa and exponent\n    parts = s.split('e')\n    if len(parts) > 2:\n        return False\n    if len(parts) == 2:\n        m, e = parts\n        if e.startswith(tuple('+-')):\n            e = e[1:]\n        if not e:\n            return False\n    else:\n        m, e = s, '1'\n    # integer and fraction of mantissa\n    parts = m.split('.')\n    if len(parts) > 2:\n        return False\n    elif len(parts) == 2:\n        i, f = parts\n    else:\n        i, f = m, '1'\n    if not i and not f:\n        return False\n    if i and i[0] in '+-':\n        i = i[1:]\n    if not i:  # -.3e4 -> -0.3e4\n        i = '1'\n    f = f or '1'\n    # check that all groups contain only digits and are not null\n    for n in (i, f, e):\n        for g in n.split('_'):\n            if not g or g.translate(_dig):\n                return False\n    return True",
    "sympy.sympy.core.numbers.<genexpr>": "all(type(i) in (int, int) for i in num)\n",
    "sympy.sympy.core.numbers._new": "@classmethod\ndef _new(cls, _mpf_, _prec, zero=True):\n    # special cases\n    if zero and _mpf_ == fzero:\n        return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    "sympy.sympy.core.sympify._is_numpy_instance": "def _is_numpy_instance(a):\n    \"\"\"\n    Checks if an object is an instance of a type from the numpy module.\n    \"\"\"\n    # This check avoids unnecessarily importing NumPy.  We check the whole\n    # __mro__ in case any base type is a numpy type.\n    return any(type_.__module__ == 'numpy'\n               for type_ in type(a).__mro__)"
}