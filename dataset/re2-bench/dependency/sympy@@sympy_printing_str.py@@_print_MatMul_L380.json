{
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.expr.as_real_imag": "def as_real_imag(self, deep=True, **hints) -> tuple[Expr, Expr]:\n    \"\"\"Performs complex expansion on 'self' and returns a tuple\n       containing collected both real and imaginary parts. This\n       method cannot be confused with re() and im() functions,\n       which does not perform complex expansion at evaluation.\n\n       However it is possible to expand both re() and im()\n       functions and get exactly the same results as with\n       a single call to this function.\n\n       >>> from sympy import symbols, I\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> (x + y*I).as_real_imag()\n       (x, y)\n\n       >>> from sympy.abc import z, w\n\n       >>> (z + w*I).as_real_imag()\n       (re(z) - im(w), re(w) + im(z))\n\n    \"\"\"\n    if hints.get('ignore') == self:\n        return None  # type: ignore\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.mul._keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n\n    If ``clear`` is False, do not keep the coefficient as a factor\n    if it can be distributed on a single factor such that one or\n    more terms will still have integer coefficients.\n\n    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n\n    Examples\n    ========\n\n    >>> from sympy.core.mul import _keep_coeff\n    >>> from sympy.abc import x, y\n    >>> from sympy import S\n\n    >>> _keep_coeff(S.Half, x + 2)\n    (x + 2)/2\n    >>> _keep_coeff(S.Half, x + 2, clear=False)\n    x/2 + 1\n    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n    y*(x + 2)/2\n    >>> _keep_coeff(S(-1), x + y)\n    -x - y\n    >>> _keep_coeff(S(-1), x + y, sign=True)\n    -(x + y)\n    \"\"\"\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = coeff, factors\n        else:\n            return coeff*factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and not sign:\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and coeff.q != 1:\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any(c.is_Integer for c, _ in args):\n                return Add._from_args([Mul._from_args(\n                    i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff*factors\n        if m.is_Number and not factors.is_Number:\n            m = Mul._from_args((coeff, factors))\n        return m",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.One",
    "sympy.sympy.matrices.expressions.matmul.as_coeff_mmul": "def as_coeff_mmul(self):\n    coeff, matrices = self.as_coeff_matrices()\n    return coeff, MatMul(*matrices)",
    "sympy.sympy.printing.str.<listcomp>": "[self.parenthesize(arg, precedence(expr)) for arg in expr.args]\n"
}