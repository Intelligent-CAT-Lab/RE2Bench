{
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.matrices.expressions.matexpr.rows": "@property\ndef rows(self):\n    return self.shape[0]",
    "sympy.sympy.matrices.expressions.matexpr.cols": "@property\ndef cols(self):\n    return self.shape[1]",
    "sympy.sympy.matrices.expressions.matmul.<genexpr>": "if any(arg.is_zero or (arg.is_Matrix and arg.is_ZeroMatrix)\n                   for arg in mul.args):\n    matrices = [arg for arg in mul.args if arg.is_Matrix]\n    return ZeroMatrix(matrices[0].rows, matrices[-1].cols)\n",
    "sympy.sympy.matrices.expressions.matmul.<listcomp>": "matrices = [arg for arg in mul.args if arg.is_Matrix]\n",
    "sympy.sympy.matrices.expressions.special.rows": "@property\ndef rows(self):\n    return self.args[0]",
    "sympy.sympy.matrices.expressions.special.cols": "@property\ndef cols(self):\n    return self.args[0]",
    "sympy.sympy.matrices.expressions.special.__new__": "def __new__(cls, m, n):\n    m, n = _sympify(m), _sympify(n)\n    cls._check_dim(m)\n    cls._check_dim(n)\n\n    return super().__new__(cls, m, n)"
}