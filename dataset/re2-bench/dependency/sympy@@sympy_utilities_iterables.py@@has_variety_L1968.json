{
    "sympy.sympy.combinatorics.perm_groups.<genexpr>": "if has_variety(a.size for a in args):\n    degree = kwargs.pop('degree', None)\n    if degree is None:\n        degree = max(a.size for a in args)\n    for i in range(len(args)):\n        if args[i].size != degree:\n            args[i] = Permutation(args[i], size=degree)\n",
    "sympy.sympy.combinatorics.permutations.<genexpr>": "if has_variety(is_sequence(ai) for ai in a):\n    ok = False\n",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.containers.__ne__": "def __ne__(self, other):\n    if isinstance(other, Basic):\n        return super().__ne__(other)\n    return self.args != other",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.geometry.entity.__ne__": "def __ne__(self, o):\n    \"\"\"Test inequality of two geometrical entities.\"\"\"\n    return not self == o",
    "sympy.sympy.geometry.polygon.<genexpr>": "return not has_variety(s.length for s in self.sides)\n\n",
    "sympy.sympy.physics.vector.frame.__ne__": "def __ne__(self, other):\n    return not self == other"
}