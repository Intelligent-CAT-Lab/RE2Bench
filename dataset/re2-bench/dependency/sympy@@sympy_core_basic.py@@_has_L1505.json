{
    "sympy.sympy.codegen.ast.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.basic.<genexpr>": "    if any(match(arg) for arg in iterargs(self)):\n        return True\n\n# no success\n",
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.containers.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.core.containers.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super().__eq__(other)\n    return self.args == other",
    "sympy.sympy.core.function.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Subs):\n        return False\n    return self._hashable_content() == other._hashable_content()",
    "sympy.sympy.core.function.__hash__": "def __hash__(self):\n    return hash((self.class_key(), frozenset(self._kwargs.items())))",
    "sympy.sympy.core.function.__instancecheck__": "def __instancecheck__(cls, instance):\n    return cls in type(instance).__mro__",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.operations._has_matcher": "def _has_matcher(self):\n    \"\"\"Helper for .has() that checks for containment of\n    subexpressions within an expr by using sets of args\n    of similar nodes, e.g. x + 1 in x + y + 1 checks\n    to see that {x, 1} & {x, y, 1} == {x, 1}\n    \"\"\"\n    def _ncsplit(expr):\n        # this is not the same as args_cnc because here\n        # we don't assume expr is a Mul -- hence deal with args --\n        # and always return a set.\n        cpart, ncpart = sift(expr.args,\n            lambda arg: arg.is_commutative is True, binary=True)\n        return set(cpart), ncpart\n\n    c, nc = _ncsplit(self)\n    cls = self.__class__\n\n    def is_in(expr):\n        if isinstance(expr, cls):\n            if expr == self:\n                return True\n            _c, _nc = _ncsplit(expr)\n            if (c & _c) == c:\n                if not nc:\n                    return True\n                elif len(nc) <= len(_nc):\n                    for i in range(len(_nc) - len(nc) + 1):\n                        if _nc[i:i + len(nc)] == nc:\n                            return True\n        return False\n    return is_in",
    "sympy.sympy.core.sympify._sympify": "def _sympify(a):\n    \"\"\"\n    Short version of :func:`~.sympify` for internal usage for ``__add__`` and\n    ``__eq__`` methods where it is ok to allow some things (like Python\n    integers and floats) in the expression. This excludes things (like strings)\n    that are unwise to allow into such an expression.\n\n    >>> from sympy import Integer\n    >>> Integer(1) == 1\n    True\n\n    >>> Integer(1) == '1'\n    False\n\n    >>> from sympy.abc import x\n    >>> x + 1\n    x + 1\n\n    >>> x + '1'\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n\n    see: sympify\n\n    \"\"\"\n    return sympify(a, strict=True)",
    "sympy.sympy.core.traversal.iterargs": "def iterargs(expr):\n    \"\"\"Yield the args of a Basic object in a breadth-first traversal.\n    Depth-traversal stops if `arg.args` is either empty or is not\n    an iterable.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral, Function\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n    >>> from sympy.core.traversal import iterargs\n    >>> list(iterargs(Integral(f(x), (f(x), 1))))\n    [Integral(f(x), (f(x), 1)), f(x), (f(x), 1), x, f(x), 1, x]\n\n    See Also\n    ========\n    iterfreeargs, preorder_traversal\n    \"\"\"\n    args = [expr]\n    for i in args:\n        yield i\n        args.extend(i.args)",
    "sympy.sympy.core.traversal.iterfreeargs": "def iterfreeargs(expr, _first=True):\n    \"\"\"Yield the args of a Basic object in a breadth-first traversal.\n    Depth-traversal stops if `arg.args` is either empty or is not\n    an iterable. The bound objects of an expression will be returned\n    as canonical variables.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral, Function\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n    >>> from sympy.core.traversal import iterfreeargs\n    >>> list(iterfreeargs(Integral(f(x), (f(x), 1))))\n    [Integral(f(x), (f(x), 1)), 1]\n\n    See Also\n    ========\n    iterargs, preorder_traversal\n    \"\"\"\n    args = [expr]\n    for i in args:\n        yield i\n        if _first and hasattr(i, 'bound_symbols'):\n            void = i.canonical_variables.values()\n            for i in iterfreeargs(i.as_dummy(), _first=False):\n                if not i.has(*void):\n                    yield i\n        args.extend(i.args)",
    "sympy.sympy.functions.elementary.exponential.__instancecheck__": "def __instancecheck__(cls, instance):\n    if exp in instance.__class__.__mro__:\n        return True\n    return isinstance(instance, Pow) and instance.base is S.Exp1",
    "sympy.sympy.geometry.point.__hash__": "def __hash__(self):\n    return hash(self.args)",
    "sympy.sympy.logic.boolalg.__hash__": "def __hash__(self):\n    return hash(False)",
    "sympy.sympy.matrices.immutable.__hash__": "def __hash__(self):\n    return MatrixExpr.__hash__(self)",
    "sympy.sympy.physics.vector.frame.__hash__": "def __hash__(self):\n    return (self._id[0].__hash__(), self._id[1]).__hash__()",
    "sympy.sympy.polys.polytools.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.sets.fancysets.__hash__": "def __hash__(self):\n    return hash(Interval(S.NegativeInfinity, S.Infinity))",
    "sympy.sympy.sets.sets.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.tensor.array.ndim_array.__hash__": "def __hash__(self):\n    return Basic.__hash__(self)",
    "sympy.sympy.vector.basisdependent.__hash__": "def __hash__(self):\n    return self._hash"
}