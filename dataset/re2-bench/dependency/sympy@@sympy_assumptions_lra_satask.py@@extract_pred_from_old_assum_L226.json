{
    "sympy.sympy.assumptions.assume.__call__": "def __call__(self, *args):\n    return AppliedPredicate(self, *args)",
    "sympy.sympy.assumptions.lra_satask.<genexpr>": "if isinstance(expr, Mul) and any(arg.is_real is not True for arg in expr.args):\n    raise UnhandledInput(f\"LRASolver: {expr} must be real\")\n\n",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    \"\"\"Return from the atoms of self those which are free symbols.\n\n    Not all free symbols are ``Symbol`` (see examples)\n\n    For most expressions, all symbols are free symbols. For some classes\n    this is not true. e.g. Integrals use Symbols for the dummy variables\n    which are bound variables, so Integral has a method to return all\n    symbols except those. Derivative keeps track of symbols with respect\n    to which it will perform a derivative; those are\n    bound variables, too, so it has its own free_symbols method.\n\n    Any other method that uses bound variables should implement a\n    free_symbols method.\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative, Integral, IndexedBase\n    >>> from sympy.abc import x, y, n\n    >>> (x + 1).free_symbols\n    {x}\n    >>> Integral(x, y).free_symbols\n    {x, y}\n\n    Not all free symbols are actually symbols:\n\n    >>> IndexedBase('F')[0].free_symbols\n    {F, F[0]}\n\n    The symbols of differentiation are not included unless they\n    appear in the expression being differentiated.\n\n    >>> Derivative(x + y, y).free_symbols\n    {x, y}\n    >>> Derivative(x, y).free_symbols\n    {x}\n    >>> Derivative(x, (y, n)).free_symbols\n    {n, x}\n\n    If you want to know if a symbol is in the variables of the\n    Derivative you can do so as follows:\n\n    >>> Derivative(x, y).has_free(y)\n    True\n    \"\"\"\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.expr.__format__": "def __format__(self, format_spec: str):\n    if self.is_number:\n        mt = re.match(r'\\+?\\d*\\.(\\d+)f', format_spec)\n        if mt:\n            prec = int(mt.group(1))\n            rounded = self.round(prec)\n            if rounded.is_Integer:\n                return format(int(rounded), format_spec)\n            if rounded.is_Float:\n                return format(rounded, format_spec)\n    return super().__format__(format_spec)",
    "sympy.sympy.core.symbol.free_symbols": "@property\ndef free_symbols(self) -> set[Basic]:\n    return {self}",
    "sympy.sympy.utilities.decorator.accessor": "@wraps(propfunc)\ndef accessor(self):\n    val = getattr(self, attrname, sentinel)\n    if val is sentinel:\n        val = propfunc(self)\n        setattr(self, attrname, val)\n    return val"
}