{
    "matplotlib.lib.matplotlib.bezier.split_bezier_intersecting_with_closedpath": "def split_bezier_intersecting_with_closedpath(\n        bezier, inside_closedpath, tolerance=0.01):\n    \"\"\"\n    Split a B\u00e9zier curve into two at the intersection with a closed path.\n\n    Parameters\n    ----------\n    bezier : (N, 2) array-like\n        Control points of the B\u00e9zier segment. See `.BezierSegment`.\n    inside_closedpath : callable\n        A function returning True if a given point (x, y) is inside the\n        closed path. See also `.find_bezier_t_intersecting_with_closedpath`.\n    tolerance : float\n        The tolerance for the intersection. See also\n        `.find_bezier_t_intersecting_with_closedpath`.\n\n    Returns\n    -------\n    left, right\n        Lists of control points for the two B\u00e9zier segments.\n    \"\"\"\n\n    bz = BezierSegment(bezier)\n\n    t0, t1 = find_bezier_t_intersecting_with_closedpath(\n        lambda t: tuple(bz(t)), inside_closedpath, tolerance=tolerance)\n\n    _left, _right = split_de_casteljau(bezier, (t0 + t1) / 2.)\n    return _left, _right",
    "matplotlib.lib.matplotlib.bezier._f": "def _f(xy):\n    x, y = xy\n    return (x - cx) ** 2 + (y - cy) ** 2 < r2",
    "matplotlib.lib.matplotlib.patches.<lambda>": "return lambda xy: patch.contains(\n    SimpleNamespace(x=xy[0], y=xy[1]))[0]\n\n",
    "matplotlib.lib.matplotlib.path.vertices": "@property\ndef vertices(self):\n    \"\"\"The vertices of the `Path` as an (N, 2) array.\"\"\"\n    return self._vertices",
    "matplotlib.lib.matplotlib.path.codes": "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1D array.\n\n    Each code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n    `CLOSEPOLY`.  For codes that correspond to more than one vertex\n    (`CURVE3` and `CURVE4`), that code will be repeated so that the length\n    of `vertices` and `codes` is always the same.\n    \"\"\"\n    return self._codes",
    "matplotlib.lib.matplotlib.path.iter_segments": "def iter_segments(self, transform=None, remove_nans=True, clip=None,\n                  snap=False, stroke_width=1.0, simplify=None,\n                  curves=True, sketch=None):\n    \"\"\"\n    Iterate over all curve segments in the path.\n\n    Each iteration returns a pair ``(vertices, code)``, where ``vertices``\n    is a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\n    Additionally, this method can provide a number of standard cleanups and\n    conversions to the path.\n\n    Parameters\n    ----------\n    transform : None or :class:`~matplotlib.transforms.Transform`\n        If not None, the given affine transformation will be applied to the\n        path.\n    remove_nans : bool, optional\n        Whether to remove all NaNs from the path and skip over them using\n        MOVETO commands.\n    clip : None or (float, float, float, float), optional\n        If not None, must be a four-tuple (x1, y1, x2, y2)\n        defining a rectangle in which to clip the path.\n    snap : None or bool, optional\n        If True, snap all nodes to pixels; if False, don't snap them.\n        If None, snap if the path contains only segments\n        parallel to the x or y axes, and no more than 1024 of them.\n    stroke_width : float, optional\n        The width of the stroke being drawn (used for path snapping).\n    simplify : None or bool, optional\n        Whether to simplify the path by removing vertices\n        that do not affect its appearance.  If None, use the\n        :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n        and :rc:`path.simplify_threshold`.\n    curves : bool, optional\n        If True, curve segments will be returned as curve segments.\n        If False, all curves will be converted to line segments.\n    sketch : None or sequence, optional\n        If not None, must be a 3-tuple of the form\n        (scale, length, randomness), representing the sketch parameters.\n    \"\"\"\n    if not len(self):\n        return\n\n    cleaned = self.cleaned(transform=transform,\n                           remove_nans=remove_nans, clip=clip,\n                           snap=snap, stroke_width=stroke_width,\n                           simplify=simplify, curves=curves,\n                           sketch=sketch)\n\n    # Cache these object lookups for performance in the loop.\n    NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE\n    STOP = self.STOP\n\n    vertices = iter(cleaned.vertices)\n    codes = iter(cleaned.codes)\n    for curr_vertices, code in zip(vertices, codes):\n        if code == STOP:\n            break\n        extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1\n        if extra_vertices:\n            for i in range(extra_vertices):\n                next(codes)\n                curr_vertices = np.append(curr_vertices, next(vertices))\n        yield curr_vertices, code",
    "matplotlib.lib.matplotlib.path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : (N, 2) array-like\n        The path vertices, as an array, masked array or sequence of pairs.\n        Masked values, if any, will be converted to NaNs, which are then\n        handled correctly by the Agg PathIterator and other consumers of\n        path data, such as :meth:`iter_segments`.\n    codes : array-like or None, optional\n        N-length array of integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        `CLOSEPOLY`).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n\n    if codes is not None and len(vertices):\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'. \"\n                             f\"Your vertices have shape {vertices.shape} \"\n                             f\"but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             f\"to 'MOVETO' ({self.MOVETO}).  \"\n                             f\"Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False"
}