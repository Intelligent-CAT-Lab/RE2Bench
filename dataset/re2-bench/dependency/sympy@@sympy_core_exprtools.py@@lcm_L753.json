{
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.exprtools.__init__": "def __init__(self, factors=None):  # Factors\n    \"\"\"Initialize Factors from dict or expr.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x\n    >>> from sympy import I\n    >>> e = 2*x**3\n    >>> Factors(e)\n    Factors({2: 1, x: 3})\n    >>> Factors(e.as_powers_dict())\n    Factors({2: 1, x: 3})\n    >>> f = _\n    >>> f.factors  # underlying dictionary\n    {2: 1, x: 3}\n    >>> f.gens  # base of each factor\n    frozenset({2, x})\n    >>> Factors(0)\n    Factors({0: 1})\n    >>> Factors(I)\n    Factors({I: 1})\n\n    Notes\n    =====\n\n    Although a dictionary can be passed, only minimal checking is\n    performed: powers of -1 and I are made canonical.\n\n    \"\"\"\n    if isinstance(factors, (SYMPY_INTS, float)):\n        factors = S(factors)\n    if isinstance(factors, Factors):\n        factors = factors.factors.copy()\n    elif factors in (None, S.One):\n        factors = {}\n    elif factors is S.Zero or factors == 0:\n        factors = {S.Zero: S.One}\n    elif isinstance(factors, Number):\n        n = factors\n        factors = {}\n        if n < 0:\n            factors[S.NegativeOne] = S.One\n            n = -n\n        if n is not S.One:\n            if n.is_Float or n.is_Integer or n is S.Infinity:\n                factors[n] = S.One\n            elif n.is_Rational:\n                # since we're processing Numbers, the denominator is\n                # stored with a negative exponent; all other factors\n                # are left .\n                if n.p != 1:\n                    factors[Integer(n.p)] = S.One\n                factors[Integer(n.q)] = S.NegativeOne\n            else:\n                raise ValueError('Expected Float|Rational|Integer, not %s' % n)\n    elif isinstance(factors, Basic) and not factors.args:\n        factors = {factors: S.One}\n    elif isinstance(factors, Expr):\n        c, nc = factors.args_cnc()\n        i = c.count(I)\n        for _ in range(i):\n            c.remove(I)\n        factors = dict(Mul._from_args(c).as_powers_dict())\n        # Handle all rational Coefficients\n        for f in list(factors.keys()):\n            if isinstance(f, Rational) and not isinstance(f, Integer):\n                p, q = Integer(f.p), Integer(f.q)\n                factors[p] = (factors[p] if p in factors else S.Zero) + factors[f]\n                factors[q] = (factors[q] if q in factors else S.Zero) - factors[f]\n                factors.pop(f)\n        if i:\n            factors[I] = factors.get(I, S.Zero) + i\n        if nc:\n            factors[Mul(*nc, evaluate=False)] = S.One\n    else:\n        factors = factors.copy()  # /!\\ should be dict-like\n\n        # tidy up -/+1 and I exponents if Rational\n\n        handle = [k for k in factors if k is I or k in (-1, 1)]\n        if handle:\n            i1 = S.One\n            for k in handle:\n                if not _isnumber(factors[k]):\n                    continue\n                i1 *= k**factors.pop(k)\n            if i1 is not S.One:\n                for a in i1.args if i1.is_Mul else [i1]:  # at worst, -1.0*I*(-1)**e\n                    if a is S.NegativeOne:\n                        factors[a] = S.One\n                    elif a is I:\n                        factors[I] = S.One\n                    elif a.is_Pow:\n                        factors[a.base] = factors.get(a.base, S.Zero) + a.exp\n                    elif equal_valued(a, 1):\n                        factors[a] = S.One\n                    elif equal_valued(a, -1):\n                        factors[-a] = S.One\n                        factors[S.NegativeOne] = S.One\n                    else:\n                        raise ValueError('unexpected factor in i1: %s' % a)\n\n    self.factors = factors\n    keys = getattr(factors, 'keys', None)\n    if keys is None:\n        raise TypeError('expecting Expr or dictionary')\n    self.gens = frozenset(keys())",
    "sympy.sympy.core.exprtools.<genexpr>": "if any(f.is_zero for f in (self, other)):\n    return Factors(S.Zero)\n\n",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False"
}