{
    "matplotlib.lib.matplotlib._constrained_layout.make_layoutgrids_gs": "def make_layoutgrids_gs(layoutgrids, gs):\n    \"\"\"\n    Make the layoutgrid for a gridspec (and anything nested in the gridspec)\n    \"\"\"\n\n    if gs in layoutgrids or gs.figure is None:\n        return layoutgrids\n    # in order to do constrained_layout there has to be at least *one*\n    # gridspec in the tree:\n    layoutgrids['hasgrids'] = True\n    if not hasattr(gs, '_subplot_spec'):\n        # normal gridspec\n        parent = layoutgrids[gs.figure]\n        layoutgrids[gs] = mlayoutgrid.LayoutGrid(\n                parent=parent,\n                parent_inner=True,\n                name='gridspec',\n                ncols=gs._ncols, nrows=gs._nrows,\n                width_ratios=gs.get_width_ratios(),\n                height_ratios=gs.get_height_ratios())\n    else:\n        # this is a gridspecfromsubplotspec:\n        subplot_spec = gs._subplot_spec\n        parentgs = subplot_spec.get_gridspec()\n        # if a nested gridspec it is possible the parent is not in there yet:\n        if parentgs not in layoutgrids:\n            layoutgrids = make_layoutgrids_gs(layoutgrids, parentgs)\n        subspeclb = layoutgrids[parentgs]\n        # gridspecfromsubplotspec need an outer container:\n        # get a unique representation:\n        rep = (gs, 'top')\n        if rep not in layoutgrids:\n            layoutgrids[rep] = mlayoutgrid.LayoutGrid(\n                parent=subspeclb,\n                name='top',\n                nrows=1, ncols=1,\n                parent_pos=(subplot_spec.rowspan, subplot_spec.colspan))\n        layoutgrids[gs] = mlayoutgrid.LayoutGrid(\n                parent=layoutgrids[rep],\n                name='gridspec',\n                nrows=gs._nrows, ncols=gs._ncols,\n                width_ratios=gs.get_width_ratios(),\n                height_ratios=gs.get_height_ratios())\n    return layoutgrids",
    "matplotlib.lib.matplotlib._layoutgrid.__init__": "def __init__(self, parent=None, parent_pos=(0, 0),\n             parent_inner=False, name='', ncols=1, nrows=1,\n             h_pad=None, w_pad=None, width_ratios=None,\n             height_ratios=None):\n    Variable = kiwi.Variable\n    self.parent_pos = parent_pos\n    self.parent_inner = parent_inner\n    self.name = name + seq_id()\n    if isinstance(parent, LayoutGrid):\n        self.name = f'{parent.name}.{self.name}'\n    self.nrows = nrows\n    self.ncols = ncols\n    self.height_ratios = np.atleast_1d(height_ratios)\n    if height_ratios is None:\n        self.height_ratios = np.ones(nrows)\n    self.width_ratios = np.atleast_1d(width_ratios)\n    if width_ratios is None:\n        self.width_ratios = np.ones(ncols)\n\n    sn = self.name + '_'\n    if not isinstance(parent, LayoutGrid):\n        # parent can be a rect if not a LayoutGrid\n        # allows specifying a rectangle to contain the layout.\n        self.solver = kiwi.Solver()\n    else:\n        parent.add_child(self, *parent_pos)\n        self.solver = parent.solver\n    # keep track of artist associated w/ this layout.  Can be none\n    self.artists = np.empty((nrows, ncols), dtype=object)\n    self.children = np.empty((nrows, ncols), dtype=object)\n\n    self.margins = {}\n    self.margin_vals = {}\n    # all the boxes in each column share the same left/right margins:\n    for todo in ['left', 'right', 'leftcb', 'rightcb']:\n        # track the value so we can change only if a margin is larger\n        # than the current value\n        self.margin_vals[todo] = np.zeros(ncols)\n\n    sol = self.solver\n\n    self.lefts = [Variable(f'{sn}lefts[{i}]') for i in range(ncols)]\n    self.rights = [Variable(f'{sn}rights[{i}]') for i in range(ncols)]\n    for todo in ['left', 'right', 'leftcb', 'rightcb']:\n        self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                              for i in range(ncols)]\n        for i in range(ncols):\n            sol.addEditVariable(self.margins[todo][i], 'strong')\n\n    for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n        self.margins[todo] = np.empty((nrows), dtype=object)\n        self.margin_vals[todo] = np.zeros(nrows)\n\n    self.bottoms = [Variable(f'{sn}bottoms[{i}]') for i in range(nrows)]\n    self.tops = [Variable(f'{sn}tops[{i}]') for i in range(nrows)]\n    for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n        self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                              for i in range(nrows)]\n        for i in range(nrows):\n            sol.addEditVariable(self.margins[todo][i], 'strong')\n\n    # set these margins to zero by default. They will be edited as\n    # children are filled.\n    self.reset_margins()\n    self.add_constraints(parent)\n\n    self.h_pad = h_pad\n    self.w_pad = w_pad",
    "matplotlib.lib.matplotlib.gridspec.get_width_ratios": "def get_width_ratios(self):\n    \"\"\"\n    Return the width ratios.\n\n    This is *None* if no width ratios have been set explicitly.\n    \"\"\"\n    return self._col_width_ratios",
    "matplotlib.lib.matplotlib.gridspec.get_height_ratios": "def get_height_ratios(self):\n    \"\"\"\n    Return the height ratios.\n\n    This is *None* if no height ratios have been set explicitly.\n    \"\"\"\n    return self._row_height_ratios",
    "matplotlib.lib.matplotlib.gridspec.get_gridspec": "def get_gridspec(self):\n    return self._gridspec",
    "matplotlib.lib.matplotlib.gridspec.rowspan": "@property\ndef rowspan(self):\n    \"\"\"The rows spanned by this subplot, as a `range` object.\"\"\"\n    ncols = self.get_gridspec().ncols\n    return range(self.num1 // ncols, self.num2 // ncols + 1)",
    "matplotlib.lib.matplotlib.gridspec.colspan": "@property\ndef colspan(self):\n    \"\"\"The columns spanned by this subplot, as a `range` object.\"\"\"\n    ncols = self.get_gridspec().ncols\n    # We explicitly support num2 referring to a column on num1's *left*, so\n    # we must sort the column indices here so that the range makes sense.\n    c1, c2 = sorted([self.num1 % ncols, self.num2 % ncols])\n    return range(c1, c2 + 1)"
}