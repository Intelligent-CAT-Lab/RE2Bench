{
    "scikit-learn.sklearn.frozen._frozen.__sklearn_is_fitted__": "def __sklearn_is_fitted__(self):\n    try:\n        check_is_fitted(self.estimator)\n        return True\n    except NotFittedError:\n        return False",
    "scikit-learn.sklearn.pipeline.__sklearn_is_fitted__": "def __sklearn_is_fitted__(self):\n    # Delegate whether feature union was fitted\n    for _, transformer, _ in self._iter():\n        check_is_fitted(transformer)\n    return True",
    "scikit-learn.sklearn.utils._available_if.__get__": "def __get__(self, obj, owner=None):\n    if obj is not None:\n        # delegate only on instances, not the classes.\n        # this is to allow access to the docstrings.\n        self._check(obj, owner=owner)\n        out = MethodType(self.fn, obj)\n\n    else:\n        # This makes it possible to use the decorated method as an unbound method,\n        # for instance when monkeypatching.\n        @wraps(self.fn)\n        def out(*args, **kwargs):\n            self._check(args[0], owner=owner)\n            return self.fn(*args, **kwargs)\n\n    return out",
    "scikit-learn.sklearn.utils.validation.<listcomp>": "fitted_attrs = [\n    v for v in vars(estimator) if v.endswith(\"_\") and not v.startswith(\"__\")\n"
}