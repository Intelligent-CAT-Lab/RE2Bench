{
    "sympy.sympy.core.basic.__hash__": "def __hash__(self) -> int:\n    # hash cannot be cached using cache_it because infinite recurrence\n    # occurs as hash is needed for setting cache dictionary keys\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.__ne__": "def __ne__(self, other):\n    \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n\n    this is the same as:\n\n    ``a.compare(b) != 0``\n\n    but faster\n    \"\"\"\n    return not self == other",
    "sympy.sympy.core.basic.func": "@property\ndef func(self):\n    \"\"\"\n    The top-level function in an expression.\n\n    The following should hold for all objects::\n\n        >> x == x.func(*x.args)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> a = 2*x\n    >>> a.func\n    <class 'sympy.core.mul.Mul'>\n    >>> a.args\n    (2, x)\n    >>> a.func(*a.args)\n    2*x\n    >>> a == a.func(*a.args)\n    True\n\n    \"\"\"\n    return self.__class__",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.expr.extract_multiplicatively": "def extract_multiplicatively(self, c: Expr | complex) -> Expr | None:\n    \"\"\"Return None if it's not possible to make self in the form\n       c * something in a nice way, i.e. preserving the properties\n       of arguments of self.\n\n       Examples\n       ========\n\n       >>> from sympy import symbols, Rational\n\n       >>> x, y = symbols('x,y', real=True)\n\n       >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n       x*y**2\n\n       >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n\n       >>> (2*x).extract_multiplicatively(2)\n       x\n\n       >>> (2*x).extract_multiplicatively(3)\n\n       >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n       x/6\n\n    \"\"\"\n    from sympy.functions.elementary.exponential import exp\n    from .add import _unevaluated_Add\n    c = sympify(c)\n    if self is S.NaN:\n        return None\n    if c is S.One:\n        return self\n    elif c == self:\n        return S.One\n\n    if c.is_Add:\n        cc, pc = c.primitive()\n        if cc is not S.One:\n            c = Mul(cc, pc, evaluate=False)\n\n    if c.is_Mul:\n        a, b = c.as_two_terms() # type: ignore\n        x = self.extract_multiplicatively(a)\n        if x is not None:\n            return x.extract_multiplicatively(b)\n        else:\n            return x\n\n    quotient = self / c\n    if self.is_Number:\n        if self is S.Infinity:\n            if c.is_positive:\n                return S.Infinity\n        elif self is S.NegativeInfinity:\n            if c.is_negative:\n                return S.Infinity\n            elif c.is_positive:\n                return S.NegativeInfinity\n        elif self is S.ComplexInfinity:\n            if not c.is_zero:\n                return S.ComplexInfinity\n        elif self.is_Integer:\n            if not quotient.is_Integer:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Rational:\n            if not quotient.is_Rational:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Float:\n            if not quotient.is_Float:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n        if quotient.is_Mul and len(quotient.args) == 2:\n            if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n                return quotient\n        elif quotient.is_Integer and c.is_Number:\n            return quotient\n    elif self.is_Add:\n        cs, ps = self.primitive()\n        # assert cs >= 1\n        if c.is_Number and c is not S.NegativeOne:\n            # assert c != 1 (handled at top)\n            if cs is not S.One:\n                if c.is_negative:\n                    xc = cs.extract_multiplicatively(-c)\n                    if xc is not None:\n                        xc = -xc\n                else:\n                    xc = cs.extract_multiplicatively(c)\n                if xc is not None:\n                    return xc*ps  # rely on 2-arg Mul to restore Add\n            return None # |c| != 1 can only be extracted from cs\n        if c == ps:\n            return cs\n        # check args of ps\n        newargs = []\n        arg: Expr\n        for arg in ps.args: # type: ignore\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is None:\n                return None # all or nothing\n            newargs.append(newarg)\n        if cs is not S.One:\n            args = [cs*t for t in newargs]\n            # args may be in different order\n            return _unevaluated_Add(*args)\n        else:\n            return Add._from_args(newargs)\n    elif self.is_Mul:\n        args: list[Expr] = list(self.args) # type: ignore\n        for i, arg in enumerate(args):\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is not None:\n                args[i] = newarg\n                return Mul(*args)\n    elif self.is_Pow or isinstance(self, exp):\n        sb, se = self.as_base_exp()\n        cb, ce = c.as_base_exp()\n        if cb == sb:\n            new_exp = se.extract_additively(ce)\n            if new_exp is not None:\n                return Pow(sb, new_exp)\n        elif c == sb:\n            new_exp = se.extract_additively(1)\n            if new_exp is not None:\n                return Pow(sb, new_exp)\n\n    return None",
    "sympy.sympy.core.expr.__neg__": "def __neg__(self) -> Expr:\n    # Mul has its own __neg__ routine, so we just\n    # create a 2-args Mul with the -1 in the canonical\n    # slot 0.\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    "sympy.sympy.core.expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    power = self._pow(other)\n    if mod is None:\n        return power\n    else:\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    "sympy.sympy.core.mul.breakup": "def breakup(eq):\n    \"\"\"break up powers of eq when treated as a Mul:\n           b**(Rational*e) -> b**e, Rational\n        commutatives come back as a dictionary {b**e: Rational}\n        noncommutatives come back as a list [(b**e, Rational)]\n    \"\"\"\n\n    (c, nc) = (defaultdict(int), [])\n    for a in Mul.make_args(eq):\n        a = powdenest(a)\n        (b, e) = base_exp(a)\n        if e is not S.One:\n            (co, _) = e.as_coeff_mul()\n            b = Pow(b, e/co)\n            e = co\n        if a.is_commutative:\n            c[b] += e\n        else:\n            nc.append([b, e])\n    return (c, nc)",
    "sympy.sympy.core.mul.rejoin": "def rejoin(b, co):\n    \"\"\"\n    Put rational back with exponent; in general this is not ok, but\n    since we took it from the exponent for analysis, it's ok to put\n    it back.\n    \"\"\"\n\n    (b, e) = base_exp(b)\n    return Pow(b, e*co)",
    "sympy.sympy.core.mul.ndiv": "def ndiv(a, b):\n    \"\"\"if b divides a in an extractive way (like 1/4 divides 1/2\n    but not vice versa, and 2/5 does not divide 1/3) then return\n    the integer number of times it divides, else return 0.\n    \"\"\"\n    if not b.q % a.q or not a.q % b.q:\n        return int(a/b)\n    return 0",
    "sympy.sympy.core.mul.<setcomp>": "elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):\n    # unmatched non-commutative bases\n    ok = False\n",
    "sympy.sympy.core.mul.<genexpr>": "elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):\n    # differences in sign\n    ok = False\n",
    "sympy.sympy.core.mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        other = Float(other)\n    return Basic.__eq__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return super().__hash__()",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__abs__": "@staticmethod\ndef __abs__():\n    return S.Half",
    "sympy.sympy.core.numbers.__ne__": "def __ne__(self, other):\n    return not self == other",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__rsub__": "def __rsub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other - self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p - self.p*other.q, other.q, 1)\n        return Rational.__rsub__(self, other)\n    return Rational.__rsub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        try:\n            other_int = as_int(other)\n            mod_int = as_int(mod)\n        except ValueError:\n            pass\n        else:\n            return Integer(pow(self.p, other_int, mod_int))\n\n    return super().__pow__(other, mod)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__neg__": "@staticmethod\ndef __neg__():\n    return S.NegativeOne",
    "sympy.sympy.core.singleton.__call__": "def __call__(self, a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    return sympify(a, locals=locals, convert_xor=convert_xor, strict=strict,\n                   rational=rational, evaluate=evaluate) # type: ignore",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.ntheory.factor_.multiplicity": "def multiplicity(p, n):\n    \"\"\"\n    Find the greatest integer m such that p**m divides n.\n\n    Examples\n    ========\n\n    >>> from sympy import multiplicity, Rational\n    >>> [multiplicity(5, n) for n in [8, 5, 25, 125, 250]]\n    [0, 1, 2, 3, 3]\n    >>> multiplicity(3, Rational(1, 9))\n    -2\n\n    Note: when checking for the multiplicity of a number in a\n    large factorial it is most efficient to send it as an unevaluated\n    factorial or to call ``multiplicity_in_factorial`` directly:\n\n    >>> from sympy.ntheory import multiplicity_in_factorial\n    >>> from sympy import factorial\n    >>> p = factorial(25)\n    >>> n = 2**100\n    >>> nfac = factorial(n, evaluate=False)\n    >>> multiplicity(p, nfac)\n    52818775009509558395695966887\n    >>> _ == multiplicity_in_factorial(p, n)\n    True\n\n    See Also\n    ========\n\n    trailing\n\n    \"\"\"\n    try:\n        p, n = as_int(p), as_int(n)\n    except ValueError:\n        from sympy.functions.combinatorial.factorials import factorial\n        if all(isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n)):\n            p = Rational(p)\n            n = Rational(n)\n            if p.q == 1:\n                if n.p == 1:\n                    return -multiplicity(p.p, n.q)\n                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)\n            elif p.p == 1:\n                return multiplicity(p.q, n.q)\n            else:\n                like = min(\n                    multiplicity(p.p, n.p),\n                    multiplicity(p.q, n.q))\n                cross = min(\n                    multiplicity(p.q, n.p),\n                    multiplicity(p.p, n.q))\n                return like - cross\n        elif (isinstance(p, (SYMPY_INTS, Integer)) and\n                isinstance(n, factorial) and\n                isinstance(n.args[0], Integer) and\n                n.args[0] >= 0):\n            return multiplicity_in_factorial(p, n.args[0])\n        raise ValueError(f\"expecting ints or fractions, got {p} and {n}\")\n\n    if n == 0:\n        raise ValueError(f\"no such integer exists: multiplicity of {n} is not-defined\")\n    return remove(n, p)[1]",
    "sympy.sympy.simplify.radsimp.fraction": "def fraction(expr, exact=False):\n    \"\"\"Returns a pair with expression's numerator and denominator.\n       If the given expression is not a fraction then this function\n       will return the tuple (expr, 1).\n\n       This function will not make any attempt to simplify nested\n       fractions or to do any term rewriting at all.\n\n       If only one of the numerator/denominator pair is needed then\n       use numer(expr) or denom(expr) functions respectively.\n\n       >>> from sympy import fraction, Rational, Symbol\n       >>> from sympy.abc import x, y\n\n       >>> fraction(x/y)\n       (x, y)\n       >>> fraction(x)\n       (x, 1)\n\n       >>> fraction(1/y**2)\n       (1, y**2)\n\n       >>> fraction(x*y/2)\n       (x*y, 2)\n       >>> fraction(Rational(1, 2))\n       (1, 2)\n\n       This function will also work fine with assumptions:\n\n       >>> k = Symbol('k', negative=True)\n       >>> fraction(x * y**k)\n       (x, y**(-k))\n\n       If we know nothing about sign of some exponent and ``exact``\n       flag is unset, then the exponent's structure will\n       be analyzed and pretty fraction will be returned:\n\n       >>> from sympy import exp, Mul\n       >>> fraction(2*x**(-y))\n       (2, x**y)\n\n       >>> fraction(exp(-x))\n       (1, exp(x))\n\n       >>> fraction(exp(-x), exact=True)\n       (exp(-x), 1)\n\n       The ``exact`` flag will also keep any unevaluated Muls from\n       being evaluated:\n\n       >>> u = Mul(2, x + 1, evaluate=False)\n       >>> fraction(u)\n       (2*x + 2, 1)\n       >>> fraction(u, exact=True)\n       (2*(x  + 1), 1)\n    \"\"\"\n    expr = sympify(expr)\n\n    numer, denom = [], []\n\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()  # this will cause evaluation\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and not term.is_Integer:\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact)"
}