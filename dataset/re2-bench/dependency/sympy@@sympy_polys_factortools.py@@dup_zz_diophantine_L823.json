{
    "sympy.sympy.polys.densearith.dup_mul": "def dup_mul(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul(x - 2, x + 2)\n    x**2 - 4\n\n    \"\"\"\n    if f == g:\n        return dup_sqr(f, K)\n\n    if not (f and g):\n        return []\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    n = max(df, dg) + 1\n\n    if n < 100 or not K.is_Exact:\n        h: list[Er] = []\n\n        for i in range(0, df + dg + 1):\n            coeff = K.zero\n\n            for j in range(max(0, i - dg), min(df, i) + 1):\n                coeff += f[j]*g[i - j]\n\n            h.append(coeff)\n\n        return dup_strip(h, K)\n    else:\n        # Use Karatsuba's algorithm (divide and conquer), see e.g.:\n        # Joris van der Hoeven, Relax But Don't Be Too Lazy,\n        # J. Symbolic Computation, 11 (2002), section 3.1.1.\n        n2 = n//2\n\n        fl, gl = dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K)\n\n        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)\n        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)\n\n        lo, hi = dup_mul(fl, gl, K), dup_mul(fh, gh, K)\n\n        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)\n        mid = dup_sub(mid, dup_add(lo, hi, K), K)\n\n        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K),\n                       dup_lshift(hi, 2*n2, K), K)",
    "sympy.sympy.polys.factortools.dmp_zz_diophantine": "def dmp_zz_diophantine(F, c, A, d, p, u, K):\n    \"\"\"Wang/EEZ: Solve multivariate Diophantine equations. \"\"\"\n    if not A:\n        S = [ [] for _ in F ]\n        n = dup_degree(c)\n\n        for i, coeff in enumerate(c):\n            if not coeff:\n                continue\n\n            T = dup_zz_diophantine(F, n - i, p, K)\n\n            for j, (s, t) in enumerate(zip(S, T)):\n                t = dup_mul_ground(t, coeff, K)\n                S[j] = dup_trunc(dup_add(s, t, K), p, K)\n    else:\n        n = len(A)\n        e = dmp_expand(F, u, K)\n\n        a, A = A[-1], A[:-1]\n        B, G = [], []\n\n        for f in F:\n            B.append(dmp_quo(e, f, u, K))\n            G.append(dmp_eval_in(f, a, n, u, K))\n\n        C = dmp_eval_in(c, a, n, u, K)\n\n        v = u - 1\n\n        S = dmp_zz_diophantine(G, C, A, d, p, v, K)\n        S = [ dmp_raise(s, 1, v, K) for s in S ]\n\n        for s, b in zip(S, B):\n            c = dmp_sub_mul(c, s, b, u, K)\n\n        c = dmp_ground_trunc(c, p, u, K)\n\n        m = dmp_nest([K.one, -a], n, K)\n        M = dmp_one(n, K)\n\n        for k in range(0, d):\n            if dmp_zero_p(c, u):\n                break\n\n            M = dmp_mul(M, m, u, K)\n            C = dmp_diff_eval_in(c, k + 1, a, n, u, K)\n\n            if not dmp_zero_p(C, v):\n                C = dmp_quo_ground(C, K.factorial(K(k) + 1), v, K)\n                T = dmp_zz_diophantine(G, C, A, d, p, v, K)\n\n                for i, t in enumerate(T):\n                    T[i] = dmp_mul(dmp_raise(t, 1, v, K), M, u, K)\n\n                for i, (s, t) in enumerate(zip(S, T)):\n                    S[i] = dmp_add(s, t, u, K)\n\n                for t, b in zip(T, B):\n                    c = dmp_sub_mul(c, t, b, u, K)\n\n                c = dmp_ground_trunc(c, p, u, K)\n\n        S = [ dmp_ground_trunc(s, p, u, K) for s in S ]\n\n    return S",
    "sympy.sympy.polys.galoistools.gf_gcdex": "def gf_gcdex(\n    f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]\n) -> tuple[dup[MPZ], dup[MPZ], dup[MPZ]]:\n    \"\"\"\n    Extended Euclidean Algorithm in ``GF(p)[x]``.\n\n    Given polynomials ``f`` and ``g`` in ``GF(p)[x]``, computes polynomials\n    ``s``, ``t`` and ``h``, such that ``h = gcd(f, g)`` and ``s*f + t*g = h``.\n    The typical application of EEA is solving polynomial diophantine equations.\n\n    Consider polynomials ``f = (x + 7) (x + 1)``, ``g = (x + 7) (x**2 + 1)``\n    in ``GF(11)[x]``. Application of Extended Euclidean Algorithm gives::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_gcdex, gf_mul, gf_add\n\n       >>> s, t, g = gf_gcdex(ZZ.map([1, 8, 7]), ZZ.map([1, 7, 1, 7]), 11, ZZ)\n       >>> s, t, g\n       ([5, 6], [6], [1, 7])\n\n    As result we obtained polynomials ``s = 5*x + 6`` and ``t = 6``, and\n    additionally ``gcd(f, g) = x + 7``. This is correct because::\n\n       >>> S = gf_mul(s, ZZ.map([1, 8, 7]), 11, ZZ)\n       >>> T = gf_mul(t, ZZ.map([1, 7, 1, 7]), 11, ZZ)\n\n       >>> gf_add(S, T, 11, ZZ) == [1, 7]\n       True\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    if not (f or g):\n        return [K.one], [], []\n\n    p0, r0 = gf_monic(f, p, K)\n    p1, r1 = gf_monic(g, p, K)\n\n    if not f:\n        return [], [K.invert(p1, p)], r1\n    if not g:\n        return [K.invert(p0, p)], [], r0\n\n    s0: dup[MPZ] = [K.invert(p0, p)]\n    s1: dup[MPZ] = []\n    t0: dup[MPZ] = []\n    t1: dup[MPZ] = [K.invert(p1, p)]\n\n    while True:\n        Q, R = gf_div(r0, r1, p, K)\n\n        if not R:\n            break\n\n        (lc, r1), r0 = gf_monic(R, p, K), r1\n\n        inv = K.invert(lc, p)\n\n        s = gf_sub_mul(s0, s1, Q, p, K)\n        t = gf_sub_mul(t0, t1, Q, p, K)\n\n        s1, s0 = gf_mul_ground(s, inv, p, K), s1\n        t1, t0 = gf_mul_ground(t, inv, p, K), t1\n\n    return s1, t1, r1",
    "sympy.sympy.polys.galoistools.gf_from_int_poly": "def gf_from_int_poly(f: dup[MPZ], p: MPZ) -> dup[MPZ]:\n    \"\"\"\n    Create a ``GF(p)[x]`` polynomial from ``Z[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_from_int_poly\n\n    >>> gf_from_int_poly([7, -2, 3], 5)\n    [2, 3, 3]\n\n    \"\"\"\n    return gf_trunc(f, p)",
    "sympy.sympy.polys.galoistools.gf_to_int_poly": "def gf_to_int_poly(f: dup[MPZ], p: MPZ, symmetric: bool = True) -> dup[MPZ]:\n    \"\"\"\n    Convert a ``GF(p)[x]`` polynomial to ``Z[x]``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_to_int_poly\n\n    >>> gf_to_int_poly([2, 3, 3], 5)\n    [2, -2, -2]\n    >>> gf_to_int_poly([2, 3, 3], 5, symmetric=False)\n    [2, 3, 3]\n\n    \"\"\"\n    if symmetric:\n        return [gf_int(c, p) for c in f]\n    else:\n        return f",
    "sympy.sympy.polys.galoistools.gf_add_mul": "def gf_add_mul(\n    f: dup[MPZ], g: dup[MPZ], h: dup[MPZ], p: MPZ, K: Domain[MPZ]\n) -> dup[MPZ]:\n    \"\"\"\n    Returns ``f + g*h`` where ``f``, ``g``, ``h`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_add_mul\n    >>> gf_add_mul([3, 2, 4], [2, 2, 2], [1, 4], 5, ZZ)\n    [2, 3, 2, 2]\n    \"\"\"\n    return gf_add(f, gf_mul(g, h, p, K), p, K)",
    "sympy.sympy.polys.galoistools.gf_div": "def gf_div(\n    f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]\n) -> tuple[dup[MPZ], dup[MPZ]]:\n    \"\"\"\n    Division with remainder in ``GF(p)[x]``.\n\n    Given univariate polynomials ``f`` and ``g`` with coefficients in a\n    finite field with ``p`` elements, returns polynomials ``q`` and ``r``\n    (quotient and remainder) such that ``f = q*g + r``.\n\n    Consider polynomials ``x**3 + x + 1`` and ``x**2 + x`` in GF(2)::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_div, gf_add_mul\n\n       >>> gf_div(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n       ([1, 1], [1])\n\n    As result we obtained quotient ``x + 1`` and remainder ``1``, thus::\n\n       >>> gf_add_mul(ZZ.map([1]), ZZ.map([1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n       [1, 0, 1, 1]\n\n    References\n    ==========\n\n    .. [1] [Monagan93]_\n    .. [2] [Gathen99]_\n\n    \"\"\"\n    df = gf_degree(f)\n    dg = gf_degree(g)\n\n    if not g:\n        raise ZeroDivisionError(\"polynomial division\")\n    elif df < dg:\n        return [], f\n\n    inv = K.invert(g[0], p)\n\n    h, dq, dr = list(f), df - dg, dg - 1\n\n    for i in range(0, df + 1):\n        coeff = h[i]\n\n        for j in range(max(0, dg - i), min(df - i, dr) + 1):\n            coeff -= h[i + j - dg] * g[dg - j]\n\n        if i <= dq:\n            coeff *= inv\n\n        h[i] = coeff % p\n\n    return h[: dq + 1], gf_strip(h[dq + 1 :])",
    "sympy.sympy.polys.galoistools.gf_rem": "def gf_rem(f: dup[MPZ], g: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Compute polynomial remainder in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_rem\n\n    >>> gf_rem(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n    [1]\n\n    \"\"\"\n    return gf_div(f, g, p, K)[1]",
    "sympy.sympy.polys.galoistools.gf_lshift": "def gf_lshift(f: dup[MPZ], n: MPZ, K: Domain[MPZ]) -> dup[MPZ]:\n    \"\"\"\n    Efficiently multiply ``f`` by ``x**n``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_lshift\n\n    >>> gf_lshift([3, 2, 4], 4, ZZ)\n    [3, 2, 4, 0, 0, 0, 0]\n\n    \"\"\"\n    if not f:\n        return f\n    else:\n        return f + [K.zero] * n"
}