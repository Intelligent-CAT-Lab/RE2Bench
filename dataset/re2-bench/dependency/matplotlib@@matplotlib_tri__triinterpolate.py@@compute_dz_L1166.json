{
    "matplotlib.lib.matplotlib.tri._triinterpolate.compute_dz": "def compute_dz(self):\n    \"\"\"\n    self.df is computed as weighted average of _triangles sharing a common\n    node. On each triangle itri f is first assumed linear (= ~f), which\n    allows to compute d~f[itri]\n    Then the following approximation of df nodal values is then proposed:\n        f[ipt] = SUM ( w[itri] x d~f[itri] , for itri sharing apex ipt)\n    The weighted coeff. w[itri] are proportional to the angle of the\n    triangle itri at apex ipt\n    \"\"\"\n    el_geom_w = self.compute_geom_weights()\n    el_geom_grad = self.compute_geom_grads()\n\n    # Sum of weights coeffs\n    w_node_sum = np.bincount(np.ravel(self._triangles),\n                             weights=np.ravel(el_geom_w))\n\n    # Sum of weighted df = (dfx, dfy)\n    dfx_el_w = np.empty_like(el_geom_w)\n    dfy_el_w = np.empty_like(el_geom_w)\n    for iapex in range(3):\n        dfx_el_w[:, iapex] = el_geom_w[:, iapex]*el_geom_grad[:, 0]\n        dfy_el_w[:, iapex] = el_geom_w[:, iapex]*el_geom_grad[:, 1]\n    dfx_node_sum = np.bincount(np.ravel(self._triangles),\n                               weights=np.ravel(dfx_el_w))\n    dfy_node_sum = np.bincount(np.ravel(self._triangles),\n                               weights=np.ravel(dfy_el_w))\n\n    # Estimation of df\n    dfx_estim = dfx_node_sum/w_node_sum\n    dfy_estim = dfy_node_sum/w_node_sum\n    return np.vstack([dfx_estim, dfy_estim]).T",
    "matplotlib.lib.matplotlib.tri._triinterpolate.__init__": "def __init__(self, vals, rows, cols, shape):\n    \"\"\"\n    Create a sparse matrix in COO format.\n    *vals*: arrays of values of non-null entries of the matrix\n    *rows*: int arrays of rows of non-null entries of the matrix\n    *cols*: int arrays of cols of non-null entries of the matrix\n    *shape*: 2-tuple (n, m) of matrix shape\n    \"\"\"\n    self.n, self.m = shape\n    self.vals = np.asarray(vals, dtype=np.float64)\n    self.rows = np.asarray(rows, dtype=np.int32)\n    self.cols = np.asarray(cols, dtype=np.int32)",
    "matplotlib.lib.matplotlib.tri._triinterpolate.dot": "def dot(self, V):\n    \"\"\"\n    Dot product of self by a vector *V* in sparse-dense to dense format\n    *V* dense vector of shape (self.m,).\n    \"\"\"\n    assert V.shape == (self.m,)\n    return np.bincount(self.rows,\n                       weights=self.vals*V[self.cols],\n                       minlength=self.m)",
    "matplotlib.lib.matplotlib.tri._triinterpolate.compress_csc": "def compress_csc(self):\n    \"\"\"\n    Compress rows, cols, vals / summing duplicates. Sort for csc format.\n    \"\"\"\n    _, unique, indices = np.unique(\n        self.rows + self.n*self.cols,\n        return_index=True, return_inverse=True)\n    self.rows = self.rows[unique]\n    self.cols = self.cols[unique]\n    self.vals = np.bincount(indices, weights=self.vals)",
    "matplotlib.lib.matplotlib.tri._triinterpolate._cg": "def _cg(A, b, x0=None, tol=1.e-10, maxiter=1000):\n    \"\"\"\n    Use Preconditioned Conjugate Gradient iteration to solve A x = b\n    A simple Jacobi (diagonal) preconditioner is used.\n\n    Parameters\n    ----------\n    A : _Sparse_Matrix_coo\n        *A* must have been compressed before by compress_csc or\n        compress_csr method.\n    b : array\n        Right hand side of the linear system.\n    x0 : array, optional\n        Starting guess for the solution. Defaults to the zero vector.\n    tol : float, optional\n        Tolerance to achieve. The algorithm terminates when the relative\n        residual is below tol. Default is 1e-10.\n    maxiter : int, optional\n        Maximum number of iterations.  Iteration will stop after *maxiter*\n        steps even if the specified tolerance has not been achieved. Defaults\n        to 1000.\n\n    Returns\n    -------\n    x : array\n        The converged solution.\n    err : float\n        The absolute error np.linalg.norm(A.dot(x) - b)\n    \"\"\"\n    n = b.size\n    assert A.n == n\n    assert A.m == n\n    b_norm = np.linalg.norm(b)\n\n    # Jacobi pre-conditioner\n    kvec = A.diag\n    # For diag elem < 1e-6 we keep 1e-6.\n    kvec = np.maximum(kvec, 1e-6)\n\n    # Initial guess\n    if x0 is None:\n        x = np.zeros(n)\n    else:\n        x = x0\n\n    r = b - A.dot(x)\n    w = r/kvec\n\n    p = np.zeros(n)\n    beta = 0.0\n    rho = np.dot(r, w)\n    k = 0\n\n    # Following C. T. Kelley\n    while (np.sqrt(abs(rho)) > tol*b_norm) and (k < maxiter):\n        p = w + beta*p\n        z = A.dot(p)\n        alpha = rho/np.dot(p, z)\n        r = r - alpha*z\n        w = r/kvec\n        rhoold = rho\n        rho = np.dot(r, w)\n        x = x + alpha*p\n        beta = rho/rhoold\n        # err = np.linalg.norm(A.dot(x) - b)  # absolute accuracy - not used\n        k += 1\n    err = np.linalg.norm(A.dot(x) - b)\n    return x, err",
    "matplotlib.lib.matplotlib.tri._triinterpolate._get_jacobian": "@staticmethod\ndef _get_jacobian(tris_pts):\n    \"\"\"\n    Fast (vectorized) function to compute triangle jacobian matrix.\n\n    Parameters\n    ----------\n    tris_pts : array like of dim 3 (shape: (nx, 3, 2))\n        Coordinates of the containing triangles apexes.\n\n    Returns\n    -------\n    array of dim 3 (shape (nx, 2, 2))\n        Barycentric coordinates of the points inside the containing\n        triangles.\n        J[itri, :, :] is the jacobian matrix at apex 0 of the triangle\n        itri, so that the following (matrix) relationship holds:\n           [dz/dksi] = [J] x [dz/dx]\n        with x: global coordinates\n             ksi: element parametric coordinates in triangle first apex\n             local basis.\n    \"\"\"\n    a = np.array(tris_pts[:, 1, :] - tris_pts[:, 0, :])\n    b = np.array(tris_pts[:, 2, :] - tris_pts[:, 0, :])\n    J = _to_matrix_vectorized([[a[:, 0], a[:, 1]],\n                               [b[:, 0], b[:, 1]]])\n    return J",
    "matplotlib.lib.matplotlib.tri._triinterpolate.get_Kff_and_Ff": "def get_Kff_and_Ff(self, J, ecc, triangles, Uc):\n    \"\"\"\n    Build K and F for the following elliptic formulation:\n    minimization of curvature energy with value of function at node\n    imposed and derivatives 'free'.\n\n    Build the global Kff matrix in cco format.\n    Build the full Ff vec Ff = - Kfc x Uc.\n\n    Parameters\n    ----------\n    *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n    triangle first apex)\n    *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n    eccentricities\n    *triangles* is a (N x 3) array of nodes indexes.\n    *Uc* is (N x 3) array of imposed displacements at nodes\n\n    Returns\n    -------\n    (Kff_rows, Kff_cols, Kff_vals) Kff matrix in COO format - Duplicate\n    (row, col) entries must be summed.\n    Ff: force vector - dim npts * 3\n    \"\"\"\n    ntri = np.size(ecc, 0)\n    vec_range = np.arange(ntri, dtype=np.int32)\n    c_indices = np.full(ntri, -1, dtype=np.int32)  # for unused dofs, -1\n    f_dof = [1, 2, 4, 5, 7, 8]\n    c_dof = [0, 3, 6]\n\n    # vals, rows and cols indices in global dof numbering\n    f_dof_indices = _to_matrix_vectorized([[\n        c_indices, triangles[:, 0]*2, triangles[:, 0]*2+1,\n        c_indices, triangles[:, 1]*2, triangles[:, 1]*2+1,\n        c_indices, triangles[:, 2]*2, triangles[:, 2]*2+1]])\n\n    expand_indices = np.ones([ntri, 9, 1], dtype=np.int32)\n    f_row_indices = _transpose_vectorized(expand_indices @ f_dof_indices)\n    f_col_indices = expand_indices @ f_dof_indices\n    K_elem = self.get_bending_matrices(J, ecc)\n\n    # Extracting sub-matrices\n    # Explanation & notations:\n    # * Subscript f denotes 'free' degrees of freedom (i.e. dz/dx, dz/dx)\n    # * Subscript c denotes 'condensated' (imposed) degrees of freedom\n    #    (i.e. z at all nodes)\n    # * F = [Ff, Fc] is the force vector\n    # * U = [Uf, Uc] is the imposed dof vector\n    #        [ Kff Kfc ]\n    # * K =  [         ]  is the laplacian stiffness matrix\n    #        [ Kcf Kff ]\n    # * As F = K x U one gets straightforwardly: Ff = - Kfc x Uc\n\n    # Computing Kff stiffness matrix in sparse COO format\n    Kff_vals = np.ravel(K_elem[np.ix_(vec_range, f_dof, f_dof)])\n    Kff_rows = np.ravel(f_row_indices[np.ix_(vec_range, f_dof, f_dof)])\n    Kff_cols = np.ravel(f_col_indices[np.ix_(vec_range, f_dof, f_dof)])\n\n    # Computing Ff force vector in sparse COO format\n    Kfc_elem = K_elem[np.ix_(vec_range, f_dof, c_dof)]\n    Uc_elem = np.expand_dims(Uc, axis=2)\n    Ff_elem = -(Kfc_elem @ Uc_elem)[:, :, 0]\n    Ff_indices = f_dof_indices[np.ix_(vec_range, [0], f_dof)][:, 0, :]\n\n    # Extracting Ff force vector in dense format\n    # We have to sum duplicate indices -  using bincount\n    Ff = np.bincount(np.ravel(Ff_indices), weights=np.ravel(Ff_elem))\n    return Kff_rows, Kff_cols, Kff_vals, Ff"
}