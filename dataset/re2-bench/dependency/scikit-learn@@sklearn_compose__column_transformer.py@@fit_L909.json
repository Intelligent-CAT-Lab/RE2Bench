{
    "scikit-learn.sklearn.utils._metadata_requests._raise_for_params": "def _raise_for_params(params, owner, method, allow=None):\n    \"\"\"Raise an error if metadata routing is not enabled and params are passed.\n\n    .. versionadded:: 1.4\n\n    Parameters\n    ----------\n    params : dict\n        The metadata passed to a method.\n\n    owner : object\n        The object to which the method belongs.\n\n    method : str\n        The name of the method, e.g. \"fit\".\n\n    allow : list of str, default=None\n        A list of parameters which are allowed to be passed even if metadata\n        routing is not enabled.\n\n    Raises\n    ------\n    ValueError\n        If metadata routing is not enabled and params are passed.\n    \"\"\"\n    caller = f\"{_routing_repr(owner)}.{method}\" if method else _routing_repr(owner)\n\n    allow = allow if allow is not None else {}\n\n    if not _routing_enabled() and (params.keys() - allow):\n        raise ValueError(\n            f\"Passing extra keyword arguments to {caller} is only supported if\"\n            \" enable_metadata_routing=True, which you can set using\"\n            \" `sklearn.set_config`. See the User Guide\"\n            \" <https://scikit-learn.org/stable/metadata_routing.html> for more\"\n            f\" details. Extra parameters passed are: {set(params)}\"\n        )",
    "scikit-learn.sklearn.utils._set_output.wrapped": "@wraps(f)\ndef wrapped(self, X, *args, **kwargs):\n    data_to_wrap = f(self, X, *args, **kwargs)\n    if isinstance(data_to_wrap, tuple):\n        # only wrap the first output for cross decomposition\n        return_tuple = (\n            _wrap_data_with_container(method, data_to_wrap[0], X, self),\n            *data_to_wrap[1:],\n        )\n        # Support for namedtuples `_make` is a documented API for namedtuples:\n        # https://docs.python.org/3/library/collections.html#collections.somenamedtuple._make\n        if hasattr(type(data_to_wrap), \"_make\"):\n            return type(data_to_wrap)._make(return_tuple)\n        return return_tuple\n\n    return _wrap_data_with_container(method, data_to_wrap, X, self)"
}