{
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.symbol.__new__": "def __new__(cls, name: str | None = None,\n                 dummy_index: int | None = None,\n                 **assumptions: bool | None) -> Self:\n    if dummy_index is not None:\n        assert name is not None, \"If you specify a dummy_index, you must also provide a name\"\n\n    if name is None:\n        name = \"Dummy_\" + str(Dummy._count)\n\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n\n    obj.dummy_index = dummy_index\n\n    return obj",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.polys.appellseqs.dup_bernoulli_c": "def dup_bernoulli_c(n, K):\n    \"\"\"Low-level implementation of central Bernoulli polynomials.\"\"\"\n    p = [K.one]\n    for i in range(1, n+1):\n        p = dup_integrate(dup_mul_ground(p, K(i), K), 1, K)\n        if i % 2 == 0:\n            p = dup_sub_ground(p, dup_eval(p, K.one, K) * K((1<<(i-1))-1, (1<<i)-1), K)\n    return p",
    "sympy.sympy.polys.appellseqs.dup_genocchi": "def dup_genocchi(n, K):\n    \"\"\"Low-level implementation of Genocchi polynomials.\"\"\"\n    if n < 1:\n        return [K.zero]\n    p = [-K.one]\n    for i in range(2, n+1):\n        p = dup_integrate(dup_mul_ground(p, K(i), K), 1, K)\n        if i % 2 == 0:\n            p = dup_sub_ground(p, dup_eval(p, K.one, K) // K(2), K)\n    return p",
    "sympy.sympy.polys.appellseqs.dup_euler": "def dup_euler(n, K):\n    \"\"\"Low-level implementation of Euler polynomials.\"\"\"\n    return dup_quo_ground(dup_genocchi(n+1, ZZ), K(-n-1), K)",
    "sympy.sympy.polys.appellseqs.dup_andre": "def dup_andre(n, K):\n    \"\"\"Low-level implementation of Andre polynomials.\"\"\"\n    p = [K.one]\n    for i in range(1, n+1):\n        p = dup_integrate(dup_mul_ground(p, K(i), K), 1, K)\n        if i % 2 == 0:\n            p = dup_sub_ground(p, dup_eval(p, K.one, K), K)\n    return p",
    "sympy.sympy.polys.appellseqs.dup_bernoulli": "def dup_bernoulli(n, K):\n    \"\"\"Low-level implementation of Bernoulli polynomials.\"\"\"\n    if n < 1:\n        return [K.one]\n    p = [K.one, K(-1,2)]\n    for i in range(2, n+1):\n        p = dup_integrate(dup_mul_ground(p, K(i), K), 1, K)\n        if i % 2 == 0:\n            p = dup_sub_ground(p, dup_eval(p, K(1,2), K) * K(1<<(i-1), (1<<i)-1), K)\n    return p",
    "sympy.sympy.polys.constructor.construct_domain": "@public\ndef construct_domain(obj, **args):\n    \"\"\"Construct a minimal domain for a list of expressions.\n\n    Explanation\n    ===========\n\n    Given a list of normal SymPy expressions (of type :py:class:`~.Expr`)\n    ``construct_domain`` will find a minimal :py:class:`~.Domain` that can\n    represent those expressions. The expressions will be converted to elements\n    of the domain and both the domain and the domain elements are returned.\n\n    Parameters\n    ==========\n\n    obj: list or dict\n        The expressions to build a domain for.\n\n    **args: keyword arguments\n        Options that affect the choice of domain.\n\n    Returns\n    =======\n\n    (K, elements): Domain and list of domain elements\n        The domain K that can represent the expressions and the list or dict\n        of domain elements representing the same expressions as elements of K.\n\n    Examples\n    ========\n\n    Given a list of :py:class:`~.Integer` ``construct_domain`` will return the\n    domain :ref:`ZZ` and a list of integers as elements of :ref:`ZZ`.\n\n    >>> from sympy import construct_domain, S\n    >>> expressions = [S(2), S(3), S(4)]\n    >>> K, elements = construct_domain(expressions)\n    >>> K\n    ZZ\n    >>> elements\n    [2, 3, 4]\n    >>> type(elements[0])  # doctest: +SKIP\n    <class 'int'>\n    >>> type(expressions[0])\n    <class 'sympy.core.numbers.Integer'>\n\n    If there are any :py:class:`~.Rational` then :ref:`QQ` is returned\n    instead.\n\n    >>> construct_domain([S(1)/2, S(3)/4])\n    (QQ, [1/2, 3/4])\n\n    If there are symbols then a polynomial ring :ref:`K[x]` is returned.\n\n    >>> from sympy import symbols\n    >>> x, y = symbols('x, y')\n    >>> construct_domain([2*x + 1, S(3)/4])\n    (QQ[x], [2*x + 1, 3/4])\n    >>> construct_domain([2*x + 1, y])\n    (ZZ[x,y], [2*x + 1, y])\n\n    If any symbols appear with negative powers then a rational function field\n    :ref:`K(x)` will be returned.\n\n    >>> construct_domain([y/x, x/(1 - y)])\n    (ZZ(x,y), [y/x, -x/(y - 1)])\n\n    Irrational algebraic numbers will result in the :ref:`EX` domain by\n    default. The keyword argument ``extension=True`` leads to the construction\n    of an algebraic number field :ref:`QQ(a)`.\n\n    >>> from sympy import sqrt\n    >>> construct_domain([sqrt(2)])\n    (EX, [EX(sqrt(2))])\n    >>> construct_domain([sqrt(2)], extension=True)  # doctest: +SKIP\n    (QQ<sqrt(2)>, [ANP([1, 0], [1, 0, -2], QQ)])\n\n    See also\n    ========\n\n    Domain\n    Expr\n    \"\"\"\n    opt = build_options(args)\n\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            if not obj:\n                monoms, coeffs = [], []\n            else:\n                monoms, coeffs = list(zip(*list(obj.items())))\n        else:\n            coeffs = obj\n    else:\n        coeffs = [obj]\n\n    coeffs = list(map(sympify, coeffs))\n    result = _construct_simple(coeffs, opt)\n\n    if result is not None:\n        if result is not False:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    else:\n        if opt.composite is False:\n            result = None\n        else:\n            result = _construct_composite(coeffs, opt)\n\n        if result is not None:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            return domain, dict(list(zip(monoms, coeffs)))\n        else:\n            return domain, coeffs\n    else:\n        return domain, coeffs[0]",
    "sympy.sympy.polys.orthopolys.dup_chebyshevu": "def dup_chebyshevu(n, K):\n    \"\"\"Low-level implementation of Chebyshev polynomials of the second kind.\"\"\"\n    if n < 1:\n        return [K.one]\n    m2, m1 = [K.one], [K(2), K.zero]\n    for i in range(2, n+1):\n        m2, m1 = m1, dup_sub(dup_mul_ground(dup_lshift(m1, 1, K), K(2), K), m2, K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_hermite": "def dup_hermite(n, K):\n    \"\"\"Low-level implementation of Hermite polynomials.\"\"\"\n    if n < 1:\n        return [K.one]\n    m2, m1 = [K.one], [K(2), K.zero]\n    for i in range(2, n+1):\n        a = dup_lshift(m1, 1, K)\n        b = dup_mul_ground(m2, K(i-1), K)\n        m2, m1 = m1, dup_mul_ground(dup_sub(a, b, K), K(2), K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_hermite_prob": "def dup_hermite_prob(n, K):\n    \"\"\"Low-level implementation of probabilist's Hermite polynomials.\"\"\"\n    if n < 1:\n        return [K.one]\n    m2, m1 = [K.one], [K.one, K.zero]\n    for i in range(2, n+1):\n        a = dup_lshift(m1, 1, K)\n        b = dup_mul_ground(m2, K(i-1), K)\n        m2, m1 = m1, dup_sub(a, b, K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_legendre": "def dup_legendre(n, K):\n    \"\"\"Low-level implementation of Legendre polynomials.\"\"\"\n    if n < 1:\n        return [K.one]\n    m2, m1 = [K.one], [K.one, K.zero]\n    for i in range(2, n+1):\n        a = dup_mul_ground(dup_lshift(m1, 1, K), K(2*i-1, i), K)\n        b = dup_mul_ground(m2, K(i-1, i), K)\n        m2, m1 = m1, dup_sub(a, b, K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_laguerre": "def dup_laguerre(n, alpha, K):\n    \"\"\"Low-level implementation of Laguerre polynomials.\"\"\"\n    m2, m1 = [K.zero], [K.one]\n    for i in range(1, n+1):\n        a = dup_mul(m1, [-K.one/K(i), (alpha-K.one)/K(i) + K(2)], K)\n        b = dup_mul_ground(m2, (alpha-K.one)/K(i) + K.one, K)\n        m2, m1 = m1, dup_sub(a, b, K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_spherical_bessel_fn": "def dup_spherical_bessel_fn(n, K):\n    \"\"\"Low-level implementation of fn(n, x).\"\"\"\n    if n < 1:\n        return [K.one, K.zero]\n    m2, m1 = [K.one], [K.one, K.zero]\n    for i in range(2, n+1):\n        m2, m1 = m1, dup_sub(dup_mul_ground(dup_lshift(m1, 1, K), K(2*i-1), K), m2, K)\n    return dup_lshift(m1, 1, K)",
    "sympy.sympy.polys.orthopolys.dup_spherical_bessel_fn_minus": "def dup_spherical_bessel_fn_minus(n, K):\n    \"\"\"Low-level implementation of fn(-n, x).\"\"\"\n    m2, m1 = [K.one, K.zero], [K.zero]\n    for i in range(2, n+1):\n        m2, m1 = m1, dup_sub(dup_mul_ground(dup_lshift(m1, 1, K), K(3-2*i), K), m2, K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_gegenbauer": "def dup_gegenbauer(n, a, K):\n    \"\"\"Low-level implementation of Gegenbauer polynomials.\"\"\"\n    if n < 1:\n        return [K.one]\n    m2, m1 = [K.one], [K(2)*a, K.zero]\n    for i in range(2, n+1):\n        p1 = dup_mul_ground(dup_lshift(m1, 1, K), K(2)*(a-K.one)/K(i) + K(2), K)\n        p2 = dup_mul_ground(m2, K(2)*(a-K.one)/K(i) + K.one, K)\n        m2, m1 = m1, dup_sub(p1, p2, K)\n    return m1",
    "sympy.sympy.polys.orthopolys.dup_chebyshevt": "def dup_chebyshevt(n, K):\n    \"\"\"Low-level implementation of Chebyshev polynomials of the first kind.\"\"\"\n    if n < 1:\n        return [K.one]\n    # When n is small, it is faster to directly calculate the recurrence relation.\n    if n < 64: # The threshold serves as a heuristic\n        return _dup_chebyshevt_rec(n, K)\n    return _dup_chebyshevt_prod(n, K)",
    "sympy.sympy.polys.orthopolys.dup_jacobi": "def dup_jacobi(n, a, b, K):\n    \"\"\"Low-level implementation of Jacobi polynomials.\"\"\"\n    if n < 1:\n        return [K.one]\n    m2, m1 = [K.one], [(a+b)/K(2) + K.one, (a-b)/K(2)]\n    for i in range(2, n+1):\n        den = K(i)*(a + b + i)*(a + b + K(2)*i - K(2))\n        f0 = (a + b + K(2)*i - K.one) * (a*a - b*b) / (K(2)*den)\n        f1 = (a + b + K(2)*i - K.one) * (a + b + K(2)*i - K(2)) * (a + b + K(2)*i) / (K(2)*den)\n        f2 = (a + i - K.one)*(b + i - K.one)*(a + b + K(2)*i) / den\n        p0 = dup_mul_ground(m1, f0, K)\n        p1 = dup_mul_ground(dup_lshift(m1, 1, K), f1, K)\n        p2 = dup_mul_ground(m2, f2, K)\n        m2, m1 = m1, dup_sub(dup_add(p0, p1, K), p2, K)\n    return m1",
    "sympy.sympy.polys.polyclasses.__new__": "def __new__(cls, rep: dmp[Er], dom: Domain[Er], lev: int | None = None):\n\n    if lev is None:\n        rep, lev = dmp_validate(rep, dom)\n    elif not isinstance(rep, list):\n        raise CoercionFailed(\"expected list, got %s\" % type(rep))\n\n    return cls.new(rep, dom, lev)",
    "sympy.sympy.polys.polytools.as_expr": "def as_expr(f, *gens):\n    \"\"\"\n    Convert a Poly instance to an Expr instance.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n    >>> f.as_expr()\n    x**2 + 2*x*y**2 - y\n    >>> f.as_expr({x: 5})\n    10*y**2 - y + 25\n    >>> f.as_expr(5, 6)\n    379\n\n    \"\"\"\n    if not gens:\n        return f.expr\n\n    if len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\n                    \"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    "sympy.sympy.polys.polytools.new": "@classmethod\ndef new(cls, rep, *gens):\n    \"\"\"Construct :class:`Poly` instance from raw representation. \"\"\"\n    if not isinstance(rep, DMP):\n        raise PolynomialError(\n            \"invalid polynomial representation: %s\" % rep)\n    elif rep.lev != len(gens) - 1:\n        raise PolynomialError(\"invalid arguments: %s, %s\" % (rep, gens))\n\n    obj = Basic.__new__(cls)\n    obj.rep = rep\n    obj.gens = gens\n\n    return obj"
}