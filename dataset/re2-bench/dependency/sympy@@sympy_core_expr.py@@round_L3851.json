{
    "sympy.sympy.core._print_helpers.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    "sympy.sympy.core.add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Return a tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import I\n    >>> (7 + 9*I).as_real_imag()\n    (7, 9)\n    >>> ((1 + I)/(1 - I)).as_real_imag()\n    (0, 1)\n    >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n    (-5, 5)\n    \"\"\"\n    sargs = self.args\n    re_part, im_part = [], []\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.atoms": "def atoms(self, *types: Tbasic | type[Tbasic]) -> set[Basic] | set[Tbasic]:\n    \"\"\"Returns the atoms that form the current object.\n\n    By default, only objects that are truly atomic and cannot\n    be divided into smaller pieces are returned: symbols, numbers,\n    and number symbols like I and pi. It is possible to request\n    atoms of any type, however, as demonstrated below.\n\n    Examples\n    ========\n\n    >>> from sympy import I, pi, sin\n    >>> from sympy.abc import x, y\n    >>> (1 + x + 2*sin(y + I*pi)).atoms()\n    {1, 2, I, pi, x, y}\n\n    If one or more types are given, the results will contain only\n    those types of atoms.\n\n    >>> from sympy import Number, NumberSymbol, Symbol\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n    {x, y}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n    {1, 2}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n    {1, 2, pi}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n    {1, 2, I, pi}\n\n    Note that I (imaginary unit) and zoo (complex infinity) are special\n    types of number symbols and are not part of the NumberSymbol class.\n\n    The type can be given implicitly, too:\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n    {x, y}\n\n    Be careful to check your assumptions when using the implicit option\n    since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n    of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n    integers in an expression:\n\n    >>> from sympy import S\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n    {1}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n    {1, 2}\n\n    Finally, arguments to atoms() can select more than atomic atoms: any\n    SymPy type (loaded in core/__init__.py) can be listed as an argument\n    and those types of \"atoms\" as found in scanning the arguments of the\n    expression recursively:\n\n    >>> from sympy import Function, Mul\n    >>> from sympy.core.function import AppliedUndef\n    >>> f = Function('f')\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n    {f(x), sin(y + I*pi)}\n    >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n    {f(x)}\n\n    >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n    {I*pi, 2*sin(y + I*pi)}\n\n    \"\"\"\n    nodes = _preorder_traversal(self)\n    if types:\n        types2 = tuple([t if isinstance(t, type) else type(t) for t in types])\n        return {node for node in nodes if isinstance(node, types2)}\n    else:\n        return {node for node in nodes if not node.args}",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.evalf.pure_complex": "def pure_complex(v: Expr, or_real=False) -> tuple[Number, Number] | None:\n    \"\"\"Return a and b if v matches a + I*b where b is not zero and\n    a and b are Numbers, else None. If `or_real` is True then 0 will\n    be returned for `b` if `v` is a real number.\n\n    Examples\n    ========\n\n    >>> from sympy.core.evalf import pure_complex\n    >>> from sympy import sqrt, I, S\n    >>> a, b, surd = S(2), S(3), sqrt(2)\n    >>> pure_complex(a)\n    >>> pure_complex(a, or_real=True)\n    (2, 0)\n    >>> pure_complex(surd)\n    >>> pure_complex(a + b*I)\n    (2, 3)\n    >>> pure_complex(I)\n    (0, 1)\n    \"\"\"\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return h, c\n    elif or_real:\n        return h, S.Zero\n    return None",
    "sympy.sympy.core.evalf.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    \"\"\"\n    Evaluate the given formula to an accuracy of *n* digits.\n\n    Parameters\n    ==========\n\n    subs : dict, optional\n        Substitute numerical values for symbols, e.g.\n        ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n        dictionary.\n\n    maxn : int, optional\n        Allow a maximum temporary working precision of maxn digits.\n\n    chop : bool or number, optional\n        Specifies how to replace tiny real or imaginary parts in\n        subresults by exact zeros.\n\n        When ``True`` the chop value defaults to standard precision.\n\n        Otherwise the chop value is used to determine the\n        magnitude of \"small\" for purposes of chopping.\n\n        >>> from sympy import N\n        >>> x = 1e-4\n        >>> N(x, chop=True)\n        0.000100000000000000\n        >>> N(x, chop=1e-5)\n        0.000100000000000000\n        >>> N(x, chop=1e-4)\n        0\n\n    strict : bool, optional\n        Raise ``PrecisionExhausted`` if any subresult fails to\n        evaluate to full accuracy, given the available maxprec.\n\n    quad : str, optional\n        Choose algorithm for numerical quadrature. By default,\n        tanh-sinh quadrature is used. For oscillatory\n        integrals on an infinite interval, try ``quad='osc'``.\n\n    verbose : bool, optional\n        Print debug information.\n\n    Notes\n    =====\n\n    When Floats are naively substituted into an expression,\n    precision errors may adversely affect the result. For example,\n    adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n    then subtracted, the result will be 0.\n    That is exactly what happens in the following:\n\n    >>> from sympy.abc import x, y, z\n    >>> values = {x: 1e16, y: 1, z: 1e16}\n    >>> (x + y - z).subs(values)\n    0\n\n    Using the subs argument for evalf is the accurate way to\n    evaluate such an expression:\n\n    >>> (x + y - z).evalf(subs=values)\n    1.00000000000000\n    \"\"\"\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n\n    # for sake of sage that doesn't like evalf(1)\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n           'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        # Fall back to the ordinary evalf\n        if hasattr(self, 'subs') and subs is not None:  # issue 20291\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            # If the result is numerical, normalize it\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            # Probably contains symbols or unknown functions\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im*S.ImaginaryUnit\n    else:\n        return re",
    "sympy.sympy.core.expr.round": "def round(self, n=None):\n    \"\"\"Return x rounded to the given decimal place.\n\n    If a complex number would result, apply round to the real\n    and imaginary components of the number.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, E, I, S, Number\n    >>> pi.round()\n    3\n    >>> pi.round(2)\n    3.14\n    >>> (2*pi + E*I).round()\n    6 + 3*I\n\n    The round method has a chopping effect:\n\n    >>> (2*pi + I/10).round()\n    6\n    >>> (pi/10 + 2*I).round()\n    2*I\n    >>> (pi/10 + E*I).round(2)\n    0.31 + 2.72*I\n\n    Notes\n    =====\n\n    The Python ``round`` function uses the SymPy ``round`` method so it\n    will always return a SymPy number (not a Python float or int):\n\n    >>> isinstance(round(S(123), -2), Number)\n    True\n    \"\"\"\n    x = self\n\n    if not x.is_number:\n        raise TypeError(\"Cannot round symbolic expression\")\n    if not x.is_Atom:\n        if not pure_complex(x.n(2), or_real=True):\n            raise TypeError(\n                'Expected a number but got %s:' % func_name(x))\n    elif x in _illegal:\n        return x\n    if not (xr := x.is_extended_real):\n        r, i = x.as_real_imag()\n        if xr is False:\n            return r.round(n) + S.ImaginaryUnit*i.round(n)\n        if i.equals(0):\n            return r.round(n)\n    if not x:\n        return S.Zero if n is None else x\n\n    p = as_int(n or 0)\n\n    if x.is_Integer:\n        return Integer(round(int(x), p))\n\n    digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1\n    allow = digits_to_decimal + p\n    precs = [f._prec for f in x.atoms(Float)]\n    dps = prec_to_dps(max(precs)) if precs else None\n    if dps is None:\n        # assume everything is exact so use the Python\n        # float default or whatever was requested\n        dps = max(15, allow)\n    else:\n        allow = min(allow, dps)\n    # this will shift all digits to right of decimal\n    # and give us dps to work with as an int\n    shift = -digits_to_decimal + dps\n    extra = 1  # how far we look past known digits\n    # NOTE\n    # mpmath will calculate the binary representation to\n    # an arbitrary number of digits but we must base our\n    # answer on a finite number of those digits, e.g.\n    # .575 2589569785738035/2**52 in binary.\n    # mpmath shows us that the first 18 digits are\n    #     >>> Float(.575).n(18)\n    #     0.574999999999999956\n    # The default precision is 15 digits and if we ask\n    # for 15 we get\n    #     >>> Float(.575).n(15)\n    #     0.575000000000000\n    # mpmath handles rounding at the 15th digit. But we\n    # need to be careful since the user might be asking\n    # for rounding at the last digit and our semantics\n    # are to round toward the even final digit when there\n    # is a tie. So the extra digit will be used to make\n    # that decision. In this case, the value is the same\n    # to 15 digits:\n    #     >>> Float(.575).n(16)\n    #     0.5750000000000000\n    # Now converting this to the 15 known digits gives\n    #     575000000000000.0\n    # which rounds to integer\n    #    5750000000000000\n    # And now we can round to the desired digt, e.g. at\n    # the second from the left and we get\n    #    5800000000000000\n    # and rescaling that gives\n    #    0.58\n    # as the final result.\n    # If the value is made slightly less than 0.575 we might\n    # still obtain the same value:\n    #    >>> Float(.575-1e-16).n(16)*10**15\n    #    574999999999999.8\n    # What 15 digits best represents the known digits (which are\n    # to the left of the decimal? 5750000000000000, the same as\n    # before. The only way we will round down (in this case) is\n    # if we declared that we had more than 15 digits of precision.\n    # For example, if we use 16 digits of precision, the integer\n    # we deal with is\n    #    >>> Float(.575-1e-16).n(17)*10**16\n    #    5749999999999998.4\n    # and this now rounds to 5749999999999998 and (if we round to\n    # the 2nd digit from the left) we get 5700000000000000.\n    #\n    xf = x.n(dps + extra)*Pow(10, shift)\n    if xf.is_Number and xf._prec == 1:  # xf.is_Add will raise below\n        # is x == 0?\n        if x.equals(0):\n            return Float(0)\n        raise ValueError('not computing with precision')\n    xi = Integer(xf)\n    # use the last digit to select the value of xi\n    # nearest to x before rounding at the desired digit\n    sign = 1 if x > 0 else -1\n    dif2 = sign*(xf - xi).n(extra)\n    if dif2 < 0:\n        raise NotImplementedError(\n            'not expecting int(x) to round away from 0')\n    if dif2 > .5:\n        xi += sign  # round away from 0\n    elif dif2 == .5:\n        xi += sign if xi%2 else -sign  # round toward even\n    # shift p to the new position\n    ip = p - shift\n    # let Python handle the int rounding then rescale\n    xr = round(xi.p, ip)\n    # restore scale\n    rv = Rational(xr, Pow(10, shift))\n    # return Float or Integer\n    if rv.is_Integer:\n        if n is None:  # the single-arg case\n            return rv\n        # use str or else it won't be a float\n        return Float(str(rv), dps)  # keep same precision\n    else:\n        if not allow and rv > self:\n            allow += 1\n        return Float(rv, allow)",
    "sympy.sympy.core.expr.<listcomp>": "precs = [f._prec for f in x.atoms(Float)]\n",
    "sympy.sympy.core.expr._mag": "def _mag(x):\n    r\"\"\"Return integer $i$ such that $0.1 \\le x/10^i < 1$\n\n    Examples\n    ========\n\n    >>> from sympy.core.expr import _mag\n    >>> from sympy import Float\n    >>> _mag(Float(.1))\n    0\n    >>> _mag(Float(.01))\n    -1\n    >>> _mag(Float(1234))\n    4\n    \"\"\"\n    from math import log10, ceil, log\n    xpos = abs(x.n())\n    if not xpos:\n        return S.Zero\n    try:\n        mag_first_dig = int(ceil(log10(xpos)))\n    except (ValueError, OverflowError):\n        mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53))/log(10)))\n    # check that we aren't off by 1\n    if (xpos/S(10)**mag_first_dig) >= 1:\n        assert 1 <= (xpos/S(10)**mag_first_dig) < 10\n        mag_first_dig += 1\n    return mag_first_dig",
    "sympy.sympy.core.expr.is_number": "@property\ndef is_number(self):\n    \"\"\"Returns True if ``self`` has no free symbols and no\n    undefined functions (AppliedUndef, to be precise). It will be\n    faster than ``if not self.free_symbols``, however, since\n    ``is_number`` will fail as soon as it hits a free symbol\n    or undefined function.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Integral, cos, sin, pi\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n\n    >>> x.is_number\n    False\n    >>> f(1).is_number\n    False\n    >>> (2*x).is_number\n    False\n    >>> (2 + Integral(2, x)).is_number\n    False\n    >>> (2 + Integral(2, (x, 1, 2))).is_number\n    True\n\n    Not all numbers are Numbers in the SymPy sense:\n\n    >>> pi.is_number, pi.is_Number\n    (True, False)\n\n    If something is a number it should evaluate to a number with\n    real and imaginary parts that are Numbers; the result may not\n    be comparable, however, since the real and/or imaginary part\n    of the result may not have precision.\n\n    >>> cos(1).is_number and cos(1).is_comparable\n    True\n\n    >>> z = cos(1)**2 + sin(1)**2 - 1\n    >>> z.is_number\n    True\n    >>> z.is_comparable\n    False\n\n    See Also\n    ========\n\n    sympy.core.basic.Basic.is_comparable\n    \"\"\"\n    return all(obj.is_number for obj in self.args)",
    "sympy.sympy.core.expr.equals": "def equals(self, other, failing_expression=False):\n    \"\"\"Return True if self == other, False if it does not, or None. If\n    failing_expression is True then the expression which did not simplify\n    to a 0 will be returned instead of None.\n\n    Explanation\n    ===========\n\n    If ``self`` is a Number (or complex number) that is not zero, then\n    the result is False.\n\n    If ``self`` is a number and has not evaluated to zero, evalf will be\n    used to test whether the expression evaluates to zero. If it does so\n    and the result has significance (i.e. the precision is either -1, for\n    a Rational result, or is greater than 1) then the evalf value will be\n    used to return True or False.\n\n    \"\"\"\n    from sympy.simplify.simplify import nsimplify, simplify\n    from sympy.solvers.solvers import solve\n    from sympy.polys.polyerrors import NotAlgebraic\n    from sympy.polys.numberfields import minimal_polynomial\n\n    other = sympify(other)\n\n    if not isinstance(other, Expr):\n        return False\n\n    if self == other:\n        return True\n\n    # they aren't the same so see if we can make the difference 0;\n    # don't worry about doing simplification steps one at a time\n    # because if the expression ever goes to 0 then the subsequent\n    # simplification steps that are done will be very fast.\n    diff = factor_terms(simplify(self - other), radical=True)\n\n    if not diff:\n        return True\n\n    if not diff.has(Add, Mod):\n        # if there is no expanding to be done after simplifying\n        # then this can't be a zero\n        return False\n\n    factors = diff.as_coeff_mul()[1]\n    if len(factors) > 1:  # avoid infinity recursion\n        fac_zero = [fac.equals(0) for fac in factors]\n        if None not in fac_zero:  # every part can be decided\n            return any(fac_zero)\n\n    constant = diff.is_constant(simplify=False, failing_number=True)\n\n    if constant is False:\n        return False\n\n    if not diff.is_number:\n        if constant is None:\n            # e.g. unless the right simplification is done, a symbolic\n            # zero is possible (see expression of issue 6829: without\n            # simplification constant will be None).\n            return\n\n    if constant is True:\n        # this gives a number whether there are free symbols or not\n        ndiff = diff._random()\n        # is_comparable will work whether the result is real\n        # or complex; it could be None, however.\n        if ndiff and ndiff.is_comparable:\n            return False\n\n    # sometimes we can use a simplified result to give a clue as to\n    # what the expression should be; if the expression is *not* zero\n    # then we should have been able to compute that and so now\n    # we can just consider the cases where the approximation appears\n    # to be zero -- we try to prove it via minimal_polynomial.\n    #\n    # removed\n    # ns = nsimplify(diff)\n    # if diff.is_number and (not ns or ns == diff):\n    #\n    # The thought was that if it nsimplifies to 0 that's a sure sign\n    # to try the following to prove it; or if it changed but wasn't\n    # zero that might be a sign that it's not going to be easy to\n    # prove. But tests seem to be working without that logic.\n    #\n    if diff.is_number:\n        # try to prove via self-consistency\n        surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n        # it seems to work better to try big ones first\n        surds.sort(key=lambda x: -x.args[0])\n        for s in surds:\n            try:\n                # simplify is False here -- this expression has already\n                # been identified as being hard to identify as zero;\n                # we will handle the checking ourselves using nsimplify\n                # to see if we are in the right ballpark or not and if so\n                # *then* the simplification will be attempted.\n                sol = solve(diff, s, simplify=False)\n                if sol:\n                    if s in sol:\n                        # the self-consistent result is present\n                        return True\n                    if all(si.is_Integer for si in sol):\n                        # perfect powers are removed at instantiation\n                        # so surd s cannot be an integer\n                        return False\n                    if all(i.is_algebraic is False for i in sol):\n                        # a surd is algebraic\n                        return False\n                    if any(si in surds for si in sol):\n                        # it wasn't equal to s but it is in surds\n                        # and different surds are not equal\n                        return False\n                    if any(nsimplify(s - si) == 0 and\n                            simplify(s - si) == 0 for si in sol):\n                        return True\n                    if s.is_real:\n                        if any(nsimplify(si, [s]) == s and simplify(si) == s\n                                for si in sol):\n                            return True\n            except NotImplementedError:\n                pass\n\n        # try to prove with minimal_polynomial but know when\n        # *not* to use this or else it can take a long time. e.g. issue 8354\n        if True:  # change True to condition that assures non-hang\n            try:\n                mp = minimal_polynomial(diff)\n                if mp.is_Symbol:\n                    return True\n                return False\n            except (NotAlgebraic, NotImplementedError):\n                pass\n\n    # diff has not simplified to zero; constant is either None, True\n    # or the number with significance (is_comparable) that was randomly\n    # calculated twice as the same value.\n    if constant not in (True, None) and constant != 0:\n        return False\n\n    if failing_expression:\n        return diff\n    return None",
    "sympy.sympy.core.mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy.functions.elementary.complexes import Abs, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i*S.ImaginaryUnit)\n        elif a.is_commutative:\n            aconj = a.conjugate() if other else None\n            # search for complex conjugate pairs:\n            for i, x in enumerate(other):\n                if x == aconj:\n                    coeffr.append(Abs(x)**2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n        # all other pairs make a real factor; they will be\n        # put into reco below\n    else:\n        imco = S.Zero\n    reco = self.func(*(coeffr + coeffi))\n    r, i = (reco*re(m), reco*im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco*imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco*i, imco*r)\n    from .function import expand_mul\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r*addre - i*addim, i*addre + r*addim)\n    else:\n        r, i = -imco*i, imco*r\n        return (r*addre - i*addim, r*addim + i*addre)",
    "sympy.sympy.core.numbers.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    # NaN is structurally equal to another NaN\n    return other is S.NaN",
    "sympy.sympy.core.numbers.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    "sympy.sympy.core.numbers.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    "sympy.sympy.core.numbers.__int__": "def __int__(self):\n    return self.p",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__new__": "def __new__(cls, num, dps=None, precision=None):\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. '\n                         'Supply only one. ')\n\n    if isinstance(num, str):\n        _num = num = num.strip()  # Python ignores leading and trailing space\n        num = num.replace(' ', '_').lower()  # Float treats spaces as digit sep; E -> e\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n        elif num in ('inf', '+inf'):\n            return S.Infinity\n        elif num == '-inf':\n            return S.NegativeInfinity\n        elif num == 'nan':\n            return S.NaN\n        elif not _literal_float(num):\n            raise ValueError('string-float not recognized: %s' % _num)\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, float) and num == float('inf'):\n        return S.Infinity\n    elif isinstance(num, float) and num == float('-inf'):\n        return S.NegativeInfinity\n    elif isinstance(num, float) and math.isnan(num):\n        return S.NaN\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity or num is S.NegativeInfinity or num is S.NaN:\n        return num\n    elif _is_numpy_instance(num):  # support for numpy datatypes\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, str):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    # 12e3 is shorthand for int, not float;\n                    # 12.e3 would be the float version\n                    dps = max(dps, num_digits(num))\n                dps = max(15, dps)\n                precision = dps_to_prec(dps)\n    elif precision == '' and dps is None or precision is None and dps == '':\n        if not isinstance(num, str):\n            raise ValueError('The null string can only be used when '\n            'the number to Float is passed as a string or an integer.')\n        try:\n            Num = decimal.Decimal(num)\n        except decimal.InvalidOperation:\n            raise ValueError('string-float not recognized by Decimal: %s' % num)\n        else:\n            isint = '.' not in num\n            num, dps = _decimal_to_Rational_prec(Num)\n            if num.is_Integer and isint:\n                # without dec, e-notation is short for int\n                dps = max(dps, num_digits(num))\n                precision = dps_to_prec(dps)\n\n    # decimal precision(dps) is set and maybe binary precision(precision)\n    # as well.From here on binary precision is used to compute the Float.\n    # Hence, if supplied use binary precision else translate from decimal\n    # precision.\n\n    if precision is None or precision == '':\n        precision = dps_to_prec(dps)\n\n    precision = int(precision)\n\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, str):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            return S.NaN\n        elif num.is_infinite():\n            if num > 0:\n                return S.Infinity\n            return S.NegativeInfinity\n        else:\n            raise ValueError(\"unexpected decimal value %s\" % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if isinstance(num[1], str):\n            # it's a hexadecimal (coming from a pickled object)\n            num = list(num)\n            # If we're loading an object pickled in Python 2 into\n            # Python 3, we may need to strip a tailing 'L' because\n            # of a shim for int on Python 3, see issue #13470.\n            # Strip leading '0x' - gmpy2 only documents such inputs\n            # with base prefix as valid when the 2nd argument (base) is 0.\n            # When mpmath uses Sage as the backend, however, it\n            # ends up including '0x' when preparing the picklable tuple.\n            # See issue #19690.\n            num[1] = num[1].removeprefix('0x').removesuffix('L')\n            # Now we can assume that it is in standard form\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        else:\n            if len(num) == 4:\n                # handle normalization hack\n                return Float._new(num, precision)\n            else:\n                if not all((\n                        num[0] in (0, 1),\n                        num[1] >= 0,\n                        all(type(i) in (int, int) for i in num)\n                        )):\n                    raise ValueError('malformed mpf: %s' % (num,))\n                # don't compute number or else it may\n                # over/underflow\n                return Float._new(\n                    (num[0], num[1], num[2], num[1].bit_length()),\n                    precision)\n    elif isinstance(num, (Number, NumberSymbol)):\n        _mpf_ = num._as_mpf_val(precision)\n    else:\n        _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n\n    return cls._new(_mpf_, precision, zero=False)",
    "sympy.sympy.core.power.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if self.exp.is_Integer:\n        from sympy.polys.polytools import poly\n\n        exp = self.exp\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n        if not im_e:\n            return self, S.Zero\n        a, b = symbols('a b', cls=Dummy)\n        if exp >= 0:\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial(self.base**exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly(\n                (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp\n        else:\n            mag = re_e**2 + im_e**2\n            re_e, im_e = re_e/mag, -im_e/mag\n            if re_e.is_Number and im_e.is_Number:\n                # We can be more efficient in this case\n                expr = expand_multinomial((re_e + im_e*S.ImaginaryUnit)**-exp)\n                if expr != self:\n                    return expr.as_real_imag()\n\n            expr = poly((a + b)**-exp)\n\n        # Terms with even b powers will be real\n        r = [i for i in expr.terms() if not i[0][1] % 2]\n        re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        # Terms with odd b powers will be imaginary\n        r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n        im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n        im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n\n        return (re_part.subs({a: re_e, b: S.ImaginaryUnit*im_e}),\n        im_part1.subs({a: re_e, b: im_e}) + im_part3.subs({a: re_e, b: -im_e}))\n\n    from sympy.functions.elementary.trigonometric import atan2, cos, sin\n\n    if self.exp.is_Rational:\n        re_e, im_e = self.base.as_real_imag(deep=deep)\n\n        if im_e.is_zero and self.exp is S.Half:\n            if re_e.is_extended_nonnegative:\n                return self, S.Zero\n            if re_e.is_extended_nonpositive:\n                return S.Zero, (-self.base)**self.exp\n\n        # XXX: This is not totally correct since for x**(p/q) with\n        #      x being imaginary there are actually q roots, but\n        #      only a single one is returned from here.\n        r = self.func(self.func(re_e, 2) + self.func(im_e, 2), S.Half)\n\n        t = atan2(im_e, re_e)\n\n        rp, tp = self.func(r, self.exp), t*self.exp\n\n        return rp*cos(tp), rp*sin(tp)\n    elif self.base is S.Exp1:\n        from sympy.functions.elementary.exponential import exp\n        re_e, im_e = self.exp.as_real_imag()\n        if deep:\n            re_e = re_e.expand(deep, **hints)\n            im_e = im_e.expand(deep, **hints)\n        c, s = cos(im_e), sin(im_e)\n        return exp(re_e)*c, exp(re_e)*s\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        if deep:\n            hints['complex'] = False\n\n            expanded = self.expand(deep, **hints)\n            if hints.get('ignore') == expanded:\n                return None\n            else:\n                return (re(expanded), im(expanded))\n        else:\n            return re(self), im(self)",
    "sympy.sympy.core.relational.__bool__": "def __bool__(self) -> bool:\n    raise TypeError(\n        LazyExceptionMessage(\n            lambda: f\"cannot determine truth value of Relational: {self}\"\n        )\n    )",
    "sympy.sympy.functions.elementary.exponential.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    \"\"\"\n    Returns this function as a 2-tuple representing a complex number.\n\n    Examples\n    ========\n\n    >>> from sympy import exp, I\n    >>> from sympy.abc import x\n    >>> exp(x).as_real_imag()\n    (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))\n    >>> exp(1).as_real_imag()\n    (E, 0)\n    >>> exp(I).as_real_imag()\n    (cos(1), sin(1))\n    >>> exp(1+I).as_real_imag()\n    (E*cos(1), E*sin(1))\n\n    See Also\n    ========\n\n    sympy.functions.elementary.complexes.re\n    sympy.functions.elementary.complexes.im\n    \"\"\"\n    from sympy.functions.elementary.trigonometric import cos, sin\n    re, im = self.args[0].as_real_imag()\n    if deep:\n        re = re.expand(deep, **hints)\n        im = im.expand(deep, **hints)\n    cos, sin = cos(im), sin(im)\n    return (exp(re)*cos, exp(re)*sin)",
    "sympy.sympy.logic.boolalg.__bool__": "def __bool__(self):\n    return False",
    "sympy.sympy.utilities.misc.as_int": "def as_int(n: SupportsIndex | SupportsInt, strict: bool = True) -> int:\n    \"\"\"\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    \"\"\"\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n) # type: ignore\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n - result: # type: ignore\n            raise ValueError('%s is not an integer' % (n,))\n        return result"
}