{
    "scikit-learn.sklearn.utils._param_validation.wrapper": "@functools.wraps(func)\ndef wrapper(*args, **kwargs):\n    global_skip_validation = get_config()[\"skip_parameter_validation\"]\n    if global_skip_validation:\n        return func(*args, **kwargs)\n\n    func_sig = signature(func)\n\n    # Map *args/**kwargs to the function signature\n    params = func_sig.bind(*args, **kwargs)\n    params.apply_defaults()\n\n    # ignore self/cls and positional/keyword markers\n    to_ignore = [\n        p.name\n        for p in func_sig.parameters.values()\n        if p.kind in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    to_ignore += [\"self\", \"cls\"]\n    params = {k: v for k, v in params.arguments.items() if k not in to_ignore}\n\n    validate_parameter_constraints(\n        parameter_constraints, params, caller_name=func.__qualname__\n    )\n\n    try:\n        with config_context(\n            skip_parameter_validation=(\n                prefer_skip_nested_validation or global_skip_validation\n            )\n        ):\n            return func(*args, **kwargs)\n    except InvalidParameterError as e:\n        # When the function is just a wrapper around an estimator, we allow\n        # the function to delegate validation to the estimator, but we replace\n        # the name of the estimator by the name of the function in the error\n        # message to avoid confusion.\n        msg = re.sub(\n            r\"parameter of \\w+ must be\",\n            f\"parameter of {func.__qualname__} must be\",\n            str(e),\n        )\n        raise InvalidParameterError(msg) from e",
    "scikit-learn.sklearn.utils._tags.get_tags": "def get_tags(estimator) -> Tags:\n    \"\"\"Get estimator tags.\n\n    :class:`~sklearn.BaseEstimator` provides the estimator tags machinery.\n\n    For scikit-learn built-in estimators, we should still rely on\n    `self.__sklearn_tags__()`. `get_tags(est)` should be used when we\n    are not sure where `est` comes from: typically\n    `get_tags(self.estimator)` where `self` is a meta-estimator, or in\n    the common checks.\n\n    .. versionadded:: 1.6\n\n    Parameters\n    ----------\n    estimator : estimator object\n        The estimator from which to get the tag.\n\n    Returns\n    -------\n    tags : :class:`~.sklearn.utils.Tags`\n        The estimator tags.\n    \"\"\"\n\n    try:\n        tags = estimator.__sklearn_tags__()\n    except AttributeError as exc:\n        if \"object has no attribute '__sklearn_tags__'\" in str(exc):\n            # Happens when `__sklearn_tags__` is implemented by calling\n            # `super().__sklearn_tags__()` but there is no `__sklearn_tags__`\n            # method in the base class. Typically happens when only inheriting\n            # from Mixins.\n\n            raise AttributeError(\n                f\"The following error was raised: {exc}. It seems that \"\n                \"there are no classes that implement `__sklearn_tags__` \"\n                \"in the MRO and/or all classes in the MRO call \"\n                \"`super().__sklearn_tags__()`. Make sure to inherit from \"\n                \"`BaseEstimator` which implements `__sklearn_tags__` (or \"\n                \"alternatively define `__sklearn_tags__` but we don't recommend \"\n                \"this approach). Note that `BaseEstimator` needs to be on the \"\n                \"right side of other Mixins in the inheritance order.\"\n            )\n        else:\n            raise\n\n    return tags",
    "scikit-learn.sklearn.utils.estimator_checks._is_pairwise_metric": "def _is_pairwise_metric(estimator):\n    \"\"\"Returns True if estimator accepts pairwise metric.\n\n    Parameters\n    ----------\n    estimator : object\n        Estimator object to test.\n\n    Returns\n    -------\n    out : bool\n        True if _pairwise is set to True and False otherwise.\n    \"\"\"\n    metric = getattr(estimator, \"metric\", None)\n\n    return bool(metric == \"precomputed\")"
}