{
    "sympy.sympy.concrete.expr_with_limits.function": "@property\ndef function(self):\n    \"\"\"Return the function applied across limits.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x\n    >>> Integral(x**2, (x,)).function\n    x**2\n\n    See Also\n    ========\n\n    limits, variables, free_symbols\n    \"\"\"\n    return self._args[0]",
    "sympy.sympy.concrete.expr_with_limits.limits": "@property\ndef limits(self):\n    \"\"\"Return the limits of expression.\n\n    Examples\n    ========\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, i\n    >>> Integral(x**i, (i, 1, 3)).limits\n    ((i, 1, 3),)\n\n    See Also\n    ========\n\n    function, variables, free_symbols\n    \"\"\"\n    return self._args[1:]",
    "sympy.sympy.core.assumptions.getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    "sympy.sympy.core.basic.subs": "def subs(self, arg1: Mapping[Basic | complex, Basic | complex]\n        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,\n         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:\n    \"\"\"\n    Substitutes old for new in an expression after sympifying args.\n\n    `args` is either:\n      - two arguments, e.g. foo.subs(old, new)\n      - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n         o an iterable container with (old, new) pairs. In this case the\n           replacements are processed in the order given with successive\n           patterns possibly affecting replacements already made.\n         o a dict or set whose key/value items correspond to old/new pairs.\n           In this case the old/new pairs will be sorted by op count and in\n           case of a tie, by number of args and the default_sort_key. The\n           resulting sorted list is then processed as an iterable container\n           (see previous).\n\n    If the keyword ``simultaneous`` is True, the subexpressions will not be\n    evaluated until all the substitutions have been made.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, exp, limit, oo\n    >>> from sympy.abc import x, y\n    >>> (1 + x*y).subs(x, pi)\n    pi*y + 1\n    >>> (1 + x*y).subs({x:pi, y:2})\n    1 + 2*pi\n    >>> (1 + x*y).subs([(x, pi), (y, 2)])\n    1 + 2*pi\n    >>> reps = [(y, x**2), (x, 2)]\n    >>> (x + y).subs(reps)\n    6\n    >>> (x + y).subs(reversed(reps))\n    x**2 + 2\n\n    >>> (x**2 + x**4).subs(x**2, y)\n    y**2 + y\n\n    To replace only the x**2 but not the x**4, use xreplace:\n\n    >>> (x**2 + x**4).xreplace({x**2: y})\n    x**4 + y\n\n    To delay evaluation until all substitutions have been made,\n    set the keyword ``simultaneous`` to True:\n\n    >>> (x/y).subs([(x, 0), (y, 0)])\n    0\n    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n    nan\n\n    This has the added feature of not allowing subsequent substitutions\n    to affect those already made:\n\n    >>> ((x + y)/y).subs({x + y: y, y: x + y})\n    1\n    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n    y/(x + y)\n\n    In order to obtain a canonical result, unordered iterables are\n    sorted by count_op length, number of arguments and by the\n    default_sort_key to break any ties. All other iterables are left\n    unsorted.\n\n    >>> from sympy import sqrt, sin, cos\n    >>> from sympy.abc import a, b, c, d, e\n\n    >>> A = (sqrt(sin(2*x)), a)\n    >>> B = (sin(2*x), b)\n    >>> C = (cos(2*x), c)\n    >>> D = (x, d)\n    >>> E = (exp(x), e)\n\n    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n    >>> expr.subs(dict([A, B, C, D, E]))\n    a*c*sin(d*e) + b\n\n    The resulting expression represents a literal replacement of the\n    old arguments with the new arguments. This may not reflect the\n    limiting behavior of the expression:\n\n    >>> (x**3 - 3*x).subs({x: oo})\n    nan\n\n    >>> limit(x**3 - 3*x, x, oo)\n    oo\n\n    If the substitution will be followed by numerical\n    evaluation, it is better to pass the substitution to\n    evalf as\n\n    >>> (1/x).evalf(subs={x: 3.0}, n=21)\n    0.333333333333333333333\n\n    rather than\n\n    >>> (1/x).subs({x: 3.0}).evalf(21)\n    0.333333333333333314830\n\n    as the former will ensure that the desired level of precision is\n    obtained.\n\n    See Also\n    ========\n    replace: replacement capable of doing wildcard-like matching,\n             parsing of match, and conditional replacements\n    xreplace: exact node replacement in expr tree; also capable of\n              using matching rules\n    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n    \"\"\"\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n\n    items: Iterable[tuple[Basic | complex, Basic | complex]]\n\n    unordered = False\n    if arg2 is None:\n\n        if isinstance(arg1, set):\n            items = arg1\n            unordered = True\n        elif isinstance(arg1, (Dict, Mapping)):\n            unordered = True\n            items = arg1.items() # type: ignore\n        elif not iterable(arg1):\n            raise ValueError(filldedent(\"\"\"\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.\"\"\"))\n        else:\n            items = arg1 # type: ignore\n    else:\n        items = [(arg1, arg2)] # type: ignore\n\n    def sympify_old(old) -> Basic:\n        if isinstance(old, str):\n            # Use Symbol rather than parse_expr for old\n            return Symbol(old)\n        elif isinstance(old, type):\n            # Allow a type e.g. Function('f') or sin\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new) -> Basic:\n        if isinstance(new, (str, type)):\n            # Allow a type or parse a string input\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]\n\n    # skip if there is no change\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n\n    simultaneous = kwargs.pop('simultaneous', False)\n\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence_dict = dict(sequence)\n        # order so more complex items are first and items\n        # of identical complexity are ordered so\n        # f(x) < f(y) < x < y\n        # \\___ 2 __/    \\_1_/  <- number of nodes\n        #\n        # For more complex ordering use an unordered sequence.\n        k = list(ordered(sequence_dict, default=False, keys=(\n            lambda x: -_nodes(x),\n            default_sort_key,\n            )))\n        sequence = [(k, sequence_dict[k]) for k in k]\n        # do infinities first\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n\n    if simultaneous:  # XXX should this be the default for dict subs?\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            # using d*m so Subs will be used on dummy variables\n            # in things like Derivative(f(x, y), x) in which x\n            # is both free and bound\n            rv = rv._subs(old, d*m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One  # get rid of m\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.singleton.__call__": "def __call__(self, a, locals=None, convert_xor=True, strict=False, rational=False,\n        evaluate=None):\n    return sympify(a, locals=locals, convert_xor=convert_xor, strict=strict,\n                   rational=rational, evaluate=evaluate) # type: ignore",
    "sympy.sympy.integrals.integrals.integrate": "def integrate(function, *symbols: SymbolLimits, meijerg=None, conds='piecewise',\n                        risch=None, heurisch=None, manual=None, **kwargs):\n    \"\"\"integrate(f, var, ...)\n\n    .. deprecated:: 1.6\n\n       Using ``integrate()`` with :class:`~.Poly` is deprecated. Use\n       :meth:`.Poly.integrate` instead. See :ref:`deprecated-integrate-poly`.\n\n    Explanation\n    ===========\n\n    Compute definite or indefinite integral of one or more variables\n    using Risch-Norman algorithm and table lookup. This procedure is\n    able to handle elementary algebraic and transcendental functions\n    and also a huge class of special functions, including Airy,\n    Bessel, Whittaker and Lambert.\n\n    var can be:\n\n    - a symbol                   -- indefinite integration\n    - a tuple (symbol, a)        -- indefinite integration with result\n                                    given with ``a`` replacing ``symbol``\n    - a tuple (symbol, a, b)     -- definite integration\n\n    Several variables can be specified, in which case the result is\n    multiple integration. (If var is omitted and the integrand is\n    univariate, the indefinite integral in that variable will be performed.)\n\n    Indefinite integrals are returned without terms that are independent\n    of the integration variables. (see examples)\n\n    Definite improper integrals often entail delicate convergence\n    conditions. Pass conds='piecewise', 'separate' or 'none' to have\n    these returned, respectively, as a Piecewise function, as a separate\n    result (i.e. result will be a tuple), or not at all (default is\n    'piecewise').\n\n    **Strategy**\n\n    SymPy uses various approaches to definite integration. One method is to\n    find an antiderivative for the integrand, and then use the fundamental\n    theorem of calculus. Various functions are implemented to integrate\n    polynomial, rational and trigonometric functions, and integrands\n    containing DiracDelta terms.\n\n    SymPy also implements the part of the Risch algorithm, which is a decision\n    procedure for integrating elementary functions, i.e., the algorithm can\n    either find an elementary antiderivative, or prove that one does not\n    exist.  There is also a (very successful, albeit somewhat slow) general\n    implementation of the heuristic Risch algorithm.  This algorithm will\n    eventually be phased out as more of the full Risch algorithm is\n    implemented. See the docstring of Integral._eval_integral() for more\n    details on computing the antiderivative using algebraic methods.\n\n    The option risch=True can be used to use only the (full) Risch algorithm.\n    This is useful if you want to know if an elementary function has an\n    elementary antiderivative.  If the indefinite Integral returned by this\n    function is an instance of NonElementaryIntegral, that means that the\n    Risch algorithm has proven that integral to be non-elementary.  Note that\n    by default, additional methods (such as the Meijer G method outlined\n    below) are tried on these integrals, as they may be expressible in terms\n    of special functions, so if you only care about elementary answers, use\n    risch=True.  Also note that an unevaluated Integral returned by this\n    function is not necessarily a NonElementaryIntegral, even with risch=True,\n    as it may just be an indication that the particular part of the Risch\n    algorithm needed to integrate that function is not yet implemented.\n\n    Another family of strategies comes from re-writing the integrand in\n    terms of so-called Meijer G-functions. Indefinite integrals of a\n    single G-function can always be computed, and the definite integral\n    of a product of two G-functions can be computed from zero to\n    infinity. Various strategies are implemented to rewrite integrands\n    as G-functions, and use this information to compute integrals (see\n    the ``meijerint`` module).\n\n    The option manual=True can be used to use only an algorithm that tries\n    to mimic integration by hand. This algorithm does not handle as many\n    integrands as the other algorithms implemented but may return results in\n    a more familiar form. The ``manualintegrate`` module has functions that\n    return the steps used (see the module docstring for more information).\n\n    In general, the algebraic methods work best for computing\n    antiderivatives of (possibly complicated) combinations of elementary\n    functions. The G-function methods work best for computing definite\n    integrals from zero to infinity of moderately complicated\n    combinations of special functions, or indefinite integrals of very\n    simple combinations of special functions.\n\n    The strategy employed by the integration code is as follows:\n\n    - If computing a definite integral, and both limits are real,\n      and at least one limit is +- oo, try the G-function method of\n      definite integration first.\n\n    - Try to find an antiderivative, using all available methods, ordered\n      by performance (that is try fastest method first, slowest last; in\n      particular polynomial integration is tried first, Meijer\n      G-functions second to last, and heuristic Risch last).\n\n    - If still not successful, try G-functions irrespective of the\n      limits.\n\n    The option meijerg=True, False, None can be used to, respectively:\n    always use G-function methods and no others, never use G-function\n    methods, or use all available methods (in order as described above).\n    It defaults to None.\n\n    Examples\n    ========\n\n    >>> from sympy import integrate, log, exp, oo\n    >>> from sympy.abc import a, x, y\n\n    >>> integrate(x*y, x)\n    x**2*y/2\n\n    >>> integrate(log(x), x)\n    x*log(x) - x\n\n    >>> integrate(log(x), (x, 1, a))\n    a*log(a) - a + 1\n\n    >>> integrate(x)\n    x**2/2\n\n    Terms that are independent of x are dropped by indefinite integration:\n\n    >>> from sympy import sqrt\n    >>> integrate(sqrt(1 + x), (x, 0, x))\n    2*(x + 1)**(3/2)/3 - 2/3\n    >>> integrate(sqrt(1 + x), x)\n    2*(x + 1)**(3/2)/3\n\n    >>> integrate(x*y)\n    Traceback (most recent call last):\n    ...\n    ValueError: specify integration variables to integrate x*y\n\n    Note that ``integrate(x)`` syntax is meant only for convenience\n    in interactive sessions and should be avoided in library code.\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'\n    Piecewise((gamma(a + 1), re(a) > -1),\n        (Integral(x**a*exp(-x), (x, 0, oo)), True))\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')\n    gamma(a + 1)\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')\n    (gamma(a + 1), re(a) > -1)\n\n    See Also\n    ========\n\n    Integral, Integral.doit\n\n    \"\"\"\n    doit_flags = {\n        'deep': False,\n        'meijerg': meijerg,\n        'conds': conds,\n        'risch': risch,\n        'heurisch': heurisch,\n        'manual': manual\n        }\n\n    integral = Integral(function, *symbols, **kwargs)\n\n    if isinstance(integral, Integral):\n        return integral.doit(**doit_flags)\n    else:\n        new_args = [a.doit(**doit_flags) if isinstance(a, Integral) else a\n            for a in integral.args]\n        return integral.func(*new_args)",
    "sympy.sympy.integrals.integrals.__new__": "def __new__(cls, function, *symbols, **assumptions) -> Integral:\n    \"\"\"Create an unevaluated integral.\n\n    Explanation\n    ===========\n\n    Arguments are an integrand followed by one or more limits.\n\n    If no limits are given and there is only one free symbol in the\n    expression, that symbol will be used, otherwise an error will be\n    raised.\n\n    >>> from sympy import Integral\n    >>> from sympy.abc import x, y\n    >>> Integral(x)\n    Integral(x, x)\n    >>> Integral(y)\n    Integral(y, y)\n\n    When limits are provided, they are interpreted as follows (using\n    ``x`` as though it were the variable of integration):\n\n        (x,) or x - indefinite integral\n        (x, a) - \"evaluate at\" integral is an abstract antiderivative\n        (x, a, b) - definite integral\n\n    The ``as_dummy`` method can be used to see which symbols cannot be\n    targeted by subs: those with a prepended underscore cannot be\n    changed with ``subs``. (Also, the integration variables themselves --\n    the first element of a limit -- can never be changed by subs.)\n\n    >>> i = Integral(x, x)\n    >>> at = Integral(x, (x, x))\n    >>> i.as_dummy()\n    Integral(x, x)\n    >>> at.as_dummy()\n    Integral(_0, (_0, x))\n\n    \"\"\"\n\n    #This will help other classes define their own definitions\n    #of behaviour with Integral.\n    if hasattr(function, '_eval_Integral'):\n        return function._eval_Integral(*symbols, **assumptions)\n\n    if isinstance(function, Poly):\n        sympy_deprecation_warning(\n            \"\"\"\n            integrate(Poly) and Integral(Poly) are deprecated. Instead,\n            use the Poly.integrate() method, or convert the Poly to an\n            Expr first with the Poly.as_expr() method.\n            \"\"\",\n            deprecated_since_version=\"1.6\",\n            active_deprecations_target=\"deprecated-integrate-poly\")\n\n    obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    "sympy.sympy.integrals.risch.integrate_primitive": "def integrate_primitive(a, d, DE, z=None):\n    \"\"\"\n    Integration of primitive functions.\n\n    Explanation\n    ===========\n\n    Given a primitive monomial t over k and f in k(t), return g elementary over\n    k(t), i in k(t), and b in {True, False} such that i = f - Dg is in k if b\n    is True or i = f - Dg does not have an elementary integral over k(t) if b\n    is False.\n\n    This function returns a Basic expression for the first argument.  If b is\n    True, the second argument is Basic expression in k to recursively integrate.\n    If b is False, the second argument is an unevaluated Integral, which has\n    been proven to be nonelementary.\n    \"\"\"\n    # XXX: a and d must be canceled, or this might return incorrect results\n    z = z or Dummy(\"z\")\n    s = list(zip(reversed(DE.T), reversed([f(DE.x) for f in DE.Tfuncs])))\n\n    g1, h, r = hermite_reduce(a, d, DE)\n    g2, b = residue_reduce(h[0], h[1], DE, z=z)\n    if not b:\n        i = cancel(a.as_expr()/d.as_expr() - (g1[1]*derivation(g1[0], DE) -\n            g1[0]*derivation(g1[1], DE)).as_expr()/(g1[1]**2).as_expr() -\n            residue_reduce_derivation(g2, DE, z))\n        i = NonElementaryIntegral(cancel(i).subs(s), DE.x)\n        return ((g1[0].as_expr()/g1[1].as_expr()).subs(s) +\n            residue_reduce_to_basic(g2, DE, z), i, b)\n\n    # h - Dg2 + r\n    p = cancel(h[0].as_expr()/h[1].as_expr() - residue_reduce_derivation(g2,\n        DE, z) + r[0].as_expr()/r[1].as_expr())\n    p = p.as_poly(DE.t)\n\n    q, i, b = integrate_primitive_polynomial(p, DE)\n\n    ret = ((g1[0].as_expr()/g1[1].as_expr() + q.as_expr()).subs(s) +\n        residue_reduce_to_basic(g2, DE, z))\n    if not b:\n        # TODO: This does not do the right thing when b is False\n        i = NonElementaryIntegral(cancel(i.as_expr()).subs(s), DE.x)\n    else:\n        i = cancel(i.as_expr())\n\n    return (ret, i, b)",
    "sympy.sympy.integrals.risch.integrate_hyperexponential": "def integrate_hyperexponential(a, d, DE, z=None, conds='piecewise'):\n    \"\"\"\n    Integration of hyperexponential functions.\n\n    Explanation\n    ===========\n\n    Given a hyperexponential monomial t over k and f in k(t), return g\n    elementary over k(t), i in k(t), and a bool b in {True, False} such that\n    i = f - Dg is in k if b is True or i = f - Dg does not have an elementary\n    integral over k(t) if b is False.\n\n    This function returns a Basic expression for the first argument.  If b is\n    True, the second argument is Basic expression in k to recursively integrate.\n    If b is False, the second argument is an unevaluated Integral, which has\n    been proven to be nonelementary.\n    \"\"\"\n    # XXX: a and d must be canceled, or this might return incorrect results\n    z = z or Dummy(\"z\")\n    s = [(z, DE.t**-1)] + list(zip(reversed(DE.T), reversed([f(DE.x) for f in DE.Tfuncs])))\n\n    g1, h, r = hermite_reduce(a, d, DE)\n    g2, b = residue_reduce(h[0], h[1], DE, z=z)\n    if not b:\n        i = cancel(a.as_expr()/d.as_expr() - (g1[1]*derivation(g1[0], DE) -\n            g1[0]*derivation(g1[1], DE)).as_expr()/(g1[1]**2).as_expr() -\n            residue_reduce_derivation(g2, DE, z))\n        i = NonElementaryIntegral(cancel(i.subs(s)), DE.x)\n        return ((g1[0].as_expr()/g1[1].as_expr()).subs(s) +\n            residue_reduce_to_basic(g2, DE, z), i, b)\n\n    # p should be a polynomial in t and 1/t, because Sirr == k[t, 1/t]\n    # h - Dg2 + r\n    p = cancel(h[0].as_expr()/h[1].as_expr() - residue_reduce_derivation(g2,\n        DE, z) + r[0].as_expr()/r[1].as_expr())\n    pp = as_poly_1t(p, DE.t, z)\n\n    qa, qd, b = integrate_hyperexponential_polynomial(pp, DE, z)\n\n    i = pp.nth(0, 0)\n\n    ret = ((g1[0].as_expr()/g1[1].as_expr()).subs(s) \\\n        + residue_reduce_to_basic(g2, DE, z))\n\n    qas = qa.as_expr().subs(s)\n    qds = qd.as_expr().subs(s)\n    if conds == 'piecewise' and DE.x not in qds.free_symbols:\n        # We have to be careful if the exponent is S.Zero!\n\n        # XXX: Does qd = 0 always necessarily correspond to the exponential\n        # equaling 1?\n        ret += Piecewise(\n                (qas/qds, Ne(qds, 0)),\n                (integrate((p - i).subs(DE.t, 1).subs(s), DE.x), True)\n            )\n    else:\n        ret += qas/qds\n\n    if not b:\n        i = p - (qd*derivation(qa, DE) - qa*derivation(qd, DE)).as_expr()/\\\n            (qd**2).as_expr()\n        i = NonElementaryIntegral(cancel(i).subs(s), DE.x)\n    return (ret, i, b)",
    "sympy.sympy.integrals.risch.__init__": "def __init__(self, f=None, x=None, handle_first='log', dummy=False, extension=None, rewrite_complex=None):\n    \"\"\"\n    Tries to build a transcendental extension tower from ``f`` with respect to ``x``.\n\n    Explanation\n    ===========\n\n    If it is successful, creates a DifferentialExtension object with, among\n    others, the attributes fa, fd, D, T, Tfuncs, and backsubs such that\n    fa and fd are Polys in T[-1] with rational coefficients in T[:-1],\n    fa/fd == f, and D[i] is a Poly in T[i] with rational coefficients in\n    T[:i] representing the derivative of T[i] for each i from 1 to len(T).\n    Tfuncs is a list of Lambda objects for back replacing the functions\n    after integrating.  Lambda() is only used (instead of lambda) to make\n    them easier to test and debug. Note that Tfuncs corresponds to the\n    elements of T, except for T[0] == x, but they should be back-substituted\n    in reverse order.  backsubs is a (possibly empty) back-substitution list\n    that should be applied on the completed integral to make it look more\n    like the original integrand.\n\n    If it is unsuccessful, it raises NotImplementedError.\n\n    You can also create an object by manually setting the attributes as a\n    dictionary to the extension keyword argument.  You must include at least\n    D.  Warning, any attribute that is not given will be set to None. The\n    attributes T, t, d, cases, case, x, and level are set automatically and\n    do not need to be given.  The functions in the Risch Algorithm will NOT\n    check to see if an attribute is None before using it.  This also does not\n    check to see if the extension is valid (non-algebraic) or even if it is\n    self-consistent.  Therefore, this should only be used for\n    testing/debugging purposes.\n    \"\"\"\n    # XXX: If you need to debug this function, set the break point here\n\n    if extension:\n        if 'D' not in extension:\n            raise ValueError(\"At least the key D must be included with \"\n                \"the extension flag to DifferentialExtension.\")\n        for attr in extension:\n            setattr(self, attr, extension[attr])\n\n        self._auto_attrs()\n\n        return\n    elif f is None or x is None:\n        raise ValueError(\"Either both f and x or a manual extension must \"\n        \"be given.\")\n\n    if handle_first not in ('log', 'exp'):\n        raise ValueError(\"handle_first must be 'log' or 'exp', not %s.\" %\n            str(handle_first))\n\n    # f will be the original function, self.f might change if we reset\n    # (e.g., we pull out a constant from an exponential)\n    self.f = f\n    self.x = x\n    # setting the default value 'dummy'\n    self.dummy = dummy\n    self.reset()\n    exp_new_extension, log_new_extension = True, True\n\n    # case of 'automatic' choosing\n    if rewrite_complex is None:\n        rewrite_complex = I in self.f.atoms()\n\n    if rewrite_complex:\n        rewritables = {\n            (sin, cos, cot, tan, sinh, cosh, coth, tanh): exp,\n            (asin, acos, acot, atan): log,\n        }\n        # rewrite the trigonometric components\n        for candidates, rule in rewritables.items():\n            self.newf = self.newf.rewrite(candidates, rule)\n        self.newf = cancel(self.newf)\n    else:\n        if any(i.has(x) for i in self.f.atoms(sin, cos, tan, atan, asin, acos)):\n            raise NotImplementedError(\"Trigonometric extensions are not \"\n            \"supported (yet!)\")\n\n    exps = set()\n    pows = set()\n    numpows = set()\n    sympows = set()\n    logs = set()\n    symlogs = set()\n\n    while True:\n        if self.newf.is_rational_function(*self.T):\n            break\n\n        if not exp_new_extension and not log_new_extension:\n            # We couldn't find a new extension on the last pass, so I guess\n            # we can't do it.\n            raise NotImplementedError(\"Couldn't find an elementary \"\n                \"transcendental extension for %s.  Try using a \" % str(f) +\n                \"manual extension with the extension flag.\")\n\n        exps, pows, numpows, sympows, log_new_extension = \\\n                self._rewrite_exps_pows(exps, pows, numpows, sympows, log_new_extension)\n\n        logs, symlogs = self._rewrite_logs(logs, symlogs)\n\n        if handle_first == 'exp' or not log_new_extension:\n            exp_new_extension = self._exp_part(exps)\n            if exp_new_extension is None:\n                # reset and restart\n                self.f = self.newf\n                self.reset()\n                exp_new_extension = True\n                continue\n\n        if handle_first == 'log' or not exp_new_extension:\n            log_new_extension = self._log_part(logs)\n\n    self.fa, self.fd = frac_in(self.newf, self.t)\n    self._auto_attrs()\n\n    return",
    "sympy.sympy.integrals.risch.decrement_level": "def decrement_level(self):\n    \"\"\"\n    Decrease the level of self.\n\n    Explanation\n    ===========\n\n    This makes the working differential extension smaller.  self.level is\n    given relative to the end of the list (-1, -2, etc.), so we do not need\n    do worry about it when building the extension.\n    \"\"\"\n    if self.level <= -len(self.T):\n        raise ValueError(\"The level of the differential extension cannot \"\n            \"be decremented any further.\")\n\n    self.level -= 1\n    self.t = self.T[self.level]\n    self.d = self.D[self.level]\n    self.case = self.cases[self.level]\n    return None",
    "sympy.sympy.integrals.risch.frac_in": "def frac_in(f, t, *, cancel=False, **kwargs):\n    \"\"\"\n    Returns the tuple (fa, fd), where fa and fd are Polys in t.\n\n    Explanation\n    ===========\n\n    This is a common idiom in the Risch Algorithm functions, so we abstract\n    it out here. ``f`` should be a basic expression, a Poly, or a tuple (fa, fd),\n    where fa and fd are either basic expressions or Polys, and f == fa/fd.\n    **kwargs are applied to Poly.\n    \"\"\"\n    if isinstance(f, tuple):\n        fa, fd = f\n        f = fa.as_expr()/fd.as_expr()\n    fa, fd = f.as_expr().as_numer_denom()\n    fa, fd = fa.as_poly(t, **kwargs), fd.as_poly(t, **kwargs)\n    if cancel:\n        fa, fd = fa.cancel(fd, include=True)\n    if fa is None or fd is None:\n        raise ValueError(\"Could not turn %s into a fraction in %s.\" % (f, t))\n    return (fa, fd)",
    "sympy.sympy.polys.polytools.as_expr": "def as_expr(f, *gens):\n    \"\"\"\n    Convert a Poly instance to an Expr instance.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x, y\n\n    >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n    >>> f.as_expr()\n    x**2 + 2*x*y**2 - y\n    >>> f.as_expr({x: 5})\n    10*y**2 - y + 25\n    >>> f.as_expr(5, 6)\n    379\n\n    \"\"\"\n    if not gens:\n        return f.expr\n\n    if len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\n                    \"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    "sympy.sympy.polys.polytools.expr": "@property\ndef expr(self):\n    return basic_from_dict(self.rep.to_sympy_dict(), *self.gens)",
    "sympy.sympy.polys.polytools.cancel": "def cancel(f, g, include=False):\n    \"\"\"\n    Cancel common factors in a rational function ``f/g``.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x\n\n    >>> Poly(2*x**2 - 2, x).cancel(Poly(x**2 - 2*x + 1, x))\n    (1, Poly(2*x + 2, x, domain='ZZ'), Poly(x - 1, x, domain='ZZ'))\n\n    >>> Poly(2*x**2 - 2, x).cancel(Poly(x**2 - 2*x + 1, x), include=True)\n    (Poly(2*x + 2, x, domain='ZZ'), Poly(x - 1, x, domain='ZZ'))\n\n    \"\"\"\n    dom, per, F, G = f._unify(g)\n\n    if hasattr(F, 'cancel'):\n        result = F.cancel(G, include=include)\n    else:  # pragma: no cover\n        raise OperationNotSupported(f, 'cancel')\n\n    if not include:\n        if dom.has_assoc_Ring:\n            dom = dom.get_ring()\n\n        cp, cq, p, q = result\n\n        cp = dom.to_sympy(cp)\n        cq = dom.to_sympy(cq)\n\n        return cp/cq, per(p), per(q)\n    else:\n        return tuple(map(per, result))"
}