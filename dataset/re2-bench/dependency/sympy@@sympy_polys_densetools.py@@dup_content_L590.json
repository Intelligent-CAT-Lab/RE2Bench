{
    "sympy.sympy.polys.domains.algebraicfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, AlgebraicField):\n        return self.dtype == other.dtype and self.ext == other.ext\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.complexfield.gcd": "def gcd(self, a, b):\n    \"\"\"Returns GCD of ``a`` and ``b``. \"\"\"\n    return self.one",
    "sympy.sympy.polys.domains.complexfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, ComplexField) and self.precision == other.precision",
    "sympy.sympy.polys.domains.domain.is_one": "def is_one(self, a: Er) -> bool:\n    \"\"\"Returns True if ``a`` is one. \"\"\"\n    return a == self.one",
    "sympy.sympy.polys.domains.expressiondomain.__eq__": "def __eq__(self, other):\n    if isinstance(other, ExpressionDomain):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.expressiondomain.gcd": "def gcd(self, a, b):\n    return self(1)",
    "sympy.sympy.polys.domains.field.gcd": "def gcd(self, a, b) -> Ef:\n    \"\"\"\n    Returns GCD of ``a`` and ``b``.\n\n    This definition of GCD over fields allows to clear denominators\n    in `primitive()`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy import S, gcd, primitive\n    >>> from sympy.abc import x\n\n    >>> QQ.gcd(QQ(2, 3), QQ(4, 9))\n    2/9\n    >>> gcd(S(2)/3, S(4)/9)\n    2/9\n    >>> primitive(2*x/3 + S(4)/9)\n    (2/9, 3*x + 2)\n\n    \"\"\"\n    try:\n        ring = self.get_ring()\n    except DomainError:\n        return self.one\n\n    p = ring.gcd(self.numer(a), self.numer(b))\n    q = ring.lcm(self.denom(a), self.denom(b))\n\n    return self.convert(p, ring)/q",
    "sympy.sympy.polys.domains.finitefield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    return isinstance(other, FiniteField) and \\\n        self.mod == other.mod and self.dom == other.dom",
    "sympy.sympy.polys.domains.fractionfield.zero": "@property\ndef zero(self):\n    return self.field.zero",
    "sympy.sympy.polys.domains.fractionfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if not isinstance(other, FractionField):\n        return NotImplemented\n    return self.field == other.field",
    "sympy.sympy.polys.domains.gaussiandomains.__eq__": "def __eq__(self, other) -> bool:\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, GaussianRationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.gaussiandomains.gcd": "def gcd(self, a: GaussianInteger, b: GaussianInteger) -> GaussianInteger:\n    \"\"\"Greatest common divisor of a and b over ZZ_I.\"\"\"\n    while b:\n        a, b = b, a % b\n    unit = self.canonical_unit(a)\n    return a*unit",
    "sympy.sympy.polys.domains.integerring.gcd": "def gcd(self, a, b):\n    \"\"\"Compute GCD of ``a`` and ``b``. \"\"\"\n    return gcd(a, b)",
    "sympy.sympy.polys.domains.integerring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, IntegerRing):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.polynomialring.gcd": "def gcd(self, a, b):\n    \"\"\"Returns GCD of `a` and `b`. \"\"\"\n    return a.gcd(b)",
    "sympy.sympy.polys.domains.polynomialring.zero": "@property\ndef zero(self) -> PolyElement[Er]: # type: ignore\n    return self.ring.zero",
    "sympy.sympy.polys.domains.polynomialring.__eq__": "def __eq__(self, other):\n    \"\"\"Returns `True` if two domains are equivalent. \"\"\"\n    if not isinstance(other, PolynomialRing):\n        return NotImplemented\n    return self.ring == other.ring",
    "sympy.sympy.polys.domains.rationalfield.__eq__": "def __eq__(self, other):\n    \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n    if isinstance(other, RationalField):\n        return True\n    else:\n        return NotImplemented",
    "sympy.sympy.polys.domains.realfield.__eq__": "def __eq__(self, other):\n    return isinstance(other, RealField) and self.precision == other.precision",
    "sympy.sympy.polys.domains.realfield.gcd": "def gcd(self, a, b):\n    \"\"\"Returns GCD of ``a`` and ``b``. \"\"\"\n    return self.one"
}