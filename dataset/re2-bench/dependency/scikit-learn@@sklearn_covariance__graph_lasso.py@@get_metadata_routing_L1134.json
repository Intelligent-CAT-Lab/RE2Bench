{
    "scikit-learn.sklearn.model_selection._split.check_cv": "def check_cv(cv=5, y=None, *, classifier=False):\n    \"\"\"Input checker utility for building a cross-validator.\n\n    Parameters\n    ----------\n    cv : int, cross-validation generator, iterable or None, default=5\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds.\n        - :term:`CV splitter`,\n        - An iterable that generates (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if classifier is True and ``y`` is either\n        binary or multiclass, :class:`StratifiedKFold` is used. In all other\n        cases, :class:`KFold` is used.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value changed from 3-fold to 5-fold.\n\n    y : array-like, default=None\n        The target variable for supervised learning problems.\n\n    classifier : bool, default=False\n        Whether the task is a classification task, in which case\n        stratified KFold will be used.\n\n    Returns\n    -------\n    checked_cv : a cross-validator instance.\n        The return value is a cross-validator which generates the train/test\n        splits via the ``split`` method.\n\n    Examples\n    --------\n    >>> from sklearn.model_selection import check_cv\n    >>> check_cv(cv=5, y=None, classifier=False)\n    KFold(...)\n    >>> check_cv(cv=5, y=[1, 1, 0, 0, 0, 0], classifier=True)\n    StratifiedKFold(...)\n    \"\"\"\n    cv = 5 if cv is None else cv\n    if isinstance(cv, numbers.Integral):\n        if (\n            classifier\n            and (y is not None)\n            and (type_of_target(y, input_name=\"y\") in (\"binary\", \"multiclass\"))\n        ):\n            return StratifiedKFold(cv)\n        else:\n            return KFold(cv)\n\n    if not hasattr(cv, \"split\") or isinstance(cv, str):\n        if not isinstance(cv, Iterable) or isinstance(cv, str):\n            raise ValueError(\n                \"Expected cv as an integer, cross-validation \"\n                \"object (from sklearn.model_selection) \"\n                \"or an iterable. Got %s.\" % cv\n            )\n        return _CVIterableWrapper(cv)\n\n    return cv  # New style cv objects are passed without any modification",
    "scikit-learn.sklearn.utils._metadata_requests.__init__": "def __init__(self, owner):\n    self._route_mappings = dict()\n    # `_self_request` is used if the router is also a consumer.\n    # _self_request, (added using `add_self_request()`) is treated\n    # differently from the other consumer objects which are stored in\n    # _route_mappings.\n    self._self_request = None\n    self.owner = owner",
    "scikit-learn.sklearn.utils._metadata_requests.add": "def add(self, *, method_mapping, **objs):\n    \"\"\"Add :term:`consumers <consumer>` to the `MetadataRouter`.\n\n    The estimators that consume metadata are passed as named objects along with a\n    method mapping, that defines how their methods relate to those of the\n    :term:`router`.\n\n    Parameters\n    ----------\n    method_mapping : MethodMapping\n        The mapping between the child (:term:`consumer`) and the parent's\n        (:term:`router`'s) methods.\n\n    **objs : dict\n        A dictionary of objects, whose requests are extracted by calling\n        :func:`~sklearn.utils.metadata_routing.get_routing_for_object` on them.\n\n    Returns\n    -------\n    self : MetadataRouter\n        Returns `self`.\n    \"\"\"\n    method_mapping = deepcopy(method_mapping)\n\n    for name, obj in objs.items():\n        self._route_mappings[name] = RouterMappingPair(\n            mapping=method_mapping, router=get_routing_for_object(obj)\n        )\n    return self"
}