{
    "sympy.sympy.algebras.quaternion.is_zero_quaternion": "def is_zero_quaternion(self) -> bool | None:\n    \"\"\"\n    Returns true if the quaternion is a zero quaternion or false if it is not a zero quaternion\n    and None if the value is unknown.\n\n    Explanation\n    ===========\n\n    A zero quaternion is a quaternion with both scalar part and\n    vector part equal to 0.\n\n    Examples\n    ========\n\n    >>> from sympy.algebras.quaternion import Quaternion\n    >>> q = Quaternion(1, 0, 0, 0)\n    >>> q.is_zero_quaternion()\n    False\n\n    >>> q = Quaternion(0, 0, 0, 0)\n    >>> q.is_zero_quaternion()\n    True\n\n    See Also\n    ========\n    scalar_part\n    vector_part\n\n    \"\"\"\n\n    return self.norm().is_zero",
    "sympy.sympy.algebras.quaternion.a": "@property\ndef a(self) -> Expr:\n    return self.args[0]",
    "sympy.sympy.algebras.quaternion.b": "@property\ndef b(self) -> Expr:\n    return self.args[1]",
    "sympy.sympy.algebras.quaternion.c": "@property\ndef c(self) -> Expr:\n    return self.args[2]",
    "sympy.sympy.algebras.quaternion.d": "@property\ndef d(self) -> Expr:\n    return self.args[3]",
    "sympy.sympy.algebras.quaternion._is_extrinsic": "def _is_extrinsic(seq: str) -> bool:\n    \"\"\"validate seq and return True if seq is lowercase and False if uppercase\"\"\"\n    if type(seq) != str:\n        raise ValueError('Expected seq to be a string.')\n    if len(seq) != 3:\n        raise ValueError(\"Expected 3 axes, got `{}`.\".format(seq))\n\n    intrinsic = seq.isupper()\n    extrinsic = seq.islower()\n    if not (intrinsic or extrinsic):\n        raise ValueError(\"seq must either be fully uppercase (for extrinsic \"\n                         \"rotations), or fully lowercase, for intrinsic \"\n                         \"rotations).\")\n\n    i, j, k = list(seq.lower())\n    if (i == j) or (j == k):\n        raise ValueError(\"Consecutive axes must be different\")\n\n    bad = set(seq) - set('xyzXYZ')\n    if bad:\n        raise ValueError(\"Expected axes from `seq` to be from \"\n                         \"['x', 'y', 'z'] or ['X', 'Y', 'Z'], \"\n                         \"got {}\".format(''.join(bad)))\n\n    return extrinsic",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.numbers.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    "sympy.sympy.core.numbers.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.relational.is_eq": "def is_eq(lhs: Basic, rhs: Basic, assumptions=None) -> bool | None:\n    \"\"\"\n    Fuzzy bool representing mathematical equality between *lhs* and *rhs*.\n\n    Parameters\n    ==========\n\n    lhs : Expr\n        The left-hand side of the expression, must be sympified.\n\n    rhs : Expr\n        The right-hand side of the expression, must be sympified.\n\n    assumptions: Boolean, optional\n        Assumptions taken to evaluate the equality.\n\n    Returns\n    =======\n\n    ``True`` if *lhs* is equal to *rhs*, ``False`` is *lhs* is not equal to *rhs*,\n    and ``None`` if the comparison between *lhs* and *rhs* is indeterminate.\n\n    Explanation\n    ===========\n\n    This function is intended to give a relatively fast determination and\n    deliberately does not attempt slow calculations that might help in\n    obtaining a determination of True or False in more difficult cases.\n\n    :func:`~.is_neq` calls this function to return its value, so supporting\n    new type with this function will ensure correct behavior for ``is_neq``\n    as well.\n\n    Examples\n    ========\n\n    >>> from sympy import Q, S\n    >>> from sympy.core.relational import is_eq, is_neq\n    >>> from sympy.abc import x\n    >>> is_eq(S(0), S(0))\n    True\n    >>> is_neq(S(0), S(0))\n    False\n    >>> is_eq(S(0), S(2))\n    False\n    >>> is_neq(S(0), S(2))\n    True\n\n    Assumptions can be passed to evaluate the equality which is otherwise\n    indeterminate.\n\n    >>> print(is_eq(x, S(0)))\n    None\n    >>> is_eq(x, S(0), assumptions=Q.zero(x))\n    True\n\n    New types can be supported by dispatching to ``_eval_is_eq``.\n\n    >>> from sympy import Basic, sympify\n    >>> from sympy.multipledispatch import dispatch\n    >>> class MyBasic(Basic):\n    ...     def __new__(cls, arg):\n    ...         return Basic.__new__(cls, sympify(arg))\n    ...     @property\n    ...     def value(self):\n    ...         return self.args[0]\n    ...\n    >>> @dispatch(MyBasic, MyBasic)\n    ... def _eval_is_eq(a, b):\n    ...     return is_eq(a.value, b.value)\n    ...\n    >>> a = MyBasic(1)\n    >>> b = MyBasic(1)\n    >>> is_eq(a, b)\n    True\n    >>> is_neq(a, b)\n    False\n\n    \"\"\"\n    # here, _eval_Eq is only called for backwards compatibility\n    # new code should use is_eq with multiple dispatch as\n    # outlined in the docstring\n    for side1, side2 in (lhs, rhs), (rhs, lhs):\n        eval_func = getattr(side1, '_eval_Eq', None)\n        if eval_func is not None:\n            retval = eval_func(side2)\n            if retval is not None:\n                return retval\n\n    retval = _eval_is_eq(lhs, rhs)\n    if retval is not None:\n        return retval\n\n    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):\n        retval = _eval_is_eq(rhs, lhs)\n        if retval is not None:\n            return retval\n\n    # retval is still None, so go through the equality logic\n    # If expressions have the same structure, they must be equal.\n    if lhs == rhs:\n        return True  # e.g. True == True\n    elif all(isinstance(i, BooleanAtom) for i in (rhs, lhs)):\n        return False  # True != False\n    elif not (lhs.is_Symbol or rhs.is_Symbol) and (\n        isinstance(lhs, Boolean) !=\n        isinstance(rhs, Boolean)):\n        return False  # only Booleans can equal Booleans\n\n    from sympy.assumptions.wrapper import (AssumptionsWrapper,\n        is_infinite, is_extended_real)\n    from .add import Add\n\n    _lhs = AssumptionsWrapper(lhs, assumptions)\n    _rhs = AssumptionsWrapper(rhs, assumptions)\n\n    if _lhs.is_infinite or _rhs.is_infinite:\n        if fuzzy_xor([_lhs.is_infinite, _rhs.is_infinite]):\n            return False\n        if fuzzy_xor([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return False\n        if fuzzy_and([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return fuzzy_xor([_lhs.is_extended_positive, fuzzy_not(_rhs.is_extended_positive)])\n\n        # Try to split real/imaginary parts and equate them\n        I = S.ImaginaryUnit\n\n        def split_real_imag(expr):\n            real_imag = lambda t: (\n                'real' if is_extended_real(t, assumptions) else\n                'imag' if is_extended_real(I*t, assumptions) else None)\n            return sift(Add.make_args(expr), real_imag)\n\n        lhs_ri = split_real_imag(lhs)\n        if not lhs_ri[None]:\n            rhs_ri = split_real_imag(rhs)\n            if not rhs_ri[None]:\n                eq_real = is_eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']), assumptions)\n                eq_imag = is_eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']), assumptions)\n                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n\n        from sympy.functions.elementary.complexes import arg\n        # Compare e.g. zoo with 1+I*oo by comparing args\n        arglhs = arg(lhs)\n        argrhs = arg(rhs)\n        # Guard against Eq(nan, nan) -> False\n        if not (arglhs == S.NaN and argrhs == S.NaN):\n            return fuzzy_bool(is_eq(arglhs, argrhs, assumptions))\n\n    if isinstance(lhs, Expr) and isinstance(rhs, Expr):\n        # see if the difference evaluates\n        dif = lhs - rhs\n        _dif = AssumptionsWrapper(dif, assumptions)\n        z = _dif.is_zero\n        if z is not None:\n            if z is False and _dif.is_commutative:  # issue 10728\n                return False\n            if z:\n                return True\n\n        # is_zero cannot help decide integer/rational with Float\n        c, t = dif.as_coeff_Add()\n        if c.is_Float:\n            if int_valued(c):\n                if t.is_integer is False:\n                    return False\n            elif t.is_rational is False:\n                return False\n\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            return _sympify(n2 == 0)\n\n        # see if the ratio evaluates\n        n, d = dif.as_numer_denom()\n        rv = None\n        _n = AssumptionsWrapper(n, assumptions)\n        _d = AssumptionsWrapper(d, assumptions)\n        if _n.is_zero:\n            rv = _d.is_nonzero\n        elif _n.is_finite:\n            if _d.is_infinite:\n                rv = True\n            elif _n.is_zero is False:\n                rv = _d.is_infinite\n                if rv is None:\n                    # if the condition that makes the denominator\n                    # infinite does not make the original expression\n                    # True then False can be returned\n                    from sympy.simplify.simplify import clear_coefficients\n                    l, r = clear_coefficients(d, S.Infinity)\n                    lhs2 = lhs.subs(l, r)\n                    rhs2 = rhs.subs(l, r)\n                    if lhs2 != lhs or rhs2 != rhs:\n                        rv = fuzzy_bool(is_eq(lhs2, rhs2, assumptions))\n                        if rv is True:\n                            rv = None\n        elif any(is_infinite(a, assumptions) for a in Add.make_args(n)):\n            # (inf or nan)/x != 0\n            rv = False\n        if rv is not None:\n            return rv\n\n    return None",
    "sympy.sympy.functions.elementary.miscellaneous.sqrt": "def sqrt(arg, evaluate=None):\n    \"\"\"Returns the principal square root.\n\n    Parameters\n    ==========\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt, Symbol, S\n    >>> x = Symbol('x')\n\n    >>> sqrt(x)\n    sqrt(x)\n\n    >>> sqrt(x)**2\n    x\n\n    Note that sqrt(x**2) does not simplify to x.\n\n    >>> sqrt(x**2)\n    sqrt(x**2)\n\n    This is because the two are not equal to each other in general.\n    For example, consider x == -1:\n\n    >>> from sympy import Eq\n    >>> Eq(sqrt(x**2), x).subs(x, -1)\n    False\n\n    This is because sqrt computes the principal square root, so the square may\n    put the argument in a different branch.  This identity does hold if x is\n    positive:\n\n    >>> y = Symbol('y', positive=True)\n    >>> sqrt(y**2)\n    y\n\n    You can force this simplification by using the powdenest() function with\n    the force option set to True:\n\n    >>> from sympy import powdenest\n    >>> sqrt(x**2)\n    sqrt(x**2)\n    >>> powdenest(sqrt(x**2), force=True)\n    x\n\n    To get both branches of the square root you can use the rootof function:\n\n    >>> from sympy import rootof\n\n    >>> [rootof(x**2-3,i) for i in (0,1)]\n    [-sqrt(3), sqrt(3)]\n\n    Although ``sqrt`` is printed, there is no ``sqrt`` function so looking for\n    ``sqrt`` in an expression will fail:\n\n    >>> from sympy.utilities.misc import func_name\n    >>> func_name(sqrt(x))\n    'Pow'\n    >>> sqrt(x).has(sqrt)\n    False\n\n    To find ``sqrt`` look for ``Pow`` with an exponent of ``1/2``:\n\n    >>> (x + 1/sqrt(x)).find(lambda i: i.is_Pow and abs(i.exp) is S.Half)\n    {1/sqrt(x)}\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof, root, real_root\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Square_root\n    .. [2] https://en.wikipedia.org/wiki/Principal_value\n    \"\"\"\n    # arg = sympify(arg) is handled by Pow\n    return Pow(arg, S.Half, evaluate=evaluate)"
}