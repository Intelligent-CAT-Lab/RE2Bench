{
    "sympy.sympy.core.traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            # LatticeOp keeps args as a set. We should use this if we\n            # don't care about the order, to prevent unnecessary sorting.\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    "sympy.sympy.strategies.branch.core.yieldify": "def yieldify(rl):\n    \"\"\" Turn a rule into a branching rule \"\"\"\n    def brl(expr):\n        yield rl(expr)\n    return brl",
    "sympy.sympy.strategies.branch.core.multiplex": "def multiplex(*brules):\n    \"\"\" Multiplex many branching rules into one \"\"\"\n    def multiplex_brl(expr):\n        seen = set()\n        for brl in brules:\n            for nexpr in brl(expr):\n                if nexpr not in seen:\n                    seen.add(nexpr)\n                    yield nexpr\n    return multiplex_brl",
    "sympy.sympy.strategies.branch.core.chain": "def chain(*brules):\n    \"\"\"\n    Compose a sequence of brules so that they apply to the expr sequentially\n    \"\"\"\n    def chain_brl(expr):\n        if not brules:\n            yield expr\n            return\n\n        head, tail = brules[0], brules[1:]\n        for nexpr in head(expr):\n            yield from chain(*tail)(nexpr)\n\n    return chain_brl",
    "sympy.sympy.strategies.core.identity": "def identity(x: _T) -> _T:\n    return x",
    "sympy.sympy.strategies.core.minimize": "def minimize(\n    *rules: Callable[[_S], _T],\n    objective=_identity\n) -> Callable[[_S], _T]:\n    \"\"\" Select result of rules that minimizes objective\n\n    >>> from sympy.strategies import minimize\n    >>> inc = lambda x: x + 1\n    >>> dec = lambda x: x - 1\n    >>> rl = minimize(inc, dec)\n    >>> rl(4)\n    3\n\n    >>> rl = minimize(inc, dec, objective=lambda x: -x)  # maximize\n    >>> rl(4)\n    5\n    \"\"\"\n    def minrule(expr: _S) -> _T:\n        return min([rule(expr) for rule in rules], key=objective)\n    return minrule",
    "sympy.sympy.strategies.core.chain": "def chain(*rules: Callable[[_T], _T]) -> Callable[[_T], _T]:\n    \"\"\"\n    Compose a sequence of rules so that they apply to the expr sequentially\n    \"\"\"\n    def chain_rl(expr: _T) -> _T:\n        for rule in rules:\n            expr = rule(expr)\n        return expr\n    return chain_rl",
    "sympy.sympy.strategies.tree.treeapply": "def treeapply(tree, join, leaf=identity):\n    \"\"\" Apply functions onto recursive containers (tree).\n\n    Explanation\n    ===========\n\n    join - a dictionary mapping container types to functions\n      e.g. ``{list: minimize, tuple: chain}``\n\n    Keys are containers/iterables.  Values are functions [a] -> a.\n\n    Examples\n    ========\n\n    >>> from sympy.strategies.tree import treeapply\n    >>> tree = [(3, 2), (4, 1)]\n    >>> treeapply(tree, {list: max, tuple: min})\n    2\n\n    >>> add = lambda *args: sum(args)\n    >>> def mul(*args):\n    ...     total = 1\n    ...     for arg in args:\n    ...         total *= arg\n    ...     return total\n    >>> treeapply(tree, {list: mul, tuple: add})\n    25\n    \"\"\"\n    for typ in join:\n        if isinstance(tree, typ):\n            return join[typ](*map(partial(treeapply, join=join, leaf=leaf),\n                                  tree))\n    return leaf(tree)",
    "sympy.sympy.utilities.iterables.numbered_symbols": "def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):\n    \"\"\"\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    \"\"\"\n    exclude = set(exclude or [])\n    if cls is None:\n        # We can't just make the default cls=Symbol because it isn't\n        # imported yet.\n        from sympy.core import Symbol\n        cls = Symbol\n\n    while True:\n        name = '%s%s' % (prefix, start)\n        s = cls(name, *args, **assumptions)\n        if s not in exclude:\n            yield s\n        start += 1"
}