{
    "sympy.sympy.multipledispatch.dispatcher.add": "def add(self, signature, func, on_ambiguity=ambiguity_warn):\n    \"\"\" Add new types/method pair to dispatcher\n\n    >>> from sympy.multipledispatch import Dispatcher\n    >>> D = Dispatcher('add')\n    >>> D.add((int, int), lambda x, y: x + y)\n    >>> D.add((float, float), lambda x, y: x + y)\n\n    >>> D(1, 2)\n    3\n    >>> D(1, 2.0)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError: Could not find signature for add: <int, float>\n\n    When ``add`` detects a warning it calls the ``on_ambiguity`` callback\n    with a dispatcher/itself, and a set of ambiguous type signature pairs\n    as inputs.  See ``ambiguity_warn`` for an example.\n    \"\"\"\n    # Handle annotations\n    if not signature:\n        annotations = self.get_func_annotations(func)\n        if annotations:\n            signature = annotations\n\n    # Handle union types\n    if any(isinstance(typ, tuple) for typ in signature):\n        for typs in expand_tuples(signature):\n            self.add(typs, func, on_ambiguity)\n        return\n\n    for typ in signature:\n        if not isinstance(typ, type):\n            str_sig = ', '.join(c.__name__ if isinstance(c, type)\n                                else str(c) for c in signature)\n            raise TypeError(\"Tried to dispatch on non-type: %s\\n\"\n                            \"In signature: <%s>\\n\"\n                            \"In function: %s\" %\n                            (typ, str_sig, self.name))\n\n    self.funcs[signature] = func\n    self.reorder(on_ambiguity=on_ambiguity)\n    self._cache.clear()",
    "sympy.sympy.multipledispatch.dispatcher.<genexpr>": "str_sig = ', '.join(c.__name__ if isinstance(c, type)\n                    else str(c) for c in signature)\n",
    "sympy.sympy.multipledispatch.dispatcher.reorder": "def reorder(self, on_ambiguity=ambiguity_warn):\n    if _resolve[0]:\n        self.ordering = ordering(self.funcs)\n        amb = ambiguities(self.funcs)\n        if amb:\n            on_ambiguity(self, amb)\n    else:\n        _unresolved_dispatchers.add(self)",
    "sympy.sympy.multipledispatch.utils.expand_tuples": "def expand_tuples(L):\n    \"\"\"\n    >>> from sympy.multipledispatch.utils import expand_tuples\n    >>> expand_tuples([1, (2, 3)])\n    [(1, 2), (1, 3)]\n\n    >>> expand_tuples([1, 2])\n    [(1, 2)]\n    \"\"\"\n    if not L:\n        return [()]\n    elif not isinstance(L[0], tuple):\n        rest = expand_tuples(L[1:])\n        return [(L[0],) + t for t in rest]\n    else:\n        rest = expand_tuples(L[1:])\n        return [(item,) + t for t in rest for item in L[0]]"
}