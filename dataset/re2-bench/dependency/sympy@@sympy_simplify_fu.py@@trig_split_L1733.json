{
    "sympy.sympy.core.basic.__eq__": "def __eq__(self, other):\n    \"\"\"Return a boolean indicating whether a == b on the basis of\n    their symbolic trees.\n\n    This is the same as a.compare(b) == 0 but faster.\n\n    Notes\n    =====\n\n    If a class that overrides __eq__() needs to retain the\n    implementation of __hash__() from a parent class, the\n    interpreter must be told this explicitly by setting\n    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.\n    Otherwise the inheritance of __hash__() will be blocked,\n    just as if __hash__ had been explicitly set to None.\n\n    References\n    ==========\n\n    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__\n    \"\"\"\n    if self is other:\n        return True\n\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n\n    # check for pure number expr\n    if  not (self.is_Number and other.is_Number) and (\n            type(self) != type(other)):\n        return False\n    a, b = self._hashable_content(), other._hashable_content()\n    if a != b:\n        return False\n    # check number *in* an expression\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    "sympy.sympy.core.basic.args": "@property\ndef args(self) -> tuple[Basic, ...]:\n    \"\"\"Returns a tuple of arguments of 'self'.\n\n    Examples\n    ========\n\n    >>> from sympy import cot\n    >>> from sympy.abc import x, y\n\n    >>> cot(x).args\n    (x,)\n\n    >>> cot(x).args[0]\n    x\n\n    >>> (x*y).args\n    (x, y)\n\n    >>> (x*y).args[1]\n    y\n\n    Notes\n    =====\n\n    Never use self._args, always use self.args.\n    Only use _args in __new__ when creating a new function.\n    Do not override .args() from Basic (so that it is easy to\n    change the interface in the future if needed).\n    \"\"\"\n    return self._args",
    "sympy.sympy.core.cache.wrapper": "@wraps(func)\ndef wrapper(*args, **kwargs):\n    try:\n        retval = cfunc(*args, **kwargs)\n    except TypeError as e:\n        if not e.args or not e.args[0].startswith('unhashable type:'):\n            raise\n        retval = func(*args, **kwargs)\n    return retval",
    "sympy.sympy.core.decorators._func": "@wraps(func)\ndef _func(self, other):\n    # XXX: The check for _op_priority here should be removed. It is\n    # needed to stop mutable matrices from being sympified to\n    # immutable matrices which breaks things in quantum...\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    "sympy.sympy.core.decorators.__sympifyit_wrapper": "@wraps(func)\ndef __sympifyit_wrapper(a, b):\n    try:\n        # If an external class has _op_priority, it knows how to deal\n        # with SymPy objects. Otherwise, it must be converted.\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    "sympy.sympy.core.exprtools.as_expr": "def as_expr(self):  # Factors\n    \"\"\"Return the underlying expression.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y\n    >>> Factors((x*y**2).as_powers_dict()).as_expr()\n    x*y**2\n\n    \"\"\"\n\n    args = []\n    for factor, exp in self.factors.items():\n        if exp != 1:\n            if isinstance(exp, Integer):\n                b, e = factor.as_base_exp()\n                e = _keep_coeff(exp, e)\n                args.append(b**e)\n            else:\n                args.append(factor**exp)\n        else:\n            args.append(factor)\n    return Mul(*args)",
    "sympy.sympy.core.exprtools.normal": "def normal(self, other):\n    \"\"\"Return ``self`` and ``other`` with ``gcd`` removed from each.\n    The only differences between this and method ``div`` is that this\n    is 1) optimized for the case when there are few factors in common and\n    2) this does not raise an error if ``other`` is zero.\n\n    See Also\n    ========\n    div\n\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return (Factors(), Factors(S.Zero))\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n\n    self_factors = dict(self.factors)\n    other_factors = dict(other.factors)\n\n    for factor, self_exp in self.factors.items():\n        try:\n            other_exp = other.factors[factor]\n        except KeyError:\n            continue\n\n        exp = self_exp - other_exp\n\n        if not exp:\n            del self_factors[factor]\n            del other_factors[factor]\n        elif _isnumber(exp):\n            if exp > 0:\n                self_factors[factor] = exp\n                del other_factors[factor]\n            else:\n                del self_factors[factor]\n                other_factors[factor] = -exp\n        else:\n            r = self_exp.extract_additively(other_exp)\n            if r is not None:\n                if r:\n                    self_factors[factor] = r\n                    del other_factors[factor]\n                else:  # should be handled already\n                    del self_factors[factor]\n                    del other_factors[factor]\n            else:\n                sc, sa = self_exp.as_coeff_Add()\n                if sc:\n                    oc, oa = other_exp.as_coeff_Add()\n                    diff = sc - oc\n                    if diff > 0:\n                        self_factors[factor] -= oc\n                        other_exp = oa\n                    elif diff < 0:\n                        self_factors[factor] -= sc\n                        other_factors[factor] -= sc\n                        other_exp = oa - diff\n                    else:\n                        self_factors[factor] = sa\n                        other_exp = oa\n                if other_exp:\n                    other_factors[factor] = other_exp\n                else:\n                    del other_factors[factor]\n\n    return Factors(self_factors), Factors(other_factors)",
    "sympy.sympy.core.exprtools.quo": "def quo(self, other):  # Factors\n    \"\"\"Return numerator Factor of ``self / other``.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.quo(b)  # same as a/b\n    Factors({y: 1})\n    \"\"\"\n    return self.div(other)[0]",
    "sympy.sympy.core.exprtools.gcd": "def gcd(self, other):  # Factors\n    \"\"\"Return Factors of ``gcd(self, other)``. The keys are\n    the intersection of factors with the minimum exponent for\n    each factor.\n\n    Examples\n    ========\n\n    >>> from sympy.core.exprtools import Factors\n    >>> from sympy.abc import x, y, z\n    >>> a = Factors((x*y**2).as_powers_dict())\n    >>> b = Factors((x*y/z).as_powers_dict())\n    >>> a.gcd(b)\n    Factors({x: 1, y: 1})\n    \"\"\"\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return Factors(self.factors)\n\n    factors = {}\n\n    for factor, exp in self.factors.items():\n        factor, exp = sympify(factor), sympify(exp)\n        if factor in other.factors:\n            lt = (exp - other.factors[factor]).is_negative\n            if lt == True:\n                factors[factor] = exp\n            elif lt == False:\n                factors[factor] = other.factors[factor]\n\n    return Factors(factors)",
    "sympy.sympy.core.function.func": "@property\ndef func(self):\n    return self.__class__",
    "sympy.sympy.core.numbers.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return (self.p == other)\n    elif isinstance(other, Integer):\n        return (self.p == other.p)\n    return Rational.__eq__(self, other)",
    "sympy.sympy.core.numbers.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p*other)\n        elif isinstance(other, Integer):\n            return Integer(self.p*other.p)\n        elif isinstance(other, Rational):\n            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    "sympy.sympy.core.numbers.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other*self.p)\n        elif isinstance(other, Rational):\n            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    "sympy.sympy.core.numbers.__hash__": "def __hash__(self):\n    return hash(self.p)",
    "sympy.sympy.simplify.fu.<listcomp>": "a, b = [i.as_expr() for i in (ua, ub)]\n\n",
    "sympy.sympy.simplify.fu.pow_cos_sin": "def pow_cos_sin(a, two):\n    \"\"\"Return ``a`` as a tuple (r, c, s) such that\n    ``a = (r or 1)*(c or 1)*(s or 1)``.\n\n    Three arguments are returned (radical, c-factor, s-factor) as\n    long as the conditions set by ``two`` are met; otherwise None is\n    returned. If ``two`` is True there will be one or two non-None\n    values in the tuple: c and s or c and r or s and r or s or c with c\n    being a cosine function (if possible) else a sine, and s being a sine\n    function (if possible) else oosine. If ``two`` is False then there\n    will only be a c or s term in the tuple.\n\n    ``two`` also require that either two cos and/or sin be present (with\n    the condition that if the functions are the same the arguments are\n    different or vice versa) or that a single cosine or a single sine\n    be present with an optional radical.\n\n    If the above conditions dictated by ``two`` are not met then None\n    is returned.\n    \"\"\"\n    c = s = None\n    co = S.One\n    if a.is_Mul:\n        co, a = a.as_coeff_Mul()\n        if len(a.args) > 2 or not two:\n            return None\n        if a.is_Mul:\n            args = list(a.args)\n        else:\n            args = [a]\n        a = args.pop(0)\n        if isinstance(a, cos):\n            c = a\n        elif isinstance(a, sin):\n            s = a\n        elif a.is_Pow and a.exp is S.Half:  # autoeval doesn't allow -1/2\n            co *= a\n        else:\n            return None\n        if args:\n            b = args[0]\n            if isinstance(b, cos):\n                if c:\n                    s = b\n                else:\n                    c = b\n            elif isinstance(b, sin):\n                if s:\n                    c = b\n                else:\n                    s = b\n            elif b.is_Pow and b.exp is S.Half:\n                co *= b\n            else:\n                return None\n        return co if co is not S.One else None, c, s\n    elif isinstance(a, cos):\n        c = a\n    elif isinstance(a, sin):\n        s = a\n    if c is None and s is None:\n        return\n    co = co if co is not S.One else None\n    return co, c, s",
    "sympy.sympy.simplify.fu.<setcomp>": "args = {j.args for j in (ca, sa)}\n",
    "sympy.sympy.simplify.fu.<genexpr>": "if not all(i.args in args for i in (cb, sb)):\n    return\n"
}