{
    "sympy.sympy.matrices.immutable._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.inverse._try_DM": "def _try_DM(M, use_EX=False):\n    \"\"\"Try to convert a matrix to a ``DomainMatrix``.\"\"\"\n    dM = M.to_DM()\n    K = dM.domain\n\n    # Return DomainMatrix if a domain is found. Only use EX if use_EX=True.\n    if not use_EX and K.is_EXRAW:\n        return None\n    elif K.is_EXRAW:\n        return dM.convert_to(EX)\n    else:\n        return dM",
    "sympy.sympy.matrices.inverse._inv_DM": "def _inv_DM(dM, cancel=True):\n    \"\"\"Calculates the inverse using ``DomainMatrix``.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_GE\n    inverse_CH\n    inverse_LDL\n    sympy.polys.matrices.domainmatrix.DomainMatrix.inv\n    \"\"\"\n    m, n = dM.shape\n    dom = dM.domain\n\n    if m != n:\n        raise NonSquareMatrixError(\"A Matrix must be square to invert.\")\n\n    # Convert RR[a,b,...] to QQ[a,b,...]\n    use_exact = _use_exact_domain(dom)\n\n    if use_exact:\n        dom_exact = dom.get_exact()\n        dM = dM.convert_to(dom_exact)\n    else:\n        dom_exact = None\n\n    try:\n        dMi, den = dM.inv_den()\n    except DMNonInvertibleMatrixError:\n        raise NonInvertibleMatrixError(\"Matrix det == 0; not invertible.\")\n\n    if dom_exact is not None:\n        dMi = dMi.convert_to(dom)\n        den = dom.convert_from(den, dom_exact)\n\n    if cancel:\n        # Convert to field and cancel with the denominator.\n        if not dMi.domain.is_Field:\n            dMi = dMi.to_field()\n        Mi = (dMi / den).to_Matrix()\n    else:\n        # Convert to Matrix and divide without cancelling\n        Mi = dMi.to_Matrix() / dMi.domain.to_sympy(den)\n\n    return Mi",
    "sympy.sympy.matrices.matrixbase.diag": "@classmethod\ndef diag(kls, *args: SExpr | Sequence[SExpr] | MatrixBase,\n            strict: bool = False,\n            unpack: bool = True,\n            rows: int | None = None,\n            cols: int | None = None,\n         cls: type[Tmat] | None = None) -> Self | Tmat:\n    \"\"\"Returns a matrix with the specified diagonal.\n    If matrices are passed, a block-diagonal matrix\n    is created (i.e. the \"direct sum\" of the matrices).\n\n    kwargs\n    ======\n\n    rows : rows of the resulting matrix; computed if\n           not given.\n\n    cols : columns of the resulting matrix; computed if\n           not given.\n\n    cls : class for the resulting matrix\n\n    unpack : bool which, when True (default), unpacks a single\n    sequence rather than interpreting it as a Matrix.\n\n    strict : bool which, when False (default), allows Matrices to\n    have variable-length rows.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> Matrix.diag(1, 2, 3)\n    Matrix([\n    [1, 0, 0],\n    [0, 2, 0],\n    [0, 0, 3]])\n\n    The current default is to unpack a single sequence. If this is\n    not desired, set `unpack=False` and it will be interpreted as\n    a matrix.\n\n    >>> Matrix.diag([1, 2, 3]) == Matrix.diag(1, 2, 3)\n    True\n\n    When more than one element is passed, each is interpreted as\n    something to put on the diagonal. Lists are converted to\n    matrices. Filling of the diagonal always continues from\n    the bottom right hand corner of the previous item: this\n    will create a block-diagonal matrix whether the matrices\n    are square or not.\n\n    >>> col = [1, 2, 3]\n    >>> row = [[4, 5]]\n    >>> Matrix.diag(col, row)\n    Matrix([\n    [1, 0, 0],\n    [2, 0, 0],\n    [3, 0, 0],\n    [0, 4, 5]])\n\n    When `unpack` is False, elements within a list need not all be\n    of the same length. Setting `strict` to True would raise a\n    ValueError for the following:\n\n    >>> Matrix.diag([[1, 2, 3], [4, 5], [6]], unpack=False)\n    Matrix([\n    [1, 2, 3],\n    [4, 5, 0],\n    [6, 0, 0]])\n\n    The type of the returned matrix can be set with the ``cls``\n    keyword.\n\n    >>> from sympy import ImmutableMatrix\n    >>> from sympy.utilities.misc import func_name\n    >>> func_name(Matrix.diag(1, cls=ImmutableMatrix))\n    'ImmutableDenseMatrix'\n\n    A zero dimension matrix can be used to position the start of\n    the filling at the start of an arbitrary row or column:\n\n    >>> from sympy import ones\n    >>> r2 = ones(0, 2)\n    >>> Matrix.diag(r2, 1, 2)\n    Matrix([\n    [0, 0, 1, 0],\n    [0, 0, 0, 2]])\n\n    See Also\n    ========\n    eye\n    diagonal\n    .dense.diag\n    .expressions.blockmatrix.BlockMatrix\n    .sparsetools.banded\n   \"\"\"\n    from sympy.matrices.matrixbase import MatrixBase\n    from sympy.matrices.dense import Matrix\n    from sympy.matrices import SparseMatrix\n\n    klass = cls if cls is not None else kls\n\n    args2: tuple[SExpr | list[SExpr] | MatrixBase, ...]\n\n    if unpack and len(args) == 1 and is_sequence(args[0]) and \\\n            not isinstance(args[0], MatrixBase):\n        args2 = args[0] # type: ignore\n    else:\n        args2 = args # type: ignore\n\n    # fill a default dict with the diagonal entries\n    diag_entries: dict[tuple[int, int], SExpr] = defaultdict(int)\n    rmax = cmax = 0  # keep track of the biggest index seen\n    for m in args2:\n        if isinstance(m, list):\n            if strict:\n                # if malformed, Matrix will raise an error\n                _ = Matrix(m)\n                r, c = _.shape\n                m2 = _.tolist()\n            else:\n                r, c, smat = SparseMatrix._handle_creation_inputs(m)\n                for (i, j), _ in smat.items():\n                    diag_entries[(i + rmax, j + cmax)] = _\n                m2 = []  # to skip process below\n        elif isinstance(m, MatrixBase):\n            # convert to list of lists\n            r, c = m.shape\n            m2 = m.tolist()\n        else:  # in this case, we're a single value\n            diag_entries[(rmax, cmax)] = m\n            rmax += 1\n            cmax += 1\n            continue\n        # process list of lists\n        for i, mi in enumerate(m2):\n            for j, _ in enumerate(mi):\n                diag_entries[(i + rmax, j + cmax)] = _\n        rmax += r\n        cmax += c\n    if rows is None:\n        rows, cols = cols, rows\n    if rows is None:\n        rows, cols = rmax, cmax\n    else:\n        cols = rows if cols is None else cols\n    if rows < rmax or cols < cmax:\n        raise ValueError(filldedent('''\n            The constructed matrix is {} x {} but a size of {} x {}\n            was specified.'''.format(rmax, cmax, rows, cols)))\n    return klass._eval_diag(rows, cols, diag_entries)",
    "sympy.sympy.matrices.matrixbase.is_square": "@property\ndef is_square(self) -> bool:\n    \"\"\"Checks if a matrix is square.\n\n    A matrix is square if the number of rows equals the number of columns.\n    The empty matrix is square by definition, since the number of rows and\n    the number of columns are both zero.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> a = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> c = Matrix([])\n    >>> a.is_square\n    False\n    >>> b.is_square\n    True\n    >>> c.is_square\n    True\n    \"\"\"\n    return self.rows == self.cols",
    "sympy.sympy.matrices.matrixbase.get_diag_blocks": "def get_diag_blocks(self) -> list[Self]:\n    \"\"\"Obtains the square sub-matrices on the main diagonal of a square matrix.\n\n    Useful for inverting symbolic matrices or solving systems of\n    linear equations which may be decoupled by having a block diagonal\n    structure.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x, y, z\n    >>> A = Matrix([[1, 3, 0, 0], [y, z*z, 0, 0], [0, 0, x, 0], [0, 0, 0, 0]])\n    >>> a1, a2, a3 = A.get_diag_blocks()\n    >>> a1\n    Matrix([\n    [1,    3],\n    [y, z**2]])\n    >>> a2\n    Matrix([[x]])\n    >>> a3\n    Matrix([[0]])\n\n    \"\"\"\n    return self._eval_get_diag_blocks()",
    "sympy.sympy.matrices.matrixbase.inverse_ADJ": "def inverse_ADJ(self, iszerofunc: Callable[[Expr], bool | None] = _iszero) -> Self:\n    return _inv_ADJ(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase.inverse_BLOCK": "def inverse_BLOCK(self, iszerofunc: Callable[[Expr], bool | None] = _iszero) -> Self:\n    return self._as_type(_inv_block(self, iszerofunc=iszerofunc))",
    "sympy.sympy.matrices.matrixbase.inverse_GE": "def inverse_GE(self, iszerofunc=_iszero) -> Self:\n    return _inv_GE(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase.inverse_LU": "def inverse_LU(self, iszerofunc=_iszero) -> Self:\n    return _inv_LU(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase.inverse_CH": "def inverse_CH(self, iszerofunc=_iszero) -> Self:\n    return _inv_CH(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase.inverse_LDL": "def inverse_LDL(self, iszerofunc=_iszero) -> Self:\n    return _inv_LDL(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase.inverse_QR": "def inverse_QR(self, iszerofunc=_iszero) -> Self:\n    return _inv_QR(self, iszerofunc=iszerofunc)",
    "sympy.sympy.matrices.matrixbase.inv": "def inv(self, method: str | None = None,\n            iszerofunc: Callable[[Expr], bool | None] = _iszero,\n            try_block_diag: bool = False\n        ) -> Self:\n    return _inv(self, method=method, iszerofunc=iszerofunc,\n            try_block_diag=try_block_diag)",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.sparse._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)"
}