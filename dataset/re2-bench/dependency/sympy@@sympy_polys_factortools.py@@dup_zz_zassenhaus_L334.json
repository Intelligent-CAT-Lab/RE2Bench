{
    "sympy.sympy.ntheory.primetest.isprime": "def isprime(n):\n    \"\"\"\n    Test if n is a prime number (True) or not (False). For n < 2^64 the\n    answer is definitive; larger n values have a small probability of actually\n    being pseudoprimes.\n\n    Negative numbers (e.g. -2) are not considered prime.\n\n    The first step is looking for trivial factors, which if found enables\n    a quick return.  Next, if the sieve is large enough, use bisection search\n    on the sieve.  For small numbers, a set of deterministic Miller-Rabin\n    tests are performed with bases that are known to have no counterexamples\n    in their range.  Finally if the number is larger than 2^64, a strong\n    BPSW test is performed.  While this is a probable prime test and we\n    believe counterexamples exist, there are no known counterexamples.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import isprime\n    >>> isprime(13)\n    True\n    >>> isprime(15)\n    False\n\n    Notes\n    =====\n\n    This routine is intended only for integer input, not numerical\n    expressions which may represent numbers. Floats are also\n    rejected as input because they represent numbers of limited\n    precision. While it is tempting to permit 7.0 to represent an\n    integer there are errors that may \"pass silently\" if this is\n    allowed:\n\n    >>> from sympy import Float, S\n    >>> int(1e3) == 1e3 == 10**3\n    True\n    >>> int(1e23) == 1e23\n    True\n    >>> int(1e23) == 10**23\n    False\n\n    >>> near_int = 1 + S(1)/10**19\n    >>> near_int == int(near_int)\n    False\n    >>> n = Float(near_int, 10)  # truncated by precision\n    >>> n % 1 == 0\n    True\n    >>> n = Float(near_int, 20)\n    >>> n % 1 == 0\n    False\n\n    See Also\n    ========\n\n    sympy.ntheory.generate.primerange : Generates all primes in a given range\n    sympy.functions.combinatorial.numbers.primepi : Return the number of primes less than or equal to n\n    sympy.ntheory.generate.prime : Return the nth prime\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Strong_pseudoprime\n    .. [2] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [3] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n    \"\"\"\n    n = as_int(n)\n\n    # Step 1, do quick composite testing via trial division.  The individual\n    # modulo tests benchmark faster than one or two primorial igcds for me.\n    # The point here is just to speedily handle small numbers and many\n    # composites.  Step 2 only requires that n <= 2 get handled here.\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or (n % 2) == 0 or (n % 3) == 0 or (n % 5) == 0:\n        return False\n    if n < 49:\n        return True\n    if (n %  7) == 0 or (n % 11) == 0 or (n % 13) == 0 or (n % 17) == 0 or \\\n       (n % 19) == 0 or (n % 23) == 0 or (n % 29) == 0 or (n % 31) == 0 or \\\n       (n % 37) == 0 or (n % 41) == 0 or (n % 43) == 0 or (n % 47) == 0:\n        return False\n    if n < 2809:\n        return True\n    if n < 65077:\n        # There are only five Euler pseudoprimes with a least prime factor greater than 47\n        return pow(2, n >> 1, n) in [1, n - 1] and n not in [8321, 31621, 42799, 49141, 49981]\n\n    # bisection search on the sieve if the sieve is large enough\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.ntheory.factor_ import factor_cache\n    if (ret := factor_cache.get(n)) is not None:\n        return ret == n\n\n    # If we have GMPY2, skip straight to step 3 and do a strong BPSW test.\n    # This should be a bit faster than our step 2, and for large values will\n    # be a lot faster than our step 3 (C+GMP vs. Python).\n    if _gmpy is not None:\n        return is_strong_bpsw_prp(n)\n\n\n    # Step 2: deterministic Miller-Rabin testing for numbers < 2^64.  See:\n    #    https://miller-rabin.appspot.com/\n    # for lists.  We have made sure the M-R routine will successfully handle\n    # bases larger than n, so we can use the minimal set.\n    # In September 2015 deterministic numbers were extended to over 2^81.\n    #    https://arxiv.org/pdf/1509.00864.pdf\n    #    https://oeis.org/A014233\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 4296595241:\n        # Michal Forisek and Jakub Jancina,\n        # Fast Primality Testing for Integers That Fit into a Machine Word\n        # https://ceur-ws.org/Vol-1326/020-Forisek.pdf\n        h = ((n >> 16) ^ n) * 0x45d9f3b\n        h = ((h >> 16) ^ h) * 0x45d9f3b\n        h = ((h >> 16) ^ h) & 255\n        return mr(n, [_MR_BASES_32[h]])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    if n < 318665857834031151167461:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37])\n    if n < 3317044064679887385961981:\n        return mr(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])\n\n    # We could do this instead at any point:\n    #if n < 18446744073709551616:\n    #   return mr(n, [2]) and is_extra_strong_lucas_prp(n)\n\n    # Here are tests that are safe for MR routines that don't understand\n    # large bases.\n    #if n < 9080191:\n    #    return mr(n, [31, 73])\n    #if n < 19471033:\n    #    return mr(n, [2, 299417])\n    #if n < 38010307:\n    #    return mr(n, [2, 9332593])\n    #if n < 316349281:\n    #    return mr(n, [11000544, 31481107])\n    #if n < 4759123141:\n    #    return mr(n, [2, 7, 61])\n    #if n < 105936894253:\n    #    return mr(n, [2, 1005905886, 1340600841])\n    #if n < 31858317218647:\n    #    return mr(n, [2, 642735, 553174392, 3046413974])\n    #if n < 3071837692357849:\n    #    return mr(n, [2, 75088, 642735, 203659041, 3613982119])\n    #if n < 18446744073709551616:\n    #    return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n\n    # Step 3: BPSW.\n    #\n    #  Time for isprime(10**2000 + 4561), no gmpy or gmpy2 installed\n    #     44.0s   old isprime using 46 bases\n    #      5.3s   strong BPSW + one random base\n    #      4.3s   extra strong BPSW + one random base\n    #      4.1s   strong BPSW\n    #      3.2s   extra strong BPSW\n\n    # Classic BPSW from page 1401 of the paper.  See alternate ideas below.\n    return is_strong_bpsw_prp(n)",
    "sympy.sympy.polys.densearith.dup_max_norm": "def dup_max_norm(f: dup[Eordered], K: Domain[Eordered]) -> Eordered:\n    \"\"\"\n    Returns maximum norm of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_max_norm(-x**2 + 2*x - 3)\n    3\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return max(dup_abs(f, K))",
    "sympy.sympy.polys.densearith.dup_l1_norm": "def dup_l1_norm(f: dup[Eabs], K: Domain[Eabs]) -> Eabs:\n    \"\"\"\n    Returns l1 norm of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_l1_norm(2*x**3 - 3*x**2 + 1)\n    6\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return K.sum(dup_abs(f, K))",
    "sympy.sympy.polys.densearith.dup_mul": "def dup_mul(f: dup[Er], g: dup[Er], K: Domain[Er]) -> dup[Er]:\n    \"\"\"\n    Multiply dense polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mul(x - 2, x + 2)\n    x**2 - 4\n\n    \"\"\"\n    if f == g:\n        return dup_sqr(f, K)\n\n    if not (f and g):\n        return []\n\n    df = dup_degree(f)\n    dg = dup_degree(g)\n\n    n = max(df, dg) + 1\n\n    if n < 100 or not K.is_Exact:\n        h: list[Er] = []\n\n        for i in range(0, df + dg + 1):\n            coeff = K.zero\n\n            for j in range(max(0, i - dg), min(df, i) + 1):\n                coeff += f[j]*g[i - j]\n\n            h.append(coeff)\n\n        return dup_strip(h, K)\n    else:\n        # Use Karatsuba's algorithm (divide and conquer), see e.g.:\n        # Joris van der Hoeven, Relax But Don't Be Too Lazy,\n        # J. Symbolic Computation, 11 (2002), section 3.1.1.\n        n2 = n//2\n\n        fl, gl = dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K)\n\n        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)\n        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)\n\n        lo, hi = dup_mul(fl, gl, K), dup_mul(fh, gh, K)\n\n        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)\n        mid = dup_sub(mid, dup_add(lo, hi, K), K)\n\n        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K),\n                       dup_lshift(hi, 2*n2, K), K)",
    "sympy.sympy.polys.densebasic.dup_LC": "def dup_LC(f: dup[Er], K: Domain[Er]) -> Er:\n    \"\"\"\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_LC\n\n    >>> dup_LC([1, 2, 3], ZZ)\n    1\n\n    \"\"\"\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    "sympy.sympy.polys.densebasic.dup_degree": "def dup_degree(f: dup[Er]) -> int:\n    \"\"\"\n    Return the leading degree of ``f`` in ``K[x]``.\n\n    Note that the degree of 0 is ``-1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_degree\n\n    >>> f = ZZ.map([1, 2, 0, 3])\n\n    >>> dup_degree(f)\n    3\n\n    .. versionchanged:: 1.15.0\n        The degree of a zero polynomial is now ``-1`` instead of\n        ``float('-inf')``.\n\n    \"\"\"\n    return len(f) - 1",
    "sympy.sympy.polys.densetools.dup_trunc": "def dup_trunc(f: dup[Eeuclid], p: Eeuclid, K: Domain[Eeuclid]) -> dup[Eeuclid]:\n    \"\"\"\n    Reduce a ``K[x]`` polynomial modulo a constant ``p`` in ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_trunc(2*x**3 + 3*x**2 + 5*x + 7, ZZ(3))\n    -x**3 - x + 1\n\n    \"\"\"\n    if K.is_ZZ:\n        g: list[Eeuclid] = []\n\n        for c in f:\n            c = c % p\n\n            if c > p // 2: # type: ignore\n                g.append(c - p)\n            else:\n                g.append(c)\n    elif K.is_FiniteField:\n        # XXX: python-flint's nmod does not support %\n        pi = int(p) # type: ignore\n        g = [ K(int(c) % pi) for c in f ] # type: ignore\n    else:\n        g = [ c % p for c in f ]\n\n    return dup_strip(g, K)",
    "sympy.sympy.polys.densetools.dup_primitive": "def dup_primitive(f: dup[Er], K: Domain[Er]) -> tuple[Er, dup[Er]]:\n    \"\"\"\n    Compute content and the primitive form of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    \"\"\"\n    if not f:\n        return K.zero, f\n\n    cont = dup_content(f, K)\n\n    if K.is_one(cont):\n        return cont, f\n    else:\n        return cont, dup_quo_ground(f, cont, K)",
    "sympy.sympy.polys.domains.domain.__call__": "def __call__(self, *args) -> Er:\n    \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n    return self.new(*args)",
    "sympy.sympy.polys.domains.domain.convert": "def convert(self,\n            element: Es | Expr | complex,\n            base: Domain[Es] | None = None\n            ) -> Er:\n    \"\"\"Convert ``element`` to ``self.dtype``. \"\"\"\n\n    if base is not None:\n        if _not_a_coeff(element):\n            raise CoercionFailed('%s is not in any domain' % element)\n        return self.convert_from(element, base) # type: ignore\n\n    if self.of_type(element):\n        return element\n\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ) # type: ignore\n\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n\n    if GROUND_TYPES != 'python':\n        if isinstance(element, ZZ.tp):\n            return self.convert_from(element, ZZ) # type: ignore\n        if isinstance(element, QQ.tp):\n            return self.convert_from(element, QQ) # type: ignore\n\n    if isinstance(element, float):\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if isinstance(element, complex):\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if type(element).__name__ == 'mpf':\n        RR = RealField()\n        return self.convert_from(RR(element), RR)\n\n    if type(element).__name__ == 'mpc':\n        CC = ComplexField()\n        return self.convert_from(CC(element), CC)\n\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n\n    # TODO: implement this in from_ methods\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC()) # type: ignore\n\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    else: # TODO: remove this branch\n        if not is_sequence(element):\n            try:\n                element = sympify(element, strict=True) # type: ignore\n                if isinstance(element, Basic):\n                    return self.from_sympy(element) # type: ignore\n            except (TypeError, ValueError):\n                pass\n\n    raise CoercionFailed(\"Cannot convert %s of type %s to %s\" % (element, type(element), self))",
    "sympy.sympy.polys.domains.integerring.sqrt": "def sqrt(self, a):\n    \"\"\"Compute square root of ``a``. \"\"\"\n    return sqrt(a)",
    "sympy.sympy.polys.factortools.dup_zz_hensel_lift": "def dup_zz_hensel_lift(p, f, f_list, l, K):\n    r\"\"\"\n    Multifactor Hensel lifting in `Z[x]`.\n\n    Given a prime `p`, polynomial `f` over `Z[x]` such that `lc(f)`\n    is a unit modulo `p`, monic pair-wise coprime polynomials `f_i`\n    over `Z[x]` satisfying::\n\n        f = lc(f) f_1 ... f_r (mod p)\n\n    and a positive integer `l`, returns a list of monic polynomials\n    `F_1,\\ F_2,\\ \\dots,\\ F_r` satisfying::\n\n       f = lc(f) F_1 ... F_r (mod p**l)\n\n       F_i = f_i (mod p), i = 1..r\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    \"\"\"\n    r = len(f_list)\n    lc = dup_LC(f, K)\n\n    if r == 1:\n        F = dup_mul_ground(f, K.gcdex(lc, p**l)[0], K)\n        return [ dup_trunc(F, p**l, K) ]\n\n    m = p\n    k = r // 2\n    d = int(_ceil(_log2(l)))\n\n    g = gf_from_int_poly([lc], p)\n\n    for f_i in f_list[:k]:\n        g = gf_mul(g, gf_from_int_poly(f_i, p), p, K)\n\n    h = gf_from_int_poly(f_list[k], p)\n\n    for f_i in f_list[k + 1:]:\n        h = gf_mul(h, gf_from_int_poly(f_i, p), p, K)\n\n    s, t, _ = gf_gcdex(g, h, p, K)\n\n    g = gf_to_int_poly(g, p)\n    h = gf_to_int_poly(h, p)\n    s = gf_to_int_poly(s, p)\n    t = gf_to_int_poly(t, p)\n\n    for _ in range(1, d + 1):\n        (g, h, s, t), m = dup_zz_hensel_step(m, f, g, h, s, t, K), m**2\n\n    return dup_zz_hensel_lift(p, g, f_list[:k], l, K) \\\n        + dup_zz_hensel_lift(p, h, f_list[k:], l, K)",
    "sympy.sympy.polys.factortools._test_pl": "def _test_pl(fc, q, pl):\n    if q > pl // 2:\n        q = q - pl\n    if not q:\n        return True\n    return fc % q == 0",
    "sympy.sympy.polys.factortools.<lambda>": "p, fsqf = min(a, key=lambda x: len(x[1]))\n\n",
    "sympy.sympy.polys.factortools.<listcomp>": "sorted_T = [i for i in sorted_T if i not in S]\n\n",
    "sympy.sympy.polys.galoistools.gf_sqf_p": "def gf_sqf_p(f: dup[MPZ], p: MPZ, K: Domain[MPZ]) -> bool:\n    \"\"\"\n    Return ``True`` if ``f`` is square-free in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sqf_p\n\n    >>> gf_sqf_p(ZZ.map([3, 2, 4]), 5, ZZ)\n    True\n    >>> gf_sqf_p(ZZ.map([2, 4, 4, 2, 2, 1, 4]), 5, ZZ)\n    False\n\n    \"\"\"\n    _, f = gf_monic(f, p, K)\n\n    if not f:\n        return True\n    else:\n        return gf_gcd(f, gf_diff(f, p, K), p, K) == [K.one]",
    "sympy.sympy.polys.galoistools.gf_factor_sqf": "def gf_factor_sqf(\n    f: dup[MPZ], p: MPZ, K: Domain[MPZ], method: str | None = None\n) -> tuple[MPZ, list[dup[MPZ]]]:\n    \"\"\"\n    Factor a square-free polynomial ``f`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_factor_sqf\n\n    >>> gf_factor_sqf(ZZ.map([3, 2, 4]), 5, ZZ)\n    (3, [[1, 1], [1, 3]])\n\n    \"\"\"\n    lc, f = gf_monic(f, p, K)\n\n    if gf_degree(f) < 1:\n        return lc, []\n\n    method = method or query(\"GF_FACTOR_METHOD\")\n\n    if method is not None:\n        factors = _factor_methods[method](f, p, K)\n    else:\n        factors = gf_zassenhaus(f, p, K)\n\n    return lc, factors",
    "sympy.sympy.polys.galoistools.gf_from_int_poly": "def gf_from_int_poly(f: dup[MPZ], p: MPZ) -> dup[MPZ]:\n    \"\"\"\n    Create a ``GF(p)[x]`` polynomial from ``Z[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_from_int_poly\n\n    >>> gf_from_int_poly([7, -2, 3], 5)\n    [2, 3, 3]\n\n    \"\"\"\n    return gf_trunc(f, p)",
    "sympy.sympy.utilities.iterables.subsets": "def subsets(seq, k=None, repetition=False):\n    r\"\"\"Generates all `k`-subsets (combinations) from an `n`-element set, ``seq``.\n\n    A `k`-subset of an `n`-element set is any subset of length exactly `k`. The\n    number of `k`-subsets of an `n`-element set is given by ``binomial(n, k)``,\n    whereas there are `2^n` subsets all together. If `k` is ``None`` then all\n    `2^n` subsets will be returned from shortest to longest.\n\n    Examples\n    ========\n\n    >>> from sympy import subsets\n\n    ``subsets(seq, k)`` will return the\n    `\\frac{n!}{k!(n - k)!}` `k`-subsets (combinations)\n    without repetition, i.e. once an item has been removed, it can no\n    longer be \"taken\":\n\n        >>> list(subsets([1, 2], 2))\n        [(1, 2)]\n        >>> list(subsets([1, 2]))\n        [(), (1,), (2,), (1, 2)]\n        >>> list(subsets([1, 2, 3], 2))\n        [(1, 2), (1, 3), (2, 3)]\n\n\n    ``subsets(seq, k, repetition=True)`` will return the\n    `\\frac{(n - 1 + k)!}{k!(n - 1)!}`\n    combinations *with* repetition:\n\n        >>> list(subsets([1, 2], 2, repetition=True))\n        [(1, 1), (1, 2), (2, 2)]\n\n    If you ask for more items than are in the set you get the empty set unless\n    you allow repetitions:\n\n        >>> list(subsets([0, 1], 3, repetition=False))\n        []\n        >>> list(subsets([0, 1], 3, repetition=True))\n        [(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1)]\n\n    \"\"\"\n    if k is None:\n        if not repetition:\n            return chain.from_iterable((combinations(seq, k)\n                                        for k in range(len(seq) + 1)))\n        else:\n            return chain.from_iterable((combinations_with_replacement(seq, k)\n                                        for k in range(len(seq) + 1)))\n    else:\n        if not repetition:\n            return combinations(seq, k)\n        else:\n            return combinations_with_replacement(seq, k)"
}