{
    "sympy.sympy.matrices.dense.as_mutable": "def as_mutable(self):\n    \"\"\"Returns a mutable version of this matrix\n\n    Examples\n    ========\n\n    >>> from sympy import ImmutableMatrix\n    >>> X = ImmutableMatrix([[1, 2], [3, 4]])\n    >>> Y = X.as_mutable()\n    >>> Y[1, 1] = 5 # Can set values in Y\n    >>> Y\n    Matrix([\n    [1, 2],\n    [3, 5]])\n    \"\"\"\n    return Matrix(self)",
    "sympy.sympy.matrices.immutable._new": "@classmethod\ndef _new(cls, *args, **kwargs):\n    rows, cols, smat = cls._handle_creation_inputs(*args, **kwargs)\n\n    rep = cls._smat_to_DomainMatrix(rows, cols, smat)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.immutable.rows": "@property\ndef rows(self):\n    return self._rows",
    "sympy.sympy.matrices.inverse.<genexpr>": "if any(iszerofunc(red[j, j]) for j in range(red.rows)):\n    raise NonInvertibleMatrixError(\"Matrix det == 0; not invertible.\")\n\n",
    "sympy.sympy.matrices.matrixbase.eye": "@classmethod\ndef eye(kls, rows: int, cols: int | None = None, *,\n             cls: type[Tmat] | None = None) -> Self | Tmat:\n    \"\"\"Returns an identity matrix.\n\n    Parameters\n    ==========\n\n    rows : rows of the matrix\n    cols : cols of the matrix (if None, cols=rows)\n\n    kwargs\n    ======\n    cls : class of the returned matrix\n    \"\"\"\n    if cols is None:\n        cols2 = rows\n    else:\n        cols2 = cols\n    if rows < 0 or cols2 < 0:\n        raise ValueError(\"Cannot create a {} x {} matrix. \"\n                         \"Both dimensions must be positive\".format(rows, cols2))\n    klass = cls if cls is not None else kls\n    rows, cols2 = as_int(rows), as_int(cols2)\n\n    return klass._eval_eye(rows, cols2)",
    "sympy.sympy.matrices.matrixbase.is_square": "@property\ndef is_square(self) -> bool:\n    \"\"\"Checks if a matrix is square.\n\n    A matrix is square if the number of rows equals the number of columns.\n    The empty matrix is square by definition, since the number of rows and\n    the number of columns are both zero.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> a = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> c = Matrix([])\n    >>> a.is_square\n    False\n    >>> b.is_square\n    True\n    >>> c.is_square\n    True\n    \"\"\"\n    return self.rows == self.cols",
    "sympy.sympy.matrices.matrixbase.rref": "def rref(self,\n         iszerofunc: Callable[[Expr], bool | None] = _iszero,\n         simplify: bool | Callable[[Expr], Expr] = False,\n         *,\n         pivots: bool = True,\n         normalize_last: bool = True\n     ) -> Self | tuple[Self, tuple[int]]:\n    return _rref(self, iszerofunc=iszerofunc, simplify=simplify,\n        pivots=pivots, normalize_last=normalize_last)",
    "sympy.sympy.matrices.matrixbase.hstack": "@classmethod\ndef hstack(cls, *args: Self) -> Self:\n    \"\"\"Return a matrix formed by joining args horizontally (i.e.\n    by repeated application of row_join).\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, eye\n    >>> Matrix.hstack(eye(2), 2*eye(2))\n    Matrix([\n    [1, 0, 2, 0],\n    [0, 1, 0, 2]])\n    \"\"\"\n    if len(args) == 0:\n        return cls._new()\n\n    kls = type(args[0])\n    return reduce(kls.row_join, args)",
    "sympy.sympy.matrices.repmatrix.__getitem__": "def __getitem__(self, key: tuple[int | Slice, int | Slice] | int | slice, /\n                ) -> Expr | Self | list[Expr]:\n    return _getitem_RepMatrix(self, key)",
    "sympy.sympy.matrices.repmatrix._new": "@classmethod\ndef _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        # The input was rows, cols, [list].\n        # It should be used directly without creating a copy.\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list) # create a shallow copy\n\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n\n    return cls._fromrep(rep)",
    "sympy.sympy.matrices.sparse.as_mutable": "def as_mutable(self):\n    \"\"\"Returns a mutable version of this matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import ImmutableMatrix\n    >>> X = ImmutableMatrix([[1, 2], [3, 4]])\n    >>> Y = X.as_mutable()\n    >>> Y[1, 1] = 5 # Can set values in Y\n    >>> Y\n    Matrix([\n    [1, 2],\n    [3, 5]])\n    \"\"\"\n    return MutableSparseMatrix(self)"
}