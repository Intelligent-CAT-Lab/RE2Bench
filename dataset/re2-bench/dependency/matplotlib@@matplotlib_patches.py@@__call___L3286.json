{
    "matplotlib.lib.matplotlib.patches.<listcomp>": "path_list = [Path(p.vertices * [1, aspect_ratio], p.codes)\n             for p in path_mutated]\n",
    "matplotlib.lib.matplotlib.patches.transmute": "def transmute(self, path, mutation_size, linewidth):\n    # docstring inherited\n    x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n    arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n    b_plus, b_minus = make_wedged_bezier2(\n                            arrow_path,\n                            self.tail_width * mutation_size / 2.,\n                            wm=self.shrink_factor)\n\n    patch_path = [(Path.MOVETO, b_plus[0]),\n                  (Path.CURVE3, b_plus[1]),\n                  (Path.CURVE3, b_plus[2]),\n                  (Path.LINETO, b_minus[2]),\n                  (Path.CURVE3, b_minus[1]),\n                  (Path.CURVE3, b_minus[0]),\n                  (Path.CLOSEPOLY, b_minus[0]),\n                  ]\n    path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n    return path, True",
    "matplotlib.lib.matplotlib.path.vertices": "@property\ndef vertices(self):\n    \"\"\"The vertices of the `Path` as an (N, 2) array.\"\"\"\n    return self._vertices",
    "matplotlib.lib.matplotlib.path.codes": "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1D array.\n\n    Each code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n    `CLOSEPOLY`.  For codes that correspond to more than one vertex\n    (`CURVE3` and `CURVE4`), that code will be repeated so that the length\n    of `vertices` and `codes` is always the same.\n    \"\"\"\n    return self._codes",
    "matplotlib.lib.matplotlib.path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : (N, 2) array-like\n        The path vertices, as an array, masked array or sequence of pairs.\n        Masked values, if any, will be converted to NaNs, which are then\n        handled correctly by the Agg PathIterator and other consumers of\n        path data, such as :meth:`iter_segments`.\n    codes : array-like or None, optional\n        N-length array of integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        `CLOSEPOLY`).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n\n    if codes is not None and len(vertices):\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'. \"\n                             f\"Your vertices have shape {vertices.shape} \"\n                             f\"but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             f\"to 'MOVETO' ({self.MOVETO}).  \"\n                             f\"Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False"
}