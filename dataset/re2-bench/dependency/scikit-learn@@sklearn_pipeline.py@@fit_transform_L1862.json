{
    "scikit-learn.sklearn.pipeline._parallel_func": "def _parallel_func(self, X, y, func, routed_params):\n    \"\"\"Runs func in parallel on X and y\"\"\"\n    self.transformer_list = list(self.transformer_list)\n    self._validate_transformers()\n    self._validate_transformer_weights()\n    transformers = list(self._iter())\n\n    return Parallel(n_jobs=self.n_jobs)(\n        delayed(func)(\n            transformer,\n            X,\n            y,\n            weight,\n            message_clsname=\"FeatureUnion\",\n            message=self._log_message(name, idx, len(transformers)),\n            params=routed_params[name],\n        )\n        for idx, (name, transformer, weight) in enumerate(transformers, 1)\n    )",
    "scikit-learn.sklearn.pipeline._hstack": "def _hstack(self, Xs):\n    # Check if Xs dimensions are valid\n    for X, (name, _) in zip(Xs, self.transformer_list):\n        if hasattr(X, \"shape\") and len(X.shape) != 2:\n            raise ValueError(\n                f\"Transformer '{name}' returned an array or dataframe with \"\n                f\"{len(X.shape)} dimensions, but expected 2 dimensions \"\n                \"(n_samples, n_features).\"\n            )\n\n    adapter = _get_container_adapter(\"transform\", self)\n    if adapter and all(adapter.is_supported_container(X) for X in Xs):\n        return adapter.hstack(Xs)\n\n    if any(sparse.issparse(f) for f in Xs):\n        return sparse.hstack(Xs).tocsr()\n\n    return np.hstack(Xs)",
    "scikit-learn.sklearn.pipeline._update_transformer_list": "def _update_transformer_list(self, transformers):\n    transformers = iter(transformers)\n    self.transformer_list[:] = [\n        (name, old if old == \"drop\" else next(transformers))\n        for name, old in self.transformer_list\n    ]",
    "scikit-learn.sklearn.utils._bunch.__init__": "def __init__(self, **kwargs):\n    super().__init__(kwargs)\n\n    # Map from deprecated key to warning message\n    self.__dict__[\"_deprecated_key_to_warnings\"] = {}",
    "scikit-learn.sklearn.utils._bunch.__getitem__": "def __getitem__(self, key):\n    if key in self.__dict__.get(\"_deprecated_key_to_warnings\", {}):\n        warnings.warn(\n            self._deprecated_key_to_warnings[key],\n            FutureWarning,\n        )\n    return super().__getitem__(key)",
    "scikit-learn.sklearn.utils._bunch.__setattr__": "def __setattr__(self, key, value):\n    self[key] = value",
    "scikit-learn.sklearn.utils._metadata_requests.process_routing": "def process_routing(_obj, _method, /, **kwargs):\n    \"\"\"Validate and route metadata.\n\n    This function is used inside a :term:`router`'s method, e.g. :term:`fit`,\n    to validate the metadata and handle the routing.\n\n    Assuming this signature of a router's fit method:\n    ``fit(self, X, y, sample_weight=None, **fit_params)``,\n    a call to this function would be:\n    ``process_routing(self, \"fit\", sample_weight=sample_weight, **fit_params)``.\n\n    Note that if routing is not enabled and ``kwargs`` is empty, then it\n    returns an empty routing where ``process_routing(...).ANYTHING.ANY_METHOD``\n    is always an empty dictionary.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    _obj : object\n        An object implementing ``get_metadata_routing``. Typically a\n        :term:`meta-estimator`.\n\n    _method : str\n        The name of the router's method in which this function is called.\n\n    **kwargs : dict\n        Metadata to be routed.\n\n    Returns\n    -------\n    routed_params : Bunch\n        A :class:`~utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        A :class:`~sklearn.utils.Bunch` of the form ``{\"object_name\": {\"method_name\":\n        {metadata: value}}}`` which can be used to pass the required metadata to\n        corresponding methods or corresponding child objects. The object names\n        are those defined in `obj.get_metadata_routing()`.\n    \"\"\"\n    if not kwargs:\n        # If routing is not enabled and kwargs are empty, then we don't have to\n        # try doing any routing, we can simply return a structure which returns\n        # an empty dict on routed_params.ANYTHING.ANY_METHOD.\n        class EmptyRequest:\n            def get(self, name, default=None):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getitem__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n            def __getattr__(self, name):\n                return Bunch(**{method: dict() for method in METHODS})\n\n        return EmptyRequest()\n\n    if not (hasattr(_obj, \"get_metadata_routing\") or isinstance(_obj, MetadataRouter)):\n        raise AttributeError(\n            f\"The given object ({_routing_repr(_obj)}) needs to either\"\n            \" implement the routing method `get_metadata_routing` or be a\"\n            \" `MetadataRouter` instance.\"\n        )\n    if _method not in METHODS:\n        raise TypeError(\n            f\"Can only route and process input on these methods: {METHODS}, \"\n            f\"while the passed method is: {_method}.\"\n        )\n\n    request_routing = get_routing_for_object(_obj)\n    request_routing.validate_metadata(params=kwargs, method=_method)\n    routed_params = request_routing.route_params(params=kwargs, caller=_method)\n\n    return routed_params",
    "scikit-learn.sklearn.utils._metadata_requests._routing_enabled": "def _routing_enabled():\n    \"\"\"Return whether metadata routing is enabled.\n\n    .. versionadded:: 1.3\n\n    Returns\n    -------\n    enabled : bool\n        Whether metadata routing is enabled. If the config is not set, it\n        defaults to False.\n    \"\"\"\n    return get_config().get(\"enable_metadata_routing\", False)"
}