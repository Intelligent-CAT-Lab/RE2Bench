You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. You only need to predict input variable values, and print input between [INPUT] and [/INPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT]. 
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import functools
import re
import sys
import types
from pathlib import Path
from django.conf import settings
from django.http import HttpResponse, HttpResponseNotFound
from django.template import Context, Engine, TemplateDoesNotExist
from django.template.defaultfilters import pprint
from django.urls import Resolver404, resolve
from django.utils import timezone
from django.utils.datastructures import MultiValueDict
from django.utils.encoding import force_str
from django.utils.module_loading import import_string
from django.utils.version import get_docs_version
from django import get_version
DEBUG_ENGINE = Engine(debug=True, libraries={'i18n': 'django.templatetags.i18n'})
HIDDEN_SETTINGS = re.compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.IGNORECASE)
CLEANSED_SUBSTITUTE = '********************'
CURRENT_DIR = Path(__file__).parent

def default_urlconf(request):
    with Path(CURRENT_DIR, 'templates', 'default_urlconf.html').open(encoding='utf-8') as fh:
        t = DEBUG_ENGINE.from_string(fh.read())
    c = Context({'version': get_docs_version()})
    return HttpResponse(t.render(c), content_type='text/html')
[/PYTHON]

Functions called during the execution:
[PYTHON]
.django.template.engine.Engine.from_string

def from_string(self, template_code):
    return Template(template_code, engine=self)

.django.template.base.Template.__init__

def __init__(self, template_string, origin=None, name=None, engine=None):
    if engine is None:
        from .engine import Engine
        engine = Engine.get_default()
    if origin is None:
        origin = Origin(UNKNOWN_SOURCE)
    self.name = name
    self.origin = origin
    self.engine = engine
    self.source = str(template_string)
    self.nodelist = self.compile_nodelist()

.django.template.base.Origin.__init__

def __init__(self, name, template_name=None, loader=None):
    self.name = name
    self.template_name = template_name
    self.loader = loader

.django.template.base.Template.compile_nodelist

def compile_nodelist(self):
    if self.engine.debug:
        lexer = DebugLexer(self.source)
    else:
        lexer = Lexer(self.source)
    tokens = lexer.tokenize()
    parser = Parser(tokens, self.engine.template_libraries, self.engine.template_builtins, self.origin)
    try:
        return parser.parse()
    except Exception as e:
        if self.engine.debug:
            e.template_debug = self.get_exception_info(e, e.token)
        raise

.django.template.base.Lexer.__init__

def __init__(self, template_string):
    self.template_string = template_string
    self.verbatim = False

.django.template.base.DebugLexer.tokenize

def tokenize(self):
    lineno = 1
    result = []
    upto = 0
    for match in tag_re.finditer(self.template_string):
        start, end = match.span()
        if start > upto:
            token_string = self.template_string[upto:start]
            result.append(self.create_token(token_string, (upto, start), lineno, in_tag=False))
            lineno += token_string.count('\n')
            upto = start
        token_string = self.template_string[start:end]
        result.append(self.create_token(token_string, (start, end), lineno, in_tag=True))
        lineno += token_string.count('\n')
        upto = end
    last_bit = self.template_string[upto:]
    if last_bit:
        result.append(self.create_token(last_bit, (upto, upto + len(last_bit)), lineno, in_tag=False))
    return result

.django.template.base.Lexer.create_token

def create_token(self, token_string, position, lineno, in_tag):
    if in_tag and token_string.startswith(BLOCK_TAG_START):
        block_content = token_string[2:-2].strip()
        if self.verbatim and block_content == self.verbatim:
            self.verbatim = False
    if in_tag and (not self.verbatim):
        if token_string.startswith(VARIABLE_TAG_START):
            return Token(TokenType.VAR, token_string[2:-2].strip(), position, lineno)
        elif token_string.startswith(BLOCK_TAG_START):
            if block_content[:9] in ('verbatim', 'verbatim '):
                self.verbatim = 'end%s' % block_content
            return Token(TokenType.BLOCK, block_content, position, lineno)
        elif token_string.startswith(COMMENT_TAG_START):
            content = ''
            if token_string.find(TRANSLATOR_COMMENT_MARK):
                content = token_string[2:-2].strip()
            return Token(TokenType.COMMENT, content, position, lineno)
    else:
        return Token(TokenType.TEXT, token_string, position, lineno)

.django.template.base.Token.__init__

def __init__(self, token_type, contents, position=None, lineno=None):
    self.token_type, self.contents = (token_type, contents)
    self.lineno = lineno
    self.position = position

.django.template.base.Parser.__init__

def __init__(self, tokens, libraries=None, builtins=None, origin=None):
    self.tokens = tokens
    self.tags = {}
    self.filters = {}
    self.command_stack = []
    if libraries is None:
        libraries = {}
    if builtins is None:
        builtins = []
    self.libraries = libraries
    for builtin in builtins:
        self.add_library(builtin)
    self.origin = origin

.django.template.base.Parser.add_library

def add_library(self, lib):
    self.tags.update(lib.tags)
    self.filters.update(lib.filters)

.django.template.base.Parser.parse

def parse(self, parse_until=None):
    if parse_until is None:
        parse_until = []
    nodelist = NodeList()
    while self.tokens:
        token = self.next_token()
        if token.token_type.value == 0:
            self.extend_nodelist(nodelist, TextNode(token.contents), token)
        elif token.token_type.value == 1:
            if not token.contents:
                raise self.error(token, 'Empty variable tag on line %d' % token.lineno)
            try:
                filter_expression = self.compile_filter(token.contents)
            except TemplateSyntaxError as e:
                raise self.error(token, e)
            var_node = VariableNode(filter_expression)
            self.extend_nodelist(nodelist, var_node, token)
        elif token.token_type.value == 2:
            try:
                command = token.contents.split()[0]
            except IndexError:
                raise self.error(token, 'Empty block tag on line %d' % token.lineno)
            if command in parse_until:
                self.prepend_token(token)
                return nodelist
            self.command_stack.append((command, token))
            try:
                compile_func = self.tags[command]
            except KeyError:
                self.invalid_block_tag(token, command, parse_until)
            try:
                compiled_result = compile_func(self, token)
            except Exception as e:
                raise self.error(token, e)
            self.extend_nodelist(nodelist, compiled_result, token)
            self.command_stack.pop()
    if parse_until:
        self.unclosed_block_tag(parse_until)
    return nodelist

.django.template.base.Parser.next_token

def next_token(self):
    return self.tokens.pop(0)

.django.template.defaulttags.load

def load(parser, token):
    bits = token.contents.split()
    if len(bits) >= 4 and bits[-2] == 'from':
        name = bits[-1]
        lib = find_library(parser, name)
        subset = load_from_library(lib, name, bits[1:-2])
        parser.add_library(subset)
    else:
        for name in bits[1:]:
            lib = find_library(parser, name)
            parser.add_library(lib)
    return LoadNode()

.django.template.defaulttags.find_library

def find_library(parser, name):
    try:
        return parser.libraries[name]
    except KeyError:
        raise TemplateSyntaxError("'%s' is not a registered tag library. Must be one of:\n%s" % (name, '\n'.join(sorted(parser.libraries))))

.django.template.base.Parser.extend_nodelist

def extend_nodelist(self, nodelist, node, token):
    if node.must_be_first and nodelist.contains_nontext:
        raise self.error(token, '%r must be the first tag in the template.' % node)
    if isinstance(nodelist, NodeList) and (not isinstance(node, TextNode)):
        nodelist.contains_nontext = True
    node.token = token
    node.origin = self.origin
    nodelist.append(node)

.django.template.base.TextNode.__init__

def __init__(self, s):
    self.s = s

.django.templatetags.i18n.do_get_current_language_bidi

def do_get_current_language_bidi(parser, token):
    args = token.contents.split()
    if len(args) != 3 or args[1] != 'as':
        raise TemplateSyntaxError("'get_current_language_bidi' requires 'as variable' (got %r)" % args)
    return GetCurrentLanguageBidiNode(args[2])

.django.templatetags.i18n.GetCurrentLanguageBidiNode.__init__

def __init__(self, variable):
    self.variable = variable

.django.template.defaulttags.do_if

def do_if(parser, token):
    bits = token.split_contents()[1:]
    condition = TemplateIfParser(parser, bits).parse()
    nodelist = parser.parse(('elif', 'else', 'endif'))
    conditions_nodelists = [(condition, nodelist)]
    token = parser.next_token()
    while token.contents.startswith('elif'):
        bits = token.split_contents()[1:]
        condition = TemplateIfParser(parser, bits).parse()
        nodelist = parser.parse(('elif', 'else', 'endif'))
        conditions_nodelists.append((condition, nodelist))
        token = parser.next_token()
    if token.contents == 'else':
        nodelist = parser.parse(('endif',))
        conditions_nodelists.append((None, nodelist))
        token = parser.next_token()
    if token.contents != 'endif':
        raise TemplateSyntaxError('Malformed template tag at line {0}: "{1}"'.format(token.lineno, token.contents))
    return IfNode(conditions_nodelists)

.django.template.base.Token.split_contents

def split_contents(self):
    split = []
    bits = smart_split(self.contents)
    for bit in bits:
        if bit.startswith(('_("', "_('")):
            sentinel = bit[2] + ')'
            trans_bit = [bit]
            while not bit.endswith(sentinel):
                bit = next(bits)
                trans_bit.append(bit)
            bit = ' '.join(trans_bit)
        split.append(bit)
    return split

.django.utils.text.smart_split

def smart_split(text):
    for bit in smart_split_re.finditer(str(text)):
        yield bit.group(0)

.django.template.defaulttags.TemplateIfParser.__init__

def __init__(self, parser, *args, **kwargs):
    self.template_parser = parser
    super().__init__(*args, **kwargs)

.django.template.smartif.IfParser.__init__

def __init__(self, tokens):
    num_tokens = len(tokens)
    mapped_tokens = []
    i = 0
    while i < num_tokens:
        token = tokens[i]
        if token == 'is' and i + 1 < num_tokens and (tokens[i + 1] == 'not'):
            token = 'is not'
            i += 1
        elif token == 'not' and i + 1 < num_tokens and (tokens[i + 1] == 'in'):
            token = 'not in'
            i += 1
        mapped_tokens.append(self.translate_token(token))
        i += 1
    self.tokens = mapped_tokens
    self.pos = 0
    self.current_token = self.next_token()

.django.template.smartif.IfParser.translate_token

def translate_token(self, token):
    try:
        op = OPERATORS[token]
    except (KeyError, TypeError):
        return self.create_var(token)
    else:
        return op()

.django.template.defaulttags.TemplateIfParser.create_var

def create_var(self, value):
    return TemplateLiteral(self.template_parser.compile_filter(value), value)

.django.template.base.Parser.compile_filter

def compile_filter(self, token):
    return FilterExpression(token, self)

.django.template.base.FilterExpression.__init__

def __init__(self, token, parser):
    self.token = token
    matches = filter_re.finditer(token)
    var_obj = None
    filters = []
    upto = 0
    for match in matches:
        start = match.start()
        if upto != start:
            raise TemplateSyntaxError('Could not parse some characters: %s|%s|%s' % (token[:upto], token[upto:start], token[start:]))
        if var_obj is None:
            var, constant = match.group('var', 'constant')
            if constant:
                try:
                    var_obj = Variable(constant).resolve({})
                except VariableDoesNotExist:
                    var_obj = None
            elif var is None:
                raise TemplateSyntaxError('Could not find variable at start of %s.' % token)
            else:
                var_obj = Variable(var)
        else:
            filter_name = match.group('filter_name')
            args = []
            constant_arg, var_arg = match.group('constant_arg', 'var_arg')
            if constant_arg:
                args.append((False, Variable(constant_arg).resolve({})))
            elif var_arg:
                args.append((True, Variable(var_arg)))
            filter_func = parser.find_filter(filter_name)
            self.args_check(filter_name, filter_func, args)
            filters.append((filter_func, args))
        upto = match.end()
    if upto != len(token):
        raise TemplateSyntaxError("Could not parse the remainder: '%s' from '%s'" % (token[upto:], token))
    self.filters = filters
    self.var = var_obj

.django.template.base.Variable.__init__

def __init__(self, var):
    self.var = var
    self.literal = None
    self.lookups = None
    self.translate = False
    self.message_context = None
    if not isinstance(var, str):
        raise TypeError('Variable must be a string or number, got %s' % type(var))
    try:
        if '.' in var or 'e' in var.lower():
            self.literal = float(var)
            if var.endswith('.'):
                raise ValueError
        else:
            self.literal = int(var)
    except ValueError:
        if var.startswith('_(') and var.endswith(')'):
            self.translate = True
            var = var[2:-1]
        try:
            self.literal = mark_safe(unescape_string_literal(var))
        except ValueError:
            if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':
                raise TemplateSyntaxError("Variables and attributes may not begin with underscores: '%s'" % var)
            self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))

.django.utils.functional.wrapper

def wrapper(*args, **kwargs):
    if any((isinstance(arg, Promise) for arg in itertools.chain(args, kwargs.values()))):
        return lazy_func(*args, **kwargs)
    return func(*args, **kwargs)

.django.utils.text.unescape_string_literal

def unescape_string_literal(s):
    if s[0] not in '"\'' or s[-1] != s[0]:
        raise ValueError('Not a string literal: %r' % s)
    quote = s[0]
    return s[1:-1].replace('\\%s' % quote, quote).replace('\\\\', '\\')

.django.template.defaulttags.TemplateLiteral.__init__

def __init__(self, value, text):
    self.value = value
    self.text = text

.django.template.smartif.IfParser.next_token

def next_token(self):
    if self.pos >= len(self.tokens):
        return EndToken
    else:
        retval = self.tokens[self.pos]
        self.pos += 1
        return retval

.django.template.smartif.IfParser.parse

def parse(self):
    retval = self.expression()
    if self.current_token is not EndToken:
        raise self.error_class("Unused '%s' at end of if expression." % self.current_token.display())
    return retval

.django.template.smartif.IfParser.expression

def expression(self, rbp=0):
    t = self.current_token
    self.current_token = self.next_token()
    left = t.nud(self)
    while rbp < self.current_token.lbp:
        t = self.current_token
        self.current_token = self.next_token()
        left = t.led(left, self)
    return left

.django.template.smartif.Literal.nud

def nud(self, parser):
    return self

.django.template.base.Parser.prepend_token

def prepend_token(self, token):
    self.tokens.insert(0, token)

.django.template.defaulttags.IfNode.__init__

def __init__(self, conditions_nodelists):
    self.conditions_nodelists = conditions_nodelists

.django.templatetags.i18n.do_translate

def do_translate(parser, token):
    bits = token.split_contents()
    if len(bits) < 2:
        raise TemplateSyntaxError("'%s' takes at least one argument" % bits[0])
    message_string = parser.compile_filter(bits[1])
    remaining = bits[2:]
    noop = False
    asvar = None
    message_context = None
    seen = set()
    invalid_context = {'as', 'noop'}
    while remaining:
        option = remaining.pop(0)
        if option in seen:
            raise TemplateSyntaxError("The '%s' option was specified more than once." % option)
        elif option == 'noop':
            noop = True
        elif option == 'context':
            try:
                value = remaining.pop(0)
            except IndexError:
                raise TemplateSyntaxError("No argument provided to the '%s' tag for the context option." % bits[0])
            if value in invalid_context:
                raise TemplateSyntaxError("Invalid argument '%s' provided to the '%s' tag for the context option" % (value, bits[0]))
            message_context = parser.compile_filter(value)
        elif option == 'as':
            try:
                value = remaining.pop(0)
            except IndexError:
                raise TemplateSyntaxError("No argument provided to the '%s' tag for the as option." % bits[0])
            asvar = value
        else:
            raise TemplateSyntaxError('Unknown argument for \'%s\' tag: \'%s\'. The only options available are \'noop\', \'context\' "xxx", and \'as VAR\'.' % (bits[0], option))
        seen.add(option)
    return TranslateNode(message_string, noop, asvar, message_context)

.django.utils.safestring.mark_safe

def mark_safe(s):
    if hasattr(s, '__html__'):
        return s
    if callable(s):
        return _safety_decorator(mark_safe, s)
    return SafeString(s)

.django.template.base.Variable.resolve

def resolve(self, context):
    if self.lookups is not None:
        value = self._resolve_lookup(context)
    else:
        value = self.literal
    if self.translate:
        is_safe = isinstance(value, SafeData)
        msgid = value.replace('%', '%%')
        msgid = mark_safe(msgid) if is_safe else msgid
        if self.message_context:
            return pgettext_lazy(self.message_context, msgid)
        else:
            return gettext_lazy(msgid)
    return value

.django.templatetags.i18n.TranslateNode.__init__

def __init__(self, filter_expression, noop, asvar=None, message_context=None):
    self.noop = noop
    self.asvar = asvar
    self.message_context = message_context
    self.filter_expression = filter_expression
    if isinstance(self.filter_expression.var, str):
        self.filter_expression.var = Variable("'%s'" % self.filter_expression.var)

.django.utils.safestring.SafeString.__str__

def __str__(self):
    return self

.django.templatetags.i18n.do_block_translate

def do_block_translate(parser, token):
    bits = token.split_contents()
    options = {}
    remaining_bits = bits[1:]
    asvar = None
    while remaining_bits:
        option = remaining_bits.pop(0)
        if option in options:
            raise TemplateSyntaxError('The %r option was specified more than once.' % option)
        if option == 'with':
            value = token_kwargs(remaining_bits, parser, support_legacy=True)
            if not value:
                raise TemplateSyntaxError('"with" in %r tag needs at least one keyword argument.' % bits[0])
        elif option == 'count':
            value = token_kwargs(remaining_bits, parser, support_legacy=True)
            if len(value) != 1:
                raise TemplateSyntaxError('"count" in %r tag expected exactly one keyword argument.' % bits[0])
        elif option == 'context':
            try:
                value = remaining_bits.pop(0)
                value = parser.compile_filter(value)
            except Exception:
                raise TemplateSyntaxError('"context" in %r tag expected exactly one argument.' % bits[0])
        elif option == 'trimmed':
            value = True
        elif option == 'asvar':
            try:
                value = remaining_bits.pop(0)
            except IndexError:
                raise TemplateSyntaxError("No argument provided to the '%s' tag for the asvar option." % bits[0])
            asvar = value
        else:
            raise TemplateSyntaxError('Unknown argument for %r tag: %r.' % (bits[0], option))
        options[option] = value
    if 'count' in options:
        countervar, counter = next(iter(options['count'].items()))
    else:
        countervar, counter = (None, None)
    if 'context' in options:
        message_context = options['context']
    else:
        message_context = None
    extra_context = options.get('with', {})
    trimmed = options.get('trimmed', False)
    singular = []
    plural = []
    while parser.tokens:
        token = parser.next_token()
        if token.token_type in (TokenType.VAR, TokenType.TEXT):
            singular.append(token)
        else:
            break
    if countervar and counter:
        if token.contents.strip() != 'plural':
            raise TemplateSyntaxError("'blocktrans' doesn't allow other block tags inside it")
        while parser.tokens:
            token = parser.next_token()
            if token.token_type in (TokenType.VAR, TokenType.TEXT):
                plural.append(token)
            else:
                break
    if token.contents.strip() != 'endblocktrans':
        raise TemplateSyntaxError("'blocktrans' doesn't allow other block tags (seen %r) inside it" % token.contents)
    return BlockTranslateNode(extra_context, singular, plural, countervar, counter, message_context, trimmed=trimmed, asvar=asvar)

.django.templatetags.i18n.BlockTranslateNode.__init__

def __init__(self, extra_context, singular, plural=None, countervar=None, counter=None, message_context=None, trimmed=False, asvar=None):
    self.extra_context = extra_context
    self.singular = singular
    self.plural = plural
    self.countervar = countervar
    self.counter = counter
    self.message_context = message_context
    self.trimmed = trimmed
    self.asvar = asvar

.django.template.base.VariableNode.__init__

def __init__(self, filter_expression):
    self.filter_expression = filter_expression

.django.utils.version.get_docs_version

def get_docs_version(version=None):
    version = get_complete_version(version)
    if version[3] != 'final':
        return 'dev'
    else:
        return '%d.%d' % version[:2]

.django.utils.version.get_complete_version

def get_complete_version(version=None):
    if version is None:
        from django import VERSION as version
    else:
        assert len(version) == 5
        assert version[3] in ('alpha', 'beta', 'rc', 'final')
    return version

.django.template.context.Context.__init__

def __init__(self, dict_=None, autoescape=True, use_l10n=None, use_tz=None):
    self.autoescape = autoescape
    self.use_l10n = use_l10n
    self.use_tz = use_tz
    self.template_name = 'unknown'
    self.render_context = RenderContext()
    self.template = None
    super().__init__(dict_)

.django.template.context.BaseContext.__init__

def __init__(self, dict_=None):
    self._reset_dicts(dict_)

.django.template.context.BaseContext._reset_dicts

def _reset_dicts(self, value=None):
    builtins = {'True': True, 'False': False, 'None': None}
    self.dicts = [builtins]
    if value is not None:
        self.dicts.append(value)

.django.dispatch.dispatcher.Signal._remove_receiver

def _remove_receiver(self, receiver=None):
    self._dead_receivers = True


[/PYTHON]
What will be the input of `default_urlconf`, given the following input:
[OUTPUT]
```
{
    "_headers": {
        "content-type": [
            "Content-Type",
            "text/html"
        ]
    },
    "_closable_objects": null,
    "_handler_class": null,
    "cookies": {},
    "closed": false,
    "_reason_phrase": null,
    "_charset": null,
    "_container": null
}
```
[/OUTPUT]

[THOUGHT]
