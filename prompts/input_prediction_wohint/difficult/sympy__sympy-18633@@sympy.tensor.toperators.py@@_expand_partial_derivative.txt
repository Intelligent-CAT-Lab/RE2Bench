You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. You only need to predict input variable values, and print input between [INPUT] and [/INPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT]. 
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from sympy import Symbol, Number, sympify
from sympy import MutableDenseNDimArray, S
from sympy.tensor.tensor import Tensor, TensExpr, TensAdd, TensMul, TensorIndex
from .array import derive_by_array, tensorcontraction

class PartialDerivative(TensExpr):

    def __new__(cls, expr, *variables):
        if isinstance(expr, PartialDerivative):
            variables = expr.variables + variables
            expr = expr.expr
        args, indices, free, dum = cls._contract_indices_for_derivative(S(expr), variables)
        obj = TensExpr.__new__(cls, *args)
        obj._indices = indices
        obj._free = free
        obj._dum = dum
        return obj

    @classmethod
    def _contract_indices_for_derivative(cls, expr, variables):
        variables_opposite_valence = []
        for i in variables:
            if isinstance(i, Tensor):
                i_free_indices = i.get_free_indices()
                variables_opposite_valence.append(i.xreplace({k: -k for k in i_free_indices}))
            elif isinstance(i, Symbol):
                variables_opposite_valence.append(i)
        args, indices, free, dum = TensMul._tensMul_contract_indices([expr] + variables_opposite_valence, replace_indices=True)
        for i in range(1, len(args)):
            args_i = args[i]
            if isinstance(args_i, Tensor):
                i_indices = args[i].get_free_indices()
                args[i] = args[i].xreplace({k: -k for k in i_indices})
        return (args, indices, free, dum)

    def _expand_partial_derivative(self):
        args, indices, free, dum = self._contract_indices_for_derivative(self.expr, self.variables)
        obj = self.func(*args)
        obj._indices = indices
        obj._free = free
        obj._dum = dum
        result = obj
        if not args[0].free_symbols:
            return S.Zero
        elif isinstance(obj.expr, TensAdd):
            result = obj.expr.func(*[self.func(a, *obj.variables)._expand_partial_derivative() for a in result.expr.args])
        elif isinstance(obj.expr, TensMul):
            if len(obj.variables) == 1:
                terms = []
                mulargs = list(obj.expr.args)
                for ind in range(len(mulargs)):
                    if not isinstance(sympify(mulargs[ind]), Number):
                        d = self.func(mulargs[ind], *obj.variables)._expand_partial_derivative()
                        terms.append(TensMul(*mulargs[:ind] + [d] + mulargs[ind + 1:]))
                result = TensAdd.fromiter(terms)
            else:
                result = obj.expr
                for v in obj.variables:
                    result = self.func(result, v)._expand_partial_derivative()
        return result

    @property
    def expr(self):
        return self.args[0]

    @property
    def variables(self):
        return self.args[1:]
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.tensor.tensor.TensMul._tensMul_contract_indices

def _tensMul_contract_indices(args, replace_indices=True):
    replacements = [{} for _ in args]
    args_indices = [get_indices(arg) for arg in args]
    indices, free, free_names, dummy_data = TensMul._indices_to_free_dum(args_indices)
    cdt = defaultdict(int)

    def dummy_name_gen(tensor_index_type):
        nd = str(cdt[tensor_index_type])
        cdt[tensor_index_type] += 1
        return tensor_index_type.dummy_name + '_' + nd
    if replace_indices:
        for old_index, pos1cov, pos1contra, pos2cov, pos2contra in dummy_data:
            index_type = old_index.tensor_index_type
            while True:
                dummy_name = dummy_name_gen(index_type)
                if dummy_name not in free_names:
                    break
            dummy = TensorIndex(dummy_name, index_type, True)
            replacements[pos1cov][old_index] = dummy
            replacements[pos1contra][-old_index] = -dummy
            indices[pos2cov] = dummy
            indices[pos2contra] = -dummy
        args = [arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg, repl in zip(args, replacements)]
    dum = TensMul._dummy_data_to_dum(dummy_data)
    return (args, indices, free, dum)

.sympy.tensor.tensor.get_indices

def get_indices(t):
    if not isinstance(t, TensExpr):
        return ()
    return t.get_indices()

.sympy.tensor.tensor.Tensor.get_indices

def get_indices(self):
    return list(self.args[1])

.sympy.core.containers.Tuple.__len__

def __len__(self):
    return len(self.args)

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.tensor.tensor.TensMul._indices_to_free_dum

def _indices_to_free_dum(args_indices):
    free2pos1 = {}
    free2pos2 = {}
    dummy_data = []
    indices = []
    pos2 = 0
    for pos1, arg_indices in enumerate(args_indices):
        for index_pos, index in enumerate(arg_indices):
            if not isinstance(index, TensorIndex):
                raise TypeError('expected TensorIndex')
            if -index in free2pos1:
                other_pos1 = free2pos1.pop(-index)
                other_pos2 = free2pos2.pop(-index)
                if index.is_up:
                    dummy_data.append((index, pos1, other_pos1, pos2, other_pos2))
                else:
                    dummy_data.append((-index, other_pos1, pos1, other_pos2, pos2))
                indices.append(index)
            elif index in free2pos1:
                raise ValueError('Repeated index: %s' % index)
            else:
                free2pos1[index] = pos1
                free2pos2[index] = pos2
                indices.append(index)
            pos2 += 1
    free = [(i, p) for i, p in free2pos2.items()]
    free_names = [i.name for i in free2pos2.keys()]
    dummy_data.sort(key=lambda x: x[3])
    return (indices, free, free_names, dummy_data)

.sympy.tensor.tensor.TensorIndex.__neg__

def __neg__(self):
    t1 = TensorIndex(self.name, self.tensor_index_type, not self.is_up)
    return t1

.sympy.tensor.tensor.TensorIndex.name

def name(self):
    return self.args[0].name

.sympy.tensor.tensor.TensorIndex.tensor_index_type

def tensor_index_type(self):
    return self.args[1]

.sympy.tensor.tensor.TensorIndex.is_up

def is_up(self):
    return self.args[2]

.sympy.logic.boolalg.BooleanTrue.__nonzero__

def __nonzero__(self):
    return True

.sympy.tensor.tensor.TensorIndex.__new__

def __new__(cls, name, tensor_index_type, is_up=True):
    if isinstance(name, str):
        name_symbol = Symbol(name)
    elif isinstance(name, Symbol):
        name_symbol = name
    elif name is True:
        name = '_i{0}'.format(len(tensor_index_type._autogenerated))
        name_symbol = Symbol(name)
        tensor_index_type._autogenerated.append(name_symbol)
    else:
        raise ValueError('invalid name')
    is_up = sympify(is_up)
    return Basic.__new__(cls, name_symbol, tensor_index_type, is_up)

.sympy.core.symbol.Symbol.__new__

def __new__(cls, name, **assumptions):
    cls._sanitize(assumptions, cls)
    return Symbol.__xnew_cached_(cls, name, **assumptions)

.sympy.core.symbol.Symbol._sanitize

def _sanitize(assumptions, obj=None):
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    if is_commutative is None:
        whose = '%s ' % obj.__name__ if obj else ''
        raise ValueError('%scommutativity must be True or False.' % whose)
    for key in list(assumptions.keys()):
        v = assumptions[key]
        if v is None:
            assumptions.pop(key)
            continue
        assumptions[key] = bool(v)

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.symbol.Symbol.__new_stage2__

def __new_stage2__(cls, name, **assumptions):
    if not isinstance(name, str):
        raise TypeError('name should be a string, not %s' % repr(type(name)))
    obj = Expr.__new__(cls)
    obj.name = name
    tmp_asm_copy = assumptions.copy()
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    assumptions['commutative'] = is_commutative
    obj._assumptions = StdFactKB(assumptions)
    obj._assumptions._generator = tmp_asm_copy
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    super(StdFactKB, self).__init__(_assume_rules)
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.facts.FactKB.__init__

def __init__(self, rules):
    self.rules = rules

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    is_sympy = getattr(a, '__sympy__', None)
    if is_sympy is not None:
        return a
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    cls = getattr(a, '__class__', None)
    if cls is None:
        cls = type(a)
    conv = converter.get(cls, None)
    if conv is not None:
        return conv(a)
    for superclass in getmro(cls):
        try:
            return converter[superclass](a)
        except KeyError:
            continue
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
    _sympy_ = getattr(a, '_sympy_', None)
    if _sympy_ is not None:
        try:
            return a._sympy_()
        except AttributeError:
            pass
    if not strict:
        flat = getattr(a, 'flat', None)
        if flat is not None:
            shape = getattr(a, 'shape', None)
            if shape is not None:
                from ..tensor.array import Array
                return Array(a.flat, a.shape)
    if not isinstance(a, str):
        for coerce in (float, int):
            try:
                coerced = coerce(a)
            except (TypeError, ValueError):
                continue
            try:
                return sympify(coerced)
            except SympifyError:
                continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
        from .compatibility import unicode
        a = unicode(a)
    except Exception as exc:
        raise SympifyError(a, exc)
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.basic.Basic.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.basic.Basic._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.expr.Expr.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))

.sympy.logic.boolalg.BooleanFalse.__hash__

def __hash__(self):
    return hash(False)

.sympy.tensor.tensor.Tensor._replace_indices

def _replace_indices(self, repl):
    return self.xreplace(repl)

.sympy.core.basic.Basic.xreplace

def xreplace(self, rule):
    value, _ = self._xreplace(rule)
    return value

.sympy.core.basic.Basic._xreplace

def _xreplace(self, rule):
    if self in rule:
        return (rule[self], True)
    elif rule:
        args = []
        changed = False
        for a in self.args:
            _xreplace = getattr(a, '_xreplace', None)
            if _xreplace is not None:
                a_xr = _xreplace(rule)
                args.append(a_xr[0])
                changed |= a_xr[1]
            else:
                args.append(a)
        args = tuple(args)
        if changed:
            return (self.func(*args), True)
    return (self, False)

.sympy.tensor.tensor.TensMul._dummy_data_to_dum

def _dummy_data_to_dum(dummy_data):
    return [(p2a, p2b) for i, p1a, p1b, p2a, p2b in dummy_data]

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.basic.Basic.free_symbols

def free_symbols(self):
    return set().union(*[a.free_symbols for a in self.args])

.sympy.core.symbol.Symbol.free_symbols

def free_symbols(self):
    return {self}

.sympy.core.expr.Expr.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
        if not isinstance(other, Expr):
            return False
    except (SympifyError, SyntaxError):
        return False
    if not (self.is_Number and other.is_Number) and type(self) != type(other):
        return False
    a, b = (self._hashable_content(), other._hashable_content())
    if a != b:
        return False
    for a, b in zip(a, b):
        if not isinstance(a, Expr):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.tensor.tensor.Tensor.get_free_indices

def get_free_indices(self):
    return self._index_structure.get_free_indices()

.sympy.tensor.tensor._IndexStructure.get_free_indices

def get_free_indices(self):
    free = sorted(self.free, key=lambda x: x[1])
    return [i[0] for i in free]

.sympy.core.expr.Expr._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.containers.Tuple.__hash__

def __hash__(self):
    return hash(self.args)

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.tensor.tensor.Tensor.__new__

def __new__(cls, tensor_head, indices, **kw_args):
    is_canon_bp = kw_args.pop('is_canon_bp', False)
    indices = cls._parse_indices(tensor_head, indices)
    obj = Basic.__new__(cls, tensor_head, Tuple(*indices), **kw_args)
    obj._index_structure = _IndexStructure.from_indices(*indices)
    obj._free = obj._index_structure.free[:]
    obj._dum = obj._index_structure.dum[:]
    obj._ext_rank = obj._index_structure._ext_rank
    obj._coeff = S.One
    obj._nocoeff = obj
    obj._component = tensor_head
    obj._components = [tensor_head]
    if tensor_head.rank != len(indices):
        raise ValueError('wrong number of indices')
    obj.is_canon_bp = is_canon_bp
    obj._index_map = Tensor._build_index_map(indices, obj._index_structure)
    return obj

.sympy.tensor.tensor.Tensor._parse_indices

def _parse_indices(tensor_head, indices):
    if not isinstance(indices, (tuple, list, Tuple)):
        raise TypeError('indices should be an array, got %s' % type(indices))
    indices = list(indices)
    for i, index in enumerate(indices):
        if isinstance(index, Symbol):
            indices[i] = TensorIndex(index, tensor_head.index_types[i], True)
        elif isinstance(index, Mul):
            c, e = index.as_coeff_Mul()
            if c == -1 and isinstance(e, Symbol):
                indices[i] = TensorIndex(e, tensor_head.index_types[i], False)
            else:
                raise ValueError('index not understood: %s' % index)
        elif not isinstance(index, TensorIndex):
            raise TypeError('wrong type for index: %s is %s' % (index, type(index)))
    return indices

.sympy.tensor.tensor._IndexStructure.from_indices

def from_indices(*indices):
    free, dum = _IndexStructure._free_dum_from_indices(*indices)
    index_types = [i.tensor_index_type for i in indices]
    indices = _IndexStructure._replace_dummy_names(indices, free, dum)
    return _IndexStructure(free, dum, index_types, indices)

.sympy.tensor.tensor._IndexStructure._free_dum_from_indices

def _free_dum_from_indices(*indices):
    n = len(indices)
    if n == 1:
        return ([(indices[0], 0)], [])
    free = [True] * len(indices)
    index_dict = {}
    dum = []
    for i, index in enumerate(indices):
        name = index.name
        typ = index.tensor_index_type
        contr = index.is_up
        if (name, typ) in index_dict:
            is_contr, pos = index_dict[name, typ]
            if is_contr:
                if contr:
                    raise ValueError('two equal contravariant indices in slots %d and %d' % (pos, i))
                else:
                    free[pos] = False
                    free[i] = False
            elif contr:
                free[pos] = False
                free[i] = False
            else:
                raise ValueError('two equal covariant indices in slots %d and %d' % (pos, i))
            if contr:
                dum.append((i, pos))
            else:
                dum.append((pos, i))
        else:
            index_dict[name, typ] = (index.is_up, i)
    free = [(index, i) for i, index in enumerate(indices) if free[i]]
    free.sort()
    return (free, dum)

.sympy.tensor.tensor._IndexStructure._replace_dummy_names

def _replace_dummy_names(indices, free, dum):
    dum.sort(key=lambda x: x[0])
    new_indices = [ind for ind in indices]
    assert len(indices) == len(free) + 2 * len(dum)
    generate_dummy_name = _IndexStructure._get_generator_for_dummy_indices(free)
    for ipos1, ipos2 in dum:
        typ1 = new_indices[ipos1].tensor_index_type
        indname = generate_dummy_name(typ1)
        new_indices[ipos1] = TensorIndex(indname, typ1, True)
        new_indices[ipos2] = TensorIndex(indname, typ1, False)
    return new_indices

.sympy.tensor.tensor._IndexStructure._get_generator_for_dummy_indices

def _get_generator_for_dummy_indices(free):
    cdt = defaultdict(int)
    for indx, ipos in free:
        if indx.name.split('_')[0] == indx.tensor_index_type.dummy_name:
            cdt[indx.tensor_index_type] = max(cdt[indx.tensor_index_type], int(indx.name.split('_')[1]) + 1)

    def dummy_name_gen(tensor_index_type):
        nd = str(cdt[tensor_index_type])
        cdt[tensor_index_type] += 1
        return tensor_index_type.dummy_name + '_' + nd
    return dummy_name_gen

.sympy.tensor.tensor.TensorIndexType.dummy_name

def dummy_name(self):
    return self.args[1].name

.sympy.tensor.tensor._IndexStructure.__init__

def __init__(self, free, dum, index_types, indices, canon_bp=False):
    self.free = free
    self.dum = dum
    self.index_types = index_types
    self.indices = indices
    self._ext_rank = len(self.free) + 2 * len(self.dum)
    self.dum.sort(key=lambda x: x[0])

.sympy.tensor.tensor.TensorHead.rank

def rank(self):
    return len(self.index_types)

.sympy.tensor.tensor.TensorHead.index_types

def index_types(self):
    return list(self.args[1])

.sympy.tensor.tensor.Tensor._build_index_map

def _build_index_map(indices, index_structure):
    index_map = {}
    for idx in indices:
        index_map[idx] = (indices.index(idx),)
    return index_map

.sympy.logic.boolalg.BooleanFalse.__nonzero__

def __nonzero__(self):
    return False

.sympy.logic.boolalg.BooleanTrue.__hash__

def __hash__(self):
    return hash(True)

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    if self is other:
        return True
    tself = type(self)
    tother = type(other)
    if tself is not tother:
        try:
            other = _sympify(other)
            tother = type(other)
        except SympifyError:
            return NotImplemented
        if type(tself).__ne__ is not type.__ne__:
            if tself != tother:
                return False
        elif tself is not tother:
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.tensor.tensor.TensorIndex.__lt__

def __lt__(self, other):
    return (self.tensor_index_type, self.name) < (other.tensor_index_type, other.name)


[/PYTHON]
What will be the input of `_expand_partial_derivative`, given the following input:
[OUTPUT]
```
{
    "_indices": null,
    "_free": null,
    "_dum": null
}
```
[/OUTPUT]

[THOUGHT]
