You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. You only need to predict input variable values, and print input between [INPUT] and [/INPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT]. 
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
from sympy.core.add import Add
from sympy.core.compatibility import as_int, is_sequence, range
from sympy.core.exprtools import factor_terms
from sympy.core.function import _mexpand
from sympy.core.mul import Mul
from sympy.core.numbers import Rational
from sympy.core.numbers import igcdex, ilcm, igcd
from sympy.core.power import integer_nthroot, isqrt
from sympy.core.relational import Eq
from sympy.core.singleton import S
from sympy.core.symbol import Symbol, symbols
from sympy.functions.elementary.complexes import sign
from sympy.functions.elementary.integers import floor
from sympy.functions.elementary.miscellaneous import sqrt
from sympy.matrices.dense import MutableDenseMatrix as Matrix
from sympy.ntheory.factor_ import divisors, factorint, multiplicity, perfect_power
from sympy.ntheory.generate import nextprime
from sympy.ntheory.primetest import is_square, isprime
from sympy.ntheory.residue_ntheory import sqrt_mod
from sympy.polys.polyerrors import GeneratorsNeeded
from sympy.polys.polytools import Poly, factor_list
from sympy.simplify.simplify import signsimp
from sympy.solvers.solvers import check_assumptions
from sympy.solvers.solveset import solveset_real
from sympy.utilities import default_sort_key, numbered_symbols
from sympy.utilities.misc import filldedent
from sympy.utilities.iterables import subsets, permute_signs, signed_permutations
from sympy.ntheory.continued_fraction import continued_fraction_periodic
from sympy.simplify.simplify import clear_coefficients
from sympy.utilities.iterables import ordered_partitions
__all__ = ['diophantine', 'classify_diop']
diop_known = {'binary_quadratic', 'cubic_thue', 'general_pythagorean', 'general_sum_of_even_powers', 'general_sum_of_squares', 'homogeneous_general_quadratic', 'homogeneous_ternary_quadratic', 'homogeneous_ternary_quadratic_normal', 'inhomogeneous_general_quadratic', 'inhomogeneous_ternary_quadratic', 'linear', 'univariate'}
classify_diop.func_doc = "\n    Helper routine used by diop_solve() to find information about ``eq``.\n\n    Returns a tuple containing the type of the diophantine equation\n    along with the variables (free symbols) and their coefficients.\n    Variables are returned as a list and coefficients are returned\n    as a dict with the key being the respective term and the constant\n    term is keyed to 1. The type is one of the following:\n\n    * %s\n\n    Usage\n    =====\n\n    ``classify_diop(eq)``: Return variables, coefficients and type of the\n    ``eq``.\n\n    Details\n    =======\n\n    ``eq`` should be an expression which is assumed to be zero.\n    ``_dict`` is for internal use: when True (default) a dict is returned,\n    otherwise a defaultdict which supplies 0 for missing keys is returned.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine import classify_diop\n    >>> from sympy.abc import x, y, z, w, t\n    >>> classify_diop(4*x + 6*y - 4)\n    ([x, y], {1: -4, x: 4, y: 6}, 'linear')\n    >>> classify_diop(x + 3*y -4*z + 5)\n    ([x, y, z], {1: 5, x: 1, y: 3, z: -4}, 'linear')\n    >>> classify_diop(x**2 + y**2 - x*y + x + 5)\n    ([x, y], {1: 5, x: 1, x**2: 1, y**2: 1, x*y: -1}, 'binary_quadratic')\n    " % '\n    * '.join(sorted(diop_known))
sum_of_powers = power_representation

def diophantine(eq, param=symbols('t', integer=True), syms=None, permute=False):
    from sympy.utilities.iterables import subsets, permute_signs, signed_permutations
    if isinstance(eq, Eq):
        eq = eq.lhs - eq.rhs
    try:
        var = list(eq.expand(force=True).free_symbols)
        var.sort(key=default_sort_key)
        if syms:
            if not is_sequence(syms):
                raise TypeError('syms should be given as a sequence, e.g. a list')
            syms = [i for i in syms if i in var]
            if syms != var:
                dict_sym_index = dict(zip(syms, range(len(syms))))
                return {tuple([t[dict_sym_index[i]] for i in var]) for t in diophantine(eq, param, permute=permute)}
        n, d = eq.as_numer_denom()
        if n.is_number:
            return set()
        if not d.is_number:
            dsol = diophantine(d)
            good = diophantine(n) - dsol
            return {s for s in good if _mexpand(d.subs(zip(var, s)))}
        else:
            eq = n
        eq = factor_terms(eq)
        assert not eq.is_number
        eq = eq.as_independent(*var, as_Add=False)[1]
        p = Poly(eq)
        assert not any((g.is_number for g in p.gens))
        eq = p.as_expr()
        assert eq.is_polynomial()
    except (GeneratorsNeeded, AssertionError, AttributeError):
        raise TypeError(filldedent('\n    Equation should be a polynomial with Rational coefficients.'))
    do_permute_signs = False
    do_permute_signs_var = False
    permute_few_signs = False
    try:
        v, c, t = classify_diop(eq)
        if permute:
            len_var = len(v)
            permute_signs_for = ['general_sum_of_squares', 'general_sum_of_even_powers']
            permute_signs_check = ['homogeneous_ternary_quadratic', 'homogeneous_ternary_quadratic_normal', 'binary_quadratic']
            if t in permute_signs_for:
                do_permute_signs_var = True
            elif t in permute_signs_check:
                if len_var == 3:
                    var_mul = list(subsets(v, 2))
                    xy_coeff = True
                    x_coeff = True
                    var1_mul_var2 = map(lambda a: a[0] * a[1], var_mul)
                    for v1_mul_v2 in var1_mul_var2:
                        try:
                            coeff = c[v1_mul_v2]
                        except KeyError:
                            coeff = 0
                        xy_coeff = bool(xy_coeff) and bool(coeff)
                    var_mul = list(subsets(v, 1))
                    for v1 in var_mul:
                        try:
                            coeff = c[v1[0]]
                        except KeyError:
                            coeff = 0
                        x_coeff = bool(x_coeff) and bool(coeff)
                    if not any([xy_coeff, x_coeff]):
                        do_permute_signs = True
                    elif not x_coeff:
                        permute_few_signs = True
                elif len_var == 2:
                    var_mul = list(subsets(v, 2))
                    xy_coeff = True
                    x_coeff = True
                    var1_mul_var2 = map(lambda x: x[0] * x[1], var_mul)
                    for v1_mul_v2 in var1_mul_var2:
                        try:
                            coeff = c[v1_mul_v2]
                        except KeyError:
                            coeff = 0
                        xy_coeff = bool(xy_coeff) and bool(coeff)
                    var_mul = list(subsets(v, 1))
                    for v1 in var_mul:
                        try:
                            coeff = c[v1[0]]
                        except KeyError:
                            coeff = 0
                        x_coeff = bool(x_coeff) and bool(coeff)
                    if not any([xy_coeff, x_coeff]):
                        do_permute_signs = True
                    elif not x_coeff:
                        permute_few_signs = True
        if t == 'general_sum_of_squares':
            terms = [(eq, 1)]
        else:
            raise TypeError
    except (TypeError, NotImplementedError):
        terms = factor_list(eq)[1]
    sols = set([])
    for term in terms:
        base, _ = term
        var_t, _, eq_type = classify_diop(base, _dict=False)
        _, base = signsimp(base, evaluate=False).as_coeff_Mul()
        solution = diop_solve(base, param)
        if eq_type in ['linear', 'homogeneous_ternary_quadratic', 'homogeneous_ternary_quadratic_normal', 'general_pythagorean']:
            sols.add(merge_solution(var, var_t, solution))
        elif eq_type in ['binary_quadratic', 'general_sum_of_squares', 'general_sum_of_even_powers', 'univariate']:
            for sol in solution:
                sols.add(merge_solution(var, var_t, sol))
        else:
            raise NotImplementedError('unhandled type: %s' % eq_type)
    if () in sols:
        sols.remove(())
    null = tuple([0] * len(var))
    if not sols and eq.subs(zip(var, null)).is_zero:
        sols.add(null)
    final_soln = set([])
    for sol in sols:
        if all((_is_int(s) for s in sol)):
            if do_permute_signs:
                permuted_sign = set(permute_signs(sol))
                final_soln.update(permuted_sign)
            elif permute_few_signs:
                lst = list(permute_signs(sol))
                lst = list(filter(lambda x: x[0] * x[1] == sol[1] * sol[0], lst))
                permuted_sign = set(lst)
                final_soln.update(permuted_sign)
            elif do_permute_signs_var:
                permuted_sign_var = set(signed_permutations(sol))
                final_soln.update(permuted_sign_var)
            else:
                final_soln.add(sol)
        else:
            final_soln.add(sol)
    return final_soln
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.expr.Expr.expand

def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):
    from sympy.simplify.radsimp import fraction
    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)
    expr = self
    if hints.pop('frac', False):
        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]
        return n / d
    elif hints.pop('denom', False):
        n, d = fraction(self)
        return n / d.expand(deep=deep, modulus=modulus, **hints)
    elif hints.pop('numer', False):
        n, d = fraction(self)
        return n.expand(deep=deep, modulus=modulus, **hints) / d

    def _expand_hint_key(hint):
        if hint == 'mul':
            return 'mulz'
        return hint
    for hint in sorted(hints.keys(), key=_expand_hint_key):
        use_hint = hints[hint]
        if use_hint:
            hint = '_eval_expand_' + hint
            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
    while True:
        was = expr
        if hints.get('multinomial', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)
        if hints.get('mul', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)
        if hints.get('log', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)
        if expr == was:
            break
    if modulus is not None:
        modulus = sympify(modulus)
        if not modulus.is_Integer or modulus <= 0:
            raise ValueError('modulus must be a positive integer, got %s' % modulus)
        terms = []
        for term in Add.make_args(expr):
            coeff, tail = term.as_coeff_Mul(rational=True)
            coeff %= modulus
            if coeff:
                terms.append(coeff * tail)
        expr = Add(*terms)
    return expr

.sympy.core.expr.Expr._expand_hint_key

def _expand_hint_key(hint):
    if hint == 'mul':
        return 'mulz'
    return hint

.sympy.core.expr.Expr._expand_hint

def _expand_hint(expr, hint, deep=True, **hints):
    hit = False
    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):
        sargs = []
        for arg in expr.args:
            arg, arghit = Expr._expand_hint(arg, hint, **hints)
            hit |= arghit
            sargs.append(arg)
        if hit:
            expr = expr.func(*sargs)
    if hasattr(expr, hint):
        newexpr = getattr(expr, hint)(**hints)
        if newexpr != expr:
            return (newexpr, True)
    return (expr, hit)

.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.core.mul.Mul._eval_expand_mul

def _eval_expand_mul(self, **hints):
    from sympy import fraction
    expr = self
    n, d = fraction(expr)
    if d.is_Mul:
        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]
        expr = n / d
        if not expr.is_Mul:
            return expr
    plain, sums, rewrite = ([], [], False)
    for factor in expr.args:
        if factor.is_Add:
            sums.append(factor)
            rewrite = True
        elif factor.is_commutative:
            plain.append(factor)
        else:
            sums.append(Basic(factor))
    if not rewrite:
        return expr
    else:
        plain = self.func(*plain)
        if sums:
            deep = hints.get('deep', False)
            terms = self.func._expandsums(sums)
            args = []
            for term in terms:
                t = self.func(plain, term)
                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:
                    t = t._eval_expand_mul()
                args.append(t)
            return Add(*args)
        else:
            return plain

.sympy.simplify.radsimp.fraction

def fraction(expr, exact=False):
    expr = sympify(expr)
    numer, denom = ([], [])
    for term in Mul.make_args(expr):
        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):
            b, ex = term.as_base_exp()
            if ex.is_negative:
                if ex is S.NegativeOne:
                    denom.append(b)
                elif exact:
                    if ex.is_constant():
                        denom.append(Pow(b, -ex))
                    else:
                        numer.append(term)
                else:
                    denom.append(Pow(b, -ex))
            elif ex.is_positive:
                numer.append(term)
            elif not exact and ex.is_Mul:
                n, d = term.as_numer_denom()
                numer.append(n)
                denom.append(d)
            else:
                numer.append(term)
        elif term.is_Rational:
            n, d = term.as_numer_denom()
            numer.append(n)
            denom.append(d)
        else:
            numer.append(term)
    if exact:
        return (Mul(*numer, evaluate=False), Mul(*denom, evaluate=False))
    else:
        return (Mul(*numer), Mul(*denom))

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    is_sympy = getattr(a, '__sympy__', None)
    if is_sympy is not None:
        return a
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    cls = getattr(a, '__class__', None)
    if cls is None:
        cls = type(a)
    conv = converter.get(cls, None)
    if conv is not None:
        return conv(a)
    for superclass in getmro(cls):
        try:
            return converter[superclass](a)
        except KeyError:
            continue
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if evaluate is None:
        if global_evaluate[0] is False:
            evaluate = global_evaluate[0]
        else:
            evaluate = True
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
    _sympy_ = getattr(a, '_sympy_', None)
    if _sympy_ is not None:
        try:
            return a._sympy_()
        except AttributeError:
            pass
    if not strict:
        flat = getattr(a, 'flat', None)
        if flat is not None:
            shape = getattr(a, 'shape', None)
            if shape is not None:
                from ..tensor.array import Array
                return Array(a.flat, a.shape)
    if not isinstance(a, string_types):
        for coerce in (float, int):
            try:
                coerced = coerce(a)
            except (TypeError, ValueError):
                continue
            except AttributeError:
                continue
            try:
                return sympify(coerced)
            except SympifyError:
                continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
        from .compatibility import unicode
        a = unicode(a)
    except Exception as exc:
        raise SympifyError(a, exc)
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.operations.AssocOp.make_args

def make_args(cls, expr):
    if isinstance(expr, cls):
        return expr.args
    else:
        return (sympify(expr),)

.sympy.core.numbers.Integer.as_numer_denom

def as_numer_denom(self):
    return (self, S.One)

.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, **options):
    from sympy import Order
    args = list(map(_sympify, args))
    args = [a for a in args if a is not cls.identity]
    evaluate = options.get('evaluate')
    if evaluate is None:
        evaluate = global_evaluate[0]
    if not evaluate:
        obj = cls._from_args(args)
        obj = cls._exec_constructor_postprocessors(obj)
        return obj
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        return Order(obj, *order_symbols)
    return obj

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
            seq = [a, b]
        assert not a is S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    rv = ([cls(a * r, b, evaluate=False)], [], None)
                elif global_distribute[0] and b.is_commutative:
                    r, b = b.as_coeff_Add()
                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
                    _addsort(bargs)
                    ar = a * r
                    if ar:
                        bargs.insert(0, ar)
                    bargs = [Add._from_args(bargs)]
                    rv = (bargs, [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number or isinstance(coeff, AccumBounds):
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            if coeff is S.ComplexInfinity:
                return ([S.ComplexInfinity], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):
                    return ([S.NaN], [], None)
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff is S.Infinity or coeff is S.NegativeInfinity:

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_extended_positive:
                    continue
                if t.is_extended_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
    elif coeff.is_zero:
        if any((isinstance(c, MatrixExpr) for c in nc_part)):
            return ([coeff], nc_part, order_symbols)
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, string_types):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)
    if ival == 1:
        return S.One
    if ival == -1:
        return S.NegativeOne
    if ival == 0:
        return S.Zero
    obj = Expr.__new__(cls)
    obj.p = ival
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.expr.Expr.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.numbers.Rational.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (self, S.One)

.sympy.core.expr.Expr.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.numbers.Zero.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    super(StdFactKB, self).__init__(_assume_rules)
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.facts.FactKB.__init__

def __init__(self, rules):
    self.rules = rules

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    assumptions._tell(fact, None)
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.numbers.Rational._eval_is_zero

def _eval_is_zero(self):
    return self.p == 0

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.basic.Basic.compare

def compare(self, other):
    if self is other:
        return 0
    n1 = self.__class__
    n2 = other.__class__
    c = (n1 > n2) - (n1 < n2)
    if c:
        return c
    st = self._hashable_content()
    ot = other._hashable_content()
    c = (len(st) > len(ot)) - (len(st) < len(ot))
    if c:
        return c
    for l, r in zip(st, ot):
        l = Basic(*l) if isinstance(l, frozenset) else l
        r = Basic(*r) if isinstance(r, frozenset) else r
        if isinstance(l, Basic):
            c = l.compare(r)
        else:
            c = (l > r) - (l < r)
        if c:
            return c
    return 0

.sympy.core.core.BasicMeta.__gt__

def __gt__(cls, other):
    if cls.__cmp__(other) == 1:
        return True
    return False

.sympy.core.core.BasicMeta.__cmp__

def __cmp__(cls, other):
    if not isinstance(other, BasicMeta):
        return -1
    n1 = cls.__name__
    n2 = other.__name__
    if n1 == n2:
        return 0
    UNKNOWN = len(ordering_of_classes) + 1
    try:
        i1 = ordering_of_classes.index(n1)
    except ValueError:
        i1 = UNKNOWN
    try:
        i2 = ordering_of_classes.index(n2)
    except ValueError:
        i2 = UNKNOWN
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)
    return (i1 > i2) - (i1 < i2)

.sympy.core.core.BasicMeta.__lt__

def __lt__(cls, other):
    if cls.__cmp__(other) == -1:
        return True
    return False

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super(AssocOp, cls).__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
            for k, v in chain.from_iterable(postprocessor_mappings):
                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    return obj

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.expr.Expr.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
        if not isinstance(other, Expr):
            return False
    except (SympifyError, SyntaxError):
        return False
    if not (self.is_Number and other.is_Number) and type(self) != type(other):
        return False
    a, b = (self._hashable_content(), other._hashable_content())
    if a != b:
        return False
    for a, b in zip(a, b):
        if not isinstance(a, Expr):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

.sympy.core.expr.Expr._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.basic.Basic.free_symbols

def free_symbols(self):
    return set().union(*[a.free_symbols for a in self.args])

.sympy.core.symbol.Symbol.free_symbols

def free_symbols(self):
    return {self}

.sympy.core.compatibility.default_sort_key

def default_sort_key(item, order=None):
    from .singleton import S
    from .basic import Basic
    from .sympify import sympify, SympifyError
    from .compatibility import iterable
    if isinstance(item, Basic):
        return item.sort_key(order=order)
    if iterable(item, exclude=string_types):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            args = list(item)
            unordered = False
        args = [default_sort_key(arg, order=order) for arg in args]
        if unordered:
            args = sorted(args)
        cls_index, args = (10, (len(args), tuple(args)))
    else:
        if not isinstance(item, string_types):
            try:
                item = sympify(item)
            except SympifyError:
                pass
            else:
                if isinstance(item, Basic):
                    return default_sort_key(item)
        cls_index, args = (0, (1, (str(item),)))
    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)

.sympy.core.symbol.Symbol.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)

.sympy.core.basic.Atom.class_key

def class_key(cls):
    return (2, 0, cls.__name__)

.sympy.core.basic.Basic.__str__

def __str__(self):
    from sympy.printing import sstr
    return sstr(self, order=None)

.sympy.printing.str.sstr

def sstr(expr, **settings):
    p = StrPrinter(settings)
    s = p.doprint(expr)
    return s

.sympy.printing.printer.Printer.__init__

def __init__(self, settings=None):
    self._str = str
    self._settings = self._default_settings.copy()
    self._context = dict()
    for key, val in self._global_settings.items():
        if key in self._default_settings:
            self._settings[key] = val
    if settings is not None:
        self._settings.update(settings)
        if len(self._settings) > len(self._default_settings):
            for key in self._settings:
                if key not in self._default_settings:
                    raise TypeError("Unknown setting '%s'." % key)
    self._print_level = 0

.sympy.printing.printer.Printer.doprint

def doprint(self, expr):
    return self._str(self._print(expr))

.sympy.printing.printer.Printer._print

def _print(self, expr, **kwargs):
    self._print_level += 1
    try:
        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):
            return getattr(expr, self.printmethod)(self, **kwargs)
        classes = type(expr).__mro__
        if AppliedUndef in classes:
            classes = classes[classes.index(AppliedUndef):]
        if UndefinedFunction in classes:
            classes = classes[classes.index(UndefinedFunction):]
        if Function in classes:
            i = classes.index(Function)
            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]
        for cls in classes:
            printmethod = '_print_' + cls.__name__
            if hasattr(self, printmethod):
                return getattr(self, printmethod)(expr, **kwargs)
        if (self.emptyPrinter == str) & (self._settings.get('decimal_separator', None) == 'comma'):
            expr = str(expr).replace('.', '{,}')
        return self.emptyPrinter(expr)
    finally:
        self._print_level -= 1

.sympy.printing.str.StrPrinter._print_Symbol

def _print_Symbol(self, expr):
    return expr.name

.sympy.core.numbers.Number.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (0, ()), (), self)

.sympy.core.numbers.Number.class_key

def class_key(cls):
    return (1, 0, 'Number')

.sympy.core.mul.Mul.as_numer_denom

def as_numer_denom(self):
    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
    return (self.func(*numers), self.func(*denoms))

.sympy.core.expr.Expr.as_numer_denom

def as_numer_denom(self):
    return (self, S.One)

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.expr.Expr.is_number

def is_number(self):
    return all((obj.is_number for obj in self.args))

.sympy.core.exprtools.factor_terms

def factor_terms(expr, radical=False, clear=False, fraction=False, sign=True):

    def do(expr):
        from sympy.concrete.summations import Sum
        from sympy.integrals.integrals import Integral
        is_iterable = iterable(expr)
        if not isinstance(expr, Basic) or expr.is_Atom:
            if is_iterable:
                return type(expr)([do(i) for i in expr])
            return expr
        if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):
            args = expr.args
            newargs = tuple([do(i) for i in args])
            if newargs == args:
                return expr
            return expr.func(*newargs)
        if isinstance(expr, (Sum, Integral)):
            return _factor_sum_int(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)
        cont, p = expr.as_content_primitive(radical=radical, clear=clear)
        if p.is_Add:
            list_args = [do(a) for a in Add.make_args(p)]
            if all((a.as_coeff_Mul()[0].extract_multiplicatively(-1) is not None for a in list_args)):
                cont = -cont
                list_args = [-a for a in list_args]
            special = {}
            for i, a in enumerate(list_args):
                b, e = a.as_base_exp()
                if e.is_Mul and e != Mul(*e.args):
                    list_args[i] = Dummy()
                    special[list_args[i]] = a
            p = Add._from_args(list_args)
            p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)
        elif p.args:
            p = p.func(*[do(a) for a in p.args])
        rv = _keep_coeff(cont, p, clear=clear, sign=sign)
        return rv
    expr = sympify(expr)
    return do(expr)

.sympy.core.exprtools.do

def do(expr):
    from sympy.concrete.summations import Sum
    from sympy.integrals.integrals import Integral
    is_iterable = iterable(expr)
    if not isinstance(expr, Basic) or expr.is_Atom:
        if is_iterable:
            return type(expr)([do(i) for i in expr])
        return expr
    if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):
        args = expr.args
        newargs = tuple([do(i) for i in args])
        if newargs == args:
            return expr
        return expr.func(*newargs)
    if isinstance(expr, (Sum, Integral)):
        return _factor_sum_int(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)
    cont, p = expr.as_content_primitive(radical=radical, clear=clear)
    if p.is_Add:
        list_args = [do(a) for a in Add.make_args(p)]
        if all((a.as_coeff_Mul()[0].extract_multiplicatively(-1) is not None for a in list_args)):
            cont = -cont
            list_args = [-a for a in list_args]
        special = {}
        for i, a in enumerate(list_args):
            b, e = a.as_base_exp()
            if e.is_Mul and e != Mul(*e.args):
                list_args[i] = Dummy()
                special[list_args[i]] = a
        p = Add._from_args(list_args)
        p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)
    elif p.args:
        p = p.func(*[do(a) for a in p.args])
    rv = _keep_coeff(cont, p, clear=clear, sign=sign)
    return rv

.sympy.core.compatibility.iterable

def iterable(i, exclude=(string_types, dict, NotIterable)):
    if hasattr(i, '_iterable'):
        return i._iterable
    try:
        iter(i)
    except TypeError:
        return False
    if exclude:
        return not isinstance(i, exclude)
    return True

.sympy.core.mul.Mul.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    coef = S.One
    args = []
    for i, a in enumerate(self.args):
        c, p = a.as_content_primitive(radical=radical, clear=clear)
        coef *= c
        if p is not S.One:
            args.append(p)
    return (coef, self.func(*args))

.sympy.core.numbers.Rational.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    if self:
        if self.is_positive:
            return (self, S.One)
        return (-self, S.NegativeOne)
    return (S.One, self)

.sympy.core.numbers.Rational._eval_is_positive

def _eval_is_positive(self):
    return self.p > 0

.sympy.core.expr.Expr.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    return (S.One, self)

.sympy.core.mul._keep_coeff

def _keep_coeff(coeff, factors, clear=True, sign=False):
    if not coeff.is_Number:
        if factors.is_Number:
            factors, coeff = (coeff, factors)
        else:
            return coeff * factors
    if coeff is S.One:
        return factors
    elif coeff is S.NegativeOne and (not sign):
        return -factors
    elif factors.is_Add:
        if not clear and coeff.is_Rational and (coeff.q != 1):
            q = S(coeff.q)
            for i in factors.args:
                c, t = i.as_coeff_Mul()
                r = c / q
                if r == int(r):
                    return coeff * factors
        return Mul(coeff, factors, evaluate=False)
    elif factors.is_Mul:
        margs = list(factors.args)
        if margs[0].is_Number:
            margs[0] *= coeff
            if margs[0] == 1:
                margs.pop(0)
        else:
            margs.insert(0, coeff)
        return Mul._from_args(margs)
    else:
        return coeff * factors

.sympy.core.logic.fuzzy_and

def fuzzy_and(args):
    rv = True
    for ai in args:
        ai = fuzzy_bool(ai)
        if ai is False:
            return False
        if rv:
            rv = ai
    return rv

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.expr.Expr.as_independent

def as_independent(self, *deps, **hint):
    from .symbol import Symbol
    from .add import _unevaluated_Add
    from .mul import _unevaluated_Mul
    from sympy.utilities.iterables import sift
    if self.is_zero:
        return (S.Zero, S.Zero)
    func = self.func
    if hint.get('as_Add', isinstance(self, Add)):
        want = Add
    else:
        want = Mul
    sym = set()
    other = []
    for d in deps:
        if isinstance(d, Symbol):
            sym.add(d)
        else:
            other.append(d)

    def has(e):
        has_other = e.has(*other)
        if not sym:
            return has_other
        return has_other or e.has(*e.free_symbols & sym)
    if want is not func or (func is not Add and func is not Mul):
        if has(self):
            return (want.identity, self)
        else:
            return (self, want.identity)
    elif func is Add:
        args = list(self.args)
    else:
        args, nc = self.args_cnc()
    d = sift(args, lambda x: has(x))
    depend = d[True]
    indep = d[False]
    if func is Add:
        return (Add(*indep), _unevaluated_Add(*depend))
    else:
        for i, n in enumerate(nc):
            if has(n):
                depend.extend(nc[i:])
                break
            indep.append(n)
        return (Mul(*indep), Mul(*depend, evaluate=False) if nc else _unevaluated_Mul(*depend))

.sympy.core.mul.Mul._eval_is_zero

def _eval_is_zero(self):
    zero = infinite = False
    for a in self.args:
        z = a.is_zero
        if z:
            if infinite:
                return
            zero = True
        else:
            if not a.is_finite:
                if zero:
                    return
                infinite = True
            if zero is False and z is None:
                zero = None
    return zero

.sympy.core.mul.Mul._eval_is_even

def _eval_is_even(self):
    is_integer = self.is_integer
    if is_integer:
        return fuzzy_not(self.is_odd)
    elif is_integer is False:
        return False

.sympy.core.mul.Mul._eval_is_integer

def _eval_is_integer(self):
    is_rational = self.is_rational
    if is_rational:
        n, d = self.as_numer_denom()
        if d is S.One:
            return True
        elif d == S(2):
            return n.is_even
    elif is_rational is False:
        return False

.sympy.core.mul.Mul._eval_is_rational

def _eval_is_rational(self):
    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.logic._fuzzy_group

def _fuzzy_group(args, quick_exit=False):
    saw_other = False
    for a in args:
        if a is True:
            continue
        if a is None:
            return
        if quick_exit and saw_other:
            return
        saw_other = True
    return not saw_other

.sympy.core.mul.Mul._eval_is_odd

def _eval_is_odd(self):
    is_integer = self.is_integer
    if is_integer:
        r, acc = (True, 1)
        for t in self.args:
            if not t.is_integer:
                return None
            elif t.is_even:
                r = False
            elif t.is_integer:
                if r is False:
                    pass
                elif acc != 1 and (acc + t).is_odd:
                    r = False
                elif t.is_odd is None:
                    r = None
            acc = t
        return r
    elif is_integer is False:
        return False

.sympy.core.numbers.Integer._eval_is_odd

def _eval_is_odd(self):
    return bool(self.p % 2)

.sympy.core.logic.fuzzy_not

def fuzzy_not(v):
    if v is None:
        return v
    else:
        return not v

.sympy.core.mul.Mul._eval_is_composite

def _eval_is_composite(self):
    number_of_args = 0
    for arg in self.args:
        if not (arg.is_integer and arg.is_positive):
            return None
        if (arg - 1).is_positive:
            number_of_args += 1
    if number_of_args > 1:
        return True

.sympy.core.numbers.Integer.__sub__

def __sub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

.sympy.core.expr.Expr._eval_is_negative

def _eval_is_negative(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_negative = self.is_extended_negative
    if finite is True:
        return extended_negative
    if extended_negative is False:
        return False

.sympy.core.mul.Mul._eval_is_extended_negative

def _eval_is_extended_negative(self):
    return self._eval_pos_neg(-1)

.sympy.core.mul.Mul._eval_pos_neg

def _eval_pos_neg(self, sign):
    saw_NON = saw_NOT = False
    for t in self.args:
        if t.is_extended_positive:
            continue
        elif t.is_extended_negative:
            sign = -sign
        elif t.is_zero:
            if all((a.is_finite for a in self.args)):
                return False
            return
        elif t.is_extended_nonpositive:
            sign = -sign
            saw_NON = True
        elif t.is_extended_nonnegative:
            saw_NON = True
        elif t.is_positive is False:
            sign = -sign
            if saw_NOT:
                return
            saw_NOT = True
        elif t.is_negative is False:
            if saw_NOT:
                return
            saw_NOT = True
        else:
            return
    if sign == 1 and saw_NON is False and (saw_NOT is False):
        return True
    if sign < 0:
        return False

.sympy.core.mul.Mul._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return self._eval_pos_neg(1)

.sympy.core.expr.Expr._eval_is_positive

def _eval_is_positive(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_positive = self.is_extended_positive
    if finite is True:
        return extended_positive
    if extended_positive is False:
        return False

.sympy.core.expr.Expr.args_cnc

def args_cnc(self, cset=False, warn=True, split_1=True):
    if self.is_Mul:
        args = list(self.args)
    else:
        args = [self]
    for i, mi in enumerate(args):
        if not mi.is_commutative:
            c = args[:i]
            nc = args[i:]
            break
    else:
        c = args
        nc = []
    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):
        c[:1] = [S.NegativeOne, -c[0]]
    if cset:
        clen = len(c)
        c = set(c)
        if clen and warn and (len(c) != clen):
            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])
    return [c, nc]

.sympy.utilities.iterables.sift

def sift(seq, keyfunc, binary=False):
    if not binary:
        m = defaultdict(list)
        for i in seq:
            m[keyfunc(i)].append(i)
        return m
    sift = F, T = ([], [])
    for i in seq:
        try:
            sift[keyfunc(i)].append(i)
        except (IndexError, TypeError):
            raise ValueError('keyfunc gave non-binary output')
    return (T, F)

.sympy.core.expr.Expr.has

def has(e):
    has_other = e.has(*other)
    if not sym:
        return has_other
    return has_other or e.has(*e.free_symbols & sym)

.sympy.core.basic.Basic.has

def has(self, *patterns):
    return any((self._has(pattern) for pattern in patterns))

.sympy.core.basic.Basic._has

def _has(self, pattern):
    from sympy.core.function import UndefinedFunction, Function
    if isinstance(pattern, UndefinedFunction):
        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))
    pattern = sympify(pattern)
    if isinstance(pattern, BasicMeta):
        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))
    _has_matcher = getattr(pattern, '_has_matcher', None)
    if _has_matcher is not None:
        match = _has_matcher()
        return any((match(arg) for arg in preorder_traversal(self)))
    else:
        return any((arg == pattern for arg in preorder_traversal(self)))

.sympy.core.basic.Basic._has_matcher

def _has_matcher(self):
    return lambda other: self == other

.sympy.core.basic.preorder_traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

.sympy.core.basic.preorder_traversal.__iter__

def __iter__(self):
    return self

.sympy.core.basic.preorder_traversal.__next__

def __next__(self):
    return next(self._pt)

.sympy.core.basic.preorder_traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            for subtree in self._preorder_traversal(arg, keys):
                yield subtree
    elif iterable(node):
        for item in node:
            for subtree in self._preorder_traversal(item, keys):
                yield subtree

.sympy.core.mul._unevaluated_Mul

def _unevaluated_Mul(*args):
    args = list(args)
    newargs = []
    ncargs = []
    co = S.One
    while args:
        a = args.pop()
        if a.is_Mul:
            c, nc = a.args_cnc()
            args.extend(c)
            if nc:
                ncargs.append(Mul._from_args(nc))
        elif a.is_Number:
            co *= a
        else:
            newargs.append(a)
    _mulsort(newargs)
    if co is not S.One:
        newargs.insert(0, co)
    if ncargs:
        newargs.append(Mul._from_args(ncargs))
    return Mul._from_args(newargs)

.sympy.polys.polytools.Poly.__new__

def __new__(cls, rep, *gens, **args):
    opt = options.build_options(gens, args)
    if 'order' in opt:
        raise NotImplementedError("'order' keyword is not implemented yet")
    if iterable(rep, exclude=str):
        if isinstance(rep, dict):
            return cls._from_dict(rep, opt)
        else:
            return cls._from_list(list(rep), opt)
    else:
        rep = sympify(rep)
        if rep.is_Poly:
            return cls._from_poly(rep, opt)
        else:
            return cls._from_expr(rep, opt)

.sympy.polys.polyoptions.build_options

def build_options(gens, args=None):
    if args is None:
        gens, args = ((), gens)
    if len(args) != 1 or 'opt' not in args or gens:
        return Options(gens, args)
    else:
        return args['opt']

.sympy.polys.polyoptions.Options.__init__

def __init__(self, gens, args, flags=None, strict=False):
    dict.__init__(self)
    if gens and args.get('gens', ()):
        raise OptionError("both '*gens' and keyword argument 'gens' supplied")
    elif gens:
        args = dict(args)
        args['gens'] = gens
    defaults = args.pop('defaults', {})

    def preprocess_options(args):
        for option, value in args.items():
            try:
                cls = self.__options__[option]
            except KeyError:
                raise OptionError("'%s' is not a valid option" % option)
            if issubclass(cls, Flag):
                if flags is None or option not in flags:
                    if strict:
                        raise OptionError("'%s' flag is not allowed in this context" % option)
            if value is not None:
                self[option] = cls.preprocess(value)
    preprocess_options(args)
    for key, value in dict(defaults).items():
        if key in self:
            del defaults[key]
        else:
            for option in self.keys():
                cls = self.__options__[option]
                if key in cls.excludes:
                    del defaults[key]
                    break
    preprocess_options(defaults)
    for option in self.keys():
        cls = self.__options__[option]
        for require_option in cls.requires:
            if self.get(require_option) is None:
                raise OptionError("'%s' option is only allowed together with '%s'" % (option, require_option))
        for exclude_option in cls.excludes:
            if self.get(exclude_option) is not None:
                raise OptionError("'%s' option is not allowed together with '%s'" % (option, exclude_option))
    for option in self.__order__:
        self.__options__[option].postprocess(self)

.sympy.polys.polyoptions.Options.preprocess_options

def preprocess_options(args):
    for option, value in args.items():
        try:
            cls = self.__options__[option]
        except KeyError:
            raise OptionError("'%s' is not a valid option" % option)
        if issubclass(cls, Flag):
            if flags is None or option not in flags:
                if strict:
                    raise OptionError("'%s' flag is not allowed in this context" % option)
        if value is not None:
            self[option] = cls.preprocess(value)

.sympy.polys.polyoptions.Option.postprocess

def postprocess(cls, options):
    pass

.sympy.polys.polyoptions.Extension.postprocess

def postprocess(cls, options):
    if 'extension' in options and options['extension'] is not True:
        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])

.sympy.polys.polyoptions.Gaussian.postprocess

def postprocess(cls, options):
    if 'gaussian' in options and options['gaussian'] is True:
        options['extension'] = set([S.ImaginaryUnit])
        Extension.postprocess(options)

.sympy.polys.polyoptions.Domain.postprocess

def postprocess(cls, options):
    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):
        raise GeneratorsError('ground domain and generators interfere together')
    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):
        raise GeneratorsError('you have to provide generators because EX domain was requested')

.sympy.polys.polyoptions.Auto.postprocess

def postprocess(cls, options):
    if ('domain' in options or 'field' in options) and 'auto' not in options:
        options['auto'] = False

.sympy.polys.polyoptions.Modulus.postprocess

def postprocess(cls, options):
    if 'modulus' in options:
        modulus = options['modulus']
        symmetric = options.get('symmetric', True)
        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)

.sympy.polys.polyoptions.Split.postprocess

def postprocess(cls, options):
    if 'split' in options:
        raise NotImplementedError("'split' option is not implemented yet")

.sympy.polys.polytools.Poly._from_expr

def _from_expr(cls, rep, opt):
    rep, opt = _dict_from_expr(rep, opt)
    return cls._from_dict(rep, opt)

.sympy.polys.polyutils._dict_from_expr

def _dict_from_expr(expr, opt):
    if expr.is_commutative is False:
        raise PolynomialError('non-commutative expressions are not supported')

    def _is_expandable_pow(expr):
        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add
    if opt.expand is not False:
        if not isinstance(expr, Expr):
            raise PolynomialError('expression must be of type Expr')
        expr = expr.expand()
        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):
            expr = expand_multinomial(expr)
        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):
            expr = expand_mul(expr)
    if opt.gens:
        rep, gens = _dict_from_expr_if_gens(expr, opt)
    else:
        rep, gens = _dict_from_expr_no_gens(expr, opt)
    return (rep, opt.clone({'gens': gens}))

.sympy.polys.polyoptions.OptionType.getter

def getter(self):
    try:
        return self[cls.option]
    except KeyError:
        return cls.default()

.sympy.polys.polyoptions.Expand.default

def default(cls):
    return True

.sympy.polys.polyutils._is_expandable_pow

def _is_expandable_pow(expr):
    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add

.sympy.polys.polyoptions.Gens.default

def default(cls):
    return ()

.sympy.polys.polyutils._dict_from_expr_no_gens

def _dict_from_expr_no_gens(expr, opt):
    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)
    return (poly, gens)

.sympy.polys.polyutils._parallel_dict_from_expr_no_gens

def _parallel_dict_from_expr_no_gens(exprs, opt):
    if opt.domain is not None:

        def _is_coeff(factor):
            return factor in opt.domain
    elif opt.extension is True:

        def _is_coeff(factor):
            return factor.is_algebraic
    elif opt.greedy is not False:

        def _is_coeff(factor):
            return False
    else:

        def _is_coeff(factor):
            return factor.is_number
    gens, reprs = (set([]), [])
    for expr in exprs:
        terms = []
        if expr.is_Equality:
            expr = expr.lhs - expr.rhs
        for term in Add.make_args(expr):
            coeff, elements = ([], {})
            for factor in Mul.make_args(term):
                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):
                    coeff.append(factor)
                else:
                    if opt.series is False:
                        base, exp = decompose_power(factor)
                        if exp < 0:
                            exp, base = (-exp, Pow(base, -S.One))
                    else:
                        base, exp = decompose_power_rat(factor)
                    elements[base] = elements.setdefault(base, 0) + exp
                    gens.add(base)
            terms.append((coeff, elements))
        reprs.append(terms)
    gens = _sort_gens(gens, opt=opt)
    k, indices = (len(gens), {})
    for i, g in enumerate(gens):
        indices[g] = i
    polys = []
    for terms in reprs:
        poly = {}
        for coeff, term in terms:
            monom = [0] * k
            for base, exp in term.items():
                monom[indices[base]] = exp
            monom = tuple(monom)
            if monom in poly:
                poly[monom] += Mul(*coeff)
            else:
                poly[monom] = Mul(*coeff)
        polys.append(poly)
    return (polys, tuple(gens))

.sympy.polys.polyoptions.Option.default

def default(cls):
    return None

.sympy.polys.polyutils._not_a_coeff

def _not_a_coeff(expr):
    if expr in illegal or expr in finf:
        return True
    if type(expr) is float and float(expr) != expr:
        return True
    return

.sympy.core.numbers.NaN.__eq__

def __eq__(self, other):
    return other is S.NaN

.sympy.core.numbers.Infinity.__eq__

def __eq__(self, other):
    return other is S.Infinity or other == float('inf')

.sympy.core.numbers.Float.__new__

def __new__(cls, num, dps=None, prec=None, precision=None):
    if prec is not None:
        SymPyDeprecationWarning(feature="Using 'prec=XX' to denote decimal precision", useinstead="'dps=XX' for decimal precision and 'precision=XX' for binary precision", issue=12820, deprecated_since_version='1.1').warn()
        dps = prec
    del prec
    if dps is not None and precision is not None:
        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')
    if isinstance(num, string_types):
        num = num.replace(' ', '').lower()
        if '_' in num:
            parts = num.split('_')
            if not (all(parts) and all((parts[i][-1].isdigit() for i in range(0, len(parts), 2))) and all((parts[i][0].isdigit() for i in range(1, len(parts), 2)))):
                raise ValueError("could not convert string to float: '%s'" % num)
            num = ''.join(parts)
        if num.startswith('.') and len(num) > 1:
            num = '0' + num
        elif num.startswith('-.') and len(num) > 2:
            num = '-0.' + num[2:]
        elif num in ('inf', '+inf'):
            return S.Infinity
        elif num == '-inf':
            return S.NegativeInfinity
    elif isinstance(num, float) and num == 0:
        num = '0'
    elif isinstance(num, float) and num == float('inf'):
        return S.Infinity
    elif isinstance(num, float) and num == float('-inf'):
        return S.NegativeInfinity
    elif isinstance(num, float) and num == float('nan'):
        return S.NaN
    elif isinstance(num, (SYMPY_INTS, Integer)):
        num = str(num)
    elif num is S.Infinity:
        return num
    elif num is S.NegativeInfinity:
        return num
    elif num is S.NaN:
        return num
    elif type(num).__module__ == 'numpy':
        num = _convert_numpy_types(num)
    elif isinstance(num, mpmath.mpf):
        if precision is None:
            if dps is None:
                precision = num.context.prec
        num = num._mpf_
    if dps is None and precision is None:
        dps = 15
        if isinstance(num, Float):
            return num
        if isinstance(num, string_types) and _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                dps = max(15, dps)
                precision = mlib.libmpf.dps_to_prec(dps)
    elif precision == '' and dps is None or (precision is None and dps == ''):
        if not isinstance(num, string_types):
            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')
        ok = None
        if _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                    precision = mlib.libmpf.dps_to_prec(dps)
                ok = True
        if ok is None:
            raise ValueError('string-float not recognized: %s' % num)
    if precision is None or precision == '':
        precision = mlib.libmpf.dps_to_prec(dps)
    precision = int(precision)
    if isinstance(num, float):
        _mpf_ = mlib.from_float(num, precision, rnd)
    elif isinstance(num, string_types):
        _mpf_ = mlib.from_str(num, precision, rnd)
    elif isinstance(num, decimal.Decimal):
        if num.is_finite():
            _mpf_ = mlib.from_str(str(num), precision, rnd)
        elif num.is_nan():
            return S.NaN
        elif num.is_infinite():
            if num > 0:
                return S.Infinity
            return S.NegativeInfinity
        else:
            raise ValueError('unexpected decimal value %s' % str(num))
    elif isinstance(num, tuple) and len(num) in (3, 4):
        if type(num[1]) is str:
            num = list(num)
            if num[1].endswith('L'):
                num[1] = num[1][:-1]
            num[1] = MPZ(num[1], 16)
            _mpf_ = tuple(num)
        elif len(num) == 4:
            return Float._new(num, precision)
        else:
            if not all((num[0] in (0, 1), num[1] >= 0, all((type(i) in (long, int) for i in num)))):
                raise ValueError('malformed mpf: %s' % (num,))
            return Float._new((num[0], num[1], num[2], bitcount(num[1])), precision)
    else:
        try:
            _mpf_ = num._as_mpf_val(precision)
        except (NotImplementedError, AttributeError):
            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
    return cls._new(_mpf_, precision, zero=False)

.sympy.core.numbers.NegativeInfinity.__eq__

def __eq__(self, other):
    return other is S.NegativeInfinity or other == float('-inf')

.sympy.polys.polyutils._is_coeff

def _is_coeff(factor):
    return factor.is_number

.sympy.polys.polyoptions.Series.default

def default(cls):
    return False

.sympy.core.exprtools.decompose_power

def decompose_power(expr):
    base, exp = expr.as_base_exp()
    if exp.is_Number:
        if exp.is_Rational:
            if not exp.is_Integer:
                base = Pow(base, Rational(1, exp.q))
            exp = exp.p
        else:
            base, exp = (expr, 1)
    else:
        exp, tail = exp.as_coeff_Mul(rational=True)
        if exp is S.NegativeOne:
            base, exp = (Pow(base, tail), -1)
        elif exp is not S.One:
            tail = _keep_coeff(Rational(1, exp.q), tail)
            base, exp = (Pow(base, tail), exp.p)
        else:
            base, exp = (expr, 1)
    return (base, exp)

.sympy.polys.polyutils._sort_gens

def _sort_gens(gens, **args):
    opt = build_options(args)
    gens_order, wrt = ({}, None)
    if opt is not None:
        gens_order, wrt = ({}, opt.wrt)
        for i, gen in enumerate(opt.sort):
            gens_order[gen] = i + 1

    def order_key(gen):
        gen = str(gen)
        if wrt is not None:
            try:
                return (-len(wrt) + wrt.index(gen), gen, 0)
            except ValueError:
                pass
        name, index = _re_gen.match(gen).groups()
        if index:
            index = int(index)
        else:
            index = 0
        try:
            return (gens_order[name], name, index)
        except KeyError:
            pass
        try:
            return (_gens_order[name], name, index)
        except KeyError:
            pass
        return (_max_order, name, index)
    try:
        gens = sorted(gens, key=order_key)
    except TypeError:
        pass
    return tuple(gens)

.sympy.polys.polyoptions.Sort.default

def default(cls):
    return []

.sympy.polys.polyutils.order_key

def order_key(gen):
    gen = str(gen)
    if wrt is not None:
        try:
            return (-len(wrt) + wrt.index(gen), gen, 0)
        except ValueError:
            pass
    name, index = _re_gen.match(gen).groups()
    if index:
        index = int(index)
    else:
        index = 0
    try:
        return (gens_order[name], name, index)
    except KeyError:
        pass
    try:
        return (_gens_order[name], name, index)
    except KeyError:
        pass
    return (_max_order, name, index)

.sympy.polys.polyoptions.Options.clone

def clone(self, updates={}):
    obj = dict.__new__(self.__class__)
    for option, value in self.items():
        obj[option] = value
    for option, value in updates.items():
        obj[option] = value
    return obj

.sympy.polys.polytools.Poly._from_dict

def _from_dict(cls, rep, opt):
    gens = opt.gens
    if not gens:
        raise GeneratorsNeeded("can't initialize from 'dict' without generators")
    level = len(gens) - 1
    domain = opt.domain
    if domain is None:
        domain, rep = construct_domain(rep, opt=opt)
    else:
        for monom, coeff in rep.items():
            rep[monom] = domain.convert(coeff)
    return cls.new(DMP.from_dict(rep, level, domain), *gens)

.sympy.polys.constructor.construct_domain

def construct_domain(obj, **args):
    opt = build_options(args)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            if not obj:
                monoms, coeffs = ([], [])
            else:
                monoms, coeffs = list(zip(*list(obj.items())))
        else:
            coeffs = obj
    else:
        coeffs = [obj]
    coeffs = list(map(sympify, coeffs))
    result = _construct_simple(coeffs, opt)
    if result is not None:
        if result is not False:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    else:
        if opt.composite is False:
            result = None
        else:
            result = _construct_composite(coeffs, opt)
        if result is not None:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            return (domain, dict(list(zip(monoms, coeffs))))
        else:
            return (domain, coeffs)
    else:
        return (domain, coeffs[0])

.sympy.polys.constructor._construct_simple

def _construct_simple(coeffs, opt):
    result, rationals, reals, algebraics = ({}, False, False, False)
    if opt.extension is True:
        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic
    else:
        is_algebraic = lambda coeff: False
    for coeff in coeffs:
        if coeff.is_Rational:
            if not coeff.is_Integer:
                rationals = True
        elif coeff.is_Float:
            if not algebraics:
                reals = True
            else:
                return False
        elif is_algebraic(coeff):
            if not reals:
                algebraics = True
            else:
                return False
        else:
            return None
    if algebraics:
        domain, result = _construct_algebraic(coeffs, opt)
    else:
        if reals:
            max_prec = max([c._prec for c in coeffs])
            domain = RealField(prec=max_prec)
        elif opt.field or rationals:
            domain = QQ
        else:
            domain = ZZ
        result = []
        for coeff in coeffs:
            result.append(domain.from_sympy(coeff))
    return (domain, result)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.from_sympy

def from_sympy(self, a):
    if a.is_Integer:
        return PythonInteger(a.p)
    elif a.is_Float and int(a) == a:
        return PythonInteger(int(a))
    else:
        raise CoercionFailed('expected an integer, got %s' % a)

.sympy.polys.polyclasses.DMP.from_dict

def from_dict(cls, rep, lev, dom):
    return cls(dmp_from_dict(rep, lev, dom), dom, lev)

.sympy.polys.densebasic.dmp_from_dict

def dmp_from_dict(f, u, K):
    if not u:
        return dup_from_dict(f, K)
    if not f:
        return dmp_zero(u)
    coeffs = {}
    for monom, coeff in f.items():
        head, tail = (monom[0], monom[1:])
        if head in coeffs:
            coeffs[head][tail] = coeff
        else:
            coeffs[head] = {tail: coeff}
    n, v, h = (max(coeffs.keys()), u - 1, [])
    for k in range(n, -1, -1):
        coeff = coeffs.get(k)
        if coeff is not None:
            h.append(dmp_from_dict(coeff, v, K))
        else:
            h.append(dmp_zero(v))
    return dmp_strip(h, u)

.sympy.polys.densebasic.dup_from_dict

def dup_from_dict(f, K):
    if not f:
        return []
    n, h = (max(f.keys()), [])
    if type(n) is int:
        for k in range(n, -1, -1):
            h.append(f.get(k, K.zero))
    else:
        n, = n
        for k in range(n, -1, -1):
            h.append(f.get((k,), K.zero))
    return dup_strip(h)

.sympy.polys.densebasic.dup_strip

def dup_strip(f):
    if not f or f[0]:
        return f
    i = 0
    for cf in f:
        if cf:
            break
        else:
            i += 1
    return f[i:]

.sympy.polys.densebasic.dmp_zero

def dmp_zero(u):
    r = []
    for i in range(u):
        r = [r]
    return r

.sympy.polys.densebasic.dmp_strip

def dmp_strip(f, u):
    if not u:
        return dup_strip(f)
    if dmp_zero_p(f, u):
        return f
    i, v = (0, u - 1)
    for c in f:
        if not dmp_zero_p(c, v):
            break
        else:
            i += 1
    if i == len(f):
        return dmp_zero(u)
    else:
        return f[i:]

.sympy.polys.densebasic.dmp_zero_p

def dmp_zero_p(f, u):
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    return not f

.sympy.polys.polyclasses.DMP.__init__

def __init__(self, rep, dom, lev=None, ring=None):
    if lev is not None:
        if type(rep) is dict:
            rep = dmp_from_dict(rep, lev, dom)
        elif type(rep) is not list:
            rep = dmp_ground(dom.convert(rep), lev)
    else:
        rep, lev = dmp_validate(rep)
    self.rep = rep
    self.lev = lev
    self.dom = dom
    self.ring = ring

.sympy.polys.polytools.Poly.new

def new(cls, rep, *gens):
    if not isinstance(rep, DMP):
        raise PolynomialError('invalid polynomial representation: %s' % rep)
    elif rep.lev != len(gens) - 1:
        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))
    obj = Basic.__new__(cls)
    obj.rep = rep
    obj.gens = gens
    return obj

.sympy.polys.polytools.Poly.as_expr

def as_expr(f, *gens):
    if not gens:
        gens = f.gens
    elif len(gens) == 1 and isinstance(gens[0], dict):
        mapping = gens[0]
        gens = list(f.gens)
        for gen, value in mapping.items():
            try:
                index = gens.index(gen)
            except ValueError:
                raise GeneratorsError("%s doesn't have %s as generator" % (f, gen))
            else:
                gens[index] = value
    return basic_from_dict(f.rep.to_sympy_dict(), *gens)

.sympy.polys.polyclasses.DMP.to_sympy_dict

def to_sympy_dict(f, zero=False):
    rep = dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)
    for k, v in rep.items():
        rep[k] = f.dom.to_sympy(v)
    return rep

.sympy.polys.densebasic.dmp_to_dict

def dmp_to_dict(f, u, K=None, zero=False):
    if not u:
        return dup_to_dict(f, K, zero=zero)
    if dmp_zero_p(f, u) and zero:
        return {(0,) * (u + 1): K.zero}
    n, v, result = (dmp_degree(f, u), u - 1, {})
    if n == -oo:
        n = -1
    for k in range(0, n + 1):
        h = dmp_to_dict(f[n - k], v)
        for exp, coeff in h.items():
            result[(k,) + exp] = coeff
    return result

.sympy.polys.densebasic.dmp_degree

def dmp_degree(f, u):
    if dmp_zero_p(f, u):
        return -oo
    else:
        return len(f) - 1

.sympy.core.numbers.Infinity.__neg__

def __neg__(self):
    return S.NegativeInfinity

.sympy.polys.densebasic.dup_to_dict

def dup_to_dict(f, K=None, zero=False):
    if not f and zero:
        return {(0,): K.zero}
    n, result = (len(f) - 1, {})
    for k in range(0, n + 1):
        if f[n - k]:
            result[k,] = f[n - k]
    return result

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.to_sympy

def to_sympy(self, a):
    return SymPyInteger(a)

.sympy.polys.polyutils.expr_from_dict

def expr_from_dict(rep, *gens):
    result = []
    for monom, coeff in rep.items():
        term = [coeff]
        for g, m in zip(gens, monom):
            if m:
                term.append(Pow(g, m))
        result.append(Mul(*term))
    return Add(*result)

.sympy.core.power.Pow.__new__

def __new__(cls, b, e, evaluate=None):
    if evaluate is None:
        evaluate = global_evaluate[0]
    from sympy.functions.elementary.exponential import exp_polar
    b = _sympify(b)
    e = _sympify(e)
    if evaluate:
        if e is S.ComplexInfinity:
            return S.NaN
        if e is S.Zero:
            return S.One
        elif e is S.One:
            return b
        elif e == -1 and (not b):
            return S.ComplexInfinity
        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):
            if e.is_even:
                b = -b
            elif e.is_odd:
                return -Pow(-b, e)
        if S.NaN in (b, e):
            return S.NaN
        elif b is S.One:
            if abs(e).is_infinite:
                return S.NaN
            return S.One
        else:
            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):
                from sympy import numer, denom, log, sign, im, factor_terms
                c, ex = factor_terms(e, sign=False).as_coeff_Mul()
                den = denom(ex)
                if isinstance(den, log) and den.args[0] == b:
                    return S.Exp1 ** (c * numer(ex))
                elif den.is_Add:
                    s = sign(im(b))
                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):
                        return S.Exp1 ** (c * numer(ex))
            obj = b._eval_power(e)
            if obj is not None:
                return obj
    obj = Expr.__new__(cls, b, e)
    obj = cls._exec_constructor_postprocessors(obj)
    if not isinstance(obj, Pow):
        return obj
    obj.is_commutative = b.is_commutative and e.is_commutative
    return obj

.sympy.core.expr.Expr.is_polynomial

def is_polynomial(self, *syms):
    if syms:
        syms = set(map(sympify, syms))
    else:
        syms = self.free_symbols
    if syms.intersection(self.free_symbols) == set([]):
        return True
    else:
        return self._eval_is_polynomial(syms)

.sympy.core.mul.Mul._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    return all((term._eval_is_polynomial(syms) for term in self.args))

.sympy.core.expr.AtomicExpr._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    return True

.sympy.solvers.diophantine.classify_diop

def classify_diop(eq, _dict=True):
    try:
        var = list(eq.free_symbols)
        assert var
    except (AttributeError, AssertionError):
        raise ValueError('equation should have 1 or more free symbols')
    var.sort(key=default_sort_key)
    eq = eq.expand(force=True)
    coeff = eq.as_coefficients_dict()
    if not all((_is_int(c) for c in coeff.values())):
        raise TypeError('Coefficients should be Integers')
    diop_type = None
    total_degree = Poly(eq).total_degree()
    homogeneous = 1 not in coeff
    if total_degree == 1:
        diop_type = 'linear'
    elif len(var) == 1:
        diop_type = 'univariate'
    elif total_degree == 2 and len(var) == 2:
        diop_type = 'binary_quadratic'
    elif total_degree == 2 and len(var) == 3 and homogeneous:
        if set(coeff) & set(var):
            diop_type = 'inhomogeneous_ternary_quadratic'
        else:
            nonzero = [k for k in coeff if coeff[k]]
            if len(nonzero) == 3 and all((i ** 2 in nonzero for i in var)):
                diop_type = 'homogeneous_ternary_quadratic_normal'
            else:
                diop_type = 'homogeneous_ternary_quadratic'
    elif total_degree == 2 and len(var) >= 3:
        if set(coeff) & set(var):
            diop_type = 'inhomogeneous_general_quadratic'
        elif any((k.is_Mul for k in coeff)):
            if not homogeneous:
                diop_type = 'inhomogeneous_general_quadratic'
            else:
                diop_type = 'homogeneous_general_quadratic'
        elif all((coeff[k] == 1 for k in coeff if k != 1)):
            diop_type = 'general_sum_of_squares'
        elif all((is_square(abs(coeff[k])) for k in coeff)):
            if abs(sum((sign(coeff[k]) for k in coeff))) == len(var) - 2:
                diop_type = 'general_pythagorean'
    elif total_degree == 3 and len(var) == 2:
        diop_type = 'cubic_thue'
    elif total_degree > 3 and total_degree % 2 == 0 and all((k.is_Pow and k.exp == total_degree for k in coeff if k != 1)):
        if all((coeff[k] == 1 for k in coeff if k != 1)):
            diop_type = 'general_sum_of_even_powers'
    if diop_type is not None:
        return (var, dict(coeff) if _dict else coeff, diop_type)
    raise NotImplementedError(filldedent('\n        This equation is not yet recognized or else has not been\n        simplified sufficiently to put it in a form recognized by\n        diop_classify().'))

.sympy.core.mul.Mul.as_coefficients_dict

def as_coefficients_dict(self):
    d = defaultdict(int)
    args = self.args
    if len(args) == 1 or not args[0].is_Number:
        d[self] = S.One
    else:
        d[self._new_rawargs(*args[1:])] = args[0]
    return d

.sympy.solvers.diophantine._is_int

def _is_int(i):
    try:
        as_int(i)
        return True
    except ValueError:
        pass

.sympy.core.compatibility.as_int

def as_int(n, strict=True):
    from sympy.core.numbers import Integer
    try:
        if strict and (not isinstance(n, SYMPY_INTS + (Integer,))):
            raise TypeError
        result = int(n)
        if result != n:
            raise TypeError
        return result
    except TypeError:
        raise ValueError('%s is not an integer' % (n,))

.sympy.core.numbers.Integer.__int__

def __int__(self):
    return self.p

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, integer_types):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.polys.polytools.Poly.total_degree

def total_degree(f):
    if hasattr(f.rep, 'total_degree'):
        return f.rep.total_degree()
    else:
        raise OperationNotSupported(f, 'total_degree')

.sympy.polys.polyclasses.DMP.total_degree

def total_degree(f):
    return max((sum(m) for m in f.monoms()))

.sympy.polys.polyclasses.DMP.monoms

def monoms(f, order=None):
    return [m for m, _ in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]

.sympy.polys.densebasic.dmp_list_terms

def dmp_list_terms(f, u, K, order=None):

    def sort(terms, O):
        return sorted(terms, key=lambda term: O(term[0]), reverse=True)
    terms = _rec_list_terms(f, u, ())
    if not terms:
        return [((0,) * (u + 1), K.zero)]
    if order is None:
        return terms
    else:
        return sort(terms, monomial_key(order))

.sympy.polys.densebasic._rec_list_terms

def _rec_list_terms(g, v, monom):
    d, terms = (dmp_degree(g, v), [])
    if not v:
        for i, c in enumerate(g):
            if not c:
                continue
            terms.append((monom + (d - i,), c))
    else:
        w = v - 1
        for i, c in enumerate(g):
            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))
    return terms

.sympy.polys.polytools.factor_list

def factor_list(f, *gens, **args):
    return _generic_factor_list(f, gens, args, method='factor')

.sympy.polys.polytools._generic_factor_list

def _generic_factor_list(expr, gens, args, method):
    options.allowed_flags(args, ['frac', 'polys'])
    opt = options.build_options(gens, args)
    expr = sympify(expr)
    if isinstance(expr, Expr) and (not expr.is_Relational):
        numer, denom = together(expr).as_numer_denom()
        cp, fp = _symbolic_factor_list(numer, opt, method)
        cq, fq = _symbolic_factor_list(denom, opt, method)
        if fq and (not opt.frac):
            raise PolynomialError('a polynomial expected, got %s' % expr)
        _opt = opt.clone(dict(expand=True))
        for factors in (fp, fq):
            for i, (f, k) in enumerate(factors):
                if not f.is_Poly:
                    f, _ = _poly_from_expr(f, _opt)
                    factors[i] = (f, k)
        fp = _sorted_factors(fp, method)
        fq = _sorted_factors(fq, method)
        if not opt.polys:
            fp = [(f.as_expr(), k) for f, k in fp]
            fq = [(f.as_expr(), k) for f, k in fq]
        coeff = cp / cq
        if not opt.frac:
            return (coeff, fp)
        else:
            return (coeff, fp, fq)
    else:
        raise PolynomialError('a polynomial expected, got %s' % expr)

.sympy.polys.polyoptions.allowed_flags

def allowed_flags(args, flags):
    flags = set(flags)
    for arg in args.keys():
        try:
            if Options.__options__[arg].is_Flag and (not arg in flags):
                raise FlagError("'%s' flag is not allowed in this context" % arg)
        except KeyError:
            raise OptionError("'%s' is not a valid option" % arg)

.sympy.polys.rationaltools.together

def together(expr, deep=False, fraction=True):

    def _together(expr):
        if isinstance(expr, Basic):
            if expr.is_Atom or (expr.is_Function and (not deep)):
                return expr
            elif expr.is_Add:
                return gcd_terms(list(map(_together, Add.make_args(expr))), fraction=fraction)
            elif expr.is_Pow:
                base = _together(expr.base)
                if deep:
                    exp = _together(expr.exp)
                else:
                    exp = expr.exp
                return expr.__class__(base, exp)
            else:
                return expr.__class__(*[_together(arg) for arg in expr.args])
        elif iterable(expr):
            return expr.__class__([_together(ex) for ex in expr])
        return expr
    return _together(sympify(expr))

.sympy.polys.rationaltools._together

def _together(expr):
    if isinstance(expr, Basic):
        if expr.is_Atom or (expr.is_Function and (not deep)):
            return expr
        elif expr.is_Add:
            return gcd_terms(list(map(_together, Add.make_args(expr))), fraction=fraction)
        elif expr.is_Pow:
            base = _together(expr.base)
            if deep:
                exp = _together(expr.exp)
            else:
                exp = expr.exp
            return expr.__class__(base, exp)
        else:
            return expr.__class__(*[_together(arg) for arg in expr.args])
    elif iterable(expr):
        return expr.__class__([_together(ex) for ex in expr])
    return expr

.sympy.polys.polytools._symbolic_factor_list

def _symbolic_factor_list(expr, opt, method):
    coeff, factors = (S.One, [])
    args = [i._eval_factor() if hasattr(i, '_eval_factor') else i for i in Mul.make_args(expr)]
    for arg in args:
        if arg.is_Number:
            coeff *= arg
            continue
        if arg.is_Mul:
            args.extend(arg.args)
            continue
        if arg.is_Pow:
            base, exp = arg.args
            if base.is_Number and exp.is_Number:
                coeff *= arg
                continue
            if base.is_Number:
                factors.append((base, exp))
                continue
        else:
            base, exp = (arg, S.One)
        try:
            poly, _ = _poly_from_expr(base, opt)
        except PolificationFailed as exc:
            factors.append((exc.expr, exp))
        else:
            func = getattr(poly, method + '_list')
            _coeff, _factors = func()
            if _coeff is not S.One:
                if exp.is_Integer:
                    coeff *= _coeff ** exp
                elif _coeff.is_positive:
                    factors.append((_coeff, exp))
                else:
                    _factors.append((_coeff, S.One))
            if exp is S.One:
                factors.extend(_factors)
            elif exp.is_integer:
                factors.extend([(f, k * exp) for f, k in _factors])
            else:
                other = []
                for f, k in _factors:
                    if f.as_expr().is_positive:
                        factors.append((f, k * exp))
                    else:
                        other.append((f, k))
                factors.append((_factors_product(other), exp))
    return (coeff, factors)

.sympy.polys.polytools._poly_from_expr

def _poly_from_expr(expr, opt):
    orig, expr = (expr, sympify(expr))
    if not isinstance(expr, Basic):
        raise PolificationFailed(opt, orig, expr)
    elif expr.is_Poly:
        poly = expr.__class__._from_poly(expr, opt)
        opt.gens = poly.gens
        opt.domain = poly.domain
        if opt.polys is None:
            opt.polys = True
        return (poly, opt)
    elif opt.expand:
        expr = expr.expand()
    rep, opt = _dict_from_expr(expr, opt)
    if not opt.gens:
        raise PolificationFailed(opt, orig, expr)
    monoms, coeffs = list(zip(*list(rep.items())))
    domain = opt.domain
    if domain is None:
        opt.domain, coeffs = construct_domain(coeffs, opt=opt)
    else:
        coeffs = list(map(domain.from_sympy, coeffs))
    rep = dict(list(zip(monoms, coeffs)))
    poly = Poly._from_dict(rep, opt)
    if opt.polys is None:
        opt.polys = False
    return (poly, opt)

.sympy.polys.polyoptions.Options.__setattr__

def __setattr__(self, attr, value):
    if attr in self.__options__:
        self[attr] = value
    else:
        super(Options, self).__setattr__(attr, value)

.sympy.polys.domains.domain.Domain.convert

def convert(self, element, base=None):
    if _not_a_coeff(element):
        raise CoercionFailed('%s is not in any domain' % element)
    if base is not None:
        return self.convert_from(element, base)
    if self.of_type(element):
        return element
    from sympy.polys.domains import PythonIntegerRing, GMPYIntegerRing, GMPYRationalField, RealField, ComplexField
    if isinstance(element, integer_types):
        return self.convert_from(element, PythonIntegerRing())
    if HAS_GMPY:
        integers = GMPYIntegerRing()
        if isinstance(element, integers.tp):
            return self.convert_from(element, integers)
        rationals = GMPYRationalField()
        if isinstance(element, rationals.tp):
            return self.convert_from(element, rationals)
    if isinstance(element, float):
        parent = RealField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, complex):
        parent = ComplexField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, DomainElement):
        return self.convert_from(element, element.parent())
    if self.is_Numerical and getattr(element, 'is_ground', False):
        return self.convert(element.LC())
    if isinstance(element, Basic):
        try:
            return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    elif not is_sequence(element):
        try:
            element = sympify(element)
            if isinstance(element, Basic):
                return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    raise CoercionFailed("can't convert %s of type %s to %s" % (element, type(element), self))

.sympy.polys.domains.domain.Domain.of_type

def of_type(self, element):
    return isinstance(element, self.tp)

.sympy.polys.domains.domain.Domain.tp

def tp(self):
    return self.dtype

.sympy.polys.polytools.Poly.factor_list

def factor_list(f):
    if hasattr(f.rep, 'factor_list'):
        try:
            coeff, factors = f.rep.factor_list()
        except DomainError:
            return (S.One, [(f, 1)])
    else:
        raise OperationNotSupported(f, 'factor_list')
    return (f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors])

.sympy.polys.polyclasses.DMP.factor_list

def factor_list(f):
    coeff, factors = dmp_factor_list(f.rep, f.lev, f.dom)
    return (coeff, [(f.per(g), k) for g, k in factors])

.sympy.polys.factortools.dmp_factor_list

def dmp_factor_list(f, u, K0):
    if not u:
        return dup_factor_list(f, K0)
    J, f = dmp_terms_gcd(f, u, K0)
    cont, f = dmp_ground_primitive(f, u, K0)
    if K0.is_FiniteField:
        coeff, factors = dmp_gf_factor(f, u, K0)
    elif K0.is_Algebraic:
        coeff, factors = dmp_ext_factor(f, u, K0)
    else:
        if not K0.is_Exact:
            K0_inexact, K0 = (K0, K0.get_exact())
            f = dmp_convert(f, u, K0_inexact, K0)
        else:
            K0_inexact = None
        if K0.is_Field:
            K = K0.get_ring()
            denom, f = dmp_clear_denoms(f, u, K0, K)
            f = dmp_convert(f, u, K0, K)
        else:
            K = K0
        if K.is_ZZ:
            levels, f, v = dmp_exclude(f, u, K)
            coeff, factors = dmp_zz_factor(f, v, K)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_include(f, levels, v, K), k)
        elif K.is_Poly:
            f, v = dmp_inject(f, u, K)
            coeff, factors = dmp_factor_list(f, v, K.dom)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_eject(f, v, K), k)
            coeff = K.convert(coeff, K.dom)
        else:
            raise DomainError('factorization not supported over %s' % K0)
        if K0.is_Field:
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_convert(f, u, K, K0), k)
            coeff = K0.convert(coeff, K)
            coeff = K0.quo(coeff, denom)
            if K0_inexact:
                for i, (f, k) in enumerate(factors):
                    max_norm = dmp_max_norm(f, u, K0)
                    f = dmp_quo_ground(f, max_norm, u, K0)
                    f = dmp_convert(f, u, K0, K0_inexact)
                    factors[i] = (f, k)
                    coeff = K0.mul(coeff, K0.pow(max_norm, k))
                coeff = K0_inexact.convert(coeff, K0)
                K0 = K0_inexact
    for i, j in enumerate(reversed(J)):
        if not j:
            continue
        term = {(0,) * (u - i) + (1,) + (0,) * i: K0.one}
        factors.insert(0, (dmp_from_dict(term, u, K0), j))
    return (coeff * cont, _sort_factors(factors))

.sympy.polys.factortools.dup_factor_list

def dup_factor_list(f, K0):
    j, f = dup_terms_gcd(f, K0)
    cont, f = dup_primitive(f, K0)
    if K0.is_FiniteField:
        coeff, factors = dup_gf_factor(f, K0)
    elif K0.is_Algebraic:
        coeff, factors = dup_ext_factor(f, K0)
    else:
        if not K0.is_Exact:
            K0_inexact, K0 = (K0, K0.get_exact())
            f = dup_convert(f, K0_inexact, K0)
        else:
            K0_inexact = None
        if K0.is_Field:
            K = K0.get_ring()
            denom, f = dup_clear_denoms(f, K0, K)
            f = dup_convert(f, K0, K)
        else:
            K = K0
        if K.is_ZZ:
            coeff, factors = dup_zz_factor(f, K)
        elif K.is_Poly:
            f, u = dmp_inject(f, 0, K)
            coeff, factors = dmp_factor_list(f, u, K.dom)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_eject(f, u, K), k)
            coeff = K.convert(coeff, K.dom)
        else:
            raise DomainError('factorization not supported over %s' % K0)
        if K0.is_Field:
            for i, (f, k) in enumerate(factors):
                factors[i] = (dup_convert(f, K, K0), k)
            coeff = K0.convert(coeff, K)
            coeff = K0.quo(coeff, denom)
            if K0_inexact:
                for i, (f, k) in enumerate(factors):
                    max_norm = dup_max_norm(f, K0)
                    f = dup_quo_ground(f, max_norm, K0)
                    f = dup_convert(f, K0, K0_inexact)
                    factors[i] = (f, k)
                    coeff = K0.mul(coeff, K0.pow(max_norm, k))
                coeff = K0_inexact.convert(coeff, K0)
                K0 = K0_inexact
    if j:
        factors.insert(0, ([K0.one, K0.zero], j))
    return (coeff * cont, _sort_factors(factors))

.sympy.polys.densebasic.dup_terms_gcd

def dup_terms_gcd(f, K):
    if dup_TC(f, K) or not f:
        return (0, f)
    i = 0
    for c in reversed(f):
        if not c:
            i += 1
        else:
            break
    return (i, f[:-i])

.sympy.polys.densebasic.poly_TC

def poly_TC(f, K):
    if not f:
        return K.zero
    else:
        return f[-1]

.sympy.polys.densetools.dup_primitive

def dup_primitive(f, K):
    if not f:
        return (K.zero, f)
    cont = dup_content(f, K)
    if K.is_one(cont):
        return (cont, f)
    else:
        return (cont, dup_quo_ground(f, cont, K))

.sympy.polys.densetools.dup_content

def dup_content(f, K):
    from sympy.polys.domains import QQ
    if not f:
        return K.zero
    cont = K.zero
    if K == QQ:
        for c in f:
            cont = K.gcd(cont, c)
    else:
        for c in f:
            cont = K.gcd(cont, c)
            if K.is_one(cont):
                break
    return cont

.sympy.polys.domains.domain.Domain.__eq__

def __eq__(self, other):
    return isinstance(other, Domain) and self.dtype == other.dtype

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.gcd

def gcd(self, a, b):
    return python_gcd(a, b)

.sympy.polys.domains.domain.Domain.is_one

def is_one(self, a):
    return a == self.one

.sympy.polys.factortools.dup_zz_factor

def dup_zz_factor(f, K):
    cont, g = dup_primitive(f, K)
    n = dup_degree(g)
    if dup_LC(g, K) < 0:
        cont, g = (-cont, dup_neg(g, K))
    if n <= 0:
        return (cont, [])
    elif n == 1:
        return (cont, [(g, 1)])
    if query('USE_IRREDUCIBLE_IN_FACTOR'):
        if dup_zz_irreducible_p(g, K):
            return (cont, [(g, 1)])
    g = dup_sqf_part(g, K)
    H = None
    if query('USE_CYCLOTOMIC_FACTOR'):
        H = dup_zz_cyclotomic_factor(g, K)
    if H is None:
        H = dup_zz_zassenhaus(g, K)
    factors = dup_trial_division(f, H, K)
    return (cont, factors)

.sympy.polys.densebasic.dup_degree

def dup_degree(f):
    if not f:
        return -oo
    return len(f) - 1

.sympy.polys.densebasic.poly_LC

def poly_LC(f, K):
    if not f:
        return K.zero
    else:
        return f[0]

.sympy.polys.polyutils._sort_factors

def _sort_factors(factors, **args):

    def order_if_multiple_key(factor):
        f, n = factor
        return (len(f), n, f)

    def order_no_multiple_key(f):
        return (len(f), f)
    if args.get('multiple', True):
        return sorted(factors, key=order_if_multiple_key)
    else:
        return sorted(factors, key=order_no_multiple_key)

.sympy.polys.polyutils.order_if_multiple_key

def order_if_multiple_key(factor):
    f, n = factor
    return (len(f), n, f)

.sympy.polys.polyclasses.DMP.per

def per(f, rep, dom=None, kill=False, ring=None):
    lev = f.lev
    if kill:
        if not lev:
            return rep
        else:
            lev -= 1
    if dom is None:
        dom = f.dom
    if ring is None:
        ring = f.ring
    return DMP(rep, dom, lev, ring)

.sympy.polys.polytools.Poly.per

def per(f, rep, gens=None, remove=None):
    if gens is None:
        gens = f.gens
    if remove is not None:
        gens = gens[:remove] + gens[remove + 1:]
        if not gens:
            return f.rep.dom.to_sympy(rep)
    return f.__class__.new(rep, *gens)

.sympy.polys.polytools._sorted_factors

def _sorted_factors(factors, method):
    if method == 'sqf':

        def key(obj):
            poly, exp = obj
            rep = poly.rep.rep
            return (exp, len(rep), len(poly.gens), rep)
    else:

        def key(obj):
            poly, exp = obj
            rep = poly.rep.rep
            return (len(rep), len(poly.gens), exp, rep)
    return sorted(factors, key=key)

.sympy.polys.polytools.key

def key(obj):
    poly, exp = obj
    rep = poly.rep.rep
    return (len(rep), len(poly.gens), exp, rep)

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.numbers.Rational.__div__

def __div__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            if self.p and other.p == S.Zero:
                return S.ComplexInfinity
            else:
                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))
        elif isinstance(other, Rational):
            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))
        elif isinstance(other, Float):
            return self * (1 / other)
        else:
            return Number.__div__(self, other)
    return Number.__div__(self, other)

.sympy.core.numbers.Rational.__new__

def __new__(cls, p, q=None, gcd=None):
    if q is None:
        if isinstance(p, Rational):
            return p
        if isinstance(p, SYMPY_INTS):
            pass
        else:
            if isinstance(p, (float, Float)):
                return Rational(*_as_integer_ratio(p))
            if not isinstance(p, string_types):
                try:
                    p = sympify(p)
                except (SympifyError, SyntaxError):
                    pass
            else:
                if p.count('/') > 1:
                    raise TypeError('invalid input: %s' % p)
                p = p.replace(' ', '')
                pq = p.rsplit('/', 1)
                if len(pq) == 2:
                    p, q = pq
                    fp = fractions.Fraction(p)
                    fq = fractions.Fraction(q)
                    p = fp / fq
                try:
                    p = fractions.Fraction(p)
                except ValueError:
                    pass
                else:
                    return Rational(p.numerator, p.denominator, 1)
            if not isinstance(p, Rational):
                raise TypeError('invalid input: %s' % p)
        q = 1
        gcd = 1
    else:
        p = Rational(p)
        q = Rational(q)
    if isinstance(q, Rational):
        p *= q.q
        q = q.p
    if isinstance(p, Rational):
        q *= p.q
        p = p.p
    if q == 0:
        if p == 0:
            if _errdict['divide']:
                raise ValueError('Indeterminate 0/0')
            else:
                return S.NaN
        return S.ComplexInfinity
    if q < 0:
        q = -q
        p = -p
    if not gcd:
        gcd = igcd(abs(p), q)
    if gcd > 1:
        p //= gcd
        q //= gcd
    if q == 1:
        return Integer(p)
    if p == 1 and q == 2:
        return S.Half
    obj = Expr.__new__(cls)
    obj.p = p
    obj.q = q
    return obj

.sympy.polys.polyoptions.Frac.default

def default(cls):
    return False

.sympy.core.expr.Expr.as_coefficients_dict

def as_coefficients_dict(self):
    c, m = self.as_coeff_Mul()
    if not c.is_Rational:
        c = S.One
        m = self
    d = defaultdict(int)
    d.update({m: c})
    return d

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (S.One, self)

.sympy.simplify.simplify.signsimp

def signsimp(expr, evaluate=None):
    if evaluate is None:
        evaluate = global_evaluate[0]
    expr = sympify(expr)
    if not isinstance(expr, Expr) or expr.is_Atom:
        return expr
    e = sub_post(sub_pre(expr))
    if not isinstance(e, Expr) or e.is_Atom:
        return e
    if e.is_Add:
        return e.func(*[signsimp(a, evaluate) for a in e.args])
    if evaluate:
        e = e.xreplace({m: --m for m in e.atoms(Mul) if --m != m})
    return e

.sympy.solvers.diophantine.diop_solve

def diop_solve(eq, param=symbols('t', integer=True)):
    var, coeff, eq_type = classify_diop(eq, _dict=False)
    if eq_type == 'linear':
        return _diop_linear(var, coeff, param)
    elif eq_type == 'binary_quadratic':
        return _diop_quadratic(var, coeff, param)
    elif eq_type == 'homogeneous_ternary_quadratic':
        x_0, y_0, z_0 = _diop_ternary_quadratic(var, coeff)
        return _parametrize_ternary_quadratic((x_0, y_0, z_0), var, coeff)
    elif eq_type == 'homogeneous_ternary_quadratic_normal':
        x_0, y_0, z_0 = _diop_ternary_quadratic_normal(var, coeff)
        return _parametrize_ternary_quadratic((x_0, y_0, z_0), var, coeff)
    elif eq_type == 'general_pythagorean':
        return _diop_general_pythagorean(var, coeff, param)
    elif eq_type == 'univariate':
        return set([(int(i),) for i in solveset_real(eq, var[0]).intersect(S.Integers)])
    elif eq_type == 'general_sum_of_squares':
        return _diop_general_sum_of_squares(var, -int(coeff[1]), limit=S.Infinity)
    elif eq_type == 'general_sum_of_even_powers':
        for k in coeff.keys():
            if k.is_Pow and coeff[k]:
                p = k.exp
        return _diop_general_sum_of_even_powers(var, p, -int(coeff[1]), limit=S.Infinity)
    if eq_type is not None and eq_type not in diop_known:
        raise ValueError(filldedent('\n    Alhough this type of equation was identified, it is not yet\n    handled. It should, however, be listed in `diop_known` at the\n    top of this file. Developers should see comments at the end of\n    `classify_diop`.\n            '))
    else:
        raise NotImplementedError('No solver has been written for %s.' % eq_type)

.sympy.solvers.diophantine._diop_linear

def _diop_linear(var, coeff, param):
    if 1 in coeff:
        c = -coeff[1]
    else:
        c = 0
    if param is None:
        params = [symbols('t')] * len(var)
    else:
        temp = str(param) + '_%i'
        params = [symbols(temp % i, integer=True) for i in range(len(var))]
    if len(var) == 1:
        q, r = divmod(c, coeff[var[0]])
        if not r:
            return (q,)
        else:
            return (None,)
    "\n    base_solution_linear() can solve diophantine equations of the form:\n\n    a*x + b*y == c\n\n    We break down multivariate linear diophantine equations into a\n    series of bivariate linear diophantine equations which can then\n    be solved individually by base_solution_linear().\n\n    Consider the following:\n\n    a_0*x_0 + a_1*x_1 + a_2*x_2 == c\n\n    which can be re-written as:\n\n    a_0*x_0 + g_0*y_0 == c\n\n    where\n\n    g_0 == gcd(a_1, a_2)\n\n    and\n\n    y == (a_1*x_1)/g_0 + (a_2*x_2)/g_0\n\n    This leaves us with two binary linear diophantine equations.\n    For the first equation:\n\n    a == a_0\n    b == g_0\n    c == c\n\n    For the second:\n\n    a == a_1/g_0\n    b == a_2/g_0\n    c == the solution we find for y_0 in the first equation.\n\n    The arrays A and B are the arrays of integers used for\n    'a' and 'b' in each of the n-1 bivariate equations we solve.\n    "
    A = [coeff[v] for v in var]
    B = []
    if len(var) > 2:
        B.append(igcd(A[-2], A[-1]))
        A[-2] = A[-2] // B[0]
        A[-1] = A[-1] // B[0]
        for i in range(len(A) - 3, 0, -1):
            gcd = igcd(B[0], A[i])
            B[0] = B[0] // gcd
            A[i] = A[i] // gcd
            B.insert(0, gcd)
    B.append(A[-1])
    "\n    Consider the trivariate linear equation:\n\n    4*x_0 + 6*x_1 + 3*x_2 == 2\n\n    This can be re-written as:\n\n    4*x_0 + 3*y_0 == 2\n\n    where\n\n    y_0 == 2*x_1 + x_2\n    (Note that gcd(3, 6) == 3)\n\n    The complete integral solution to this equation is:\n\n    x_0 ==  2 + 3*t_0\n    y_0 == -2 - 4*t_0\n\n    where 't_0' is any integer.\n\n    Now that we have a solution for 'x_0', find 'x_1' and 'x_2':\n\n    2*x_1 + x_2 == -2 - 4*t_0\n\n    We can then solve for '-2' and '-4' independently,\n    and combine the results:\n\n    2*x_1a + x_2a == -2\n    x_1a == 0 + t_0\n    x_2a == -2 - 2*t_0\n\n    2*x_1b + x_2b == -4*t_0\n    x_1b == 0*t_0 + t_1\n    x_2b == -4*t_0 - 2*t_1\n\n    ==>\n\n    x_1 == t_0 + t_1\n    x_2 == -2 - 6*t_0 - 2*t_1\n\n    where 't_0' and 't_1' are any integers.\n\n    Note that:\n\n    4*(2 + 3*t_0) + 6*(t_0 + t_1) + 3*(-2 - 6*t_0 - 2*t_1) == 2\n\n    for any integral values of 't_0', 't_1'; as required.\n\n    This method is generalised for many variables, below.\n\n    "
    solutions = []
    for i in range(len(B)):
        tot_x, tot_y = ([], [])
        for j, arg in enumerate(Add.make_args(c)):
            if arg.is_Integer:
                k, p = (arg, S.One)
                pnew = params[0]
            else:
                k, p = arg.as_coeff_Mul()
                pnew = params[params.index(p) + 1]
            sol = sol_x, sol_y = base_solution_linear(k, A[i], B[i], pnew)
            if p is S.One:
                if None in sol:
                    return tuple([None] * len(var))
            else:
                if isinstance(sol_x, Add):
                    sol_x = sol_x.args[0] * p + sol_x.args[1]
                if isinstance(sol_y, Add):
                    sol_y = sol_y.args[0] * p + sol_y.args[1]
            tot_x.append(sol_x)
            tot_y.append(sol_y)
        solutions.append(Add(*tot_x))
        c = Add(*tot_y)
    solutions.append(c)
    if param is None:
        solutions = [i.as_coeff_Add()[0] for i in solutions]
    return tuple(solutions)

.sympy.core.symbol.symbols

def symbols(names, **args):
    result = []
    if isinstance(names, string_types):
        marker = 0
        literals = ['\\,', '\\:', '\\ ']
        for i in range(len(literals)):
            lit = literals.pop(0)
            if lit in names:
                while chr(marker) in names:
                    marker += 1
                lit_char = chr(marker)
                marker += 1
                names = names.replace(lit, lit_char)
                literals.append((lit_char, lit[1:]))

        def literal(s):
            if literals:
                for c, l in literals:
                    s = s.replace(c, l)
            return s
        names = names.strip()
        as_seq = names.endswith(',')
        if as_seq:
            names = names[:-1].rstrip()
        if not names:
            raise ValueError('no symbols given')
        names = [n.strip() for n in names.split(',')]
        if not all((n for n in names)):
            raise ValueError('missing symbol between commas')
        for i in range(len(names) - 1, -1, -1):
            names[i:i + 1] = names[i].split()
        cls = args.pop('cls', Symbol)
        seq = args.pop('seq', as_seq)
        for name in names:
            if not name:
                raise ValueError('missing symbol')
            if ':' not in name:
                symbol = cls(literal(name), **args)
                result.append(symbol)
                continue
            split = _range.split(name)
            for i in range(len(split) - 1):
                if i and ':' in split[i] and (split[i] != ':') and split[i - 1].endswith('(') and split[i + 1].startswith(')'):
                    split[i - 1] = split[i - 1][:-1]
                    split[i + 1] = split[i + 1][1:]
            for i, s in enumerate(split):
                if ':' in s:
                    if s[-1].endswith(':'):
                        raise ValueError('missing end range')
                    a, b = s.split(':')
                    if b[-1] in string.digits:
                        a = 0 if not a else int(a)
                        b = int(b)
                        split[i] = [str(c) for c in range(a, b)]
                    else:
                        a = a or 'a'
                        split[i] = [string.ascii_letters[c] for c in range(string.ascii_letters.index(a), string.ascii_letters.index(b) + 1)]
                    if not split[i]:
                        break
                else:
                    split[i] = [s]
            else:
                seq = True
                if len(split) == 1:
                    names = split[0]
                else:
                    names = [''.join(s) for s in cartes(*split)]
                if literals:
                    result.extend([cls(literal(s), **args) for s in names])
                else:
                    result.extend([cls(s, **args) for s in names])
        if not seq and len(result) <= 1:
            if not result:
                return ()
            return result[0]
        return tuple(result)
    else:
        for name in names:
            result.append(symbols(name, **args))
        return type(names)(result)

.sympy.core.symbol.literal

def literal(s):
    if literals:
        for c, l in literals:
            s = s.replace(c, l)
    return s

.sympy.core.symbol.Symbol.__new__

def __new__(cls, name, **assumptions):
    cls._sanitize(assumptions, cls)
    return Symbol.__xnew_cached_(cls, name, **assumptions)

.sympy.core.symbol.Symbol._sanitize

def _sanitize(assumptions, obj=None):
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    if is_commutative is None:
        whose = '%s ' % obj.__name__ if obj else ''
        raise ValueError('%scommutativity must be True or False.' % whose)
    for key in list(assumptions.keys()):
        from collections import defaultdict
        from sympy.utilities.exceptions import SymPyDeprecationWarning
        keymap = defaultdict(lambda: None)
        keymap.update({'bounded': 'finite', 'unbounded': 'infinite', 'infinitesimal': 'zero'})
        if keymap[key]:
            SymPyDeprecationWarning(feature='%s assumption' % key, useinstead='%s' % keymap[key], issue=8071, deprecated_since_version='0.7.6').warn()
            assumptions[keymap[key]] = assumptions[key]
            assumptions.pop(key)
            key = keymap[key]
        v = assumptions[key]
        if v is None:
            assumptions.pop(key)
            continue
        assumptions[key] = bool(v)

.sympy.core.symbol.Symbol.__new_stage2__

def __new_stage2__(cls, name, **assumptions):
    if not isinstance(name, string_types):
        raise TypeError('name should be a string, not %s' % repr(type(name)))
    obj = Expr.__new__(cls)
    obj.name = name
    tmp_asm_copy = assumptions.copy()
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    assumptions['commutative'] = is_commutative
    obj._assumptions = StdFactKB(assumptions)
    obj._assumptions._generator = tmp_asm_copy
    return obj

.sympy.core.numbers.Integer.__rdivmod__

def __rdivmod__(self, other):
    from .containers import Tuple
    if isinstance(other, integer_types) and global_evaluate[0]:
        return Tuple(*divmod(other, self.p))
    else:
        try:
            other = Number(other)
        except TypeError:
            msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
            oname = type(other).__name__
            sname = type(self).__name__
            raise TypeError(msg % (oname, sname))
        return Number.__divmod__(other, self)

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.solvers.diophantine.merge_solution

def merge_solution(var, var_t, solution):
    sol = []
    if None in solution:
        return ()
    solution = iter(solution)
    params = numbered_symbols('n', integer=True, start=1)
    for v in var:
        if v in var_t:
            sol.append(next(solution))
        else:
            sol.append(next(params))
    for val, symb in zip(sol, var):
        if check_assumptions(val, **symb.assumptions0) is False:
            return tuple()
    return tuple(sol)

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    from sympy.core.power import integer_log
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not isinstance(other, Number):
        return False
    if not self:
        return not other
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Rational:
        return self.p == other.p and self.q == other.q
    if other.is_Float:
        if self.q & self.q - 1:
            return False
        s, m, t = other._mpf_[:3]
        if s:
            m = -m
        if not t:
            if not self.is_Integer or self.is_even:
                return False
            return m == self.p
        if t > 0:
            if not self.is_Integer:
                return False
            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))
        if self.is_Integer:
            return False
        return m == self.p and integer_log(self.q, 2) == (-t, True)
    return False

.sympy.core.sympify.SympifyError.__init__

def __init__(self, expr, base_exc=None):
    self.expr = expr
    self.base_exc = base_exc

.sympy.utilities.iterables.numbered_symbols

def numbered_symbols(prefix='x', cls=None, start=0, exclude=[], *args, **assumptions):
    exclude = set(exclude or [])
    if cls is None:
        from sympy import Symbol
        cls = Symbol
    while True:
        name = '%s%s' % (prefix, start)
        s = cls(name, *args, **assumptions)
        if s not in exclude:
            yield s
        start += 1

.sympy.solvers.solvers.check_assumptions

def check_assumptions(expr, against=None, **assumptions):
    expr = sympify(expr)
    if against:
        if not isinstance(against, Symbol):
            raise TypeError('against should be of type Symbol')
        if assumptions:
            raise AssertionError('No assumptions should be specified')
        assumptions = against.assumptions0

    def _test(key):
        v = getattr(expr, 'is_' + key, None)
        if v is not None:
            return assumptions[key] is v
    return fuzzy_and((_test(key) for key in assumptions))

.sympy.solvers.solvers._test

def _test(key):
    v = getattr(expr, 'is_' + key, None)
    if v is not None:
        return assumptions[key] is v

.sympy.core.power.Pow._eval_expand_multinomial

def _eval_expand_multinomial(self, **hints):
    base, exp = self.args
    result = self
    if exp.is_Rational and exp.p > 0 and base.is_Add:
        if not exp.is_Integer:
            n = Integer(exp.p // exp.q)
            if not n:
                return result
            else:
                radical, result = (self.func(base, exp - n), [])
                expanded_base_n = self.func(base, n)
                if expanded_base_n.is_Pow:
                    expanded_base_n = expanded_base_n._eval_expand_multinomial()
                for term in Add.make_args(expanded_base_n):
                    result.append(term * radical)
                return Add(*result)
        n = int(exp)
        if base.is_commutative:
            order_terms, other_terms = ([], [])
            for b in base.args:
                if b.is_Order:
                    order_terms.append(b)
                else:
                    other_terms.append(b)
            if order_terms:
                f = Add(*other_terms)
                o = Add(*order_terms)
                if n == 2:
                    return expand_multinomial(f ** n, deep=False) + n * f * o
                else:
                    g = expand_multinomial(f ** (n - 1), deep=False)
                    return expand_mul(f * g, deep=False) + n * g * o
            if base.is_number:
                a, b = base.as_real_imag()
                if a.is_Rational and b.is_Rational:
                    if not a.is_Integer:
                        if not b.is_Integer:
                            k = self.func(a.q * b.q, n)
                            a, b = (a.p * b.q, a.q * b.p)
                        else:
                            k = self.func(a.q, n)
                            a, b = (a.p, a.q * b)
                    elif not b.is_Integer:
                        k = self.func(b.q, n)
                        a, b = (a * b.q, b.p)
                    else:
                        k = 1
                    a, b, c, d = (int(a), int(b), 1, 0)
                    while n:
                        if n & 1:
                            c, d = (a * c - b * d, b * c + a * d)
                            n -= 1
                        a, b = (a * a - b * b, 2 * a * b)
                        n //= 2
                    I = S.ImaginaryUnit
                    if k == 1:
                        return c + I * d
                    else:
                        return Integer(c) / k + I * d / k
            p = other_terms
            from sympy import multinomial_coefficients
            from sympy.polys.polyutils import basic_from_dict
            expansion_dict = multinomial_coefficients(len(p), n)
            return basic_from_dict(expansion_dict, *p)
        elif n == 2:
            return Add(*[f * g for f in base.args for g in base.args])
        else:
            multi = (base ** (n - 1))._eval_expand_multinomial()
            if multi.is_Add:
                return Add(*[f * g for f in base.args for g in multi.args])
            else:
                return Add(*[f * multi for f in base.args])
    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):
        return 1 / self.func(base, -exp)._eval_expand_multinomial()
    elif exp.is_Add and base.is_Number:
        coeff, tail = (S.One, S.Zero)
        for term in exp.args:
            if term.is_Number:
                coeff *= self.func(base, term)
            else:
                tail += term
        return coeff * self.func(base, tail)
    else:
        return result

.sympy.core.power.Pow.as_base_exp

def as_base_exp(self):
    b, e = self.args
    if b.is_Rational and b.p == 1 and (b.q != 1):
        return (Integer(b.q), -e)
    return (b, e)

.sympy.core.expr.Expr._eval_is_extended_negative

def _eval_is_extended_negative(self):
    return self._eval_is_extended_positive_negative(positive=False)

.sympy.core.expr.Expr._eval_is_extended_positive_negative

def _eval_is_extended_positive_negative(self, positive):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_extended_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
        except ValueError:
            return None
        if n2 is None:
            return None
        if getattr(n2, '_prec', 1) == 1:
            return None
        if n2 is S.NaN:
            return None
        r, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not r.is_Number:
            return False
        if r._prec != 1 and i._prec != 1:
            return bool(not i and (r > 0 if positive else r < 0))
        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.numbers.Number._eval_evalf

def _eval_evalf(self, prec):
    return Float._new(self._as_mpf_val(prec), prec)

.sympy.core.numbers.Integer._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_int(self.p, prec, rnd)

.sympy.core.numbers.Float._new

def _new(cls, _mpf_, _prec, zero=True):
    if zero and _mpf_ == fzero:
        return S.Zero
    elif _mpf_ == _mpf_nan:
        return S.NaN
    elif _mpf_ == _mpf_inf:
        return S.Infinity
    elif _mpf_ == _mpf_ninf:
        return S.NegativeInfinity
    obj = Expr.__new__(cls)
    obj._mpf_ = mpf_norm(_mpf_, _prec)
    obj._prec = _prec
    return obj

.sympy.core.numbers.mpf_norm

def mpf_norm(mpf, prec):
    sign, man, expt, bc = mpf
    if not man:
        if not bc:
            return fzero
        else:
            return mpf
    from mpmath.libmp.backend import MPZ
    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
    return rv

.sympy.core.evalf.EvalfMixin.evalf

def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
    from sympy import Float, Number
    n = n if n is not None else 15
    if subs and is_sequence(subs):
        raise TypeError('subs must be given as a dictionary')
    if n == 1 and isinstance(self, Number):
        from sympy.core.expr import _mag
        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
        m = _mag(rv)
        rv = rv.round(1 - m)
        return rv
    if not evalf_table:
        _create_evalf_table()
    prec = dps_to_prec(n)
    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}
    if subs is not None:
        options['subs'] = subs
    if quad is not None:
        options['quad'] = quad
    try:
        result = evalf(self, prec + 4, options)
    except NotImplementedError:
        v = self._eval_evalf(prec)
        if v is None:
            return self
        elif not v.is_number:
            return v
        try:
            result = evalf(v, prec, options)
        except NotImplementedError:
            return v
    re, im, re_acc, im_acc = result
    if re:
        p = max(min(prec, re_acc), 1)
        re = Float._new(re, p)
    else:
        re = S.Zero
    if im:
        p = max(min(prec, im_acc), 1)
        im = Float._new(im, p)
        return re + im * S.ImaginaryUnit
    else:
        return re

.sympy.core.evalf.evalf

def evalf(x, prec, options):
    from sympy import re as re_, im as im_
    try:
        rf = evalf_table[x.func]
        r = rf(x, prec, options)
    except KeyError:
        if 'subs' in options:
            x = x.subs(evalf_subs(prec, options['subs']))
        xe = x._eval_evalf(prec)
        if xe is None:
            raise NotImplementedError
        as_real_imag = getattr(xe, 'as_real_imag', None)
        if as_real_imag is None:
            raise NotImplementedError
        re, im = as_real_imag()
        if re.has(re_) or im.has(im_):
            raise NotImplementedError
        if re == 0:
            re = None
            reprec = None
        elif re.is_number:
            re = re._to_mpmath(prec, allow_ints=False)._mpf_
            reprec = prec
        else:
            raise NotImplementedError
        if im == 0:
            im = None
            imprec = None
        elif im.is_number:
            im = im._to_mpmath(prec, allow_ints=False)._mpf_
            imprec = prec
        else:
            raise NotImplementedError
        r = (re, im, reprec, imprec)
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50))
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.expr.Expr.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import im, re
    if hints.get('ignore') == self:
        return None
    else:
        return (re(self), im(self))

.sympy.core.numbers.Float.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not self:
        return not other
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Float:
        return self._mpf_ == other._mpf_
    if other.is_Rational:
        return other.__eq__(self)
    if other.is_Number:
        ompf = other._as_mpf_val(self._prec)
        return bool(mlib.mpf_eq(self._mpf_, ompf))
    return False

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_evaluate[0])
    result = super(Function, cls).__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(mlib.libmpf.prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return S.EmptySet
    else:
        args = list(map(sympify, args))
    _args_set = set(args)
    args = list(ordered(_args_set, Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._args_set = _args_set
    return obj

.sympy.core.compatibility.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                from sympy.utilities.iterables import uniq
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        for v in d[k]:
            yield v
        d.pop(k)

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super(Infinity, self).__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super(Number, self).__hash__()

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    other = _sympify(other)
    c = self._contains(other)
    b = tfn[c]
    if b is None:
        raise TypeError('did not evaluate to a bool: %r' % c)
    return b

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    if other in self._args_set:
        return True
    else:
        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))

.sympy.logic.boolalg.BooleanTrue.__nonzero__

def __nonzero__(self):
    return True

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_evaluate[0])
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super(Application, cls).__new__(cls, *args, **options)
    sentinel = object()
    objnargs = getattr(obj, 'nargs', sentinel)
    if objnargs is not sentinel:
        if is_sequence(objnargs):
            nargs = tuple(ordered(set(objnargs)))
        elif objnargs is not None:
            nargs = (as_int(objnargs),)
        else:
            nargs = None
    else:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.functions.elementary.complexes.re.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_extended_real:
        return arg
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:
        return S.Zero
    elif arg.is_Matrix:
        return arg.as_real_imag()[0]
    elif arg.is_Function and isinstance(arg, conjugate):
        return re(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_extended_real:
                    reverted.append(coeff)
            elif not term.has(S.ImaginaryUnit) and term.is_extended_real:
                excluded.append(term)
            else:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[0])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) - im(b) + c

.sympy.functions.elementary.complexes.im.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_extended_real:
        return S.Zero
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:
        return -S.ImaginaryUnit * arg
    elif arg.is_Matrix:
        return arg.as_real_imag()[1]
    elif arg.is_Function and isinstance(arg, conjugate):
        return -im(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_extended_real:
                    reverted.append(coeff)
                else:
                    excluded.append(coeff)
            elif term.has(S.ImaginaryUnit) or not term.is_extended_real:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[1])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) + re(b) + c

.sympy.core.numbers.Float.__lt__

def __lt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__gt__(self)
    rv = self._Frel(other, mlib.mpf_lt)
    if rv is None:
        return Expr.__lt__(self, other)
    return rv

.sympy.core.numbers.Float._Frel

def _Frel(self, other, op):
    from sympy.core.evalf import evalf
    from sympy.core.numbers import prec_to_dps
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Rational:
        '\n        >>> f = Float(.1,2)\n        >>> i = 1234567890\n        >>> (f*i)._mpf_\n        (0, 471, 18, 9)\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\n        (0, 505555550955, -12, 39)\n        '
        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
        ompf = mlib.from_int(other.p)
        return _sympify(bool(op(smpf, ompf)))
    elif other.is_Float:
        return _sympify(bool(op(self._mpf_, other._mpf_)))
    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):
        other = other.evalf(prec_to_dps(self._prec))
        if other._prec > 1:
            if other.is_Number:
                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))

.sympy.logic.boolalg.BooleanFalse.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.function._coeff_isneg

def _coeff_isneg(a):
    if a.is_MatMul:
        a = a.args[0]
    if a.is_Mul:
        a = a.args[0]
    return a.is_Number and a.is_extended_negative

.sympy.core.expr.Expr._eval_power

def _eval_power(self, other):
    return None

.sympy.core.power.Pow._eval_expand_power_base

def _eval_expand_power_base(self, **hints):
    force = hints.get('force', False)
    b = self.base
    e = self.exp
    if not b.is_Mul:
        return self
    cargs, nc = b.args_cnc(split_1=False)
    if nc:
        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]
        if e.is_Integer:
            if e.is_positive:
                rv = Mul(*nc * e)
            else:
                rv = Mul(*[i ** (-1) for i in nc[::-1]] * -e)
            if cargs:
                rv *= Mul(*cargs) ** e
            return rv
        if not cargs:
            return self.func(Mul(*nc), e, evaluate=False)
        nc = [Mul(*nc)]
    other, maybe_real = sift(cargs, lambda x: x.is_extended_real is False, binary=True)

    def pred(x):
        if x is S.ImaginaryUnit:
            return S.ImaginaryUnit
        polar = x.is_polar
        if polar:
            return True
        if polar is None:
            return fuzzy_bool(x.is_extended_nonnegative)
    sifted = sift(maybe_real, pred)
    nonneg = sifted[True]
    other += sifted[None]
    neg = sifted[False]
    imag = sifted[S.ImaginaryUnit]
    if imag:
        I = S.ImaginaryUnit
        i = len(imag) % 4
        if i == 0:
            pass
        elif i == 1:
            other.append(I)
        elif i == 2:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
        else:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
            other.append(I)
        del imag
    if force or e.is_integer:
        cargs = nonneg + neg + other
        other = nc
    else:
        assert not e.is_Integer
        if len(neg) > 1:
            o = S.One
            if not other and neg[0].is_Number:
                o *= neg.pop(0)
            if len(neg) % 2:
                o = -o
            for n in neg:
                nonneg.append(-n)
            if o is not S.One:
                other.append(o)
        elif neg and other:
            if neg[0].is_Number and neg[0] is not S.NegativeOne:
                other.append(S.NegativeOne)
                nonneg.append(-neg[0])
            else:
                other.extend(neg)
        else:
            other.extend(neg)
        del neg
        cargs = nonneg
        other += nc
    rv = S.One
    if cargs:
        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])
    if other:
        rv *= self.func(Mul(*other), e, evaluate=False)
    return rv

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.core.power.Pow._eval_expand_power_exp

def _eval_expand_power_exp(self, **hints):
    b = self.base
    e = self.exp
    if e.is_Add and e.is_commutative:
        expr = []
        for x in e.args:
            expr.append(self.func(self.base, x))
        return Mul(*expr)
    return self.func(b, e)

.sympy.core.add.Add.as_numer_denom

def as_numer_denom(self):
    content, expr = self.primitive()
    ncon, dcon = content.as_numer_denom()
    nd = defaultdict(list)
    for f in expr.args:
        ni, di = f.as_numer_denom()
        nd[di].append(ni)
    if len(nd) == 1:
        d, n = nd.popitem()
        return (self.func(*[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d))
    for d, n in nd.items():
        if len(n) == 1:
            nd[d] = n[0]
        else:
            nd[d] = self.func(*n)
    denoms, numers = [list(i) for i in zip(*iter(nd.items()))]
    n, d = (self.func(*[Mul(*denoms[:i] + [numers[i]] + denoms[i + 1:]) for i in range(len(numers))]), Mul(*denoms))
    return (_keep_coeff(ncon, n), _keep_coeff(dcon, d))

.sympy.core.add.Add.primitive

def primitive(self):
    terms = []
    inf = False
    for a in self.args:
        c, m = a.as_coeff_Mul()
        if not c.is_Rational:
            c = S.One
            m = a
        inf = inf or m is S.ComplexInfinity
        terms.append((c.p, c.q, m))
    if not inf:
        ngcd = reduce(igcd, [t[0] for t in terms], 0)
        dlcm = reduce(ilcm, [t[1] for t in terms], 1)
    else:
        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)
        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)
    if ngcd == dlcm == 1:
        return (S.One, self)
    if not inf:
        for i, (p, q, term) in enumerate(terms):
            terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)
    else:
        for i, (p, q, term) in enumerate(terms):
            if q:
                terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)
            else:
                terms[i] = _keep_coeff(Rational(p, q), term)
    if terms[0].is_Number or terms[0] is S.ComplexInfinity:
        c = terms.pop(0)
    else:
        c = None
    _addsort(terms)
    if c:
        terms.insert(0, c)
    return (Rational(ngcd, dlcm), self._new_rawargs(*terms))

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_extended_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, **kwargs):
    if kwargs.pop('reeval', True) and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.core.numbers.igcd

def igcd(*args):
    if len(args) < 2:
        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))
    args_temp = [abs(as_int(i)) for i in args]
    if 1 in args_temp:
        return 1
    a = args_temp.pop()
    for b in args_temp:
        a = igcd2(a, b) if b else a
    return a

.sympy.core.numbers.ilcm

def ilcm(*args):
    if len(args) < 2:
        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))
    if 0 in args:
        return 0
    a = args[0]
    for b in args[1:]:
        a = a // igcd(a, b) * b
    return a

.sympy.core.power.Pow.as_numer_denom

def as_numer_denom(self):
    if not self.is_commutative:
        return (self, S.One)
    base, exp = self.as_base_exp()
    n, d = base.as_numer_denom()
    neg_exp = exp.is_negative
    if not neg_exp and (not (-exp).is_negative):
        neg_exp = _coeff_isneg(exp)
    int_exp = exp.is_integer
    if not (d.is_extended_real or int_exp):
        n = base
        d = S.One
    dnonpos = d.is_nonpositive
    if dnonpos:
        n, d = (-n, -d)
    elif dnonpos is None and (not int_exp):
        n = base
        d = S.One
    if neg_exp:
        n, d = (d, n)
        exp = -exp
    if exp.is_infinite:
        if n is S.One and d is not S.One:
            return (n, self.func(d, exp))
        if n is not S.One and d is S.One:
            return (self.func(n, exp), d)
    return (self.func(n, exp), self.func(d, exp))

.sympy.core.numbers.Integer.__neg__

def __neg__(self):
    return Integer(-self.p)

.sympy.core.numbers.Integer.__abs__

def __abs__(self):
    if self.p >= 0:
        return self
    else:
        return Integer(-self.p)

.sympy.core.add.Add.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    from sympy.tensor.tensor import TensExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        if a.is_Rational:
            if b.is_Mul:
                rv = ([a, b], [], None)
        if rv:
            if all((s.is_commutative for s in rv[0])):
                return rv
            return ([], rv[0], None)
    terms = {}
    coeff = S.Zero
    order_factors = []
    extra = []
    for o in seq:
        if o.is_Order:
            for o1 in order_factors:
                if o1.contains(o):
                    o = None
                    break
            if o is None:
                continue
            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]
            continue
        elif o.is_Number:
            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):
                return ([S.NaN], [], None)
            if coeff.is_Number:
                coeff += o
                if coeff is S.NaN and (not extra):
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__add__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            extra.append(o)
            continue
        elif isinstance(o, TensExpr):
            coeff = o.__add__(coeff) if coeff else o
            continue
        elif o is S.ComplexInfinity:
            if coeff.is_finite is False and (not extra):
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o.is_Add:
            seq.extend(o.args)
            continue
        elif o.is_Mul:
            c, s = o.as_coeff_Mul()
        elif o.is_Pow:
            b, e = o.as_base_exp()
            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):
                seq.append(b ** e)
                continue
            c, s = (S.One, o)
        else:
            c = S.One
            s = o
        if s in terms:
            terms[s] += c
            if terms[s] is S.NaN and (not extra):
                return ([S.NaN], [], None)
        else:
            terms[s] = c
    newseq = []
    noncommutative = False
    for s, c in terms.items():
        if c.is_zero:
            continue
        elif c is S.One:
            newseq.append(s)
        elif s.is_Mul:
            cs = s._new_rawargs(*(c,) + s.args)
            newseq.append(cs)
        elif s.is_Add:
            newseq.append(Mul(c, s, evaluate=False))
        else:
            newseq.append(Mul(c, s))
        noncommutative = noncommutative or not s.is_commutative
    if coeff is S.Infinity:
        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]
    elif coeff is S.NegativeInfinity:
        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]
    if coeff is S.ComplexInfinity:
        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]
    if order_factors:
        newseq2 = []
        for t in newseq:
            for o in order_factors:
                if o.contains(t):
                    t = None
                    break
            if t is not None:
                newseq2.append(t)
        newseq = newseq2 + order_factors
        for o in order_factors:
            if o.contains(coeff):
                coeff = S.Zero
                break
    _addsort(newseq)
    if coeff is not S.Zero:
        newseq.insert(0, coeff)
    if extra:
        newseq += extra
        noncommutative = True
    if noncommutative:
        return ([], newseq, None)
    else:
        return (newseq, [], None)

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.core.add._addsort

def _addsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.numbers.Rational._hashable_content

def _hashable_content(self):
    return (self.p, self.q)

.sympy.core.add.Add.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(radical=radical, clear=clear)) for a in self.args]).primitive()
    if not clear and (not con.is_Integer) and prim.is_Add:
        con, d = con.as_numer_denom()
        _p = prim / d
        if any((a.as_coeff_Mul()[0].is_Integer for a in _p.args)):
            prim = _p
        else:
            con /= d
    if radical and prim.is_Add:
        args = prim.args
        rads = []
        common_q = None
        for m in args:
            term_rads = defaultdict(list)
            for ai in Mul.make_args(m):
                if ai.is_Pow:
                    b, e = ai.as_base_exp()
                    if e.is_Rational and b.is_Integer:
                        term_rads[e.q].append(abs(int(b)) ** e.p)
            if not term_rads:
                break
            if common_q is None:
                common_q = set(term_rads.keys())
            else:
                common_q = common_q & set(term_rads.keys())
                if not common_q:
                    break
            rads.append(term_rads)
        else:
            for r in rads:
                for q in list(r.keys()):
                    if q not in common_q:
                        r.pop(q)
                for q in r:
                    r[q] = prod(r[q])
            G = []
            for q in common_q:
                g = reduce(igcd, [r[q] for r in rads], 0)
                if g != 1:
                    G.append(g ** Rational(1, q))
            if G:
                G = Mul(*G)
                args = [ai / G for ai in args]
                prim = G * prim.func(*args)
    return (con, prim)

.sympy.core.numbers.Rational.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))
        elif isinstance(other, Float):
            return other * self
        else:
            return Number.__mul__(self, other)
    return Number.__mul__(self, other)

.sympy.core.numbers.Number.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.Infinity
            else:
                return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.NegativeInfinity
            else:
                return S.Infinity
    elif isinstance(other, Tuple):
        return NotImplemented
    return AtomicExpr.__mul__(self, other)

.sympy.core.decorators._SympifyWrapper._func

def _func(self, other):
    if not hasattr(other, '_op_priority'):
        try:
            other = sympify(other, strict=True)
        except SympifyError:
            return retval
    if not isinstance(other, expectedcls):
        return retval
    return func(self, other)

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            f = getattr(other, method_name, None)
            if f is not None:
                return f(self)
    return func(self, other)

.sympy.core.expr.Expr.__mul__

def __mul__(self, other):
    return Mul(self, other)

.sympy.core.power.Pow.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    b, e = self.as_base_exp()
    b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))
    ce, pe = e.as_content_primitive(radical=radical, clear=clear)
    if b.is_Rational:
        h, t = pe.as_coeff_Add()
        if h.is_Rational:
            ceh = ce * h
            c = self.func(b, ceh)
            r = S.Zero
            if not c.is_Rational:
                iceh, r = divmod(ceh.p, ceh.q)
                c = self.func(b, iceh)
            return (c, self.func(b, _keep_coeff(ce, t + r / ce / ceh.q)))
    e = _keep_coeff(ce, pe)
    if e.is_Rational and b.is_Mul:
        h, t = b.as_content_primitive(radical=radical, clear=clear)
        c, m = self.func(h, e).as_coeff_Mul()
        m, me = m.as_base_exp()
        if m is S.One or me == e:
            return (c, self.func(_keep_coeff(m, t), e))
    return (S.One, self.func(b, e))

.sympy.core.expr.Expr.extract_multiplicatively

def extract_multiplicatively(self, c):
    from .add import _unevaluated_Add
    c = sympify(c)
    if self is S.NaN:
        return None
    if c is S.One:
        return self
    elif c == self:
        return S.One
    if c.is_Add:
        cc, pc = c.primitive()
        if cc is not S.One:
            c = Mul(cc, pc, evaluate=False)
    if c.is_Mul:
        a, b = c.as_two_terms()
        x = self.extract_multiplicatively(a)
        if x is not None:
            return x.extract_multiplicatively(b)
        else:
            return x
    quotient = self / c
    if self.is_Number:
        if self is S.Infinity:
            if c.is_positive:
                return S.Infinity
        elif self is S.NegativeInfinity:
            if c.is_negative:
                return S.Infinity
            elif c.is_positive:
                return S.NegativeInfinity
        elif self is S.ComplexInfinity:
            if not c.is_zero:
                return S.ComplexInfinity
        elif self.is_Integer:
            if not quotient.is_Integer:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
        elif self.is_Rational:
            if not quotient.is_Rational:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
        elif self.is_Float:
            if not quotient.is_Float:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
        if quotient.is_Mul and len(quotient.args) == 2:
            if quotient.args[0].is_Integer and quotient.args[0].is_positive and (quotient.args[1] == self):
                return quotient
        elif quotient.is_Integer and c.is_Number:
            return quotient
    elif self.is_Add:
        cs, ps = self.primitive()
        if c.is_Number and c is not S.NegativeOne:
            if cs is not S.One:
                if c.is_negative:
                    xc = -cs.extract_multiplicatively(-c)
                else:
                    xc = cs.extract_multiplicatively(c)
                if xc is not None:
                    return xc * ps
            return
        if c == ps:
            return cs
        newargs = []
        for arg in ps.args:
            newarg = arg.extract_multiplicatively(c)
            if newarg is None:
                return
            newargs.append(newarg)
        if cs is not S.One:
            args = [cs * t for t in newargs]
            return _unevaluated_Add(*args)
        else:
            return Add._from_args(newargs)
    elif self.is_Mul:
        args = list(self.args)
        for i, arg in enumerate(args):
            newarg = arg.extract_multiplicatively(c)
            if newarg is not None:
                args[i] = newarg
                return Mul(*args)
    elif self.is_Pow:
        if c.is_Pow and c.base == self.base:
            new_exp = self.exp.extract_additively(c.exp)
            if new_exp is not None:
                return self.base ** new_exp
        elif c == self.base:
            new_exp = self.exp.extract_additively(1)
            if new_exp is not None:
                return self.base ** new_exp

.sympy.core.mul.Mul.as_base_exp

def as_base_exp(self):
    e1 = None
    bases = []
    nc = 0
    for m in self.args:
        b, e = m.as_base_exp()
        if not b.is_commutative:
            nc += 1
        if e1 is None:
            e1 = e
        elif e != e1 or nc > 1:
            return (self, S.One)
        bases.append(b)
    return (self.func(*bases), e1)

.sympy.core.exprtools.gcd_terms

def gcd_terms(terms, isprimitive=False, clear=True, fraction=True):

    def mask(terms):
        args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]
        reps = []
        for i, (c, nc) in enumerate(args):
            if nc:
                nc = Mul(*nc)
                d = Dummy()
                reps.append((d, nc))
                c.append(d)
                args[i] = Mul(*c)
            else:
                args[i] = c
        return (args, dict(reps))
    isadd = isinstance(terms, Add)
    addlike = isadd or (not isinstance(terms, Basic) and is_sequence(terms, include=set) and (not isinstance(terms, Dict)))
    if addlike:
        if isadd:
            terms = list(terms.args)
        else:
            terms = sympify(terms)
        terms, reps = mask(terms)
        cont, numer, denom = _gcd_terms(terms, isprimitive, fraction)
        numer = numer.xreplace(reps)
        coeff, factors = cont.as_coeff_Mul()
        if not clear:
            c, _coeff = coeff.as_coeff_Mul()
            if not c.is_Integer and (not clear) and numer.is_Add:
                n, d = c.as_numer_denom()
                _numer = numer / d
                if any((a.as_coeff_Mul()[0].is_Integer for a in _numer.args)):
                    numer = _numer
                    coeff = n * _coeff
        return _keep_coeff(coeff, factors * numer / denom, clear=clear)
    if not isinstance(terms, Basic):
        return terms
    if terms.is_Atom:
        return terms
    if terms.is_Mul:
        c, args = terms.as_coeff_mul()
        return _keep_coeff(c, Mul(*[gcd_terms(i, isprimitive, clear, fraction) for i in args]), clear=clear)

    def handle(a):
        if not isinstance(a, Expr):
            if isinstance(a, Basic):
                return a.func(*[handle(i) for i in a.args])
            return type(a)([handle(i) for i in a])
        return gcd_terms(a, isprimitive, clear, fraction)
    if isinstance(terms, Dict):
        return Dict(*[(k, handle(v)) for k, v in terms.args])
    return terms.func(*[handle(i) for i in terms.args])

.sympy.core.exprtools.mask

def mask(terms):
    args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]
    reps = []
    for i, (c, nc) in enumerate(args):
        if nc:
            nc = Mul(*nc)
            d = Dummy()
            reps.append((d, nc))
            c.append(d)
            args[i] = Mul(*c)
        else:
            args[i] = c
    return (args, dict(reps))

.sympy.core.exprtools._gcd_terms

def _gcd_terms(terms, isprimitive=False, fraction=True):
    if isinstance(terms, Basic) and (not isinstance(terms, Tuple)):
        terms = Add.make_args(terms)
    terms = list(map(Term, [t for t in terms if t]))
    if len(terms) == 0:
        return (S.Zero, S.Zero, S.One)
    if len(terms) == 1:
        cont = terms[0].coeff
        numer = terms[0].numer.as_expr()
        denom = terms[0].denom.as_expr()
    else:
        cont = terms[0]
        for term in terms[1:]:
            cont = cont.gcd(term)
        for i, term in enumerate(terms):
            terms[i] = term.quo(cont)
        if fraction:
            denom = terms[0].denom
            for term in terms[1:]:
                denom = denom.lcm(term.denom)
            numers = []
            for term in terms:
                numer = term.numer.mul(denom.quo(term.denom))
                numers.append(term.coeff * numer.as_expr())
        else:
            numers = [t.as_expr() for t in terms]
            denom = Term(S.One).numer
        cont = cont.as_expr()
        numer = Add(*numers)
        denom = denom.as_expr()
    if not isprimitive and numer.is_Add:
        _cont, numer = numer.primitive()
        cont *= _cont
    return (cont, numer, denom)

.sympy.core.exprtools.Term.__init__

def __init__(self, term, numer=None, denom=None):
    if numer is None and denom is None:
        if not term.is_commutative:
            raise NonCommutativeExpression('commutative expression expected')
        coeff, factors = term.as_coeff_mul()
        numer, denom = (defaultdict(int), defaultdict(int))
        for factor in factors:
            base, exp = decompose_power(factor)
            if base.is_Add:
                cont, base = base.primitive()
                coeff *= cont ** exp
            if exp > 0:
                numer[base] += exp
            else:
                denom[base] += -exp
        numer = Factors(numer)
        denom = Factors(denom)
    else:
        coeff = term
        if numer is None:
            numer = Factors()
        if denom is None:
            denom = Factors()
    self.coeff = coeff
    self.numer = numer
    self.denom = denom

.sympy.core.numbers.Number.as_coeff_mul

def as_coeff_mul(self, *deps, **kwargs):
    if self.is_Rational or not kwargs.pop('rational', True):
        return (self, tuple())
    elif self.is_negative:
        return (S.NegativeOne, (-self,))
    return (S.One, (self,))

.sympy.core.exprtools.Factors.__init__

def __init__(self, factors=None):
    if isinstance(factors, (SYMPY_INTS, float)):
        factors = S(factors)
    if isinstance(factors, Factors):
        factors = factors.factors.copy()
    elif factors is None or factors is S.One:
        factors = {}
    elif factors is S.Zero or factors == 0:
        factors = {S.Zero: S.One}
    elif isinstance(factors, Number):
        n = factors
        factors = {}
        if n < 0:
            factors[S.NegativeOne] = S.One
            n = -n
        if n is not S.One:
            if n.is_Float or n.is_Integer or n is S.Infinity:
                factors[n] = S.One
            elif n.is_Rational:
                if n.p != 1:
                    factors[Integer(n.p)] = S.One
                factors[Integer(n.q)] = S.NegativeOne
            else:
                raise ValueError('Expected Float|Rational|Integer, not %s' % n)
    elif isinstance(factors, Basic) and (not factors.args):
        factors = {factors: S.One}
    elif isinstance(factors, Expr):
        c, nc = factors.args_cnc()
        i = c.count(I)
        for _ in range(i):
            c.remove(I)
        factors = dict(Mul._from_args(c).as_powers_dict())
        for f in list(factors.keys()):
            if isinstance(f, Rational) and (not isinstance(f, Integer)):
                p, q = (Integer(f.p), Integer(f.q))
                factors[p] = (factors[p] if p in factors else S.Zero) + factors[f]
                factors[q] = (factors[q] if q in factors else S.Zero) - factors[f]
                factors.pop(f)
        if i:
            factors[I] = S.One * i
        if nc:
            factors[Mul(*nc, evaluate=False)] = S.One
    else:
        factors = factors.copy()
        handle = []
        for k in factors:
            if k is I or k in (-1, 1):
                handle.append(k)
        if handle:
            i1 = S.One
            for k in handle:
                if not _isnumber(factors[k]):
                    continue
                i1 *= k ** factors.pop(k)
            if i1 is not S.One:
                for a in i1.args if i1.is_Mul else [i1]:
                    if a is S.NegativeOne:
                        factors[a] = S.One
                    elif a is I:
                        factors[I] = S.One
                    elif a.is_Pow:
                        if S.NegativeOne not in factors:
                            factors[S.NegativeOne] = S.Zero
                        factors[S.NegativeOne] += a.exp
                    elif a == 1:
                        factors[a] = S.One
                    elif a == -1:
                        factors[-a] = S.One
                        factors[S.NegativeOne] = S.One
                    else:
                        raise ValueError('unexpected factor in i1: %s' % a)
    self.factors = factors
    keys = getattr(factors, 'keys', None)
    if keys is None:
        raise TypeError('expecting Expr or dictionary')
    self.gens = frozenset(keys())

.sympy.core.mul.Mul.as_coeff_mul

def as_coeff_mul(self, *deps, **kwargs):
    if deps:
        from sympy.utilities.iterables import sift
        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)
        return (self._new_rawargs(*l2), tuple(l1))
    rational = kwargs.pop('rational', True)
    args = self.args
    if args[0].is_Number:
        if not rational or args[0].is_Rational:
            return (args[0], args[1:])
        elif args[0].is_extended_negative:
            return (S.NegativeOne, (-args[0],) + args[1:])
    return (S.One, args)

.sympy.core.exprtools.Term.gcd

def gcd(self, other):
    return Term(self.coeff.gcd(other.coeff), self.numer.gcd(other.numer), self.denom.gcd(other.denom))

.sympy.core.numbers.Rational.gcd

def gcd(self, other):
    if isinstance(other, Rational):
        if other == S.Zero:
            return other
        return Rational(Integer(igcd(self.p, other.p)), Integer(ilcm(self.q, other.q)))
    return Number.gcd(self, other)

.sympy.core.exprtools.Factors.gcd

def gcd(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
        if other.is_zero:
            return Factors(self.factors)
    factors = {}
    for factor, exp in self.factors.items():
        factor, exp = (sympify(factor), sympify(exp))
        if factor in other.factors:
            lt = (exp - other.factors[factor]).is_negative
            if lt == True:
                factors[factor] = exp
            elif lt == False:
                factors[factor] = other.factors[factor]
    return Factors(factors)

.sympy.core.exprtools.Term.quo

def quo(self, other):
    return self.mul(other.inv())

.sympy.core.exprtools.Term.inv

def inv(self):
    return Term(1 / self.coeff, self.denom, self.numer)

.sympy.core.expr.Expr.__rdiv__

def __rdiv__(self, other):
    return Mul(other, Pow(self, S.NegativeOne))

.sympy.core.numbers.NegativeOne.__abs__

def __abs__():
    return S.One

.sympy.core.exprtools.Term.mul

def mul(self, other):
    coeff = self.coeff * other.coeff
    numer = self.numer.mul(other.numer)
    denom = self.denom.mul(other.denom)
    numer, denom = numer.normal(denom)
    return Term(coeff, numer, denom)

.sympy.core.exprtools.Factors.mul

def mul(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
    if any((f.is_zero for f in (self, other))):
        return Factors(S.Zero)
    factors = dict(self.factors)
    for factor, exp in other.factors.items():
        if factor in factors:
            exp = factors[factor] + exp
            if not exp:
                del factors[factor]
                continue
        factors[factor] = exp
    return Factors(factors)

.sympy.core.exprtools.Factors.is_zero

def is_zero(self):
    f = self.factors
    return len(f) == 1 and S.Zero in f

.sympy.core.exprtools.Factors.normal

def normal(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
        if other.is_zero:
            return (Factors(), Factors(S.Zero))
        if self.is_zero:
            return (Factors(S.Zero), Factors())
    self_factors = dict(self.factors)
    other_factors = dict(other.factors)
    for factor, self_exp in self.factors.items():
        try:
            other_exp = other.factors[factor]
        except KeyError:
            continue
        exp = self_exp - other_exp
        if not exp:
            del self_factors[factor]
            del other_factors[factor]
        elif _isnumber(exp):
            if exp > 0:
                self_factors[factor] = exp
                del other_factors[factor]
            else:
                del self_factors[factor]
                other_factors[factor] = -exp
        else:
            r = self_exp.extract_additively(other_exp)
            if r is not None:
                if r:
                    self_factors[factor] = r
                    del other_factors[factor]
                else:
                    del self_factors[factor]
                    del other_factors[factor]
            else:
                sc, sa = self_exp.as_coeff_Add()
                if sc:
                    oc, oa = other_exp.as_coeff_Add()
                    diff = sc - oc
                    if diff > 0:
                        self_factors[factor] -= oc
                        other_exp = oa
                    elif diff < 0:
                        self_factors[factor] -= sc
                        other_factors[factor] -= sc
                        other_exp = oa - diff
                    else:
                        self_factors[factor] = sa
                        other_exp = oa
                if other_exp:
                    other_factors[factor] = other_exp
                else:
                    del other_factors[factor]
    return (Factors(self_factors), Factors(other_factors))

.sympy.core.exprtools.Term.as_expr

def as_expr(self):
    return self.coeff * (self.numer.as_expr() / self.denom.as_expr())

.sympy.core.exprtools.Factors.as_expr

def as_expr(self):
    args = []
    for factor, exp in self.factors.items():
        if exp != 1:
            if isinstance(exp, Integer):
                b, e = factor.as_base_exp()
                e = _keep_coeff(exp, e)
                args.append(b ** e)
            else:
                args.append(factor ** exp)
        else:
            args.append(factor)
    return Mul(*args)

.sympy.core.expr.Expr.__div__

def __div__(self, other):
    return Mul(self, Pow(other, S.NegativeOne))

.sympy.core.expr.Expr.__pow__

def __pow__(self, other, mod=None):
    if mod is None:
        return self._pow(other)
    try:
        _self, other, mod = (as_int(self), as_int(other), as_int(mod))
        if other >= 0:
            return pow(_self, other, mod)
        else:
            from sympy.core.numbers import mod_inverse
            return mod_inverse(pow(_self, -other, mod), mod)
    except ValueError:
        power = self._pow(other)
        try:
            return power % mod
        except TypeError:
            return NotImplemented

.sympy.core.expr.Expr._pow

def _pow(self, other):
    return Pow(self, other)

.sympy.core.basic.Basic.xreplace

def xreplace(self, rule):
    value, _ = self._xreplace(rule)
    return value

.sympy.core.basic.Basic._xreplace

def _xreplace(self, rule):
    if self in rule:
        return (rule[self], True)
    elif rule:
        args = []
        changed = False
        for a in self.args:
            _xreplace = getattr(a, '_xreplace', None)
            if _xreplace is not None:
                a_xr = _xreplace(rule)
                args.append(a_xr[0])
                changed |= a_xr[1]
            else:
                args.append(a)
        args = tuple(args)
        if changed:
            return (self.func(*args), True)
    return (self, False)

.sympy.core.add.Add._eval_is_zero

def _eval_is_zero(self):
    if self.is_commutative is False:
        return
    nz = []
    z = 0
    im_or_z = False
    im = False
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                z += 1
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im = True
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_or_z = True
        else:
            return
    if z == len(self.args):
        return True
    if len(nz) == 0 or len(nz) == len(self.args):
        return None
    b = self.func(*nz)
    if b.is_zero:
        if not im_or_z and (not im):
            return True
        if im and (not im_or_z):
            return False
    if b.is_zero is False:
        return False

.sympy.core.mul.Mul._eval_is_extended_real

def _eval_is_extended_real(self):
    return self._eval_real_imag(True)

.sympy.core.mul.Mul._eval_real_imag

def _eval_real_imag(self, real):
    zero = False
    t_not_re_im = None
    for t in self.args:
        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:
            return False
        elif t.is_imaginary:
            real = not real
        elif t.is_extended_real:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_extended_real is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        elif t.is_imaginary is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        else:
            return
    if t_not_re_im:
        if t_not_re_im.is_extended_real is False:
            if real:
                return zero
        if t_not_re_im.is_imaginary is False:
            if not real:
                return zero
    elif zero is False:
        return real
    elif real:
        return real

.sympy.core.mul.Mul._eval_is_complex

def _eval_is_complex(self):
    comp = _fuzzy_group((a.is_complex for a in self.args))
    if comp is False:
        if any((a.is_infinite for a in self.args)):
            if any((a.is_zero is not False for a in self.args)):
                return None
            return False
    return comp

.sympy.core.numbers.Rational.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p + self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return other + self
        else:
            return Number.__add__(self, other)
    return Number.__add__(self, other)

.sympy.core.numbers.Number.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            return S.Infinity
        elif other is S.NegativeInfinity:
            return S.NegativeInfinity
    return AtomicExpr.__add__(self, other)

.sympy.core.expr.Expr.__add__

def __add__(self, other):
    return Add(self, other)

.sympy.core.add.Add._eval_is_odd

def _eval_is_odd(self):
    l = [f for f in self.args if not f.is_even is True]
    if not l:
        return False
    if l[0].is_odd:
        return self._new_rawargs(*l[1:]).is_even

.sympy.core.add.Add._eval_is_imaginary

def _eval_is_imaginary(self):
    nz = []
    im_I = []
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                pass
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im_I.append(a * S.ImaginaryUnit)
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_I.append(a * S.ImaginaryUnit)
        else:
            return
    b = self.func(*nz)
    if b.is_zero:
        return fuzzy_not(self.func(*im_I).is_zero)
    elif b.is_zero is False:
        return False

.sympy.core.add.Add._eval_is_extended_nonnegative

def _eval_is_extended_nonnegative(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonnegative:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonnegative:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonnegative:
                        return True

.sympy.core.add.Add.as_coeff_Add

def as_coeff_Add(self, rational=False, deps=None):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number and (not rational) or coeff.is_Rational:
        return (coeff, self._new_rawargs(*args))
    return (S.Zero, self)

.sympy.core.add.Add._eval_is_extended_negative

def _eval_is_extended_negative(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_extended_negative()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_negative and a.is_extended_nonpositive:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_negative:
                    return True
    neg = nonpos = nonneg = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        isneg = a.is_extended_negative
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))
            if True in saw_INF and False in saw_INF:
                return
        if isneg:
            neg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonneg and (not nonpos) and neg:
        return True
    elif not nonneg and neg:
        return True
    elif not neg and (not nonpos):
        return False

.sympy.core.exprtools._monotonic_sign

def _monotonic_sign(self):
    if not self.is_extended_real:
        return
    if (-self).is_Symbol:
        rv = _monotonic_sign(-self)
        return rv if rv is None else -rv
    if not self.is_Add and self.as_numer_denom()[1].is_number:
        s = self
        if s.is_prime:
            if s.is_odd:
                return S(3)
            else:
                return S(2)
        elif s.is_composite:
            if s.is_odd:
                return S(9)
            else:
                return S(4)
        elif s.is_positive:
            if s.is_even:
                if s.is_prime is False:
                    return S(4)
                else:
                    return S(2)
            elif s.is_integer:
                return S.One
            else:
                return _eps
        elif s.is_extended_negative:
            if s.is_even:
                return S(-2)
            elif s.is_integer:
                return S.NegativeOne
            else:
                return -_eps
        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:
            return S.Zero
        return None
    free = self.free_symbols
    if len(free) == 1:
        if self.is_polynomial():
            from sympy.polys.polytools import real_roots
            from sympy.polys.polyroots import roots
            from sympy.polys.polyerrors import PolynomialError
            x = free.pop()
            x0 = _monotonic_sign(x)
            if x0 == _eps or x0 == -_eps:
                x0 = S.Zero
            if x0 is not None:
                d = self.diff(x)
                if d.is_number:
                    currentroots = []
                else:
                    try:
                        currentroots = real_roots(d)
                    except (PolynomialError, NotImplementedError):
                        currentroots = [r for r in roots(d, x) if r.is_extended_real]
                y = self.subs(x, x0)
                if x.is_nonnegative and all((r <= x0 for r in currentroots)):
                    if y.is_nonnegative and d.is_positive:
                        if y:
                            return y if y.is_positive else Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_negative:
                        if y:
                            return y if y.is_negative else Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
                elif x.is_nonpositive and all((r >= x0 for r in currentroots)):
                    if y.is_nonnegative and d.is_negative:
                        if y:
                            return Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_positive:
                        if y:
                            return Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
        else:
            n, d = self.as_numer_denom()
            den = None
            if n.is_number:
                den = _monotonic_sign(d)
            elif not d.is_number:
                if _monotonic_sign(n) is not None:
                    den = _monotonic_sign(d)
            if den is not None and (den.is_positive or den.is_negative):
                v = n * den
                if v.is_positive:
                    return Dummy('pos', positive=True)
                elif v.is_nonnegative:
                    return Dummy('nneg', nonnegative=True)
                elif v.is_negative:
                    return Dummy('neg', negative=True)
                elif v.is_nonpositive:
                    return Dummy('npos', nonpositive=True)
        return None
    c, a = self.as_coeff_Add()
    v = None
    if not a.is_polynomial():
        n, d = a.as_numer_denom()
        if not (n.is_number or d.is_number):
            return
        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):
            v = S.One
            for ai in Mul.make_args(a):
                if ai.is_number:
                    v *= ai
                    continue
                reps = {}
                for x in ai.free_symbols:
                    reps[x] = _monotonic_sign(x)
                    if reps[x] is None:
                        return
                v *= ai.subs(reps)
    elif c:
        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):
            free = list(a.free_symbols)
            p = {}
            for i in free:
                v = _monotonic_sign(i)
                if v is None:
                    return
                p[i] = v or (_eps if i.is_nonnegative else -_eps)
            v = a.xreplace(p)
    if v is not None:
        rv = v + c
        if v.is_nonnegative and rv.is_positive:
            return rv.subs(_eps, 0)
        if v.is_nonpositive and rv.is_negative:
            return rv.subs(_eps, 0)

.sympy.core.expr.Expr.__neg__

def __neg__(self):
    c = self.is_commutative
    return Mul._from_args((S.NegativeOne, self), c)

.sympy.core.add.Add._eval_is_extended_nonpositive

def _eval_is_extended_nonpositive(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonpositive:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonpositive:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonpositive:
                        return True

.sympy.core.add.Add._eval_is_extended_positive

def _eval_is_extended_positive(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_extended_positive()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_positive and a.is_extended_nonnegative:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_positive:
                    return True
    pos = nonneg = nonpos = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        ispos = a.is_extended_positive
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))
            if True in saw_INF and False in saw_INF:
                return
        if ispos:
            pos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonpos and (not nonneg) and pos:
        return True
    elif not nonpos and pos:
        return True
    elif not pos and (not nonneg):
        return False

.sympy.core.mul.Mul._eval_is_hermitian

def _eval_is_hermitian(self):
    return self._eval_herm_antiherm(True)

.sympy.core.mul.Mul._eval_herm_antiherm

def _eval_herm_antiherm(self, real):
    one_nc = zero = one_neither = False
    for t in self.args:
        if not t.is_commutative:
            if one_nc:
                return
            one_nc = True
        if t.is_antihermitian:
            real = not real
        elif t.is_hermitian:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_hermitian is False:
            if one_neither:
                return
            one_neither = True
        else:
            return
    if one_neither:
        if real:
            return zero
    elif zero is False or real:
        return real

.sympy.core.power.Pow._eval_is_imaginary

def _eval_is_imaginary(self):
    from sympy import arg, log
    if self.base.is_imaginary:
        if self.exp.is_integer:
            odd = self.exp.is_odd
            if odd is not None:
                return odd
            return
    if self.exp.is_imaginary:
        imlog = log(self.base).is_imaginary
        if imlog is not None:
            return False
    if self.base.is_extended_real and self.exp.is_extended_real:
        if self.base.is_positive:
            return False
        else:
            rat = self.exp.is_rational
            if not rat:
                return rat
            if self.exp.is_integer:
                return False
            else:
                half = (2 * self.exp).is_integer
                if half:
                    return self.base.is_negative
                return half
    if self.base.is_extended_real is False:
        i = arg(self.base) * self.exp / S.Pi
        isodd = (2 * i).is_odd
        if isodd is not None:
            return isodd
    if self.exp.is_negative:
        return (1 / self).is_imaginary

.sympy.core.power.Pow._eval_is_positive

def _eval_is_positive(self):
    ext_pos = Pow._eval_is_extended_positive(self)
    if ext_pos is True:
        return self.is_finite
    return ext_pos

.sympy.core.power.Pow._eval_is_extended_positive

def _eval_is_extended_positive(self):
    from sympy import log
    if self.base == self.exp:
        if self.base.is_extended_nonnegative:
            return True
    elif self.base.is_positive:
        if self.exp.is_extended_real:
            return True
    elif self.base.is_extended_negative:
        if self.exp.is_even:
            return True
        if self.exp.is_odd:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return self.exp.is_zero
    elif self.base.is_extended_nonpositive:
        if self.exp.is_odd:
            return False
    elif self.base.is_imaginary:
        if self.exp.is_integer:
            m = self.exp % 4
            if m.is_zero:
                return True
            if m.is_integer and m.is_zero is False:
                return False
        if self.exp.is_imaginary:
            return log(self.base).is_imaginary

.sympy.core.power.Pow._eval_is_complex

def _eval_is_complex(self):
    if all((a.is_complex for a in self.args)) and self._eval_is_finite():
        return True

.sympy.core.power.Pow._eval_is_finite

def _eval_is_finite(self):
    if self.exp.is_negative:
        if self.base.is_zero:
            return False
        if self.base.is_infinite or self.base.is_nonzero:
            return True
    c1 = self.base.is_finite
    if c1 is None:
        return
    c2 = self.exp.is_finite
    if c2 is None:
        return
    if c1 and c2:
        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):
            return True

.sympy.core.power.Pow._eval_is_zero

def _eval_is_zero(self):
    if self.base.is_zero:
        if self.exp.is_extended_positive:
            return True
        elif self.exp.is_extended_nonpositive:
            return False
    elif self.base.is_zero is False:
        if self.exp.is_negative:
            return self.base.is_infinite
        elif self.exp.is_nonnegative:
            return False
        elif self.exp.is_infinite:
            if (1 - abs(self.base)).is_extended_positive:
                return self.exp.is_extended_positive
            elif (1 - abs(self.base)).is_extended_negative:
                return self.exp.is_extended_negative
    else:
        return None

.sympy.core.power.Pow._eval_is_negative

def _eval_is_negative(self):
    ext_neg = Pow._eval_is_extended_negative(self)
    if ext_neg is True:
        return self.is_finite
    return ext_neg

.sympy.core.power.Pow._eval_is_extended_negative

def _eval_is_extended_negative(self):
    if self.base.is_extended_negative:
        if self.exp.is_odd and self.base.is_finite:
            return True
        if self.exp.is_even:
            return False
    elif self.base.is_extended_positive:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_extended_nonnegative:
        if self.exp.is_extended_nonnegative:
            return False
    elif self.base.is_extended_nonpositive:
        if self.exp.is_even:
            return False
    elif self.base.is_extended_real:
        if self.exp.is_even:
            return False

.sympy.core.power.Pow._eval_is_odd

def _eval_is_odd(self):
    if self.exp.is_integer:
        if self.exp.is_positive:
            return self.base.is_odd
        elif self.exp.is_nonnegative and self.base.is_odd:
            return True
        elif self.base is S.NegativeOne:
            return True

.sympy.core.power.Pow._eval_is_extended_real

def _eval_is_extended_real(self):
    from sympy import arg, exp, log, Mul
    real_b = self.base.is_extended_real
    if real_b is None:
        if self.base.func == exp and self.base.args[0].is_imaginary:
            return self.exp.is_imaginary
        return
    real_e = self.exp.is_extended_real
    if real_e is None:
        return
    if real_b and real_e:
        if self.base.is_extended_positive:
            return True
        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:
            return True
        elif self.exp.is_integer and self.base.is_extended_nonzero:
            return True
        elif self.exp.is_integer and self.exp.is_nonnegative:
            return True
        elif self.base.is_extended_negative:
            if self.exp.is_Rational:
                return False
    if real_e and self.exp.is_extended_negative and (self.base.is_zero is False):
        return Pow(self.base, -self.exp).is_extended_real
    im_b = self.base.is_imaginary
    im_e = self.exp.is_imaginary
    if im_b:
        if self.exp.is_integer:
            if self.exp.is_even:
                return True
            elif self.exp.is_odd:
                return False
        elif im_e and log(self.base).is_imaginary:
            return True
        elif self.exp.is_Add:
            c, a = self.exp.as_coeff_Add()
            if c and c.is_Integer:
                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real
        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
            if (self.exp / 2).is_integer is False:
                return False
    if real_b and im_e:
        if self.base is S.NegativeOne:
            return True
        c = self.exp.coeff(S.ImaginaryUnit)
        if c:
            if self.base.is_rational and c.is_rational:
                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:
                    return False
            ok = (c * log(self.base) / S.Pi).is_integer
            if ok is not None:
                return ok
    if real_b is False:
        i = arg(self.base) * self.exp / S.Pi
        return i.is_integer

.sympy.core.power.Pow._eval_is_even

def _eval_is_even(self):
    if self.exp.is_integer and self.exp.is_positive:
        return self.base.is_even

.sympy.core.power.Pow._eval_is_rational

def _eval_is_rational(self):
    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):
        return True
    p = self.func(*self.as_base_exp())
    if not p.is_Pow:
        return p.is_rational
    b, e = p.as_base_exp()
    if e.is_Rational and b.is_Rational:
        return False
    if e.is_integer:
        if b.is_rational:
            if fuzzy_not(b.is_zero) or e.is_nonnegative:
                return True
            if b == e:
                return True
        elif b.is_irrational:
            return e.is_zero

.sympy.core.power.Pow._eval_is_integer

def _eval_is_integer(self):
    b, e = self.args
    if b.is_rational:
        if b.is_integer is False and e.is_positive:
            return False
    if b.is_integer and e.is_integer:
        if b is S.NegativeOne:
            return True
        if e.is_nonnegative or e.is_positive:
            return True
    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
            return False
    if b.is_Number and e.is_Number:
        check = self.func(*self.args)
        return check.is_Integer

.sympy.core.power.Pow._eval_is_prime

def _eval_is_prime(self):
    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:
        return False

.sympy.core.power.Pow._eval_is_composite

def _eval_is_composite(self):
    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):
        return True

.sympy.core.expr.Expr.__sub__

def __sub__(self, other):
    return Add(self, -other)

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.core.add.Add._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all((x.is_rational is True for x in others)):
                return True
            return None
        if a is None:
            return
    return False

.sympy.core.power.Pow._eval_is_algebraic

def _eval_is_algebraic(self):

    def _is_one(expr):
        try:
            return (expr - 1).is_zero
        except ValueError:
            return False
    if self.base.is_zero or _is_one(self.base):
        return True
    elif self.exp.is_rational:
        if self.base.is_algebraic is False:
            return self.exp.is_zero
        if self.base.is_zero is False:
            if self.exp.is_nonzero:
                return self.base.is_algebraic
            elif self.base.is_algebraic:
                return True
        if self.exp.is_positive:
            return self.base.is_algebraic
    elif self.base.is_algebraic and self.exp.is_algebraic:
        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:
            return self.exp.is_rational

.sympy.core.power.Pow._is_one

def _is_one(expr):
    try:
        return (expr - 1).is_zero
    except ValueError:
        return False

.sympy.core.mul.Mul._eval_is_finite

def _eval_is_finite(self):
    if all((a.is_finite for a in self.args)):
        return True
    if any((a.is_infinite for a in self.args)):
        if all((a.is_zero is False for a in self.args)):
            return False

.sympy.core.expr.Expr._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return self._eval_is_extended_positive_negative(positive=True)

.sympy.core.numbers.Float.__gt__

def __gt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__lt__(self)
    rv = self._Frel(other, mlib.mpf_gt)
    if rv is None:
        return Expr.__gt__(self, other)
    return rv

.sympy.core.mul.Mul._eval_is_algebraic

def _eval_is_algebraic(self):
    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.mul.Mul._eval_is_imaginary

def _eval_is_imaginary(self):
    z = self.is_zero
    if z:
        return False
    elif z is False:
        return self._eval_real_imag(False)

.sympy.core.add.Add.__neg__

def __neg__(self):
    if not global_distribute[0]:
        return super(Add, self).__neg__()
    return Add(*[-i for i in self.args])

.sympy.core.mul.Mul.__neg__

def __neg__(self):
    c, args = self.as_coeff_mul()
    c = -c
    if c is not S.One:
        if args[0].is_Number:
            args = list(args)
            if c is S.NegativeOne:
                args[0] = -args[0]
            else:
                args[0] *= c
        else:
            args = (c,) + args
    return self._from_args(args, self.is_commutative)

.sympy.core.add.Add._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    return all((term._eval_is_polynomial(syms) for term in self.args))

.sympy.core.power.Pow._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    if self.exp.has(*syms):
        return False
    if self.base.has(*syms):
        return bool(self.base._eval_is_polynomial(syms) and self.exp.is_Integer and (self.exp >= 0))
    else:
        return True

.sympy.core.numbers.Integer.__ge__

def __ge__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p >= other.p)
    return Rational.__ge__(self, other)

.sympy.core.add.Add.as_coefficients_dict

def as_coefficients_dict(a):
    d = defaultdict(list)
    for ai in a.args:
        c, m = ai.as_coeff_Mul()
        d[m].append(c)
    for k, v in d.items():
        if len(v) == 1:
            d[k] = v[0]
        else:
            d[k] = Add(*v)
    di = defaultdict(int)
    di.update(d)
    return di

.sympy.core.compatibility.is_sequence

def is_sequence(i, include=None):
    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))

.sympy.core.exprtools.Factors.lcm

def lcm(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
        if any((f.is_zero for f in (self, other))):
            return Factors(S.Zero)
    factors = dict(self.factors)
    for factor, exp in other.factors.items():
        if factor in factors:
            exp = max(exp, factors[factor])
        factors[factor] = exp
    return Factors(factors)

.sympy.core.exprtools.Factors.quo

def quo(self, other):
    return self.div(other)[0]

.sympy.core.exprtools.Factors.div

def div(self, other):
    quo, rem = (dict(self.factors), {})
    if not isinstance(other, Factors):
        other = Factors(other)
        if other.is_zero:
            raise ZeroDivisionError
        if self.is_zero:
            return (Factors(S.Zero), Factors())
    for factor, exp in other.factors.items():
        if factor in quo:
            d = quo[factor] - exp
            if _isnumber(d):
                if d <= 0:
                    del quo[factor]
                if d >= 0:
                    if d:
                        quo[factor] = d
                    continue
                exp = -d
            else:
                r = quo[factor].extract_additively(exp)
                if r is not None:
                    if r:
                        quo[factor] = r
                    else:
                        del quo[factor]
                else:
                    other_exp = exp
                    sc, sa = quo[factor].as_coeff_Add()
                    if sc:
                        oc, oa = other_exp.as_coeff_Add()
                        diff = sc - oc
                        if diff > 0:
                            quo[factor] -= oc
                            other_exp = oa
                        elif diff < 0:
                            quo[factor] -= sc
                            other_exp = oa - diff
                        else:
                            quo[factor] = sa
                            other_exp = oa
                    if other_exp:
                        rem[factor] = other_exp
                    else:
                        assert factor not in rem
                continue
        rem[factor] = exp
    return (Factors(quo), Factors(rem))

.sympy.polys.densebasic.dmp_terms_gcd

def dmp_terms_gcd(f, u, K):
    if dmp_ground_TC(f, u, K) or dmp_zero_p(f, u):
        return ((0,) * (u + 1), f)
    F = dmp_to_dict(f, u)
    G = monomial_min(*list(F.keys()))
    if all((g == 0 for g in G)):
        return (G, f)
    f = {}
    for monom, coeff in F.items():
        f[monomial_div(monom, G)] = coeff
    return (G, dmp_from_dict(f, u, K))

.sympy.polys.densebasic.dmp_ground_TC

def dmp_ground_TC(f, u, K):
    while u:
        f = dmp_TC(f, K)
        u -= 1
    return dup_TC(f, K)

.sympy.polys.densetools.dmp_ground_primitive

def dmp_ground_primitive(f, u, K):
    if not u:
        return dup_primitive(f, K)
    if dmp_zero_p(f, u):
        return (K.zero, f)
    cont = dmp_ground_content(f, u, K)
    if K.is_one(cont):
        return (cont, f)
    else:
        return (cont, dmp_quo_ground(f, cont, u, K))

.sympy.polys.densetools.dmp_ground_content

def dmp_ground_content(f, u, K):
    from sympy.polys.domains import QQ
    if not u:
        return dup_content(f, K)
    if dmp_zero_p(f, u):
        return K.zero
    cont, v = (K.zero, u - 1)
    if K == QQ:
        for c in f:
            cont = K.gcd(cont, dmp_ground_content(c, v, K))
    else:
        for c in f:
            cont = K.gcd(cont, dmp_ground_content(c, v, K))
            if K.is_one(cont):
                break
    return cont

.sympy.polys.densebasic.dmp_exclude

def dmp_exclude(f, u, K):
    if not u or dmp_ground_p(f, None, u):
        return ([], f, u)
    J, F = ([], dmp_to_dict(f, u))
    for j in range(0, u + 1):
        for monom in F.keys():
            if monom[j]:
                break
        else:
            J.append(j)
    if not J:
        return ([], f, u)
    f = {}
    for monom, coeff in F.items():
        monom = list(monom)
        for j in reversed(J):
            del monom[j]
        f[tuple(monom)] = coeff
    u -= len(J)
    return (J, dmp_from_dict(f, u, K), u)

.sympy.polys.densebasic.dmp_ground_p

def dmp_ground_p(f, c, u):
    if c is not None and (not c):
        return dmp_zero_p(f, u)
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    if c is None:
        return len(f) <= 1
    else:
        return f == [c]

.sympy.polys.factortools.dmp_zz_factor

def dmp_zz_factor(f, u, K):
    if not u:
        return dup_zz_factor(f, K)
    if dmp_zero_p(f, u):
        return (K.zero, [])
    cont, g = dmp_ground_primitive(f, u, K)
    if dmp_ground_LC(g, u, K) < 0:
        cont, g = (-cont, dmp_neg(g, u, K))
    if all((d <= 0 for d in dmp_degree_list(g, u))):
        return (cont, [])
    G, g = dmp_primitive(g, u, K)
    factors = []
    if dmp_degree(g, u) > 0:
        g = dmp_sqf_part(g, u, K)
        H = dmp_zz_wang(g, u, K)
        factors = dmp_trial_division(f, H, u, K)
    for g, k in dmp_zz_factor(G, u - 1, K)[1]:
        factors.insert(0, ([g], k))
    return (cont, _sort_factors(factors))

.sympy.polys.densebasic.dmp_ground_LC

def dmp_ground_LC(f, u, K):
    while u:
        f = dmp_LC(f, K)
        u -= 1
    return dup_LC(f, K)

.sympy.polys.densebasic.dmp_degree_list

def dmp_degree_list(f, u):
    degs = [-oo] * (u + 1)
    _rec_degree_list(f, u, 0, degs)
    return tuple(degs)

.sympy.polys.densebasic._rec_degree_list

def _rec_degree_list(g, v, i, degs):
    degs[i] = max(degs[i], dmp_degree(g, v))
    if v > 0:
        v, i = (v - 1, i + 1)
        for c in g:
            _rec_degree_list(c, v, i, degs)

.sympy.core.expr.Expr.__lt__

def __lt__(self, other):
    from sympy import StrictLessThan
    return self._cmp(other, '<', StrictLessThan)

.sympy.core.expr.Expr._cmp

def _cmp(self, other, op, cls):
    assert op in ('<', '>', '<=', '>=')
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not isinstance(other, Expr):
        return NotImplemented
    for me in (self, other):
        if me.is_extended_real is False:
            raise TypeError('Invalid comparison of non-real %s' % me)
        if me is S.NaN:
            raise TypeError('Invalid NaN comparison')
    n2 = _n2(self, other)
    if n2 is not None:
        if n2 in (S.Infinity, S.NegativeInfinity):
            n2 = float(n2)
        if op == '<':
            return _sympify(n2 < 0)
        elif op == '>':
            return _sympify(n2 > 0)
        elif op == '<=':
            return _sympify(n2 <= 0)
        else:
            return _sympify(n2 >= 0)
    if self.is_extended_real and other.is_extended_real:
        if op in ('<=', '>') and (self.is_infinite and self.is_extended_negative or (other.is_infinite and other.is_extended_positive)):
            return S.true if op == '<=' else S.false
        if op in ('<', '>=') and (self.is_infinite and self.is_extended_positive or (other.is_infinite and other.is_extended_negative)):
            return S.true if op == '>=' else S.false
        diff = self - other
        if diff is not S.NaN:
            if op == '<':
                test = diff.is_extended_negative
            elif op == '>':
                test = diff.is_extended_positive
            elif op == '<=':
                test = diff.is_extended_nonpositive
            else:
                test = diff.is_extended_nonnegative
            if test is not None:
                return S.true if test == True else S.false
    return cls(self, other, evaluate=False)

.sympy.core.expr._n2

def _n2(a, b):
    if a.is_comparable and b.is_comparable:
        dif = (a - b).evalf(2)
        if dif.is_comparable:
            return dif

.sympy.core.basic.Basic.is_comparable

def is_comparable(self):
    is_extended_real = self.is_extended_real
    if is_extended_real is False:
        return False
    if not self.is_number:
        return False
    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]
    if not (i.is_Number and n.is_Number):
        return False
    if i:
        return False
    else:
        return n._prec != 1

.sympy.core.numbers.NegativeInfinity.__sub__

def __sub__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NegativeInfinity or other is S.NaN:
            return S.NaN
        return self
    return Number.__sub__(self, other)

.sympy.core.numbers.NegativeInfinity.evalf

def evalf(self, prec=None, **options):
    return self._eval_evalf(prec)

.sympy.core.numbers.NegativeInfinity._eval_evalf

def _eval_evalf(self, prec=None):
    return Float('-inf')

.sympy.core.numbers.Number.__float__

def __float__(self):
    return mlib.to_float(self._as_mpf_val(53))

.sympy.core.numbers.NegativeInfinity._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.fninf

.sympy.polys.euclidtools.dmp_primitive

def dmp_primitive(f, u, K):
    cont, v = (dmp_content(f, u, K), u - 1)
    if dmp_zero_p(f, u) or dmp_one_p(cont, v, K):
        return (cont, f)
    else:
        return (cont, [dmp_quo(c, cont, v, K) for c in f])

.sympy.polys.euclidtools.dmp_content

def dmp_content(f, u, K):
    cont, v = (dmp_LC(f, K), u - 1)
    if dmp_zero_p(f, u):
        return cont
    for c in f[1:]:
        cont = dmp_gcd(cont, c, v, K)
        if dmp_one_p(cont, v, K):
            break
    if K.is_negative(dmp_ground_LC(cont, v, K)):
        return dmp_neg(cont, v, K)
    else:
        return cont

.sympy.polys.euclidtools.dmp_gcd

def dmp_gcd(f, g, u, K):
    return dmp_inner_gcd(f, g, u, K)[0]

.sympy.polys.euclidtools.dmp_inner_gcd

def dmp_inner_gcd(f, g, u, K):
    if not u:
        return dup_inner_gcd(f, g, K)
    J, (f, g) = dmp_multi_deflate((f, g), u, K)
    h, cff, cfg = _dmp_inner_gcd(f, g, u, K)
    return (dmp_inflate(h, J, u, K), dmp_inflate(cff, J, u, K), dmp_inflate(cfg, J, u, K))

.sympy.polys.euclidtools.dup_inner_gcd

def dup_inner_gcd(f, g, K):
    if not K.is_Exact:
        try:
            exact = K.get_exact()
        except DomainError:
            return ([K.one], f, g)
        f = dup_convert(f, K, exact)
        g = dup_convert(g, K, exact)
        h, cff, cfg = dup_inner_gcd(f, g, exact)
        h = dup_convert(h, exact, K)
        cff = dup_convert(cff, exact, K)
        cfg = dup_convert(cfg, exact, K)
        return (h, cff, cfg)
    elif K.is_Field:
        if K.is_QQ and query('USE_HEU_GCD'):
            try:
                return dup_qq_heu_gcd(f, g, K)
            except HeuristicGCDFailed:
                pass
        return dup_ff_prs_gcd(f, g, K)
    else:
        if K.is_ZZ and query('USE_HEU_GCD'):
            try:
                return dup_zz_heu_gcd(f, g, K)
            except HeuristicGCDFailed:
                pass
        return dup_rr_prs_gcd(f, g, K)

.sympy.polys.polyconfig.query

def query(key):
    return _current_config.get(key.upper(), None)

.sympy.polys.euclidtools.dup_zz_heu_gcd

def dup_zz_heu_gcd(f, g, K):
    result = _dup_rr_trivial_gcd(f, g, K)
    if result is not None:
        return result
    df = dup_degree(f)
    dg = dup_degree(g)
    gcd, f, g = dup_extract(f, g, K)
    if df == 0 or dg == 0:
        return ([gcd], f, g)
    f_norm = dup_max_norm(f, K)
    g_norm = dup_max_norm(g, K)
    B = K(2 * min(f_norm, g_norm) + 29)
    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dup_LC(f, K)), g_norm // abs(dup_LC(g, K))) + 2)
    for i in range(0, HEU_GCD_MAX):
        ff = dup_eval(f, x, K)
        gg = dup_eval(g, x, K)
        if ff and gg:
            h = K.gcd(ff, gg)
            cff = ff // h
            cfg = gg // h
            h = _dup_zz_gcd_interpolate(h, x, K)
            h = dup_primitive(h, K)[1]
            cff_, r = dup_div(f, h, K)
            if not r:
                cfg_, r = dup_div(g, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff_, cfg_)
            cff = _dup_zz_gcd_interpolate(cff, x, K)
            h, r = dup_div(f, cff, K)
            if not r:
                cfg_, r = dup_div(g, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff, cfg_)
            cfg = _dup_zz_gcd_interpolate(cfg, x, K)
            h, r = dup_div(g, cfg, K)
            if not r:
                cff_, r = dup_div(f, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff_, cfg)
        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011
    raise HeuristicGCDFailed('no luck')

.sympy.polys.euclidtools._dup_rr_trivial_gcd

def _dup_rr_trivial_gcd(f, g, K):
    if not (f or g):
        return ([], [], [])
    elif not f:
        if K.is_nonnegative(dup_LC(g, K)):
            return (g, [], [K.one])
        else:
            return (dup_neg(g, K), [], [-K.one])
    elif not g:
        if K.is_nonnegative(dup_LC(f, K)):
            return (f, [K.one], [])
        else:
            return (dup_neg(f, K), [-K.one], [])
    return None

.sympy.polys.densetools.dup_extract

def dup_extract(f, g, K):
    fc = dup_content(f, K)
    gc = dup_content(g, K)
    gcd = K.gcd(fc, gc)
    if not K.is_one(gcd):
        f = dup_quo_ground(f, gcd, K)
        g = dup_quo_ground(g, gcd, K)
    return (gcd, f, g)

.sympy.polys.densebasic.dmp_one_p

def dmp_one_p(f, u, K):
    return dmp_ground_p(f, K.one, u)

.sympy.polys.domains.domain.Domain.is_negative

def is_negative(self, a):
    return a < 0

.sympy.polys.sqfreetools.dmp_sqf_part

def dmp_sqf_part(f, u, K):
    if not u:
        return dup_sqf_part(f, K)
    if K.is_FiniteField:
        return dmp_gf_sqf_part(f, u, K)
    if dmp_zero_p(f, u):
        return f
    if K.is_negative(dmp_ground_LC(f, u, K)):
        f = dmp_neg(f, u, K)
    gcd = dmp_gcd(f, dmp_diff(f, 1, u, K), u, K)
    sqf = dmp_quo(f, gcd, u, K)
    if K.is_Field:
        return dmp_ground_monic(sqf, u, K)
    else:
        return dmp_ground_primitive(sqf, u, K)[1]

.sympy.polys.densetools.dmp_diff

def dmp_diff(f, m, u, K):
    if not u:
        return dup_diff(f, m, K)
    if m <= 0:
        return f
    n = dmp_degree(f, u)
    if n < m:
        return dmp_zero(u)
    deriv, v = ([], u - 1)
    if m == 1:
        for coeff in f[:-m]:
            deriv.append(dmp_mul_ground(coeff, K(n), v, K))
            n -= 1
    else:
        for coeff in f[:-m]:
            k = n
            for i in range(n - 1, n - m, -1):
                k *= i
            deriv.append(dmp_mul_ground(coeff, K(k), v, K))
            n -= 1
    return dmp_strip(deriv, u)

.sympy.polys.domains.domain.Domain.__call__

def __call__(self, *args):
    return self.new(*args)

.sympy.polys.domains.domain.Domain.new

def new(self, *args):
    return self.dtype(*args)

.sympy.polys.densearith.dmp_mul_ground

def dmp_mul_ground(f, c, u, K):
    if not u:
        return dup_mul_ground(f, c, K)
    v = u - 1
    return [dmp_mul_ground(cf, c, v, K) for cf in f]

.sympy.polys.densearith.dup_mul_ground

def dup_mul_ground(f, c, K):
    if not c or not f:
        return []
    else:
        return [cf * c for cf in f]

.sympy.polys.densebasic.dmp_multi_deflate

def dmp_multi_deflate(polys, u, K):
    if not u:
        M, H = dup_multi_deflate(polys, K)
        return ((M,), H)
    F, B = ([], [0] * (u + 1))
    for p in polys:
        f = dmp_to_dict(p, u)
        if not dmp_zero_p(p, u):
            for M in f.keys():
                for i, m in enumerate(M):
                    B[i] = igcd(B[i], m)
        F.append(f)
    for i, b in enumerate(B):
        if not b:
            B[i] = 1
    B = tuple(B)
    if all((b == 1 for b in B)):
        return (B, polys)
    H = []
    for f in F:
        h = {}
        for A, coeff in f.items():
            N = [a // b for a, b in zip(A, B)]
            h[tuple(N)] = coeff
        H.append(dmp_from_dict(h, u, K))
    return (B, tuple(H))

.sympy.polys.euclidtools._dmp_inner_gcd

def _dmp_inner_gcd(f, g, u, K):
    if not K.is_Exact:
        try:
            exact = K.get_exact()
        except DomainError:
            return (dmp_one(u, K), f, g)
        f = dmp_convert(f, u, K, exact)
        g = dmp_convert(g, u, K, exact)
        h, cff, cfg = _dmp_inner_gcd(f, g, u, exact)
        h = dmp_convert(h, u, exact, K)
        cff = dmp_convert(cff, u, exact, K)
        cfg = dmp_convert(cfg, u, exact, K)
        return (h, cff, cfg)
    elif K.is_Field:
        if K.is_QQ and query('USE_HEU_GCD'):
            try:
                return dmp_qq_heu_gcd(f, g, u, K)
            except HeuristicGCDFailed:
                pass
        return dmp_ff_prs_gcd(f, g, u, K)
    else:
        if K.is_ZZ and query('USE_HEU_GCD'):
            try:
                return dmp_zz_heu_gcd(f, g, u, K)
            except HeuristicGCDFailed:
                pass
        return dmp_rr_prs_gcd(f, g, u, K)

.sympy.polys.euclidtools.dmp_zz_heu_gcd

def dmp_zz_heu_gcd(f, g, u, K):
    if not u:
        return dup_zz_heu_gcd(f, g, K)
    result = _dmp_rr_trivial_gcd(f, g, u, K)
    if result is not None:
        return result
    gcd, f, g = dmp_ground_extract(f, g, u, K)
    f_norm = dmp_max_norm(f, u, K)
    g_norm = dmp_max_norm(g, u, K)
    B = K(2 * min(f_norm, g_norm) + 29)
    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dmp_ground_LC(f, u, K)), g_norm // abs(dmp_ground_LC(g, u, K))) + 2)
    for i in range(0, HEU_GCD_MAX):
        ff = dmp_eval(f, x, u, K)
        gg = dmp_eval(g, x, u, K)
        v = u - 1
        if not (dmp_zero_p(ff, v) or dmp_zero_p(gg, v)):
            h, cff, cfg = dmp_zz_heu_gcd(ff, gg, v, K)
            h = _dmp_zz_gcd_interpolate(h, x, v, K)
            h = dmp_ground_primitive(h, u, K)[1]
            cff_, r = dmp_div(f, h, u, K)
            if dmp_zero_p(r, u):
                cfg_, r = dmp_div(g, h, u, K)
                if dmp_zero_p(r, u):
                    h = dmp_mul_ground(h, gcd, u, K)
                    return (h, cff_, cfg_)
            cff = _dmp_zz_gcd_interpolate(cff, x, v, K)
            h, r = dmp_div(f, cff, u, K)
            if dmp_zero_p(r, u):
                cfg_, r = dmp_div(g, h, u, K)
                if dmp_zero_p(r, u):
                    h = dmp_mul_ground(h, gcd, u, K)
                    return (h, cff, cfg_)
            cfg = _dmp_zz_gcd_interpolate(cfg, x, v, K)
            h, r = dmp_div(g, cfg, u, K)
            if dmp_zero_p(r, u):
                cff_, r = dmp_div(f, h, u, K)
                if dmp_zero_p(r, u):
                    h = dmp_mul_ground(h, gcd, u, K)
                    return (h, cff_, cfg)
        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011
    raise HeuristicGCDFailed('no luck')

.sympy.polys.euclidtools._dmp_rr_trivial_gcd

def _dmp_rr_trivial_gcd(f, g, u, K):
    zero_f = dmp_zero_p(f, u)
    zero_g = dmp_zero_p(g, u)
    if_contain_one = dmp_one_p(f, u, K) or dmp_one_p(g, u, K)
    if zero_f and zero_g:
        return tuple(dmp_zeros(3, u, K))
    elif zero_f:
        if K.is_nonnegative(dmp_ground_LC(g, u, K)):
            return (g, dmp_zero(u), dmp_one(u, K))
        else:
            return (dmp_neg(g, u, K), dmp_zero(u), dmp_ground(-K.one, u))
    elif zero_g:
        if K.is_nonnegative(dmp_ground_LC(f, u, K)):
            return (f, dmp_one(u, K), dmp_zero(u))
        else:
            return (dmp_neg(f, u, K), dmp_ground(-K.one, u), dmp_zero(u))
    elif if_contain_one:
        return (dmp_one(u, K), f, g)
    elif query('USE_SIMPLIFY_GCD'):
        return _dmp_simplify_gcd(f, g, u, K)
    else:
        return None

.sympy.polys.euclidtools._dmp_simplify_gcd

def _dmp_simplify_gcd(f, g, u, K):
    df = dmp_degree(f, u)
    dg = dmp_degree(g, u)
    if df > 0 and dg > 0:
        return None
    if not (df or dg):
        F = dmp_LC(f, K)
        G = dmp_LC(g, K)
    elif not df:
        F = dmp_LC(f, K)
        G = dmp_content(g, u, K)
    else:
        F = dmp_content(f, u, K)
        G = dmp_LC(g, K)
    v = u - 1
    h = dmp_gcd(F, G, v, K)
    cff = [dmp_quo(cf, h, v, K) for cf in f]
    cfg = [dmp_quo(cg, h, v, K) for cg in g]
    return ([h], cff, cfg)

.sympy.polys.densetools.dmp_ground_extract

def dmp_ground_extract(f, g, u, K):
    fc = dmp_ground_content(f, u, K)
    gc = dmp_ground_content(g, u, K)
    gcd = K.gcd(fc, gc)
    if not K.is_one(gcd):
        f = dmp_quo_ground(f, gcd, u, K)
        g = dmp_quo_ground(g, gcd, u, K)
    return (gcd, f, g)

.sympy.polys.densearith.dmp_max_norm

def dmp_max_norm(f, u, K):
    if not u:
        return dup_max_norm(f, K)
    v = u - 1
    return max([dmp_max_norm(c, v, K) for c in f])

.sympy.polys.densearith.dup_max_norm

def dup_max_norm(f, K):
    if not f:
        return K.zero
    else:
        return max(dup_abs(f, K))

.sympy.polys.densearith.dup_abs

def dup_abs(f, K):
    return [K.abs(coeff) for coeff in f]

.sympy.polys.domains.domain.Domain.abs

def abs(self, a):
    return abs(a)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.sqrt

def sqrt(self, a):
    return python_sqrt(a)

.sympy.polys.domains.groundtypes.python_sqrt

def python_sqrt(n):
    return int(mlib.isqrt(n))

.sympy.polys.densetools.dmp_eval

def dmp_eval(f, a, u, K):
    if not u:
        return dup_eval(f, a, K)
    if not a:
        return dmp_TC(f, K)
    result, v = (dmp_LC(f, K), u - 1)
    for coeff in f[1:]:
        result = dmp_mul_ground(result, a, v, K)
        result = dmp_add(result, coeff, v, K)
    return result

.sympy.polys.densearith.dmp_add

def dmp_add(f, g, u, K):
    if not u:
        return dup_add(f, g, K)
    df = dmp_degree(f, u)
    if df < 0:
        return g
    dg = dmp_degree(g, u)
    if dg < 0:
        return f
    v = u - 1
    if df == dg:
        return dmp_strip([dmp_add(a, b, v, K) for a, b in zip(f, g)], u)
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [dmp_add(a, b, v, K) for a, b in zip(f, g)]

.sympy.polys.densearith.dup_add

def dup_add(f, g, K):
    if not f:
        return g
    if not g:
        return f
    df = dup_degree(f)
    dg = dup_degree(g)
    if df == dg:
        return dup_strip([a + b for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [a + b for a, b in zip(f, g)]

.sympy.polys.densetools.dup_eval

def dup_eval(f, a, K):
    if not a:
        return dup_TC(f, K)
    result = K.zero
    for c in f:
        result *= a
        result += c
    return result

.sympy.polys.euclidtools._dup_zz_gcd_interpolate

def _dup_zz_gcd_interpolate(h, x, K):
    f = []
    while h:
        g = h % x
        if g > x // 2:
            g -= x
        f.insert(0, g)
        h = (h - g) // x
    return f

.sympy.polys.densearith.dup_div

def dup_div(f, g, K):
    if K.is_Field:
        return dup_ff_div(f, g, K)
    else:
        return dup_rr_div(f, g, K)

.sympy.polys.densearith.dup_rr_div

def dup_rr_div(f, g, K):
    df = dup_degree(f)
    dg = dup_degree(g)
    q, r, dr = ([], f, df)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return (q, r)
    lc_g = dup_LC(g, K)
    while True:
        lc_r = dup_LC(r, K)
        if lc_r % lc_g:
            break
        c = K.exquo(lc_r, lc_g)
        j = dr - dg
        q = dup_add_term(q, c, j, K)
        h = dup_mul_term(g, c, j, K)
        r = dup_sub(r, h, K)
        _dr, dr = (dr, dup_degree(r))
        if dr < dg:
            break
        elif not dr < _dr:
            raise PolynomialDivisionFailed(f, g, K)
    return (q, r)

.sympy.polys.domains.ring.Ring.exquo

def exquo(self, a, b):
    if a % b:
        raise ExactQuotientFailed(a, b, self)
    else:
        return a // b

.sympy.polys.densearith.dup_add_term

def dup_add_term(f, c, i, K):
    if not c:
        return f
    n = len(f)
    m = n - i - 1
    if i == n - 1:
        return dup_strip([f[0] + c] + f[1:])
    elif i >= n:
        return [c] + [K.zero] * (i - n) + f
    else:
        return f[:m] + [f[m] + c] + f[m + 1:]

.sympy.polys.densearith.dup_mul_term

def dup_mul_term(f, c, i, K):
    if not c or not f:
        return []
    else:
        return [cf * c for cf in f] + [K.zero] * i

.sympy.polys.densearith.dup_sub

def dup_sub(f, g, K):
    if not f:
        return dup_neg(g, K)
    if not g:
        return f
    df = dup_degree(f)
    dg = dup_degree(g)
    if df == dg:
        return dup_strip([a - b for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (dup_neg(g[:k], K), g[k:])
        return h + [a - b for a, b in zip(f, g)]

.sympy.polys.euclidtools._dmp_zz_gcd_interpolate

def _dmp_zz_gcd_interpolate(h, x, v, K):
    f = []
    while not dmp_zero_p(h, v):
        g = dmp_ground_trunc(h, x, v, K)
        f.insert(0, g)
        h = dmp_sub(h, g, v, K)
        h = dmp_quo_ground(h, x, v, K)
    if K.is_negative(dmp_ground_LC(f, v + 1, K)):
        return dmp_neg(f, v + 1, K)
    else:
        return f

.sympy.polys.densetools.dmp_ground_trunc

def dmp_ground_trunc(f, p, u, K):
    if not u:
        return dup_trunc(f, p, K)
    v = u - 1
    return dmp_strip([dmp_ground_trunc(c, p, v, K) for c in f], u)

.sympy.polys.densetools.dup_trunc

def dup_trunc(f, p, K):
    if K.is_ZZ:
        g = []
        for c in f:
            c = c % p
            if c > p // 2:
                g.append(c - p)
            else:
                g.append(c)
    else:
        g = [c % p for c in f]
    return dup_strip(g)

.sympy.polys.densearith.dmp_sub

def dmp_sub(f, g, u, K):
    if not u:
        return dup_sub(f, g, K)
    df = dmp_degree(f, u)
    if df < 0:
        return dmp_neg(g, u, K)
    dg = dmp_degree(g, u)
    if dg < 0:
        return f
    v = u - 1
    if df == dg:
        return dmp_strip([dmp_sub(a, b, v, K) for a, b in zip(f, g)], u)
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (dmp_neg(g[:k], u, K), g[k:])
        return h + [dmp_sub(a, b, v, K) for a, b in zip(f, g)]

.sympy.polys.densearith.dmp_quo_ground

def dmp_quo_ground(f, c, u, K):
    if not u:
        return dup_quo_ground(f, c, K)
    v = u - 1
    return [dmp_quo_ground(cf, c, v, K) for cf in f]

.sympy.polys.densearith.dup_quo_ground

def dup_quo_ground(f, c, K):
    if not c:
        raise ZeroDivisionError('polynomial division')
    if not f:
        return f
    if K.is_Field:
        return [K.quo(cf, c) for cf in f]
    else:
        return [cf // c for cf in f]

.sympy.polys.densearith.dmp_div

def dmp_div(f, g, u, K):
    if K.is_Field:
        return dmp_ff_div(f, g, u, K)
    else:
        return dmp_rr_div(f, g, u, K)

.sympy.polys.densearith.dmp_rr_div

def dmp_rr_div(f, g, u, K):
    if not u:
        return dup_rr_div(f, g, K)
    df = dmp_degree(f, u)
    dg = dmp_degree(g, u)
    if dg < 0:
        raise ZeroDivisionError('polynomial division')
    q, r, dr = (dmp_zero(u), f, df)
    if df < dg:
        return (q, r)
    lc_g, v = (dmp_LC(g, K), u - 1)
    while True:
        lc_r = dmp_LC(r, K)
        c, R = dmp_rr_div(lc_r, lc_g, v, K)
        if not dmp_zero_p(R, v):
            break
        j = dr - dg
        q = dmp_add_term(q, c, j, u, K)
        h = dmp_mul_term(g, c, j, u, K)
        r = dmp_sub(r, h, u, K)
        _dr, dr = (dr, dmp_degree(r, u))
        if dr < dg:
            break
        elif not dr < _dr:
            raise PolynomialDivisionFailed(f, g, K)
    return (q, r)

.sympy.polys.densearith.dmp_add_term

def dmp_add_term(f, c, i, u, K):
    if not u:
        return dup_add_term(f, c, i, K)
    v = u - 1
    if dmp_zero_p(c, v):
        return f
    n = len(f)
    m = n - i - 1
    if i == n - 1:
        return dmp_strip([dmp_add(f[0], c, v, K)] + f[1:], u)
    elif i >= n:
        return [c] + dmp_zeros(i - n, v, K) + f
    else:
        return f[:m] + [dmp_add(f[m], c, v, K)] + f[m + 1:]

.sympy.polys.densebasic.dmp_zeros

def dmp_zeros(n, u, K):
    if not n:
        return []
    if u < 0:
        return [K.zero] * n
    else:
        return [dmp_zero(u) for i in range(n)]

.sympy.polys.densearith.dmp_mul_term

def dmp_mul_term(f, c, i, u, K):
    if not u:
        return dup_mul_term(f, c, i, K)
    v = u - 1
    if dmp_zero_p(f, u):
        return f
    if dmp_zero_p(c, v):
        return dmp_zero(u)
    else:
        return [dmp_mul(cf, c, v, K) for cf in f] + dmp_zeros(i, v, K)

.sympy.polys.densearith.dmp_mul

def dmp_mul(f, g, u, K):
    if not u:
        return dup_mul(f, g, K)
    if f == g:
        return dmp_sqr(f, u, K)
    df = dmp_degree(f, u)
    if df < 0:
        return f
    dg = dmp_degree(g, u)
    if dg < 0:
        return g
    h, v = ([], u - 1)
    for i in range(0, df + dg + 1):
        coeff = dmp_zero(v)
        for j in range(max(0, i - dg), min(df, i) + 1):
            coeff = dmp_add(coeff, dmp_mul(f[j], g[i - j], v, K), v, K)
        h.append(coeff)
    return dmp_strip(h, u)

.sympy.polys.densearith.dup_mul

def dup_mul(f, g, K):
    if f == g:
        return dup_sqr(f, K)
    if not (f and g):
        return []
    df = dup_degree(f)
    dg = dup_degree(g)
    n = max(df, dg) + 1
    if n < 100:
        h = []
        for i in range(0, df + dg + 1):
            coeff = K.zero
            for j in range(max(0, i - dg), min(df, i) + 1):
                coeff += f[j] * g[i - j]
            h.append(coeff)
        return dup_strip(h)
    else:
        n2 = n // 2
        fl, gl = (dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K))
        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)
        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)
        lo, hi = (dup_mul(fl, gl, K), dup_mul(fh, gh, K))
        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)
        mid = dup_sub(mid, dup_add(lo, hi, K), K)
        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K), dup_lshift(hi, 2 * n2, K), K)

.sympy.polys.densebasic.dmp_inflate

def dmp_inflate(f, M, u, K):
    if not u:
        return dup_inflate(f, M[0], K)
    if all((m == 1 for m in M)):
        return f
    else:
        return _rec_inflate(f, M, u, 0, K)

.sympy.polys.densearith.dmp_quo

def dmp_quo(f, g, u, K):
    return dmp_div(f, g, u, K)[0]

.sympy.polys.factortools.dmp_zz_wang

def dmp_zz_wang(f, u, K, mod=None, seed=None):
    from sympy.utilities.randtest import _randint
    randint = _randint(seed)
    ct, T = dmp_zz_factor(dmp_LC(f, K), u - 1, K)
    b = dmp_zz_mignotte_bound(f, u, K)
    p = K(nextprime(b))
    if mod is None:
        if u == 1:
            mod = 2
        else:
            mod = 1
    history, configs, A, r = (set([]), [], [K.zero] * u, None)
    try:
        cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
        _, H = dup_zz_factor_sqf(s, K)
        r = len(H)
        if r == 1:
            return [f]
        configs = [(s, cs, E, H, A)]
    except EvaluationFailed:
        pass
    eez_num_configs = query('EEZ_NUMBER_OF_CONFIGS')
    eez_num_tries = query('EEZ_NUMBER_OF_TRIES')
    eez_mod_step = query('EEZ_MODULUS_STEP')
    while len(configs) < eez_num_configs:
        for _ in range(eez_num_tries):
            A = [K(randint(-mod, mod)) for _ in range(u)]
            if tuple(A) not in history:
                history.add(tuple(A))
            else:
                continue
            try:
                cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
            except EvaluationFailed:
                continue
            _, H = dup_zz_factor_sqf(s, K)
            rr = len(H)
            if r is not None:
                if rr != r:
                    if rr < r:
                        configs, r = ([], rr)
                    else:
                        continue
            else:
                r = rr
            if r == 1:
                return [f]
            configs.append((s, cs, E, H, A))
            if len(configs) == eez_num_configs:
                break
        else:
            mod += eez_mod_step
    s_norm, s_arg, i = (None, 0, 0)
    for s, _, _, _, _ in configs:
        _s_norm = dup_max_norm(s, K)
        if s_norm is not None:
            if _s_norm < s_norm:
                s_norm = _s_norm
                s_arg = i
        else:
            s_norm = _s_norm
        i += 1
    _, cs, E, H, A = configs[s_arg]
    orig_f = f
    try:
        f, H, LC = dmp_zz_wang_lead_coeffs(f, T, cs, E, H, A, u, K)
        factors = dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K)
    except ExtraneousFactors:
        if query('EEZ_RESTART_IF_NEEDED'):
            return dmp_zz_wang(orig_f, u, K, mod + 1)
        else:
            raise ExtraneousFactors('we need to restart algorithm with better parameters')
    result = []
    for f in factors:
        _, f = dmp_ground_primitive(f, u, K)
        if K.is_negative(dmp_ground_LC(f, u, K)):
            f = dmp_neg(f, u, K)
        result.append(f)
    return result

.sympy.utilities.randtest._randint

def _randint(seed=None):
    if seed is None:
        return randint
    elif isinstance(seed, int):
        return Random(seed).randint
    elif is_sequence(seed):
        seed = list(seed)
        seed.reverse()

        def give(a, b, seq=seed):
            a, b = (as_int(a), as_int(b))
            w = b - a
            if w < 0:
                raise ValueError('_randint got empty range')
            try:
                x = seq.pop()
            except IndexError:
                raise ValueError('_randint sequence was too short')
            if a <= x <= b:
                return x
            else:
                return give(a, b, seq)
        return give
    else:
        raise ValueError('_randint got an unexpected seed')

.sympy.polys.factortools.dmp_zz_mignotte_bound

def dmp_zz_mignotte_bound(f, u, K):
    a = dmp_max_norm(f, u, K)
    b = abs(dmp_ground_LC(f, u, K))
    n = sum(dmp_degree_list(f, u))
    return K.sqrt(K(n + 1)) * 2 ** n * a * b

.sympy.ntheory.generate.nextprime

def nextprime(n, ith=1):
    n = int(n)
    i = as_int(ith)
    if i > 1:
        pr = n
        j = 1
        while 1:
            pr = nextprime(pr)
            j += 1
            if j > i:
                break
        return pr
    if n < 2:
        return 2
    if n < 7:
        return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]
    if n <= sieve._list[-2]:
        l, u = sieve.search(n)
        if l == u:
            return sieve[u + 1]
        else:
            return sieve[u]
    nn = 6 * (n // 6)
    if nn == n:
        n += 1
        if isprime(n):
            return n
        n += 4
    elif n - nn == 5:
        n += 2
        if isprime(n):
            return n
        n += 4
    else:
        n = nn + 5
    while 1:
        if isprime(n):
            return n
        n += 2
        if isprime(n):
            return n
        n += 4

.sympy.ntheory.primetest.isprime

def isprime(n):
    try:
        n = as_int(n)
    except ValueError:
        return False
    if n in [2, 3, 5]:
        return True
    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):
        return False
    if n < 49:
        return True
    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):
        return False
    if n < 2809:
        return True
    if n <= 23001:
        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]
    from sympy.ntheory.generate import sieve as s
    if n <= s._list[-1]:
        l, u = s.search(n)
        return l == u
    from sympy.core.compatibility import HAS_GMPY
    if HAS_GMPY == 2:
        from gmpy2 import is_strong_prp, is_strong_selfridge_prp
        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)
    if n < 341531:
        return mr(n, [9345883071009581737])
    if n < 885594169:
        return mr(n, [725270293939359937, 3569819667048198375])
    if n < 350269456337:
        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])
    if n < 55245642489451:
        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])
    if n < 7999252175582851:
        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])
    if n < 585226005592931977:
        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])
    if n < 18446744073709551616:
        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])
    return mr(n, [2]) and is_strong_lucas_prp(n)

.sympy.polys.factortools.dmp_zz_wang_test_points

def dmp_zz_wang_test_points(f, T, ct, A, u, K):
    if not dmp_eval_tail(dmp_LC(f, K), A, u - 1, K):
        raise EvaluationFailed('no luck')
    g = dmp_eval_tail(f, A, u, K)
    if not dup_sqf_p(g, K):
        raise EvaluationFailed('no luck')
    c, h = dup_primitive(g, K)
    if K.is_negative(dup_LC(h, K)):
        c, h = (-c, dup_neg(h, K))
    v = u - 1
    E = [dmp_eval_tail(t, A, v, K) for t, _ in T]
    D = dmp_zz_wang_non_divisors(E, c, ct, K)
    if D is not None:
        return (c, h, E)
    else:
        raise EvaluationFailed('no luck')

.sympy.polys.densetools.dmp_eval_tail

def dmp_eval_tail(f, A, u, K):
    if not A:
        return f
    if dmp_zero_p(f, u):
        return dmp_zero(u - len(A))
    e = _rec_eval_tail(f, 0, A, u, K)
    if u == len(A) - 1:
        return e
    else:
        return dmp_strip(e, u - len(A))

.sympy.polys.densetools._rec_eval_tail

def _rec_eval_tail(g, i, A, u, K):
    if i == u:
        return dup_eval(g, A[-1], K)
    else:
        h = [_rec_eval_tail(c, i + 1, A, u, K) for c in g]
        if i < u - len(A) + 1:
            return h
        else:
            return dup_eval(h, A[-u + i - 1], K)

.sympy.polys.sqfreetools.dup_sqf_p

def dup_sqf_p(f, K):
    if not f:
        return True
    else:
        return not dup_degree(dup_gcd(f, dup_diff(f, 1, K), K))

.sympy.polys.densetools.dup_diff

def dup_diff(f, m, K):
    if m <= 0:
        return f
    n = dup_degree(f)
    if n < m:
        return []
    deriv = []
    if m == 1:
        for coeff in f[:-m]:
            deriv.append(K(n) * coeff)
            n -= 1
    else:
        for coeff in f[:-m]:
            k = n
            for i in range(n - 1, n - m, -1):
                k *= i
            deriv.append(K(k) * coeff)
            n -= 1
    return dup_strip(deriv)

.sympy.polys.euclidtools.dup_gcd

def dup_gcd(f, g, K):
    return dup_inner_gcd(f, g, K)[0]

.sympy.polys.factortools.dmp_zz_wang_non_divisors

def dmp_zz_wang_non_divisors(E, cs, ct, K):
    result = [cs * ct]
    for q in E:
        q = abs(q)
        for r in reversed(result):
            while r != 1:
                r = K.gcd(r, q)
                q = q // r
            if K.is_one(q):
                return None
        result.append(q)
    return result[1:]

.sympy.polys.factortools.dup_zz_factor_sqf

def dup_zz_factor_sqf(f, K):
    cont, g = dup_primitive(f, K)
    n = dup_degree(g)
    if dup_LC(g, K) < 0:
        cont, g = (-cont, dup_neg(g, K))
    if n <= 0:
        return (cont, [])
    elif n == 1:
        return (cont, [g])
    if query('USE_IRREDUCIBLE_IN_FACTOR'):
        if dup_zz_irreducible_p(g, K):
            return (cont, [g])
    factors = None
    if query('USE_CYCLOTOMIC_FACTOR'):
        factors = dup_zz_cyclotomic_factor(g, K)
    if factors is None:
        factors = dup_zz_zassenhaus(g, K)
    return (cont, _sort_factors(factors, multiple=False))

.sympy.polys.factortools.dup_zz_cyclotomic_factor

def dup_zz_cyclotomic_factor(f, K):
    lc_f, tc_f = (dup_LC(f, K), dup_TC(f, K))
    if dup_degree(f) <= 0:
        return None
    if lc_f != 1 or tc_f not in [-1, 1]:
        return None
    if any((bool(cf) for cf in f[1:-1])):
        return None
    n = dup_degree(f)
    F = _dup_cyclotomic_decompose(n, K)
    if not K.is_one(tc_f):
        return F
    else:
        H = []
        for h in _dup_cyclotomic_decompose(2 * n, K):
            if h not in F:
                H.append(h)
        return H

.sympy.polys.factortools.dup_zz_zassenhaus

def dup_zz_zassenhaus(f, K):
    n = dup_degree(f)
    if n == 1:
        return [f]
    fc = f[-1]
    A = dup_max_norm(f, K)
    b = dup_LC(f, K)
    B = int(abs(K.sqrt(K(n + 1)) * 2 ** n * A * b))
    C = int((n + 1) ** (2 * n) * A ** (2 * n - 1))
    gamma = int(_ceil(2 * _log(C, 2)))
    bound = int(2 * gamma * _log(gamma))
    a = []
    for px in range(3, bound + 1):
        if not isprime(px) or b % px == 0:
            continue
        px = K.convert(px)
        F = gf_from_int_poly(f, px)
        if not gf_sqf_p(F, px, K):
            continue
        fsqfx = gf_factor_sqf(F, px, K)[1]
        a.append((px, fsqfx))
        if len(fsqfx) < 15 or len(a) > 4:
            break
    p, fsqf = min(a, key=lambda x: len(x[1]))
    l = int(_ceil(_log(2 * B + 1, p)))
    modular = [gf_to_int_poly(ff, p) for ff in fsqf]
    g = dup_zz_hensel_lift(p, f, modular, l, K)
    sorted_T = range(len(g))
    T = set(sorted_T)
    factors, s = ([], 1)
    pl = p ** l
    while 2 * s <= len(T):
        for S in subsets(sorted_T, s):
            if b == 1:
                q = 1
                for i in S:
                    q = q * g[i][-1]
                q = q % pl
                if not _test_pl(fc, q, pl):
                    continue
            else:
                G = [b]
                for i in S:
                    G = dup_mul(G, g[i], K)
                G = dup_trunc(G, pl, K)
                G = dup_primitive(G, K)[1]
                q = G[-1]
                if q and fc % q != 0:
                    continue
            H = [b]
            S = set(S)
            T_S = T - S
            if b == 1:
                G = [b]
                for i in S:
                    G = dup_mul(G, g[i], K)
                G = dup_trunc(G, pl, K)
            for i in T_S:
                H = dup_mul(H, g[i], K)
            H = dup_trunc(H, pl, K)
            G_norm = dup_l1_norm(G, K)
            H_norm = dup_l1_norm(H, K)
            if G_norm * H_norm <= B:
                T = T_S
                sorted_T = [i for i in sorted_T if i not in S]
                G = dup_primitive(G, K)[1]
                f = dup_primitive(H, K)[1]
                factors.append(G)
                b = dup_LC(f, K)
                break
        else:
            s += 1
    return factors + [f]

.sympy.polys.galoistools.gf_from_int_poly

def gf_from_int_poly(f, p):
    return gf_trunc(f, p)

.sympy.polys.galoistools.gf_trunc

def gf_trunc(f, p):
    return gf_strip([a % p for a in f])

.sympy.polys.galoistools.gf_strip

def gf_strip(f):
    if not f or f[0]:
        return f
    k = 0
    for coeff in f:
        if coeff:
            break
        else:
            k += 1
    return f[k:]

.sympy.polys.galoistools.gf_sqf_p

def gf_sqf_p(f, p, K):
    _, f = gf_monic(f, p, K)
    if not f:
        return True
    else:
        return gf_gcd(f, gf_diff(f, p, K), p, K) == [K.one]

.sympy.polys.galoistools.gf_monic

def gf_monic(f, p, K):
    if not f:
        return (K.zero, [])
    else:
        lc = f[0]
        if K.is_one(lc):
            return (lc, list(f))
        else:
            return (lc, gf_quo_ground(f, lc, p, K))

.sympy.polys.galoistools.gf_quo_ground

def gf_quo_ground(f, a, p, K):
    return gf_mul_ground(f, K.invert(a, p), p, K)

.sympy.polys.domains.ring.Ring.invert

def invert(self, a, b):
    s, t, h = self.gcdex(a, b)
    if self.is_one(h):
        return s % b
    else:
        raise NotInvertible('zero divisor')

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.gcdex

def gcdex(self, a, b):
    return python_gcdex(a, b)

.sympy.core.numbers.igcdex

def igcdex(a, b):
    if not a and (not b):
        return (0, 1, 0)
    if not a:
        return (0, b // abs(b), abs(b))
    if not b:
        return (a // abs(a), 0, abs(a))
    if a < 0:
        a, x_sign = (-a, -1)
    else:
        x_sign = 1
    if b < 0:
        b, y_sign = (-b, -1)
    else:
        y_sign = 1
    x, y, r, s = (1, 0, 0, 1)
    while b:
        c, q = (a % b, a // b)
        a, b, r, s, x, y = (b, c, x - q * r, y - q * s, r, s)
    return (x * x_sign, y * y_sign, a)

.sympy.polys.galoistools.gf_mul_ground

def gf_mul_ground(f, a, p, K):
    if not a:
        return []
    else:
        return [a * b % p for b in f]

.sympy.polys.galoistools.gf_diff

def gf_diff(f, p, K):
    df = gf_degree(f)
    h, n = ([K.zero] * df, df)
    for coeff in f[:-1]:
        coeff *= K(n)
        coeff %= p
        if coeff:
            h[df - n] = coeff
        n -= 1
    return gf_strip(h)

.sympy.polys.galoistools.gf_degree

def gf_degree(f):
    return len(f) - 1

.sympy.polys.galoistools.gf_gcd

def gf_gcd(f, g, p, K):
    while g:
        f, g = (g, gf_rem(f, g, p, K))
    return gf_monic(f, p, K)[1]

.sympy.polys.galoistools.gf_rem

def gf_rem(f, g, p, K):
    return gf_div(f, g, p, K)[1]

.sympy.polys.galoistools.gf_div

def gf_div(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return ([], f)
    inv = K.invert(g[0], p)
    h, dq, dr = (list(f), df - dg, dg - 1)
    for i in range(0, df + 1):
        coeff = h[i]
        for j in range(max(0, dg - i), min(df - i, dr) + 1):
            coeff -= h[i + j - dg] * g[dg - j]
        if i <= dq:
            coeff *= inv
        h[i] = coeff % p
    return (h[:dq + 1], gf_strip(h[dq + 1:]))

.sympy.polys.galoistools.gf_factor_sqf

def gf_factor_sqf(f, p, K, method=None):
    lc, f = gf_monic(f, p, K)
    if gf_degree(f) < 1:
        return (lc, [])
    method = method or query('GF_FACTOR_METHOD')
    if method is not None:
        factors = _factor_methods[method](f, p, K)
    else:
        factors = gf_zassenhaus(f, p, K)
    return (lc, factors)

.sympy.polys.galoistools.gf_zassenhaus

def gf_zassenhaus(f, p, K):
    factors = []
    for factor, n in gf_ddf_zassenhaus(f, p, K):
        factors += gf_edf_zassenhaus(factor, n, p, K)
    return _sort_factors(factors, multiple=False)

.sympy.polys.galoistools.gf_ddf_zassenhaus

def gf_ddf_zassenhaus(f, p, K):
    i, g, factors = (1, [K.one, K.zero], [])
    b = gf_frobenius_monomial_base(f, p, K)
    while 2 * i <= gf_degree(f):
        g = gf_frobenius_map(g, f, b, p, K)
        h = gf_gcd(f, gf_sub(g, [K.one, K.zero], p, K), p, K)
        if h != [K.one]:
            factors.append((h, i))
            f = gf_quo(f, h, p, K)
            g = gf_rem(g, f, p, K)
            b = gf_frobenius_monomial_base(f, p, K)
        i += 1
    if f != [K.one]:
        return factors + [(f, gf_degree(f))]
    else:
        return factors

.sympy.polys.galoistools.gf_frobenius_monomial_base

def gf_frobenius_monomial_base(g, p, K):
    n = gf_degree(g)
    if n == 0:
        return []
    b = [0] * n
    b[0] = [1]
    if p < n:
        for i in range(1, n):
            mon = gf_lshift(b[i - 1], p, K)
            b[i] = gf_rem(mon, g, p, K)
    elif n > 1:
        b[1] = gf_pow_mod([K.one, K.zero], p, g, p, K)
        for i in range(2, n):
            b[i] = gf_mul(b[i - 1], b[1], p, K)
            b[i] = gf_rem(b[i], g, p, K)
    return b

.sympy.polys.galoistools.gf_pow_mod

def gf_pow_mod(f, n, g, p, K):
    if not n:
        return [K.one]
    elif n == 1:
        return gf_rem(f, g, p, K)
    elif n == 2:
        return gf_rem(gf_sqr(f, p, K), g, p, K)
    h = [K.one]
    while True:
        if n & 1:
            h = gf_mul(h, f, p, K)
            h = gf_rem(h, g, p, K)
            n -= 1
        n >>= 1
        if not n:
            break
        f = gf_sqr(f, p, K)
        f = gf_rem(f, g, p, K)
    return h

.sympy.polys.galoistools.gf_mul

def gf_mul(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    dh = df + dg
    h = [0] * (dh + 1)
    for i in range(0, dh + 1):
        coeff = K.zero
        for j in range(max(0, i - dg), min(i, df) + 1):
            coeff += f[j] * g[i - j]
        h[i] = coeff % p
    return gf_strip(h)

.sympy.polys.galoistools.gf_sqr

def gf_sqr(f, p, K):
    df = gf_degree(f)
    dh = 2 * df
    h = [0] * (dh + 1)
    for i in range(0, dh + 1):
        coeff = K.zero
        jmin = max(0, i - df)
        jmax = min(i, df)
        n = jmax - jmin + 1
        jmax = jmin + n // 2 - 1
        for j in range(jmin, jmax + 1):
            coeff += f[j] * f[i - j]
        coeff += coeff
        if n & 1:
            elem = f[jmax + 1]
            coeff += elem ** 2
        h[i] = coeff % p
    return gf_strip(h)

.sympy.polys.galoistools.gf_frobenius_map

def gf_frobenius_map(f, g, b, p, K):
    m = gf_degree(g)
    if gf_degree(f) >= m:
        f = gf_rem(f, g, p, K)
    if not f:
        return []
    n = gf_degree(f)
    sf = [f[-1]]
    for i in range(1, n + 1):
        v = gf_mul_ground(b[i], f[n - i], p, K)
        sf = gf_add(sf, v, p, K)
    return sf

.sympy.polys.galoistools.gf_add

def gf_add(f, g, p, K):
    if not f:
        return g
    if not g:
        return f
    df = gf_degree(f)
    dg = gf_degree(g)
    if df == dg:
        return gf_strip([(a + b) % p for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [(a + b) % p for a, b in zip(f, g)]

.sympy.polys.galoistools.gf_sub

def gf_sub(f, g, p, K):
    if not g:
        return f
    if not f:
        return gf_neg(g, p, K)
    df = gf_degree(f)
    dg = gf_degree(g)
    if df == dg:
        return gf_strip([(a - b) % p for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (gf_neg(g[:k], p, K), g[k:])
        return h + [(a - b) % p for a, b in zip(f, g)]

.sympy.polys.galoistools.gf_edf_zassenhaus

def gf_edf_zassenhaus(f, n, p, K):
    factors = [f]
    if gf_degree(f) <= n:
        return factors
    N = gf_degree(f) // n
    if p != 2:
        b = gf_frobenius_monomial_base(f, p, K)
    while len(factors) < N:
        r = gf_random(2 * n - 1, p, K)
        if p == 2:
            h = r
            for i in range(0, 2 ** (n * N - 1)):
                r = gf_pow_mod(r, 2, f, p, K)
                h = gf_add(h, r, p, K)
            g = gf_gcd(f, h, p, K)
        else:
            h = _gf_pow_pnm1d2(r, n, f, b, p, K)
            g = gf_gcd(f, gf_sub_ground(h, K.one, p, K), p, K)
        if g != [K.one] and g != f:
            factors = gf_edf_zassenhaus(g, n, p, K) + gf_edf_zassenhaus(gf_quo(f, g, p, K), n, p, K)
    return _sort_factors(factors, multiple=False)

.sympy.polys.polyutils.order_no_multiple_key

def order_no_multiple_key(f):
    return (len(f), f)

.sympy.polys.galoistools.gf_to_int_poly

def gf_to_int_poly(f, p, symmetric=True):
    if symmetric:
        return [gf_int(c, p) for c in f]
    else:
        return f

.sympy.polys.galoistools.gf_int

def gf_int(a, p):
    if a <= p // 2:
        return a
    else:
        return a - p

.sympy.polys.factortools.dup_zz_hensel_lift

def dup_zz_hensel_lift(p, f, f_list, l, K):
    r = len(f_list)
    lc = dup_LC(f, K)
    if r == 1:
        F = dup_mul_ground(f, K.gcdex(lc, p ** l)[0], K)
        return [dup_trunc(F, p ** l, K)]
    m = p
    k = r // 2
    d = int(_ceil(_log(l, 2)))
    g = gf_from_int_poly([lc], p)
    for f_i in f_list[:k]:
        g = gf_mul(g, gf_from_int_poly(f_i, p), p, K)
    h = gf_from_int_poly(f_list[k], p)
    for f_i in f_list[k + 1:]:
        h = gf_mul(h, gf_from_int_poly(f_i, p), p, K)
    s, t, _ = gf_gcdex(g, h, p, K)
    g = gf_to_int_poly(g, p)
    h = gf_to_int_poly(h, p)
    s = gf_to_int_poly(s, p)
    t = gf_to_int_poly(t, p)
    for _ in range(1, d + 1):
        (g, h, s, t), m = (dup_zz_hensel_step(m, f, g, h, s, t, K), m ** 2)
    return dup_zz_hensel_lift(p, g, f_list[:k], l, K) + dup_zz_hensel_lift(p, h, f_list[k:], l, K)

.sympy.polys.factortools.dmp_trial_division

def dmp_trial_division(f, factors, u, K):
    result = []
    for factor in factors:
        k = 0
        while True:
            q, r = dmp_div(f, factor, u, K)
            if dmp_zero_p(r, u):
                f, k = (q, k + 1)
            else:
                break
        result.append((factor, k))
    return _sort_factors(result)

.sympy.polys.densebasic.dmp_include

def dmp_include(f, J, u, K):
    if not J:
        return f
    F, f = (dmp_to_dict(f, u), {})
    for monom, coeff in F.items():
        monom = list(monom)
        for j in J:
            monom.insert(j, 0)
        f[tuple(monom)] = coeff
    u += len(J)
    return dmp_from_dict(f, u, K)

.sympy.simplify.cse_opts.sub_pre

def sub_pre(e):
    adds = [a for a in e.atoms(Add) if a.could_extract_minus_sign()]
    reps = dict(((a, Mul._from_args([S.NegativeOne, -a])) for a in adds))
    e = e.xreplace(reps)
    if isinstance(e, Basic):
        negs = {}
        for a in sorted(e.atoms(Add), key=default_sort_key):
            if a in reps:
                negs[a] = reps[a]
            elif a.could_extract_minus_sign():
                negs[a] = Mul._from_args([S.One, S.NegativeOne, -a])
        e = e.xreplace(negs)
    return e

.sympy.core.basic.Basic.atoms

def atoms(self, *types):
    if types:
        types = tuple([t if isinstance(t, type) else type(t) for t in types])
    else:
        types = (Atom,)
    result = set()
    for expr in preorder_traversal(self):
        if isinstance(expr, types):
            result.add(expr)
    return result

.sympy.core.expr.Expr.could_extract_minus_sign

def could_extract_minus_sign(self):
    negative_self = -self
    if self == negative_self:
        return False
    self_has_minus = self.extract_multiplicatively(-1) is not None
    negative_self_has_minus = negative_self.extract_multiplicatively(-1) is not None
    if self_has_minus != negative_self_has_minus:
        return self_has_minus
    else:
        if self.is_Add:
            all_args = len(self.args)
            negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
            positive_args = all_args - negative_args
            if positive_args > negative_args:
                return False
            elif positive_args < negative_args:
                return True
        elif self.is_Mul:
            num, den = self.as_numer_denom()
            args = Mul.make_args(num) + Mul.make_args(den)
            arg_signs = [arg.could_extract_minus_sign() for arg in args]
            negative_args = list(filter(None, arg_signs))
            return len(negative_args) % 2 == 1
        return bool(self.sort_key() < negative_self.sort_key())

.sympy.core.numbers.NegativeOne.__neg__

def __neg__():
    return S.One

.sympy.core.expr.Expr.sort_key

def sort_key(self, order=None):
    coeff, expr = self.as_coeff_Mul()
    if expr.is_Pow:
        expr, exp = expr.args
    else:
        expr, exp = (expr, S.One)
    if expr.is_Dummy:
        args = (expr.sort_key(),)
    elif expr.is_Atom:
        args = (str(expr),)
    else:
        if expr.is_Add:
            args = expr.as_ordered_terms(order=order)
        elif expr.is_Mul:
            args = expr.as_ordered_factors(order=order)
        else:
            args = expr.args
        args = tuple([default_sort_key(arg, order=order) for arg in args])
    args = (len(args), tuple(args))
    exp = exp.sort_key(order=order)
    return (expr.class_key(), args, exp, coeff)

.sympy.core.expr.Expr.as_ordered_terms

def as_ordered_terms(self, order=None, data=False):
    from .numbers import Number, NumberSymbol
    if order is None and self.is_Add:
        key = lambda x: not isinstance(x, (Number, NumberSymbol))
        add_args = sorted(Add.make_args(self), key=key)
        if len(add_args) == 2 and isinstance(add_args[0], (Number, NumberSymbol)) and isinstance(add_args[1], Mul):
            mul_args = sorted(Mul.make_args(add_args[1]), key=key)
            if len(mul_args) == 2 and isinstance(mul_args[0], Number) and add_args[0].is_positive and mul_args[0].is_negative:
                return add_args
    key, reverse = self._parse_order(order)
    terms, gens = self.as_terms()
    if not any((term.is_Order for term, _ in terms)):
        ordered = sorted(terms, key=key, reverse=reverse)
    else:
        _terms, _order = ([], [])
        for term, repr in terms:
            if not term.is_Order:
                _terms.append((term, repr))
            else:
                _order.append((term, repr))
        ordered = sorted(_terms, key=key, reverse=True) + sorted(_order, key=key, reverse=True)
    if data:
        return (ordered, gens)
    else:
        return [term for term, _ in ordered]

.sympy.core.expr.Expr._parse_order

def _parse_order(cls, order):
    from sympy.polys.orderings import monomial_key
    startswith = getattr(order, 'startswith', None)
    if startswith is None:
        reverse = False
    else:
        reverse = startswith('rev-')
        if reverse:
            order = order[4:]
    monom_key = monomial_key(order)

    def neg(monom):
        result = []
        for m in monom:
            if isinstance(m, tuple):
                result.append(neg(m))
            else:
                result.append(-m)
        return tuple(result)

    def key(term):
        _, ((re, im), monom, ncpart) = term
        monom = neg(monom_key(monom))
        ncpart = tuple([e.sort_key(order=order) for e in ncpart])
        coeff = ((bool(im), im), (re, im))
        return (monom, ncpart, coeff)
    return (key, reverse)

.sympy.polys.orderings.monomial_key

def monomial_key(order=None, gens=None):
    if order is None:
        order = lex
    if isinstance(order, Symbol):
        order = str(order)
    if isinstance(order, str):
        try:
            order = _monomial_key[order]
        except KeyError:
            raise ValueError("supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r" % order)
    if hasattr(order, '__call__'):
        if gens is not None:

            def _order(expr):
                return order(expr.as_poly(*gens).degree_list())
            return _order
        return order
    else:
        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)

.sympy.core.expr.Expr.as_terms

def as_terms(self):
    from .add import Add
    from .mul import Mul
    from .exprtools import decompose_power
    gens, terms = (set([]), [])
    for term in Add.make_args(self):
        coeff, _term = term.as_coeff_Mul()
        coeff = complex(coeff)
        cpart, ncpart = ({}, [])
        if _term is not S.One:
            for factor in Mul.make_args(_term):
                if factor.is_number:
                    try:
                        coeff *= complex(factor)
                    except (TypeError, ValueError):
                        pass
                    else:
                        continue
                if factor.is_commutative:
                    base, exp = decompose_power(factor)
                    cpart[base] = exp
                    gens.add(base)
                else:
                    ncpart.append(factor)
        coeff = (coeff.real, coeff.imag)
        ncpart = tuple(ncpart)
        terms.append((term, (coeff, cpart, ncpart)))
    gens = sorted(gens, key=default_sort_key)
    k, indices = (len(gens), {})
    for i, g in enumerate(gens):
        indices[g] = i
    result = []
    for term, (coeff, cpart, ncpart) in terms:
        monom = [0] * k
        for base, exp in cpart.items():
            monom[indices[base]] = exp
        result.append((term, (coeff, tuple(monom), ncpart)))
    return (result, gens)

.sympy.core.expr.Expr.__complex__

def __complex__(self):
    result = self.evalf()
    re, im = result.as_real_imag()
    return complex(float(re), float(im))

.sympy.core.numbers.Float._as_mpf_val

def _as_mpf_val(self, prec):
    rv = mpf_norm(self._mpf_, prec)
    if rv != self._mpf_ and self._prec == prec:
        debug(self._mpf_, rv)
    return rv

.sympy.core.expr.Expr.key

def key(term):
    _, ((re, im), monom, ncpart) = term
    monom = neg(monom_key(monom))
    ncpart = tuple([e.sort_key(order=order) for e in ncpart])
    coeff = ((bool(im), im), (re, im))
    return (monom, ncpart, coeff)

.sympy.polys.orderings.LexOrder.__call__

def __call__(self, monomial):
    return monomial

.sympy.core.expr.Expr.neg

def neg(monom):
    result = []
    for m in monom:
        if isinstance(m, tuple):
            result.append(neg(m))
        else:
            result.append(-m)
    return tuple(result)

.sympy.core.mul.Mul.as_ordered_factors

def as_ordered_factors(self, order=None):
    cpart, ncpart = self.args_cnc()
    cpart.sort(key=lambda expr: expr.sort_key(order=order))
    return cpart + ncpart

.sympy.core.mul.Mul.class_key

def class_key(cls):
    return (3, 0, cls.__name__)

.sympy.core.add.Add.class_key

def class_key(cls):
    return (3, 1, cls.__name__)

.sympy.simplify.cse_opts.sub_post

def sub_post(e):
    replacements = []
    for node in preorder_traversal(e):
        if isinstance(node, Mul) and node.args[0] is S.One and (node.args[1] is S.NegativeOne):
            replacements.append((node, -Mul._from_args(node.args[2:])))
    for node, replacement in replacements:
        e = e.xreplace({node: replacement})
    return e

.sympy.solvers.diophantine._diop_quadratic

def _diop_quadratic(var, coeff, t):
    x, y = var
    A = coeff[x ** 2]
    B = coeff[x * y]
    C = coeff[y ** 2]
    D = coeff[x]
    E = coeff[y]
    F = coeff[S.One]
    A, B, C, D, E, F = [as_int(i) for i in _remove_gcd(A, B, C, D, E, F)]
    sol = set([])
    discr = B ** 2 - 4 * A * C
    if A == 0 and C == 0 and (B != 0):
        if D * E - B * F == 0:
            q, r = divmod(E, B)
            if not r:
                sol.add((-q, t))
            q, r = divmod(D, B)
            if not r:
                sol.add((t, -q))
        else:
            div = divisors(D * E - B * F)
            div = div + [-term for term in div]
            for d in div:
                x0, r = divmod(d - E, B)
                if not r:
                    q, r = divmod(D * E - B * F, d)
                    if not r:
                        y0, r = divmod(q - D, B)
                        if not r:
                            sol.add((x0, y0))
    elif discr == 0:
        if A == 0:
            s = _diop_quadratic([y, x], coeff, t)
            for soln in s:
                sol.add((soln[1], soln[0]))
        else:
            g = sign(A) * igcd(A, C)
            a = A // g
            c = C // g
            e = sign(B / A)
            sqa = isqrt(a)
            sqc = isqrt(c)
            _c = e * sqc * D - sqa * E
            if not _c:
                z = symbols('z', real=True)
                eq = sqa * g * z ** 2 + D * z + sqa * F
                roots = solveset_real(eq, z).intersect(S.Integers)
                for root in roots:
                    ans = diop_solve(sqa * x + e * sqc * y - root)
                    sol.add((ans[0], ans[1]))
            elif _is_int(c):
                solve_x = lambda u: -e * sqc * g * _c * t ** 2 - (E + 2 * e * sqc * g * u) * t - (e * sqc * g * u ** 2 + E * u + e * sqc * F) // _c
                solve_y = lambda u: sqa * g * _c * t ** 2 + (D + 2 * sqa * g * u) * t + (sqa * g * u ** 2 + D * u + sqa * F) // _c
                for z0 in range(0, abs(_c)):
                    if divisible(sqa * g * z0 ** 2 + D * z0 + sqa * F, _c) and divisible(e * sqc * g * z0 ** 2 + E * z0 + e * sqc * F, _c):
                        sol.add((solve_x(z0), solve_y(z0)))
    elif is_square(discr):
        if A != 0:
            r = sqrt(discr)
            u, v = symbols('u, v', integer=True)
            eq = _mexpand(4 * A * r * u * v + 4 * A * D * (B * v + r * u + r * v - B * u) + 2 * A * 4 * A * E * (u - v) + 4 * A * r * 4 * A * F)
            solution = diop_solve(eq, t)
            for s0, t0 in solution:
                num = B * t0 + r * s0 + r * t0 - B * s0
                x_0 = S(num) / (4 * A * r)
                y_0 = S(s0 - t0) / (2 * r)
                if isinstance(s0, Symbol) or isinstance(t0, Symbol):
                    if check_param(x_0, y_0, 4 * A * r, t) != (None, None):
                        ans = check_param(x_0, y_0, 4 * A * r, t)
                        sol.add((ans[0], ans[1]))
                elif x_0.is_Integer and y_0.is_Integer:
                    if is_solution_quad(var, coeff, x_0, y_0):
                        sol.add((x_0, y_0))
        else:
            s = _diop_quadratic(var[::-1], coeff, t)
            while s:
                sol.add(s.pop()[::-1])
    else:
        P, Q = _transformation_to_DN(var, coeff)
        D, N = _find_DN(var, coeff)
        solns_pell = diop_DN(D, N)
        if D < 0:
            for x0, y0 in solns_pell:
                for x in [-x0, x0]:
                    for y in [-y0, y0]:
                        s = P * Matrix([x, y]) + Q
                        try:
                            sol.add(tuple([as_int(_) for _ in s]))
                        except ValueError:
                            pass
        else:
            solns_pell = set(solns_pell)
            for X, Y in list(solns_pell):
                solns_pell.add((-X, -Y))
            a = diop_DN(D, 1)
            T = a[0][0]
            U = a[0][1]
            if all((_is_int(_) for _ in P[:4] + Q[:2])):
                for r, s in solns_pell:
                    _a = (r + s * sqrt(D)) * (T + U * sqrt(D)) ** t
                    _b = (r - s * sqrt(D)) * (T - U * sqrt(D)) ** t
                    x_n = _mexpand(S(_a + _b) / 2)
                    y_n = _mexpand(S(_a - _b) / (2 * sqrt(D)))
                    s = P * Matrix([x_n, y_n]) + Q
                    sol.add(tuple(s))
            else:
                L = ilcm(*[_.q for _ in P[:4] + Q[:2]])
                k = 1
                T_k = T
                U_k = U
                while (T_k - 1) % L != 0 or U_k % L != 0:
                    T_k, U_k = (T_k * T + D * U_k * U, T_k * U + U_k * T)
                    k += 1
                for X, Y in solns_pell:
                    for i in range(k):
                        if all((_is_int(_) for _ in P * Matrix([X, Y]) + Q)):
                            _a = (X + sqrt(D) * Y) * (T_k + sqrt(D) * U_k) ** t
                            _b = (X - sqrt(D) * Y) * (T_k - sqrt(D) * U_k) ** t
                            Xt = S(_a + _b) / 2
                            Yt = S(_a - _b) / (2 * sqrt(D))
                            s = P * Matrix([Xt, Yt]) + Q
                            sol.add(tuple(s))
                        X, Y = (X * T + D * U * Y, X * U + Y * T)
    return sol

.sympy.solvers.diophantine._remove_gcd

def _remove_gcd(*x):
    try:
        g = igcd(*x)
    except ValueError:
        fx = list(filter(None, x))
        if len(fx) < 2:
            return x
        g = igcd(*[i.as_content_primitive()[0] for i in fx])
    except TypeError:
        raise TypeError('_remove_gcd(a,b,c) or _remove_gcd(*container)')
    if g == 1:
        return x
    return tuple([i // g for i in x])

.sympy.functions.elementary.complexes.sign.eval

def eval(cls, arg):
    if arg.is_Mul:
        c, args = arg.as_coeff_mul()
        unk = []
        s = sign(c)
        for a in args:
            if a.is_extended_negative:
                s = -s
            elif a.is_extended_positive:
                pass
            else:
                ai = im(a)
                if a.is_imaginary and ai.is_comparable:
                    s *= S.ImaginaryUnit
                    if ai.is_extended_negative:
                        s = -s
                else:
                    unk.append(a)
        if c is S.One and len(unk) == len(args):
            return None
        return s * cls(arg._new_rawargs(*unk))
    if arg is S.NaN:
        return S.NaN
    if arg.is_zero:
        return S.Zero
    if arg.is_extended_positive:
        return S.One
    if arg.is_extended_negative:
        return S.NegativeOne
    if arg.is_Function:
        if isinstance(arg, sign):
            return arg
    if arg.is_imaginary:
        if arg.is_Pow and arg.exp is S.Half:
            return S.ImaginaryUnit
        arg2 = -S.ImaginaryUnit * arg
        if arg2.is_extended_positive:
            return S.ImaginaryUnit
        if arg2.is_extended_negative:
            return -S.ImaginaryUnit

.sympy.core.numbers.Integer.__rfloordiv__

def __rfloordiv__(self, other):
    return Integer(Integer(other).p // self.p)

.sympy.core.numbers.Float._eval_is_zero

def _eval_is_zero(self):
    return self._mpf_ == fzero

.sympy.core.numbers.Float._eval_is_extended_positive

def _eval_is_extended_positive(self):
    if self._mpf_ == _mpf_inf:
        return True
    if self._mpf_ == _mpf_ninf:
        return False
    return self.num > 0

.sympy.core.numbers.Float.num

def num(self):
    return mpmath.mpf(self._mpf_)

.sympy.core.power.isqrt

def isqrt(n):
    if n < 0:
        raise ValueError('n must be nonnegative')
    n = int(n)
    if n < 4503599761588224:
        s = int(_sqrt(n))
        if 0 <= n - s * s <= 2 * s:
            return s
    return integer_nthroot(n, 2)[0]

.sympy.core.numbers.Integer.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p < other.p)
    return Rational.__lt__(self, other)

.sympy.core.numbers.Integer.__index__

def __index__(self):
    return self.p

.sympy.core.numbers.Integer.__rmul__

def __rmul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(other * self.p)
        elif isinstance(other, Rational):
            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))
        return Rational.__rmul__(self, other)
    return Rational.__rmul__(self, other)

.sympy.solvers.diophantine.divisible

def divisible(a, b):
    return not a % b

.sympy.core.numbers.Integer.__mod__

def __mod__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p % other)
        elif isinstance(other, Integer):
            return Integer(self.p % other.p)
        return Rational.__mod__(self, other)
    return Rational.__mod__(self, other)

.sympy.core.numbers.Integer.__radd__

def __radd__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(other + self.p)
        elif isinstance(other, Rational):
            return Rational(other.p + self.p * other.q, other.q, 1)
        return Rational.__radd__(self, other)
    return Rational.__radd__(self, other)

.sympy.core.numbers.Integer.__floordiv__

def __floordiv__(self, other):
    if not isinstance(other, Expr):
        return NotImplemented
    if isinstance(other, Integer):
        return Integer(self.p // other)
    return Integer(divmod(self, other)[0])

.sympy.printing.str.StrPrinter._print_Add

def _print_Add(self, expr, order=None):
    if self.order == 'none':
        terms = list(expr.args)
    else:
        terms = self._as_ordered_terms(expr, order=order)
    PREC = precedence(expr)
    l = []
    for term in terms:
        t = self._print(term)
        if t.startswith('-'):
            sign = '-'
            t = t[1:]
        else:
            sign = '+'
        if precedence(term) < PREC:
            l.extend([sign, '(%s)' % t])
        else:
            l.extend([sign, t])
    sign = l.pop(0)
    if sign == '+':
        sign = ''
    return sign + ' '.join(l)

.sympy.printing.printer.Printer.order

def order(self):
    if 'order' in self._settings:
        return self._settings['order']
    else:
        raise AttributeError('No order defined.')

.sympy.printing.printer.Printer._as_ordered_terms

def _as_ordered_terms(self, expr, order=None):
    order = order or self.order
    if order == 'old':
        return sorted(Add.make_args(expr), key=cmp_to_key(Basic._compare_pretty))
    else:
        return expr.as_ordered_terms(order=order)

.sympy.printing.precedence.precedence

def precedence(item):
    if hasattr(item, 'precedence'):
        return item.precedence
    try:
        mro = item.__class__.__mro__
    except AttributeError:
        return PRECEDENCE['Atom']
    for i in mro:
        n = i.__name__
        if n in PRECEDENCE_FUNCTIONS:
            return PRECEDENCE_FUNCTIONS[n](item)
        elif n in PRECEDENCE_VALUES:
            return PRECEDENCE_VALUES[n]
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Mul

def _print_Mul(self, expr):
    prec = precedence(expr)
    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = '-'
    else:
        sign = ''
    a = []
    b = []
    pow_paren = []
    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        args = Mul.make_args(expr)
    for item in args:
        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):
                    pow_paren.append(item)
                b.append(Pow(item.base, -item.exp))
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append(Rational(item.p))
            if item.q != 1:
                b.append(Rational(item.q))
        else:
            a.append(item)
    a = a or [S.One]
    a_str = [self.parenthesize(x, prec, strict=False) for x in a]
    b_str = [self.parenthesize(x, prec, strict=False) for x in b]
    for item in pow_paren:
        if item.base in b:
            b_str[b.index(item.base)] = '(%s)' % b_str[b.index(item.base)]
    if not b:
        return sign + '*'.join(a_str)
    elif len(b) == 1:
        return sign + '*'.join(a_str) + '/' + b_str[0]
    else:
        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)

.sympy.printing.precedence.precedence_Mul

def precedence_Mul(item):
    if _coeff_isneg(item):
        return PRECEDENCE['Add']
    return PRECEDENCE['Mul']

.sympy.printing.str.StrPrinter.parenthesize

def parenthesize(self, item, level, strict=False):
    if precedence(item) < level or (not strict and precedence(item) <= level):
        return '(%s)' % self._print(item)
    else:
        return self._print(item)

.sympy.printing.precedence.precedence_Integer

def precedence_Integer(item):
    if item.p < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Integer

def _print_Integer(self, expr):
    if self._settings.get('sympy_integers', False):
        return 'S(%s)' % expr
    return str(expr.p)

.sympy.printing.str.StrPrinter._print_Pow

def _print_Pow(self, expr, rational=False):
    PREC = precedence(expr)
    if expr.exp is S.Half and (not rational):
        return 'sqrt(%s)' % self._print(expr.base)
    if expr.is_commutative:
        if -expr.exp is S.Half and (not rational):
            return '%s/sqrt(%s)' % tuple(map(lambda arg: self._print(arg), (S.One, expr.base)))
        if expr.exp is -S.One:
            return '%s/%s' % (self._print(S.One), self.parenthesize(expr.base, PREC, strict=False))
    e = self.parenthesize(expr.exp, PREC, strict=False)
    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and (expr.exp.q != 1):
        if e.startswith('(Rational'):
            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)

.sympy.core.mul.Mul._eval_is_infinite

def _eval_is_infinite(self):
    if any((a.is_infinite for a in self.args)):
        if any((a.is_zero for a in self.args)):
            return S.NaN.is_infinite
        if any((a.is_zero is None for a in self.args)):
            return None
        return True

.sympy.core.mul.Mul._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):
                return True
            return
        if a is None:
            return
    return False

.sympy.core.numbers.Integer._eval_is_prime

def _eval_is_prime(self):
    from sympy.ntheory import isprime
    return isprime(self)

.sympy.core.mul.Mul._eval_is_antihermitian

def _eval_is_antihermitian(self):
    z = self.is_zero
    if z:
        return False
    elif z is False:
        return self._eval_herm_antiherm(False)

.sympy.core.numbers.Zero.__neg__

def __neg__():
    return S.Zero

.sympy.polys.galoistools.gf_quo

def gf_quo(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return []
    inv = K.invert(g[0], p)
    h, dq, dr = (f[:], df - dg, dg - 1)
    for i in range(0, dq + 1):
        coeff = h[i]
        for j in range(max(0, dg - i), min(df - i, dr) + 1):
            coeff -= h[i + j - dg] * g[dg - j]
        h[i] = coeff * inv % p
    return h[:dq + 1]

.sympy.polys.galoistools.gf_random

def gf_random(n, p, K):
    return [K.one] + [K(int(uniform(0, p))) for i in range(0, n)]

.sympy.polys.galoistools._gf_pow_pnm1d2

def _gf_pow_pnm1d2(f, n, g, b, p, K):
    f = gf_rem(f, g, p, K)
    h = f
    r = f
    for i in range(1, n):
        h = gf_frobenius_map(h, g, b, p, K)
        r = gf_mul(r, h, p, K)
        r = gf_rem(r, g, p, K)
    res = gf_pow_mod(r, (p - 1) // 2, g, p, K)
    return res

.sympy.polys.galoistools.gf_sub_ground

def gf_sub_ground(f, a, p, K):
    if not f:
        a = -a % p
    else:
        a = (f[-1] - a) % p
        if len(f) > 1:
            return f[:-1] + [a]
    if not a:
        return []
    else:
        return [a]

.sympy.polys.galoistools.gf_gcdex

def gf_gcdex(f, g, p, K):
    if not (f or g):
        return ([K.one], [], [])
    p0, r0 = gf_monic(f, p, K)
    p1, r1 = gf_monic(g, p, K)
    if not f:
        return ([], [K.invert(p1, p)], r1)
    if not g:
        return ([K.invert(p0, p)], [], r0)
    s0, s1 = ([K.invert(p0, p)], [])
    t0, t1 = ([], [K.invert(p1, p)])
    while True:
        Q, R = gf_div(r0, r1, p, K)
        if not R:
            break
        (lc, r1), r0 = (gf_monic(R, p, K), r1)
        inv = K.invert(lc, p)
        s = gf_sub_mul(s0, s1, Q, p, K)
        t = gf_sub_mul(t0, t1, Q, p, K)
        s1, s0 = (gf_mul_ground(s, inv, p, K), s1)
        t1, t0 = (gf_mul_ground(t, inv, p, K), t1)
    return (s1, t1, r1)

.sympy.polys.galoistools.gf_sub_mul

def gf_sub_mul(f, g, h, p, K):
    return gf_sub(f, gf_mul(g, h, p, K), p, K)

.sympy.polys.galoistools.gf_neg

def gf_neg(f, p, K):
    return [-coeff % p for coeff in f]

.sympy.polys.factortools.dup_zz_hensel_step

def dup_zz_hensel_step(m, f, g, h, s, t, K):
    M = m ** 2
    e = dup_sub_mul(f, g, h, K)
    e = dup_trunc(e, M, K)
    q, r = dup_div(dup_mul(s, e, K), h, K)
    q = dup_trunc(q, M, K)
    r = dup_trunc(r, M, K)
    u = dup_add(dup_mul(t, e, K), dup_mul(q, g, K), K)
    G = dup_trunc(dup_add(g, u, K), M, K)
    H = dup_trunc(dup_add(h, r, K), M, K)
    u = dup_add(dup_mul(s, G, K), dup_mul(t, H, K), K)
    b = dup_trunc(dup_sub(u, [K.one], K), M, K)
    c, d = dup_div(dup_mul(s, b, K), H, K)
    c = dup_trunc(c, M, K)
    d = dup_trunc(d, M, K)
    u = dup_add(dup_mul(t, b, K), dup_mul(c, G, K), K)
    S = dup_trunc(dup_sub(s, d, K), M, K)
    T = dup_trunc(dup_sub(t, u, K), M, K)
    return (G, H, S, T)

.sympy.polys.densearith.dup_sub_mul

def dup_sub_mul(f, g, h, K):
    return dup_sub(f, dup_mul(g, h, K), K)

.sympy.polys.densearith.dup_neg

def dup_neg(f, K):
    return [-coeff for coeff in f]

.sympy.utilities.iterables.subsets

def subsets(seq, k=None, repetition=False):
    if k is None:
        for k in range(len(seq) + 1):
            for i in subsets(seq, k, repetition):
                yield i
    elif not repetition:
        for i in combinations(seq, k):
            yield i
    else:
        for i in combinations_with_replacement(seq, k):
            yield i

.sympy.core.expr.Expr.__rmul__

def __rmul__(self, other):
    return Mul(other, self)

.sympy.solvers.solveset.solveset_real

def solveset_real(f, symbol):
    return solveset(f, symbol, S.Reals)

.sympy.solvers.solveset.solveset

def solveset(f, symbol=None, domain=S.Complexes):
    f = sympify(f)
    symbol = sympify(symbol)
    if f is S.true:
        return domain
    if f is S.false:
        return S.EmptySet
    if not isinstance(f, (Expr, Number)):
        raise ValueError('%s is not a valid SymPy expression' % f)
    if not isinstance(symbol, Expr) and symbol is not None:
        raise ValueError('%s is not a valid SymPy symbol' % symbol)
    if not isinstance(domain, Set):
        raise ValueError('%s is not a valid domain' % domain)
    free_symbols = f.free_symbols
    if symbol is None and (not free_symbols):
        b = Eq(f, 0)
        if b is S.true:
            return domain
        elif b is S.false:
            return S.EmptySet
        else:
            raise NotImplementedError(filldedent('\n                relationship between value and 0 is unknown: %s' % b))
    if symbol is None:
        if len(free_symbols) == 1:
            symbol = free_symbols.pop()
        elif free_symbols:
            raise ValueError(filldedent('\n                The independent variable must be specified for a\n                multivariate equation.'))
    elif not isinstance(symbol, Symbol):
        f, s, swap = recast_to_symbols([f], [symbol])
        return solveset(f[0], s[0], domain).xreplace(swap)
    if domain.is_subset(S.Reals):
        if not symbol.is_real:
            assumptions = symbol.assumptions0
            assumptions['real'] = True
            try:
                r = Dummy('r', **assumptions)
                return solveset(f.xreplace({symbol: r}), r, domain).xreplace({r: symbol})
            except InconsistentAssumptions:
                pass
    f, mask = _masked(f, Abs)
    f = f.rewrite(Piecewise)
    for d, e in mask:
        e = e.func(e.args[0].rewrite(Piecewise))
        f = f.xreplace({d: e})
    f = piecewise_fold(f)
    return _solveset(f, symbol, domain, _check=True)

.sympy.sets.sets.Set.is_subset

def is_subset(self, other):
    if not isinstance(other, Set):
        raise ValueError("Unknown argument '%s'" % other)
    if self == other:
        return True
    is_empty = self.is_empty
    if is_empty is True:
        return True
    elif fuzzy_not(is_empty) and other.is_empty:
        return False
    if self.is_finite_set is False and other.is_finite_set:
        return False
    ret = self._eval_is_subset(other)
    if ret is not None:
        return ret
    ret = other._eval_is_superset(self)
    if ret is not None:
        return ret
    from sympy.sets.handlers.issubset import is_subset_sets
    ret = is_subset_sets(self, other)
    if ret is not None:
        return ret
    if self.intersect(other) == self:
        return True

.sympy.sets.fancysets.Reals.__eq__

def __eq__(self, other):
    return other == Interval(S.NegativeInfinity, S.Infinity)

.sympy.sets.sets.Interval.__new__

def __new__(cls, start, end, left_open=False, right_open=False):
    start = _sympify(start)
    end = _sympify(end)
    left_open = _sympify(left_open)
    right_open = _sympify(right_open)
    if not all((isinstance(a, (type(true), type(false))) for a in [left_open, right_open])):
        raise NotImplementedError('left_open and right_open can have only true/false values, got %s and %s' % (left_open, right_open))
    inftys = [S.Infinity, S.NegativeInfinity]
    if not all((i.is_extended_real is not False or i in inftys for i in (start, end))):
        raise ValueError('Non-real intervals are not supported')
    if (end < start) == True:
        return S.EmptySet
    elif (end - start).is_negative:
        return S.EmptySet
    if end == start and (left_open or right_open):
        return S.EmptySet
    if end == start and (not (left_open or right_open)):
        if start is S.Infinity or start is S.NegativeInfinity:
            return S.EmptySet
        return FiniteSet(end)
    if start is S.NegativeInfinity:
        left_open = true
    if end is S.Infinity:
        right_open = true
    if start == S.Infinity or end == S.NegativeInfinity:
        return S.EmptySet
    return Basic.__new__(cls, start, end, left_open, right_open)

.sympy.core.numbers.Infinity.__sub__

def __sub__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.Infinity or other is S.NaN:
            return S.NaN
        return self
    return Number.__sub__(self, other)

.sympy.core.numbers.Infinity.evalf

def evalf(self, prec=None, **options):
    return self._eval_evalf(prec)

.sympy.core.numbers.Infinity._eval_evalf

def _eval_evalf(self, prec=None):
    return Float('inf')

.sympy.core.numbers.Infinity._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.finf

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    if self is other:
        return True
    tself = type(self)
    tother = type(other)
    if tself is not tother:
        try:
            other = _sympify(other)
            tother = type(other)
        except SympifyError:
            return NotImplemented
        if PY3 or type(tself).__ne__ is not type.__ne__:
            if tself != tother:
                return False
        elif tself is not tother:
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.core.basic.Basic._hashable_content

def _hashable_content(self):
    return self._args

.sympy.solvers.solveset._masked

def _masked(f, *atoms):
    sym = numbered_symbols('a', cls=Dummy, real=True)
    mask = []
    for a in ordered(f.atoms(*atoms)):
        for i in mask:
            a = a.replace(*i)
        mask.append((a, next(sym)))
    for i, (o, n) in enumerate(mask):
        f = f.replace(o, n)
        mask[i] = (n, o)
    mask = list(reversed(mask))
    return (f, mask)

.sympy.core.basic.Basic.rewrite

def rewrite(self, *args, **hints):
    if not args:
        return self
    else:
        pattern = args[:-1]
        if isinstance(args[-1], string_types):
            rule = '_eval_rewrite_as_' + args[-1]
        else:
            try:
                rule = '_eval_rewrite_as_' + args[-1].__name__
            except:
                rule = '_eval_rewrite_as_' + args[-1].__class__.__name__
        if not pattern:
            return self._eval_rewrite(None, rule, **hints)
        else:
            if iterable(pattern[0]):
                pattern = pattern[0]
            pattern = [p for p in pattern if self.has(p)]
            if pattern:
                return self._eval_rewrite(tuple(pattern), rule, **hints)
            else:
                return self

.sympy.core.basic.Basic._eval_rewrite

def _eval_rewrite(self, pattern, rule, **hints):
    if self.is_Atom:
        if hasattr(self, rule):
            return getattr(self, rule)()
        return self
    if hints.get('deep', True):
        args = [a._eval_rewrite(pattern, rule, **hints) if isinstance(a, Basic) else a for a in self.args]
    else:
        args = self.args
    if pattern is None or isinstance(self, pattern):
        if hasattr(self, rule):
            rewritten = getattr(self, rule)(*args, **hints)
            if rewritten is not None:
                return rewritten
    return self.func(*args) if hints.get('evaluate', True) else self

.sympy.functions.elementary.piecewise.piecewise_fold

def piecewise_fold(expr):
    if not isinstance(expr, Basic) or not expr.has(Piecewise):
        return expr
    new_args = []
    if isinstance(expr, (ExprCondPair, Piecewise)):
        for e, c in expr.args:
            if not isinstance(e, Piecewise):
                e = piecewise_fold(e)
            assert not c.has(Piecewise)
            if isinstance(c, ITE):
                c = c.to_nnf()
                c = simplify_logic(c, form='cnf')
            if isinstance(e, Piecewise):
                new_args.extend([(piecewise_fold(ei), And(ci, c)) for ei, ci in e.args])
            else:
                new_args.append((e, c))
    else:
        from sympy.utilities.iterables import cartes, sift, common_prefix
        if expr.is_Add or (expr.is_Mul and expr.is_commutative):
            p, args = sift(expr.args, lambda x: x.is_Piecewise, binary=True)
            pc = sift(p, lambda x: tuple([c for e, c in x.args]))
            for c in list(ordered(pc)):
                if len(pc[c]) > 1:
                    pargs = [list(i.args) for i in pc[c]]
                    com = common_prefix(*[[i.cond for i in j] for j in pargs])
                    n = len(com)
                    collected = []
                    for i in range(n):
                        collected.append((expr.func(*[ai[i].expr for ai in pargs]), com[i]))
                    remains = []
                    for a in pargs:
                        if n == len(a):
                            continue
                        if a[n].cond == True:
                            remains.append(a[n].expr)
                        else:
                            remains.append(Piecewise(*a[n:], evaluate=False))
                    if remains:
                        collected.append((expr.func(*remains), True))
                    args.append(Piecewise(*collected, evaluate=False))
                    continue
                args.extend(pc[c])
        else:
            args = expr.args
        folded = list(map(piecewise_fold, args))
        for ec in cartes(*[i.args if isinstance(i, Piecewise) else [(i, true)] for i in folded]):
            e, c = zip(*ec)
            new_args.append((expr.func(*e), And(*c)))
    return Piecewise(*new_args)

.sympy.solvers.solveset._solveset

def _solveset(f, symbol, domain, _check=False):
    from sympy.simplify.simplify import signsimp
    orig_f = f
    if f.is_Mul:
        coeff, f = f.as_independent(symbol, as_Add=False)
        if coeff in set([S.ComplexInfinity, S.NegativeInfinity, S.Infinity]):
            f = together(orig_f)
    elif f.is_Add:
        a, h = f.as_independent(symbol)
        m, h = h.as_independent(symbol, as_Add=False)
        if m not in set([S.ComplexInfinity, S.Zero, S.Infinity, S.NegativeInfinity]):
            f = a / m + h
    solver = lambda f, x, domain=domain: _solveset(f, x, domain)
    inverter = lambda f, rhs, symbol: _invert(f, rhs, symbol, domain)
    result = EmptySet
    if f.expand().is_zero:
        return domain
    elif not f.has(symbol):
        return EmptySet
    elif f.is_Mul and all((_is_finite_with_finite_vars(m, domain) for m in f.args)):
        result = Union(*[solver(m, symbol) for m in f.args])
    elif _is_function_class_equation(TrigonometricFunction, f, symbol) or _is_function_class_equation(HyperbolicFunction, f, symbol):
        result = _solve_trig(f, symbol, domain)
    elif isinstance(f, arg):
        a = f.args[0]
        result = solveset_real(a > 0, symbol)
    elif f.is_Piecewise:
        result = EmptySet
        expr_set_pairs = f.as_expr_set_pairs(domain)
        for expr, in_set in expr_set_pairs:
            if in_set.is_Relational:
                in_set = in_set.as_set()
            solns = solver(expr, symbol, in_set)
            result += solns
    elif isinstance(f, Eq):
        result = solver(Add(f.lhs, -f.rhs, evaluate=False), symbol, domain)
    elif f.is_Relational:
        if not domain.is_subset(S.Reals):
            raise NotImplementedError(filldedent('\n                Inequalities in the complex domain are\n                not supported. Try the real domain by\n                setting domain=S.Reals'))
        try:
            result = solve_univariate_inequality(f, symbol, domain=domain, relational=False)
        except NotImplementedError:
            result = ConditionSet(symbol, f, domain)
        return result
    elif _is_modular(f, symbol):
        result = _solve_modular(f, symbol, domain)
    else:
        lhs, rhs_s = inverter(f, 0, symbol)
        if lhs == symbol:
            if isinstance(rhs_s, FiniteSet):
                rhs_s = FiniteSet(*[Mul(*signsimp(i).as_content_primitive()) for i in rhs_s])
            result = rhs_s
        elif isinstance(rhs_s, FiniteSet):
            for equation in [lhs - rhs for rhs in rhs_s]:
                if equation == f:
                    if any((_has_rational_power(g, symbol)[0] for g in equation.args)) or _has_rational_power(equation, symbol)[0]:
                        result += _solve_radical(equation, symbol, solver)
                    elif equation.has(Abs):
                        result += _solve_abs(f, symbol, domain)
                    else:
                        result_rational = _solve_as_rational(equation, symbol, domain)
                        if isinstance(result_rational, ConditionSet):
                            result += _transolve(equation, symbol, domain)
                        else:
                            result += result_rational
                else:
                    result += solver(equation, symbol)
        elif rhs_s is not S.EmptySet:
            result = ConditionSet(symbol, Eq(f, 0), domain)
    if isinstance(result, ConditionSet):
        num, den = f.as_numer_denom()
        if den.has(symbol):
            _result = _solveset(num, symbol, domain)
            if not isinstance(_result, ConditionSet):
                singularities = _solveset(den, symbol, domain)
                result = _result - singularities
    if _check:
        if isinstance(result, ConditionSet):
            return result
        fx = orig_f.as_independent(symbol, as_Add=True)[1]
        fx = fx.as_independent(symbol, as_Add=False)[1]
        if isinstance(result, FiniteSet):
            result = FiniteSet(*[s for s in result if isinstance(s, RootOf) or domain_check(fx, symbol, s)])
    return result

.sympy.core.add._unevaluated_Add

def _unevaluated_Add(*args):
    args = list(args)
    newargs = []
    co = S.Zero
    while args:
        a = args.pop()
        if a.is_Add:
            args.extend(a.args)
        elif a.is_Number:
            co += a
        else:
            newargs.append(a)
    _addsort(newargs)
    if co:
        newargs.insert(0, co)
    return Add._from_args(newargs)

.sympy.core.numbers.NegativeInfinity.__hash__

def __hash__(self):
    return super(NegativeInfinity, self).__hash__()

.sympy.core.add.Add._eval_is_infinite

def _eval_is_infinite(self):
    sawinf = False
    for a in self.args:
        ainf = a.is_infinite
        if ainf is None:
            return None
        elif ainf is True:
            if sawinf is True:
                return None
            sawinf = True
    return sawinf

.sympy.solvers.solveset._is_function_class_equation

def _is_function_class_equation(func_class, f, symbol):
    if f.is_Mul or f.is_Add:
        return all((_is_function_class_equation(func_class, arg, symbol) for arg in f.args))
    if f.is_Pow:
        if not f.exp.has(symbol):
            return _is_function_class_equation(func_class, f.base, symbol)
        else:
            return False
    if not f.has(symbol):
        return True
    if isinstance(f, func_class):
        try:
            g = Poly(f.args[0], symbol)
            return g.degree() <= 1
        except PolynomialError:
            return False
    else:
        return False

.sympy.solvers.solveset._is_modular

def _is_modular(f, symbol):
    if not f.has(Mod):
        return False
    modterms = list(f.atoms(Mod))
    return len(modterms) == 1 and modterms[0].args[0].has(symbol) and modterms[0].args[1].is_integer and any((isinstance(term, Mod) for term in list(_term_factors(f))))

.sympy.solvers.solveset._invert

def _invert(f_x, y, x, domain=S.Complexes):
    x = sympify(x)
    if not x.is_Symbol:
        raise ValueError('x must be a symbol')
    f_x = sympify(f_x)
    if x not in f_x.free_symbols:
        raise ValueError("Inverse of constant function doesn't exist")
    y = sympify(y)
    if x in y.free_symbols:
        raise ValueError('y should be independent of x ')
    if domain.is_subset(S.Reals):
        x1, s = _invert_real(f_x, FiniteSet(y), x)
    else:
        x1, s = _invert_complex(f_x, FiniteSet(y), x)
    if not isinstance(s, FiniteSet) or x1 != x:
        return (x1, s)
    return (x1, s.intersection(domain))

.sympy.solvers.solveset._invert_real

def _invert_real(f, g_ys, symbol):
    if f == symbol:
        return (f, g_ys)
    n = Dummy('n', real=True)
    if hasattr(f, 'inverse') and (not isinstance(f, (TrigonometricFunction, HyperbolicFunction))):
        if len(f.args) > 1:
            raise ValueError('Only functions with one argument are supported.')
        return _invert_real(f.args[0], imageset(Lambda(n, f.inverse()(n)), g_ys), symbol)
    if isinstance(f, Abs):
        return _invert_abs(f.args[0], g_ys, symbol)
    if f.is_Add:
        g, h = f.as_independent(symbol)
        if g is not S.Zero:
            return _invert_real(h, imageset(Lambda(n, n - g), g_ys), symbol)
    if f.is_Mul:
        g, h = f.as_independent(symbol)
        if g is not S.One:
            return _invert_real(h, imageset(Lambda(n, n / g), g_ys), symbol)
    if f.is_Pow:
        base, expo = f.args
        base_has_sym = base.has(symbol)
        expo_has_sym = expo.has(symbol)
        if not expo_has_sym:
            res = imageset(Lambda(n, real_root(n, expo)), g_ys)
            if expo.is_rational:
                numer, denom = expo.as_numer_denom()
                if denom % 2 == 0:
                    base_positive = solveset(base >= 0, symbol, S.Reals)
                    res = imageset(Lambda(n, real_root(n, expo)), g_ys.intersect(Interval.Ropen(S.Zero, S.Infinity)))
                    _inv, _set = _invert_real(base, res, symbol)
                    return (_inv, _set.intersect(base_positive))
                elif numer % 2 == 0:
                    n = Dummy('n')
                    neg_res = imageset(Lambda(n, -n), res)
                    return _invert_real(base, res + neg_res, symbol)
                else:
                    return _invert_real(base, res, symbol)
            else:
                if not base.is_positive:
                    raise ValueError('x**w where w is irrational is not defined for negative x')
                return _invert_real(base, res, symbol)
        if not base_has_sym:
            rhs = g_ys.args[0]
            if base.is_positive:
                return _invert_real(expo, imageset(Lambda(n, log(n, base, evaluate=False)), g_ys), symbol)
            elif base.is_negative:
                from sympy.core.power import integer_log
                s, b = integer_log(rhs, base)
                if b:
                    return _invert_real(expo, FiniteSet(s), symbol)
                else:
                    return _invert_real(expo, S.EmptySet, symbol)
            elif base.is_zero:
                one = Eq(rhs, 1)
                if one == S.true:
                    return _invert_real(expo, FiniteSet(0), symbol)
                elif one == S.false:
                    return _invert_real(expo, S.EmptySet, symbol)
    if isinstance(f, TrigonometricFunction):
        if isinstance(g_ys, FiniteSet):

            def inv(trig):
                if isinstance(f, (sin, csc)):
                    F = asin if isinstance(f, sin) else acsc
                    return (lambda a: n * pi + (-1) ** n * F(a),)
                if isinstance(f, (cos, sec)):
                    F = acos if isinstance(f, cos) else asec
                    return (lambda a: 2 * n * pi + F(a), lambda a: 2 * n * pi - F(a))
                if isinstance(f, (tan, cot)):
                    return (lambda a: n * pi + f.inverse()(a),)
            n = Dummy('n', integer=True)
            invs = S.EmptySet
            for L in inv(f):
                invs += Union(*[imageset(Lambda(n, L(g)), S.Integers) for g in g_ys])
            return _invert_real(f.args[0], invs, symbol)
    return (f, g_ys)

.sympy.core.symbol.Dummy.__new__

def __new__(cls, name=None, dummy_index=None, **assumptions):
    if dummy_index is not None:
        assert name is not None, 'If you specify a dummy_index, you must also provide a name'
    if name is None:
        name = 'Dummy_' + str(Dummy._count)
    if dummy_index is None:
        dummy_index = Dummy._base_dummy_index + Dummy._count
        Dummy._count += 1
    cls._sanitize(assumptions, cls)
    obj = Symbol.__xnew__(cls, name, **assumptions)
    obj.dummy_index = dummy_index
    return obj

.sympy.core.symbol.Dummy._hashable_content

def _hashable_content(self):
    return Symbol._hashable_content(self) + (self.dummy_index,)

.sympy.core.function.Lambda.__new__

def __new__(cls, signature, expr):
    if iterable(signature) and (not isinstance(signature, (tuple, Tuple))):
        SymPyDeprecationWarning(feature='non tuple iterable of argument symbols to Lambda', useinstead='tuple of argument symbols', issue=17474, deprecated_since_version='1.5').warn()
        signature = tuple(signature)
    sig = signature if iterable(signature) else (signature,)
    sig = sympify(sig)
    cls._check_signature(sig)
    if len(sig) == 1 and sig[0] == expr:
        return S.IdentityFunction
    return Expr.__new__(cls, sig, sympify(expr))

.sympy.core.function.Lambda._check_signature

def _check_signature(cls, sig):
    syms = set()

    def rcheck(args):
        for a in args:
            if a.is_symbol:
                if a in syms:
                    raise BadSignatureError('Duplicate symbol %s' % a)
                syms.add(a)
            elif isinstance(a, Tuple):
                rcheck(a)
            else:
                raise BadSignatureError('Lambda signature should be only tuples and symbols, not %s' % a)
    if not isinstance(sig, Tuple):
        raise BadSignatureError('Lambda signature should be a tuple not %s' % sig)
    rcheck(sig)

.sympy.core.function.Lambda.rcheck

def rcheck(args):
    for a in args:
        if a.is_symbol:
            if a in syms:
                raise BadSignatureError('Duplicate symbol %s' % a)
            syms.add(a)
        elif isinstance(a, Tuple):
            rcheck(a)
        else:
            raise BadSignatureError('Lambda signature should be only tuples and symbols, not %s' % a)

.sympy.core.containers.Tuple.__len__

def __len__(self):
    return len(self.args)

.sympy.core.containers.Tuple.__getitem__

def __getitem__(self, i):
    if isinstance(i, slice):
        indices = i.indices(len(self))
        return Tuple(*(self.args[j] for j in range(*indices)))
    return self.args[i]

.sympy.sets.sets.imageset

def imageset(*args):
    from sympy.core import Lambda
    from sympy.sets.fancysets import ImageSet
    from sympy.sets.setexpr import set_function
    if len(args) < 2:
        raise ValueError('imageset expects at least 2 args, got: %s' % len(args))
    if isinstance(args[0], (Symbol, tuple)) and len(args) > 2:
        f = Lambda(args[0], args[1])
        set_list = args[2:]
    else:
        f = args[0]
        set_list = args[1:]
    if isinstance(f, Lambda):
        pass
    elif callable(f):
        nargs = getattr(f, 'nargs', {})
        if nargs:
            if len(nargs) != 1:
                raise NotImplementedError(filldedent('\n                    This function can take more than 1 arg\n                    but the potentially complicated set input\n                    has not been analyzed at this point to\n                    know its dimensions. TODO\n                    '))
            N = nargs.args[0]
            if N == 1:
                s = 'x'
            else:
                s = [Symbol('x%i' % i) for i in range(1, N + 1)]
        elif PY3:
            s = inspect.signature(f).parameters
        else:
            s = inspect.getargspec(f).args
        dexpr = _sympify(f(*[Dummy() for i in s]))
        var = tuple((_uniquely_named_symbol(Symbol(i), dexpr) for i in s))
        f = Lambda(var, f(*var))
    else:
        raise TypeError(filldedent("\n            expecting lambda, Lambda, or FunctionClass,\n            not '%s'." % func_name(f)))
    if any((not isinstance(s, Set) for s in set_list)):
        name = [func_name(s) for s in set_list]
        raise ValueError('arguments after mapping should be sets, not %s' % name)
    if len(set_list) == 1:
        set = set_list[0]
        try:
            r = set_function(f, set)
            if r is None:
                raise TypeError
            if not r:
                return r
        except TypeError:
            r = ImageSet(f, set)
        if isinstance(r, ImageSet):
            f, set = r.args
        if f.variables[0] == f.expr:
            return set
        if isinstance(set, ImageSet):
            if len(set.lamda.variables) == 1 and len(f.variables) == 1:
                x = set.lamda.variables[0]
                y = f.variables[0]
                return imageset(Lambda(x, f.expr.subs(y, set.lamda.expr)), *set.base_sets)
        if r is not None:
            return r
    return ImageSet(f, *set_list)

.sympy.sets.sets.set_function

def set_function(f, x):
    from sympy.sets.handlers.functions import _set_function
    return _set_function(f, x)

.sympy.multipledispatch.dispatcher.Dispatcher.__call__

def __call__(self, *args, **kwargs):
    types = tuple([type(arg) for arg in args])
    try:
        func = self._cache[types]
    except KeyError:
        func = self.dispatch(*types)
        if not func:
            raise NotImplementedError('Could not find signature for %s: <%s>' % (self.name, str_signature(types)))
        self._cache[types] = func
    try:
        return func(*args, **kwargs)
    except MDNotImplementedError:
        funcs = self.dispatch_iter(*types)
        next(funcs)
        for func in funcs:
            try:
                return func(*args, **kwargs)
            except MDNotImplementedError:
                pass
        raise NotImplementedError('Matching functions for %s: <%s> found, but none completed successfully' % (self.name, str_signature(types)))

.sympy.sets.handlers.functions._set_function

def _set_function(f, x):
    return None

.sympy.sets.sets.FiniteSet.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.core.function.Lambda.__call__

def __call__(self, *args):
    n = len(args)
    if n not in self.nargs:
        temp = '%(name)s takes exactly %(args)s argument%(plural)s (%(given)s given)'
        raise BadArgumentsError(temp % {'name': self, 'args': list(self.nargs)[0], 'plural': 's' * (list(self.nargs)[0] != 1), 'given': n})
    d = self._match_signature(self.signature, args)
    return self.expr.xreplace(d)

.sympy.core.function.Lambda.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(len(self.signature))

.sympy.core.function.Lambda.signature

def signature(self):
    return self._args[0]

.sympy.core.function.Lambda._match_signature

def _match_signature(self, sig, args):
    symargmap = {}

    def rmatch(pars, args):
        for par, arg in zip(pars, args):
            if par.is_symbol:
                symargmap[par] = arg
            elif isinstance(par, Tuple):
                if not isinstance(arg, (tuple, Tuple)) or len(args) != len(pars):
                    raise BadArgumentsError("Can't match %s and %s" % (args, pars))
                rmatch(par, arg)
    rmatch(sig, args)
    return symargmap

.sympy.core.function.Lambda.rmatch

def rmatch(pars, args):
    for par, arg in zip(pars, args):
        if par.is_symbol:
            symargmap[par] = arg
        elif isinstance(par, Tuple):
            if not isinstance(arg, (tuple, Tuple)) or len(args) != len(pars):
                raise BadArgumentsError("Can't match %s and %s" % (args, pars))
            rmatch(par, arg)

.sympy.core.function.Lambda.expr

def expr(self):
    return self._args[1]

.sympy.sets.sets.FiniteSet.__len__

def __len__(self):
    return len(self.args)

.sympy.core.function.Lambda.variables

def variables(self):

    def _variables(args):
        if isinstance(args, Tuple):
            for arg in args:
                for a in _variables(arg):
                    yield a
        else:
            yield args
    return tuple(_variables(self.signature))

.sympy.core.function.Lambda._variables

def _variables(args):
    if isinstance(args, Tuple):
        for arg in args:
            for a in _variables(arg):
                yield a
    else:
        yield args

.sympy.solvers.solveset._has_rational_power

def _has_rational_power(expr, symbol):
    a, p, q = (Wild('a'), Wild('p'), Wild('q'))
    pattern_match = expr.match(a * p ** q) or {}
    if pattern_match.get(a, S.Zero).is_zero:
        return (False, S.One)
    elif p not in pattern_match.keys():
        return (False, S.One)
    elif isinstance(pattern_match[q], Rational) and pattern_match[p].has(symbol):
        if not pattern_match[q].q == S.One:
            return (True, pattern_match[q].q)
    if not isinstance(pattern_match[a], Pow) or isinstance(pattern_match[a], Mul):
        return (False, S.One)
    else:
        return _has_rational_power(pattern_match[a], symbol)

.sympy.core.symbol.Wild.__new__

def __new__(cls, name, exclude=(), properties=(), **assumptions):
    exclude = tuple([sympify(x) for x in exclude])
    properties = tuple(properties)
    cls._sanitize(assumptions, cls)
    return Wild.__xnew__(cls, name, exclude, properties, **assumptions)

.sympy.core.symbol.Wild.__xnew__

def __xnew__(cls, name, exclude, properties, **assumptions):
    obj = Symbol.__xnew__(cls, name, **assumptions)
    obj.exclude = exclude
    obj.properties = properties
    return obj

.sympy.core.symbol.Wild._hashable_content

def _hashable_content(self):
    return super(Wild, self)._hashable_content() + (self.exclude, self.properties)

.sympy.core.basic.Basic.match

def match(self, pattern, old=False):
    pattern = sympify(pattern)
    return pattern.matches(self, old=old)

.sympy.core.mul.Mul.matches

def matches(self, expr, repl_dict={}, old=False):
    expr = sympify(expr)
    if self.is_commutative and expr.is_commutative:
        return AssocOp._matches_commutative(self, expr, repl_dict, old)
    elif self.is_commutative is not expr.is_commutative:
        return None
    c1, nc1 = self.args_cnc()
    c2, nc2 = expr.args_cnc()
    c1, c2 = [c or [1] for c in [c1, c2]]
    comm_mul_self = Mul(*c1)
    comm_mul_expr = Mul(*c2)
    repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)
    if repl_dict is None and c1 != c2:
        return None
    nc1 = Mul._matches_expand_pows(nc1)
    nc2 = Mul._matches_expand_pows(nc2)
    repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)
    return repl_dict or None

.sympy.core.operations.AssocOp._matches_commutative

def _matches_commutative(self, expr, repl_dict={}, old=False):
    from .expr import Add, Expr
    from sympy import Mul
    if isinstance(self, Expr) and (not isinstance(expr, Expr)):
        return None
    if self == expr:
        return repl_dict
    d = self._matches_simple(expr, repl_dict)
    if d is not None:
        return d
    from .function import WildFunction
    from .symbol import Wild
    wild_part, exact_part = sift(self.args, lambda p: p.has(Wild, WildFunction) and (not expr.has(p)), binary=True)
    if not exact_part:
        wild_part = list(ordered(wild_part))
    else:
        exact = self._new_rawargs(*exact_part)
        free = expr.free_symbols
        if free and exact.free_symbols - free:
            return None
        newexpr = self._combine_inverse(expr, exact)
        if not old and (expr.is_Add or expr.is_Mul):
            if newexpr.count_ops() > expr.count_ops():
                return None
        newpattern = self._new_rawargs(*wild_part)
        return newpattern.matches(newexpr, repl_dict)
    i = 0
    saw = set()
    while expr not in saw:
        saw.add(expr)
        expr_list = (self.identity,) + tuple(ordered(self.make_args(expr)))
        for last_op in reversed(expr_list):
            for w in reversed(wild_part):
                d1 = w.matches(last_op, repl_dict)
                if d1 is not None:
                    d2 = self.xreplace(d1).matches(expr, d1)
                    if d2 is not None:
                        return d2
        if i == 0:
            if self.is_Mul:
                if expr.is_Pow and expr.exp.is_Integer:
                    if expr.exp > 0:
                        expr = Mul(*[expr.base, expr.base ** (expr.exp - 1)], evaluate=False)
                    else:
                        expr = Mul(*[1 / expr.base, expr.base ** (expr.exp + 1)], evaluate=False)
                    i += 1
                    continue
            elif self.is_Add:
                c, e = expr.as_coeff_Mul()
                if abs(c) > 1:
                    if c > 0:
                        expr = Add(*[e, (c - 1) * e], evaluate=False)
                    else:
                        expr = Add(*[-e, (c + 1) * e], evaluate=False)
                    i += 1
                    continue
                from sympy.simplify.radsimp import collect
                was = expr
                did = set()
                for w in reversed(wild_part):
                    c, w = w.as_coeff_mul(Wild)
                    free = c.free_symbols - did
                    if free:
                        did.update(free)
                        expr = collect(expr, free)
                if expr != was:
                    i += 0
                    continue
            break
    return

.sympy.core.mul.Mul._matches_simple

def _matches_simple(self, expr, repl_dict):
    coeff, terms = self.as_coeff_Mul()
    terms = Mul.make_args(terms)
    if len(terms) == 1:
        newexpr = self.__class__._combine_inverse(expr, coeff)
        return terms[0].matches(newexpr, repl_dict)
    return

.sympy.core.compatibility._nodes

def _nodes(e):
    from .basic import Basic
    if isinstance(e, Basic):
        return e.count(Basic)
    elif iterable(e):
        return 1 + sum((_nodes(ei) for ei in e))
    elif isinstance(e, dict):
        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))
    else:
        return 1

.sympy.core.basic.Basic.count

def count(self, query):
    query = _make_find_query(query)
    return sum((bool(query(sub)) for sub in preorder_traversal(self)))

.sympy.core.basic._make_find_query

def _make_find_query(query):
    try:
        query = sympify(query)
    except SympifyError:
        pass
    if isinstance(query, type):
        return lambda expr: isinstance(expr, query)
    elif isinstance(query, Basic):
        return lambda expr: expr.match(query) is not None
    return query

.sympy.core.power.Pow.matches

def matches(self, expr, repl_dict={}, old=False):
    expr = _sympify(expr)
    if expr is S.One:
        d = repl_dict.copy()
        d = self.exp.matches(S.Zero, d)
        if d is not None:
            return d
    if not isinstance(expr, Expr):
        return None
    b, e = expr.as_base_exp()
    sb, se = self.as_base_exp()
    if sb.is_Symbol and se.is_Integer and expr:
        if e.is_rational:
            return sb.matches(b ** (e / se), repl_dict)
        return sb.matches(expr ** (1 / se), repl_dict)
    d = repl_dict.copy()
    d = self.base.matches(b, d)
    if d is None:
        return None
    d = self.exp.xreplace(d).matches(e, d)
    if d is None:
        return Expr.matches(self, expr, repl_dict)
    return d

.sympy.core.symbol.Wild.matches

def matches(self, expr, repl_dict={}, old=False):
    if any((expr.has(x) for x in self.exclude)):
        return None
    if any((not f(expr) for f in self.properties)):
        return None
    repl_dict = repl_dict.copy()
    repl_dict[self] = expr
    return repl_dict

.sympy.core.basic.Atom.xreplace

def xreplace(self, rule, hack2=False):
    return rule.get(self, self)

.sympy.core.mul.Mul._combine_inverse

def _combine_inverse(lhs, rhs):
    from .symbol import Dummy
    if lhs == rhs:
        return S.One

    def check(l, r):
        if l.is_Float and r.is_comparable:
            return l.__add__(0) == r.evalf().__add__(0)
        return False
    if check(lhs, rhs) or check(rhs, lhs):
        return S.One
    if any((i.is_Pow or i.is_Mul for i in (lhs, rhs))):
        d = Dummy('I')
        _i = {S.ImaginaryUnit: d}
        i_ = {d: S.ImaginaryUnit}
        a = lhs.xreplace(_i).as_powers_dict()
        b = rhs.xreplace(_i).as_powers_dict()
        blen = len(b)
        for bi in tuple(b.keys()):
            if bi in a:
                a[bi] -= b.pop(bi)
                if not a[bi]:
                    a.pop(bi)
        if len(b) != blen:
            lhs = Mul(*[k ** v for k, v in a.items()]).xreplace(i_)
            rhs = Mul(*[k ** v for k, v in b.items()]).xreplace(i_)
    return lhs / rhs

.sympy.core.mul.Mul.check

def check(l, r):
    if l.is_Float and r.is_comparable:
        return l.__add__(0) == r.evalf().__add__(0)
    return False

.sympy.core.mul.Mul.as_powers_dict

def as_powers_dict(self):
    d = defaultdict(int)
    for term in self.args:
        for b, e in term.as_powers_dict().items():
            d[b] += e
    return d

.sympy.core.expr.Expr.as_powers_dict

def as_powers_dict(self):
    d = defaultdict(int)
    d.update(dict([self.as_base_exp()]))
    return d

.sympy.core.expr.Expr.count_ops

def count_ops(self, visual=None):
    from .function import count_ops
    return count_ops(self, visual)

.sympy.core.function.count_ops

def count_ops(expr, visual=False):
    from sympy import Integral, Symbol
    from sympy.core.relational import Relational
    from sympy.simplify.radsimp import fraction
    from sympy.logic.boolalg import BooleanFunction
    from sympy.utilities.misc import func_name
    expr = sympify(expr)
    if isinstance(expr, Expr) and (not expr.is_Relational):
        ops = []
        args = [expr]
        NEG = Symbol('NEG')
        DIV = Symbol('DIV')
        SUB = Symbol('SUB')
        ADD = Symbol('ADD')
        while args:
            a = args.pop()
            if a.is_Rational:
                if a is not S.One:
                    if a.p < 0:
                        ops.append(NEG)
                    if a.q != 1:
                        ops.append(DIV)
                    continue
            elif a.is_Mul or a.is_MatMul:
                if _coeff_isneg(a):
                    ops.append(NEG)
                    if a.args[0] is S.NegativeOne:
                        a = a.as_two_terms()[1]
                    else:
                        a = -a
                n, d = fraction(a)
                if n.is_Integer:
                    ops.append(DIV)
                    if n < 0:
                        ops.append(NEG)
                    args.append(d)
                    continue
                elif d is not S.One:
                    if not d.is_Integer:
                        args.append(d)
                    ops.append(DIV)
                    args.append(n)
                    continue
            elif a.is_Add or a.is_MatAdd:
                aargs = list(a.args)
                negs = 0
                for i, ai in enumerate(aargs):
                    if _coeff_isneg(ai):
                        negs += 1
                        args.append(-ai)
                        if i > 0:
                            ops.append(SUB)
                    else:
                        args.append(ai)
                        if i > 0:
                            ops.append(ADD)
                if negs == len(aargs):
                    ops.append(NEG)
                elif _coeff_isneg(aargs[0]):
                    ops.append(SUB - ADD)
                continue
            if a.is_Pow and a.exp is S.NegativeOne:
                ops.append(DIV)
                args.append(a.base)
                continue
            if a.is_Mul or a.is_Pow or a.is_Function or isinstance(a, Derivative) or isinstance(a, Integral):
                o = Symbol(a.func.__name__.upper())
                if a.is_Mul or isinstance(a, LatticeOp):
                    ops.append(o * (len(a.args) - 1))
                else:
                    ops.append(o)
            if not a.is_Symbol:
                args.extend(a.args)
    elif isinstance(expr, Dict):
        ops = [count_ops(k, visual=visual) + count_ops(v, visual=visual) for k, v in expr.items()]
    elif iterable(expr):
        ops = [count_ops(i, visual=visual) for i in expr]
    elif isinstance(expr, (Relational, BooleanFunction)):
        ops = []
        for arg in expr.args:
            ops.append(count_ops(arg, visual=True))
        o = Symbol(func_name(expr, short=True).upper())
        ops.append(o)
    elif not isinstance(expr, Basic):
        ops = []
    elif not isinstance(expr, Basic):
        raise TypeError('Invalid type of expr')
    else:
        ops = []
        args = [expr]
        while args:
            a = args.pop()
            if a.args:
                o = Symbol(a.func.__name__.upper())
                if a.is_Boolean:
                    ops.append(o * (len(a.args) - 1))
                else:
                    ops.append(o)
                args.extend(a.args)
    if not ops:
        if visual:
            return S.Zero
        return 0
    ops = Add(*ops)
    if visual:
        return ops
    if ops.is_Number:
        return int(ops)
    return sum((int((a.args or [1])[0]) for a in Add.make_args(ops)))

.sympy.solvers.solveset._solve_as_rational

def _solve_as_rational(f, symbol, domain):
    f = together(f, deep=True)
    g, h = fraction(f)
    if not h.has(symbol):
        try:
            return _solve_as_poly(g, symbol, domain)
        except NotImplementedError:
            return ConditionSet(symbol, Eq(f, 0), domain)
        except CoercionFailed:
            return S.EmptySet
    else:
        valid_solns = _solveset(g, symbol, domain)
        invalid_solns = _solveset(h, symbol, domain)
        return valid_solns - invalid_solns

.sympy.core.numbers.Integer._eval_power

def _eval_power(self, expt):
    from sympy.ntheory.factor_ import perfect_power
    if expt is S.Infinity:
        if self.p > S.One:
            return S.Infinity
        return S.Infinity + S.ImaginaryUnit * S.Infinity
    if expt is S.NegativeInfinity:
        return Rational(1, self) ** S.Infinity
    if not isinstance(expt, Number):
        if self.is_negative and expt.is_even:
            return (-self) ** expt
    if isinstance(expt, Float):
        return super(Integer, self)._eval_power(expt)
    if not isinstance(expt, Rational):
        return
    if expt is S.Half and self.is_negative:
        return S.ImaginaryUnit * Pow(-self, expt)
    if expt.is_negative:
        ne = -expt
        if self.is_negative:
            return S.NegativeOne ** expt * Rational(1, -self) ** ne
        else:
            return Rational(1, self.p) ** ne
    x, xexact = integer_nthroot(abs(self.p), expt.q)
    if xexact:
        result = Integer(x ** abs(expt.p))
        if self.is_negative:
            result *= S.NegativeOne ** expt
        return result
    b_pos = int(abs(self.p))
    p = perfect_power(b_pos)
    if p is not False:
        dict = {p[0]: p[1]}
    else:
        dict = Integer(b_pos).factors(limit=2 ** 15)
    out_int = 1
    out_rad = 1
    sqr_int = 1
    sqr_gcd = 0
    sqr_dict = {}
    for prime, exponent in dict.items():
        exponent *= expt.p
        div_e, div_m = divmod(exponent, expt.q)
        if div_e > 0:
            out_int *= prime ** div_e
        if div_m > 0:
            g = igcd(div_m, expt.q)
            if g != 1:
                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))
            else:
                sqr_dict[prime] = div_m
    for p, ex in sqr_dict.items():
        if sqr_gcd == 0:
            sqr_gcd = ex
        else:
            sqr_gcd = igcd(sqr_gcd, ex)
            if sqr_gcd == 1:
                break
    for k, v in sqr_dict.items():
        sqr_int *= k ** (v // sqr_gcd)
    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):
        result = None
    else:
        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))
        if self.is_negative:
            result *= Pow(S.NegativeOne, expt)
    return result

.sympy.solvers.solveset._solve_as_poly

def _solve_as_poly(f, symbol, domain=S.Complexes):
    result = None
    if f.is_polynomial(symbol):
        solns = roots(f, symbol, cubics=True, quartics=True, quintics=True, domain='EX')
        num_roots = sum(solns.values())
        if degree(f, symbol) <= num_roots:
            result = FiniteSet(*solns.keys())
        else:
            poly = Poly(f, symbol)
            solns = poly.all_roots()
            if poly.degree() <= len(solns):
                result = FiniteSet(*solns)
            else:
                result = ConditionSet(symbol, Eq(f, 0), domain)
    else:
        poly = Poly(f)
        if poly is None:
            result = ConditionSet(symbol, Eq(f, 0), domain)
        gens = [g for g in poly.gens if g.has(symbol)]
        if len(gens) == 1:
            poly = Poly(poly, gens[0])
            gen = poly.gen
            deg = poly.degree()
            poly = Poly(poly.as_expr(), poly.gen, composite=True)
            poly_solns = FiniteSet(*roots(poly, cubics=True, quartics=True, quintics=True).keys())
            if len(poly_solns) < deg:
                result = ConditionSet(symbol, Eq(f, 0), domain)
            if gen != symbol:
                y = Dummy('y')
                inverter = invert_real if domain.is_subset(S.Reals) else invert_complex
                lhs, rhs_s = inverter(gen, y, symbol)
                if lhs == symbol:
                    result = Union(*[rhs_s.subs(y, s) for s in poly_solns])
                else:
                    result = ConditionSet(symbol, Eq(f, 0), domain)
        else:
            result = ConditionSet(symbol, Eq(f, 0), domain)
    if result is not None:
        if isinstance(result, FiniteSet):
            if all([s.atoms(Symbol, AppliedUndef) == set() and (not isinstance(s, RootOf)) for s in result]):
                s = Dummy('s')
                result = imageset(Lambda(s, expand_complex(s)), result)
        if isinstance(result, FiniteSet):
            result = result.intersection(domain)
        return result
    else:
        return ConditionSet(symbol, Eq(f, 0), domain)

.sympy.polys.polyroots.roots

def roots(f, *gens, **flags):
    from sympy.polys.polytools import to_rational_coeffs
    flags = dict(flags)
    auto = flags.pop('auto', True)
    cubics = flags.pop('cubics', True)
    trig = flags.pop('trig', False)
    quartics = flags.pop('quartics', True)
    quintics = flags.pop('quintics', False)
    multiple = flags.pop('multiple', False)
    filter = flags.pop('filter', None)
    predicate = flags.pop('predicate', None)
    if isinstance(f, list):
        if gens:
            raise ValueError('redundant generators given')
        x = Dummy('x')
        poly, i = ({}, len(f) - 1)
        for coeff in f:
            poly[i], i = (sympify(coeff), i - 1)
        f = Poly(poly, x, field=True)
    else:
        try:
            f = Poly(f, *gens, **flags)
            if f.length == 2 and f.degree() != 1:
                n = f.degree()
                npow_bases = []
                others = []
                expr = f.as_expr()
                con = expr.as_independent(*gens)[0]
                for p in Mul.make_args(con):
                    if p.is_Pow and (not p.exp % n):
                        npow_bases.append(p.base ** (p.exp / n))
                    else:
                        others.append(p)
                    if npow_bases:
                        b = Mul(*npow_bases)
                        B = Dummy()
                        d = roots(Poly(expr - con + B ** n * Mul(*others), *gens, **flags), *gens, **flags)
                        rv = {}
                        for k, v in d.items():
                            rv[k.subs(B, b)] = v
                        return rv
        except GeneratorsNeeded:
            if multiple:
                return []
            else:
                return {}
        if f.is_multivariate:
            raise PolynomialError('multivariate polynomials are not supported')

    def _update_dict(result, currentroot, k):
        if currentroot in result:
            result[currentroot] += k
        else:
            result[currentroot] = k

    def _try_decompose(f):
        factors, roots = (f.decompose(), [])
        for currentroot in _try_heuristics(factors[0]):
            roots.append(currentroot)
        for currentfactor in factors[1:]:
            previous, roots = (list(roots), [])
            for currentroot in previous:
                g = currentfactor - Poly(currentroot, f.gen)
                for currentroot in _try_heuristics(g):
                    roots.append(currentroot)
        return roots

    def _try_heuristics(f):
        if f.is_ground:
            return []
        if f.is_monomial:
            return [S.Zero] * f.degree()
        if f.length() == 2:
            if f.degree() == 1:
                return list(map(cancel, roots_linear(f)))
            else:
                return roots_binomial(f)
        result = []
        for i in [-1, 1]:
            if not f.eval(i):
                f = f.quo(Poly(f.gen - i, f.gen))
                result.append(i)
                break
        n = f.degree()
        if n == 1:
            result += list(map(cancel, roots_linear(f)))
        elif n == 2:
            result += list(map(cancel, roots_quadratic(f)))
        elif f.is_cyclotomic:
            result += roots_cyclotomic(f)
        elif n == 3 and cubics:
            result += roots_cubic(f, trig=trig)
        elif n == 4 and quartics:
            result += roots_quartic(f)
        elif n == 5 and quintics:
            result += roots_quintic(f)
        return result
    (k,), f = f.terms_gcd()
    if not k:
        zeros = {}
    else:
        zeros = {S.Zero: k}
    coeff, f = preprocess_roots(f)
    if auto and f.get_domain().is_Ring:
        f = f.to_field()
    rescale_x = None
    translate_x = None
    result = {}
    if not f.is_ground:
        dom = f.get_domain()
        if not dom.is_Exact and dom.is_Numerical:
            for r in f.nroots():
                _update_dict(result, r, 1)
        elif f.degree() == 1:
            result[roots_linear(f)[0]] = 1
        elif f.length() == 2:
            roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial
            for r in roots_fun(f):
                _update_dict(result, r, 1)
        else:
            _, factors = Poly(f.as_expr()).factor_list()
            if len(factors) == 1 and f.degree() == 2:
                for r in roots_quadratic(f):
                    _update_dict(result, r, 1)
            elif len(factors) == 1 and factors[0][1] == 1:
                if f.get_domain().is_EX:
                    res = to_rational_coeffs(f)
                    if res:
                        if res[0] is None:
                            translate_x, f = res[2:]
                        else:
                            rescale_x, f = (res[1], res[-1])
                        result = roots(f)
                        if not result:
                            for currentroot in _try_decompose(f):
                                _update_dict(result, currentroot, 1)
                    else:
                        for r in _try_heuristics(f):
                            _update_dict(result, r, 1)
                else:
                    for currentroot in _try_decompose(f):
                        _update_dict(result, currentroot, 1)
            else:
                for currentfactor, k in factors:
                    for r in _try_heuristics(Poly(currentfactor, f.gen, field=True)):
                        _update_dict(result, r, k)
    if coeff is not S.One:
        _result, result = (result, {})
        for currentroot, k in _result.items():
            result[coeff * currentroot] = k
    if filter not in [None, 'C']:
        handlers = {'Z': lambda r: r.is_Integer, 'Q': lambda r: r.is_Rational, 'R': lambda r: all((a.is_real for a in r.as_numer_denom())), 'I': lambda r: r.is_imaginary}
        try:
            query = handlers[filter]
        except KeyError:
            raise ValueError('Invalid filter: %s' % filter)
        for zero in dict(result).keys():
            if not query(zero):
                del result[zero]
    if predicate is not None:
        for zero in dict(result).keys():
            if not predicate(zero):
                del result[zero]
    if rescale_x:
        result1 = {}
        for k, v in result.items():
            result1[k * rescale_x] = v
        result = result1
    if translate_x:
        result1 = {}
        for k, v in result.items():
            result1[k + translate_x] = v
        result = result1
    result.update(zeros)
    if not multiple:
        return result
    else:
        zeros = []
        for zero in ordered(result):
            zeros.extend([zero] * result[zero])
        return zeros

.sympy.polys.polyoptions.Domain.preprocess

def preprocess(cls, domain):
    if isinstance(domain, sympy.polys.domains.Domain):
        return domain
    elif hasattr(domain, 'to_domain'):
        return domain.to_domain()
    elif isinstance(domain, string_types):
        if domain in ['Z', 'ZZ']:
            return sympy.polys.domains.ZZ
        if domain in ['Q', 'QQ']:
            return sympy.polys.domains.QQ
        if domain == 'EX':
            return sympy.polys.domains.EX
        r = cls._re_realfield.match(domain)
        if r is not None:
            _, _, prec = r.groups()
            if prec is None:
                return sympy.polys.domains.RR
            else:
                return sympy.polys.domains.RealField(int(prec))
        r = cls._re_complexfield.match(domain)
        if r is not None:
            _, _, prec = r.groups()
            if prec is None:
                return sympy.polys.domains.CC
            else:
                return sympy.polys.domains.ComplexField(int(prec))
        r = cls._re_finitefield.match(domain)
        if r is not None:
            return sympy.polys.domains.FF(int(r.groups()[1]))
        r = cls._re_polynomial.match(domain)
        if r is not None:
            ground, gens = r.groups()
            gens = list(map(sympify, gens.split(',')))
            if ground in ['Z', 'ZZ']:
                return sympy.polys.domains.ZZ.poly_ring(*gens)
            elif ground in ['Q', 'QQ']:
                return sympy.polys.domains.QQ.poly_ring(*gens)
            elif ground in ['R', 'RR']:
                return sympy.polys.domains.RR.poly_ring(*gens)
            else:
                return sympy.polys.domains.CC.poly_ring(*gens)
        r = cls._re_fraction.match(domain)
        if r is not None:
            ground, gens = r.groups()
            gens = list(map(sympify, gens.split(',')))
            if ground in ['Z', 'ZZ']:
                return sympy.polys.domains.ZZ.frac_field(*gens)
            else:
                return sympy.polys.domains.QQ.frac_field(*gens)
        r = cls._re_algebraic.match(domain)
        if r is not None:
            gens = list(map(sympify, r.groups()[1].split(',')))
            return sympy.polys.domains.QQ.algebraic_field(*gens)
    raise OptionError('expected a valid domain specification, got %s' % domain)

.sympy.polys.polyoptions.Gens.preprocess

def preprocess(cls, gens):
    if isinstance(gens, Basic):
        gens = (gens,)
    elif len(gens) == 1 and hasattr(gens[0], '__iter__'):
        gens = gens[0]
    if gens == (None,):
        gens = ()
    elif has_dups(gens):
        raise GeneratorsError('duplicated generators: %s' % str(gens))
    elif any((gen.is_commutative is False for gen in gens)):
        raise GeneratorsError('non-commutative generators: %s' % str(gens))
    return tuple(gens)

.sympy.utilities.iterables.has_dups

def has_dups(seq):
    from sympy.core.containers import Dict
    from sympy.sets.sets import Set
    if isinstance(seq, (dict, set, Dict, Set)):
        return False
    uniq = set()
    return any((True for s in seq if s in uniq or uniq.add(s)))

.sympy.polys.polyutils._dict_from_expr_if_gens

def _dict_from_expr_if_gens(expr, opt):
    (poly,), gens = _parallel_dict_from_expr_if_gens((expr,), opt)
    return (poly, gens)

.sympy.polys.polyutils._parallel_dict_from_expr_if_gens

def _parallel_dict_from_expr_if_gens(exprs, opt):
    k, indices = (len(opt.gens), {})
    for i, g in enumerate(opt.gens):
        indices[g] = i
    polys = []
    for expr in exprs:
        poly = {}
        if expr.is_Equality:
            expr = expr.lhs - expr.rhs
        for term in Add.make_args(expr):
            coeff, monom = ([], [0] * k)
            for factor in Mul.make_args(term):
                if not _not_a_coeff(factor) and factor.is_Number:
                    coeff.append(factor)
                else:
                    try:
                        if opt.series is False:
                            base, exp = decompose_power(factor)
                            if exp < 0:
                                exp, base = (-exp, Pow(base, -S.One))
                        else:
                            base, exp = decompose_power_rat(factor)
                        monom[indices[base]] = exp
                    except KeyError:
                        if not factor.free_symbols.intersection(opt.gens):
                            coeff.append(factor)
                        else:
                            raise PolynomialError('%s contains an element of the set of generators.' % factor)
            monom = tuple(monom)
            if monom in poly:
                poly[monom] += Mul(*coeff)
            else:
                poly[monom] = Mul(*coeff)
        polys.append(poly)
    return (polys, opt.gens)

.sympy.polys.domains.expressiondomain.ExpressionDomain.from_sympy

def from_sympy(self, a):
    return self.dtype(a)

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.__init__

def __init__(self):
    pass

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.__nonzero__

def __nonzero__(f):
    return f.ex != 0

.sympy.polys.polytools.Poly.is_multivariate

def is_multivariate(f):
    return len(f.gens) != 1

.sympy.polys.polytools.Poly.terms_gcd

def terms_gcd(f):
    if hasattr(f.rep, 'terms_gcd'):
        J, result = f.rep.terms_gcd()
    else:
        raise OperationNotSupported(f, 'terms_gcd')
    return (J, f.per(result))

.sympy.polys.polyclasses.DMP.terms_gcd

def terms_gcd(f):
    J, F = dmp_terms_gcd(f.rep, f.lev, f.dom)
    return (J, f.per(F))

.sympy.polys.polyroots.preprocess_roots

def preprocess_roots(poly):
    coeff = S.One
    poly_func = poly.func
    try:
        _, poly = poly.clear_denoms(convert=True)
    except DomainError:
        return (coeff, poly)
    poly = poly.primitive()[1]
    poly = poly.retract()
    if poly.get_domain().is_Poly and all((c.is_term for c in poly.rep.coeffs())):
        poly = poly.inject()
        strips = list(zip(*poly.monoms()))
        gens = list(poly.gens[1:])
        base, strips = (strips[0], strips[1:])
        for gen, strip in zip(list(gens), strips):
            reverse = False
            if strip[0] < strip[-1]:
                strip = reversed(strip)
                reverse = True
            ratio = None
            for a, b in zip(base, strip):
                if not a and (not b):
                    continue
                elif not a or not b:
                    break
                elif b % a != 0:
                    break
                else:
                    _ratio = b // a
                    if ratio is None:
                        ratio = _ratio
                    elif ratio != _ratio:
                        break
            else:
                if reverse:
                    ratio = -ratio
                poly = poly.eval(gen, 1)
                coeff *= gen ** (-ratio)
                gens.remove(gen)
        if gens:
            poly = poly.eject(*gens)
    if poly.is_univariate and poly.get_domain().is_ZZ:
        basis = _integer_basis(poly)
        if basis is not None:
            n = poly.degree()

            def func(k, coeff):
                return coeff // basis ** (n - k[0])
            poly = poly.termwise(func)
            coeff *= basis
    if not isinstance(poly, poly_func):
        poly = poly_func(poly)
    return (coeff, poly)

.sympy.polys.polytools.Poly.clear_denoms

def clear_denoms(self, convert=False):
    f = self
    if not f.rep.dom.is_Field:
        return (S.One, f)
    dom = f.get_domain()
    if dom.has_assoc_Ring:
        dom = f.rep.dom.get_ring()
    if hasattr(f.rep, 'clear_denoms'):
        coeff, result = f.rep.clear_denoms()
    else:
        raise OperationNotSupported(f, 'clear_denoms')
    coeff, f = (dom.to_sympy(coeff), f.per(result))
    if not convert or not dom.has_assoc_Ring:
        return (coeff, f)
    else:
        return (coeff, f.to_ring())

.sympy.polys.polytools.Poly.get_domain

def get_domain(f):
    return f.rep.dom

.sympy.polys.polyclasses.DMP.clear_denoms

def clear_denoms(f):
    coeff, F = dmp_clear_denoms(f.rep, f.lev, f.dom)
    return (coeff, f.per(F))

.sympy.polys.densetools.dmp_clear_denoms

def dmp_clear_denoms(f, u, K0, K1=None, convert=False):
    if not u:
        return dup_clear_denoms(f, K0, K1, convert=convert)
    if K1 is None:
        if K0.has_assoc_Ring:
            K1 = K0.get_ring()
        else:
            K1 = K0
    common = _rec_clear_denoms(f, u, K0, K1)
    if not K1.is_one(common):
        f = dmp_mul_ground(f, common, u, K0)
    if not convert:
        return (common, f)
    else:
        return (common, dmp_convert(f, u, K0, K1))

.sympy.polys.densetools.dup_clear_denoms

def dup_clear_denoms(f, K0, K1=None, convert=False):
    if K1 is None:
        if K0.has_assoc_Ring:
            K1 = K0.get_ring()
        else:
            K1 = K0
    common = K1.one
    for c in f:
        common = K1.lcm(common, K0.denom(c))
    if not K1.is_one(common):
        f = dup_mul_ground(f, common, K0)
    if not convert:
        return (common, f)
    else:
        return (common, dup_convert(f, K0, K1))

.sympy.polys.domains.expressiondomain.ExpressionDomain.denom

def denom(self, a):
    return a.denom()

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.denom

def denom(self, a):
    return a.denom()

.sympy.polys.domains.expressiondomain.ExpressionDomain.lcm

def lcm(self, a, b):
    return a.lcm(b)

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.lcm

def lcm(self, a, b):
    return a.lcm(b)

.sympy.polys.polytools.lcm

def lcm(f, g=None, *gens, **args):
    if hasattr(f, '__iter__'):
        if g is not None:
            gens = (g,) + gens
        return lcm_list(f, *gens, **args)
    elif g is None:
        raise TypeError('lcm() takes 2 arguments or a sequence of arguments')
    options.allowed_flags(args, ['polys'])
    try:
        (F, G), opt = parallel_poly_from_expr((f, g), *gens, **args)
        a, b = map(sympify, (f, g))
        if a.is_algebraic and a.is_irrational and b.is_algebraic and b.is_irrational:
            frc = (a / b).ratsimp()
            if frc.is_rational:
                return a * frc.as_numer_denom()[1]
    except PolificationFailed as exc:
        domain, (a, b) = construct_domain(exc.exprs)
        try:
            return domain.to_sympy(domain.lcm(a, b))
        except NotImplementedError:
            raise ComputationFailed('lcm', 2, exc)
    result = F.lcm(G)
    if not opt.polys:
        return result.as_expr()
    else:
        return result

.sympy.polys.polytools.parallel_poly_from_expr

def parallel_poly_from_expr(exprs, *gens, **args):
    opt = options.build_options(gens, args)
    return _parallel_poly_from_expr(exprs, opt)

.sympy.polys.polytools._parallel_poly_from_expr

def _parallel_poly_from_expr(exprs, opt):
    from sympy.functions.elementary.piecewise import Piecewise
    if len(exprs) == 2:
        f, g = exprs
        if isinstance(f, Poly) and isinstance(g, Poly):
            f = f.__class__._from_poly(f, opt)
            g = g.__class__._from_poly(g, opt)
            f, g = f.unify(g)
            opt.gens = f.gens
            opt.domain = f.domain
            if opt.polys is None:
                opt.polys = True
            return ([f, g], opt)
    origs, exprs = (list(exprs), [])
    _exprs, _polys = ([], [])
    failed = False
    for i, expr in enumerate(origs):
        expr = sympify(expr)
        if isinstance(expr, Basic):
            if expr.is_Poly:
                _polys.append(i)
            else:
                _exprs.append(i)
                if opt.expand:
                    expr = expr.expand()
        else:
            failed = True
        exprs.append(expr)
    if failed:
        raise PolificationFailed(opt, origs, exprs, True)
    if _polys:
        for i in _polys:
            exprs[i] = exprs[i].as_expr()
    reps, opt = _parallel_dict_from_expr(exprs, opt)
    if not opt.gens:
        raise PolificationFailed(opt, origs, exprs, True)
    for k in opt.gens:
        if isinstance(k, Piecewise):
            raise PolynomialError('Piecewise generators do not make sense')
    coeffs_list, lengths = ([], [])
    all_monoms = []
    all_coeffs = []
    for rep in reps:
        monoms, coeffs = list(zip(*list(rep.items())))
        coeffs_list.extend(coeffs)
        all_monoms.append(monoms)
        lengths.append(len(coeffs))
    domain = opt.domain
    if domain is None:
        opt.domain, coeffs_list = construct_domain(coeffs_list, opt=opt)
    else:
        coeffs_list = list(map(domain.from_sympy, coeffs_list))
    for k in lengths:
        all_coeffs.append(coeffs_list[:k])
        coeffs_list = coeffs_list[k:]
    polys = []
    for monoms, coeffs in zip(all_monoms, all_coeffs):
        rep = dict(list(zip(monoms, coeffs)))
        poly = Poly._from_dict(rep, opt)
        polys.append(poly)
    if opt.polys is None:
        opt.polys = bool(_polys)
    return (polys, opt)

.sympy.polys.polyutils._parallel_dict_from_expr

def _parallel_dict_from_expr(exprs, opt):
    if opt.expand is not False:
        exprs = [expr.expand() for expr in exprs]
    if any((expr.is_commutative is False for expr in exprs)):
        raise PolynomialError('non-commutative expressions are not supported')
    if opt.gens:
        reps, gens = _parallel_dict_from_expr_if_gens(exprs, opt)
    else:
        reps, gens = _parallel_dict_from_expr_no_gens(exprs, opt)
    return (reps, opt.clone({'gens': gens}))

.sympy.polys.polyerrors.PolificationFailed.__init__

def __init__(self, opt, origs, exprs, seq=False):
    if not seq:
        self.orig = origs
        self.expr = exprs
        self.origs = [origs]
        self.exprs = [exprs]
    else:
        self.origs = origs
        self.exprs = exprs
    self.opt = opt
    self.seq = seq

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.lcm

def lcm(self, a, b):
    return python_lcm(a, b)

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.__eq__

def __eq__(f, g):
    return f.ex == f.__class__(g).ex

.sympy.polys.domains.expressiondomain.ExpressionDomain.to_sympy

def to_sympy(self, a):
    return a.as_expr()

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.as_expr

def as_expr(f):
    return f.ex

.sympy.polys.polytools.Poly.primitive

def primitive(f):
    if hasattr(f.rep, 'primitive'):
        cont, result = f.rep.primitive()
    else:
        raise OperationNotSupported(f, 'primitive')
    return (f.rep.dom.to_sympy(cont), f.per(result))

.sympy.polys.polyclasses.DMP.primitive

def primitive(f):
    cont, F = dmp_ground_primitive(f.rep, f.lev, f.dom)
    return (cont, f.per(F))

.sympy.polys.domains.expressiondomain.ExpressionDomain.gcd

def gcd(self, a, b):
    return a.gcd(b)

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.gcd

def gcd(self, a, b):
    return a.gcd(b)

.sympy.polys.polytools.gcd

def gcd(f, g=None, *gens, **args):
    if hasattr(f, '__iter__'):
        if g is not None:
            gens = (g,) + gens
        return gcd_list(f, *gens, **args)
    elif g is None:
        raise TypeError('gcd() takes 2 arguments or a sequence of arguments')
    options.allowed_flags(args, ['polys'])
    try:
        (F, G), opt = parallel_poly_from_expr((f, g), *gens, **args)
        a, b = map(sympify, (f, g))
        if a.is_algebraic and a.is_irrational and b.is_algebraic and b.is_irrational:
            frc = (a / b).ratsimp()
            if frc.is_rational:
                return a / frc.as_numer_denom()[0]
    except PolificationFailed as exc:
        domain, (a, b) = construct_domain(exc.exprs)
        try:
            return domain.to_sympy(domain.gcd(a, b))
        except NotImplementedError:
            raise ComputationFailed('gcd', 2, exc)
    result = F.gcd(G)
    if not opt.polys:
        return result.as_expr()
    else:
        return result

.sympy.polys.domains.field.Field.quo

def quo(self, a, b):
    return a / b

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.__truediv__

def __truediv__(f, g):
    g = f._to_ex(g)
    if g is not None:
        return f.simplify(f.ex / g.ex)
    else:
        return NotImplemented

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression._to_ex

def _to_ex(f, g):
    try:
        return f.__class__(g)
    except SympifyError:
        return None

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.simplify

def simplify(f, ex):
    return f.__class__(ex.cancel())

.sympy.core.expr.Expr.cancel

def cancel(self, *gens, **args):
    from sympy.polys import cancel
    return cancel(self, *gens, **args)

.sympy.polys.polytools.cancel

def cancel(f, *gens, **args):
    from sympy.core.exprtools import factor_terms
    from sympy.functions.elementary.piecewise import Piecewise
    options.allowed_flags(args, ['polys'])
    f = sympify(f)
    if not isinstance(f, (tuple, Tuple)):
        if f.is_Number or isinstance(f, Relational) or (not isinstance(f, Expr)):
            return f
        f = factor_terms(f, radical=True)
        p, q = f.as_numer_denom()
    elif len(f) == 2:
        p, q = f
    elif isinstance(f, Tuple):
        return factor_terms(f)
    else:
        raise ValueError('unexpected argument: %s' % f)
    try:
        (F, G), opt = parallel_poly_from_expr((p, q), *gens, **args)
    except PolificationFailed:
        if not isinstance(f, (tuple, Tuple)):
            return f
        else:
            return (S.One, p, q)
    except PolynomialError as msg:
        if f.is_commutative and (not f.has(Piecewise)):
            raise PolynomialError(msg)
        if f.is_Add or f.is_Mul:
            c, nc = sift(f.args, lambda x: x.is_commutative is True and (not x.has(Piecewise)), binary=True)
            nc = [cancel(i) for i in nc]
            return f.func(cancel(f.func(*c)), *nc)
        else:
            reps = []
            pot = preorder_traversal(f)
            next(pot)
            for e in pot:
                if isinstance(e, (tuple, Tuple, BooleanAtom)):
                    continue
                try:
                    reps.append((e, cancel(e)))
                    pot.skip()
                except NotImplementedError:
                    pass
            return f.xreplace(dict(reps))
    c, P, Q = F.cancel(G)
    if not isinstance(f, (tuple, Tuple)):
        return c * (P.as_expr() / Q.as_expr())
    elif not opt.polys:
        return (c, P.as_expr(), Q.as_expr())
    else:
        return (c, P, Q)

.sympy.polys.polytools.Poly.retract

def retract(f, field=None):
    dom, rep = construct_domain(f.as_dict(zero=True), field=field, composite=f.domain.is_Composite or None)
    return f.from_dict(rep, f.gens, domain=dom)

.sympy.polys.polytools.Poly.as_dict

def as_dict(f, native=False, zero=False):
    if native:
        return f.rep.to_dict(zero=zero)
    else:
        return f.rep.to_sympy_dict(zero=zero)

.sympy.polys.polytools.Poly.domain

def domain(self):
    return self.get_domain()

.sympy.polys.polytools.Poly.from_dict

def from_dict(cls, rep, *gens, **args):
    opt = options.build_options(gens, args)
    return cls._from_dict(rep, opt)

.sympy.polys.polytools.Poly.is_univariate

def is_univariate(f):
    return len(f.gens) == 1

.sympy.polys.polyroots._integer_basis

def _integer_basis(poly):
    monoms, coeffs = list(zip(*poly.terms()))
    monoms, = list(zip(*monoms))
    coeffs = list(map(abs, coeffs))
    if coeffs[0] < coeffs[-1]:
        coeffs = list(reversed(coeffs))
        n = monoms[0]
        monoms = [n - i for i in reversed(monoms)]
    else:
        return None
    monoms = monoms[:-1]
    coeffs = coeffs[:-1]
    divs = reversed(divisors(gcd_list(coeffs))[1:])
    try:
        div = next(divs)
    except StopIteration:
        return None
    while True:
        for monom, coeff in zip(monoms, coeffs):
            if coeff % div ** monom != 0:
                try:
                    div = next(divs)
                except StopIteration:
                    return None
                else:
                    break
        else:
            return div

.sympy.polys.polytools.Poly.terms

def terms(f, order=None):
    return [(m, f.rep.dom.to_sympy(c)) for m, c in f.rep.terms(order=order)]

.sympy.polys.polyclasses.DMP.terms

def terms(f, order=None):
    return dmp_list_terms(f.rep, f.lev, f.dom, order=order)

.sympy.polys.polytools.gcd_list

def gcd_list(seq, *gens, **args):
    seq = sympify(seq)

    def try_non_polynomial_gcd(seq):
        if not gens and (not args):
            domain, numbers = construct_domain(seq)
            if not numbers:
                return domain.zero
            elif domain.is_Numerical:
                result, numbers = (numbers[0], numbers[1:])
                for number in numbers:
                    result = domain.gcd(result, number)
                    if domain.is_one(result):
                        break
                return domain.to_sympy(result)
        return None
    result = try_non_polynomial_gcd(seq)
    if result is not None:
        return result
    options.allowed_flags(args, ['polys'])
    try:
        polys, opt = parallel_poly_from_expr(seq, *gens, **args)
        if len(seq) > 1 and all((elt.is_algebraic and elt.is_irrational for elt in seq)):
            a = seq[-1]
            lst = [(a / elt).ratsimp() for elt in seq[:-1]]
            if all((frc.is_rational for frc in lst)):
                lc = 1
                for frc in lst:
                    lc = lcm(lc, frc.as_numer_denom()[0])
                return a / lc
    except PolificationFailed as exc:
        result = try_non_polynomial_gcd(exc.exprs)
        if result is not None:
            return result
        else:
            raise ComputationFailed('gcd_list', len(seq), exc)
    if not polys:
        if not opt.polys:
            return S.Zero
        else:
            return Poly(0, opt=opt)
    result, polys = (polys[0], polys[1:])
    for poly in polys:
        result = result.gcd(poly)
        if result.is_one:
            break
    if not opt.polys:
        return result.as_expr()
    else:
        return result

.sympy.polys.polytools.try_non_polynomial_gcd

def try_non_polynomial_gcd(seq):
    if not gens and (not args):
        domain, numbers = construct_domain(seq)
        if not numbers:
            return domain.zero
        elif domain.is_Numerical:
            result, numbers = (numbers[0], numbers[1:])
            for number in numbers:
                result = domain.gcd(result, number)
                if domain.is_one(result):
                    break
            return domain.to_sympy(result)
    return None

.sympy.ntheory.factor_.divisors

def divisors(n, generator=False, proper=False):
    n = as_int(abs(n))
    if isprime(n):
        if proper:
            return [1]
        return [1, n]
    if n == 1:
        if proper:
            return []
        return [1]
    if n == 0:
        return []
    rv = _divisors(n, proper)
    if not generator:
        return sorted(rv)
    return rv

.sympy.core.numbers.One.__abs__

def __abs__():
    return S.One

.sympy.polys.polytools.Poly.to_field

def to_field(f):
    if hasattr(f.rep, 'to_field'):
        result = f.rep.to_field()
    else:
        raise OperationNotSupported(f, 'to_field')
    return f.per(result)

.sympy.polys.polyclasses.DMP.to_field

def to_field(f):
    return f.convert(f.dom.get_field())

.sympy.polys.domains.integerring.IntegerRing.get_field

def get_field(self):
    from sympy.polys.domains import QQ
    return QQ

.sympy.polys.polyclasses.DMP.convert

def convert(f, dom):
    if f.dom == dom:
        return f
    else:
        return DMP(dmp_convert(f.rep, f.lev, f.dom, dom), dom, f.lev)

.sympy.polys.densebasic.dmp_convert

def dmp_convert(f, u, K0, K1):
    if not u:
        return dup_convert(f, K0, K1)
    if K0 is not None and K0 == K1:
        return f
    v = u - 1
    return dmp_strip([dmp_convert(c, v, K0, K1) for c in f], u)

.sympy.polys.densebasic.dup_convert

def dup_convert(f, K0, K1):
    if K0 is not None and K0 == K1:
        return f
    else:
        return dup_strip([K1.convert(c, K0) for c in f])

.sympy.polys.domains.domain.Domain.convert_from

def convert_from(self, element, base):
    if base.alias is not None:
        method = 'from_' + base.alias
    else:
        method = 'from_' + base.__class__.__name__
    _convert = getattr(self, method)
    if _convert is not None:
        result = _convert(element, base)
        if result is not None:
            return result
    raise CoercionFailed("can't convert %s of type %s from %s to %s" % (element, type(element), base, self))

.sympy.polys.domains.pythonrationalfield.PythonRationalField.from_ZZ_python

def from_ZZ_python(K1, a, K0):
    return PythonRational(a)

.sympy.polys.domains.pythonrational.PythonRational.__init__

def __init__(self, p, q=1, _gcd=True):
    from sympy.polys.domains.groundtypes import python_gcd as gcd
    if isinstance(p, Integer):
        p = p.p
    elif isinstance(p, Rational):
        p, q = (p.p, p.q)
    if not q:
        raise ZeroDivisionError('rational number')
    elif q < 0:
        p, q = (-p, -q)
    if not p:
        self.p = 0
        self.q = 1
    elif p == 1 or q == 1:
        self.p = p
        self.q = q
    else:
        if _gcd:
            x = gcd(p, q)
            if x != 1:
                p //= x
                q //= x
        self.p = p
        self.q = q

.sympy.polys.domains.pythonrational.PythonRational.__nonzero__

def __nonzero__(self):
    return self.p != 0

.sympy.polys.polytools.Poly.is_ground

def is_ground(f):
    return f.rep.is_ground

.sympy.polys.polyclasses.DMP.is_ground

def is_ground(f):
    return dmp_ground_p(f.rep, None, f.lev)

.sympy.polys.polytools.Poly.degree

def degree(f, gen=0):
    j = f._gen_to_level(gen)
    if hasattr(f.rep, 'degree'):
        return f.rep.degree(j)
    else:
        raise OperationNotSupported(f, 'degree')

.sympy.polys.polytools.Poly._gen_to_level

def _gen_to_level(f, gen):
    if isinstance(gen, int):
        length = len(f.gens)
        if -length <= gen < length:
            if gen < 0:
                return length + gen
            else:
                return gen
        else:
            raise PolynomialError('-%s <= gen < %s expected, got %s' % (length, length, gen))
    else:
        try:
            return f.gens.index(sympify(gen))
        except ValueError:
            raise PolynomialError('a valid generator expected, got %s' % gen)

.sympy.polys.polyclasses.DMP.degree

def degree(f, j=0):
    if isinstance(j, int):
        return dmp_degree_in(f.rep, j, f.lev)
    else:
        raise TypeError('``int`` expected, got %s' % type(j))

.sympy.polys.densebasic.dmp_degree_in

def dmp_degree_in(f, j, u):
    if not j:
        return dmp_degree(f, u)
    if j < 0 or j > u:
        raise IndexError('0 <= j <= %s expected, got %s' % (u, j))
    return _rec_degree_in(f, u, 0, j)

.sympy.polys.polytools.Poly.length

def length(f):
    return len(f.as_dict())

.sympy.polys.domains.pythonrationalfield.PythonRationalField.to_sympy

def to_sympy(self, a):
    return SymPyRational(a.numerator, a.denominator)

.sympy.polys.domains.pythonrational.PythonRational.numer

def numer(self):
    return self.p

.sympy.polys.domains.pythonrational.PythonRational.denom

def denom(self):
    return self.q

.sympy.polys.sqfreetools.dup_sqf_part

def dup_sqf_part(f, K):
    if K.is_FiniteField:
        return dup_gf_sqf_part(f, K)
    if not f:
        return f
    if K.is_negative(dup_LC(f, K)):
        f = dup_neg(f, K)
    gcd = dup_gcd(f, dup_diff(f, 1, K), K)
    sqf = dup_quo(f, gcd, K)
    if K.is_Field:
        return dup_monic(sqf, K)
    else:
        return dup_primitive(sqf, K)[1]

.sympy.polys.densearith.dup_quo

def dup_quo(f, g, K):
    return dup_div(f, g, K)[0]

.sympy.polys.factortools.dup_trial_division

def dup_trial_division(f, factors, K):
    result = []
    for factor in factors:
        k = 0
        while True:
            q, r = dup_div(f, factor, K)
            if not r:
                f, k = (q, k + 1)
            else:
                break
        result.append((factor, k))
    return _sort_factors(result)

.sympy.polys.polyroots.roots_quadratic

def roots_quadratic(f):
    a, b, c = f.all_coeffs()
    dom = f.get_domain()

    def _sqrt(d):
        co = []
        other = []
        for di in Mul.make_args(d):
            if di.is_Pow and di.exp.is_Integer and (di.exp % 2 == 0):
                co.append(Pow(di.base, di.exp // 2))
            else:
                other.append(di)
        if co:
            d = Mul(*other)
            co = Mul(*co)
            return co * sqrt(d)
        return sqrt(d)

    def _simplify(expr):
        if dom.is_Composite:
            return factor(expr)
        else:
            return simplify(expr)
    if c is S.Zero:
        r0, r1 = (S.Zero, -b / a)
        if not dom.is_Numerical:
            r1 = _simplify(r1)
        elif r1.is_negative:
            r0, r1 = (r1, r0)
    elif b is S.Zero:
        r = -c / a
        if not dom.is_Numerical:
            r = _simplify(r)
        R = _sqrt(r)
        r0 = -R
        r1 = R
    else:
        d = b ** 2 - 4 * a * c
        A = 2 * a
        B = -b / A
        if not dom.is_Numerical:
            d = _simplify(d)
            B = _simplify(B)
        D = factor_terms(_sqrt(d) / A)
        r0 = B - D
        r1 = B + D
        if a.is_negative:
            r0, r1 = (r1, r0)
        elif not dom.is_Numerical:
            r0, r1 = [expand_2arg(i) for i in (r0, r1)]
    return [r0, r1]

.sympy.polys.polytools.Poly.all_coeffs

def all_coeffs(f):
    return [f.rep.dom.to_sympy(c) for c in f.rep.all_coeffs()]

.sympy.polys.polyclasses.DMP.all_coeffs

def all_coeffs(f):
    if not f.lev:
        if not f:
            return [f.dom.zero]
        else:
            return [c for c in f.rep]
    else:
        raise PolynomialError('multivariate polynomials not supported')

.sympy.polys.polyclasses.DMP.__nonzero__

def __nonzero__(f):
    return not dmp_zero_p(f.rep, f.lev)

.sympy.core.power.integer_nthroot

def integer_nthroot(y, n):
    y, n = (as_int(y), as_int(n))
    if y < 0:
        raise ValueError('y must be nonnegative')
    if n < 1:
        raise ValueError('n must be positive')
    if y in (0, 1):
        return (y, True)
    if n == 1:
        return (y, True)
    if n == 2:
        x, rem = mpmath_sqrtrem(y)
        return (int(x), not rem)
    if n > y:
        return (1, False)
    try:
        guess = int(y ** (1.0 / n) + 0.5)
    except OverflowError:
        exp = _log(y, 2) / n
        if exp > 53:
            shift = int(exp - 53)
            guess = int(2.0 ** (exp - shift) + 1) << shift
        else:
            guess = int(2.0 ** exp)
    if guess > 2 ** 50:
        xprev, x = (-1, guess)
        while 1:
            t = x ** (n - 1)
            xprev, x = (x, ((n - 1) * x + y // t) // n)
            if abs(x - xprev) < 2:
                break
    else:
        x = guess
    t = x ** n
    while t < y:
        x += 1
        t = x ** n
    while t > y:
        x -= 1
        t = x ** n
    return (int(x), t == y)

.sympy.polys.polyroots._sqrt

def _sqrt(d):
    co = []
    other = []
    for di in Mul.make_args(d):
        if di.is_Pow and di.exp.is_Integer and (di.exp % 2 == 0):
            co.append(Pow(di.base, di.exp // 2))
        else:
            other.append(di)
    if co:
        d = Mul(*other)
        co = Mul(*co)
        return co * sqrt(d)
    return sqrt(d)

.sympy.functions.elementary.miscellaneous.sqrt

def sqrt(arg, evaluate=None):
    return Pow(arg, S.Half, evaluate=evaluate)

.sympy.ntheory.factor_.perfect_power

def perfect_power(n, candidates=None, big=True, factor=True):
    from sympy.core.power import integer_nthroot
    n = as_int(n)
    if n < 3:
        if n < 1:
            raise ValueError('expecting positive n')
        return False
    logn = math.log(n, 2)
    max_possible = int(logn) + 2
    not_square = n % 10 in [2, 3, 7, 8]
    min_possible = 2 + not_square
    if not candidates:
        candidates = primerange(min_possible, max_possible)
    else:
        candidates = sorted([i for i in candidates if min_possible <= i < max_possible])
        if n % 2 == 0:
            e = trailing(n)
            candidates = [i for i in candidates if e % i == 0]
        if big:
            candidates = reversed(candidates)
        for e in candidates:
            r, ok = integer_nthroot(n, e)
            if ok:
                return (r, e)
        return False

    def _factors():
        rv = 2 + n % 2
        while True:
            yield rv
            rv = nextprime(rv)
    for fac, e in zip(_factors(), candidates):
        if factor and n % fac == 0:
            if fac == 2:
                e = trailing(n)
            else:
                e = multiplicity(fac, n)
            if e == 1:
                return False
            r, exact = integer_nthroot(n, e)
            if not exact:
                m = n // fac ** e
                rE = perfect_power(m, candidates=divisors(e, generator=True))
                if not rE:
                    return False
                else:
                    r, E = rE
                    r, e = (fac ** (e // E) * r, E)
            if not big:
                e0 = primefactors(e)
                if e0[0] != e:
                    r, e = (r ** (e // e0[0]), e0[0])
            return (r, e)
        if logn / e < 40:
            b = 2.0 ** (logn / e)
            if abs(int(b + 0.5) - b) > 0.01:
                continue
        r, exact = integer_nthroot(n, e)
        if exact:
            if big:
                m = perfect_power(r, big=big, factor=factor)
                if m:
                    r, e = (m[0], e * m[1])
            return (int(r), e)
    return False

.sympy.ntheory.factor_._factors

def _factors():
    rv = 2 + n % 2
    while True:
        yield rv
        rv = nextprime(rv)

.sympy.ntheory.generate.primerange

def primerange(a, b):
    from sympy.functions.elementary.integers import ceiling
    if a >= b:
        return
    if b <= sieve._list[-1]:
        for i in sieve.primerange(a, b):
            yield i
        return
    a = as_int(ceiling(a)) - 1
    b = as_int(ceiling(b))
    while 1:
        a = nextprime(a)
        if a < b:
            yield a
        else:
            return

.sympy.ntheory.generate.Sieve.primerange

def primerange(self, a, b):
    from sympy.functions.elementary.integers import ceiling
    a = max(2, as_int(ceiling(a)))
    b = as_int(ceiling(b))
    if a >= b:
        return
    self.extend(b)
    i = self.search(a)[1]
    maxi = len(self._list) + 1
    while i < maxi:
        p = self._list[i - 1]
        if p < b:
            yield p
            i += 1
        else:
            return

.sympy.functions.elementary.integers.RoundFunction.eval

def eval(cls, arg):
    from sympy import im
    if arg.is_integer or arg.is_finite is False:
        return arg
    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:
        i = im(arg)
        if not i.has(S.ImaginaryUnit):
            return cls(i) * S.ImaginaryUnit
        return cls(arg, evaluate=False)
    v = cls._eval_number(arg)
    if v is not None:
        return v
    ipart = npart = spart = S.Zero
    terms = Add.make_args(arg)
    for t in terms:
        if t.is_integer or (t.is_imaginary and im(t).is_integer):
            ipart += t
        elif t.has(Symbol):
            spart += t
        else:
            npart += t
    if not (npart or spart):
        return ipart
    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):
        try:
            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)
            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit
            npart = S.Zero
        except (PrecisionExhausted, NotImplementedError):
            pass
    spart += npart
    if not spart:
        return ipart
    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:
        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit
    else:
        return ipart + cls(spart, evaluate=False)

.sympy.ntheory.generate.Sieve.extend

def extend(self, n):
    n = int(n)
    if n <= self._list[-1]:
        return
    maxbase = int(n ** 0.5) + 1
    self.extend(maxbase)
    begin = self._list[-1] + 1
    newsieve = _arange(begin, n + 1)
    for p in self.primerange(2, maxbase):
        startindex = -begin % p
        for i in range(startindex, len(newsieve), p):
            newsieve[i] = 0
    self._list += _array('l', [x for x in newsieve if x])

.sympy.ntheory.generate.Sieve.search

def search(self, n):
    from sympy.functions.elementary.integers import ceiling
    test = as_int(ceiling(n))
    n = as_int(n)
    if n < 2:
        raise ValueError('n should be >= 2 but got: %s' % n)
    if n > self._list[-1]:
        self.extend(n)
    b = bisect(self._list, n)
    if self._list[b - 1] == test:
        return (b, b)
    else:
        return (b, b + 1)

.sympy.ntheory.factor_.trailing

def trailing(n):
    n = abs(int(n))
    if not n:
        return 0
    low_byte = n & 255
    if low_byte:
        return small_trailing[low_byte]
    z = bitcount(n) - 1
    if isinstance(z, SYMPY_INTS):
        if n == 1 << z:
            return z
    if z < 300:
        t = 8
        n >>= 8
        while not n & 255:
            n >>= 8
            t += 8
        return t + small_trailing[n & 255]
    t = 0
    p = 8
    while not n & 1:
        while not n & (1 << p) - 1:
            n >>= p
            t += p
            p *= 2
        p //= 2
    return t

.sympy.core.numbers.Rational.factors

def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):
    from sympy.ntheory import factorrat
    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()

.sympy.ntheory.factor_.factorrat

def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    from collections import defaultdict
    if multiple:
        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])
        return factorlist
    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()
    f = defaultdict(int, f)
    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():
        f[p] += -e
    if len(f) > 1 and 1 in f:
        del f[1]
    if not visual:
        return dict(f)
    else:
        if -1 in f:
            f.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])
        return Mul(*args, evaluate=False)

.sympy.ntheory.factor_.factorint

def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    if isinstance(n, Dict):
        n = dict(n)
    if multiple:
        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p in sorted(fac)), [])
        return factorlist
    factordict = {}
    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):
        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
    elif isinstance(n, Mul):
        factordict = {int(k): int(v) for k, v in n.as_powers_dict().items()}
    elif isinstance(n, dict):
        factordict = n
    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):
        for key in list(factordict.keys()):
            if isprime(key):
                continue
            e = factordict.pop(key)
            d = factorint(key, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
            for k, v in d.items():
                if k in factordict:
                    factordict[k] += v * e
                else:
                    factordict[k] = v * e
    if visual or (type(n) is dict and visual is not True and (visual is not False)):
        if factordict == {}:
            return S.One
        if -1 in factordict:
            factordict.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])
        return Mul(*args, evaluate=False)
    elif isinstance(n, dict) or isinstance(n, Mul):
        return factordict
    assert use_trial or use_rho or use_pm1
    from sympy.functions.combinatorial.factorials import factorial
    if isinstance(n, factorial):
        x = as_int(n.args[0])
        if x >= 20:
            factors = {}
            m = 2
            for p in sieve.primerange(2, x + 1):
                if m > 1:
                    m, q = (0, x // p)
                    while q != 0:
                        m += q
                        q //= p
                factors[p] = m
            if factors and verbose:
                for k in sorted(factors):
                    print(factor_msg % (k, factors[k]))
            if verbose:
                print(complete_msg)
            return factors
        else:
            n = n.func(x)
    n = as_int(n)
    if limit:
        limit = int(limit)
    if n < 0:
        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
        factors[-1] = 1
        return factors
    if limit and limit < 2:
        if n == 1:
            return {}
        return {n: 1}
    elif n < 10:
        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]
    factors = {}
    if verbose:
        sn = str(n)
        if len(sn) > 50:
            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])
        else:
            print('Factoring', n)
    if use_trial:
        small = 2 ** 15
        fail_max = 600
        small = min(small, limit or small)
        if verbose:
            print(trial_int_msg % (2, small, fail_max))
        n, next_p = _factorint_small(factors, n, small, fail_max)
    else:
        next_p = 2
    if factors and verbose:
        for k in sorted(factors):
            print(factor_msg % (k, factors[k]))
    if next_p == 0:
        if n > 1:
            factors[int(n)] = 1
        if verbose:
            print(complete_msg)
        return factors
    try:
        if limit and next_p > limit:
            if verbose:
                print('Exceeded limit:', limit)
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            if n > 1:
                factors[int(n)] = 1
            return factors
        else:
            sqrt_n = integer_nthroot(n, 2)[0]
            a = sqrt_n + 1
            a2 = a ** 2
            b2 = a2 - n
            for i in range(3):
                b, fermat = integer_nthroot(b2, 2)
                if fermat:
                    break
                b2 += 2 * a + 1
                a += 1
            if fermat:
                if verbose:
                    print(fermat_msg)
                if limit:
                    limit -= 1
                for r in [a - b, a + b]:
                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                    for k, v in facs.items():
                        factors[k] = factors.get(k, 0) + v
                raise StopIteration
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
    except StopIteration:
        if verbose:
            print(complete_msg)
        return factors
    low, high = (next_p, 2 * next_p)
    limit = limit or sqrt_n
    limit += 1
    while 1:
        try:
            high_ = high
            if limit < high_:
                high_ = limit
            if use_trial:
                if verbose:
                    print(trial_msg % (low, high_))
                ps = sieve.primerange(low, high_)
                n, found_trial = _trial(factors, n, ps, verbose)
                if found_trial:
                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            else:
                found_trial = False
            if high > limit:
                if verbose:
                    print('Exceeded limit:', limit)
                if n > 1:
                    factors[int(n)] = 1
                raise StopIteration
            if not found_trial:
                if use_pm1 or use_rho:
                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)
                    if use_pm1:
                        if verbose:
                            print(pm1_msg % (high_root, high_))
                        c = pollard_pm1(n, B=high_root, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
                    if use_rho:
                        max_steps = high_root
                        if verbose:
                            print(rho_msg % (1, max_steps, high_))
                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
        except StopIteration:
            if verbose:
                print(complete_msg)
            return factors
        low, high = (high, high * 2)

.sympy.ntheory.factor_._factorint_small

def _factorint_small(factors, n, limit, fail_max):

    def done(n, d):
        if d * d <= n:
            return (n, d)
        return (n, 0)
    d = 2
    m = trailing(n)
    if m:
        factors[d] = m
        n >>= m
    d = 3
    if limit < d:
        if n > 1:
            factors[n] = 1
        return done(n, d)
    m = 0
    while n % d == 0:
        n //= d
        m += 1
        if m == 20:
            mm = multiplicity(d, n)
            m += mm
            n //= d ** mm
            break
    if m:
        factors[d] = m
    if limit * limit > n:
        maxx = 0
    else:
        maxx = limit * limit
    dd = maxx or n
    d = 5
    fails = 0
    while fails < fail_max:
        if d * d > dd:
            break
        m = 0
        while n % d == 0:
            n //= d
            m += 1
            if m == 20:
                mm = multiplicity(d, n)
                m += mm
                n //= d ** mm
                break
        if m:
            factors[d] = m
            dd = maxx or n
            fails = 0
        else:
            fails += 1
        d += 2
        if d * d > dd:
            break
        m = 0
        while n % d == 0:
            n //= d
            m += 1
            if m == 20:
                mm = multiplicity(d, n)
                m += mm
                n //= d ** mm
                break
        if m:
            factors[d] = m
            dd = maxx or n
            fails = 0
        else:
            fails += 1
        d += 4
    return done(n, d)

.sympy.ntheory.factor_.done

def done(n, d):
    if d * d <= n:
        return (n, d)
    return (n, 0)

.sympy.ntheory.factor_.multiplicity

def multiplicity(p, n):
    try:
        p, n = (as_int(p), as_int(n))
    except ValueError:
        if all((isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n))):
            p = Rational(p)
            n = Rational(n)
            if p.q == 1:
                if n.p == 1:
                    return -multiplicity(p.p, n.q)
                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)
            elif p.p == 1:
                return multiplicity(p.q, n.q)
            else:
                like = min(multiplicity(p.p, n.p), multiplicity(p.q, n.q))
                cross = min(multiplicity(p.q, n.p), multiplicity(p.p, n.q))
                return like - cross
        raise ValueError('expecting ints or fractions, got %s and %s' % (p, n))
    if n == 0:
        raise ValueError('no such integer exists: multiplicity of %s is not-defined' % n)
    if p == 2:
        return trailing(n)
    if p < 2:
        raise ValueError('p must be an integer, 2 or larger, but got %s' % p)
    if p == n:
        return 1
    m = 0
    n, rem = divmod(n, p)
    while not rem:
        m += 1
        if m > 5:
            e = 2
            while 1:
                ppow = p ** e
                if ppow < n:
                    nnew, rem = divmod(n, ppow)
                    if not rem:
                        m += e
                        e *= 2
                        n = nnew
                        continue
                return m + multiplicity(p, n)
        n, rem = divmod(n, p)
    return m

.sympy.core.numbers.Rational.__hash__

def __hash__(self):
    return super(Rational, self).__hash__()

.sympy.core.numbers.Rational.as_coeff_Add

def as_coeff_Add(self, rational=False):
    return (self, S.Zero)

.sympy.core.numbers.Rational._eval_power

def _eval_power(self, expt):
    if isinstance(expt, Number):
        if isinstance(expt, Float):
            return self._eval_evalf(expt._prec) ** expt
        if expt.is_extended_negative:
            ne = -expt
            if ne is S.One:
                return Rational(self.q, self.p)
            if self.is_negative:
                return S.NegativeOne ** expt * Rational(self.q, -self.p) ** ne
            else:
                return Rational(self.q, self.p) ** ne
        if expt is S.Infinity:
            if self.p > self.q:
                return S.Infinity
            if self.p < -self.q:
                return S.Infinity + S.Infinity * S.ImaginaryUnit
            return S.Zero
        if isinstance(expt, Integer):
            return Rational(self.p ** expt.p, self.q ** expt.p, 1)
        if isinstance(expt, Rational):
            if self.p != 1:
                return Integer(self.p) ** expt * Integer(self.q) ** (-expt)
            return Integer(self.q) ** Rational(expt.p * (expt.q - 1), expt.q) / Integer(self.q) ** Integer(expt.p)
    if self.is_extended_negative and expt.is_even:
        return (-self) ** expt
    return

.sympy.core.numbers.Rational.__sub__

def __sub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p - self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return -other + self
        else:
            return Number.__sub__(self, other)
    return Number.__sub__(self, other)

.sympy.core.numbers.Number.__sub__

def __sub__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            return S.Infinity
    return AtomicExpr.__sub__(self, other)

.sympy.core.numbers.Rational.__neg__

def __neg__(self):
    return Rational(-self.p, self.q)

.sympy.polys.polyroots._update_dict

def _update_dict(result, currentroot, k):
    if currentroot in result:
        result[currentroot] += k
    else:
        result[currentroot] = k

.sympy.polys.polytools.degree

def degree(f, gen=0):
    f = sympify(f, strict=True)
    gen_is_Num = sympify(gen, strict=True).is_Number
    if f.is_Poly:
        p = f
        isNum = p.as_expr().is_Number
    else:
        isNum = f.is_Number
        if not isNum:
            if gen_is_Num:
                p, _ = poly_from_expr(f)
            else:
                p, _ = poly_from_expr(f, gen)
    if isNum:
        return S.Zero if f else S.NegativeInfinity
    if not gen_is_Num:
        if f.is_Poly and gen not in p.gens:
            p, _ = poly_from_expr(f.as_expr())
        if gen not in p.gens:
            return S.Zero
    elif not f.is_Poly and len(f.free_symbols) > 1:
        raise TypeError(filldedent('\n         A symbolic generator of interest is required for a multivariate\n         expression like func = %s, e.g. degree(func, gen = %s) instead of\n         degree(func, gen = %s).\n        ' % (f, next(ordered(f.free_symbols)), gen)))
    return Integer(p.degree(gen))

.sympy.polys.polytools.poly_from_expr

def poly_from_expr(expr, *gens, **args):
    opt = options.build_options(gens, args)
    return _poly_from_expr(expr, opt)

.sympy.core.numbers.Integer.__le__

def __le__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p <= other.p)
    return Rational.__le__(self, other)

.sympy.core.evalf.evalf_pow

def evalf_pow(v, prec, options):
    target_prec = prec
    base, exp = v.args
    if exp.is_Integer:
        p = exp.p
        if not p:
            return (fone, None, prec, None)
        prec += int(math.log(abs(p), 2))
        re, im, re_acc, im_acc = evalf(base, prec + 5, options)
        if re and (not im):
            return (mpf_pow_int(re, p, target_prec), None, target_prec, None)
        if im and (not re):
            z = mpf_pow_int(im, p, target_prec)
            case = p % 4
            if case == 0:
                return (z, None, target_prec, None)
            if case == 1:
                return (None, z, None, target_prec)
            if case == 2:
                return (mpf_neg(z), None, target_prec, None)
            if case == 3:
                return (None, mpf_neg(z), None, target_prec)
        if not re:
            return (None, None, None, None)
        re, im = libmp.mpc_pow_int((re, im), p, prec)
        return finalize_complex(re, im, target_prec)
    if exp is S.Half:
        xre, xim, _, _ = evalf(base, prec + 5, options)
        if xim:
            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)
            return finalize_complex(re, im, prec)
        if not xre:
            return (None, None, None, None)
        if mpf_lt(xre, fzero):
            return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)
        return (mpf_sqrt(xre, prec), None, prec, None)
    prec += 10
    yre, yim, _, _ = evalf(exp, prec, options)
    if not (yre or yim):
        return (fone, None, prec, None)
    ysize = fastlog(yre)
    if ysize > 5:
        prec += ysize
        yre, yim, _, _ = evalf(exp, prec, options)
    if base is S.Exp1:
        if yim:
            re, im = libmp.mpc_exp((yre or fzero, yim), prec)
            return finalize_complex(re, im, target_prec)
        return (mpf_exp(yre, target_prec), None, target_prec, None)
    xre, xim, _, _ = evalf(base, prec + 5, options)
    if not (xre or xim):
        return (None, None, None, None)
    if yim:
        re, im = libmp.mpc_pow((xre or fzero, xim or fzero), (yre or fzero, yim), target_prec)
        return finalize_complex(re, im, target_prec)
    if xim:
        re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)
        return finalize_complex(re, im, target_prec)
    elif mpf_lt(xre, fzero):
        re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)
        return finalize_complex(re, im, target_prec)
    else:
        return (mpf_pow(xre, yre, target_prec), None, target_prec, None)

.sympy.core.function.expand_complex

def expand_complex(expr, deep=True):
    return sympify(expr).expand(deep=deep, complex=True, basic=False, log=False, mul=False, power_exp=False, power_base=False, multinomial=False)

.sympy.core.expr.Expr._eval_expand_complex

def _eval_expand_complex(self, **hints):
    real, imag = self.as_real_imag(**hints)
    return real + S.ImaginaryUnit * imag

.sympy.core.symbol.Symbol.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import im, re
    if hints.get('ignore') == self:
        return None
    else:
        return (re(self), im(self))

.sympy.core.numbers.Rational.as_numer_denom

def as_numer_denom(self):
    return (Integer(self.p), Integer(self.q))

.sympy.core.numbers.Integer.__divmod__

def __divmod__(self, other):
    from .containers import Tuple
    if isinstance(other, Integer) and global_evaluate[0]:
        return Tuple(*divmod(self.p, other.p))
    else:
        return Number.__divmod__(self, other)

.sympy.core.expr.Expr.as_coefficient

def as_coefficient(self, expr):
    r = self.extract_multiplicatively(expr)
    if r and (not r.has(expr)):
        return r

.sympy.core.numbers.ImaginaryUnit._eval_power

def _eval_power(self, expt):
    if isinstance(expt, Number):
        if isinstance(expt, Integer):
            expt = expt.p % 4
            if expt == 0:
                return S.One
            if expt == 1:
                return S.ImaginaryUnit
            if expt == 2:
                return -S.One
            return -S.ImaginaryUnit
    return

.sympy.core.function.Function._should_evalf

def _should_evalf(cls, arg):
    from sympy.core.evalf import pure_complex
    if arg.is_Float:
        return arg._prec
    if not arg.is_Add:
        return -1
    m = pure_complex(arg)
    if m is None or not (m[0].is_Float or m[1].is_Float):
        return -1
    l = [i._prec for i in m if i.is_Float]
    l.append(-1)
    return max(l)

.sympy.core.function.Function.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.function.Application.func

def func(self):
    return self.__class__

.sympy.sets.sets.Set.intersection

def intersection(self, other):
    return self.intersect(other)

.sympy.sets.sets.Set.intersect

def intersect(self, other):
    return Intersection(self, other)

.sympy.sets.sets.Intersection.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    args = list(ordered(set(_sympify(args))))
    if evaluate:
        args = list(cls._new_args_filter(args))
        return simplify_intersection(args)
    args = list(ordered(args, Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._argset = frozenset(args)
    return obj

.sympy.core.basic.Basic.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.sets.fancysets.Reals.__hash__

def __hash__(self):
    return hash(Interval(S.NegativeInfinity, S.Infinity))

.sympy.logic.boolalg.BooleanTrue.__hash__

def __hash__(self):
    return hash(True)

.sympy.core.operations.LatticeOp._new_args_filter

def _new_args_filter(cls, arg_sequence, call_cls=None):
    ncls = call_cls or cls
    for arg in arg_sequence:
        if arg == ncls.zero:
            raise ShortCircuit(arg)
        elif arg == ncls.identity:
            continue
        elif arg.func == ncls:
            for x in arg.args:
                yield x
        else:
            yield arg

.sympy.sets.sets.simplify_intersection

def simplify_intersection(args):
    if not args:
        return S.UniversalSet
    for arg in args:
        if not isinstance(arg, Set):
            raise TypeError('Input args to Union must be Sets')
    if S.EmptySet in args:
        return S.EmptySet
    rv = Intersection._handle_finite_sets(args)
    if rv is not None:
        return rv
    for s in args:
        if s.is_Union:
            other_sets = set(args) - set((s,))
            if len(other_sets) > 0:
                other = Intersection(*other_sets)
                return Union(*(Intersection(arg, other) for arg in s.args))
            else:
                return Union(*[arg for arg in s.args])
    for s in args:
        if s.is_Complement:
            args.remove(s)
            other_sets = args + [s.args[0]]
            return Complement(Intersection(*other_sets), s.args[1])
    from sympy.sets.handlers.intersection import intersection_sets
    args = set(args)
    new_args = True
    while new_args:
        for s in args:
            new_args = False
            for t in args - set((s,)):
                new_set = intersection_sets(s, t)
                if new_set is not None:
                    new_args = (args - set((s, t))).union(set((new_set,)))
                    break
            if new_args:
                args = new_args
                break
    if len(args) == 1:
        return args.pop()
    else:
        return Intersection(*args, evaluate=False)

.sympy.sets.sets.Intersection._handle_finite_sets

def _handle_finite_sets(args):
    fs_args, others = sift(args, lambda x: x.is_FiniteSet, binary=True)
    if not fs_args:
        return
    fs_sets = [set(fs) for fs in fs_args]
    all_elements = reduce(lambda a, b: a | b, fs_sets, set())
    definite = set()
    for e in all_elements:
        inall = fuzzy_and((s.contains(e) for s in args))
        if inall is True:
            definite.add(e)
        if inall is not None:
            for s in fs_sets:
                s.discard(e)
    fs_elements = reduce(lambda a, b: a | b, fs_sets, set())
    fs_symsets = [FiniteSet(*s) for s in fs_sets]
    while fs_elements:
        for e in fs_elements:
            infs = fuzzy_and((s.contains(e) for s in fs_symsets))
            if infs is True:
                definite.add(e)
            if infs is not None:
                for n, s in enumerate(fs_sets):
                    if e in s:
                        s.remove(e)
                        fs_symsets[n] = FiniteSet(*s)
                fs_elements.remove(e)
                break
        else:
            break
    if not all(fs_sets):
        fs_sets = [set()]
    if definite:
        fs_sets = [fs | definite for fs in fs_sets]
    if fs_sets == [set()]:
        return S.EmptySet
    sets = [FiniteSet(*s) for s in fs_sets]
    all_elements = reduce(lambda a, b: a | b, fs_sets, set())
    is_redundant = lambda o: all((fuzzy_bool(o.contains(e)) for e in all_elements))
    others = [o for o in others if not is_redundant(o)]
    if others:
        rest = Intersection(*others)
        if rest is S.EmptySet:
            return S.EmptySet
        if rest.is_Intersection:
            sets.extend(rest.args)
        else:
            sets.append(rest)
    if len(sets) == 1:
        return sets[0]
    else:
        return Intersection(*sets, evaluate=False)

.sympy.sets.sets.Set.contains

def contains(self, other):
    other = sympify(other, strict=True)
    c = self._contains(other)
    if c is None:
        return Contains(other, self, evaluate=False)
    b = tfn[c]
    if b is None:
        return c
    return b

.sympy.sets.sets.Interval._contains

def _contains(self, other):
    if not isinstance(other, Expr) or (other is S.Infinity or other is S.NegativeInfinity or other is S.NaN or (other is S.ComplexInfinity)) or other.is_extended_real is False:
        return false
    if self.start is S.NegativeInfinity and self.end is S.Infinity:
        if not other.is_extended_real is None:
            return other.is_extended_real
    d = Dummy()
    return self.as_relational(d).subs(d, other)

.sympy.sets.sets.Interval.start

def start(self):
    return self._args[0]

.sympy.sets.sets.Interval.end

def end(self):
    return self._args[1]

.sympy.sets.sets.Set.__add__

def __add__(self, other):
    return self.union(other)

.sympy.sets.sets.Set.union

def union(self, other):
    return Union(self, other)

.sympy.sets.sets.Union.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    args = _sympify(args)
    if evaluate:
        args = list(cls._new_args_filter(args))
        return simplify_union(args)
    args = list(ordered(args, Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._argset = frozenset(args)
    return obj

.sympy.sets.sets.simplify_union

def simplify_union(args):
    from sympy.sets.handlers.union import union_sets
    if not args:
        return S.EmptySet
    for arg in args:
        if not isinstance(arg, Set):
            raise TypeError('Input args to Union must be Sets')
    finite_sets = [x for x in args if x.is_FiniteSet]
    if len(finite_sets) > 1:
        a = (x for set in finite_sets for x in set)
        finite_set = FiniteSet(*a)
        args = [finite_set] + [x for x in args if not x.is_FiniteSet]
    args = set(args)
    new_args = True
    while new_args:
        for s in args:
            new_args = False
            for t in args - set((s,)):
                new_set = union_sets(s, t)
                if new_set is not None:
                    if not isinstance(new_set, set):
                        new_set = set((new_set,))
                    new_args = (args - set((s, t))).union(new_set)
                    break
            if new_args:
                args = new_args
                break
    if len(args) == 1:
        return args.pop()
    else:
        return Union(*args, evaluate=False)

.sympy.sets.sets.EmptySet.__iter__

def __iter__(self):
    return iter([])

.sympy.solvers.solveset.domain_check

def domain_check(f, symbol, p):
    f, p = (sympify(f), sympify(p))
    if p.is_infinite:
        return False
    return _domain_check(f, symbol, p)

.sympy.solvers.solveset._domain_check

def _domain_check(f, symbol, p):
    if f.is_Atom and f.is_finite:
        return True
    elif f.subs(symbol, p).is_infinite:
        return False
    else:
        return all([_domain_check(g, symbol, p) for g in f.args])

.sympy.core.basic.Basic.subs

def subs(self, *args, **kwargs):
    from sympy.core.containers import Dict
    from sympy.utilities import default_sort_key
    from sympy import Dummy, Symbol
    unordered = False
    if len(args) == 1:
        sequence = args[0]
        if isinstance(sequence, set):
            unordered = True
        elif isinstance(sequence, (Dict, Mapping)):
            unordered = True
            sequence = sequence.items()
        elif not iterable(sequence):
            from sympy.utilities.misc import filldedent
            raise ValueError(filldedent('\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.'))
    elif len(args) == 2:
        sequence = [args]
    else:
        raise ValueError('subs accepts either 1 or 2 arguments')
    sequence = list(sequence)
    for i, s in enumerate(sequence):
        if isinstance(s[0], string_types):
            s = (Symbol(s[0]), s[1])
        try:
            s = [sympify(_, strict=not isinstance(_, string_types)) for _ in s]
        except SympifyError:
            sequence[i] = None
            continue
        sequence[i] = None if _aresame(*s) else tuple(s)
    sequence = list(filter(None, sequence))
    if unordered:
        sequence = dict(sequence)
        if not all((k.is_Atom for k in sequence)):
            d = {}
            for o, n in sequence.items():
                try:
                    ops = (o.count_ops(), len(o.args))
                except TypeError:
                    ops = (0, 0)
                d.setdefault(ops, []).append((o, n))
            newseq = []
            for k in sorted(d.keys(), reverse=True):
                newseq.extend(sorted([v[0] for v in d[k]], key=default_sort_key))
            sequence = [(k, sequence[k]) for k in newseq]
            del newseq, d
        else:
            sequence = sorted([(k, v) for k, v in sequence.items()], key=default_sort_key)
    if kwargs.pop('simultaneous', False):
        reps = {}
        rv = self
        kwargs['hack2'] = True
        m = Dummy('subs_m')
        for old, new in sequence:
            com = new.is_commutative
            if com is None:
                com = True
            d = Dummy('subs_d', commutative=com)
            rv = rv._subs(old, d * m, **kwargs)
            if not isinstance(rv, Basic):
                break
            reps[d] = new
        reps[m] = S.One
        return rv.xreplace(reps)
    else:
        rv = self
        for old, new in sequence:
            rv = rv._subs(old, new, **kwargs)
            if not isinstance(rv, Basic):
                break
        return rv

.sympy.core.basic._aresame

def _aresame(a, b):
    from .numbers import Number
    from .function import AppliedUndef, UndefinedFunction as UndefFunc
    if isinstance(a, Number) and isinstance(b, Number):
        return a == b and a.__class__ == b.__class__
    for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):
        if i != j or type(i) != type(j):
            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):
                if i.class_key() != j.class_key():
                    return False
            else:
                return False
    return True

.sympy.core.basic.Basic._subs

def _subs(self, old, new, **hints):

    def fallback(self, old, new):
        hit = False
        args = list(self.args)
        for i, arg in enumerate(args):
            if not hasattr(arg, '_eval_subs'):
                continue
            arg = arg._subs(old, new, **hints)
            if not _aresame(arg, args[i]):
                hit = True
                args[i] = arg
        if hit:
            rv = self.func(*args)
            hack2 = hints.get('hack2', False)
            if hack2 and self.is_Mul and (not rv.is_Mul):
                coeff = S.One
                nonnumber = []
                for i in args:
                    if i.is_Number:
                        coeff *= i
                    else:
                        nonnumber.append(i)
                nonnumber = self.func(*nonnumber)
                if coeff is S.One:
                    return nonnumber
                else:
                    return self.func(coeff, nonnumber, evaluate=False)
            return rv
        return self
    if _aresame(self, old):
        return new
    rv = self._eval_subs(old, new)
    if rv is None:
        rv = fallback(self, old, new)
    return rv

.sympy.core.add.Add._eval_subs

def _eval_subs(self, old, new):
    if not old.is_Add:
        if old is S.Infinity and -old in self.args:
            return self.xreplace({-old: -new})
        return None
    coeff_self, terms_self = self.as_coeff_Add()
    coeff_old, terms_old = old.as_coeff_Add()
    if coeff_self.is_Rational and coeff_old.is_Rational:
        if terms_self == terms_old:
            return self.func(new, coeff_self, -coeff_old)
        if terms_self == -terms_old:
            return self.func(-new, coeff_self, coeff_old)
    if coeff_self.is_Rational and coeff_old.is_Rational or coeff_self == coeff_old:
        args_old, args_self = (self.func.make_args(terms_old), self.func.make_args(terms_self))
        if len(args_old) < len(args_self):
            self_set = set(args_self)
            old_set = set(args_old)
            if old_set < self_set:
                ret_set = self_set - old_set
                return self.func(new, coeff_self, -coeff_old, *[s._subs(old, new) for s in ret_set])
            args_old = self.func.make_args(-terms_old)
            old_set = set(args_old)
            if old_set < self_set:
                ret_set = self_set - old_set
                return self.func(-new, coeff_self, coeff_old, *[s._subs(old, new) for s in ret_set])

.sympy.core.basic.Basic.fallback

def fallback(self, old, new):
    hit = False
    args = list(self.args)
    for i, arg in enumerate(args):
        if not hasattr(arg, '_eval_subs'):
            continue
        arg = arg._subs(old, new, **hints)
        if not _aresame(arg, args[i]):
            hit = True
            args[i] = arg
    if hit:
        rv = self.func(*args)
        hack2 = hints.get('hack2', False)
        if hack2 and self.is_Mul and (not rv.is_Mul):
            coeff = S.One
            nonnumber = []
            for i in args:
                if i.is_Number:
                    coeff *= i
                else:
                    nonnumber.append(i)
            nonnumber = self.func(*nonnumber)
            if coeff is S.One:
                return nonnumber
            else:
                return self.func(coeff, nonnumber, evaluate=False)
        return rv
    return self

.sympy.core.mul.Mul._eval_subs

def _eval_subs(self, old, new):
    from sympy.functions.elementary.complexes import sign
    from sympy.ntheory.factor_ import multiplicity
    from sympy.simplify.powsimp import powdenest
    from sympy.simplify.radsimp import fraction
    if not old.is_Mul:
        return None
    if old.args[0].is_Number and old.args[0] < 0:
        if self.args[0].is_Number:
            if self.args[0] < 0:
                return self._subs(-old, -new)
            return None

    def base_exp(a):
        from sympy import exp
        if a.is_Pow or isinstance(a, exp):
            return a.as_base_exp()
        return (a, S.One)

    def breakup(eq):
        c, nc = (defaultdict(int), list())
        for a in Mul.make_args(eq):
            a = powdenest(a)
            b, e = base_exp(a)
            if e is not S.One:
                co, _ = e.as_coeff_mul()
                b = Pow(b, e / co)
                e = co
            if a.is_commutative:
                c[b] += e
            else:
                nc.append([b, e])
        return (c, nc)

    def rejoin(b, co):
        b, e = base_exp(b)
        return Pow(b, e * co)

    def ndiv(a, b):
        if not b.q % a.q or not a.q % b.q:
            return int(a / b)
        return 0
    rv = None
    n, d = fraction(self)
    self2 = self
    if d is not S.One:
        self2 = n._subs(old, new) / d._subs(old, new)
        if not self2.is_Mul:
            return self2._subs(old, new)
        if self2 != self:
            rv = self2
    co_self = self2.args[0]
    co_old = old.args[0]
    co_xmul = None
    if co_old.is_Rational and co_self.is_Rational:
        if co_old != co_self:
            co_xmul = co_self.extract_multiplicatively(co_old)
    elif co_old.is_Rational:
        return rv
    c, nc = breakup(self2)
    old_c, old_nc = breakup(old)
    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):
        mult = S(multiplicity(abs(co_old), co_self))
        c.pop(co_self)
        if co_old in c:
            c[co_old] += mult
        else:
            c[co_old] = mult
        co_residual = co_self / co_old ** mult
    else:
        co_residual = 1
    ok = True
    if len(old_nc) > len(nc):
        ok = False
    elif len(old_c) > len(c):
        ok = False
    elif set((i[0] for i in old_nc)).difference(set((i[0] for i in nc))):
        ok = False
    elif set(old_c).difference(set(c)):
        ok = False
    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):
        ok = False
    if not ok:
        return rv
    if not old_c:
        cdid = None
    else:
        rat = []
        for b, old_e in old_c.items():
            c_e = c[b]
            rat.append(ndiv(c_e, old_e))
            if not rat[-1]:
                return rv
        cdid = min(rat)
    if not old_nc:
        ncdid = None
        for i in range(len(nc)):
            nc[i] = rejoin(*nc[i])
    else:
        ncdid = 0
        take = len(old_nc)
        limit = cdid or S.Infinity
        failed = []
        i = 0
        while limit and i + take <= len(nc):
            hit = False
            rat = []
            for j in range(take):
                if nc[i + j][0] != old_nc[j][0]:
                    break
                elif j == 0:
                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
                elif j == take - 1:
                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
                elif nc[i + j][1] != old_nc[j][1]:
                    break
                else:
                    rat.append(1)
                j += 1
            else:
                ndo = min(rat)
                if ndo:
                    if take == 1:
                        if cdid:
                            ndo = min(cdid, ndo)
                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])
                    else:
                        ndo = 1
                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])
                        mid = new
                        ir = i + take - 1
                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])
                        if r[1]:
                            if i + take < len(nc):
                                nc[i:i + take] = [l * mid, r]
                            else:
                                r = rejoin(*r)
                                nc[i:i + take] = [l * mid * r]
                        else:
                            nc[i:i + take] = [l * mid]
                    limit -= ndo
                    ncdid += ndo
                    hit = True
            if not hit:
                failed.append(i)
            i += 1
        else:
            if not ncdid:
                return rv
            failed.extend(range(i, len(nc)))
            for i in failed:
                nc[i] = rejoin(*nc[i]).subs(old, new)
    if cdid is None:
        do = ncdid
    elif ncdid is None:
        do = cdid
    else:
        do = min(ncdid, cdid)
    margs = []
    for b in c:
        if b in old_c:
            e = c[b] - old_c[b] * do
            margs.append(rejoin(b, e))
        else:
            margs.append(rejoin(b.subs(old, new), c[b]))
    if cdid and (not ncdid):
        margs = [Pow(new, cdid)] + margs
    return co_residual * self2.func(*margs) * self2.func(*nc)

.sympy.core.numbers.Number._eval_subs

def _eval_subs(self, old, new):
    if old == -self:
        return -new
    return self

.sympy.core.power.Pow._eval_subs

def _eval_subs(self, old, new):
    from sympy import exp, log, Symbol

    def _check(ct1, ct2, old):
        coeff1, terms1 = ct1
        coeff2, terms2 = ct2
        if terms1 == terms2:
            if old.is_commutative:
                pow = coeff1 / coeff2
                try:
                    as_int(pow, strict=False)
                    combines = True
                except ValueError:
                    combines = isinstance(Pow._eval_power(Pow(*old.as_base_exp(), evaluate=False), pow), (Pow, exp, Symbol))
                return (combines, pow, None)
            else:
                if not isinstance(terms1, tuple):
                    terms1 = (terms1,)
                if not all((term.is_integer for term in terms1)):
                    return (False, None, None)
                try:
                    pow, remainder = divmod(as_int(coeff1), as_int(coeff2))
                    if pow < 0 and remainder != 0:
                        pow += 1
                        remainder -= as_int(coeff2)
                    if remainder == 0:
                        remainder_pow = None
                    else:
                        remainder_pow = Mul(remainder, *terms1)
                    return (True, pow, remainder_pow)
                except ValueError:
                    pass
        return (False, None, None)
    if old == self.base:
        return new ** self.exp._subs(old, new)
    if isinstance(old, self.func) and self.exp == old.exp:
        l = log(self.base, old.base)
        if l.is_Number:
            return Pow(new, l)
    if isinstance(old, self.func) and self.base == old.base:
        if self.exp.is_Add is False:
            ct1 = self.exp.as_independent(Symbol, as_Add=False)
            ct2 = old.exp.as_independent(Symbol, as_Add=False)
            ok, pow, remainder_pow = _check(ct1, ct2, old)
            if ok:
                result = self.func(new, pow)
                if remainder_pow is not None:
                    result = Mul(result, Pow(old.base, remainder_pow))
                return result
        else:
            oarg = old.exp
            new_l = []
            o_al = []
            ct2 = oarg.as_coeff_mul()
            for a in self.exp.args:
                newa = a._subs(old, new)
                ct1 = newa.as_coeff_mul()
                ok, pow, remainder_pow = _check(ct1, ct2, old)
                if ok:
                    new_l.append(new ** pow)
                    if remainder_pow is not None:
                        o_al.append(remainder_pow)
                    continue
                elif not old.is_commutative and (not newa.is_integer):
                    return
                o_al.append(newa)
            if new_l:
                expo = Add(*o_al)
                new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)
                return Mul(*new_l)
    if isinstance(old, exp) and self.exp.is_extended_real and self.base.is_positive:
        ct1 = old.args[0].as_independent(Symbol, as_Add=False)
        ct2 = (self.exp * log(self.base)).as_independent(Symbol, as_Add=False)
        ok, pow, remainder_pow = _check(ct1, ct2, old)
        if ok:
            result = self.func(new, pow)
            if remainder_pow is not None:
                result = Mul(result, Pow(old.base, remainder_pow))
            return result

.sympy.core.add.Add._eval_power

def _eval_power(self, e):
    if e.is_Rational and self.is_number:
        from sympy.core.evalf import pure_complex
        from sympy.core.mul import _unevaluated_Mul
        from sympy.core.exprtools import factor_terms
        from sympy.core.function import expand_multinomial
        from sympy.functions.elementary.complexes import sign
        from sympy.functions.elementary.miscellaneous import sqrt
        ri = pure_complex(self)
        if ri:
            r, i = ri
            if e.q == 2:
                D = sqrt(r ** 2 + i ** 2)
                if D.is_Rational:
                    root = sqrt(factor_terms((D - r) / 2)) ** e.p
                    return root * expand_multinomial(((D + r) / abs(i) + sign(i) * S.ImaginaryUnit) ** e.p)
            elif e == -1:
                return _unevaluated_Mul(r - i * S.ImaginaryUnit, 1 / (r ** 2 + i ** 2))
    elif e.is_Number and abs(e) != 1:
        c, m = zip(*[i.as_coeff_Mul() for i in self.args])
        if any((i.is_Float for i in c)):
            big = -1
            for i in c:
                if abs(i) >= big:
                    big = abs(i)
            if big > 0 and big != 1:
                from sympy.functions.elementary.complexes import sign
                bigs = (big, -big)
                c = [sign(i) if i in bigs else i / big for i in c]
                addpow = Add(*[c * m for c, m in zip(c, m)]) ** e
                return big ** e * addpow

.sympy.core.evalf.pure_complex

def pure_complex(v, or_real=False):
    h, t = v.as_coeff_Add()
    if not t:
        if or_real:
            return (h, t)
        return
    c, i = t.as_coeff_Mul()
    if i is S.ImaginaryUnit:
        return (h, c)

.sympy.core.operations.AssocOp._eval_evalf

def _eval_evalf(self, prec):
    from .add import Add
    from .mul import Mul
    from .symbol import Symbol
    from .function import AppliedUndef
    if isinstance(self, (Mul, Add)):
        x, tail = self.as_independent(Symbol, AppliedUndef)
        if not (tail is self.identity or (isinstance(x, AssocOp) and x.is_Function) or (x is self.identity and isinstance(tail, AssocOp))):
            x = x._evalf(prec) if x is not self.identity else self.identity
            args = []
            tail_args = tuple(self.func.make_args(tail))
            for a in tail_args:
                newa = a._eval_evalf(prec)
                if newa is None:
                    args.append(a)
                else:
                    args.append(newa)
            return self.func(x, *args)
    args = []
    for a in self.args:
        newa = a._eval_evalf(prec)
        if newa is None:
            args.append(a)
        else:
            args.append(newa)
    return self.func(*args)

.sympy.core.numbers.Rational._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_rational(self.p, self.q, prec, rnd)

.sympy.core.mul.Mul._eval_evalf

def _eval_evalf(self, prec):
    c, m = self.as_coeff_Mul()
    if c is S.NegativeOne:
        if m.is_Mul:
            rv = -AssocOp._eval_evalf(m, prec)
        else:
            mnew = m._eval_evalf(prec)
            if mnew is not None:
                m = mnew
            rv = -m
    else:
        rv = AssocOp._eval_evalf(self, prec)
    if rv.is_number:
        return rv.expand()
    return rv

.sympy.core.power.Pow._eval_evalf

def _eval_evalf(self, prec):
    base, exp = self.as_base_exp()
    base = base._evalf(prec)
    if not exp.is_Integer:
        exp = exp._evalf(prec)
    if exp.is_negative and base.is_number and (base.is_extended_real is False):
        base = base.conjugate() / (base * base.conjugate())._evalf(prec)
        exp = -exp
        return self.func(base, exp).expand()
    return self.func(base, exp)

.sympy.core.evalf.EvalfMixin._evalf

def _evalf(self, prec):
    r = self._eval_evalf(prec)
    if r is None:
        r = self
    return r

.sympy.core.numbers.Float._eval_is_negative

def _eval_is_negative(self):
    if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
        return False
    return self.num < 0

.sympy.core.numbers.Float.__nonzero__

def __nonzero__(self):
    return self._mpf_ != fzero

.sympy.core.numbers.Float._eval_is_integer

def _eval_is_integer(self):
    return self._mpf_ == fzero

.sympy.core.numbers.NaN._as_mpf_val

def _as_mpf_val(self, prec):
    return _mpf_nan

.sympy.core.numbers.Float._eval_power

def _eval_power(self, expt):
    if self == 0:
        if expt.is_positive:
            return S.Zero
        if expt.is_negative:
            return S.Infinity
    if isinstance(expt, Number):
        if isinstance(expt, Integer):
            prec = self._prec
            return Float._new(mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
        elif isinstance(expt, Rational) and expt.p == 1 and expt.q % 2 and self.is_negative:
            return Pow(S.NegativeOne, expt, evaluate=False) * (-self)._eval_power(expt)
        expt, prec = expt._as_mpf_op(self._prec)
        mpfself = self._mpf_
        try:
            y = mpf_pow(mpfself, expt, prec, rnd)
            return Float._new(y, prec)
        except mlib.ComplexResult:
            re, im = mlib.mpc_pow((mpfself, fzero), (expt, fzero), prec, rnd)
            return Float._new(re, prec) + Float._new(im, prec) * S.ImaginaryUnit

.sympy.core.numbers.Float._as_mpf_op

def _as_mpf_op(self, prec):
    return (self._mpf_, max(prec, self._prec))

.sympy.core.numbers.Float.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        rhs, prec = other._as_mpf_op(self._prec)
        return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
    return Number.__mul__(self, other)

.sympy.core.numbers.Number._as_mpf_op

def _as_mpf_op(self, prec):
    prec = max(prec, self._prec)
    return (self._as_mpf_val(prec), prec)

.sympy.core.numbers.Float.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        rhs, prec = other._as_mpf_op(self._prec)
        return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
    return Number.__add__(self, other)

.sympy.core.evalf.evalf_add

def evalf_add(v, prec, options):
    res = pure_complex(v)
    if res:
        h, c = res
        re, _, re_acc, _ = evalf(h, prec, options)
        im, _, im_acc, _ = evalf(c, prec, options)
        return (re, im, re_acc, im_acc)
    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
    i = 0
    target_prec = prec
    while 1:
        options['maxprec'] = min(oldmaxprec, 2 * prec)
        terms = [evalf(arg, prec + 10, options) for arg in v.args]
        re, re_acc = add_terms([a[0::2] for a in terms if a[0]], prec, target_prec)
        im, im_acc = add_terms([a[1::2] for a in terms if a[1]], prec, target_prec)
        acc = complex_accuracy((re, im, re_acc, im_acc))
        if acc >= target_prec:
            if options.get('verbose'):
                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)
            break
        else:
            if prec - target_prec > options['maxprec']:
                break
            prec = prec + max(10 + 2 ** i, target_prec - acc)
            i += 1
            if options.get('verbose'):
                print('ADD: restarting with prec', prec)
    options['maxprec'] = oldmaxprec
    if iszero(re, scaled=True):
        re = scaled_zero(re)
    if iszero(im, scaled=True):
        im = scaled_zero(im)
    return (re, im, re_acc, im_acc)

.sympy.core.evalf.evalf_mul

def evalf_mul(v, prec, options):
    res = pure_complex(v)
    if res:
        _, h = res
        im, _, im_acc, _ = evalf(h, prec, options)
        return (None, im, None, im_acc)
    args = list(v.args)
    special = []
    from sympy.core.numbers import Float
    for arg in args:
        arg = evalf(arg, prec, options)
        if arg[0] is None:
            continue
        arg = Float._new(arg[0], 1)
        if arg is S.NaN or arg.is_infinite:
            special.append(arg)
    if special:
        from sympy.core.mul import Mul
        special = Mul(*special)
        return evalf(special, prec + 4, {})
    acc = prec
    working_prec = prec + len(args) + 5
    start = man, exp, bc = (MPZ(1), 0, 1)
    last = len(args)
    direction = 0
    args.append(S.One)
    complex_factors = []
    for i, arg in enumerate(args):
        if i != last and pure_complex(arg):
            args[-1] = (args[-1] * arg).expand()
            continue
        elif i == last and arg is S.One:
            continue
        re, im, re_acc, im_acc = evalf(arg, working_prec, options)
        if re and im:
            complex_factors.append((re, im, re_acc, im_acc))
            continue
        elif re:
            (s, m, e, b), w_acc = (re, re_acc)
        elif im:
            (s, m, e, b), w_acc = (im, im_acc)
            direction += 1
        else:
            return (None, None, None, None)
        direction += 2 * s
        man *= m
        exp += e
        bc += b
        if bc > 3 * working_prec:
            man >>= working_prec
            exp += working_prec
        acc = min(acc, w_acc)
    sign = (direction & 2) >> 1
    if not complex_factors:
        v = normalize(sign, man, exp, bitcount(man), prec, rnd)
        if direction & 1:
            return (None, v, None, acc)
        else:
            return (v, None, acc, None)
    else:
        if (man, exp, bc) != start:
            re, im = ((sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0))
            i0 = 0
        else:
            wre, wim, wre_acc, wim_acc = complex_factors[0]
            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))
            re = wre
            im = wim
            i0 = 1
        for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:
            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))
            use_prec = working_prec
            A = mpf_mul(re, wre, use_prec)
            B = mpf_mul(mpf_neg(im), wim, use_prec)
            C = mpf_mul(re, wim, use_prec)
            D = mpf_mul(im, wre, use_prec)
            re = mpf_add(A, B, use_prec)
            im = mpf_add(C, D, use_prec)
        if options.get('verbose'):
            print('MUL: wanted', prec, 'accurate bits, got', acc)
        if direction & 1:
            re, im = (mpf_neg(im), re)
        return (re, im, acc, acc)

.sympy.core.expr.Expr.as_coeff_Add

def as_coeff_Add(self, rational=False):
    return (S.Zero, self)

.sympy.core.evalf.bitcount

def bitcount(n):
    return mpmath_bitcount(abs(int(n)))

.sympy.core.evalf.add_terms

def add_terms(terms, prec, target_prec):
    terms = [t for t in terms if not iszero(t[0])]
    if not terms:
        return (None, None)
    elif len(terms) == 1:
        return terms[0]
    special = []
    from sympy.core.numbers import Float
    for t in terms:
        arg = Float._new(t[0], 1)
        if arg is S.NaN or arg.is_infinite:
            special.append(arg)
    if special:
        from sympy.core.add import Add
        rv = evalf(Add(*special), prec + 4, {})
        return (rv[0], rv[2])
    working_prec = 2 * prec
    sum_man, sum_exp, absolute_error = (0, 0, MINUS_INF)
    for x, accuracy in terms:
        sign, man, exp, bc = x
        if sign:
            man = -man
        absolute_error = max(absolute_error, bc + exp - accuracy)
        delta = exp - sum_exp
        if exp >= sum_exp:
            if delta > working_prec and (not sum_man or delta - bitcount(abs(sum_man)) > working_prec):
                sum_man = man
                sum_exp = exp
            else:
                sum_man += man << delta
        else:
            delta = -delta
            if delta - bc > working_prec:
                if not sum_man:
                    sum_man, sum_exp = (man, exp)
            else:
                sum_man = (sum_man << delta) + man
                sum_exp = exp
    if not sum_man:
        return scaled_zero(absolute_error)
    if sum_man < 0:
        sum_sign = 1
        sum_man = -sum_man
    else:
        sum_sign = 0
    sum_bc = bitcount(sum_man)
    sum_accuracy = sum_exp + sum_bc - absolute_error
    r = (normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec, rnd), sum_accuracy)
    return r

.sympy.core.evalf.iszero

def iszero(mpf, scaled=False):
    if not scaled:
        return not mpf or (not mpf[1] and (not mpf[-1]))
    return mpf and type(mpf[0]) is list and (mpf[1] == mpf[-1] == 1)

.sympy.core.evalf.complex_accuracy

def complex_accuracy(result):
    re, im, re_acc, im_acc = result
    if not im:
        if not re:
            return INF
        return re_acc
    if not re:
        return im_acc
    re_size = fastlog(re)
    im_size = fastlog(im)
    absolute_error = max(re_size - re_acc, im_size - im_acc)
    relative_error = absolute_error - max(re_size, im_size)
    return -relative_error

.sympy.sets.fancysets.Integers._contains

def _contains(self, other):
    if not isinstance(other, Expr):
        return S.false
    return other.is_integer

.sympy.core.symbol.Symbol._eval_subs

def _eval_subs(self, old, new):
    from sympy.core.power import Pow
    if old.is_Pow:
        return Pow(self, S.One, evaluate=False)._eval_subs(old, new)

.sympy.core.numbers.Zero._eval_power

def _eval_power(self, expt):
    if expt.is_positive:
        return self
    if expt.is_negative:
        return S.ComplexInfinity
    if expt.is_extended_real is False:
        return S.NaN
    coeff, terms = expt.as_coeff_Mul()
    if coeff.is_negative:
        return S.ComplexInfinity ** terms
    if coeff is not S.One:
        return self ** terms

.sympy.polys.densearith.dmp_neg

def dmp_neg(f, u, K):
    if not u:
        return dup_neg(f, K)
    v = u - 1
    return [dmp_neg(cf, v, K) for cf in f]

.sympy.core.expr.Expr.as_coeff_mul

def as_coeff_mul(self, *deps, **kwargs):
    if deps:
        if not self.has(*deps):
            return (self, tuple())
    return (S.One, (self,))

.sympy.polys.densearith.dup_sqr

def dup_sqr(f, K):
    df, h = (len(f) - 1, [])
    for i in range(0, 2 * df + 1):
        c = K.zero
        jmin = max(0, i - df)
        jmax = min(i, df)
        n = jmax - jmin + 1
        jmax = jmin + n // 2 - 1
        for j in range(jmin, jmax + 1):
            c += f[j] * f[i - j]
        c += c
        if n & 1:
            elem = f[jmax + 1]
            c += elem ** 2
        h.append(c)
    return dup_strip(h)

.sympy.solvers.diophantine.base_solution_linear

def base_solution_linear(c, a, b, t=None):
    a, b, c = _remove_gcd(a, b, c)
    if c == 0:
        if t is not None:
            if b < 0:
                t = -t
            return (b * t, -a * t)
        else:
            return (0, 0)
    else:
        x0, y0, d = igcdex(abs(a), abs(b))
        x0 *= sign(a)
        y0 *= sign(b)
        if divisible(c, d):
            if t is not None:
                if b < 0:
                    t = -t
                return (c * x0 + b * t, c * y0 - a * t)
            else:
                return (c * x0, c * y0)
        else:
            return (None, None)

.sympy.core.numbers.Integer.__rsub__

def __rsub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(other - self.p)
        elif isinstance(other, Rational):
            return Rational(other.p - self.p * other.q, other.q, 1)
        return Rational.__rsub__(self, other)
    return Rational.__rsub__(self, other)

.sympy.polys.densebasic._rec_inflate

def _rec_inflate(g, M, v, i, K):
    if not v:
        return dup_inflate(g, M[i], K)
    if M[i] <= 0:
        raise IndexError('all M[i] must be positive, got %s' % M[i])
    w, j = (v - 1, i + 1)
    g = [_rec_inflate(c, M, w, j, K) for c in g]
    result = [g[0]]
    for coeff in g[1:]:
        for _ in range(1, M[i]):
            result.append(dmp_zero(w))
        result.append(coeff)
    return result

.sympy.polys.densebasic.dup_inflate

def dup_inflate(f, m, K):
    if m <= 0:
        raise IndexError("'m' must be positive, got %s" % m)
    if m == 1 or not f:
        return f
    result = [f[0]]
    for coeff in f[1:]:
        result.extend([K.zero] * (m - 1))
        result.append(coeff)
    return result

.sympy.ntheory.primetest.mr

def mr(n, bases):
    from sympy.ntheory.factor_ import trailing
    from sympy.polys.domains import ZZ
    n = as_int(n)
    if n < 2:
        return False
    s = trailing(n - 1)
    t = n >> s
    for base in bases:
        if base >= n:
            base %= n
        if base >= 2:
            base = ZZ(base)
            if not _test(n, base, s, t):
                return False
    return True

.sympy.ntheory.primetest._test

def _test(n, base, s, t):
    b = pow(base, t, n)
    if b == 1 or b == n - 1:
        return True
    else:
        for j in range(1, s):
            b = pow(b, 2, n)
            if b == n - 1:
                return True
            if b == 1:
                return False
    return False

.sympy.core.numbers._literal_float

def _literal_float(f):
    return bool(_floatpat.match(f))

.sympy.core.numbers._decimal_to_Rational_prec

def _decimal_to_Rational_prec(dec):
    if not dec.is_finite():
        raise TypeError('dec must be finite, got %s.' % dec)
    s, d, e = dec.as_tuple()
    prec = len(d)
    if e >= 0:
        rv = Integer(int(dec))
    else:
        s = (-1) ** s
        d = sum([di * 10 ** i for i, di in enumerate(reversed(d))])
        rv = Rational(s * d, 10 ** (-e))
    return (rv, prec)

.sympy.printing.str.StrPrinter._print_Zero

def _print_Zero(self, expr):
    if self._settings.get('sympy_integers', False):
        return 'S(0)'
    return '0'

.sympy.ntheory.primetest.is_square

def is_square(n, prep=True):
    if prep:
        n = as_int(n)
        if n < 0:
            return False
        if n in [0, 1]:
            return True
    m = n & 127
    if not m * 2344881533 & m * 2716005841 & 1311242:
        m = n % 63
        if not m * 1028201975 & m * 3357846009 & 284246024:
            from sympy.core.power import integer_nthroot
            return integer_nthroot(n, 2)[1]
    return False

.sympy.core.function._mexpand

def _mexpand(expr, recursive=False):
    if expr is None:
        return
    was = None
    while was != expr:
        was, expr = (expr, expand_mul(expand_multinomial(expr)))
        if not recursive:
            break
    return expr

.sympy.core.function.expand_multinomial

def expand_multinomial(expr, deep=True):
    return sympify(expr).expand(deep=deep, mul=False, power_exp=False, power_base=False, basic=False, multinomial=True, log=False)

.sympy.core.function.expand_mul

def expand_mul(expr, deep=True):
    return sympify(expr).expand(deep=deep, mul=True, power_exp=False, power_base=False, basic=False, multinomial=False, log=False)

.sympy.ntheory.factor_._divisors

def _divisors(n, proper=False):
    factordict = factorint(n)
    ps = sorted(factordict.keys())

    def rec_gen(n=0):
        if n == len(ps):
            yield 1
        else:
            pows = [1]
            for j in range(factordict[ps[n]]):
                pows.append(pows[-1] * ps[n])
            for q in rec_gen(n + 1):
                for p in pows:
                    yield (p * q)
    if proper:
        for p in rec_gen():
            if p != n:
                yield p
    else:
        for p in rec_gen():
            yield p

.sympy.ntheory.factor_.rec_gen

def rec_gen(n=0):
    if n == len(ps):
        yield 1
    else:
        pows = [1]
        for j in range(factordict[ps[n]]):
            pows.append(pows[-1] * ps[n])
        for q in rec_gen(n + 1):
            for p in pows:
                yield (p * q)

.sympy.solvers.diophantine.is_solution_quad

def is_solution_quad(var, coeff, u, v):
    reps = dict(zip(var, (u, v)))
    eq = Add(*[j * i.xreplace(reps) for i, j in coeff.items()])
    return _mexpand(eq) == 0

.sympy.polys.densearith.dup_l1_norm

def dup_l1_norm(f, K):
    if not f:
        return K.zero
    else:
        return sum(dup_abs(f, K))

.sympy.core.numbers.Zero.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (S.One, self)

.sympy.polys.monomials.monomial_min

def monomial_min(*monoms):
    M = list(monoms[0])
    for N in monoms[1:]:
        for i, n in enumerate(N):
            M[i] = min(M[i], n)
    return tuple(M)

.sympy.polys.factortools._test_pl

def _test_pl(fc, q, pl):
    if q > pl // 2:
        q = q - pl
    if not q:
        return True
    return fc % q == 0

.sympy.polys.factortools.dmp_zz_wang_lead_coeffs

def dmp_zz_wang_lead_coeffs(f, T, cs, E, H, A, u, K):
    C, J, v = ([], [0] * len(E), u - 1)
    for h in H:
        c = dmp_one(v, K)
        d = dup_LC(h, K) * cs
        for i in reversed(range(len(E))):
            k, e, (t, _) = (0, E[i], T[i])
            while not d % e:
                d, k = (d // e, k + 1)
            if k != 0:
                c, J[i] = (dmp_mul(c, dmp_pow(t, k, v, K), v, K), 1)
        C.append(c)
    if any((not j for j in J)):
        raise ExtraneousFactors
    CC, HH = ([], [])
    for c, h in zip(C, H):
        d = dmp_eval_tail(c, A, v, K)
        lc = dup_LC(h, K)
        if K.is_one(cs):
            cc = lc // d
        else:
            g = K.gcd(lc, d)
            d, cc = (d // g, lc // g)
            h, cs = (dup_mul_ground(h, d, K), cs // d)
        c = dmp_mul_ground(c, cc, v, K)
        CC.append(c)
        HH.append(h)
    if K.is_one(cs):
        return (f, HH, CC)
    CCC, HHH = ([], [])
    for c, h in zip(CC, HH):
        CCC.append(dmp_mul_ground(c, cs, v, K))
        HHH.append(dmp_mul_ground(h, cs, 0, K))
    f = dmp_mul_ground(f, cs ** (len(H) - 1), u, K)
    return (f, HHH, CCC)

.sympy.polys.densebasic.dmp_one

def dmp_one(u, K):
    return dmp_ground(K.one, u)

.sympy.polys.densebasic.dmp_ground

def dmp_ground(c, u):
    if not c:
        return dmp_zero(u)
    for i in range(u + 1):
        c = [c]
    return c

.sympy.polys.factortools.dmp_zz_wang_hensel_lifting

def dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K):
    S, n, v = ([f], len(A), u - 1)
    H = list(H)
    for i, a in enumerate(reversed(A[1:])):
        s = dmp_eval_in(S[0], a, n - i, u - i, K)
        S.insert(0, dmp_ground_trunc(s, p, v - i, K))
    d = max(dmp_degree_list(f, u)[1:])
    for j, s, a in zip(range(2, n + 2), S, A):
        G, w = (list(H), j - 1)
        I, J = (A[:j - 2], A[j - 1:])
        for i, (h, lc) in enumerate(zip(H, LC)):
            lc = dmp_ground_trunc(dmp_eval_tail(lc, J, v, K), p, w - 1, K)
            H[i] = [lc] + dmp_raise(h[1:], 1, w - 1, K)
        m = dmp_nest([K.one, -a], w, K)
        M = dmp_one(w, K)
        c = dmp_sub(s, dmp_expand(H, w, K), w, K)
        dj = dmp_degree_in(s, w, w)
        for k in K.map(range(0, dj)):
            if dmp_zero_p(c, w):
                break
            M = dmp_mul(M, m, w, K)
            C = dmp_diff_eval_in(c, k + 1, a, w, w, K)
            if not dmp_zero_p(C, w - 1):
                C = dmp_quo_ground(C, K.factorial(k + 1), w - 1, K)
                T = dmp_zz_diophantine(G, C, I, d, p, w - 1, K)
                for i, (h, t) in enumerate(zip(H, T)):
                    h = dmp_add_mul(h, dmp_raise(t, 1, w - 1, K), M, w, K)
                    H[i] = dmp_ground_trunc(h, p, w, K)
                h = dmp_sub(s, dmp_expand(H, w, K), w, K)
                c = dmp_ground_trunc(h, p, w, K)
    if dmp_expand(H, u, K) != f:
        raise ExtraneousFactors
    else:
        return H

.sympy.polys.densebasic.dmp_raise

def dmp_raise(f, l, u, K):
    if not l:
        return f
    if not u:
        if not f:
            return dmp_zero(l)
        k = l - 1
        return [dmp_ground(c, k) for c in f]
    v = u - 1
    return [dmp_raise(c, l, v, K) for c in f]

.sympy.polys.densebasic.dmp_nest

def dmp_nest(f, l, K):
    if not isinstance(f, list):
        return dmp_ground(f, l)
    for i in range(l):
        f = [f]
    return f

.sympy.polys.densearith.dmp_expand

def dmp_expand(polys, u, K):
    if not polys:
        return dmp_one(u, K)
    f = polys[0]
    for g in polys[1:]:
        f = dmp_mul(f, g, u, K)
    return f

.sympy.polys.densebasic._rec_degree_in

def _rec_degree_in(g, v, i, j):
    if i == j:
        return dmp_degree(g, v)
    v, i = (v - 1, i + 1)
    return max([_rec_degree_in(c, v, i, j) for c in g])

.sympy.polys.domains.domain.Domain.map

def map(self, seq):
    result = []
    for elt in seq:
        if isinstance(elt, list):
            result.append(self.map(elt))
        else:
            result.append(self(elt))
    return result

.sympy.polys.densetools.dmp_diff_eval_in

def dmp_diff_eval_in(f, m, a, j, u, K):
    if j > u:
        raise IndexError('-%s <= j < %s expected, got %s' % (u, u, j))
    if not j:
        return dmp_eval(dmp_diff(f, m, u, K), a, u, K)
    return _rec_diff_eval(f, m, a, u, 0, j, K)

.sympy.polys.densetools._rec_diff_eval

def _rec_diff_eval(g, m, a, v, i, j, K):
    if i == j:
        return dmp_eval(dmp_diff(g, m, v, K), a, v, K)
    v, i = (v - 1, i + 1)
    return dmp_strip([_rec_diff_eval(c, m, a, v, i, j, K) for c in g], v)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.factorial

def factorial(self, a):
    return python_factorial(a)

.sympy.polys.domains.groundtypes.python_factorial

def python_factorial(n):
    return int(mlib.ifac(n))

.sympy.polys.factortools.dmp_zz_diophantine

def dmp_zz_diophantine(F, c, A, d, p, u, K):
    if not A:
        S = [[] for _ in F]
        n = dup_degree(c)
        for i, coeff in enumerate(c):
            if not coeff:
                continue
            T = dup_zz_diophantine(F, n - i, p, K)
            for j, (s, t) in enumerate(zip(S, T)):
                t = dup_mul_ground(t, coeff, K)
                S[j] = dup_trunc(dup_add(s, t, K), p, K)
    else:
        n = len(A)
        e = dmp_expand(F, u, K)
        a, A = (A[-1], A[:-1])
        B, G = ([], [])
        for f in F:
            B.append(dmp_quo(e, f, u, K))
            G.append(dmp_eval_in(f, a, n, u, K))
        C = dmp_eval_in(c, a, n, u, K)
        v = u - 1
        S = dmp_zz_diophantine(G, C, A, d, p, v, K)
        S = [dmp_raise(s, 1, v, K) for s in S]
        for s, b in zip(S, B):
            c = dmp_sub_mul(c, s, b, u, K)
        c = dmp_ground_trunc(c, p, u, K)
        m = dmp_nest([K.one, -a], n, K)
        M = dmp_one(n, K)
        for k in K.map(range(0, d)):
            if dmp_zero_p(c, u):
                break
            M = dmp_mul(M, m, u, K)
            C = dmp_diff_eval_in(c, k + 1, a, n, u, K)
            if not dmp_zero_p(C, v):
                C = dmp_quo_ground(C, K.factorial(k + 1), v, K)
                T = dmp_zz_diophantine(G, C, A, d, p, v, K)
                for i, t in enumerate(T):
                    T[i] = dmp_mul(dmp_raise(t, 1, v, K), M, u, K)
                for i, (s, t) in enumerate(zip(S, T)):
                    S[i] = dmp_add(s, t, u, K)
                for t, b in zip(T, B):
                    c = dmp_sub_mul(c, t, b, u, K)
                c = dmp_ground_trunc(c, p, u, K)
        S = [dmp_ground_trunc(s, p, u, K) for s in S]
    return S

.sympy.polys.factortools.dup_zz_diophantine

def dup_zz_diophantine(F, m, p, K):
    if len(F) == 2:
        a, b = F
        f = gf_from_int_poly(a, p)
        g = gf_from_int_poly(b, p)
        s, t, G = gf_gcdex(g, f, p, K)
        s = gf_lshift(s, m, K)
        t = gf_lshift(t, m, K)
        q, s = gf_div(s, f, p, K)
        t = gf_add_mul(t, q, g, p, K)
        s = gf_to_int_poly(s, p)
        t = gf_to_int_poly(t, p)
        result = [s, t]
    else:
        G = [F[-1]]
        for f in reversed(F[1:-1]):
            G.insert(0, dup_mul(f, G[0], K))
        S, T = ([], [[1]])
        for f, g in zip(F, G):
            t, s = dmp_zz_diophantine([g, f], T[-1], [], 0, p, 1, K)
            T.append(t)
            S.append(s)
        result, S = ([], S + [T[-1]])
        for s, f in zip(S, F):
            s = gf_from_int_poly(s, p)
            f = gf_from_int_poly(f, p)
            r = gf_rem(gf_lshift(s, m, K), f, p, K)
            s = gf_to_int_poly(r, p)
            result.append(s)
    return result

.sympy.polys.galoistools.gf_lshift

def gf_lshift(f, n, K):
    if not f:
        return f
    else:
        return f + [K.zero] * n

.sympy.polys.galoistools.gf_add_mul

def gf_add_mul(f, g, h, p, K):
    return gf_add(f, gf_mul(g, h, p, K), p, K)

.sympy.polys.densearith.dmp_add_mul

def dmp_add_mul(f, g, h, u, K):
    return dmp_add(f, dmp_mul(g, h, u, K), u, K)

.sympy.core.numbers.Integer._eval_is_composite

def _eval_is_composite(self):
    if self > 1:
        return fuzzy_not(self.is_prime)
    else:
        return False

.sympy.core.numbers.Integer.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p > other.p)
    return Rational.__gt__(self, other)


[/PYTHON]
What will be the input of `diophantine`, given the following input:
[OUTPUT]
```
{
    "output": "{(-8*q**2, 64*p**2 + 16*p*q + q**2, 64*p*q + 8*q**2)}"
}
```
[/OUTPUT]

[THOUGHT]
