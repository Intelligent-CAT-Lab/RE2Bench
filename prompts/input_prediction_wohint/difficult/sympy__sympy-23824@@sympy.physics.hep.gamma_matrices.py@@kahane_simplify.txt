You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. You only need to predict input variable values, and print input between [INPUT] and [/INPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT]. 
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from sympy.core.mul import Mul
from sympy.core.singleton import S
from sympy.matrices.dense import eye
from sympy.matrices.expressions.trace import trace
from sympy.tensor.tensor import TensorIndexType, TensorIndex, TensMul, TensAdd, tensor_mul, Tensor, TensorHead, TensorSymmetry
LorentzIndex = TensorIndexType('LorentzIndex', dim=4, dummy_name='L')
GammaMatrix = TensorHead('GammaMatrix', [LorentzIndex], TensorSymmetry.no_symmetry(1), comm=None)

def kahane_simplify(expression):
    if isinstance(expression, Mul):
        return expression
    if isinstance(expression, TensAdd):
        return TensAdd(*[kahane_simplify(arg) for arg in expression.args])
    if isinstance(expression, Tensor):
        return expression
    assert isinstance(expression, TensMul)
    gammas = expression.args
    for gamma in gammas:
        assert gamma.component == GammaMatrix
    free = expression.free
    dum = []
    for dum_pair in expression.dum:
        if expression.index_types[dum_pair[0]] == LorentzIndex:
            dum.append((dum_pair[0], dum_pair[1]))
    dum = sorted(dum)
    if len(dum) == 0:
        return expression
    first_dum_pos = min(map(min, dum))
    total_number = len(free) + len(dum) * 2
    number_of_contractions = len(dum)
    free_pos = [None] * total_number
    for i in free:
        free_pos[i[1]] = i[0]
    index_is_free = [False] * total_number
    for i, indx in enumerate(free):
        index_is_free[indx[1]] = True
    links = {i: [] for i in range(first_dum_pos, total_number)}
    cum_sign = -1
    cum_sign_list = [None] * total_number
    block_free_count = 0
    resulting_coeff = S.One
    resulting_indices = [[]]
    connected_components = 1
    for i, is_free in enumerate(index_is_free):
        if i < first_dum_pos:
            continue
        if is_free:
            block_free_count += 1
            if block_free_count > 1:
                links[i - 1].append(i)
                links[i].append(i - 1)
        else:
            cum_sign *= 1 if block_free_count % 2 else -1
            if block_free_count == 0 and i != first_dum_pos:
                if cum_sign == -1:
                    links[-1 - i] = [-1 - i + 1]
                    links[-1 - i + 1] = [-1 - i]
            if i - cum_sign in links:
                if i != first_dum_pos:
                    links[i].append(i - cum_sign)
                if block_free_count != 0:
                    if i - cum_sign < len(index_is_free):
                        if index_is_free[i - cum_sign]:
                            links[i - cum_sign].append(i)
            block_free_count = 0
        cum_sign_list[i] = cum_sign
    for i in dum:
        pos1 = i[0]
        pos2 = i[1]
        links[pos1].append(pos2)
        links[pos2].append(pos1)
        linkpos1 = pos1 + cum_sign_list[pos1]
        linkpos2 = pos2 + cum_sign_list[pos2]
        if linkpos1 >= total_number:
            continue
        if linkpos2 >= total_number:
            continue
        if linkpos1 < first_dum_pos:
            continue
        if linkpos2 < first_dum_pos:
            continue
        if -1 - linkpos1 in links:
            linkpos1 = -1 - linkpos1
        if -1 - linkpos2 in links:
            linkpos2 = -1 - linkpos2
        if linkpos1 >= 0 and (not index_is_free[linkpos1]):
            linkpos1 = pos1
        if linkpos2 >= 0 and (not index_is_free[linkpos2]):
            linkpos2 = pos2
        if linkpos2 not in links[linkpos1]:
            links[linkpos1].append(linkpos2)
        if linkpos1 not in links[linkpos2]:
            links[linkpos2].append(linkpos1)
    pointer = first_dum_pos
    previous_pointer = 0
    while True:
        if pointer in links:
            next_ones = links.pop(pointer)
        else:
            break
        if previous_pointer in next_ones:
            next_ones.remove(previous_pointer)
        previous_pointer = pointer
        if next_ones:
            pointer = next_ones[0]
        else:
            break
        if pointer == previous_pointer:
            break
        if pointer >= 0 and free_pos[pointer] is not None:
            for ri in resulting_indices:
                ri.append(free_pos[pointer])
    while links:
        connected_components += 1
        pointer = min(links.keys())
        previous_pointer = pointer
        prepend_indices = []
        while True:
            if pointer in links:
                next_ones = links.pop(pointer)
            else:
                break
            if previous_pointer in next_ones:
                if len(next_ones) > 1:
                    next_ones.remove(previous_pointer)
            previous_pointer = pointer
            if next_ones:
                pointer = next_ones[0]
            if pointer >= first_dum_pos and free_pos[pointer] is not None:
                prepend_indices.insert(0, free_pos[pointer])
        if len(prepend_indices) == 0:
            resulting_coeff *= 2
        else:
            expr1 = prepend_indices
            expr2 = list(reversed(prepend_indices))
            resulting_indices = [expri + ri for ri in resulting_indices for expri in (expr1, expr2)]
    resulting_coeff *= -1 if (number_of_contractions - connected_components + 1) % 2 else 1
    resulting_coeff *= 2 ** number_of_contractions
    resulting_indices = list((free_pos[0:first_dum_pos] + ri for ri in resulting_indices))
    resulting_expr = S.Zero
    for i in resulting_indices:
        temp_expr = S.One
        for j in i:
            temp_expr *= GammaMatrix(j)
        resulting_expr += temp_expr
    t = resulting_coeff * resulting_expr
    t1 = None
    if isinstance(t, TensAdd):
        t1 = t.args[0]
    elif isinstance(t, TensMul):
        t1 = t
    if t1:
        pass
    else:
        t = eye(4) * t
    return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.basic.Basic.args

def args(self) -> tuple[Basic, ...]:
    return self._args

.sympy.tensor.tensor.Tensor.component

def component(self):
    return self._component

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    if self is other:
        return True
    if not isinstance(other, Basic):
        return self._do_eq_sympify(other)
    if not (self.is_Number and other.is_Number) and type(self) != type(other):
        return False
    a, b = (self._hashable_content(), other._hashable_content())
    if a != b:
        return False
    for a, b in zip(a, b):
        if not isinstance(a, Basic):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, str):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)
    if ival == 1:
        return S.One
    if ival == -1:
        return S.NegativeOne
    if ival == 0:
        return S.Zero
    obj = Expr.__new__(cls)
    obj.p = ival
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.tensor.tensor.TensorHead.__call__

def __call__(self, *indices, **kw_args):
    updated_indices = []
    for idx, typ in zip(indices, self.index_types):
        if isinstance(idx, str):
            idx = idx.strip().replace(' ', '')
            if idx.startswith('-'):
                updated_indices.append(TensorIndex(idx[1:], typ, is_up=False))
            else:
                updated_indices.append(TensorIndex(idx, typ))
        else:
            updated_indices.append(idx)
    updated_indices += indices[len(updated_indices):]
    tensor = Tensor(self, updated_indices, **kw_args)
    return tensor.doit()

.sympy.tensor.tensor.TensorHead.index_types

def index_types(self):
    return list(self.args[1])

.sympy.core.containers.Tuple.__len__

def __len__(self):
    return len(self.args)

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.tensor.tensor.Tensor.__new__

def __new__(cls, tensor_head, indices, *, is_canon_bp=False, **kw_args):
    indices = cls._parse_indices(tensor_head, indices)
    obj = Basic.__new__(cls, tensor_head, Tuple(*indices), **kw_args)
    obj._index_structure = _IndexStructure.from_indices(*indices)
    obj._free = obj._index_structure.free[:]
    obj._dum = obj._index_structure.dum[:]
    obj._ext_rank = obj._index_structure._ext_rank
    obj._coeff = S.One
    obj._nocoeff = obj
    obj._component = tensor_head
    obj._components = [tensor_head]
    if tensor_head.rank != len(indices):
        raise ValueError('wrong number of indices')
    obj.is_canon_bp = is_canon_bp
    obj._index_map = Tensor._build_index_map(indices, obj._index_structure)
    return obj

.sympy.tensor.tensor.Tensor._parse_indices

def _parse_indices(tensor_head, indices):
    if not isinstance(indices, (tuple, list, Tuple)):
        raise TypeError('indices should be an array, got %s' % type(indices))
    indices = list(indices)
    for i, index in enumerate(indices):
        if isinstance(index, Symbol):
            indices[i] = TensorIndex(index, tensor_head.index_types[i], True)
        elif isinstance(index, Mul):
            c, e = index.as_coeff_Mul()
            if c == -1 and isinstance(e, Symbol):
                indices[i] = TensorIndex(e, tensor_head.index_types[i], False)
            else:
                raise ValueError('index not understood: %s' % index)
        elif not isinstance(index, TensorIndex):
            raise TypeError('wrong type for index: %s is %s' % (index, type(index)))
    return indices

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    is_sympy = getattr(a, '__sympy__', None)
    if is_sympy is True:
        return a
    elif is_sympy is not None:
        if not strict:
            return a
        else:
            raise SympifyError(a)
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    cls = getattr(a, '__class__', None)
    for superclass in getmro(cls):
        conv = _external_converter.get(superclass)
        if conv is None:
            conv = _sympy_converter.get(superclass)
        if conv is not None:
            return conv(a)
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if _is_numpy_instance(a):
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
    _sympy_ = getattr(a, '_sympy_', None)
    if _sympy_ is not None:
        try:
            return a._sympy_()
        except AttributeError:
            pass
    if not strict:
        flat = getattr(a, 'flat', None)
        if flat is not None:
            shape = getattr(a, 'shape', None)
            if shape is not None:
                from sympy.tensor.array import Array
                return Array(a.flat, a.shape)
    if not isinstance(a, str):
        if _is_numpy_instance(a):
            import numpy as np
            assert not isinstance(a, np.number)
            if isinstance(a, np.ndarray):
                if a.ndim == 0:
                    try:
                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
                    except SympifyError:
                        pass
        else:
            for coerce in (float, int):
                try:
                    return sympify(coerce(a))
                except (TypeError, ValueError, AttributeError, SympifyError):
                    continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])
        except TypeError:
            pass
    if not isinstance(a, str):
        try:
            a = str(a)
        except Exception as exc:
            raise SympifyError(a, exc)
        sympy_deprecation_warning(f'\nThe string fallback in sympify() is deprecated.\n\nTo explicitly convert the string form of an object, use\nsympify(str(obj)). To add define sympify behavior on custom\nobjects, use sympy.core.sympify.converter or define obj._sympy_\n(see the sympify() docstring).\n\nsympify() performed the string fallback resulting in the following string:\n\n{a!r}\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.tensor.tensor._IndexStructure.from_indices

def from_indices(*indices):
    free, dum = _IndexStructure._free_dum_from_indices(*indices)
    index_types = [i.tensor_index_type for i in indices]
    indices = _IndexStructure._replace_dummy_names(indices, free, dum)
    return _IndexStructure(free, dum, index_types, indices)

.sympy.tensor.tensor._IndexStructure._free_dum_from_indices

def _free_dum_from_indices(*indices):
    n = len(indices)
    if n == 1:
        return ([(indices[0], 0)], [])
    free = [True] * len(indices)
    index_dict = {}
    dum = []
    for i, index in enumerate(indices):
        name = index.name
        typ = index.tensor_index_type
        contr = index.is_up
        if (name, typ) in index_dict:
            is_contr, pos = index_dict[name, typ]
            if is_contr:
                if contr:
                    raise ValueError('two equal contravariant indices in slots %d and %d' % (pos, i))
                else:
                    free[pos] = False
                    free[i] = False
            elif contr:
                free[pos] = False
                free[i] = False
            else:
                raise ValueError('two equal covariant indices in slots %d and %d' % (pos, i))
            if contr:
                dum.append((i, pos))
            else:
                dum.append((pos, i))
        else:
            index_dict[name, typ] = (index.is_up, i)
    free = [(index, i) for i, index in enumerate(indices) if free[i]]
    free.sort()
    return (free, dum)

.sympy.tensor.tensor.TensorIndex.tensor_index_type

def tensor_index_type(self):
    return self.args[1]

.sympy.tensor.tensor._IndexStructure._replace_dummy_names

def _replace_dummy_names(indices, free, dum):
    dum.sort(key=lambda x: x[0])
    new_indices = [ind for ind in indices]
    assert len(indices) == len(free) + 2 * len(dum)
    generate_dummy_name = _IndexStructure._get_generator_for_dummy_indices(free)
    for ipos1, ipos2 in dum:
        typ1 = new_indices[ipos1].tensor_index_type
        indname = generate_dummy_name(typ1)
        new_indices[ipos1] = TensorIndex(indname, typ1, True)
        new_indices[ipos2] = TensorIndex(indname, typ1, False)
    return new_indices

.sympy.tensor.tensor._IndexStructure._get_generator_for_dummy_indices

def _get_generator_for_dummy_indices(free):
    cdt = defaultdict(int)
    for indx, ipos in free:
        if indx.name.split('_')[0] == indx.tensor_index_type.dummy_name:
            cdt[indx.tensor_index_type] = max(cdt[indx.tensor_index_type], int(indx.name.split('_')[1]) + 1)

    def dummy_name_gen(tensor_index_type):
        nd = str(cdt[tensor_index_type])
        cdt[tensor_index_type] += 1
        return tensor_index_type.dummy_name + '_' + nd
    return dummy_name_gen

.sympy.tensor.tensor.TensorIndex.name

def name(self):
    return self.args[0].name

.sympy.tensor.tensor.TensorIndexType.dummy_name

def dummy_name(self):
    return self.args[1].name

.sympy.tensor.tensor._IndexStructure.__init__

def __init__(self, free, dum, index_types, indices, canon_bp=False):
    self.free = free
    self.dum = dum
    self.index_types = index_types
    self.indices = indices
    self._ext_rank = len(self.free) + 2 * len(self.dum)
    self.dum.sort(key=lambda x: x[0])

.sympy.tensor.tensor.TensorHead.rank

def rank(self):
    return len(self.index_types)

.sympy.tensor.tensor.Tensor._build_index_map

def _build_index_map(indices, index_structure):
    index_map = {}
    for idx in indices:
        index_map[idx] = (indices.index(idx),)
    return index_map

.sympy.core.basic.Basic.__hash__

def __hash__(self) -> int:
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.tensor.tensor.Tensor.doit

def doit(self, **hints):
    args, indices, free, dum = TensMul._tensMul_contract_indices([self])
    return args[0]

.sympy.tensor.tensor.TensMul._tensMul_contract_indices

def _tensMul_contract_indices(args, replace_indices=True):
    replacements = [{} for _ in args]
    args_indices = [get_indices(arg) for arg in args]
    indices, free, free_names, dummy_data = TensMul._indices_to_free_dum(args_indices)
    cdt = defaultdict(int)

    def dummy_name_gen(tensor_index_type):
        nd = str(cdt[tensor_index_type])
        cdt[tensor_index_type] += 1
        return tensor_index_type.dummy_name + '_' + nd
    if replace_indices:
        for old_index, pos1cov, pos1contra, pos2cov, pos2contra in dummy_data:
            index_type = old_index.tensor_index_type
            while True:
                dummy_name = dummy_name_gen(index_type)
                if dummy_name not in free_names:
                    break
            dummy = TensorIndex(dummy_name, index_type, True)
            replacements[pos1cov][old_index] = dummy
            replacements[pos1contra][-old_index] = -dummy
            indices[pos2cov] = dummy
            indices[pos2contra] = -dummy
        args = [arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg, repl in zip(args, replacements)]
    dum = TensMul._dummy_data_to_dum(dummy_data)
    return (args, indices, free, dum)

.sympy.tensor.tensor.get_indices

def get_indices(t):
    if not isinstance(t, TensExpr):
        return ()
    return t.get_indices()

.sympy.tensor.tensor.Tensor.get_indices

def get_indices(self):
    return list(self.args[1])

.sympy.tensor.tensor.TensMul._indices_to_free_dum

def _indices_to_free_dum(args_indices):
    free2pos1 = {}
    free2pos2 = {}
    dummy_data = []
    indices = []
    pos2 = 0
    for pos1, arg_indices in enumerate(args_indices):
        for index_pos, index in enumerate(arg_indices):
            if not isinstance(index, TensorIndex):
                raise TypeError('expected TensorIndex')
            if -index in free2pos1:
                other_pos1 = free2pos1.pop(-index)
                other_pos2 = free2pos2.pop(-index)
                if index.is_up:
                    dummy_data.append((index, pos1, other_pos1, pos2, other_pos2))
                else:
                    dummy_data.append((-index, other_pos1, pos1, other_pos2, pos2))
                indices.append(index)
            elif index in free2pos1:
                raise ValueError('Repeated index: %s' % index)
            else:
                free2pos1[index] = pos1
                free2pos2[index] = pos2
                indices.append(index)
            pos2 += 1
    free = [(i, p) for i, p in free2pos2.items()]
    free_names = [i.name for i in free2pos2.keys()]
    dummy_data.sort(key=lambda x: x[3])
    return (indices, free, free_names, dummy_data)

.sympy.tensor.tensor.TensorIndex.__neg__

def __neg__(self):
    t1 = TensorIndex(self.name, self.tensor_index_type, not self.is_up)
    return t1

.sympy.tensor.tensor.TensorIndex.is_up

def is_up(self):
    return self.args[2]

.sympy.logic.boolalg.BooleanTrue.__bool__

def __bool__(self):
    return True

.sympy.tensor.tensor.TensorIndex.__new__

def __new__(cls, name, tensor_index_type, is_up=True):
    if isinstance(name, str):
        name_symbol = Symbol(name)
    elif isinstance(name, Symbol):
        name_symbol = name
    elif name is True:
        name = '_i{}'.format(len(tensor_index_type._autogenerated))
        name_symbol = Symbol(name)
        tensor_index_type._autogenerated.append(name_symbol)
    else:
        raise ValueError('invalid name')
    is_up = sympify(is_up)
    return Basic.__new__(cls, name_symbol, tensor_index_type, is_up)

.sympy.core.symbol.Symbol.__new__

def __new__(cls, name, **assumptions):
    cls._sanitize(assumptions, cls)
    return Symbol.__xnew_cached_(cls, name, **assumptions)

.sympy.core.symbol.Symbol._sanitize

def _sanitize(assumptions, obj=None):
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    if is_commutative is None:
        whose = '%s ' % obj.__name__ if obj else ''
        raise ValueError('%scommutativity must be True or False.' % whose)
    for key in list(assumptions.keys()):
        v = assumptions[key]
        if v is None:
            assumptions.pop(key)
            continue
        assumptions[key] = bool(v)

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.symbol.Symbol.__xnew_cached_

def __xnew_cached_(cls, name, **assumptions):
    return Symbol.__xnew__(cls, name, **assumptions)

.sympy.core.symbol.Symbol.__xnew__

def __xnew__(cls, name, **assumptions):
    if not isinstance(name, str):
        raise TypeError('name should be a string, not %s' % repr(type(name)))
    obj = Expr.__new__(cls)
    obj.name = name
    tmp_asm_copy = assumptions.copy()
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    assumptions['commutative'] = is_commutative
    obj._assumptions = StdFactKB(assumptions)
    obj._assumptions._generator = tmp_asm_copy
    return obj

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    super().__init__(_assume_rules)
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.facts.FactKB.__init__

def __init__(self, rules):
    self.rules = rules

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.basic.Basic._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return {key: value for key, value in self._assumptions.items() if value is not None}

.sympy.logic.boolalg.BooleanFalse.__hash__

def __hash__(self):
    return hash(False)

.sympy.tensor.tensor.Tensor._replace_indices

def _replace_indices(self, repl):
    return self.xreplace(repl)

.sympy.core.basic.Basic.xreplace

def xreplace(self, rule):
    value, _ = self._xreplace(rule)
    return value

.sympy.core.basic.Basic._xreplace

def _xreplace(self, rule):
    if self in rule:
        return (rule[self], True)
    elif rule:
        args = []
        changed = False
        for a in self.args:
            _xreplace = getattr(a, '_xreplace', None)
            if _xreplace is not None:
                a_xr = _xreplace(rule)
                args.append(a_xr[0])
                changed |= a_xr[1]
            else:
                args.append(a)
        args = tuple(args)
        if changed:
            return (self.func(*args), True)
    return (self, False)

.sympy.core.expr.Expr._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.containers.Tuple.__hash__

def __hash__(self):
    return hash(self.args)

.sympy.tensor.tensor.TensMul._dummy_data_to_dum

def _dummy_data_to_dum(dummy_data):
    return [(p2a, p2b) for i, p1a, p1b, p2a, p2b in dummy_data]

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.numbers.Rational.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))
        elif isinstance(other, Float):
            return other * self
        else:
            return Number.__mul__(self, other)
    return Number.__mul__(self, other)

.sympy.core.numbers.Number.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_parameters.evaluate:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.Infinity
            else:
                return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.NegativeInfinity
            else:
                return S.Infinity
    elif isinstance(other, Tuple):
        return NotImplemented
    return AtomicExpr.__mul__(self, other)

.sympy.core.decorators._SympifyWrapper._func

def _func(self, other):
    if not hasattr(other, '_op_priority'):
        try:
            other = sympify(other, strict=True)
        except SympifyError:
            return retval
    if not isinstance(other, expectedcls):
        return retval
    return func(self, other)

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            f = getattr(other, method_name, None)
            if f is not None:
                return f(self)
    return func(self, other)

.sympy.tensor.tensor.TensExpr.__rmul__

def __rmul__(self, other):
    return TensMul(other, self).doit()

.sympy.tensor.tensor.TensMul.__new__

def __new__(cls, *args, **kw_args):
    is_canon_bp = kw_args.get('is_canon_bp', False)
    args = list(map(_sympify, args))
    args = [i for arg in args for i in (arg.args if isinstance(arg, (TensMul, Mul)) else [arg])]
    args, indices, free, dum = TensMul._tensMul_contract_indices(args, replace_indices=False)
    index_types = [i.tensor_index_type for i in indices]
    index_structure = _IndexStructure(free, dum, index_types, indices, canon_bp=is_canon_bp)
    obj = TensExpr.__new__(cls, *args)
    obj._indices = indices
    obj._index_types = index_types[:]
    obj._index_structure = index_structure
    obj._free = index_structure.free[:]
    obj._dum = index_structure.dum[:]
    obj._free_indices = {x[0] for x in obj.free}
    obj._rank = len(obj.free)
    obj._ext_rank = len(obj._index_structure.free) + 2 * len(obj._index_structure.dum)
    obj._coeff = S.One
    obj._is_canon_bp = is_canon_bp
    return obj

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.tensor.tensor.TensMul.doit

def doit(self, **hints):
    is_canon_bp = self._is_canon_bp
    deep = hints.get('deep', True)
    if deep:
        args = [arg.doit(**hints) for arg in self.args]
    else:
        args = self.args
    args = [arg for arg in args if arg != self.identity]
    coeff = reduce(lambda a, b: a * b, [arg for arg in args if not isinstance(arg, TensExpr)], S.One)
    args = [arg for arg in args if isinstance(arg, TensExpr)]
    if len(args) == 0:
        return coeff
    if coeff != self.identity:
        args = [coeff] + args
    if coeff == 0:
        return S.Zero
    if len(args) == 1:
        return args[0]
    args, indices, free, dum = TensMul._tensMul_contract_indices(args)
    index_types = [i.tensor_index_type for i in indices]
    index_structure = _IndexStructure(free, dum, index_types, indices, canon_bp=is_canon_bp)
    obj = self.func(*args)
    obj._index_types = index_types
    obj._index_structure = index_structure
    obj._ext_rank = len(obj._index_structure.free) + 2 * len(obj._index_structure.dum)
    obj._coeff = coeff
    obj._is_canon_bp = is_canon_bp
    return obj

.sympy.core.basic.Atom.doit

def doit(self, **hints):
    return self

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, int):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.tensor.tensor.TensExpr.__mul__

def __mul__(self, other):
    return TensMul(self, other).doit()

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.core.numbers.Rational.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p + self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return other + self
        else:
            return Number.__add__(self, other)
    return Number.__add__(self, other)

.sympy.core.numbers.Number.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_parameters.evaluate:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            return S.Infinity
        elif other is S.NegativeInfinity:
            return S.NegativeInfinity
    return AtomicExpr.__add__(self, other)

.sympy.tensor.tensor.TensExpr.__radd__

def __radd__(self, other):
    return TensAdd(other, self).doit()

.sympy.tensor.tensor.TensAdd.__new__

def __new__(cls, *args, **kw_args):
    args = [_sympify(x) for x in args if x]
    args = TensAdd._tensAdd_flatten(args)
    args.sort(key=default_sort_key)
    if not args:
        return S.Zero
    if len(args) == 1:
        return args[0]
    return Basic.__new__(cls, *args, **kw_args)

.sympy.core.numbers.Zero.__bool__

def __bool__(self):
    return False

.sympy.tensor.tensor.TensAdd._tensAdd_flatten

def _tensAdd_flatten(args):
    a = []
    for x in args:
        if isinstance(x, (Add, TensAdd)):
            a.extend(list(x.args))
        else:
            a.append(x)
    args = [x for x in a if x.coeff]
    return args

.sympy.tensor.tensor.TensMul.coeff

def coeff(self):
    return self._coeff

.sympy.core.sorting.default_sort_key

def default_sort_key(item, order=None):
    from .basic import Basic
    from .singleton import S
    if isinstance(item, Basic):
        return item.sort_key(order=order)
    if iterable(item, exclude=str):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            args = list(item)
            unordered = False
        args = [default_sort_key(arg, order=order) for arg in args]
        if unordered:
            args = sorted(args)
        cls_index, args = (10, (len(args), tuple(args)))
    else:
        if not isinstance(item, str):
            try:
                item = sympify(item, strict=True)
            except SympifyError:
                pass
            else:
                if isinstance(item, Basic):
                    return default_sort_key(item)
        cls_index, args = (0, (1, (str(item),)))
    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)

.sympy.core.expr.Expr.sort_key

def sort_key(self, order=None):
    coeff, expr = self.as_coeff_Mul()
    if expr.is_Pow:
        if expr.base is S.Exp1:
            expr, exp = (Function('exp')(expr.exp), S.One)
        else:
            expr, exp = expr.args
    else:
        exp = S.One
    if expr.is_Dummy:
        args = (expr.sort_key(),)
    elif expr.is_Atom:
        args = (str(expr),)
    else:
        if expr.is_Add:
            args = expr.as_ordered_terms(order=order)
        elif expr.is_Mul:
            args = expr.as_ordered_factors(order=order)
        else:
            args = expr.args
        args = tuple([default_sort_key(arg, order=order) for arg in args])
    args = (len(args), tuple(args))
    exp = exp.sort_key(order=order)
    return (expr.class_key(), args, exp, coeff)

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational: bool=False) -> tuple['Number', Expr]:
    return (S.One, self)

.sympy.core.basic.Basic.sort_key

def sort_key(self, order=None):

    def inner_key(arg):
        if isinstance(arg, Basic):
            return arg.sort_key(order)
        else:
            return arg
    args = self._sorted_args
    args = (len(args), tuple([inner_key(arg) for arg in args]))
    return (self.class_key(), args, S.One.sort_key(), S.One)

.sympy.core.basic.Basic._sorted_args

def _sorted_args(self):
    return self.args

.sympy.core.basic.Basic.inner_key

def inner_key(arg):
    if isinstance(arg, Basic):
        return arg.sort_key(order)
    else:
        return arg

.sympy.core.symbol.Symbol.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)

.sympy.core.basic.Atom.class_key

def class_key(cls):
    return (2, 0, cls.__name__)

.sympy.core.numbers.Number.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (0, ()), (), self)

.sympy.core.numbers.Number.class_key

def class_key(cls):
    return (1, 0, 'Number')

.sympy.core.basic.Basic.class_key

def class_key(cls):
    return (5, 0, cls.__name__)

.sympy.core.basic.Atom.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)

.sympy.core._print_helpers.Printable.__str__

def __str__(self):
    from sympy.printing.str import sstr
    return sstr(self, order=None)

.sympy.printing.printer._PrintFunction.__call__

def __call__(self, *args, **kwargs):
    return self.__wrapped__(*args, **kwargs)

.sympy.printing.str.sstr

def sstr(expr, **settings):
    p = StrPrinter(settings)
    s = p.doprint(expr)
    return s

.sympy.printing.printer.Printer.__init__

def __init__(self, settings=None):
    self._str = str
    self._settings = self._get_initial_settings()
    self._context = {}
    if settings is not None:
        self._settings.update(settings)
        if len(self._settings) > len(self._default_settings):
            for key in self._settings:
                if key not in self._default_settings:
                    raise TypeError("Unknown setting '%s'." % key)
    self._print_level = 0

.sympy.printing.printer.Printer._get_initial_settings

def _get_initial_settings(cls):
    settings = cls._default_settings.copy()
    for key, val in cls._global_settings.items():
        if key in cls._default_settings:
            settings[key] = val
    return settings

.sympy.printing.printer.Printer.doprint

def doprint(self, expr):
    return self._str(self._print(expr))

.sympy.printing.printer.Printer._print

def _print(self, expr, **kwargs) -> str:
    self._print_level += 1
    try:
        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):
            return getattr(expr, self.printmethod)(self, **kwargs)
        classes = type(expr).__mro__
        if AppliedUndef in classes:
            classes = classes[classes.index(AppliedUndef):]
        if UndefinedFunction in classes:
            classes = classes[classes.index(UndefinedFunction):]
        if Function in classes:
            i = classes.index(Function)
            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]
        for cls in classes:
            printmethodname = '_print_' + cls.__name__
            printmethod = getattr(self, printmethodname, None)
            if printmethod is not None:
                return printmethod(expr, **kwargs)
        return self.emptyPrinter(expr)
    finally:
        self._print_level -= 1

.sympy.printing.str.StrPrinter._print_Permutation

def _print_Permutation(self, expr):
    from sympy.combinatorics.permutations import Permutation, Cycle
    from sympy.utilities.exceptions import sympy_deprecation_warning
    perm_cyclic = Permutation.print_cyclic
    if perm_cyclic is not None:
        sympy_deprecation_warning(f'\n            Setting Permutation.print_cyclic is deprecated. Instead use\n            init_printing(perm_cyclic={perm_cyclic}).\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-permutation-print_cyclic', stacklevel=7)
    else:
        perm_cyclic = self._settings.get('perm_cyclic', True)
    if perm_cyclic:
        if not expr.size:
            return '()'
        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]
        last = s.rfind('(')
        if not last == 0 and ',' not in s[last:]:
            s = s[last:] + s[:last]
        s = s.replace(',', '')
        return s
    else:
        s = expr.support()
        if not s:
            if expr.size < 5:
                return 'Permutation(%s)' % self._print(expr.array_form)
            return 'Permutation([], size=%s)' % self._print(expr.size)
        trim = self._print(expr.array_form[:s[-1] + 1]) + ', size=%s' % self._print(expr.size)
        use = full = self._print(expr.array_form)
        if len(trim) < len(full):
            use = trim
        return 'Permutation(%s)' % use

.sympy.combinatorics.permutations.Permutation.size

def size(self):
    return self._size

.sympy.combinatorics.permutations.Cycle.__init__

def __init__(self, *args):
    if not args:
        return
    if len(args) == 1:
        if isinstance(args[0], Permutation):
            for c in args[0].cyclic_form:
                self.update(self(*c))
            return
        elif isinstance(args[0], Cycle):
            for k, v in args[0].items():
                self[k] = v
            return
    args = [as_int(a) for a in args]
    if any((i < 0 for i in args)):
        raise ValueError('negative integers are not allowed in a cycle.')
    if has_dups(args):
        raise ValueError('All elements must be unique in a cycle.')
    for i in range(-len(args), 0):
        self[args[i]] = args[i + 1]

.sympy.combinatorics.permutations.Permutation.cyclic_form

def cyclic_form(self):
    if self._cyclic_form is not None:
        return list(self._cyclic_form)
    array_form = self.array_form
    unchecked = [True] * len(array_form)
    cyclic_form = []
    for i in range(len(array_form)):
        if unchecked[i]:
            cycle = []
            cycle.append(i)
            unchecked[i] = False
            j = i
            while unchecked[array_form[j]]:
                j = array_form[j]
                cycle.append(j)
                unchecked[j] = False
            if len(cycle) > 1:
                cyclic_form.append(cycle)
                assert cycle == list(minlex(cycle))
    cyclic_form.sort()
    self._cyclic_form = cyclic_form[:]
    return cyclic_form

.sympy.combinatorics.permutations.Permutation.array_form

def array_form(self):
    return self._array_form[:]

.sympy.combinatorics.permutations.Cycle.__call__

def __call__(self, *other):
    rv = Cycle(*other)
    for k, v in zip(list(self.keys()), [rv[self[k]] for k in self.keys()]):
        rv[k] = v
    return rv

.sympy.utilities.misc.as_int

def as_int(n, strict=True):
    if strict:
        try:
            if isinstance(n, bool):
                raise TypeError
            return operator.index(n)
        except TypeError:
            raise ValueError('%s is not an integer' % (n,))
    else:
        try:
            result = int(n)
        except TypeError:
            raise ValueError('%s is not an integer' % (n,))
        if n != result:
            raise ValueError('%s is not an integer' % (n,))
        return result

.sympy.utilities.iterables.has_dups

def has_dups(seq):
    from sympy.core.containers import Dict
    from sympy.sets.sets import Set
    if isinstance(seq, (dict, set, Dict, Set)):
        return False
    unique = set()
    try:
        return any((True for s in seq if s in unique or unique.add(s)))
    except TypeError:
        return len(seq) != len(list(uniq(seq)))

.sympy.combinatorics.permutations.Cycle.__repr__

def __repr__(self):
    if not self:
        return 'Cycle()'
    cycles = Permutation(self).cyclic_form
    s = ''.join((str(tuple(c)) for c in cycles))
    big = self.size - 1
    if not any((i == big for c in cycles for i in c)):
        s += '(%s)' % big
    return 'Cycle%s' % s

.sympy.combinatorics.permutations.Permutation.__new__

def __new__(cls, *args, size=None, **kwargs):
    if size is not None:
        size = int(size)
    ok = True
    if not args:
        return cls._af_new(list(range(size or 0)))
    elif len(args) > 1:
        return cls._af_new(Cycle(*args).list(size))
    if len(args) == 1:
        a = args[0]
        if isinstance(a, cls):
            if size is None or size == a.size:
                return a
            return cls(a.array_form, size=size)
        if isinstance(a, Cycle):
            return cls._af_new(a.list(size))
        if not is_sequence(a):
            if size is not None and a + 1 > size:
                raise ValueError('size is too small when max is %s' % a)
            return cls._af_new(list(range(a + 1)))
        if has_variety((is_sequence(ai) for ai in a)):
            ok = False
    else:
        ok = False
    if not ok:
        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')
    args = list(args[0])
    is_cycle = args and is_sequence(args[0])
    if is_cycle:
        args = [[int(i) for i in c] for c in args]
    else:
        args = [int(i) for i in args]
    temp = flatten(args)
    if has_dups(temp) and (not is_cycle):
        raise ValueError('there were repeated elements.')
    temp = set(temp)
    if not is_cycle:
        if temp != set(range(len(temp))):
            raise ValueError('Integers 0 through %s must be present.' % max(temp))
        if size is not None and temp and (max(temp) + 1 > size):
            raise ValueError('max element should not exceed %s' % (size - 1))
    if is_cycle:
        c = Cycle()
        for ci in args:
            c = c(*ci)
        aform = c.list()
    else:
        aform = list(args)
    if size and size > len(aform):
        aform.extend(list(range(len(aform), size)))
    return cls._af_new(aform)

.sympy.combinatorics.permutations.Cycle.list

def list(self, size=None):
    if not self and size is None:
        raise ValueError('must give size for empty Cycle')
    if size is not None:
        big = max([i for i in self.keys() if self[i] != i] + [0])
        size = max(size, big + 1)
    else:
        size = self.size
    return [self[i] for i in range(size)]

.sympy.combinatorics.permutations.Cycle.size

def size(self):
    if not self:
        return 0
    return max(self.keys()) + 1

.sympy.combinatorics.permutations.Cycle.__missing__

def __missing__(self, arg):
    return as_int(arg)

.sympy.combinatorics.permutations.Permutation._af_new

def _af_new(cls, perm):
    p = super().__new__(cls)
    p._array_form = perm
    p._size = len(perm)
    return p

.sympy.tensor.tensor.TensExpr.__add__

def __add__(self, other):
    return TensAdd(self, other).doit()

.sympy.tensor.tensor.TensAdd.doit

def doit(self, **hints):
    deep = hints.get('deep', True)
    if deep:
        args = [arg.doit(**hints) for arg in self.args]
    else:
        args = self.args
    if not args:
        return S.Zero
    if len(args) == 1 and (not isinstance(args[0], TensExpr)):
        return args[0]
    TensAdd._tensAdd_check(args)
    if len(args) == 1:
        return args[0]
    args = [x for x in args if x]
    if not args:
        return S.Zero
    if len(args) == 1:
        return args[0]
    args = TensAdd._tensAdd_collect_terms(args)

    def sort_key(t):
        if not isinstance(t, TensExpr):
            return ([], [], [])
        if hasattr(t, '_index_structure') and hasattr(t, 'components'):
            x = get_index_structure(t)
            return (t.components, x.free, x.dum)
        return ([], [], [])
    args.sort(key=sort_key)
    if not args:
        return S.Zero
    if len(args) == 1:
        return args[0]
    obj = self.func(*args)
    return obj

.sympy.tensor.tensor.TensAdd._tensAdd_check

def _tensAdd_check(args):

    def get_indices_set(x):
        if isinstance(x, TensExpr):
            return set(x.get_free_indices())
        return set()
    indices0 = get_indices_set(args[0])
    list_indices = [get_indices_set(arg) for arg in args[1:]]
    if not all((x == indices0 for x in list_indices)):
        raise ValueError('all tensors must have the same indices')

.sympy.tensor.tensor.TensAdd.get_indices_set

def get_indices_set(x):
    if isinstance(x, TensExpr):
        return set(x.get_free_indices())
    return set()

.sympy.tensor.tensor.TensMul.get_free_indices

def get_free_indices(self):
    return self._index_structure.get_free_indices()

.sympy.tensor.tensor._IndexStructure.get_free_indices

def get_free_indices(self):
    free = sorted(self.free, key=lambda x: x[1])
    return [i[0] for i in free]

.sympy.tensor.tensor.TensAdd._tensAdd_collect_terms

def _tensAdd_collect_terms(args):
    terms_dict = defaultdict(list)
    scalars = S.Zero
    if isinstance(args[0], TensExpr):
        free_indices = set(args[0].get_free_indices())
    else:
        free_indices = set()
    for arg in args:
        if not isinstance(arg, TensExpr):
            if free_indices != set():
                raise ValueError('wrong valence')
            scalars += arg
            continue
        if free_indices != set(arg.get_free_indices()):
            raise ValueError('wrong valence')
        terms_dict[arg.nocoeff].append(arg.coeff)
    new_args = [TensMul(Add(*coeff), t).doit() for t, coeff in terms_dict.items() if Add(*coeff) != 0]
    if isinstance(scalars, Add):
        new_args = list(scalars.args) + new_args
    elif scalars != 0:
        new_args = [scalars] + new_args
    return new_args

.sympy.tensor.tensor.TensMul.nocoeff

def nocoeff(self):
    return self.func(*[t for t in self.args if isinstance(t, TensExpr)]).doit()

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, evaluate=None, _sympify=True):
    if _sympify:
        args = list(map(_sympify_, args))
    typ = cls._args_type
    if typ is not None:
        from .relational import Relational
        if any((isinstance(arg, Relational) for arg in args)):
            raise TypeError('Relational cannot be used in %s' % cls.__name__)
        for arg in args:
            if not isinstance(arg, typ):
                sympy_deprecation_warning(f'\n\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\nthe arguments has type {type(arg).__name__!r}).\n\nIf you really did intend to use a multiplication or addition operation with\nthis object, use the * or + operator instead.\n\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if not evaluate:
        obj = cls._from_args(args)
        obj = cls._exec_constructor_postprocessors(obj)
        return obj
    args = [a for a in args if a is not cls.identity]
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        from sympy.series.order import Order
        return Order(obj, *order_symbols)
    return obj

.sympy.tensor.tensor.TensAdd.sort_key

def sort_key(t):
    if not isinstance(t, TensExpr):
        return ([], [], [])
    if hasattr(t, '_index_structure') and hasattr(t, 'components'):
        x = get_index_structure(t)
        return (t.components, x.free, x.dum)
    return ([], [], [])

.sympy.tensor.tensor.TensMul.components

def components(self):
    return self._get_components_from_args(self.args)

.sympy.tensor.tensor.TensMul._get_components_from_args

def _get_components_from_args(args):
    components = []
    for arg in args:
        if not isinstance(arg, TensExpr):
            continue
        if isinstance(arg, TensAdd):
            continue
        components.extend(arg.components)
    return components

.sympy.tensor.tensor.Tensor.components

def components(self):
    return self._components

.sympy.tensor.tensor.get_index_structure

def get_index_structure(t):
    if isinstance(t, TensExpr):
        return t._index_structure
    return _IndexStructure([], [], [], [])

.sympy.tensor.tensor.TensorIndex.__lt__

def __lt__(self, other):
    return (self.tensor_index_type, self.name) < (other.tensor_index_type, other.name)

.sympy.tensor.tensor.TensAdd.get_indices

def get_indices(self):
    indices = []
    for arg in self.args:
        indices.extend([i for i in get_indices(arg) if i not in indices])
    return indices

.sympy.tensor.tensor.TensMul.get_indices

def get_indices(self):
    return self._indices

.sympy.tensor.tensor.TensAdd._replace_indices

def _replace_indices(self, repl):
    newargs = [arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg in self.args]
    return self.func(*newargs)

.sympy.tensor.tensor.TensMul._replace_indices

def _replace_indices(self, repl):
    return self.func(*[arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg in self.args])

.sympy.matrices.dense.eye

def eye(*args, **kwargs):
    return Matrix.eye(*args, **kwargs)

.sympy.matrices.common.MatrixSpecial.eye

def eye(kls, rows, cols=None, **kwargs):
    if cols is None:
        cols = rows
    if rows < 0 or cols < 0:
        raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))
    klass = kwargs.get('cls', kls)
    rows, cols = (as_int(rows), as_int(cols))
    return klass._eval_eye(rows, cols)

.sympy.matrices.repmatrix.RepMatrix._eval_eye

def _eval_eye(cls, rows, cols):
    rep = DomainMatrix.eye((rows, cols), ZZ)
    return cls._fromrep(rep)

.sympy.polys.matrices.domainmatrix.DomainMatrix.eye

def eye(cls, shape, domain):
    if isinstance(shape, int):
        shape = (shape, shape)
    return cls.from_rep(SDM.eye(shape, domain))

.sympy.polys.matrices.sdm.SDM.eye

def eye(cls, shape, domain):
    rows, cols = shape
    one = domain.one
    sdm = {i: {i: one} for i in range(min(rows, cols))}
    return cls(sdm, shape, domain)

.sympy.polys.matrices.sdm.SDM.__init__

def __init__(self, elemsdict, shape, domain):
    super().__init__(elemsdict)
    self.shape = self.rows, self.cols = m, n = shape
    self.domain = domain
    if not all((0 <= r < m for r in self)):
        raise DMBadInputError('Row out of range')
    if not all((0 <= c < n for row in self.values() for c in row)):
        raise DMBadInputError('Column out of range')

.sympy.polys.matrices.domainmatrix.DomainMatrix.from_rep

def from_rep(cls, rep):
    if not isinstance(rep, (DDM, SDM)):
        raise TypeError('rep should be of type DDM or SDM')
    self = super().__new__(cls)
    self.rep = rep
    self.shape = rep.shape
    self.domain = rep.domain
    return self

.sympy.matrices.repmatrix.MutableRepMatrix._fromrep

def _fromrep(cls, rep):
    obj = super().__new__(cls)
    obj.rows, obj.cols = rep.shape
    obj._rep = rep
    return obj

.sympy.matrices.common.MatrixArithmetic.__mul__

def __mul__(self, other):
    return self.multiply(other)

.sympy.matrices.common.MatrixArithmetic.multiply

def multiply(self, other, dotprodsimp=None):
    isimpbool = _get_intermediate_simp_bool(False, dotprodsimp)
    other = _matrixify(other)
    if hasattr(other, 'shape') and len(other.shape) == 2 and (getattr(other, 'is_Matrix', True) or getattr(other, 'is_MatrixLike', True)):
        if self.shape[1] != other.shape[0]:
            raise ShapeError('Matrix size mismatch: %s * %s.' % (self.shape, other.shape))
    if getattr(other, 'is_Matrix', False):
        m = self._eval_matrix_mul(other)
        if isimpbool:
            return m._new(m.rows, m.cols, [_dotprodsimp(e) for e in m])
        return m
    if getattr(other, 'is_MatrixLike', False):
        return MatrixArithmetic._eval_matrix_mul(self, other)
    if not isinstance(other, Iterable):
        try:
            return self._eval_scalar_mul(other)
        except TypeError:
            pass
    return NotImplemented

.sympy.matrices.utilities._get_intermediate_simp_bool

def _get_intermediate_simp_bool(default=False, dotprodsimp=None):
    return _get_intermediate_simp(default, False, True, dotprodsimp)

.sympy.matrices.utilities._get_intermediate_simp

def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x, onfunc=_dotprodsimp, dotprodsimp=None):
    if dotprodsimp is False or _dotprodsimp_state.state is False:
        return offfunc
    if dotprodsimp is True or _dotprodsimp_state.state is True:
        return onfunc
    return deffunc

.sympy.matrices.common._matrixify

def _matrixify(mat):
    if getattr(mat, 'is_Matrix', False) or getattr(mat, 'is_MatrixLike', False):
        return mat
    if not (getattr(mat, 'is_Matrix', True) or getattr(mat, 'is_MatrixLike', True)):
        return mat
    shape = None
    if hasattr(mat, 'shape'):
        if len(mat.shape) == 2:
            shape = mat.shape
    elif hasattr(mat, 'rows') and hasattr(mat, 'cols'):
        shape = (mat.rows, mat.cols)
    if shape:
        return _MatrixWrapper(mat, shape)
    return mat

.sympy.matrices.repmatrix.RepMatrix._eval_scalar_mul

def _eval_scalar_mul(self, other):
    rep, other = self._unify_element_sympy(self._rep, other)
    return self._fromrep(rep.scalarmul(other))

.sympy.matrices.repmatrix.RepMatrix._unify_element_sympy

def _unify_element_sympy(cls, rep, element):
    domain = rep.domain
    element = _sympify(element)
    if domain != EXRAW:
        if element.is_Integer:
            new_domain = domain
        elif element.is_Rational:
            new_domain = QQ
        else:
            new_domain = EXRAW
        if new_domain != domain:
            rep = rep.convert_to(new_domain)
            domain = new_domain
        if domain != EXRAW:
            element = new_domain.from_sympy(element)
    if domain == EXRAW and (not isinstance(element, Expr)):
        sympy_deprecation_warning('\n            non-Expr objects in a Matrix is deprecated. Matrix represents\n            a mathematical matrix. To represent a container of non-numeric\n            entities, Use a list of lists, TableForm, NumPy array, or some\n            other data structure instead.\n            ', deprecated_since_version='1.9', active_deprecations_target='deprecated-non-expr-in-matrix', stacklevel=4)
    return (rep, element)

.sympy.polys.domains.domain.Domain.__ne__

def __ne__(self, other):
    return not self == other

.sympy.polys.domains.domain.Domain.__eq__

def __eq__(self, other):
    return isinstance(other, Domain) and self.dtype == other.dtype

.sympy.polys.domains.integerring.IntegerRing.from_sympy

def from_sympy(self, a):
    if a.is_Integer:
        return MPZ(a.p)
    elif a.is_Float and int(a) == a:
        return MPZ(int(a))
    else:
        raise CoercionFailed('expected an integer, got %s' % a)

.sympy.polys.matrices.domainmatrix.DomainMatrix.scalarmul

def scalarmul(A, lamda):
    return A._scalarmul(lamda, reverse=False)

.sympy.polys.matrices.domainmatrix.DomainMatrix._scalarmul

def _scalarmul(A, lamda, reverse):
    if lamda == A.domain.zero:
        return DomainMatrix.zeros(A.shape, A.domain)
    elif lamda == A.domain.one:
        return A.copy()
    elif reverse:
        return A.rmul(lamda)
    else:
        return A.mul(lamda)

.sympy.polys.matrices.domainmatrix.DomainMatrix.mul

def mul(A, b):
    return A.from_rep(A.rep.mul(b))

.sympy.polys.matrices.sdm.SDM.mul

def mul(A, b):
    Csdm = unop_dict(A, lambda aij: aij * b)
    return A.new(Csdm, A.shape, A.domain)

.sympy.polys.matrices.sdm.unop_dict

def unop_dict(A, f):
    B = {}
    for i, Ai in A.items():
        Bi = {}
        for j, Aij in Ai.items():
            Bij = f(Aij)
            if Bij:
                Bi[j] = Bij
        if Bi:
            B[i] = Bi
    return B

.sympy.polys.matrices.sdm.SDM.new

def new(cls, sdm, shape, domain):
    return cls(sdm, shape, domain)

.sympy.tensor.tensor.Tensor.coeff

def coeff(self):
    return self._coeff


[/PYTHON]
What will be the input of `kahane_simplify`, given the following input:
[OUTPUT]
```
{
    "_indices": null,
    "_index_types": null,
    "_index_structure": {
        "free": null,
        "dum": null,
        "index_types": null,
        "indices": null,
        "_ext_rank": 2
    },
    "_free": null,
    "_dum": null,
    "_free_indices": "set()",
    "_rank": 2,
    "_ext_rank": 2,
    "_coeff": "1",
    "_is_canon_bp": false
}
```
[/OUTPUT]

[THOUGHT]
