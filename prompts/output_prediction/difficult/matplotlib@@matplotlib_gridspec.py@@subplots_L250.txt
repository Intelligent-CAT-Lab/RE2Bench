You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from numbers import Integral
import numpy as np
from matplotlib import _api, _pylab_helpers, _tight_layout

class GridSpecBase:

    def __init__(self, nrows, ncols, height_ratios=None, width_ratios=None):
        if not isinstance(nrows, Integral) or nrows <= 0:
            raise ValueError(f'Number of rows must be a positive integer, not {nrows!r}')
        if not isinstance(ncols, Integral) or ncols <= 0:
            raise ValueError(f'Number of columns must be a positive integer, not {ncols!r}')
        self._nrows, self._ncols = (nrows, ncols)
        self.set_height_ratios(height_ratios)
        self.set_width_ratios(width_ratios)
    nrows = property(lambda self: self._nrows, doc='The number of rows in the grid.')
    ncols = property(lambda self: self._ncols, doc='The number of columns in the grid.')

    def set_width_ratios(self, width_ratios):
        if width_ratios is None:
            width_ratios = [1] * self._ncols
        elif len(width_ratios) != self._ncols:
            raise ValueError('Expected the given number of width ratios to match the number of columns of the grid')
        self._col_width_ratios = width_ratios

    def set_height_ratios(self, height_ratios):
        if height_ratios is None:
            height_ratios = [1] * self._nrows
        elif len(height_ratios) != self._nrows:
            raise ValueError('Expected the given number of height ratios to match the number of rows of the grid')
        self._row_height_ratios = height_ratios

    def subplots(self, *, sharex=False, sharey=False, squeeze=True, subplot_kw=None):
        figure = self.figure
        if figure is None:
            raise ValueError('GridSpec.subplots() only works for GridSpecs created with a parent figure')
        if not isinstance(sharex, str):
            sharex = 'all' if sharex else 'none'
        if not isinstance(sharey, str):
            sharey = 'all' if sharey else 'none'
        _api.check_in_list(['all', 'row', 'col', 'none', False, True], sharex=sharex, sharey=sharey)
        if subplot_kw is None:
            subplot_kw = {}
        subplot_kw = subplot_kw.copy()
        axarr = np.empty((self._nrows, self._ncols), dtype=object)
        for row in range(self._nrows):
            for col in range(self._ncols):
                shared_with = {'none': None, 'all': axarr[0, 0], 'row': axarr[row, 0], 'col': axarr[0, col]}
                subplot_kw['sharex'] = shared_with[sharex]
                subplot_kw['sharey'] = shared_with[sharey]
                axarr[row, col] = figure.add_subplot(self[row, col], **subplot_kw)
        if sharex in ['col', 'all']:
            for ax in axarr.flat:
                ax._label_outer_xaxis(skip_non_rectangular_axes=True)
        if sharey in ['row', 'all']:
            for ax in axarr.flat:
                ax._label_outer_yaxis(skip_non_rectangular_axes=True)
        if squeeze:
            return axarr.item() if axarr.size == 1 else axarr.squeeze()
        else:
            return axarr
[/PYTHON]

Functions called during the execution:
[PYTHON]
matplotlib.lib.matplotlib._api.__init__.check_in_list

def check_in_list(values, /, *, _print_supported_values=True, **kwargs):
    """
    For each *key, value* pair in *kwargs*, check that *value* is in *values*;
    if not, raise an appropriate ValueError.

    Parameters
    ----------
    values : iterable
        Sequence of values to check on.

        Note: All values must support == comparisons.
        This means in particular the entries must not be numpy arrays.
    _print_supported_values : bool, default: True
        Whether to print *values* when raising ValueError.
    **kwargs : dict
        *key, value* pairs as keyword arguments to find in *values*.

    Raises
    ------
    ValueError
        If any *value* in *kwargs* is not found in *values*.

    Examples
    --------
    >>> _api.check_in_list(["foo", "bar"], arg=arg, other_arg=other_arg)
    """
    if not kwargs:
        raise TypeError("No argument to check!")
    for key, val in kwargs.items():
        try:
            exists = val in values
        except ValueError:
            # `in` internally uses `val == values[i]`. There are some objects
            # that do not support == to arbitrary other objects, in particular
            # numpy arrays.
            # Since such objects are not allowed in values, we can gracefully
            # handle the case that val (typically provided by users) is of such
            # type and directly state it's not in the list instead of letting
            # the individual `val == values[i]` ValueError surface.
            exists = False
        if not exists:
            msg = f"{val!r} is not a valid value for {key}"
            if _print_supported_values:
                msg += f"; supported values are {', '.join(map(repr, values))}"
            raise ValueError(msg)

matplotlib.lib.matplotlib.axes._base._label_outer_xaxis

def _label_outer_xaxis(self, *, skip_non_rectangular_axes,
                       remove_inner_ticks=False):
    # see documentation in label_outer.
    if skip_non_rectangular_axes and not isinstance(self.patch,
                                                    mpl.patches.Rectangle):
        return
    ss = self._get_subplotspec_with_optional_colorbar()
    if ss is None:
        return
    label_position = self.xaxis.get_label_position()
    if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
        if label_position == "top":
            self.set_xlabel("")
        top_kw = {'top': False} if remove_inner_ticks else {}
        self.xaxis.set_tick_params(
            which="both", labeltop=False, **top_kw)
        if self.xaxis.offsetText.get_position()[1] == 1:
            self.xaxis.offsetText.set_visible(False)
    if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
        if label_position == "bottom":
            self.set_xlabel("")
        bottom_kw = {'bottom': False} if remove_inner_ticks else {}
        self.xaxis.set_tick_params(
            which="both", labelbottom=False, **bottom_kw)
        if self.xaxis.offsetText.get_position()[1] == 0:
            self.xaxis.offsetText.set_visible(False)

matplotlib.lib.matplotlib.axes._base._label_outer_yaxis

def _label_outer_yaxis(self, *, skip_non_rectangular_axes,
                       remove_inner_ticks=False):
    # see documentation in label_outer.
    if skip_non_rectangular_axes and not isinstance(self.patch,
                                                    mpl.patches.Rectangle):
        return
    ss = self._get_subplotspec_with_optional_colorbar()
    if ss is None:
        return
    label_position = self.yaxis.get_label_position()
    if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
        if label_position == "left":
            self.set_ylabel("")
        left_kw = {'left': False} if remove_inner_ticks else {}
        self.yaxis.set_tick_params(
            which="both", labelleft=False, **left_kw)
        if self.yaxis.offsetText.get_position()[0] == 0:
            self.yaxis.offsetText.set_visible(False)
    if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
        if label_position == "right":
            self.set_ylabel("")
        right_kw = {'right': False} if remove_inner_ticks else {}
        self.yaxis.set_tick_params(
            which="both", labelright=False, **right_kw)
        if self.yaxis.offsetText.get_position()[0] == 1:
            self.yaxis.offsetText.set_visible(False)

matplotlib.lib.matplotlib.figure.add_subplot

    @_docstring.interpd
    def add_subplot(self, *args, **kwargs):
        """
        Add an `~.axes.Axes` to the figure as part of a subplot arrangement.

        Call signatures::

           add_subplot(nrows, ncols, index, **kwargs)
           add_subplot(pos, **kwargs)
           add_subplot(ax)
           add_subplot()

        Parameters
        ----------
        *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
            The position of the subplot described by one of

            - Three integers (*nrows*, *ncols*, *index*). The subplot will
              take the *index* position on a grid with *nrows* rows and
              *ncols* columns. *index* starts at 1 in the upper left corner
              and increases to the right.  *index* can also be a two-tuple
              specifying the (*first*, *last*) indices (1-based, and including
              *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``
              makes a subplot that spans the upper 2/3 of the figure.
            - A 3-digit integer. The digits are interpreted as if given
              separately as three single-digit integers, i.e.
              ``fig.add_subplot(235)`` is the same as
              ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
              if there are no more than 9 subplots.
            - A `.SubplotSpec`.

            In rare circumstances, `.add_subplot` may be called with a single
            argument, a subplot Axes instance already created in the
            present figure but not in the figure's list of Axes.

        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
'polar', 'rectilinear', str}, optional
            The projection type of the subplot (`~.axes.Axes`). *str* is the
            name of a custom projection, see `~matplotlib.projections`. The
            default None results in a 'rectilinear' projection.

        polar : bool, default: False
            If True, equivalent to projection='polar'.

        axes_class : subclass type of `~.axes.Axes`, optional
            The `.axes.Axes` subclass that is instantiated.  This parameter
            is incompatible with *projection* and *polar*.  See
            :ref:`axisartist_users-guide-index` for examples.

        sharex, sharey : `~matplotlib.axes.Axes`, optional
            Share the x or y `~matplotlib.axis` with sharex and/or sharey.
            The axis will have the same limits, ticks, and scale as the axis
            of the shared Axes.

        label : str
            A label for the returned Axes.

        Returns
        -------
        `~.axes.Axes`

            The Axes of the subplot. The returned Axes can actually be an
            instance of a subclass, such as `.projections.polar.PolarAxes` for
            polar projections.

        Other Parameters
        ----------------
        **kwargs
            This method also takes the keyword arguments for the returned Axes
            base class; except for the *figure* argument. The keyword arguments
            for the rectilinear base class `~.axes.Axes` can be found in
            the following table but there might also be other keyword
            arguments if another projection is used.

            %(Axes:kwdoc)s

        See Also
        --------
        .Figure.add_axes
        .pyplot.subplot
        .pyplot.axes
        .Figure.subplots
        .pyplot.subplots

        Examples
        --------
        ::

            fig = plt.figure()

            fig.add_subplot(231)
            ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general

            fig.add_subplot(232, frameon=False)  # subplot with no frame
            fig.add_subplot(233, projection='polar')  # polar subplot
            fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1
            fig.add_subplot(235, facecolor="red")  # red subplot

            ax1.remove()  # delete ax1 from the figure
            fig.add_subplot(ax1)  # add ax1 back to the figure
        """
        if 'figure' in kwargs:
            # Axes itself allows for a 'figure' kwarg, but since we want to
            # bind the created Axes to self, it is not allowed here.
            raise _api.kwarg_error("add_subplot", "figure")

        if (len(args) == 1
                and isinstance(args[0], mpl.axes._base._AxesBase)
                and args[0].get_subplotspec()):
            ax = args[0]
            key = ax._projection_init
            if ax.get_figure(root=False) is not self:
                raise ValueError("The Axes must have been created in "
                                 "the present figure")
        else:
            if not args:
                args = (1, 1, 1)
            # Normalize correct ijk values to (i, j, k) here so that
            # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will
            # trigger errors later (via SubplotSpec._from_subplot_args).
            if (len(args) == 1 and isinstance(args[0], Integral)
                    and 100 <= args[0] <= 999):
                args = tuple(map(int, str(args[0])))
            projection_class, pkw = self._process_projection_requirements(**kwargs)
            ax = projection_class(self, *args, **pkw)
            key = (projection_class, pkw)
        return self._add_axes_internal(ax, key)

matplotlib.lib.matplotlib.gridspec.__getitem__

def __getitem__(self, key):
    """Create and return a `.SubplotSpec` instance."""
    nrows, ncols = self.get_geometry()

    def _normalize(key, size, axis):  # Includes last index.
        orig_key = key
        if isinstance(key, slice):
            start, stop, _ = key.indices(size)
            if stop > start:
                return start, stop - 1
            raise IndexError("GridSpec slice would result in no space "
                             "allocated for subplot")
        else:
            if key < 0:
                key = key + size
            if 0 <= key < size:
                return key, key
            elif axis is not None:
                raise IndexError(f"index {orig_key} is out of bounds for "
                                 f"axis {axis} with size {size}")
            else:  # flat index
                raise IndexError(f"index {orig_key} is out of bounds for "
                                 f"GridSpec with size {size}")

    if isinstance(key, tuple):
        try:
            k1, k2 = key
        except ValueError as err:
            raise ValueError("Unrecognized subplot spec") from err
        num1, num2 = np.ravel_multi_index(
            [_normalize(k1, nrows, 0), _normalize(k2, ncols, 1)],
            (nrows, ncols))
    else:  # Single key
        num1, num2 = _normalize(key, nrows * ncols, None)

    return SubplotSpec(self, num1, num2)


[/PYTHON]
What will be the output of `subplots`, given the following input:
[INPUT]
```
{
    "self": {
        "left": null,
        "bottom": null,
        "right": null,
        "top": null,
        "wspace": null,
        "hspace": null,
        "figure": "<Figure size 640x480 with 0 Axes>",
        "_nrows": 1,
        "_ncols": 1,
        "_row_height_ratios": [
            1
        ],
        "_col_width_ratios": [
            1
        ]
    },
    "args": {
        "sharex": false,
        "sharey": false,
        "squeeze": true,
        "subplot_kw": null
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[THOUGHT]
