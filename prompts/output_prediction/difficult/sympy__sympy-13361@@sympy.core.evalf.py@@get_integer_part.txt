You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
import math
import mpmath.libmp as libmp
from mpmath import make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec
from mpmath import inf as mpmath_inf
from mpmath.libmp import from_int, from_man_exp, from_rational, fhalf, fnan, fnone, fone, fzero, mpf_abs, mpf_add, mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt, mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin, mpf_sqrt, normalize, round_nearest, to_int, to_str
from mpmath.libmp import bitcount as mpmath_bitcount
from mpmath.libmp.backend import MPZ
from mpmath.libmp.libmpc import _infs_nan
from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps
from mpmath.libmp.gammazeta import mpf_bernoulli
from .compatibility import SYMPY_INTS, range
from .sympify import sympify
from .singleton import S
from sympy.utilities.iterables import is_sequence
from sympy.functions.elementary.complexes import re, im
from sympy.core.numbers import Float
from sympy.core.numbers import Float
from sympy import cos, sin
from sympy import Abs, Add, log
from sympy import Float, Integer
from sympy.core.numbers import Infinity, NegativeInfinity, Zero
from sympy import Poly
from sympy import Float, hypersimp, lambdify
from sympy import Sum
from sympy import Float
from sympy.functions.combinatorial.numbers import bernoulli
from sympy.concrete.products import Product
from sympy.concrete.summations import Sum
from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy.core.numbers import Exp1, Float, Half, ImaginaryUnit, Integer, NaN, NegativeOne, One, Pi, Rational, Zero
from sympy.core.power import Pow
from sympy.core.symbol import Dummy, Symbol
from sympy.functions.elementary.complexes import Abs, im, re
from sympy.functions.elementary.exponential import exp, log
from sympy.functions.elementary.integers import ceiling, floor
from sympy.functions.elementary.piecewise import Piecewise
from sympy.functions.elementary.trigonometric import atan, cos, sin
from sympy.integrals.integrals import Integral
from sympy import re as re_, im as im_
from sympy.core.add import Add
from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy import cos, sin, Wild
from sympy import Float, Number
from sympy.core.expr import _mag
from sympy.core.compatibility import as_int
LG10 = math.log(10, 2)
rnd = round_nearest
INF = float(mpmath_inf)
MINUS_INF = float(-mpmath_inf)
DEFAULT_MAXPREC = 333
evalf_table = None

def get_integer_part(expr, no, options, return_ints=False):
    from sympy.functions.elementary.complexes import re, im
    assumed_size = 30
    ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)
    if ire and iim:
        gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)
    elif ire:
        gap = fastlog(ire) - ire_acc
    elif iim:
        gap = fastlog(iim) - iim_acc
    else:
        return (None, None, None, None)
    margin = 10
    if gap >= -margin:
        ire, iim, ire_acc, iim_acc = evalf(expr, margin + assumed_size + gap, options)

    def calc_part(expr, nexpr):
        from sympy.core.add import Add
        nint = int(to_int(nexpr, rnd))
        n, c, p, b = nexpr
        is_int = p == 0
        if not is_int:
            s = options.get('subs', False)
            if s:
                doit = True
                from sympy.core.compatibility import as_int
                for v in s.values():
                    try:
                        as_int(v)
                    except ValueError:
                        try:
                            [as_int(i) for i in v.as_real_imag()]
                            continue
                        except (ValueError, AttributeError):
                            doit = False
                            break
                if doit:
                    expr = expr.subs(s)
            expr = Add(expr, -nint, evaluate=False)
            x, _, x_acc, _ = evalf(expr, 10, options)
            try:
                check_target(expr, (x, None, x_acc, None), 3)
            except PrecisionExhausted:
                if not expr.equals(0):
                    raise PrecisionExhausted
                x = fzero
            nint += int(no * (mpf_cmp(x or fzero, fzero) == no))
        nint = from_int(nint)
        return (nint, INF)
    re_, im_, re_acc, im_acc = (None, None, None, None)
    if ire:
        re_, re_acc = calc_part(re(expr, evaluate=False), ire)
    if iim:
        im_, im_acc = calc_part(im(expr, evaluate=False), iim)
    if return_ints:
        return (int(to_int(re_ or fzero)), int(to_int(im_ or fzero)))
    return (re_, im_, re_acc, im_acc)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.evalf.evalf

def evalf(x, prec, options):
    from sympy import re as re_, im as im_
    try:
        rf = evalf_table[x.func]
        r = rf(x, prec, options)
    except KeyError:
        try:
            if 'subs' in options:
                x = x.subs(evalf_subs(prec, options['subs']))
            xe = x._eval_evalf(prec)
            re, im = xe.as_real_imag()
            if re.has(re_) or im.has(im_):
                raise NotImplementedError
            if re == 0:
                re = None
                reprec = None
            elif re.is_number:
                re = re._to_mpmath(prec, allow_ints=False)._mpf_
                reprec = prec
            if im == 0:
                im = None
                imprec = None
            elif im.is_number:
                im = im._to_mpmath(prec, allow_ints=False)._mpf_
                imprec = prec
            r = (re, im, reprec, imprec)
        except AttributeError:
            raise NotImplementedError
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50))
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.evalf.evalf_add

def evalf_add(v, prec, options):
    res = pure_complex(v)
    if res:
        h, c = res
        re, _, re_acc, _ = evalf(h, prec, options)
        im, _, im_acc, _ = evalf(c, prec, options)
        return (re, im, re_acc, im_acc)
    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
    i = 0
    target_prec = prec
    while 1:
        options['maxprec'] = min(oldmaxprec, 2 * prec)
        terms = [evalf(arg, prec + 10, options) for arg in v.args]
        re, re_acc = add_terms([a[0::2] for a in terms if a[0]], prec, target_prec)
        im, im_acc = add_terms([a[1::2] for a in terms if a[1]], prec, target_prec)
        acc = complex_accuracy((re, im, re_acc, im_acc))
        if acc >= target_prec:
            if options.get('verbose'):
                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)
            break
        else:
            if prec - target_prec > options['maxprec']:
                break
            prec = prec + max(10 + 2 ** i, target_prec - acc)
            i += 1
            if options.get('verbose'):
                print('ADD: restarting with prec', prec)
    options['maxprec'] = oldmaxprec
    if iszero(re, scaled=True):
        re = scaled_zero(re)
    if iszero(im, scaled=True):
        im = scaled_zero(im)
    return (re, im, re_acc, im_acc)

.sympy.core.evalf.pure_complex

def pure_complex(v, or_real=False):
    h, t = v.as_coeff_Add()
    if not t:
        if or_real:
            return (h, t)
        return
    c, i = t.as_coeff_Mul()
    if i is S.ImaginaryUnit:
        return (h, c)

.sympy.core.add.Add.as_coeff_Add

def as_coeff_Add(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number and (not rational) or coeff.is_Rational:
        return (coeff, self._new_rawargs(*args))
    return (S.Zero, self)

.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (S.One, self)

.sympy.core.evalf.evalf_mul

def evalf_mul(v, prec, options):
    res = pure_complex(v)
    if res:
        _, h = res
        im, _, im_acc, _ = evalf(h, prec, options)
        return (None, im, None, im_acc)
    args = list(v.args)
    special = []
    from sympy.core.numbers import Float
    for arg in args:
        arg = evalf(arg, prec, options)
        if arg[0] is None:
            continue
        arg = Float._new(arg[0], 1)
        if arg is S.NaN or arg.is_infinite:
            special.append(arg)
    if special:
        from sympy.core.mul import Mul
        special = Mul(*special)
        return evalf(special, prec + 4, {})
    acc = prec
    working_prec = prec + len(args) + 5
    start = man, exp, bc = (MPZ(1), 0, 1)
    last = len(args)
    direction = 0
    args.append(S.One)
    complex_factors = []
    for i, arg in enumerate(args):
        if i != last and pure_complex(arg):
            args[-1] = (args[-1] * arg).expand()
            continue
        elif i == last and arg is S.One:
            continue
        re, im, re_acc, im_acc = evalf(arg, working_prec, options)
        if re and im:
            complex_factors.append((re, im, re_acc, im_acc))
            continue
        elif re:
            (s, m, e, b), w_acc = (re, re_acc)
        elif im:
            (s, m, e, b), w_acc = (im, im_acc)
            direction += 1
        else:
            return (None, None, None, None)
        direction += 2 * s
        man *= m
        exp += e
        bc += b
        if bc > 3 * working_prec:
            man >>= working_prec
            exp += working_prec
        acc = min(acc, w_acc)
    sign = (direction & 2) >> 1
    if not complex_factors:
        v = normalize(sign, man, exp, bitcount(man), prec, rnd)
        if direction & 1:
            return (None, v, None, acc)
        else:
            return (v, None, acc, None)
    else:
        if (man, exp, bc) != start:
            re, im = ((sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0))
            i0 = 0
        else:
            wre, wim, wre_acc, wim_acc = complex_factors[0]
            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))
            re = wre
            im = wim
            i0 = 1
        for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:
            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))
            use_prec = working_prec
            A = mpf_mul(re, wre, use_prec)
            B = mpf_mul(mpf_neg(im), wim, use_prec)
            C = mpf_mul(re, wim, use_prec)
            D = mpf_mul(im, wre, use_prec)
            re = mpf_add(A, B, use_prec)
            im = mpf_add(C, D, use_prec)
        if options.get('verbose'):
            print('MUL: wanted', prec, 'accurate bits, got', acc)
        if direction & 1:
            re, im = (mpf_neg(im), re)
        return (re, im, acc, acc)

.sympy.core.expr.Expr.as_coeff_Add

def as_coeff_Add(self, rational=False):
    return (S.Zero, self)

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.core.numbers.Float._new

def _new(cls, _mpf_, _prec):
    if _mpf_ == _mpf_zero:
        return S.Zero
    elif _mpf_ == _mpf_nan:
        return S.NaN
    obj = Expr.__new__(cls)
    obj._mpf_ = mpf_norm(_mpf_, _prec)
    obj._prec = _prec
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.numbers.mpf_norm

def mpf_norm(mpf, prec):
    sign, man, expt, bc = mpf
    if not man:
        if not bc:
            return _mpf_zero
        else:
            return mpf
    from mpmath.libmp.backend import MPZ
    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
    return rv

.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    assumptions._tell(fact, None)
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.numbers.Float._eval_is_infinite

def _eval_is_infinite(self):
    if self._mpf_ in (_mpf_inf, _mpf_ninf):
        return True
    return False

.sympy.core.function.Application.func

def func(self):
    return self.__class__

.sympy.core.power.Pow.__new__

def __new__(cls, b, e, evaluate=None):
    if evaluate is None:
        evaluate = global_evaluate[0]
    from sympy.functions.elementary.exponential import exp_polar
    b = _sympify(b)
    e = _sympify(e)
    if evaluate:
        if e is S.Zero:
            return S.One
        elif e is S.One:
            return b
        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):
            if e.is_even:
                b = -b
            elif e.is_odd:
                return -Pow(-b, e)
        if S.NaN in (b, e):
            return S.NaN
        elif b is S.One:
            if abs(e).is_infinite:
                return S.NaN
            return S.One
        else:
            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):
                from sympy import numer, denom, log, sign, im, factor_terms
                c, ex = factor_terms(e, sign=False).as_coeff_Mul()
                den = denom(ex)
                if isinstance(den, log) and den.args[0] == b:
                    return S.Exp1 ** (c * numer(ex))
                elif den.is_Add:
                    s = sign(im(b))
                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):
                        return S.Exp1 ** (c * numer(ex))
            obj = b._eval_power(e)
            if obj is not None:
                return obj
    obj = Expr.__new__(cls, b, e)
    obj = cls._exec_constructor_postprocessors(obj)
    if not isinstance(obj, Pow):
        return obj
    obj.is_commutative = b.is_commutative and e.is_commutative
    return obj

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    if evaluate is None:
        if global_evaluate[0] is False:
            evaluate = global_evaluate[0]
        else:
            evaluate = True
    try:
        if a in sympy_classes:
            return a
    except TypeError:
        pass
    try:
        cls = a.__class__
    except AttributeError:
        cls = type(a)
    if cls in sympy_classes:
        return a
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            if not isinstance(a, np.floating):
                func = converter[complex] if np.iscomplex(a) else sympify
                return func(np.asscalar(a))
            else:
                try:
                    from sympy.core.numbers import Float
                    prec = np.finfo(a).nmant
                    a = str(list(np.reshape(np.asarray(a), (1, np.size(a)))[0]))[1:-1]
                    return Float(a, precision=prec)
                except NotImplementedError:
                    raise SympifyError('Translation for numpy float : %s is not implemented' % a)
    try:
        return converter[cls](a)
    except KeyError:
        for superclass in getmro(cls):
            try:
                return converter[superclass](a)
            except KeyError:
                continue
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    try:
        return a._sympy_()
    except AttributeError:
        pass
    if not isinstance(a, string_types):
        for coerce in (float, int):
            try:
                return sympify(coerce(a))
            except (TypeError, ValueError, AttributeError, SympifyError):
                continue
    if strict:
        raise SympifyError(a)
    try:
        from ..tensor.array import Array
        return Array(a.flat, a.shape)
    except AttributeError:
        pass
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
        from .compatibility import unicode
        a = unicode(a)
    except Exception as exc:
        raise SympifyError(a, exc)
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.numbers.NumberSymbol.__hash__

def __hash__(self):
    return super(NumberSymbol, self).__hash__()

.sympy.core.basic.Basic.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            if i in Basic._constructor_postprocessor_mapping:
                for k, v in Basic._constructor_postprocessor_mapping[i].items():
                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
            else:
                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
                for k, v in chain.from_iterable(postprocessor_mappings):
                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:
        Basic._constructor_postprocessor_mapping[obj] = postprocessors
    return obj

.sympy.core.evalf.evalf_pow

def evalf_pow(v, prec, options):
    target_prec = prec
    base, exp = v.args
    if exp.is_Integer:
        p = exp.p
        if not p:
            return (fone, None, prec, None)
        prec += int(math.log(abs(p), 2))
        re, im, re_acc, im_acc = evalf(base, prec + 5, options)
        if re and (not im):
            return (mpf_pow_int(re, p, target_prec), None, target_prec, None)
        if im and (not re):
            z = mpf_pow_int(im, p, target_prec)
            case = p % 4
            if case == 0:
                return (z, None, target_prec, None)
            if case == 1:
                return (None, z, None, target_prec)
            if case == 2:
                return (mpf_neg(z), None, target_prec, None)
            if case == 3:
                return (None, mpf_neg(z), None, target_prec)
        if not re:
            return (None, None, None, None)
        re, im = libmp.mpc_pow_int((re, im), p, prec)
        return finalize_complex(re, im, target_prec)
    if exp is S.Half:
        xre, xim, _, _ = evalf(base, prec + 5, options)
        if xim:
            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)
            return finalize_complex(re, im, prec)
        if not xre:
            return (None, None, None, None)
        if mpf_lt(xre, fzero):
            return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)
        return (mpf_sqrt(xre, prec), None, prec, None)
    prec += 10
    yre, yim, _, _ = evalf(exp, prec, options)
    if not (yre or yim):
        return (fone, None, prec, None)
    ysize = fastlog(yre)
    if ysize > 5:
        prec += ysize
        yre, yim, _, _ = evalf(exp, prec, options)
    if base is S.Exp1:
        if yim:
            re, im = libmp.mpc_exp((yre or fzero, yim), prec)
            return finalize_complex(re, im, target_prec)
        return (mpf_exp(yre, target_prec), None, target_prec, None)
    xre, xim, _, _ = evalf(base, prec + 5, options)
    if not (xre or xim):
        return (None, None, None, None)
    if yim:
        re, im = libmp.mpc_pow((xre or fzero, xim or fzero), (yre or fzero, yim), target_prec)
        return finalize_complex(re, im, target_prec)
    if xim:
        re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)
        return finalize_complex(re, im, target_prec)
    elif mpf_lt(xre, fzero):
        re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)
        return finalize_complex(re, im, target_prec)
    else:
        return (mpf_pow(xre, yre, target_prec), None, target_prec, None)

.sympy.core.numbers.Rational.as_coeff_Add

def as_coeff_Add(self, rational=False):
    return (self, S.Zero)

.sympy.core.numbers.Zero.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.evalf.bitcount

def bitcount(n):
    return mpmath_bitcount(abs(int(n)))

.sympy.core.evalf.evalf_log

def evalf_log(expr, prec, options):
    from sympy import Abs, Add, log
    if len(expr.args) > 1:
        expr = expr.doit()
        return evalf(expr, prec, options)
    arg = expr.args[0]
    workprec = prec + 10
    xre, xim, xacc, _ = evalf(arg, workprec, options)
    if xim:
        re = evalf_log(log(Abs(arg, evaluate=False), evaluate=False), prec, options)
        im = mpf_atan2(xim, xre or fzero, prec)
        return (re[0], im, re[2], prec)
    imaginary_term = mpf_cmp(xre, fzero) < 0
    re = mpf_log(mpf_abs(xre), prec, rnd)
    size = fastlog(re)
    if prec - size > workprec and re != fzero:
        arg = Add(S.NegativeOne, arg, evaluate=False)
        xre, xim, _, _ = evalf_add(arg, prec, options)
        prec2 = workprec - fastlog(xre)
        re = mpf_log(mpf_abs(mpf_add(xre, fone, prec2)), prec, rnd)
    re_acc = prec
    if imaginary_term:
        return (re, mpf_pi(prec), re_acc, prec)
    else:
        return (re, None, re_acc, None)

.sympy.core.evalf.fastlog

def fastlog(x):
    if not x or x == fzero:
        return MINUS_INF
    return x[2] + x[3]

.sympy.core.evalf.add_terms

def add_terms(terms, prec, target_prec):
    terms = [t for t in terms if not iszero(t)]
    if not terms:
        return (None, None)
    elif len(terms) == 1:
        return terms[0]
    special = []
    from sympy.core.numbers import Float
    for t in terms:
        arg = Float._new(t[0], 1)
        if arg is S.NaN or arg.is_infinite:
            special.append(arg)
    if special:
        from sympy.core.add import Add
        rv = evalf(Add(*special), prec + 4, {})
        return (rv[0], rv[2])
    working_prec = 2 * prec
    sum_man, sum_exp, absolute_error = (0, 0, MINUS_INF)
    for x, accuracy in terms:
        sign, man, exp, bc = x
        if sign:
            man = -man
        absolute_error = max(absolute_error, bc + exp - accuracy)
        delta = exp - sum_exp
        if exp >= sum_exp:
            if delta > working_prec and (not sum_man or delta - bitcount(abs(sum_man)) > working_prec):
                sum_man = man
                sum_exp = exp
            else:
                sum_man += man << delta
        else:
            delta = -delta
            if delta - bc > working_prec:
                if not sum_man:
                    sum_man, sum_exp = (man, exp)
            else:
                sum_man = (sum_man << delta) + man
                sum_exp = exp
    if not sum_man:
        return scaled_zero(absolute_error)
    if sum_man < 0:
        sum_sign = 1
        sum_man = -sum_man
    else:
        sum_sign = 0
    sum_bc = bitcount(sum_man)
    sum_accuracy = sum_exp + sum_bc - absolute_error
    r = (normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec, rnd), sum_accuracy)
    return r

.sympy.core.evalf.iszero

def iszero(mpf, scaled=False):
    if not scaled:
        return not mpf or (not mpf[1] and (not mpf[-1]))
    return mpf and type(mpf[0]) is list and (mpf[1] == mpf[-1] == 1)

.sympy.core.evalf.complex_accuracy

def complex_accuracy(result):
    re, im, re_acc, im_acc = result
    if not im:
        if not re:
            return INF
        return re_acc
    if not re:
        return im_acc
    re_size = fastlog(re)
    im_size = fastlog(im)
    absolute_error = max(re_size - re_acc, im_size - im_acc)
    relative_error = absolute_error - max(re_size, im_size)
    return -relative_error

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_evaluate[0])
    result = super(Function, cls).__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(mlib.libmpf.prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return EmptySet()
    else:
        args = list(map(sympify, args))
    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._elements = frozenset(args)
    return obj

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, string_types):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Integer can only work with integer expressions.')
    try:
        return _intcache[ival]
    except KeyError:
        obj = Expr.__new__(cls)
        obj.p = ival
        _intcache[ival] = obj
        return obj

.sympy.core.compatibility.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                from sympy.utilities.iterables import uniq
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        for v in d[k]:
            yield v
        d.pop(k)

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super(Infinity, self).__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super(Number, self).__hash__()

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    symb = sympify(self.contains(other))
    if not (symb is S.true or symb is S.false):
        raise TypeError('contains did not evaluate to a bool: %r' % symb)
    return bool(symb)

.sympy.sets.sets.Set.contains

def contains(self, other):
    other = sympify(other, strict=True)
    ret = sympify(self._contains(other))
    if ret is None:
        ret = Contains(other, self, evaluate=False)
    return ret

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    r = false
    for e in self._elements:
        t = Eq(e, other, evaluate=True)
        if isinstance(t, Eq):
            t = t.simplify()
        if t == true:
            return t
        elif t != false:
            r = None
    return r

.sympy.core.relational.Equality.__new__

def __new__(cls, lhs, rhs=0, **options):
    from sympy.core.add import Add
    from sympy.core.logic import fuzzy_bool
    from sympy.core.expr import _n2
    from sympy.simplify.simplify import clear_coefficients
    lhs = _sympify(lhs)
    rhs = _sympify(rhs)
    evaluate = options.pop('evaluate', global_evaluate[0])
    if evaluate:
        if hasattr(lhs, '_eval_Eq'):
            r = lhs._eval_Eq(rhs)
            if r is not None:
                return r
        if hasattr(rhs, '_eval_Eq'):
            r = rhs._eval_Eq(lhs)
            if r is not None:
                return r
        if lhs == rhs:
            return S.true
        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):
            return S.false
        fin = L, R = [i.is_finite for i in (lhs, rhs)]
        if None not in fin:
            if L != R:
                return S.false
            if L is False:
                if lhs == -rhs:
                    return S.false
                return S.true
        elif None in fin and False in fin:
            return Relational.__new__(cls, lhs, rhs, **options)
        if all((isinstance(i, Expr) for i in (lhs, rhs))):
            dif = lhs - rhs
            z = dif.is_zero
            if z is not None:
                if z is False and dif.is_commutative:
                    return S.false
                if z:
                    return S.true
            n2 = _n2(lhs, rhs)
            if n2 is not None:
                return _sympify(n2 == 0)
            n, d = dif.as_numer_denom()
            rv = None
            if n.is_zero:
                rv = d.is_nonzero
            elif n.is_finite:
                if d.is_infinite:
                    rv = S.true
                elif n.is_zero is False:
                    rv = d.is_infinite
                    if rv is None:
                        l, r = clear_coefficients(d, S.Infinity)
                        args = [_.subs(l, r) for _ in (lhs, rhs)]
                        if args != [lhs, rhs]:
                            rv = fuzzy_bool(Eq(*args))
                            if rv is True:
                                rv = None
            elif any((a.is_infinite for a in Add.make_args(n))):
                rv = S.false
            if rv is not None:
                return _sympify(rv)
    return Relational.__new__(cls, lhs, rhs, **options)

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, integer_types):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    from sympy import Pow
    if self is other:
        return True
    if type(self) is not type(other):
        if isinstance(self, Pow) and self.exp == 1:
            return self.base == other
        if isinstance(other, Pow) and other.exp == 1:
            return self == other.base
        try:
            other = _sympify(other)
        except SympifyError:
            return NotImplemented
        if type(self) != type(other):
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.logic.boolalg.BooleanTrue.__hash__

def __hash__(self):
    return hash(True)

.sympy.logic.boolalg.BooleanTrue.__nonzero__

def __nonzero__(self):
    return True

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_evaluate[0])
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super(Application, cls).__new__(cls, *args, **options)
    try:
        if is_sequence(obj.nargs):
            nargs = tuple(ordered(set(obj.nargs)))
        elif obj.nargs is not None:
            nargs = (as_int(obj.nargs),)
        else:
            nargs = None
    except AttributeError:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.core.evalf.evalf_trig

def evalf_trig(v, prec, options):
    from sympy import cos, sin
    if isinstance(v, cos):
        func = mpf_cos
    elif isinstance(v, sin):
        func = mpf_sin
    else:
        raise NotImplementedError
    arg = v.args[0]
    xprec = prec + 20
    re, im, re_acc, im_acc = evalf(arg, xprec, options)
    if im:
        if 'subs' in options:
            v = v.subs(options['subs'])
        return evalf(v._eval_evalf(prec), prec, options)
    if not re:
        if isinstance(v, cos):
            return (fone, None, prec, None)
        elif isinstance(v, sin):
            return (None, None, None, None)
        else:
            raise NotImplementedError
    xsize = fastlog(re)
    if xsize < 1:
        return (func(re, prec, rnd), None, prec, None)
    if xsize >= 10:
        xprec = prec + xsize
        re, im, re_acc, im_acc = evalf(arg, xprec, options)
    while 1:
        y = func(re, prec, rnd)
        ysize = fastlog(y)
        gap = -ysize
        accuracy = xprec - xsize - gap
        if accuracy < prec:
            if options.get('verbose'):
                print('SIN/COS', accuracy, 'wanted', prec, 'gap', gap)
                print(to_str(y, 10))
            if xprec > options.get('maxprec', DEFAULT_MAXPREC):
                return (y, None, accuracy, None)
            xprec += gap
            re, im, re_acc, im_acc = evalf(arg, xprec, options)
            continue
        else:
            return (y, None, prec, None)

.sympy.core.basic.Basic._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, **options):
    from sympy import Order
    args = list(map(_sympify, args))
    args = [a for a in args if a is not cls.identity]
    if not options.pop('evaluate', global_evaluate[0]):
        return cls._from_args(args)
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        return Order(obj, *order_symbols)
    return obj

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super(AssocOp, cls).__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.core.logic.fuzzy_and

def fuzzy_and(args):
    rv = True
    for ai in args:
        ai = fuzzy_bool(ai)
        if ai is False:
            return False
        if rv:
            rv = ai
    return rv

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.evalf.evalf_re

def evalf_re(expr, prec, options):
    return get_complex_part(expr.args[0], 0, prec, options)

.sympy.core.evalf.get_complex_part

def get_complex_part(expr, no, prec, options):
    workprec = prec
    i = 0
    while 1:
        res = evalf(expr, workprec, options)
        value, accuracy = res[no::2]
        if not value or accuracy >= prec or -value[2] > prec:
            return (value, None, accuracy, None)
        workprec += max(30, 2 ** i)
        i += 1

.sympy.core.evalf.scaled_zero

def scaled_zero(mag, sign=1):
    if type(mag) is tuple and len(mag) == 4 and iszero(mag, scaled=True):
        return (mag[0][0],) + mag[1:]
    elif isinstance(mag, SYMPY_INTS):
        if sign not in [-1, 1]:
            raise ValueError('sign must be +/-1')
        rv, p = (mpf_shift(fone, mag), -1)
        s = 0 if sign == 1 else 1
        rv = ([s],) + rv[1:]
        return (rv, p)
    else:
        raise ValueError('scaled zero expects int or scaled_zero tuple.')

.sympy.core.evalf.check_target

def check_target(expr, result, prec):
    a = complex_accuracy(result)
    if a < prec:
        raise PrecisionExhausted('Failed to distinguish the expression: \n\n%s\n\nfrom zero. Try simplifying the input, using chop=True, or providing a higher maxn for evalf' % expr)

.sympy.core.basic.Basic.__str__

def __str__(self):
    from sympy.printing import sstr
    return sstr(self, order=None)

.sympy.printing.str.sstr

def sstr(expr, **settings):
    p = StrPrinter(settings)
    s = p.doprint(expr)
    return s

.sympy.printing.printer.Printer.__init__

def __init__(self, settings=None):
    self._str = str
    self._settings = self._default_settings.copy()
    for key, val in self._global_settings.items():
        if key in self._default_settings:
            self._settings[key] = val
    if settings is not None:
        self._settings.update(settings)
        if len(self._settings) > len(self._default_settings):
            for key in self._settings:
                if key not in self._default_settings:
                    raise TypeError("Unknown setting '%s'." % key)
    self._print_level = 0

.sympy.printing.printer.Printer.doprint

def doprint(self, expr):
    return self._str(self._print(expr))

.sympy.printing.printer.Printer._print

def _print(self, expr, *args, **kwargs):
    self._print_level += 1
    try:
        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):
            return getattr(expr, self.printmethod)(self, *args, **kwargs)
        for cls in type(expr).__mro__:
            printmethod = '_print_' + cls.__name__
            if hasattr(self, printmethod):
                return getattr(self, printmethod)(expr, *args, **kwargs)
        return self.emptyPrinter(expr)
    finally:
        self._print_level -= 1

.sympy.printing.str.StrPrinter._print_Add

def _print_Add(self, expr, order=None):
    if self.order == 'none':
        terms = list(expr.args)
    else:
        terms = self._as_ordered_terms(expr, order=order)
    PREC = precedence(expr)
    l = []
    for term in terms:
        t = self._print(term)
        if t.startswith('-'):
            sign = '-'
            t = t[1:]
        else:
            sign = '+'
        if precedence(term) < PREC:
            l.extend([sign, '(%s)' % t])
        else:
            l.extend([sign, t])
    sign = l.pop(0)
    if sign == '+':
        sign = ''
    return sign + ' '.join(l)

.sympy.printing.printer.Printer.order

def order(self):
    if 'order' in self._settings:
        return self._settings['order']
    else:
        raise AttributeError('No order defined.')

.sympy.printing.printer.Printer._as_ordered_terms

def _as_ordered_terms(self, expr, order=None):
    order = order or self.order
    if order == 'old':
        return sorted(Add.make_args(expr), key=cmp_to_key(Basic._compare_pretty))
    else:
        return expr.as_ordered_terms(order=order)

.sympy.core.expr.Expr.as_ordered_terms

def as_ordered_terms(self, order=None, data=False):
    key, reverse = self._parse_order(order)
    terms, gens = self.as_terms()
    if not any((term.is_Order for term, _ in terms)):
        ordered = sorted(terms, key=key, reverse=reverse)
    else:
        _terms, _order = ([], [])
        for term, repr in terms:
            if not term.is_Order:
                _terms.append((term, repr))
            else:
                _order.append((term, repr))
        ordered = sorted(_terms, key=key, reverse=True) + sorted(_order, key=key, reverse=True)
    if data:
        return (ordered, gens)
    else:
        return [term for term, _ in ordered]

.sympy.core.expr.Expr._parse_order

def _parse_order(cls, order):
    from sympy.polys.orderings import monomial_key
    try:
        reverse = order.startswith('rev-')
    except AttributeError:
        reverse = False
    else:
        if reverse:
            order = order[4:]
    monom_key = monomial_key(order)

    def neg(monom):
        result = []
        for m in monom:
            if isinstance(m, tuple):
                result.append(neg(m))
            else:
                result.append(-m)
        return tuple(result)

    def key(term):
        _, ((re, im), monom, ncpart) = term
        monom = neg(monom_key(monom))
        ncpart = tuple([e.sort_key(order=order) for e in ncpart])
        coeff = ((bool(im), im), (re, im))
        return (monom, ncpart, coeff)
    return (key, reverse)

.sympy.polys.orderings.monomial_key

def monomial_key(order=None, gens=None):
    if order is None:
        order = lex
    if isinstance(order, Symbol):
        order = str(order)
    if isinstance(order, str):
        try:
            order = _monomial_key[order]
        except KeyError:
            raise ValueError("supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r" % order)
    if hasattr(order, '__call__'):
        if gens is not None:

            def _order(expr):
                return order(expr.as_poly(*gens).degree_list())
            return _order
        return order
    else:
        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)

.sympy.core.expr.Expr.as_terms

def as_terms(self):
    from .add import Add
    from .mul import Mul
    from .exprtools import decompose_power
    gens, terms = (set([]), [])
    for term in Add.make_args(self):
        coeff, _term = term.as_coeff_Mul()
        coeff = complex(coeff)
        cpart, ncpart = ({}, [])
        if _term is not S.One:
            for factor in Mul.make_args(_term):
                if factor.is_number:
                    try:
                        coeff *= complex(factor)
                    except TypeError:
                        pass
                    else:
                        continue
                if factor.is_commutative:
                    base, exp = decompose_power(factor)
                    cpart[base] = exp
                    gens.add(base)
                else:
                    ncpart.append(factor)
        coeff = (coeff.real, coeff.imag)
        ncpart = tuple(ncpart)
        terms.append((term, (coeff, cpart, ncpart)))
    gens = sorted(gens, key=default_sort_key)
    k, indices = (len(gens), {})
    for i, g in enumerate(gens):
        indices[g] = i
    result = []
    for term, (coeff, cpart, ncpart) in terms:
        monom = [0] * k
        for base, exp in cpart.items():
            monom[indices[base]] = exp
        result.append((term, (coeff, tuple(monom), ncpart)))
    return (result, gens)

.sympy.core.operations.AssocOp.make_args

def make_args(cls, expr):
    if isinstance(expr, cls):
        return expr.args
    else:
        return (sympify(expr),)

.sympy.core.expr.Expr.__complex__

def __complex__(self):
    result = self.evalf()
    re, im = result.as_real_imag()
    return complex(float(re), float(im))

.sympy.core.evalf.EvalfMixin.evalf

def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
    from sympy import Float, Number
    n = n if n is not None else 15
    if subs and is_sequence(subs):
        raise TypeError('subs must be given as a dictionary')
    if n == 1 and isinstance(self, Number):
        from sympy.core.expr import _mag
        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
        m = _mag(rv)
        rv = rv.round(1 - m)
        return rv
    if not evalf_table:
        _create_evalf_table()
    prec = dps_to_prec(n)
    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}
    if subs is not None:
        options['subs'] = subs
    if quad is not None:
        options['quad'] = quad
    try:
        result = evalf(self, prec + 4, options)
    except NotImplementedError:
        v = self._eval_evalf(prec)
        if v is None:
            return self
        try:
            result = evalf(v, prec, options)
        except NotImplementedError:
            return v
    re, im, re_acc, im_acc = result
    if re:
        p = max(min(prec, re_acc), 1)
        re = Float._new(re, p)
    else:
        re = S.Zero
    if im:
        p = max(min(prec, im_acc), 1)
        im = Float._new(im, p)
        return re + im * S.ImaginaryUnit
    else:
        return re

.sympy.core.expr.Expr.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import im, re
    if hints.get('ignore') == self:
        return None
    else:
        return (re(self), im(self))

.sympy.core.numbers.Float.__eq__

def __eq__(self, other):
    if isinstance(other, float):
        o = Float(other)
        try:
            ompf = o._as_mpf_val(self._prec)
        except ValueError:
            return False
        return bool(mlib.mpf_eq(self._mpf_, ompf))
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if isinstance(other, NumberSymbol):
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if isinstance(other, Float):
        return bool(mlib.mpf_eq(self._mpf_, other._mpf_))
    if isinstance(other, Number):
        ompf = other._as_mpf_val(self._prec)
        return bool(mlib.mpf_eq(self._mpf_, ompf))
    return False

.sympy.core.sympify.SympifyError.__init__

def __init__(self, expr, base_exc=None):
    self.expr = expr
    self.base_exc = base_exc

.sympy.core.numbers.Float.__hash__

def __hash__(self):
    return super(Float, self).__hash__()

.sympy.core.numbers.Float._hashable_content

def _hashable_content(self):
    return (self._mpf_, self._prec)

.sympy.functions.elementary.complexes.re.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_real:
        return arg
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:
        return S.Zero
    elif arg.is_Matrix:
        return arg.as_real_imag()[0]
    elif arg.is_Function and isinstance(arg, conjugate):
        return re(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_real:
                    reverted.append(coeff)
            elif not term.has(S.ImaginaryUnit) and term.is_real:
                excluded.append(term)
            else:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[0])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) - im(b) + c

.sympy.functions.elementary.complexes.im.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_real:
        return S.Zero
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:
        return -S.ImaginaryUnit * arg
    elif arg.is_Matrix:
        return arg.as_real_imag()[1]
    elif arg.is_Function and isinstance(arg, conjugate):
        return -im(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_real:
                    reverted.append(coeff)
                else:
                    excluded.append(coeff)
            elif term.has(S.ImaginaryUnit) or not term.is_real:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[1])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) + re(b) + c

.sympy.core.numbers.Number.__float__

def __float__(self):
    return mlib.to_float(self._as_mpf_val(53))

.sympy.core.numbers.Float._as_mpf_val

def _as_mpf_val(self, prec):
    rv = mpf_norm(self._mpf_, prec)
    if rv != self._mpf_ and self._prec == prec:
        debug(self._mpf_, rv)
    return rv

.sympy.core.numbers.Integer._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_int(self.p, prec, rnd)

.sympy.core.expr.Expr.is_number

def is_number(self):
    return all((obj.is_number for obj in self.args))

.sympy.core.numbers.Rational.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (self, S.One)

.sympy.core.expr.Expr.key

def key(term):
    _, ((re, im), monom, ncpart) = term
    monom = neg(monom_key(monom))
    ncpart = tuple([e.sort_key(order=order) for e in ncpart])
    coeff = ((bool(im), im), (re, im))
    return (monom, ncpart, coeff)

.sympy.polys.orderings.LexOrder.__call__

def __call__(self, monomial):
    return monomial

.sympy.core.expr.Expr.neg

def neg(monom):
    result = []
    for m in monom:
        if isinstance(m, tuple):
            result.append(neg(m))
        else:
            result.append(-m)
    return tuple(result)

.sympy.printing.precedence.precedence

def precedence(item):
    if hasattr(item, 'precedence'):
        return item.precedence
    try:
        mro = item.__class__.__mro__
    except AttributeError:
        return PRECEDENCE['Atom']
    for i in mro:
        n = i.__name__
        if n in PRECEDENCE_FUNCTIONS:
            return PRECEDENCE_FUNCTIONS[n](item)
        elif n in PRECEDENCE_VALUES:
            return PRECEDENCE_VALUES[n]
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Integer

def _print_Integer(self, expr):
    if self._settings.get('sympy_integers', False):
        return 'S(%s)' % expr
    return str(expr.p)

.sympy.printing.precedence.precedence_Integer

def precedence_Integer(item):
    if item.p < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Function

def _print_Function(self, expr):
    return expr.func.__name__ + '(%s)' % self.stringify(expr.args, ', ')

.sympy.printing.str.StrPrinter.stringify

def stringify(self, args, sep, level=0):
    return sep.join([self.parenthesize(item, level) for item in args])

.sympy.printing.str.StrPrinter.parenthesize

def parenthesize(self, item, level, strict=False):
    if precedence(item) < level or (not strict and precedence(item) <= level):
        return '(%s)' % self._print(item)
    else:
        return self._print(item)

.sympy.printing.str.StrPrinter._print_Mul

def _print_Mul(self, expr):
    prec = precedence(expr)
    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = '-'
    else:
        sign = ''
    a = []
    b = []
    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        args = Mul.make_args(expr)
    for item in args:
        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                b.append(Pow(item.base, -item.exp))
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append(Rational(item.p))
            if item.q != 1:
                b.append(Rational(item.q))
        else:
            a.append(item)
    a = a or [S.One]
    a_str = [self.parenthesize(x, prec, strict=False) for x in a]
    b_str = [self.parenthesize(x, prec, strict=False) for x in b]
    if len(b) == 0:
        return sign + '*'.join(a_str)
    elif len(b) == 1:
        return sign + '*'.join(a_str) + '/' + b_str[0]
    else:
        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)

.sympy.printing.precedence.precedence_Mul

def precedence_Mul(item):
    if _coeff_isneg(item):
        return PRECEDENCE['Add']
    return PRECEDENCE['Mul']

.sympy.core.function._coeff_isneg

def _coeff_isneg(a):
    if a.is_Mul:
        a = a.args[0]
    return a.is_Number and a.is_negative

.sympy.core.numbers.Integer.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if isinstance(other, Integer):
        return _sympify(self.p < other.p)
    return Rational.__lt__(self, other)

.sympy.logic.boolalg.BooleanFalse.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.mul.Mul.as_ordered_factors

def as_ordered_factors(self, order=None):
    cpart, ncpart = self.args_cnc()
    cpart.sort(key=lambda expr: expr.sort_key(order=order))
    return cpart + ncpart

.sympy.core.expr.Expr.args_cnc

def args_cnc(self, cset=False, warn=True, split_1=True):
    if self.is_Mul:
        args = list(self.args)
    else:
        args = [self]
    for i, mi in enumerate(args):
        if not mi.is_commutative:
            c = args[:i]
            nc = args[i:]
            break
    else:
        c = args
        nc = []
    if c and split_1 and (c[0].is_Number and c[0].is_negative and (c[0] is not S.NegativeOne)):
        c[:1] = [S.NegativeOne, -c[0]]
    if cset:
        clen = len(c)
        c = set(c)
        if clen and warn and (len(c) != clen):
            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])
    return [c, nc]

.sympy.core.numbers.Number.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (0, ()), (), self)

.sympy.core.numbers.Number.class_key

def class_key(cls):
    return (1, 0, 'Number')

.sympy.core.expr.Expr.sort_key

def sort_key(self, order=None):
    coeff, expr = self.as_coeff_Mul()
    if expr.is_Pow:
        expr, exp = expr.args
    else:
        expr, exp = (expr, S.One)
    if expr.is_Dummy:
        args = (expr.sort_key(),)
    elif expr.is_Atom:
        args = (str(expr),)
    else:
        if expr.is_Add:
            args = expr.as_ordered_terms(order=order)
        elif expr.is_Mul:
            args = expr.as_ordered_factors(order=order)
        else:
            args = expr.args
        args = tuple([default_sort_key(arg, order=order) for arg in args])
    args = (len(args), tuple(args))
    exp = exp.sort_key(order=order)
    return (expr.class_key(), args, exp, coeff)

.sympy.core.compatibility.default_sort_key

def default_sort_key(item, order=None):
    from .singleton import S
    from .basic import Basic
    from .sympify import sympify, SympifyError
    from .compatibility import iterable
    if isinstance(item, Basic):
        return item.sort_key(order=order)
    if iterable(item, exclude=string_types):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            args = list(item)
            unordered = False
        args = [default_sort_key(arg, order=order) for arg in args]
        if unordered:
            args = sorted(args)
        cls_index, args = (10, (len(args), tuple(args)))
    else:
        if not isinstance(item, string_types):
            try:
                item = sympify(item)
            except SympifyError:
                pass
            else:
                if isinstance(item, Basic):
                    return default_sort_key(item)
        cls_index, args = (0, (1, (str(item),)))
    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)

.sympy.core.function.Function.class_key

def class_key(cls):
    from sympy.sets.fancysets import Naturals0
    funcs = {'exp': 10, 'log': 11, 'sin': 20, 'cos': 21, 'tan': 22, 'cot': 23, 'sinh': 30, 'cosh': 31, 'tanh': 32, 'coth': 33, 'conjugate': 40, 're': 41, 'im': 42, 'arg': 43}
    name = cls.__name__
    try:
        i = funcs[name]
    except KeyError:
        i = 0 if isinstance(cls.nargs, Naturals0) else 10000
    return (4, i, name)

.sympy.core.numbers.Rational.__new__

def __new__(cls, p, q=None, gcd=None):
    if q is None:
        if isinstance(p, Rational):
            return p
        if isinstance(p, string_types):
            if p.count('/') > 1:
                raise TypeError('invalid input: %s' % p)
            pq = p.rsplit('/', 1)
            if len(pq) == 2:
                p, q = pq
                fp = fractions.Fraction(p)
                fq = fractions.Fraction(q)
                f = fp / fq
                return Rational(f.numerator, f.denominator, 1)
            p = p.replace(' ', '')
            try:
                p = fractions.Fraction(p)
            except ValueError:
                pass
        if not isinstance(p, string_types):
            try:
                if isinstance(p, fractions.Fraction):
                    return Rational(p.numerator, p.denominator, 1)
            except NameError:
                pass
            if isinstance(p, (float, Float)):
                return Rational(*_as_integer_ratio(p))
        if not isinstance(p, SYMPY_INTS + (Rational,)):
            raise TypeError('invalid input: %s' % p)
        q = q or S.One
        gcd = 1
    else:
        p = Rational(p)
        q = Rational(q)
    if isinstance(q, Rational):
        p *= q.q
        q = q.p
    if isinstance(p, Rational):
        q *= p.q
        p = p.p
    if q == 0:
        if p == 0:
            if _errdict['divide']:
                raise ValueError('Indeterminate 0/0')
            else:
                return S.NaN
        return S.ComplexInfinity
    if q < 0:
        q = -q
        p = -p
    if not gcd:
        gcd = igcd(abs(p), q)
    if gcd > 1:
        p //= gcd
        q //= gcd
    if q == 1:
        return Integer(p)
    if p == 1 and q == 2:
        return S.Half
    obj = Expr.__new__(cls)
    obj.p = p
    obj.q = q
    return obj

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.printing.str.StrPrinter._print_Pow

def _print_Pow(self, expr, rational=False):
    PREC = precedence(expr)
    if expr.exp is S.Half and (not rational):
        return 'sqrt(%s)' % self._print(expr.base)
    if expr.is_commutative:
        if -expr.exp is S.Half and (not rational):
            return '%s/sqrt(%s)' % tuple(map(self._print, (S.One, expr.base)))
        if expr.exp is -S.One:
            return '%s/%s' % (self._print(S.One), self.parenthesize(expr.base, PREC, strict=False))
    e = self.parenthesize(expr.exp, PREC, strict=False)
    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and (expr.exp.q != 1):
        if e.startswith('(Rational'):
            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)

.sympy.core.numbers.Integer.__neg__

def __neg__(self):
    return Integer(-self.p)

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.expr.Expr.equals

def equals(self, other, failing_expression=False):
    from sympy.simplify.simplify import nsimplify, simplify
    from sympy.solvers.solveset import solveset
    from sympy.polys.polyerrors import NotAlgebraic
    from sympy.polys.numberfields import minimal_polynomial
    other = sympify(other)
    if self == other:
        return True
    diff = factor_terms(simplify(self - other), radical=True)
    if not diff:
        return True
    if not diff.has(Add, Mod):
        return False
    constant = diff.is_constant(simplify=False, failing_number=True)
    if constant is False:
        return False
    if constant is None and (diff.free_symbols or not diff.is_number):
        return
    if constant is True:
        ndiff = diff._random()
        if ndiff:
            return False
    if diff.is_number:
        approx = diff.nsimplify()
        if not approx:
            surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
            surds.sort(key=lambda x: -x.args[0])
            for s in surds:
                try:
                    if s.is_Symbol:
                        sol = list(solveset(diff, s))
                    else:
                        sol = [s]
                    if sol:
                        if s in sol:
                            return True
                        if s.is_real:
                            if any((nsimplify(si, [s]) == s and simplify(si) == s for si in sol)):
                                return True
                except NotImplementedError:
                    pass
            if True:
                try:
                    mp = minimal_polynomial(diff)
                    if mp.is_Symbol:
                        return True
                    return False
                except (NotAlgebraic, NotImplementedError):
                    pass
    if constant not in (True, None) and constant != 0:
        return False
    if failing_expression:
        return diff
    return None

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            try:
                f = getattr(other, method_name)
            except AttributeError:
                pass
            else:
                return f(self)
    return func(self, other)

.sympy.core.expr.Expr.__sub__

def __sub__(self, other):
    return Add(self, -other)

.sympy.core.numbers.Zero.__neg__

def __neg__():
    return S.Zero

.sympy.simplify.simplify.simplify

def simplify(expr, ratio=1.7, measure=count_ops, rational=False):
    expr = sympify(expr)
    try:
        return expr._eval_simplify(ratio=ratio, measure=measure)
    except AttributeError:
        pass
    original_expr = expr = signsimp(expr)
    from sympy.simplify.hyperexpand import hyperexpand
    from sympy.functions.special.bessel import BesselBase
    from sympy import Sum, Product
    if not isinstance(expr, Basic) or not expr.args:
        return expr
    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
        if isinstance(expr, Function) and hasattr(expr, 'inverse'):
            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and isinstance(expr.args[0], expr.inverse(argindex=1)):
                return simplify(expr.args[0].args[0], ratio=ratio, measure=measure, rational=rational)
        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational) for x in expr.args])

    def shorter(*choices):
        if not has_variety(choices):
            return choices[0]
        return min(choices, key=measure)
    floats = False
    if rational is not False and expr.has(Float):
        floats = True
        expr = nsimplify(expr, rational=True)
    expr = bottom_up(expr, lambda w: w.normal())
    expr = Mul(*powsimp(expr).as_content_primitive())
    _e = cancel(expr)
    expr1 = shorter(_e, _mexpand(_e).cancel())
    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
    if ratio is S.Infinity:
        expr = expr2
    else:
        expr = shorter(expr2, expr1, expr)
    if not isinstance(expr, Basic):
        return expr
    expr = factor_terms(expr, sign=False)
    expr = hyperexpand(expr)
    expr = piecewise_fold(expr)
    if expr.has(BesselBase):
        expr = besselsimp(expr)
    if expr.has(TrigonometricFunction, HyperbolicFunction):
        expr = trigsimp(expr, deep=True)
    if expr.has(log):
        expr = shorter(expand_log(expr, deep=True), logcombine(expr))
    if expr.has(CombinatorialFunction, gamma):
        expr = combsimp(expr)
    if expr.has(Sum):
        expr = sum_simplify(expr)
    if expr.has(Product):
        expr = product_simplify(expr)
    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
    short = shorter(short, cancel(short))
    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
        short = exptrigsimp(short)
    hollow_mul = Transform(lambda x: Mul(*x.args), lambda x: x.is_Mul and len(x.args) == 2 and x.args[0].is_Number and x.args[1].is_Add and x.is_commutative)
    expr = short.xreplace(hollow_mul)
    numer, denom = expr.as_numer_denom()
    if denom.is_Add:
        n, d = fraction(radsimp(1 / denom, symbolic=False, max_terms=1))
        if n is not S.One:
            expr = (numer * n).expand() / d
    if expr.could_extract_minus_sign():
        n, d = fraction(expr)
        if d != 0:
            expr = signsimp(-n / -d)
    if measure(expr) > ratio * measure(original_expr):
        expr = original_expr
    if floats and rational is None:
        expr = nfloat(expr, exponent=False)
    return expr

.sympy.simplify.simplify.signsimp

def signsimp(expr, evaluate=None):
    if evaluate is None:
        evaluate = global_evaluate[0]
    expr = sympify(expr)
    if not isinstance(expr, Expr) or expr.is_Atom:
        return expr
    e = sub_post(sub_pre(expr))
    if not isinstance(e, Expr) or e.is_Atom:
        return e
    if e.is_Add:
        return e.func(*[signsimp(a, evaluate) for a in e.args])
    if evaluate:
        e = e.xreplace({m: --m for m in e.atoms(Mul) if --m != m})
    return e

.sympy.simplify.cse_opts.sub_pre

def sub_pre(e):
    reps = [a for a in e.atoms(Add) if a.could_extract_minus_sign()]
    reps.sort(key=default_sort_key)
    e = e.xreplace(dict(((a, Mul._from_args([S.NegativeOne, -a])) for a in reps)))
    if isinstance(e, Basic):
        negs = {}
        for a in sorted(e.atoms(Add), key=default_sort_key):
            if a in reps or a.could_extract_minus_sign():
                negs[a] = Mul._from_args([S.One, S.NegativeOne, -a])
        e = e.xreplace(negs)
    return e

.sympy.core.basic.Basic.atoms

def atoms(self, *types):
    if types:
        types = tuple([t if isinstance(t, type) else type(t) for t in types])
    else:
        types = (Atom,)
    result = set()
    for expr in preorder_traversal(self):
        if isinstance(expr, types):
            result.add(expr)
    return result

.sympy.core.basic.preorder_traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

.sympy.core.basic.preorder_traversal.__iter__

def __iter__(self):
    return self

.sympy.core.basic.preorder_traversal.__next__

def __next__(self):
    return next(self._pt)

.sympy.core.basic.preorder_traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            for subtree in self._preorder_traversal(arg, keys):
                yield subtree
    elif iterable(node):
        for item in node:
            for subtree in self._preorder_traversal(item, keys):
                yield subtree

.sympy.core.expr.Expr.could_extract_minus_sign

def could_extract_minus_sign(self):
    negative_self = -self
    if self == negative_self:
        return False
    self_has_minus = self.extract_multiplicatively(-1) is not None
    negative_self_has_minus = negative_self.extract_multiplicatively(-1) is not None
    if self_has_minus != negative_self_has_minus:
        return self_has_minus
    else:
        if self.is_Add:
            all_args = len(self.args)
            negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
            positive_args = all_args - negative_args
            if positive_args > negative_args:
                return False
            elif positive_args < negative_args:
                return True
        elif self.is_Mul:
            num, den = self.as_numer_denom()
            args = Mul.make_args(num) + Mul.make_args(den)
            arg_signs = [arg.could_extract_minus_sign() for arg in args]
            negative_args = list(filter(None, arg_signs))
            return len(negative_args) % 2 == 1
        return bool(self.sort_key() < negative_self.sort_key())

.sympy.core.add.Add.__neg__

def __neg__(self):
    return self * -1

.sympy.core.expr.Expr.__mul__

def __mul__(self, other):
    return Mul(self, other)

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        assert not a is S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    rv = ([cls(a * r, b, evaluate=False)], [], None)
                elif global_distribute[0] and b.is_commutative:
                    r, b = b.as_coeff_Add()
                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
                    _addsort(bargs)
                    ar = a * r
                    if ar:
                        bargs.insert(0, ar)
                    bargs = [Add._from_args(bargs)]
                    rv = (bargs, [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number:
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            if coeff is S.ComplexInfinity:
                return ([S.ComplexInfinity], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
                elif b is S.ImaginaryUnit and e.is_Rational:
                    neg1e += e / 2
                    continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff is S.Infinity or coeff is S.NegativeInfinity:

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_positive:
                    continue
                if t.is_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]
    elif coeff is S.Zero:
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.mul._keep_coeff

def _keep_coeff(coeff, factors, clear=True, sign=False):
    if not coeff.is_Number:
        if factors.is_Number:
            factors, coeff = (coeff, factors)
        else:
            return coeff * factors
    if coeff is S.One:
        return factors
    elif coeff is S.NegativeOne and (not sign):
        return -factors
    elif factors.is_Add:
        if not clear and coeff.is_Rational and (coeff.q != 1):
            q = S(coeff.q)
            for i in factors.args:
                c, t = i.as_coeff_Mul()
                r = c / q
                if r == int(r):
                    return coeff * factors
        return Mul._from_args((coeff, factors))
    elif factors.is_Mul:
        margs = list(factors.args)
        if margs[0].is_Number:
            margs[0] *= coeff
            if margs[0] == 1:
                margs.pop(0)
        else:
            margs.insert(0, coeff)
        return Mul._from_args(margs)
    else:
        return coeff * factors

.sympy.core.expr.Expr.__neg__

def __neg__(self):
    return Mul(S.NegativeOne, self)

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.power.Pow.as_base_exp

def as_base_exp(self):
    b, e = self.args
    if b.is_Rational and b.p == 1 and (b.q != 1):
        return (Integer(b.q), -e)
    return (b, e)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.numbers.NaN.__hash__

def __hash__(self):
    return super(NaN, self).__hash__()

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if isinstance(other, NumberSymbol):
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if isinstance(other, Number):
        if isinstance(other, Rational):
            return self.p == other.p and self.q == other.q
        if isinstance(other, Float):
            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
    return False

.sympy.core.expr.Expr._eval_power

def _eval_power(self, other):
    return None

.sympy.core.function.Function.is_commutative

def is_commutative(self):
    if all((getattr(t, 'is_commutative') for t in self.args)):
        return True
    else:
        return False

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.add._addsort

def _addsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.basic.Basic.compare

def compare(self, other):
    if self is other:
        return 0
    n1 = self.__class__
    n2 = other.__class__
    c = (n1 > n2) - (n1 < n2)
    if c:
        return c
    st = self._hashable_content()
    ot = other._hashable_content()
    c = (len(st) > len(ot)) - (len(st) < len(ot))
    if c:
        return c
    for l, r in zip(st, ot):
        l = Basic(*l) if isinstance(l, frozenset) else l
        r = Basic(*r) if isinstance(r, frozenset) else r
        if isinstance(l, Basic):
            c = l.compare(r)
        else:
            c = (l > r) - (l < r)
        if c:
            return c
    return 0

.sympy.core.core.BasicMeta.__gt__

def __gt__(cls, other):
    if cls.__cmp__(other) == 1:
        return True
    return False

.sympy.core.core.BasicMeta.__cmp__

def __cmp__(cls, other):
    if not isinstance(other, BasicMeta):
        return -1
    n1 = cls.__name__
    n2 = other.__name__
    if n1 == n2:
        return 0
    UNKNOWN = len(ordering_of_classes) + 1
    try:
        i1 = ordering_of_classes.index(n1)
    except ValueError:
        i1 = UNKNOWN
    try:
        i2 = ordering_of_classes.index(n2)
    except ValueError:
        i2 = UNKNOWN
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)
    return (i1 > i2) - (i1 < i2)

.sympy.core.core.BasicMeta.__lt__

def __lt__(cls, other):
    if cls.__cmp__(other) == -1:
        return True
    return False

.sympy.core.expr.Expr.extract_multiplicatively

def extract_multiplicatively(self, c):
    from .function import _coeff_isneg
    c = sympify(c)
    if self is S.NaN:
        return None
    if c is S.One:
        return self
    elif c == self:
        return S.One
    if c.is_Add:
        cc, pc = c.primitive()
        if cc is not S.One:
            c = Mul(cc, pc, evaluate=False)
    if c.is_Mul:
        a, b = c.as_two_terms()
        x = self.extract_multiplicatively(a)
        if x is not None:
            return x.extract_multiplicatively(b)
    quotient = self / c
    if self.is_Number:
        if self is S.Infinity:
            if c.is_positive:
                return S.Infinity
        elif self is S.NegativeInfinity:
            if c.is_negative:
                return S.Infinity
            elif c.is_positive:
                return S.NegativeInfinity
        elif self is S.ComplexInfinity:
            if not c.is_zero:
                return S.ComplexInfinity
        elif self.is_Integer:
            if not quotient.is_Integer:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
        elif self.is_Rational:
            if not quotient.is_Rational:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
        elif self.is_Float:
            if not quotient.is_Float:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
        if quotient.is_Mul and len(quotient.args) == 2:
            if quotient.args[0].is_Integer and quotient.args[0].is_positive and (quotient.args[1] == self):
                return quotient
        elif quotient.is_Integer and c.is_Number:
            return quotient
    elif self.is_Add:
        cs, ps = self.primitive()
        if c.is_Number and c is not S.NegativeOne:
            if cs is not S.One:
                if c.is_negative:
                    xc = -cs.extract_multiplicatively(-c)
                else:
                    xc = cs.extract_multiplicatively(c)
                if xc is not None:
                    return xc * ps
            return
        if c == ps:
            return cs
        newargs = []
        for arg in ps.args:
            newarg = arg.extract_multiplicatively(c)
            if newarg is None:
                return
            newargs.append(newarg)
        if cs is not S.One:
            return Add._from_args([cs * t for t in newargs])
        else:
            return Add._from_args(newargs)
    elif self.is_Mul:
        args = list(self.args)
        for i, arg in enumerate(args):
            newarg = arg.extract_multiplicatively(c)
            if newarg is not None:
                args[i] = newarg
                return Mul(*args)
    elif self.is_Pow:
        if c.is_Pow and c.base == self.base:
            new_exp = self.exp.extract_additively(c.exp)
            if new_exp is not None:
                return self.base ** new_exp
        elif c == self.base:
            new_exp = self.exp.extract_additively(1)
            if new_exp is not None:
                return self.base ** new_exp

.sympy.core.expr.Expr.__div__

def __div__(self, other):
    return Mul(self, Pow(other, S.NegativeOne))

.sympy.core.numbers.NegativeOne.__neg__

def __neg__():
    return S.One

.sympy.core.numbers.NegativeOne.__abs__

def __abs__():
    return S.One

.sympy.core.add.Add.primitive

def primitive(self):
    terms = []
    inf = False
    for a in self.args:
        c, m = a.as_coeff_Mul()
        if not c.is_Rational:
            c = S.One
            m = a
        inf = inf or m is S.ComplexInfinity
        terms.append((c.p, c.q, m))
    if not inf:
        ngcd = reduce(igcd, [t[0] for t in terms], 0)
        dlcm = reduce(ilcm, [t[1] for t in terms], 1)
    else:
        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)
        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)
    if ngcd == dlcm == 1:
        return (S.One, self)
    if not inf:
        for i, (p, q, term) in enumerate(terms):
            terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)
    else:
        for i, (p, q, term) in enumerate(terms):
            if q:
                terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)
            else:
                terms[i] = _keep_coeff(Rational(p, q), term)
    if terms[0].is_Number or terms[0] is S.ComplexInfinity:
        c = terms.pop(0)
    else:
        c = None
    _addsort(terms)
    if c:
        terms.insert(0, c)
    return (Rational(ngcd, dlcm), self._new_rawargs(*terms))

.sympy.core.numbers.igcd

def igcd(*args):
    if len(args) < 2:
        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))
    if 1 in args:
        a = 1
        k = 0
    else:
        a = abs(as_int(args[0]))
        k = 1
    if a != 1:
        while k < len(args):
            b = args[k]
            k += 1
            try:
                a = _gcdcache[a, b]
            except KeyError:
                b = as_int(b)
                if not b:
                    continue
                if b == 1:
                    a = 1
                    break
                if b < 0:
                    b = -b
                t = (a, b)
                a = igcd2(a, b)
                _gcdcache[t] = _gcdcache[t[1], t[0]] = a
    while k < len(args):
        ok = as_int(args[k])
        k += 1
    return a

.sympy.core.compatibility.as_int

def as_int(n):
    try:
        result = int(n)
        if result != n:
            raise TypeError
    except TypeError:
        raise ValueError('%s is not an integer' % (n,))
    return result

.sympy.core.numbers.ilcm

def ilcm(*args):
    if len(args) < 2:
        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))
    if 0 in args:
        return 0
    a = args[0]
    for b in args[1:]:
        a = a * b // igcd(a, b)
    return a

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, **kwargs):
    if kwargs.pop('reeval', True) and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.core.numbers.Rational.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))
        elif isinstance(other, Float):
            return other * self
        else:
            return Number.__mul__(self, other)
    return Number.__mul__(self, other)

.sympy.core.numbers.Number.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.Infinity
            else:
                return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.NegativeInfinity
            else:
                return S.Infinity
    elif isinstance(other, Tuple):
        return NotImplemented
    return AtomicExpr.__mul__(self, other)

.sympy.core.function.Function.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.numbers.Rational.__div__

def __div__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            if self.p and other.p == S.Zero:
                return S.ComplexInfinity
            else:
                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))
        elif isinstance(other, Rational):
            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))
        elif isinstance(other, Float):
            return self * (1 / other)
        else:
            return Number.__div__(self, other)
    return Number.__div__(self, other)

.sympy.core.expr.Expr._eval_is_negative

def _eval_is_negative(self):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
            if n2 is None:
                raise AttributeError
            if n2._prec == 1:
                raise AttributeError
            if n2 == S.NaN:
                raise AttributeError
        except (AttributeError, ValueError):
            return None
        n, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not n.is_Number:
            return False
        if n._prec != 1 and i._prec != 1:
            return bool(not i and n < 0)
        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.numbers.Number._eval_evalf

def _eval_evalf(self, prec):
    return Float._new(self._as_mpf_val(prec), prec)

.sympy.core.numbers.NaN._as_mpf_val

def _as_mpf_val(self, prec):
    return _mpf_nan

.sympy.core.numbers.Float.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if isinstance(other, NumberSymbol):
        return other.__gt__(self)
    if other.is_real and other.is_number:
        other = other.evalf()
    if isinstance(other, Number) and other is not S.NaN:
        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))
    return Expr.__lt__(self, other)

.sympy.core.add.Add.class_key

def class_key(cls):
    return (3, 1, cls.__name__)

.sympy.core.basic.Basic.xreplace

def xreplace(self, rule):
    value, _ = self._xreplace(rule)
    return value

.sympy.core.basic.Basic._xreplace

def _xreplace(self, rule):
    if self in rule:
        return (rule[self], True)
    elif rule:
        args = []
        changed = False
        for a in self.args:
            try:
                a_xr = a._xreplace(rule)
                args.append(a_xr[0])
                changed |= a_xr[1]
            except AttributeError:
                args.append(a)
        args = tuple(args)
        if changed:
            return (self.func(*args), True)
    return (self, False)

.sympy.simplify.cse_opts.sub_post

def sub_post(e):
    replacements = []
    for node in preorder_traversal(e):
        if isinstance(node, Mul) and node.args[0] is S.One and (node.args[1] is S.NegativeOne):
            replacements.append((node, -Mul._from_args(node.args[2:])))
    for node, replacement in replacements:
        e = e.xreplace({node: replacement})
    return e

.sympy.simplify.simplify.bottom_up

def bottom_up(rv, F, atoms=False, nonbasic=False):
    try:
        if rv.args:
            args = tuple([bottom_up(a, F, atoms, nonbasic) for a in rv.args])
            if args != rv.args:
                rv = rv.func(*args)
            rv = F(rv)
        elif atoms:
            rv = F(rv)
    except AttributeError:
        if nonbasic:
            try:
                rv = F(rv)
            except TypeError:
                pass
    return rv

.sympy.core.expr.Expr.normal

def normal(self):
    from .mul import _unevaluated_Mul
    n, d = self.as_numer_denom()
    if d is S.One:
        return n
    if d.is_Number:
        if d is S.One:
            return n
        else:
            return _unevaluated_Mul(n, 1 / d)
    else:
        return n / d

.sympy.core.expr.Expr.as_numer_denom

def as_numer_denom(self):
    return (self, S.One)

.sympy.core.power.Pow.as_numer_denom

def as_numer_denom(self):
    if not self.is_commutative:
        return (self, S.One)
    base, exp = self.as_base_exp()
    n, d = base.as_numer_denom()
    neg_exp = exp.is_negative
    if not neg_exp and (not (-exp).is_negative):
        neg_exp = _coeff_isneg(exp)
    int_exp = exp.is_integer
    if not (d.is_real or int_exp):
        n = base
        d = S.One
    dnonpos = d.is_nonpositive
    if dnonpos:
        n, d = (-n, -d)
    elif dnonpos is None and (not int_exp):
        n = base
        d = S.One
    if neg_exp:
        n, d = (d, n)
        exp = -exp
    if exp.is_infinite:
        if n is S.One and d is not S.One:
            return (n, self.func(d, exp))
        if n is not S.One and d is S.One:
            return (self.func(n, exp), d)
    return (self.func(n, exp), self.func(d, exp))

.sympy.core.numbers.Integer.__abs__

def __abs__(self):
    if self.p >= 0:
        return self
    else:
        return Integer(-self.p)

.sympy.core.mul.Mul.as_numer_denom

def as_numer_denom(self):
    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
    return (self.func(*numers), self.func(*denoms))

.sympy.core.numbers.Integer.as_numer_denom

def as_numer_denom(self):
    return (self, S.One)

.sympy.core.add.Add.as_numer_denom

def as_numer_denom(self):
    content, expr = self.primitive()
    ncon, dcon = content.as_numer_denom()
    nd = defaultdict(list)
    for f in expr.args:
        ni, di = f.as_numer_denom()
        nd[di].append(ni)
    if S.Zero in nd:
        n = nd.pop(S.Zero)
        assert len(n) == 1
        n = n[0]
        nd[S.One].append(n / S.Zero)
    if len(nd) == 1:
        d, n = nd.popitem()
        return (self.func(*[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d))
    for d, n in nd.items():
        if len(n) == 1:
            nd[d] = n[0]
        else:
            nd[d] = self.func(*n)
    denoms, numers = [list(i) for i in zip(*iter(nd.items()))]
    n, d = (self.func(*[Mul(*denoms[:i] + [numers[i]] + denoms[i + 1:]) for i in range(len(numers))]), Mul(*denoms))
    return (_keep_coeff(ncon, n), _keep_coeff(dcon, d))

.sympy.core.add.Add.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        if a.is_Rational:
            if b.is_Mul:
                rv = ([a, b], [], None)
        if rv:
            if all((s.is_commutative for s in rv[0])):
                return rv
            return ([], rv[0], None)
    terms = {}
    coeff = S.Zero
    order_factors = []
    for o in seq:
        if o.is_Order:
            for o1 in order_factors:
                if o1.contains(o):
                    o = None
                    break
            if o is None:
                continue
            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):
                return ([S.NaN], [], None)
            if coeff.is_Number:
                coeff += o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__add__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            coeff = o.__add__(coeff) if coeff else o
            continue
        elif o is S.ComplexInfinity:
            if coeff.is_finite is False:
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o.is_Add:
            seq.extend(o.args)
            continue
        elif o.is_Mul:
            c, s = o.as_coeff_Mul()
        elif o.is_Pow:
            b, e = o.as_base_exp()
            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):
                seq.append(b ** e)
                continue
            c, s = (S.One, o)
        else:
            c = S.One
            s = o
        if s in terms:
            terms[s] += c
            if terms[s] is S.NaN:
                return ([S.NaN], [], None)
        else:
            terms[s] = c
    newseq = []
    noncommutative = False
    for s, c in terms.items():
        if c is S.Zero:
            continue
        elif c is S.One:
            newseq.append(s)
        elif s.is_Mul:
            cs = s._new_rawargs(*(c,) + s.args)
            newseq.append(cs)
        elif s.is_Add:
            newseq.append(Mul(c, s, evaluate=False))
        else:
            newseq.append(Mul(c, s))
        noncommutative = noncommutative or not s.is_commutative
    if coeff is S.Infinity:
        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]
    elif coeff is S.NegativeInfinity:
        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]
    if coeff is S.ComplexInfinity:
        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]
    if order_factors:
        newseq2 = []
        for t in newseq:
            for o in order_factors:
                if o.contains(t):
                    t = None
                    break
            if t is not None:
                newseq2.append(t)
        newseq = newseq2 + order_factors
        for o in order_factors:
            if o.contains(coeff):
                coeff = S.Zero
                break
    _addsort(newseq)
    if coeff is not S.Zero:
        newseq.insert(0, coeff)
    if noncommutative:
        return ([], newseq, None)
    else:
        return (newseq, [], None)

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.simplify.powsimp.powsimp

def powsimp(expr, deep=False, combine='all', force=False, measure=count_ops):
    from sympy.matrices.expressions.matexpr import MatrixSymbol

    def recurse(arg, **kwargs):
        _deep = kwargs.get('deep', deep)
        _combine = kwargs.get('combine', combine)
        _force = kwargs.get('force', force)
        _measure = kwargs.get('measure', measure)
        return powsimp(arg, _deep, _combine, _force, _measure)
    expr = sympify(expr)
    if not isinstance(expr, Basic) or isinstance(expr, MatrixSymbol) or (expr.is_Atom or expr in (exp_polar(0), exp_polar(1))):
        return expr
    if deep or expr.is_Add or (expr.is_Mul and _y not in expr.args):
        expr = expr.func(*[recurse(w) for w in expr.args])
    if expr.is_Pow:
        return recurse(expr * _y, deep=False) / _y
    if not expr.is_Mul:
        return expr
    if combine in ('exp', 'all'):
        c_powers = defaultdict(list)
        nc_part = []
        newexpr = []
        coeff = S.One
        for term in expr.args:
            if term.is_Rational:
                coeff *= term
                continue
            if term.is_Pow:
                term = _denest_pow(term)
            if term.is_commutative:
                b, e = term.as_base_exp()
                if deep:
                    b, e = [recurse(i) for i in [b, e]]
                if b.is_Pow or isinstance(b, exp):
                    b, e = (b ** e, S.One)
                c_powers[b].append(e)
            else:
                if nc_part:
                    b1, e1 = nc_part[-1].as_base_exp()
                    b2, e2 = term.as_base_exp()
                    if b1 == b2 and e1.is_commutative and e2.is_commutative:
                        nc_part[-1] = Pow(b1, Add(e1, e2))
                        continue
                nc_part.append(term)
        for b, e in ordered(iter(c_powers.items())):
            if b and b.is_Rational and (not all((ei.is_Number for ei in e))) and (coeff is not S.One) and (b not in (S.One, S.NegativeOne)):
                m = multiplicity(abs(b), abs(coeff))
                if m:
                    e.append(m)
                    coeff /= b ** m
            c_powers[b] = Add(*e)
        if coeff is not S.One:
            if coeff in c_powers:
                c_powers[coeff] += S.One
            else:
                c_powers[coeff] = S.One
        c_powers = dict(c_powers)
        be = list(c_powers.items())
        skip = set()
        for b, e in be:
            if b in skip:
                continue
            bpos = b.is_positive or b.is_polar
            if bpos:
                binv = 1 / b
                if b != binv and binv in c_powers:
                    if b.as_numer_denom()[0] is S.One:
                        c_powers.pop(b)
                        c_powers[binv] -= e
                    else:
                        skip.add(binv)
                        e = c_powers.pop(binv)
                        c_powers[b] -= e
        be = list(c_powers.items())
        _n = S.NegativeOne
        for i, (b, e) in enumerate(be):
            if ((-b).is_Symbol or b.is_Add) and -b in c_powers:
                if b.is_positive in (0, 1) or e.is_integer:
                    c_powers[-b] += c_powers.pop(b)
                    if _n in c_powers:
                        c_powers[_n] += e
                    else:
                        c_powers[_n] = e
        c_powers = [(b, e) for b, e in c_powers.items() if e]

        def ratq(x):
            return bkey(x)[0][1]

        def bkey(b, e=None):
            if e is not None:
                if e.is_Integer:
                    return ((b, S.One), e)
                elif e.is_Rational:
                    return ((b, Integer(e.q)), Integer(e.p))
                else:
                    c, m = e.as_coeff_Mul(rational=True)
                    if c is not S.One:
                        if m.is_integer:
                            return ((b, Integer(c.q)), m * Integer(c.p))
                        return ((b ** m, Integer(c.q)), Integer(c.p))
                    else:
                        return ((b ** e, S.One), S.One)
            else:
                return bkey(*b.as_base_exp())

        def update(b):
            newe, r = divmod(common_b[b], b[1])
            if not r:
                common_b.pop(b)
                if newe:
                    for m in Mul.make_args(b[0] ** newe):
                        b, e = bkey(m)
                        if b not in common_b:
                            common_b[b] = 0
                        common_b[b] += e
                        if b[1] != 1:
                            bases.append(b)
        common_b = {}
        done = []
        bases = []
        for b, e in c_powers:
            b, e = bkey(b, e)
            if b in common_b:
                common_b[b] = common_b[b] + e
            else:
                common_b[b] = e
            if b[1] != 1 and b[0].is_Mul:
                bases.append(b)
        c_powers = [(b, e) for b, e in common_b.items() if e]
        bases.sort(key=default_sort_key)
        bases.sort(key=measure, reverse=True)
        for base in bases:
            if base not in common_b:
                continue
            b, exponent = base
            last = False
            qlcm = 1
            while True:
                bstart = b
                qstart = qlcm
                bb = []
                ee = []
                for bi in Mul.make_args(b):
                    bib, bie = bkey(bi)
                    if bib not in common_b or common_b[bib] < bie:
                        ee = bb = []
                        break
                    ee.append([bie, common_b[bib]])
                    bb.append(bib)
                if ee:
                    min1 = ee[0][1] / ee[0][0]
                    for i in range(len(ee)):
                        rat = ee[i][1] / ee[i][0]
                        if rat < 1:
                            break
                        min1 = min(min1, rat)
                    else:
                        for i in range(len(bb)):
                            common_b[bb[i]] -= min1 * ee[i][0]
                            update(bb[i])
                        common_b[base] += min1 * qstart * exponent
                if last or len(common_b) == 1 or all((k[1] == 1 for k in common_b)):
                    break
                qlcm = lcm([ratq(bi) for bi in Mul.make_args(bstart)])
                if qlcm == 1:
                    break
                b = bstart ** qlcm
                qlcm *= qstart
                if all((ratq(bi) == 1 for bi in Mul.make_args(b))):
                    last = True
            b, q = base
            done.append((b, common_b.pop(base) * Rational(1, q)))
        c_powers = done
        for (b, q), e in common_b.items():
            if (b.is_Pow or isinstance(b, exp)) and q is not S.One and (not b.exp.is_Rational):
                b, be = b.as_base_exp()
                b = b ** (be / q)
            else:
                b = root(b, q)
            c_powers.append((b, e))
        check = len(c_powers)
        c_powers = dict(c_powers)
        assert len(c_powers) == check
        newexpr = expr.func(*newexpr + [Pow(b, e) for b, e in c_powers.items()])
        if combine == 'exp':
            return expr.func(newexpr, expr.func(*nc_part))
        else:
            return recurse(expr.func(*nc_part), combine='base') * recurse(newexpr, combine='base')
    elif combine == 'base':
        c_powers = []
        nc_part = []
        for term in expr.args:
            if term.is_commutative:
                c_powers.append(list(term.as_base_exp()))
            else:
                nc_part.append(term)
        for i in range(len(c_powers)):
            b, e = c_powers[i]
            if not (all((x.is_nonnegative for x in b.as_numer_denom())) or e.is_integer or force or b.is_polar):
                continue
            exp_c, exp_t = e.as_coeff_Mul(rational=True)
            if exp_c is not S.One and exp_t is not S.One:
                c_powers[i] = [Pow(b, exp_c), exp_t]
        c_exp = defaultdict(list)
        for b, e in c_powers:
            if deep:
                e = recurse(e)
            c_exp[e].append(b)
        del c_powers
        c_powers = defaultdict(list)
        for e in c_exp:
            bases = c_exp[e]
            if len(bases) == 1:
                new_base = bases[0]
            elif e.is_integer or force:
                new_base = expr.func(*bases)
            else:
                unk = []
                nonneg = []
                neg = []
                for bi in bases:
                    if bi.is_negative:
                        neg.append(bi)
                    elif bi.is_nonnegative:
                        nonneg.append(bi)
                    elif bi.is_polar:
                        nonneg.append(bi)
                    else:
                        unk.append(bi)
                if len(unk) == 1 and (not neg) or (len(neg) == 1 and (not unk)):
                    nonneg.extend(unk + neg)
                    unk = neg = []
                elif neg:
                    israt = False
                    if e.is_Rational:
                        israt = True
                    else:
                        p, d = e.as_numer_denom()
                        if p.is_integer and d.is_integer:
                            israt = True
                    if israt:
                        neg = [-w for w in neg]
                        unk.extend([S.NegativeOne] * len(neg))
                    else:
                        unk.extend(neg)
                        neg = []
                    del israt
                for b in unk:
                    c_powers[b].append(e)
                new_base = expr.func(*nonneg + neg)

                def _terms(e):
                    if e.is_Add:
                        return sum([_terms(ai) for ai in e.args])
                    if e.is_Mul:
                        return prod([_terms(mi) for mi in e.args])
                    return 1
                xnew_base = expand_mul(new_base, deep=False)
                if len(Add.make_args(xnew_base)) < _terms(new_base):
                    new_base = factor_terms(xnew_base)
            c_powers[new_base].append(e)
        c_part = [Pow(b, ei) for b, e in c_powers.items() for ei in e]
        return expr.func(*c_part + nc_part)
    else:
        raise ValueError("combine must be one of ('all', 'exp', 'base').")

.sympy.sets.fancysets.Naturals0._contains

def _contains(self, other):
    if not isinstance(other, Expr):
        return S.false
    elif other.is_integer and other.is_nonnegative:
        return S.true
    elif other.is_integer is False or other.is_nonnegative is False:
        return S.false

.sympy.core.function.Application.eval

def eval(cls, *args):
    return

.sympy.core.singleton.Singleton.__call__

def __call__(self, *args, **kwargs):
    if self not in Singleton._instances:
        Singleton._instances[self] = super(Singleton, self).__call__(*args, **kwargs)
    return Singleton._instances[self]

    def __getnewargs__(self):
        return ()
    self.__getnewargs__ = __getnewargs__

.sympy.core.function.Function._should_evalf

def _should_evalf(cls, arg):
    from sympy.core.symbol import Wild
    if arg.is_Float:
        return arg._prec
    if not arg.is_Add:
        return -1
    a, b = (Wild('a'), Wild('b'))
    m = arg.match(a + b * S.ImaginaryUnit)
    if not m or not (m[a].is_Float or m[b].is_Float):
        return -1
    l = [m[i]._prec for i in m if m[i].is_Float]
    l.append(-1)
    return max(l)

.sympy.simplify.powsimp.recurse

def recurse(arg, **kwargs):
    _deep = kwargs.get('deep', deep)
    _combine = kwargs.get('combine', combine)
    _force = kwargs.get('force', force)
    _measure = kwargs.get('measure', measure)
    return powsimp(arg, _deep, _combine, _force, _measure)

.sympy.core.add.Add.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(radical=radical, clear=clear)) for a in self.args]).primitive()
    if not clear and (not con.is_Integer) and prim.is_Add:
        con, d = con.as_numer_denom()
        _p = prim / d
        if any((a.as_coeff_Mul()[0].is_Integer for a in _p.args)):
            prim = _p
        else:
            con /= d
    if radical and prim.is_Add:
        args = prim.args
        rads = []
        common_q = None
        for m in args:
            term_rads = defaultdict(list)
            for ai in Mul.make_args(m):
                if ai.is_Pow:
                    b, e = ai.as_base_exp()
                    if e.is_Rational and b.is_Integer:
                        term_rads[e.q].append(abs(int(b)) ** e.p)
            if not term_rads:
                break
            if common_q is None:
                common_q = set(term_rads.keys())
            else:
                common_q = common_q & set(term_rads.keys())
                if not common_q:
                    break
            rads.append(term_rads)
        else:
            for r in rads:
                for q in list(r.keys()):
                    if q not in common_q:
                        r.pop(q)
                for q in r:
                    r[q] = prod(r[q])
            G = []
            for q in common_q:
                g = reduce(igcd, [r[q] for r in rads], 0)
                if g != 1:
                    G.append(g ** Rational(1, q))
            if G:
                G = Mul(*G)
                args = [ai / G for ai in args]
                prim = G * prim.func(*args)
    return (con, prim)

.sympy.core.numbers.Rational.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    if self:
        if self.is_positive:
            return (self, S.One)
        return (-self, S.NegativeOne)
    return (S.One, self)

.sympy.core.expr.Expr.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    return (S.One, self)

.sympy.polys.polytools.cancel

def cancel(f, *gens, **args):
    from sympy.core.exprtools import factor_terms
    from sympy.functions.elementary.piecewise import Piecewise
    options.allowed_flags(args, ['polys'])
    f = sympify(f)
    if not isinstance(f, (tuple, Tuple)):
        if f.is_Number or isinstance(f, Relational) or (not isinstance(f, Expr)):
            return f
        f = factor_terms(f, radical=True)
        p, q = f.as_numer_denom()
    elif len(f) == 2:
        p, q = f
    elif isinstance(f, Tuple):
        return factor_terms(f)
    else:
        raise ValueError('unexpected argument: %s' % f)
    try:
        (F, G), opt = parallel_poly_from_expr((p, q), *gens, **args)
    except PolificationFailed:
        if not isinstance(f, (tuple, Tuple)):
            return f
        else:
            return (S.One, p, q)
    except PolynomialError as msg:
        if f.is_commutative and (not f.has(Piecewise)):
            raise PolynomialError(msg)
        if f.is_Add or f.is_Mul:
            sifted = sift(f.args, lambda x: x.is_commutative is True and (not x.has(Piecewise)))
            c, nc = (sifted[True], sifted[False])
            nc = [cancel(i) for i in nc]
            return f.func(cancel(f.func._from_args(c)), *nc)
        else:
            reps = []
            pot = preorder_traversal(f)
            next(pot)
            for e in pot:
                if isinstance(e, (tuple, Tuple, BooleanAtom)):
                    continue
                try:
                    reps.append((e, cancel(e)))
                    pot.skip()
                except NotImplementedError:
                    pass
            return f.xreplace(dict(reps))
    c, P, Q = F.cancel(G)
    if not isinstance(f, (tuple, Tuple)):
        return c * (P.as_expr() / Q.as_expr())
    elif not opt.polys:
        return (c, P.as_expr(), Q.as_expr())
    else:
        return (c, P, Q)

.sympy.polys.polyoptions.allowed_flags

def allowed_flags(args, flags):
    flags = set(flags)
    for arg in args.keys():
        try:
            if Options.__options__[arg].is_Flag and (not arg in flags):
                raise FlagError("'%s' flag is not allowed in this context" % arg)
        except KeyError:
            raise OptionError("'%s' is not a valid option" % arg)

.sympy.core.exprtools.factor_terms

def factor_terms(expr, radical=False, clear=False, fraction=False, sign=True):

    def do(expr):
        from sympy.concrete.summations import Sum
        from sympy.simplify.simplify import factor_sum
        is_iterable = iterable(expr)
        if not isinstance(expr, Basic) or expr.is_Atom:
            if is_iterable:
                return type(expr)([do(i) for i in expr])
            return expr
        if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):
            args = expr.args
            newargs = tuple([do(i) for i in args])
            if newargs == args:
                return expr
            return expr.func(*newargs)
        if isinstance(expr, Sum):
            return factor_sum(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)
        cont, p = expr.as_content_primitive(radical=radical, clear=clear)
        if p.is_Add:
            list_args = [do(a) for a in Add.make_args(p)]
            if all((a.as_coeff_Mul()[0] < 0 for a in list_args)):
                cont = -cont
                list_args = [-a for a in list_args]
            special = {}
            for i, a in enumerate(list_args):
                b, e = a.as_base_exp()
                if e.is_Mul and e != Mul(*e.args):
                    list_args[i] = Dummy()
                    special[list_args[i]] = a
            p = Add._from_args(list_args)
            p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)
        elif p.args:
            p = p.func(*[do(a) for a in p.args])
        rv = _keep_coeff(cont, p, clear=clear, sign=sign)
        return rv
    expr = sympify(expr)
    return do(expr)

.sympy.core.exprtools.do

def do(expr):
    from sympy.concrete.summations import Sum
    from sympy.simplify.simplify import factor_sum
    is_iterable = iterable(expr)
    if not isinstance(expr, Basic) or expr.is_Atom:
        if is_iterable:
            return type(expr)([do(i) for i in expr])
        return expr
    if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):
        args = expr.args
        newargs = tuple([do(i) for i in args])
        if newargs == args:
            return expr
        return expr.func(*newargs)
    if isinstance(expr, Sum):
        return factor_sum(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)
    cont, p = expr.as_content_primitive(radical=radical, clear=clear)
    if p.is_Add:
        list_args = [do(a) for a in Add.make_args(p)]
        if all((a.as_coeff_Mul()[0] < 0 for a in list_args)):
            cont = -cont
            list_args = [-a for a in list_args]
        special = {}
        for i, a in enumerate(list_args):
            b, e = a.as_base_exp()
            if e.is_Mul and e != Mul(*e.args):
                list_args[i] = Dummy()
                special[list_args[i]] = a
        p = Add._from_args(list_args)
        p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)
    elif p.args:
        p = p.func(*[do(a) for a in p.args])
    rv = _keep_coeff(cont, p, clear=clear, sign=sign)
    return rv

.sympy.core.compatibility.iterable

def iterable(i, exclude=(string_types, dict, NotIterable)):
    if hasattr(i, '_iterable'):
        return i._iterable
    try:
        iter(i)
    except TypeError:
        return False
    if exclude:
        return not isinstance(i, exclude)
    return True

.sympy.core.mul.Mul.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    coef = S.One
    args = []
    for i, a in enumerate(self.args):
        c, p = a.as_content_primitive(radical=radical, clear=clear)
        coef *= c
        if p is not S.One:
            args.append(p)
    return (coef, self.func(*args))

.sympy.core.power.Pow.as_content_primitive

def as_content_primitive(self, radical=False, clear=True):
    b, e = self.as_base_exp()
    b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))
    ce, pe = e.as_content_primitive(radical=radical, clear=clear)
    if b.is_Rational:
        h, t = pe.as_coeff_Add()
        if h.is_Rational:
            ceh = ce * h
            c = self.func(b, ceh)
            r = S.Zero
            if not c.is_Rational:
                iceh, r = divmod(ceh.p, ceh.q)
                c = self.func(b, iceh)
            return (c, self.func(b, _keep_coeff(ce, t + r / ce / ceh.q)))
    e = _keep_coeff(ce, pe)
    if e.is_Rational and b.is_Mul:
        h, t = b.as_content_primitive(radical=radical, clear=clear)
        c, m = self.func(h, e).as_coeff_Mul()
        m, me = m.as_base_exp()
        if m is S.One or me == e:
            return (c, self.func(_keep_coeff(m, t), e))
    return (S.One, self.func(b, e))

.sympy.core.exprtools.gcd_terms

def gcd_terms(terms, isprimitive=False, clear=True, fraction=True):

    def mask(terms):
        args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]
        reps = []
        for i, (c, nc) in enumerate(args):
            if nc:
                nc = Mul._from_args(nc)
                d = Dummy()
                reps.append((d, nc))
                c.append(d)
                args[i] = Mul._from_args(c)
            else:
                args[i] = c
        return (args, dict(reps))
    isadd = isinstance(terms, Add)
    addlike = isadd or (not isinstance(terms, Basic) and is_sequence(terms, include=set) and (not isinstance(terms, Dict)))
    if addlike:
        if isadd:
            terms = list(terms.args)
        else:
            terms = sympify(terms)
        terms, reps = mask(terms)
        cont, numer, denom = _gcd_terms(terms, isprimitive, fraction)
        numer = numer.xreplace(reps)
        coeff, factors = cont.as_coeff_Mul()
        if not clear:
            c, _coeff = coeff.as_coeff_Mul()
            if not c.is_Integer and (not clear) and numer.is_Add:
                n, d = c.as_numer_denom()
                _numer = numer / d
                if any((a.as_coeff_Mul()[0].is_Integer for a in _numer.args)):
                    numer = _numer
                    coeff = n * _coeff
        return _keep_coeff(coeff, factors * numer / denom, clear=clear)
    if not isinstance(terms, Basic):
        return terms
    if terms.is_Atom:
        return terms
    if terms.is_Mul:
        c, args = terms.as_coeff_mul()
        return _keep_coeff(c, Mul(*[gcd_terms(i, isprimitive, clear, fraction) for i in args]), clear=clear)

    def handle(a):
        if not isinstance(a, Expr):
            if isinstance(a, Basic):
                return a.func(*[handle(i) for i in a.args])
            return type(a)([handle(i) for i in a])
        return gcd_terms(a, isprimitive, clear, fraction)
    if isinstance(terms, Dict):
        return Dict(*[(k, handle(v)) for k, v in terms.args])
    return terms.func(*[handle(i) for i in terms.args])

.sympy.core.exprtools.mask

def mask(terms):
    args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]
    reps = []
    for i, (c, nc) in enumerate(args):
        if nc:
            nc = Mul._from_args(nc)
            d = Dummy()
            reps.append((d, nc))
            c.append(d)
            args[i] = Mul._from_args(c)
        else:
            args[i] = c
    return (args, dict(reps))

.sympy.core.exprtools._gcd_terms

def _gcd_terms(terms, isprimitive=False, fraction=True):
    if isinstance(terms, Basic) and (not isinstance(terms, Tuple)):
        terms = Add.make_args(terms)
    terms = list(map(Term, [t for t in terms if t]))
    if len(terms) == 0:
        return (S.Zero, S.Zero, S.One)
    if len(terms) == 1:
        cont = terms[0].coeff
        numer = terms[0].numer.as_expr()
        denom = terms[0].denom.as_expr()
    else:
        cont = terms[0]
        for term in terms[1:]:
            cont = cont.gcd(term)
        for i, term in enumerate(terms):
            terms[i] = term.quo(cont)
        if fraction:
            denom = terms[0].denom
            for term in terms[1:]:
                denom = denom.lcm(term.denom)
            numers = []
            for term in terms:
                numer = term.numer.mul(denom.quo(term.denom))
                numers.append(term.coeff * numer.as_expr())
        else:
            numers = [t.as_expr() for t in terms]
            denom = Term(S(1)).numer
        cont = cont.as_expr()
        numer = Add(*numers)
        denom = denom.as_expr()
    if not isprimitive and numer.is_Add:
        _cont, numer = numer.primitive()
        cont *= _cont
    return (cont, numer, denom)

.sympy.core.exprtools.Term.__init__

def __init__(self, term, numer=None, denom=None):
    if numer is None and denom is None:
        if not term.is_commutative:
            raise NonCommutativeExpression('commutative expression expected')
        coeff, factors = term.as_coeff_mul()
        numer, denom = (defaultdict(int), defaultdict(int))
        for factor in factors:
            base, exp = decompose_power(factor)
            if base.is_Add:
                cont, base = base.primitive()
                coeff *= cont ** exp
            if exp > 0:
                numer[base] += exp
            else:
                denom[base] += -exp
        numer = Factors(numer)
        denom = Factors(denom)
    else:
        coeff = term
        if numer is None:
            numer = Factors()
        if denom is None:
            denom = Factors()
    self.coeff = coeff
    self.numer = numer
    self.denom = denom

.sympy.core.expr.Expr.as_coeff_mul

def as_coeff_mul(self, *deps, **kwargs):
    if deps:
        if not self.has(*deps):
            return (self, tuple())
    return (S.One, (self,))

.sympy.core.exprtools.decompose_power

def decompose_power(expr):
    base, exp = expr.as_base_exp()
    if exp.is_Number:
        if exp.is_Rational:
            if not exp.is_Integer:
                base = Pow(base, Rational(1, exp.q))
            exp = exp.p
        else:
            base, exp = (expr, 1)
    else:
        exp, tail = exp.as_coeff_Mul(rational=True)
        if exp is S.NegativeOne:
            base, exp = (Pow(base, tail), -1)
        elif exp is not S.One:
            tail = _keep_coeff(Rational(1, exp.q), tail)
            base, exp = (Pow(base, tail), exp.p)
        else:
            base, exp = (expr, 1)
    return (base, exp)

.sympy.core.exprtools.Factors.__init__

def __init__(self, factors=None):
    if isinstance(factors, (SYMPY_INTS, float)):
        factors = S(factors)
    if isinstance(factors, Factors):
        factors = factors.factors.copy()
    elif factors is None or factors is S.One:
        factors = {}
    elif factors is S.Zero or factors == 0:
        factors = {S.Zero: S.One}
    elif isinstance(factors, Number):
        n = factors
        factors = {}
        if n < 0:
            factors[S.NegativeOne] = S.One
            n = -n
        if n is not S.One:
            if n.is_Float or n.is_Integer or n is S.Infinity:
                factors[n] = S.One
            elif n.is_Rational:
                if n.p != 1:
                    factors[Integer(n.p)] = S.One
                factors[Integer(n.q)] = S.NegativeOne
            else:
                raise ValueError('Expected Float|Rational|Integer, not %s' % n)
    elif isinstance(factors, Basic) and (not factors.args):
        factors = {factors: S.One}
    elif isinstance(factors, Expr):
        c, nc = factors.args_cnc()
        i = c.count(I)
        for _ in range(i):
            c.remove(I)
        factors = dict(Mul._from_args(c).as_powers_dict())
        if i:
            factors[I] = S.One * i
        if nc:
            factors[Mul(*nc, evaluate=False)] = S.One
    else:
        factors = factors.copy()
        handle = []
        for k in factors:
            if k is I or k in (-1, 1):
                handle.append(k)
        if handle:
            i1 = S.One
            for k in handle:
                if not _isnumber(factors[k]):
                    continue
                i1 *= k ** factors.pop(k)
            if i1 is not S.One:
                for a in i1.args if i1.is_Mul else [i1]:
                    if a is S.NegativeOne:
                        factors[a] = S.One
                    elif a is I:
                        factors[I] = S.One
                    elif a.is_Pow:
                        if S.NegativeOne not in factors:
                            factors[S.NegativeOne] = S.Zero
                        factors[S.NegativeOne] += a.exp
                    elif a == 1:
                        factors[a] = S.One
                    elif a == -1:
                        factors[-a] = S.One
                        factors[S.NegativeOne] = S.One
                    else:
                        raise ValueError('unexpected factor in i1: %s' % a)
    self.factors = factors
    try:
        self.gens = frozenset(factors.keys())
    except AttributeError:
        raise TypeError('expecting Expr or dictionary')

.sympy.core.exprtools.Term.gcd

def gcd(self, other):
    return Term(self.coeff.gcd(other.coeff), self.numer.gcd(other.numer), self.denom.gcd(other.denom))

.sympy.core.numbers.Rational.gcd

def gcd(self, other):
    if isinstance(other, Rational):
        if other is S.Zero:
            return other
        return Rational(Integer(igcd(self.p, other.p)), Integer(ilcm(self.q, other.q)))
    return Number.gcd(self, other)

.sympy.core.exprtools.Factors.gcd

def gcd(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
        if other.is_zero:
            return Factors(self.factors)
    factors = {}
    for factor, exp in self.factors.items():
        factor, exp = (sympify(factor), sympify(exp))
        if factor in other.factors:
            lt = (exp - other.factors[factor]).is_negative
            if lt == True:
                factors[factor] = exp
            elif lt == False:
                factors[factor] = other.factors[factor]
    return Factors(factors)

.sympy.core.exprtools.Term.quo

def quo(self, other):
    return self.mul(other.inv())

.sympy.core.exprtools.Term.inv

def inv(self):
    return Term(1 / self.coeff, self.denom, self.numer)

.sympy.core.expr.Expr.__rdiv__

def __rdiv__(self, other):
    return Mul(other, Pow(self, S.NegativeOne))

.sympy.core.exprtools.Term.mul

def mul(self, other):
    coeff = self.coeff * other.coeff
    numer = self.numer.mul(other.numer)
    denom = self.denom.mul(other.denom)
    numer, denom = numer.normal(denom)
    return Term(coeff, numer, denom)

.sympy.core.exprtools.Factors.mul

def mul(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
    if any((f.is_zero for f in (self, other))):
        return Factors(S.Zero)
    factors = dict(self.factors)
    for factor, exp in other.factors.items():
        if factor in factors:
            exp = factors[factor] + exp
            if not exp:
                del factors[factor]
                continue
        factors[factor] = exp
    return Factors(factors)

.sympy.core.exprtools.Factors.is_zero

def is_zero(self):
    f = self.factors
    return len(f) == 1 and S.Zero in f

.sympy.core.exprtools.Factors.normal

def normal(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
        if other.is_zero:
            return (Factors(), Factors(S.Zero))
        if self.is_zero:
            return (Factors(S.Zero), Factors())
    self_factors = dict(self.factors)
    other_factors = dict(other.factors)
    for factor, self_exp in self.factors.items():
        try:
            other_exp = other.factors[factor]
        except KeyError:
            continue
        exp = self_exp - other_exp
        if not exp:
            del self_factors[factor]
            del other_factors[factor]
        elif _isnumber(exp):
            if exp > 0:
                self_factors[factor] = exp
                del other_factors[factor]
            else:
                del self_factors[factor]
                other_factors[factor] = -exp
        else:
            r = self_exp.extract_additively(other_exp)
            if r is not None:
                if r:
                    self_factors[factor] = r
                    del other_factors[factor]
                else:
                    del self_factors[factor]
                    del other_factors[factor]
            else:
                sc, sa = self_exp.as_coeff_Add()
                if sc:
                    oc, oa = other_exp.as_coeff_Add()
                    diff = sc - oc
                    if diff > 0:
                        self_factors[factor] -= oc
                        other_exp = oa
                    elif diff < 0:
                        self_factors[factor] -= sc
                        other_factors[factor] -= sc
                        other_exp = oa - diff
                    else:
                        self_factors[factor] = sa
                        other_exp = oa
                if other_exp:
                    other_factors[factor] = other_exp
                else:
                    del other_factors[factor]
    return (Factors(self_factors), Factors(other_factors))

.sympy.core.exprtools.Term.as_expr

def as_expr(self):
    return self.coeff * (self.numer.as_expr() / self.denom.as_expr())

.sympy.core.exprtools.Factors.as_expr

def as_expr(self):
    args = []
    for factor, exp in self.factors.items():
        if exp != 1:
            b, e = factor.as_base_exp()
            if isinstance(exp, int):
                e = _keep_coeff(Integer(exp), e)
            elif isinstance(exp, Rational):
                e = _keep_coeff(exp, e)
            else:
                e *= exp
            args.append(b ** e)
        else:
            args.append(factor)
    return Mul(*args)

.sympy.core.expr.Expr.__pow__

def __pow__(self, other):
    return Pow(self, other)

.sympy.core.numbers.Number.as_coeff_mul

def as_coeff_mul(self, *deps, **kwargs):
    if self.is_Rational or not kwargs.pop('rational', True):
        return (self, tuple())
    elif self.is_negative:
        return (S.NegativeOne, (-self,))
    return (S.One, (self,))

.sympy.core.mul.Mul._eval_is_real

def _eval_is_real(self):
    return self._eval_real_imag(True)

.sympy.core.mul.Mul._eval_real_imag

def _eval_real_imag(self, real):
    zero = False
    t_not_re_im = None
    for t in self.args:
        if not t.is_complex:
            return t.is_complex
        elif t.is_imaginary:
            real = not real
        elif t.is_real:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_real is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        elif t.is_imaginary is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        else:
            return
    if t_not_re_im:
        if t_not_re_im.is_real is False:
            if real:
                return zero
        if t_not_re_im.is_imaginary is False:
            if not real:
                return zero
    elif zero is False:
        return real
    elif real:
        return real

.sympy.core.logic._fuzzy_group

def _fuzzy_group(args, quick_exit=False):
    saw_other = False
    for a in args:
        if a is True:
            continue
        if a is None:
            return
        if quick_exit and saw_other:
            return
        saw_other = True
    return not saw_other

.sympy.core.power.Pow._eval_is_complex

def _eval_is_complex(self):
    if all((a.is_complex for a in self.args)):
        return True

.sympy.core.add.Add._eval_is_imaginary

def _eval_is_imaginary(self):
    nz = []
    im_I = []
    for a in self.args:
        if a.is_real:
            if a.is_zero:
                pass
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im_I.append(a * S.ImaginaryUnit)
        elif (S.ImaginaryUnit * a).is_real:
            im_I.append(a * S.ImaginaryUnit)
        else:
            return
    b = self.func(*nz)
    if b.is_zero:
        return fuzzy_not(self.func(*im_I).is_zero)
    elif b.is_zero is False:
        return False

.sympy.core.power.Pow._eval_is_real

def _eval_is_real(self):
    from sympy import arg, exp, log, Mul
    real_b = self.base.is_real
    if real_b is None:
        if self.base.func == exp and self.base.args[0].is_imaginary:
            return self.exp.is_imaginary
        return
    real_e = self.exp.is_real
    if real_e is None:
        return
    if real_b and real_e:
        if self.base.is_positive:
            return True
        elif self.base.is_nonnegative:
            if self.exp.is_nonnegative:
                return True
        elif self.exp.is_integer:
            return True
        elif self.base.is_negative:
            if self.exp.is_Rational:
                return False
    if real_e and self.exp.is_negative:
        return Pow(self.base, -self.exp).is_real
    im_b = self.base.is_imaginary
    im_e = self.exp.is_imaginary
    if im_b:
        if self.exp.is_integer:
            if self.exp.is_even:
                return True
            elif self.exp.is_odd:
                return False
        elif im_e and log(self.base).is_imaginary:
            return True
        elif self.exp.is_Add:
            c, a = self.exp.as_coeff_Add()
            if c and c.is_Integer:
                return Mul(self.base ** c, self.base ** a, evaluate=False).is_real
        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
            if (self.exp / 2).is_integer is False:
                return False
    if real_b and im_e:
        if self.base is S.NegativeOne:
            return True
        c = self.exp.coeff(S.ImaginaryUnit)
        if c:
            ok = (c * log(self.base) / S.Pi).is_Integer
            if ok is not None:
                return ok
    if real_b is False:
        i = arg(self.base) * self.exp / S.Pi
        return i.is_integer

.sympy.core.power.Pow._eval_is_zero

def _eval_is_zero(self):
    if self.base.is_zero:
        if self.exp.is_positive:
            return True
        elif self.exp.is_nonpositive:
            return False
    elif self.base.is_zero is False:
        if self.exp.is_finite:
            return False
        elif self.exp.is_infinite:
            if (1 - abs(self.base)).is_positive:
                return self.exp.is_positive
            elif (1 - abs(self.base)).is_negative:
                return self.exp.is_negative
    else:
        return None

.sympy.core.add.Add._eval_is_zero

def _eval_is_zero(self):
    if self.is_commutative is False:
        return
    nz = []
    z = 0
    im_or_z = False
    im = False
    for a in self.args:
        if a.is_real:
            if a.is_zero:
                z += 1
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im = True
        elif (S.ImaginaryUnit * a).is_real:
            im_or_z = True
        else:
            return
    if z == len(self.args):
        return True
    if len(nz) == len(self.args):
        return None
    b = self.func(*nz)
    if b.is_zero:
        if not im_or_z and (not im):
            return True
        if im and (not im_or_z):
            return False
    if b.is_zero is False:
        return False

.sympy.core.add.Add._eval_is_nonpositive

def _eval_is_nonpositive(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_nonpositive:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_nonpositive:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_nonpositive:
                        return True

.sympy.core.add.Add._eval_is_negative

def _eval_is_negative(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_negative()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_negative and a.is_nonpositive:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_negative:
                    return True
    neg = nonpos = nonneg = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        isneg = a.is_negative
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((isneg, a.is_nonpositive)))
            if True in saw_INF and False in saw_INF:
                return
        if isneg:
            neg = True
            continue
        elif a.is_nonpositive:
            nonpos = True
            continue
        elif a.is_nonnegative:
            nonneg = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonneg and (not nonpos) and neg:
        return True
    elif not nonneg and neg:
        return True
    elif not neg and (not nonpos):
        return False

.sympy.core.operations.AssocOp._eval_evalf

def _eval_evalf(self, prec):
    from .add import Add
    from .mul import Mul
    from .symbol import Symbol
    from .function import AppliedUndef
    if isinstance(self, (Mul, Add)):
        x, tail = self.as_independent(Symbol, AppliedUndef)
        if not (tail is self.identity or (isinstance(x, AssocOp) and x.is_Function) or (x is self.identity and isinstance(tail, AssocOp))):
            x = x._evalf(prec) if x is not self.identity else self.identity
            args = []
            tail_args = tuple(self.func.make_args(tail))
            for a in tail_args:
                newa = a._eval_evalf(prec)
                if newa is None:
                    args.append(a)
                else:
                    args.append(newa)
            return self.func(x, *args)
    args = []
    for a in self.args:
        newa = a._eval_evalf(prec)
        if newa is None:
            args.append(a)
        else:
            args.append(newa)
    return self.func(*args)

.sympy.core.expr.Expr.as_independent

def as_independent(self, *deps, **hint):
    from .symbol import Symbol
    from .add import _unevaluated_Add
    from .mul import _unevaluated_Mul
    from sympy.utilities.iterables import sift
    if self.is_zero:
        return (S.Zero, S.Zero)
    func = self.func
    if hint.get('as_Add', func is Add):
        want = Add
    else:
        want = Mul
    sym = set()
    other = []
    for d in deps:
        if isinstance(d, Symbol):
            sym.add(d)
        else:
            other.append(d)

    def has(e):
        has_other = e.has(*other)
        if not sym:
            return has_other
        return has_other or e.has(*e.free_symbols & sym)
    if want is not func or (func is not Add and func is not Mul):
        if has(self):
            return (want.identity, self)
        else:
            return (self, want.identity)
    elif func is Add:
        args = list(self.args)
    else:
        args, nc = self.args_cnc()
    d = sift(args, lambda x: has(x))
    depend = d[True]
    indep = d[False]
    if func is Add:
        return (Add(*indep), _unevaluated_Add(*depend))
    else:
        for i, n in enumerate(nc):
            if has(n):
                depend.extend(nc[i:])
                break
            indep.append(n)
        return (Mul(*indep), Mul(*depend, evaluate=False) if nc else _unevaluated_Mul(*depend))

.sympy.utilities.iterables.sift

def sift(seq, keyfunc):
    m = defaultdict(list)
    for i in seq:
        m[keyfunc(i)].append(i)
    return m

.sympy.core.expr.Expr.has

def has(e):
    has_other = e.has(*other)
    if not sym:
        return has_other
    return has_other or e.has(*e.free_symbols & sym)

.sympy.core.basic.Basic.has

def has(self, *patterns):
    return any((self._has(pattern) for pattern in patterns))

.sympy.core.basic.Basic._has

def _has(self, pattern):
    from sympy.core.function import UndefinedFunction, Function
    if isinstance(pattern, UndefinedFunction):
        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))
    pattern = sympify(pattern)
    if isinstance(pattern, BasicMeta):
        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))
    try:
        match = pattern._has_matcher()
        return any((match(arg) for arg in preorder_traversal(self)))
    except AttributeError:
        return any((arg == pattern for arg in preorder_traversal(self)))

.sympy.core.add._unevaluated_Add

def _unevaluated_Add(*args):
    args = list(args)
    newargs = []
    co = S.Zero
    while args:
        a = args.pop()
        if a.is_Add:
            args.extend(a.args)
        elif a.is_Number:
            co += a
        else:
            newargs.append(a)
    _addsort(newargs)
    if co:
        newargs.insert(0, co)
    return Add._from_args(newargs)

.sympy.core.power.Pow._eval_evalf

def _eval_evalf(self, prec):
    base, exp = self.as_base_exp()
    base = base._evalf(prec)
    if not exp.is_Integer:
        exp = exp._evalf(prec)
    if exp.is_negative and base.is_number and (base.is_real is False):
        base = base.conjugate() / (base * base.conjugate())._evalf(prec)
        exp = -exp
        return self.func(base, exp).expand()
    return self.func(base, exp)

.sympy.core.evalf.EvalfMixin._evalf

def _evalf(self, prec):
    r = self._eval_evalf(prec)
    if r is None:
        r = self
    return r

.sympy.core.function.Function._eval_evalf

def _eval_evalf(self, prec):
    fname = self.func.__name__
    try:
        if not hasattr(mpmath, fname):
            from sympy.utilities.lambdify import MPMATH_TRANSLATIONS
            fname = MPMATH_TRANSLATIONS[fname]
        func = getattr(mpmath, fname)
    except (AttributeError, KeyError):
        try:
            return Float(self._imp_(*[i.evalf(prec) for i in self.args]), prec)
        except (AttributeError, TypeError, ValueError):
            return
    try:
        args = [arg._to_mpmath(prec + 5) for arg in self.args]

        def bad(m):
            from mpmath import mpf, mpc
            if isinstance(m, mpf):
                m = m._mpf_
                return m[1] != 1 and m[-1] == 1
            elif isinstance(m, mpc):
                m, n = m._mpc_
                return m[1] != 1 and m[-1] == 1 and (n[1] != 1) and (n[-1] == 1)
            else:
                return False
        if any((bad(a) for a in args)):
            raise ValueError
    except ValueError:
        return
    with mpmath.workprec(prec):
        v = func(*args)
    return Expr._from_mpmath(v, prec)

.sympy.core.evalf.EvalfMixin._to_mpmath

def _to_mpmath(self, prec, allow_ints=True):
    errmsg = 'cannot convert to mpmath number'
    if allow_ints and self.is_Integer:
        return self.p
    if hasattr(self, '_as_mpf_val'):
        return make_mpf(self._as_mpf_val(prec))
    try:
        re, im, _, _ = evalf(self, prec, {})
        if im:
            if not re:
                re = fzero
            return make_mpc((re, im))
        elif re:
            return make_mpf(re)
        else:
            return make_mpf(fzero)
    except NotImplementedError:
        v = self._eval_evalf(prec)
        if v is None:
            raise ValueError(errmsg)
        if v.is_Float:
            return make_mpf(v._mpf_)
        re, im = v.as_real_imag()
        if allow_ints and re.is_Integer:
            re = from_int(re.p)
        elif re.is_Float:
            re = re._mpf_
        else:
            raise ValueError(errmsg)
        if allow_ints and im.is_Integer:
            im = from_int(im.p)
        elif im.is_Float:
            im = im._mpf_
        else:
            raise ValueError(errmsg)
        return make_mpc((re, im))

.sympy.core.function.Function.bad

def bad(m):
    from mpmath import mpf, mpc
    if isinstance(m, mpf):
        m = m._mpf_
        return m[1] != 1 and m[-1] == 1
    elif isinstance(m, mpc):
        m, n = m._mpc_
        return m[1] != 1 and m[-1] == 1 and (n[1] != 1) and (n[-1] == 1)
    else:
        return False

.sympy.core.expr.Expr._from_mpmath

def _from_mpmath(x, prec):
    from sympy import Float
    if hasattr(x, '_mpf_'):
        return Float._new(x._mpf_, prec)
    elif hasattr(x, '_mpc_'):
        re, im = x._mpc_
        re = Float._new(re, prec)
        im = Float._new(im, prec) * S.ImaginaryUnit
        return re + im
    else:
        raise TypeError('expected mpmath number (mpf or mpc)')

.sympy.core.numbers.Float._eval_is_negative

def _eval_is_negative(self):
    if self._mpf_ == _mpf_ninf:
        return True
    if self._mpf_ == _mpf_inf:
        return False
    return self.num < 0

.sympy.core.numbers.Float.num

def num(self):
    return mpmath.mpf(self._mpf_)

.sympy.core.numbers.Float._eval_power

def _eval_power(self, expt):
    if self == 0:
        if expt.is_positive:
            return S.Zero
        if expt.is_negative:
            return Float('inf')
    if isinstance(expt, Number):
        if isinstance(expt, Integer):
            prec = self._prec
            return Float._new(mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
        elif isinstance(expt, Rational) and expt.p == 1 and expt.q % 2 and self.is_negative:
            return Pow(S.NegativeOne, expt, evaluate=False) * (-self)._eval_power(expt)
        expt, prec = expt._as_mpf_op(self._prec)
        mpfself = self._mpf_
        try:
            y = mpf_pow(mpfself, expt, prec, rnd)
            return Float._new(y, prec)
        except mlib.ComplexResult:
            re, im = mlib.mpc_pow((mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)
            return Float._new(re, prec) + Float._new(im, prec) * S.ImaginaryUnit

.sympy.core.numbers.Rational.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p + self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return other + self
        else:
            return Number.__add__(self, other)
    return Number.__add__(self, other)

.sympy.core.numbers.Float.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        rhs, prec = other._as_mpf_op(self._prec)
        return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
    return Number.__add__(self, other)

.sympy.core.numbers.Number._as_mpf_op

def _as_mpf_op(self, prec):
    prec = max(prec, self._prec)
    return (self._as_mpf_val(prec), prec)

.sympy.core.numbers.Float._as_mpf_op

def _as_mpf_op(self, prec):
    return (self._mpf_, max(prec, self._prec))

.sympy.core.add.Add._eval_is_positive

def _eval_is_positive(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_positive()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_positive and a.is_nonnegative:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_positive:
                    return True
    pos = nonneg = nonpos = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        ispos = a.is_positive
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((ispos, a.is_nonnegative)))
            if True in saw_INF and False in saw_INF:
                return
        if ispos:
            pos = True
            continue
        elif a.is_nonnegative:
            nonneg = True
            continue
        elif a.is_nonpositive:
            nonpos = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonpos and (not nonneg) and pos:
        return True
    elif not nonpos and pos:
        return True
    elif not pos and (not nonneg):
        return False

.sympy.core.expr.Expr._eval_is_positive

def _eval_is_positive(self):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
            if n2 is None:
                raise AttributeError
            if n2._prec == 1:
                raise AttributeError
            if n2 == S.NaN:
                raise AttributeError
        except (AttributeError, ValueError):
            return None
        n, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not n.is_Number:
            return False
        if n._prec != 1 and i._prec != 1:
            return bool(not i and n > 0)
        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.numbers.Float.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s > %s' % (self, other))
    if isinstance(other, NumberSymbol):
        return other.__lt__(self)
    if other.is_comparable:
        other = other.evalf()
    if isinstance(other, Number) and other is not S.NaN:
        return _sympify(bool(mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))
    return Expr.__gt__(self, other)

.sympy.core.basic.Basic.is_comparable

def is_comparable(self):
    is_real = self.is_real
    if is_real is False:
        return False
    is_number = self.is_number
    if is_number is False:
        return False
    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]
    if not i.is_Number or not n.is_Number:
        return False
    if i:
        return False
    else:
        return n._prec != 1

.sympy.core.power.Pow._eval_is_rational

def _eval_is_rational(self):
    p = self.func(*self.as_base_exp())
    if not p.is_Pow:
        return p.is_rational
    b, e = p.as_base_exp()
    if e.is_Rational and b.is_Rational:
        return False
    if e.is_integer:
        if b.is_rational:
            if fuzzy_not(b.is_zero) or e.is_nonnegative:
                return True
            if b == e:
                return True
        elif b.is_irrational:
            return e.is_zero

.sympy.core.add.Add._eval_is_odd

def _eval_is_odd(self):
    l = [f for f in self.args if not f.is_even is True]
    if not l:
        return False
    if l[0].is_odd:
        return self._new_rawargs(*l[1:]).is_even

.sympy.core.power.Pow._eval_is_algebraic

def _eval_is_algebraic(self):

    def _is_one(expr):
        try:
            return (expr - 1).is_zero
        except ValueError:
            return False
    if self.base.is_zero or _is_one(self.base):
        return True
    elif self.exp.is_rational:
        if self.base.is_algebraic is False:
            return self.exp.is_zero
        return self.base.is_algebraic
    elif self.base.is_algebraic and self.exp.is_algebraic:
        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:
            return self.exp.is_rational

.sympy.core.power.Pow._is_one

def _is_one(expr):
    try:
        return (expr - 1).is_zero
    except ValueError:
        return False

.sympy.core.add.Add._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all((x.is_rational is True for x in others)):
                return True
            return None
        if a is None:
            return
    return False

.sympy.core.expr.Expr.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.mul.Mul.as_base_exp

def as_base_exp(self):
    e1 = None
    bases = []
    nc = 0
    for m in self.args:
        b, e = m.as_base_exp()
        if not b.is_commutative:
            nc += 1
        if e1 is None:
            e1 = e
        elif e != e1 or nc > 1:
            return (self, S.One)
        bases.append(b)
    return (self.func(*bases), e1)

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.mul.Mul.as_coeff_mul

def as_coeff_mul(self, *deps, **kwargs):
    rational = kwargs.pop('rational', True)
    if deps:
        l1 = []
        l2 = []
        for f in self.args:
            if f.has(*deps):
                l2.append(f)
            else:
                l1.append(f)
        return (self._new_rawargs(*l1), tuple(l2))
    args = self.args
    if args[0].is_Number:
        if not rational or args[0].is_Rational:
            return (args[0], args[1:])
        elif args[0].is_negative:
            return (S.NegativeOne, (-args[0],) + args[1:])
    return (S.One, args)

.sympy.core.numbers.Integer._eval_power

def _eval_power(self, expt):
    from sympy import perfect_power
    if expt is S.Infinity:
        if self.p > S.One:
            return S.Infinity
        return S.Infinity + S.ImaginaryUnit * S.Infinity
    if expt is S.NegativeInfinity:
        return Rational(1, self) ** S.Infinity
    if not isinstance(expt, Number):
        if self.is_negative and expt.is_even:
            return (-self) ** expt
    if isinstance(expt, Float):
        return super(Integer, self)._eval_power(expt)
    if not isinstance(expt, Rational):
        return
    if expt is S.Half and self.is_negative:
        return S.ImaginaryUnit * Pow(-self, expt)
    if expt.is_negative:
        ne = -expt
        if self.is_negative:
            if expt.q != 1:
                return -S.NegativeOne ** (expt.p % expt.q / S(expt.q)) * Rational(1, -self) ** ne
            else:
                return S.NegativeOne ** ne * Rational(1, -self) ** ne
        else:
            return Rational(1, self.p) ** ne
    x, xexact = integer_nthroot(abs(self.p), expt.q)
    if xexact:
        result = Integer(x ** abs(expt.p))
        if self.is_negative:
            result *= S.NegativeOne ** expt
        return result
    b_pos = int(abs(self.p))
    p = perfect_power(b_pos)
    if p is not False:
        dict = {p[0]: p[1]}
    else:
        dict = Integer(self).factors(limit=2 ** 15)
    if self.is_negative:
        dict[-1] = 1
    out_int = 1
    out_rad = 1
    sqr_int = 1
    sqr_gcd = 0
    sqr_dict = {}
    for prime, exponent in dict.items():
        exponent *= expt.p
        div_e, div_m = divmod(exponent, expt.q)
        if div_e > 0:
            out_int *= prime ** div_e
        if div_m > 0:
            g = igcd(div_m, expt.q)
            if g != 1:
                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))
            else:
                sqr_dict[prime] = div_m
    for p, ex in sqr_dict.items():
        if sqr_gcd == 0:
            sqr_gcd = ex
        else:
            sqr_gcd = igcd(sqr_gcd, ex)
            if sqr_gcd == 1:
                break
    for k, v in sqr_dict.items():
        sqr_int *= k ** (v // sqr_gcd)
    if sqr_int == self and out_int == 1 and (out_rad == 1):
        result = None
    else:
        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))
    return result

.sympy.core.numbers.Rational.__hash__

def __hash__(self):
    return super(Rational, self).__hash__()

.sympy.core.numbers.Rational._hashable_content

def _hashable_content(self):
    return (self.p, self.q)

.sympy.polys.polytools.parallel_poly_from_expr

def parallel_poly_from_expr(exprs, *gens, **args):
    opt = options.build_options(gens, args)
    return _parallel_poly_from_expr(exprs, opt)

.sympy.polys.polyoptions.build_options

def build_options(gens, args=None):
    if args is None:
        gens, args = ((), gens)
    if len(args) != 1 or 'opt' not in args or gens:
        return Options(gens, args)
    else:
        return args['opt']

.sympy.polys.polyoptions.Options.__init__

def __init__(self, gens, args, flags=None, strict=False):
    dict.__init__(self)
    if gens and args.get('gens', ()):
        raise OptionError("both '*gens' and keyword argument 'gens' supplied")
    elif gens:
        args = dict(args)
        args['gens'] = gens
    defaults = args.pop('defaults', {})

    def preprocess_options(args):
        for option, value in args.items():
            try:
                cls = self.__options__[option]
            except KeyError:
                raise OptionError("'%s' is not a valid option" % option)
            if issubclass(cls, Flag):
                if flags is None or option not in flags:
                    if strict:
                        raise OptionError("'%s' flag is not allowed in this context" % option)
            if value is not None:
                self[option] = cls.preprocess(value)
    preprocess_options(args)
    for key, value in dict(defaults).items():
        if key in self:
            del defaults[key]
        else:
            for option in self.keys():
                cls = self.__options__[option]
                if key in cls.excludes:
                    del defaults[key]
                    break
    preprocess_options(defaults)
    for option in self.keys():
        cls = self.__options__[option]
        for require_option in cls.requires:
            if self.get(require_option) is None:
                raise OptionError("'%s' option is only allowed together with '%s'" % (option, require_option))
        for exclude_option in cls.excludes:
            if self.get(exclude_option) is not None:
                raise OptionError("'%s' option is not allowed together with '%s'" % (option, exclude_option))
    for option in self.__order__:
        self.__options__[option].postprocess(self)

.sympy.polys.polyoptions.Options.preprocess_options

def preprocess_options(args):
    for option, value in args.items():
        try:
            cls = self.__options__[option]
        except KeyError:
            raise OptionError("'%s' is not a valid option" % option)
        if issubclass(cls, Flag):
            if flags is None or option not in flags:
                if strict:
                    raise OptionError("'%s' flag is not allowed in this context" % option)
        if value is not None:
            self[option] = cls.preprocess(value)

.sympy.polys.polyoptions.Option.postprocess

def postprocess(cls, options):
    pass

.sympy.polys.polyoptions.Extension.postprocess

def postprocess(cls, options):
    if 'extension' in options and options['extension'] is not True:
        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])

.sympy.polys.polyoptions.Gaussian.postprocess

def postprocess(cls, options):
    if 'gaussian' in options and options['gaussian'] is True:
        options['extension'] = set([S.ImaginaryUnit])
        Extension.postprocess(options)

.sympy.polys.polyoptions.Domain.postprocess

def postprocess(cls, options):
    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):
        raise GeneratorsError('ground domain and generators interfere together')
    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):
        raise GeneratorsError('you have to provide generators because EX domain was requested')

.sympy.polys.polyoptions.Auto.postprocess

def postprocess(cls, options):
    if ('domain' in options or 'field' in options) and 'auto' not in options:
        options['auto'] = False

.sympy.polys.polyoptions.Modulus.postprocess

def postprocess(cls, options):
    if 'modulus' in options:
        modulus = options['modulus']
        symmetric = options.get('symmetric', True)
        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)

.sympy.polys.polyoptions.Split.postprocess

def postprocess(cls, options):
    if 'split' in options:
        raise NotImplementedError("'split' option is not implemented yet")

.sympy.polys.polytools._parallel_poly_from_expr

def _parallel_poly_from_expr(exprs, opt):
    from sympy.functions.elementary.piecewise import Piecewise
    if len(exprs) == 2:
        f, g = exprs
        if isinstance(f, Poly) and isinstance(g, Poly):
            f = f.__class__._from_poly(f, opt)
            g = g.__class__._from_poly(g, opt)
            f, g = f.unify(g)
            opt.gens = f.gens
            opt.domain = f.domain
            if opt.polys is None:
                opt.polys = True
            return ([f, g], opt)
    origs, exprs = (list(exprs), [])
    _exprs, _polys = ([], [])
    failed = False
    for i, expr in enumerate(origs):
        expr = sympify(expr)
        if isinstance(expr, Basic):
            if expr.is_Poly:
                _polys.append(i)
            else:
                _exprs.append(i)
                if opt.expand:
                    expr = expr.expand()
        else:
            failed = True
        exprs.append(expr)
    if failed:
        raise PolificationFailed(opt, origs, exprs, True)
    if _polys:
        for i in _polys:
            exprs[i] = exprs[i].as_expr()
    reps, opt = _parallel_dict_from_expr(exprs, opt)
    if not opt.gens:
        raise PolificationFailed(opt, origs, exprs, True)
    for k in opt.gens:
        if isinstance(k, Piecewise):
            raise PolynomialError('Piecewise generators do not make sense')
    coeffs_list, lengths = ([], [])
    all_monoms = []
    all_coeffs = []
    for rep in reps:
        monoms, coeffs = list(zip(*list(rep.items())))
        coeffs_list.extend(coeffs)
        all_monoms.append(monoms)
        lengths.append(len(coeffs))
    domain = opt.domain
    if domain is None:
        opt.domain, coeffs_list = construct_domain(coeffs_list, opt=opt)
    else:
        coeffs_list = list(map(domain.from_sympy, coeffs_list))
    for k in lengths:
        all_coeffs.append(coeffs_list[:k])
        coeffs_list = coeffs_list[k:]
    polys = []
    for monoms, coeffs in zip(all_monoms, all_coeffs):
        rep = dict(list(zip(monoms, coeffs)))
        poly = Poly._from_dict(rep, opt)
        polys.append(poly)
    if opt.polys is None:
        opt.polys = bool(_polys)
    return (polys, opt)

.sympy.polys.polyoptions.OptionType.getter

def getter(self):
    try:
        return self[cls.option]
    except KeyError:
        return cls.default()

.sympy.polys.polyoptions.Expand.default

def default(cls):
    return True

.sympy.core.expr.Expr.expand

def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):
    from sympy.simplify.radsimp import fraction
    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)
    expr = self
    if hints.pop('frac', False):
        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]
        return n / d
    elif hints.pop('denom', False):
        n, d = fraction(self)
        return n / d.expand(deep=deep, modulus=modulus, **hints)
    elif hints.pop('numer', False):
        n, d = fraction(self)
        return n.expand(deep=deep, modulus=modulus, **hints) / d

    def _expand_hint_key(hint):
        if hint == 'mul':
            return 'mulz'
        return hint
    for hint in sorted(hints.keys(), key=_expand_hint_key):
        use_hint = hints[hint]
        if use_hint:
            hint = '_eval_expand_' + hint
            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
    while True:
        was = expr
        if hints.get('multinomial', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)
        if hints.get('mul', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)
        if hints.get('log', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)
        if expr == was:
            break
    if modulus is not None:
        modulus = sympify(modulus)
        if not modulus.is_Integer or modulus <= 0:
            raise ValueError('modulus must be a positive integer, got %s' % modulus)
        terms = []
        for term in Add.make_args(expr):
            coeff, tail = term.as_coeff_Mul(rational=True)
            coeff %= modulus
            if coeff:
                terms.append(coeff * tail)
        expr = Add(*terms)
    return expr

.sympy.core.expr.Expr._expand_hint_key

def _expand_hint_key(hint):
    if hint == 'mul':
        return 'mulz'
    return hint

.sympy.core.expr.Expr._expand_hint

def _expand_hint(expr, hint, deep=True, **hints):
    hit = False
    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):
        sargs = []
        for arg in expr.args:
            arg, arghit = Expr._expand_hint(arg, hint, **hints)
            hit |= arghit
            sargs.append(arg)
        if hit:
            expr = expr.func(*sargs)
    if hasattr(expr, hint):
        newexpr = getattr(expr, hint)(**hints)
        if newexpr != expr:
            return (newexpr, True)
    return (expr, hit)

.sympy.core.power.Pow._eval_expand_multinomial

def _eval_expand_multinomial(self, **hints):
    base, exp = self.args
    result = self
    if exp.is_Rational and exp.p > 0 and base.is_Add:
        if not exp.is_Integer:
            n = Integer(exp.p // exp.q)
            if not n:
                return result
            else:
                radical, result = (self.func(base, exp - n), [])
                expanded_base_n = self.func(base, n)
                if expanded_base_n.is_Pow:
                    expanded_base_n = expanded_base_n._eval_expand_multinomial()
                for term in Add.make_args(expanded_base_n):
                    result.append(term * radical)
                return Add(*result)
        n = int(exp)
        if base.is_commutative:
            order_terms, other_terms = ([], [])
            for b in base.args:
                if b.is_Order:
                    order_terms.append(b)
                else:
                    other_terms.append(b)
            if order_terms:
                f = Add(*other_terms)
                o = Add(*order_terms)
                if n == 2:
                    return expand_multinomial(f ** n, deep=False) + n * f * o
                else:
                    g = expand_multinomial(f ** (n - 1), deep=False)
                    return expand_mul(f * g, deep=False) + n * g * o
            if base.is_number:
                a, b = base.as_real_imag()
                if a.is_Rational and b.is_Rational:
                    if not a.is_Integer:
                        if not b.is_Integer:
                            k = self.func(a.q * b.q, n)
                            a, b = (a.p * b.q, a.q * b.p)
                        else:
                            k = self.func(a.q, n)
                            a, b = (a.p, a.q * b)
                    elif not b.is_Integer:
                        k = self.func(b.q, n)
                        a, b = (a * b.q, b.p)
                    else:
                        k = 1
                    a, b, c, d = (int(a), int(b), 1, 0)
                    while n:
                        if n & 1:
                            c, d = (a * c - b * d, b * c + a * d)
                            n -= 1
                        a, b = (a * a - b * b, 2 * a * b)
                        n //= 2
                    I = S.ImaginaryUnit
                    if k == 1:
                        return c + I * d
                    else:
                        return Integer(c) / k + I * d / k
            p = other_terms
            from sympy import multinomial_coefficients
            from sympy.polys.polyutils import basic_from_dict
            expansion_dict = multinomial_coefficients(len(p), n)
            return basic_from_dict(expansion_dict, *p)
        elif n == 2:
            return Add(*[f * g for f in base.args for g in base.args])
        else:
            multi = (base ** (n - 1))._eval_expand_multinomial()
            if multi.is_Add:
                return Add(*[f * g for f in base.args for g in multi.args])
            else:
                return Add(*[f * multi for f in base.args])
    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):
        return 1 / self.func(base, -exp)._eval_expand_multinomial()
    elif exp.is_Add and base.is_Number:
        coeff, tail = (S.One, S.Zero)
        for term in exp.args:
            if term.is_Number:
                coeff *= self.func(base, term)
            else:
                tail += term
        return coeff * self.func(base, tail)
    else:
        return result

.sympy.core.mul.Mul._eval_expand_mul

def _eval_expand_mul(self, **hints):
    from sympy import fraction
    expr = self
    n, d = fraction(expr)
    if d.is_Mul:
        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]
        expr = n / d
        if not expr.is_Mul:
            return expr
    plain, sums, rewrite = ([], [], False)
    for factor in expr.args:
        if factor.is_Add:
            sums.append(factor)
            rewrite = True
        elif factor.is_commutative:
            plain.append(factor)
        else:
            sums.append(Basic(factor))
    if not rewrite:
        return expr
    else:
        plain = self.func(*plain)
        if sums:
            deep = hints.get('deep', False)
            terms = self.func._expandsums(sums)
            args = []
            for term in terms:
                t = self.func(plain, term)
                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:
                    t = t._eval_expand_mul()
                args.append(t)
            return Add(*args)
        else:
            return plain

.sympy.simplify.radsimp.fraction

def fraction(expr, exact=False):
    expr = sympify(expr)
    numer, denom = ([], [])
    for term in Mul.make_args(expr):
        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):
            b, ex = term.as_base_exp()
            if ex.is_negative:
                if ex is S.NegativeOne:
                    denom.append(b)
                elif exact:
                    if ex.is_constant():
                        denom.append(Pow(b, -ex))
                    else:
                        numer.append(term)
                else:
                    denom.append(Pow(b, -ex))
            elif ex.is_positive:
                numer.append(term)
            elif not exact and ex.is_Mul:
                n, d = term.as_numer_denom()
                numer.append(n)
                denom.append(d)
            else:
                numer.append(term)
        elif term.is_Rational:
            n, d = term.as_numer_denom()
            numer.append(n)
            denom.append(d)
        else:
            numer.append(term)
    if exact:
        return (Mul(*numer, evaluate=False), Mul(*denom, evaluate=False))
    else:
        return (Mul(*numer), Mul(*denom))

.sympy.core.power.Pow._eval_expand_power_base

def _eval_expand_power_base(self, **hints):
    force = hints.get('force', False)
    b = self.base
    e = self.exp
    if not b.is_Mul:
        return self
    cargs, nc = b.args_cnc(split_1=False)
    if nc:
        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]
        if e.is_Integer:
            if e.is_positive:
                rv = Mul(*nc * e)
            else:
                rv = 1 / Mul(*nc * -e)
            if cargs:
                rv *= Mul(*cargs) ** e
            return rv
        if not cargs:
            return self.func(Mul(*nc), e, evaluate=False)
        nc = [Mul(*nc)]
    sifted = sift(cargs, lambda x: x.is_real)
    maybe_real = sifted[True] + sifted[None]
    other = sifted[False]

    def pred(x):
        if x is S.ImaginaryUnit:
            return S.ImaginaryUnit
        polar = x.is_polar
        if polar:
            return True
        if polar is None:
            return fuzzy_bool(x.is_nonnegative)
    sifted = sift(maybe_real, pred)
    nonneg = sifted[True]
    other += sifted[None]
    neg = sifted[False]
    imag = sifted[S.ImaginaryUnit]
    if imag:
        I = S.ImaginaryUnit
        i = len(imag) % 4
        if i == 0:
            pass
        elif i == 1:
            other.append(I)
        elif i == 2:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
        else:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
            other.append(I)
        del imag
    if force or e.is_integer:
        cargs = nonneg + neg + other
        other = nc
    else:
        assert not e.is_Integer
        if len(neg) > 1:
            o = S.One
            if not other and neg[0].is_Number:
                o *= neg.pop(0)
            if len(neg) % 2:
                o = -o
            for n in neg:
                nonneg.append(-n)
            if o is not S.One:
                other.append(o)
        elif neg and other:
            if neg[0].is_Number and neg[0] is not S.NegativeOne:
                other.append(S.NegativeOne)
                nonneg.append(-neg[0])
            else:
                other.extend(neg)
        else:
            other.extend(neg)
        del neg
        cargs = nonneg
        other += nc
    rv = S.One
    if cargs:
        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])
    if other:
        rv *= self.func(Mul(*other), e, evaluate=False)
    return rv

.sympy.core.power.Pow._eval_expand_power_exp

def _eval_expand_power_exp(self, **hints):
    b = self.base
    e = self.exp
    if e.is_Add and e.is_commutative:
        expr = []
        for x in e.args:
            expr.append(self.func(self.base, x))
        return Mul(*expr)
    return self.func(b, e)

.sympy.polys.polyutils._parallel_dict_from_expr

def _parallel_dict_from_expr(exprs, opt):
    if opt.expand is not False:
        exprs = [expr.expand() for expr in exprs]
    if any((expr.is_commutative is False for expr in exprs)):
        raise PolynomialError('non-commutative expressions are not supported')
    if opt.gens:
        reps, gens = _parallel_dict_from_expr_if_gens(exprs, opt)
    else:
        reps, gens = _parallel_dict_from_expr_no_gens(exprs, opt)
    return (reps, opt.clone({'gens': gens}))

.sympy.polys.polyoptions.Gens.default

def default(cls):
    return ()

.sympy.polys.polyutils._parallel_dict_from_expr_no_gens

def _parallel_dict_from_expr_no_gens(exprs, opt):
    if opt.domain is not None:

        def _is_coeff(factor):
            return factor in opt.domain
    elif opt.extension is True:

        def _is_coeff(factor):
            return factor.is_algebraic
    elif opt.greedy is not False:

        def _is_coeff(factor):
            return False
    else:

        def _is_coeff(factor):
            return factor.is_number
    gens, reprs = (set([]), [])
    for expr in exprs:
        terms = []
        if expr.is_Equality:
            expr = expr.lhs - expr.rhs
        for term in Add.make_args(expr):
            coeff, elements = ([], {})
            for factor in Mul.make_args(term):
                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):
                    coeff.append(factor)
                else:
                    if opt.series is False:
                        base, exp = decompose_power(factor)
                        if exp < 0:
                            exp, base = (-exp, Pow(base, -S.One))
                    else:
                        base, exp = decompose_power_rat(factor)
                    elements[base] = elements.setdefault(base, 0) + exp
                    gens.add(base)
            terms.append((coeff, elements))
        reprs.append(terms)
    gens = _sort_gens(gens, opt=opt)
    k, indices = (len(gens), {})
    for i, g in enumerate(gens):
        indices[g] = i
    polys = []
    for terms in reprs:
        poly = {}
        for coeff, term in terms:
            monom = [0] * k
            for base, exp in term.items():
                monom[indices[base]] = exp
            monom = tuple(monom)
            if monom in poly:
                poly[monom] += Mul(*coeff)
            else:
                poly[monom] = Mul(*coeff)
        polys.append(poly)
    return (polys, tuple(gens))

.sympy.polys.polyoptions.Option.default

def default(cls):
    return None

.sympy.polys.polyutils._not_a_coeff

def _not_a_coeff(expr):
    return expr in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]

.sympy.core.numbers.NaN.__eq__

def __eq__(self, other):
    return other is S.NaN

.sympy.core.numbers.Infinity.__eq__

def __eq__(self, other):
    return other is S.Infinity

.sympy.core.numbers.NegativeInfinity.__eq__

def __eq__(self, other):
    return other is S.NegativeInfinity

.sympy.polys.polyutils._is_coeff

def _is_coeff(factor):
    return factor.is_number

.sympy.polys.polyoptions.Series.default

def default(cls):
    return False

.sympy.polys.polyutils._sort_gens

def _sort_gens(gens, **args):
    opt = build_options(args)
    gens_order, wrt = ({}, None)
    if opt is not None:
        gens_order, wrt = ({}, opt.wrt)
        for i, gen in enumerate(opt.sort):
            gens_order[gen] = i + 1

    def order_key(gen):
        gen = str(gen)
        if wrt is not None:
            try:
                return (-len(wrt) + wrt.index(gen), gen, 0)
            except ValueError:
                pass
        name, index = _re_gen.match(gen).groups()
        if index:
            index = int(index)
        else:
            index = 0
        try:
            return (gens_order[name], name, index)
        except KeyError:
            pass
        try:
            return (_gens_order[name], name, index)
        except KeyError:
            pass
        return (_max_order, name, index)
    try:
        gens = sorted(gens, key=order_key)
    except TypeError:
        pass
    return tuple(gens)

.sympy.polys.polyoptions.Sort.default

def default(cls):
    return []

.sympy.polys.polyutils.order_key

def order_key(gen):
    gen = str(gen)
    if wrt is not None:
        try:
            return (-len(wrt) + wrt.index(gen), gen, 0)
        except ValueError:
            pass
    name, index = _re_gen.match(gen).groups()
    if index:
        index = int(index)
    else:
        index = 0
    try:
        return (gens_order[name], name, index)
    except KeyError:
        pass
    try:
        return (_gens_order[name], name, index)
    except KeyError:
        pass
    return (_max_order, name, index)

.sympy.polys.polyoptions.Options.clone

def clone(self, updates={}):
    obj = dict.__new__(self.__class__)
    for option, value in self.items():
        obj[option] = value
    for option, value in updates.items():
        obj[option] = value
    return obj

.sympy.polys.constructor.construct_domain

def construct_domain(obj, **args):
    opt = build_options(args)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            if not obj:
                monoms, coeffs = ([], [])
            else:
                monoms, coeffs = list(zip(*list(obj.items())))
        else:
            coeffs = obj
    else:
        coeffs = [obj]
    coeffs = list(map(sympify, coeffs))
    result = _construct_simple(coeffs, opt)
    if result is not None:
        if result is not False:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    else:
        if opt.composite is False:
            result = None
        else:
            result = _construct_composite(coeffs, opt)
        if result is not None:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            return (domain, dict(list(zip(monoms, coeffs))))
        else:
            return (domain, coeffs)
    else:
        return (domain, coeffs[0])

.sympy.polys.constructor._construct_simple

def _construct_simple(coeffs, opt):
    result, rationals, reals, algebraics = ({}, False, False, False)
    if opt.extension is True:
        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic
    else:
        is_algebraic = lambda coeff: False
    for coeff in coeffs:
        if coeff.is_Rational:
            if not coeff.is_Integer:
                rationals = True
        elif coeff.is_Float:
            if not algebraics:
                reals = True
            else:
                return False
        elif is_algebraic(coeff):
            if not reals:
                algebraics = True
            else:
                return False
        else:
            return None
    if algebraics:
        domain, result = _construct_algebraic(coeffs, opt)
    else:
        if reals:
            max_prec = max([c._prec for c in coeffs])
            domain = RealField(prec=max_prec)
        elif opt.field or rationals:
            domain = QQ
        else:
            domain = ZZ
        result = []
        for coeff in coeffs:
            result.append(domain.from_sympy(coeff))
    return (domain, result)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.from_sympy

def from_sympy(self, a):
    if a.is_Integer:
        return PythonInteger(a.p)
    elif a.is_Float and int(a) == a:
        return PythonInteger(int(a))
    else:
        raise CoercionFailed('expected an integer, got %s' % a)

.sympy.polys.polyoptions.Options.__setattr__

def __setattr__(self, attr, value):
    if attr in self.__options__:
        self[attr] = value
    else:
        super(Options, self).__setattr__(attr, value)

.sympy.polys.polytools.Poly._from_dict

def _from_dict(cls, rep, opt):
    gens = opt.gens
    if not gens:
        raise GeneratorsNeeded("can't initialize from 'dict' without generators")
    level = len(gens) - 1
    domain = opt.domain
    if domain is None:
        domain, rep = construct_domain(rep, opt=opt)
    else:
        for monom, coeff in rep.items():
            rep[monom] = domain.convert(coeff)
    return cls.new(DMP.from_dict(rep, level, domain), *gens)

.sympy.polys.domains.domain.Domain.convert

def convert(self, element, base=None):
    if base is not None:
        return self.convert_from(element, base)
    if self.of_type(element):
        return element
    from sympy.polys.domains import PythonIntegerRing, GMPYIntegerRing, GMPYRationalField, RealField, ComplexField
    if isinstance(element, integer_types):
        return self.convert_from(element, PythonIntegerRing())
    if HAS_GMPY:
        integers = GMPYIntegerRing()
        if isinstance(element, integers.tp):
            return self.convert_from(element, integers)
        rationals = GMPYRationalField()
        if isinstance(element, rationals.tp):
            return self.convert_from(element, rationals)
    if isinstance(element, float):
        parent = RealField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, complex):
        parent = ComplexField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, DomainElement):
        return self.convert_from(element, element.parent())
    if self.is_Numerical and getattr(element, 'is_ground', False):
        return self.convert(element.LC())
    if isinstance(element, Basic):
        try:
            return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    elif not is_sequence(element):
        try:
            element = sympify(element)
            if isinstance(element, Basic):
                return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    raise CoercionFailed("can't convert %s of type %s to %s" % (element, type(element), self))

.sympy.polys.domains.domain.Domain.of_type

def of_type(self, element):
    return isinstance(element, self.tp)

.sympy.polys.domains.domain.Domain.tp

def tp(self):
    return self.dtype

.sympy.polys.polyclasses.DMP.from_dict

def from_dict(cls, rep, lev, dom):
    return cls(dmp_from_dict(rep, lev, dom), dom, lev)

.sympy.polys.densebasic.dmp_from_dict

def dmp_from_dict(f, u, K):
    if not u:
        return dup_from_dict(f, K)
    if not f:
        return dmp_zero(u)
    coeffs = {}
    for monom, coeff in f.items():
        head, tail = (monom[0], monom[1:])
        if head in coeffs:
            coeffs[head][tail] = coeff
        else:
            coeffs[head] = {tail: coeff}
    n, v, h = (max(coeffs.keys()), u - 1, [])
    for k in range(n, -1, -1):
        coeff = coeffs.get(k)
        if coeff is not None:
            h.append(dmp_from_dict(coeff, v, K))
        else:
            h.append(dmp_zero(v))
    return dmp_strip(h, u)

.sympy.polys.densebasic.dup_from_dict

def dup_from_dict(f, K):
    if not f:
        return []
    n, h = (max(f.keys()), [])
    if type(n) is int:
        for k in range(n, -1, -1):
            h.append(f.get(k, K.zero))
    else:
        n, = n
        for k in range(n, -1, -1):
            h.append(f.get((k,), K.zero))
    return dup_strip(h)

.sympy.polys.densebasic.dup_strip

def dup_strip(f):
    if not f or f[0]:
        return f
    i = 0
    for cf in f:
        if cf:
            break
        else:
            i += 1
    return f[i:]

.sympy.polys.densebasic.dmp_zero

def dmp_zero(u):
    r = []
    for i in range(u):
        r = [r]
    return r

.sympy.polys.densebasic.dmp_strip

def dmp_strip(f, u):
    if not u:
        return dup_strip(f)
    if dmp_zero_p(f, u):
        return f
    i, v = (0, u - 1)
    for c in f:
        if not dmp_zero_p(c, v):
            break
        else:
            i += 1
    if i == len(f):
        return dmp_zero(u)
    else:
        return f[i:]

.sympy.polys.densebasic.dmp_zero_p

def dmp_zero_p(f, u):
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    return not f

.sympy.polys.polyclasses.DMP.__init__

def __init__(self, rep, dom, lev=None, ring=None):
    if lev is not None:
        if type(rep) is dict:
            rep = dmp_from_dict(rep, lev, dom)
        elif type(rep) is not list:
            rep = dmp_ground(dom.convert(rep), lev)
    else:
        rep, lev = dmp_validate(rep)
    self.rep = rep
    self.lev = lev
    self.dom = dom
    self.ring = ring

.sympy.polys.polytools.Poly.new

def new(cls, rep, *gens):
    if not isinstance(rep, DMP):
        raise PolynomialError('invalid polynomial representation: %s' % rep)
    elif rep.lev != len(gens) - 1:
        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))
    obj = Basic.__new__(cls)
    obj.rep = rep
    obj.gens = gens
    return obj

.sympy.polys.polytools.Poly.cancel

def cancel(f, g, include=False):
    dom, per, F, G = f._unify(g)
    if hasattr(F, 'cancel'):
        result = F.cancel(G, include=include)
    else:
        raise OperationNotSupported(f, 'cancel')
    if not include:
        if dom.has_assoc_Ring:
            dom = dom.get_ring()
        cp, cq, p, q = result
        cp = dom.to_sympy(cp)
        cq = dom.to_sympy(cq)
        return (cp / cq, per(p), per(q))
    else:
        return tuple(map(per, result))

.sympy.polys.polytools.Poly._unify

def _unify(f, g):
    g = sympify(g)
    if not g.is_Poly:
        try:
            return (f.rep.dom, f.per, f.rep, f.rep.per(f.rep.dom.from_sympy(g)))
        except CoercionFailed:
            raise UnificationFailed("can't unify %s with %s" % (f, g))
    if isinstance(f.rep, DMP) and isinstance(g.rep, DMP):
        gens = _unify_gens(f.gens, g.gens)
        dom, lev = (f.rep.dom.unify(g.rep.dom, gens), len(gens) - 1)
        if f.gens != gens:
            f_monoms, f_coeffs = _dict_reorder(f.rep.to_dict(), f.gens, gens)
            if f.rep.dom != dom:
                f_coeffs = [dom.convert(c, f.rep.dom) for c in f_coeffs]
            F = DMP(dict(list(zip(f_monoms, f_coeffs))), dom, lev)
        else:
            F = f.rep.convert(dom)
        if g.gens != gens:
            g_monoms, g_coeffs = _dict_reorder(g.rep.to_dict(), g.gens, gens)
            if g.rep.dom != dom:
                g_coeffs = [dom.convert(c, g.rep.dom) for c in g_coeffs]
            G = DMP(dict(list(zip(g_monoms, g_coeffs))), dom, lev)
        else:
            G = g.rep.convert(dom)
    else:
        raise UnificationFailed("can't unify %s with %s" % (f, g))
    cls = f.__class__

    def per(rep, dom=dom, gens=gens, remove=None):
        if remove is not None:
            gens = gens[:remove] + gens[remove + 1:]
            if not gens:
                return dom.to_sympy(rep)
        return cls.new(rep, *gens)
    return (dom, per, F, G)

.sympy.polys.polytools.Poly.__hash__

def __hash__(self):
    return super(Poly, self).__hash__()

.sympy.polys.polytools.Poly._hashable_content

def _hashable_content(self):
    return (self.rep, self.gens)

.sympy.polys.polyclasses.DMP.__hash__

def __hash__(f):
    return hash((f.__class__.__name__, f.to_tuple(), f.lev, f.dom, f.ring))

.sympy.polys.polyclasses.DMP.to_tuple

def to_tuple(f):
    return dmp_to_tuple(f.rep, f.lev)

.sympy.polys.densebasic.dmp_to_tuple

def dmp_to_tuple(f, u):
    if not u:
        return tuple(f)
    v = u - 1
    return tuple((dmp_to_tuple(c, v) for c in f))

.sympy.polys.domains.domain.Domain.__hash__

def __hash__(self):
    return hash((self.__class__.__name__, self.dtype))

.sympy.polys.polyutils._unify_gens

def _unify_gens(f_gens, g_gens):
    f_gens = list(f_gens)
    g_gens = list(g_gens)
    if f_gens == g_gens:
        return tuple(f_gens)
    gens, common, k = ([], [], 0)
    for gen in f_gens:
        if gen in g_gens:
            common.append(gen)
    for i, gen in enumerate(g_gens):
        if gen in common:
            g_gens[i], k = (common[k], k + 1)
    for gen in common:
        i = f_gens.index(gen)
        gens.extend(f_gens[:i])
        f_gens = f_gens[i + 1:]
        i = g_gens.index(gen)
        gens.extend(g_gens[:i])
        g_gens = g_gens[i + 1:]
        gens.append(gen)
    gens.extend(f_gens)
    gens.extend(g_gens)
    return tuple(gens)

.sympy.polys.domains.domain.Domain.unify

def unify(K0, K1, symbols=None):
    if symbols is not None:
        return K0.unify_with_symbols(K1, symbols)
    if K0 == K1:
        return K0
    if K0.is_EX:
        return K0
    if K1.is_EX:
        return K1
    if K0.is_Composite or K1.is_Composite:
        K0_ground = K0.dom if K0.is_Composite else K0
        K1_ground = K1.dom if K1.is_Composite else K1
        K0_symbols = K0.symbols if K0.is_Composite else ()
        K1_symbols = K1.symbols if K1.is_Composite else ()
        domain = K0_ground.unify(K1_ground)
        symbols = _unify_gens(K0_symbols, K1_symbols)
        order = K0.order if K0.is_Composite else K1.order
        if (K0.is_FractionField and K1.is_PolynomialRing or (K1.is_FractionField and K0.is_PolynomialRing)) and (not K0_ground.is_Field or not K1_ground.is_Field) and domain.is_Field:
            domain = domain.get_ring()
        if K0.is_Composite and (not K1.is_Composite or K0.is_FractionField or K1.is_PolynomialRing):
            cls = K0.__class__
        else:
            cls = K1.__class__
        from sympy.polys.domains.old_polynomialring import GlobalPolynomialRing
        if cls == GlobalPolynomialRing:
            return cls(domain, symbols)
        return cls(domain, symbols, order)

    def mkinexact(cls, K0, K1):
        prec = max(K0.precision, K1.precision)
        tol = max(K0.tolerance, K1.tolerance)
        return cls(prec=prec, tol=tol)
    if K0.is_ComplexField and K1.is_ComplexField:
        return mkinexact(K0.__class__, K0, K1)
    if K0.is_ComplexField and K1.is_RealField:
        return mkinexact(K0.__class__, K0, K1)
    if K0.is_RealField and K1.is_ComplexField:
        return mkinexact(K1.__class__, K1, K0)
    if K0.is_RealField and K1.is_RealField:
        return mkinexact(K0.__class__, K0, K1)
    if K0.is_ComplexField or K0.is_RealField:
        return K0
    if K1.is_ComplexField or K1.is_RealField:
        return K1
    if K0.is_AlgebraicField and K1.is_AlgebraicField:
        return K0.__class__(K0.dom.unify(K1.dom), *_unify_gens(K0.orig_ext, K1.orig_ext))
    elif K0.is_AlgebraicField:
        return K0
    elif K1.is_AlgebraicField:
        return K1
    if K0.is_RationalField:
        return K0
    if K1.is_RationalField:
        return K1
    if K0.is_IntegerRing:
        return K0
    if K1.is_IntegerRing:
        return K1
    if K0.is_FiniteField and K1.is_FiniteField:
        return K0.__class__(max(K0.mod, K1.mod, key=default_sort_key))
    from sympy.polys.domains import EX
    return EX

.sympy.polys.domains.domain.Domain.unify_with_symbols

def unify_with_symbols(K0, K1, symbols):
    if K0.is_Composite and set(K0.symbols) & set(symbols) or (K1.is_Composite and set(K1.symbols) & set(symbols)):
        raise UnificationFailed("can't unify %s with %s, given %s generators" % (K0, K1, tuple(symbols)))
    return K0.unify(K1)

.sympy.polys.domains.domain.Domain.__eq__

def __eq__(self, other):
    return isinstance(other, Domain) and self.dtype == other.dtype

.sympy.polys.polyclasses.DMP.convert

def convert(f, dom):
    if f.dom == dom:
        return f
    else:
        return DMP(dmp_convert(f.rep, f.lev, f.dom, dom), dom, f.lev)

.sympy.polys.polyclasses.DMP.cancel

def cancel(f, g, include=True):
    lev, dom, per, F, G = f.unify(g)
    if include:
        F, G = dmp_cancel(F, G, lev, dom, include=True)
    else:
        cF, cG, F, G = dmp_cancel(F, G, lev, dom, include=False)
    F, G = (per(F), per(G))
    if include:
        return (F, G)
    else:
        return (cF, cG, F, G)

.sympy.polys.polyclasses.DMP.unify

def unify(f, g):
    if not isinstance(g, DMP) or f.lev != g.lev:
        raise UnificationFailed("can't unify %s with %s" % (f, g))
    if f.dom == g.dom and f.ring == g.ring:
        return (f.lev, f.dom, f.per, f.rep, g.rep)
    else:
        lev, dom = (f.lev, f.dom.unify(g.dom))
        ring = f.ring
        if g.ring is not None:
            if ring is not None:
                ring = ring.unify(g.ring)
            else:
                ring = g.ring
        F = dmp_convert(f.rep, lev, f.dom, dom)
        G = dmp_convert(g.rep, lev, g.dom, dom)

        def per(rep, dom=dom, lev=lev, kill=False):
            if kill:
                if not lev:
                    return rep
                else:
                    lev -= 1
            return DMP(rep, dom, lev, ring)
        return (lev, dom, per, F, G)

.sympy.polys.euclidtools.dmp_cancel

def dmp_cancel(f, g, u, K, include=True):
    K0 = None
    if K.is_Field and K.has_assoc_Ring:
        K0, K = (K, K.get_ring())
        cq, f = dmp_clear_denoms(f, u, K0, K, convert=True)
        cp, g = dmp_clear_denoms(g, u, K0, K, convert=True)
    else:
        cp, cq = (K.one, K.one)
    _, p, q = dmp_inner_gcd(f, g, u, K)
    if K0 is not None:
        _, cp, cq = K.cofactors(cp, cq)
        p = dmp_convert(p, u, K, K0)
        q = dmp_convert(q, u, K, K0)
        K = K0
    p_neg = K.is_negative(dmp_ground_LC(p, u, K))
    q_neg = K.is_negative(dmp_ground_LC(q, u, K))
    if p_neg and q_neg:
        p, q = (dmp_neg(p, u, K), dmp_neg(q, u, K))
    elif p_neg:
        cp, p = (-cp, dmp_neg(p, u, K))
    elif q_neg:
        cp, q = (-cp, dmp_neg(q, u, K))
    if not include:
        return (cp, cq, p, q)
    p = dmp_mul_ground(p, cp, u, K)
    q = dmp_mul_ground(q, cq, u, K)
    return (p, q)

.sympy.polys.euclidtools.dmp_inner_gcd

def dmp_inner_gcd(f, g, u, K):
    if not u:
        return dup_inner_gcd(f, g, K)
    J, (f, g) = dmp_multi_deflate((f, g), u, K)
    h, cff, cfg = _dmp_inner_gcd(f, g, u, K)
    return (dmp_inflate(h, J, u, K), dmp_inflate(cff, J, u, K), dmp_inflate(cfg, J, u, K))

.sympy.polys.densebasic.dmp_multi_deflate

def dmp_multi_deflate(polys, u, K):
    if not u:
        M, H = dup_multi_deflate(polys, K)
        return ((M,), H)
    F, B = ([], [0] * (u + 1))
    for p in polys:
        f = dmp_to_dict(p, u)
        if not dmp_zero_p(p, u):
            for M in f.keys():
                for i, m in enumerate(M):
                    B[i] = igcd(B[i], m)
        F.append(f)
    for i, b in enumerate(B):
        if not b:
            B[i] = 1
    B = tuple(B)
    if all((b == 1 for b in B)):
        return (B, polys)
    H = []
    for f in F:
        h = {}
        for A, coeff in f.items():
            N = [a // b for a, b in zip(A, B)]
            h[tuple(N)] = coeff
        H.append(dmp_from_dict(h, u, K))
    return (B, tuple(H))

.sympy.polys.densebasic.dmp_to_dict

def dmp_to_dict(f, u, K=None, zero=False):
    if not u:
        return dup_to_dict(f, K, zero=zero)
    if dmp_zero_p(f, u) and zero:
        return {(0,) * (u + 1): K.zero}
    n, v, result = (dmp_degree(f, u), u - 1, {})
    if n == -oo:
        n = -1
    for k in range(0, n + 1):
        h = dmp_to_dict(f[n - k], v)
        for exp, coeff in h.items():
            result[(k,) + exp] = coeff
    return result

.sympy.polys.densebasic.dmp_degree

def dmp_degree(f, u):
    if dmp_zero_p(f, u):
        return -oo
    else:
        return len(f) - 1

.sympy.core.numbers.Infinity.__neg__

def __neg__(self):
    return S.NegativeInfinity

.sympy.polys.densebasic.dup_to_dict

def dup_to_dict(f, K=None, zero=False):
    if not f and zero:
        return {(0,): K.zero}
    n, result = (len(f) - 1, {})
    for k in range(0, n + 1):
        if f[n - k]:
            result[k,] = f[n - k]
    return result

.sympy.polys.euclidtools._dmp_inner_gcd

def _dmp_inner_gcd(f, g, u, K):
    if not K.is_Exact:
        try:
            exact = K.get_exact()
        except DomainError:
            return (dmp_one(u, K), f, g)
        f = dmp_convert(f, u, K, exact)
        g = dmp_convert(g, u, K, exact)
        h, cff, cfg = _dmp_inner_gcd(f, g, u, exact)
        h = dmp_convert(h, u, exact, K)
        cff = dmp_convert(cff, u, exact, K)
        cfg = dmp_convert(cfg, u, exact, K)
        return (h, cff, cfg)
    elif K.is_Field:
        if K.is_QQ and query('USE_HEU_GCD'):
            try:
                return dmp_qq_heu_gcd(f, g, u, K)
            except HeuristicGCDFailed:
                pass
        return dmp_ff_prs_gcd(f, g, u, K)
    else:
        if K.is_ZZ and query('USE_HEU_GCD'):
            try:
                return dmp_zz_heu_gcd(f, g, u, K)
            except HeuristicGCDFailed:
                pass
        return dmp_rr_prs_gcd(f, g, u, K)

.sympy.polys.polyconfig.query

def query(key):
    return _current_config.get(key.upper(), None)

.sympy.polys.euclidtools.dmp_zz_heu_gcd

def dmp_zz_heu_gcd(f, g, u, K):
    if not u:
        return dup_zz_heu_gcd(f, g, K)
    result = _dmp_rr_trivial_gcd(f, g, u, K)
    if result is not None:
        return result
    gcd, f, g = dmp_ground_extract(f, g, u, K)
    f_norm = dmp_max_norm(f, u, K)
    g_norm = dmp_max_norm(g, u, K)
    B = K(2 * min(f_norm, g_norm) + 29)
    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dmp_ground_LC(f, u, K)), g_norm // abs(dmp_ground_LC(g, u, K))) + 2)
    for i in range(0, HEU_GCD_MAX):
        ff = dmp_eval(f, x, u, K)
        gg = dmp_eval(g, x, u, K)
        v = u - 1
        if not (dmp_zero_p(ff, v) or dmp_zero_p(gg, v)):
            h, cff, cfg = dmp_zz_heu_gcd(ff, gg, v, K)
            h = _dmp_zz_gcd_interpolate(h, x, v, K)
            h = dmp_ground_primitive(h, u, K)[1]
            cff_, r = dmp_div(f, h, u, K)
            if dmp_zero_p(r, u):
                cfg_, r = dmp_div(g, h, u, K)
                if dmp_zero_p(r, u):
                    h = dmp_mul_ground(h, gcd, u, K)
                    return (h, cff_, cfg_)
            cff = _dmp_zz_gcd_interpolate(cff, x, v, K)
            h, r = dmp_div(f, cff, u, K)
            if dmp_zero_p(r, u):
                cfg_, r = dmp_div(g, h, u, K)
                if dmp_zero_p(r, u):
                    h = dmp_mul_ground(h, gcd, u, K)
                    return (h, cff, cfg_)
            cfg = _dmp_zz_gcd_interpolate(cfg, x, v, K)
            h, r = dmp_div(g, cfg, u, K)
            if dmp_zero_p(r, u):
                cff_, r = dmp_div(f, h, u, K)
                if dmp_zero_p(r, u):
                    h = dmp_mul_ground(h, gcd, u, K)
                    return (h, cff_, cfg)
        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011
    raise HeuristicGCDFailed('no luck')

.sympy.polys.euclidtools._dmp_rr_trivial_gcd

def _dmp_rr_trivial_gcd(f, g, u, K):
    zero_f = dmp_zero_p(f, u)
    zero_g = dmp_zero_p(g, u)
    if_contain_one = dmp_one_p(f, u, K) or dmp_one_p(g, u, K)
    if zero_f and zero_g:
        return tuple(dmp_zeros(3, u, K))
    elif zero_f:
        if K.is_nonnegative(dmp_ground_LC(g, u, K)):
            return (g, dmp_zero(u), dmp_one(u, K))
        else:
            return (dmp_neg(g, u, K), dmp_zero(u), dmp_ground(-K.one, u))
    elif zero_g:
        if K.is_nonnegative(dmp_ground_LC(f, u, K)):
            return (f, dmp_one(u, K), dmp_zero(u))
        else:
            return (dmp_neg(f, u, K), dmp_ground(-K.one, u), dmp_zero(u))
    elif if_contain_one:
        return (dmp_one(u, K), f, g)
    elif query('USE_SIMPLIFY_GCD'):
        return _dmp_simplify_gcd(f, g, u, K)
    else:
        return None

.sympy.polys.densebasic.dmp_one_p

def dmp_one_p(f, u, K):
    return dmp_ground_p(f, K.one, u)

.sympy.polys.densebasic.dmp_ground_p

def dmp_ground_p(f, c, u):
    if c is not None and (not c):
        return dmp_zero_p(f, u)
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    if c is None:
        return len(f) <= 1
    else:
        return f == [c]

.sympy.polys.densebasic.dmp_one

def dmp_one(u, K):
    return dmp_ground(K.one, u)

.sympy.polys.densebasic.dmp_ground

def dmp_ground(c, u):
    if not c:
        return dmp_zero(u)
    for i in range(u + 1):
        c = [c]
    return c

.sympy.polys.densebasic.dmp_inflate

def dmp_inflate(f, M, u, K):
    if not u:
        return dup_inflate(f, M[0], K)
    if all((m == 1 for m in M)):
        return f
    else:
        return _rec_inflate(f, M, u, 0, K)

.sympy.polys.densebasic._rec_inflate

def _rec_inflate(g, M, v, i, K):
    if not v:
        return dup_inflate(g, M[i], K)
    if M[i] <= 0:
        raise IndexError('all M[i] must be positive, got %s' % M[i])
    w, j = (v - 1, i + 1)
    g = [_rec_inflate(c, M, w, j, K) for c in g]
    result = [g[0]]
    for coeff in g[1:]:
        for _ in range(1, M[i]):
            result.append(dmp_zero(w))
        result.append(coeff)
    return result

.sympy.polys.densebasic.dup_inflate

def dup_inflate(f, m, K):
    if m <= 0:
        raise IndexError("'m' must be positive, got %s" % m)
    if m == 1 or not f:
        return f
    result = [f[0]]
    for coeff in f[1:]:
        result.extend([K.zero] * (m - 1))
        result.append(coeff)
    return result

.sympy.polys.densebasic.dmp_ground_LC

def dmp_ground_LC(f, u, K):
    while u:
        f = dmp_LC(f, K)
        u -= 1
    return dup_LC(f, K)

.sympy.polys.densebasic.poly_LC

def poly_LC(f, K):
    if not f:
        return K.zero
    else:
        return f[0]

.sympy.polys.domains.domain.Domain.is_negative

def is_negative(self, a):
    return a < 0

.sympy.polys.polyclasses.DMP.per

def per(f, rep, dom=None, kill=False, ring=None):
    lev = f.lev
    if kill:
        if not lev:
            return rep
        else:
            lev -= 1
    if dom is None:
        dom = f.dom
    if ring is None:
        ring = f.ring
    return DMP(rep, dom, lev, ring)

.sympy.polys.domains.ring.Ring.get_ring

def get_ring(self):
    return self

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.to_sympy

def to_sympy(self, a):
    return SymPyInteger(a)

.sympy.polys.polytools.Poly.per

def per(f, rep, gens=None, remove=None):
    if gens is None:
        gens = f.gens
    if remove is not None:
        gens = gens[:remove] + gens[remove + 1:]
        if not gens:
            return f.rep.dom.to_sympy(rep)
    return f.__class__.new(rep, *gens)

.sympy.polys.polytools.Poly.as_expr

def as_expr(f, *gens):
    if not gens:
        gens = f.gens
    elif len(gens) == 1 and isinstance(gens[0], dict):
        mapping = gens[0]
        gens = list(f.gens)
        for gen, value in mapping.items():
            try:
                index = gens.index(gen)
            except ValueError:
                raise GeneratorsError("%s doesn't have %s as generator" % (f, gen))
            else:
                gens[index] = value
    return basic_from_dict(f.rep.to_sympy_dict(), *gens)

.sympy.polys.polyclasses.DMP.to_sympy_dict

def to_sympy_dict(f, zero=False):
    rep = dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)
    for k, v in rep.items():
        rep[k] = f.dom.to_sympy(v)
    return rep

.sympy.polys.polyutils.expr_from_dict

def expr_from_dict(rep, *gens):
    result = []
    for monom, coeff in rep.items():
        term = [coeff]
        for g, m in zip(gens, monom):
            if m:
                term.append(Pow(g, m))
        result.append(Mul(*term))
    return Add(*result)

.sympy.core.function._mexpand

def _mexpand(expr, recursive=False):
    if expr is None:
        return
    was = None
    while was != expr:
        was, expr = (expr, expand_mul(expand_multinomial(expr)))
        if not recursive:
            break
    return expr

.sympy.core.function.expand_multinomial

def expand_multinomial(expr, deep=True):
    return sympify(expr).expand(deep=deep, mul=False, power_exp=False, power_base=False, basic=False, multinomial=True, log=False)

.sympy.core.function.expand_mul

def expand_mul(expr, deep=True):
    return sympify(expr).expand(deep=deep, mul=True, power_exp=False, power_base=False, basic=False, multinomial=False, log=False)

.sympy.core.expr.Expr.cancel

def cancel(self, *gens, **args):
    from sympy.polys import cancel
    return cancel(self, *gens, **args)

.sympy.simplify.simplify.shorter

def shorter(*choices):
    if not has_variety(choices):
        return choices[0]
    return min(choices, key=measure)

.sympy.utilities.iterables.has_variety

def has_variety(seq):
    for i, s in enumerate(seq):
        if i == 0:
            sentinel = s
        elif s != sentinel:
            return True
    return False

.sympy.polys.rationaltools.together

def together(expr, deep=False):

    def _together(expr):
        if isinstance(expr, Basic):
            if expr.is_Atom or (expr.is_Function and (not deep)):
                return expr
            elif expr.is_Add:
                return gcd_terms(list(map(_together, Add.make_args(expr))))
            elif expr.is_Pow:
                base = _together(expr.base)
                if deep:
                    exp = _together(expr.exp)
                else:
                    exp = expr.exp
                return expr.__class__(base, exp)
            else:
                return expr.__class__(*[_together(arg) for arg in expr.args])
        elif iterable(expr):
            return expr.__class__([_together(ex) for ex in expr])
        return expr
    return _together(sympify(expr))

.sympy.polys.rationaltools._together

def _together(expr):
    if isinstance(expr, Basic):
        if expr.is_Atom or (expr.is_Function and (not deep)):
            return expr
        elif expr.is_Add:
            return gcd_terms(list(map(_together, Add.make_args(expr))))
        elif expr.is_Pow:
            base = _together(expr.base)
            if deep:
                exp = _together(expr.exp)
            else:
                exp = expr.exp
            return expr.__class__(base, exp)
        else:
            return expr.__class__(*[_together(arg) for arg in expr.args])
    elif iterable(expr):
        return expr.__class__([_together(ex) for ex in expr])
    return expr

.sympy.functions.elementary.trigonometric.cos.eval

def eval(cls, arg):
    from sympy.functions.special.polynomials import chebyshevt
    from sympy.calculus.util import AccumBounds
    if arg.is_Number:
        if arg is S.NaN:
            return S.NaN
        elif arg is S.Zero:
            return S.One
        elif arg is S.Infinity or arg is S.NegativeInfinity:
            return AccumBounds(-1, 1)
    if isinstance(arg, AccumBounds):
        return sin(arg + S.Pi / 2)
    if arg.could_extract_minus_sign():
        return cls(-arg)
    i_coeff = arg.as_coefficient(S.ImaginaryUnit)
    if i_coeff is not None:
        return cosh(i_coeff)
    pi_coeff = _pi_coeff(arg)
    if pi_coeff is not None:
        if pi_coeff.is_integer:
            return S.NegativeOne ** pi_coeff
        if (2 * pi_coeff).is_integer:
            if pi_coeff.is_even:
                return S.NegativeOne ** (pi_coeff / 2)
            elif pi_coeff.is_even is False:
                return S.Zero
        if not pi_coeff.is_Rational:
            narg = pi_coeff * S.Pi
            if narg != arg:
                return cls(narg)
            return None
        cst_table_some = {3: S.Half, 5: (sqrt(5) + 1) / 4}
        if pi_coeff.is_Rational:
            q = pi_coeff.q
            p = pi_coeff.p % (2 * q)
            if p > q:
                narg = (pi_coeff - 1) * S.Pi
                return -cls(narg)
            if 2 * p > q:
                narg = (1 - pi_coeff) * S.Pi
                return -cls(narg)
            table2 = {12: (3, 4), 20: (4, 5), 30: (5, 6), 15: (6, 10), 24: (6, 8), 40: (8, 10), 60: (20, 30), 120: (40, 60)}
            if q in table2:
                a, b = (p * S.Pi / table2[q][0], p * S.Pi / table2[q][1])
                nvala, nvalb = (cls(a), cls(b))
                if None == nvala or None == nvalb:
                    return None
                return nvala * nvalb + cls(S.Pi / 2 - a) * cls(S.Pi / 2 - b)
            if q > 12:
                return None
            if q in cst_table_some:
                cts = cst_table_some[pi_coeff.q]
                return chebyshevt(pi_coeff.p, cts).expand()
            if 0 == q % 2:
                narg = pi_coeff * 2 * S.Pi
                nval = cls(narg)
                if None == nval:
                    return None
                x = (2 * pi_coeff + 1) / 2
                sign_cos = (-1) ** ((-1 if x < 0 else 1) * int(abs(x)))
                return sign_cos * sqrt((1 + nval) / 2)
        return None
    if arg.is_Add:
        x, m = _peeloff_pi(arg)
        if m:
            return cos(m) * cos(x) - sin(m) * sin(x)
    if isinstance(arg, acos):
        return arg.args[0]
    if isinstance(arg, atan):
        x = arg.args[0]
        return 1 / sqrt(1 + x ** 2)
    if isinstance(arg, atan2):
        y, x = arg.args
        return x / sqrt(x ** 2 + y ** 2)
    if isinstance(arg, asin):
        x = arg.args[0]
        return sqrt(1 - x ** 2)
    if isinstance(arg, acot):
        x = arg.args[0]
        return 1 / sqrt(1 + 1 / x ** 2)
    if isinstance(arg, acsc):
        x = arg.args[0]
        return sqrt(1 - 1 / x ** 2)
    if isinstance(arg, asec):
        x = arg.args[0]
        return 1 / x

.sympy.core.expr.Expr.as_coefficient

def as_coefficient(self, expr):
    r = self.extract_multiplicatively(expr)
    if r and (not r.has(expr)):
        return r

.sympy.core.numbers.Number.__div__

def __div__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity or other is S.NegativeInfinity:
            return S.Zero
    return AtomicExpr.__div__(self, other)

.sympy.core.numbers.ImaginaryUnit._eval_power

def _eval_power(self, expt):
    if isinstance(expt, Number):
        if isinstance(expt, Integer):
            expt = expt.p % 4
            if expt == 0:
                return S.One
            if expt == 1:
                return S.ImaginaryUnit
            if expt == 2:
                return -S.One
            return -S.ImaginaryUnit
        return S.NegativeOne ** (expt * S.Half)
    return

.sympy.core.numbers.Rational.as_numer_denom

def as_numer_denom(self):
    return (Integer(self.p), Integer(self.q))

.sympy.core.numbers.Integer.__divmod__

def __divmod__(self, other):
    from .containers import Tuple
    if isinstance(other, Integer) and global_evaluate[0]:
        return Tuple(*divmod(self.p, other.p))
    else:
        return Number.__divmod__(self, other)

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.core.numbers.Integer.__mod__

def __mod__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p % other)
        elif isinstance(other, Integer):
            return Integer(self.p % other.p)
        return Rational.__mod__(self, other)
    return Rational.__mod__(self, other)

.sympy.functions.elementary.trigonometric._pi_coeff

def _pi_coeff(arg, cycles=1):
    arg = sympify(arg)
    if arg is S.Pi:
        return S.One
    elif not arg:
        return S.Zero
    elif arg.is_Mul:
        cx = arg.coeff(S.Pi)
        if cx:
            c, x = cx.as_coeff_Mul()
            if c.is_Float:
                f = abs(c) % 1
                if f != 0:
                    p = -int(round(log(f, 2).evalf()))
                    m = 2 ** p
                    cm = c * m
                    i = int(cm)
                    if i == cm:
                        c = Rational(i, m)
                        cx = c * x
                else:
                    c = Rational(int(c))
                    cx = c * x
            if x.is_integer:
                c2 = c % 2
                if c2 == 1:
                    return x
                elif not c2:
                    if x.is_even is not None:
                        return S.Zero
                    return S(2)
                else:
                    return c2 * x
            return cx

.sympy.functions.elementary.trigonometric.sin.eval

def eval(cls, arg):
    from sympy.calculus import AccumBounds
    if arg.is_Number:
        if arg is S.NaN:
            return S.NaN
        elif arg is S.Zero:
            return S.Zero
        elif arg is S.Infinity or arg is S.NegativeInfinity:
            return AccumBounds(-1, 1)
    if isinstance(arg, AccumBounds):
        min, max = (arg.min, arg.max)
        d = floor(min / (2 * S.Pi))
        if min is not S.NegativeInfinity:
            min = min - d * 2 * S.Pi
        if max is not S.Infinity:
            max = max - d * 2 * S.Pi
        if AccumBounds(min, max).intersection(FiniteSet(S.Pi / 2, 5 * S.Pi / 2)) is not S.EmptySet and AccumBounds(min, max).intersection(FiniteSet(3 * S.Pi / 2, 7 * S.Pi / 2)) is not S.EmptySet:
            return AccumBounds(-1, 1)
        elif AccumBounds(min, max).intersection(FiniteSet(S.Pi / 2, 5 * S.Pi / 2)) is not S.EmptySet:
            return AccumBounds(Min(sin(min), sin(max)), 1)
        elif AccumBounds(min, max).intersection(FiniteSet(3 * S.Pi / 2, 8 * S.Pi / 2)) is not S.EmptySet:
            return AccumBounds(-1, Max(sin(min), sin(max)))
        else:
            return AccumBounds(Min(sin(min), sin(max)), Max(sin(min), sin(max)))
    if arg.could_extract_minus_sign():
        return -cls(-arg)
    i_coeff = arg.as_coefficient(S.ImaginaryUnit)
    if i_coeff is not None:
        return S.ImaginaryUnit * sinh(i_coeff)
    pi_coeff = _pi_coeff(arg)
    if pi_coeff is not None:
        if pi_coeff.is_integer:
            return S.Zero
        if (2 * pi_coeff).is_integer:
            if pi_coeff.is_even:
                return S.Zero
            elif pi_coeff.is_even is False:
                return S.NegativeOne ** (pi_coeff - S.Half)
        if not pi_coeff.is_Rational:
            narg = pi_coeff * S.Pi
            if narg != arg:
                return cls(narg)
            return None
        if pi_coeff.is_Rational:
            x = pi_coeff % 2
            if x > 1:
                return -cls(x % 1 * S.Pi)
            if 2 * x > 1:
                return cls((1 - x) * S.Pi)
            narg = (pi_coeff + Rational(3, 2)) % 2 * S.Pi
            result = cos(narg)
            if not isinstance(result, cos):
                return result
            if pi_coeff * S.Pi != arg:
                return cls(pi_coeff * S.Pi)
            return None
    if arg.is_Add:
        x, m = _peeloff_pi(arg)
        if m:
            return sin(m) * cos(x) + cos(m) * sin(x)
    if isinstance(arg, asin):
        return arg.args[0]
    if isinstance(arg, atan):
        x = arg.args[0]
        return x / sqrt(1 + x ** 2)
    if isinstance(arg, atan2):
        y, x = arg.args
        return y / sqrt(x ** 2 + y ** 2)
    if isinstance(arg, acos):
        x = arg.args[0]
        return sqrt(1 - x ** 2)
    if isinstance(arg, acot):
        x = arg.args[0]
        return 1 / (sqrt(1 + 1 / x ** 2) * x)
    if isinstance(arg, acsc):
        x = arg.args[0]
        return 1 / x
    if isinstance(arg, asec):
        x = arg.args[0]
        return sqrt(1 - 1 / x ** 2)

.sympy.core.compatibility.is_sequence

def is_sequence(i, include=None):
    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))

.sympy.core.exprtools.Factors.lcm

def lcm(self, other):
    if not isinstance(other, Factors):
        other = Factors(other)
        if any((f.is_zero for f in (self, other))):
            return Factors(S.Zero)
    factors = dict(self.factors)
    for factor, exp in other.factors.items():
        if factor in factors:
            exp = max(exp, factors[factor])
        factors[factor] = exp
    return Factors(factors)

.sympy.core.exprtools.Factors.quo

def quo(self, other):
    return self.div(other)[0]

.sympy.core.exprtools.Factors.div

def div(self, other):
    quo, rem = (dict(self.factors), {})
    if not isinstance(other, Factors):
        other = Factors(other)
        if other.is_zero:
            raise ZeroDivisionError
        if self.is_zero:
            return (Factors(S.Zero), Factors())
    for factor, exp in other.factors.items():
        if factor in quo:
            d = quo[factor] - exp
            if _isnumber(d):
                if d <= 0:
                    del quo[factor]
                if d >= 0:
                    if d:
                        quo[factor] = d
                    continue
                exp = -d
            else:
                r = quo[factor].extract_additively(exp)
                if r is not None:
                    if r:
                        quo[factor] = r
                    else:
                        del quo[factor]
                else:
                    other_exp = exp
                    sc, sa = quo[factor].as_coeff_Add()
                    if sc:
                        oc, oa = other_exp.as_coeff_Add()
                        diff = sc - oc
                        if diff > 0:
                            quo[factor] -= oc
                            other_exp = oa
                        elif diff < 0:
                            quo[factor] -= sc
                            other_exp = oa - diff
                        else:
                            quo[factor] = sa
                            other_exp = oa
                    if other_exp:
                        rem[factor] = other_exp
                    else:
                        assert factor not in rem
                continue
        rem[factor] = exp
    return (Factors(quo), Factors(rem))

.sympy.core.function.Function._eval_is_complex

def _eval_is_complex(self):
    return fuzzy_and((a.is_complex for a in self.args))

.sympy.functions.elementary.trigonometric.cos._eval_is_real

def _eval_is_real(self):
    return self.args[0].is_real

.sympy.functions.elementary.trigonometric.sin._eval_is_real

def _eval_is_real(self):
    return self.args[0].is_real

.sympy.core.power.Pow._eval_is_integer

def _eval_is_integer(self):
    b, e = self.args
    if b.is_rational:
        if b.is_integer is False and e.is_positive:
            return False
    if b.is_integer and e.is_integer:
        if b is S.NegativeOne:
            return True
        if e.is_nonnegative or e.is_positive:
            return True
    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
            return False
    if b.is_Number and e.is_Number:
        check = self.func(*self.args)
        return check.is_Integer

.sympy.functions.elementary.trigonometric.TrigonometricFunction._eval_is_rational

def _eval_is_rational(self):
    s = self.func(*self.args)
    if s.func == self.func:
        if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):
            return False
    else:
        return s.is_rational

.sympy.core.logic.fuzzy_not

def fuzzy_not(v):
    if v is None:
        return v
    else:
        return not v

.sympy.core.power.Pow._eval_is_odd

def _eval_is_odd(self):
    if self.exp.is_integer:
        if self.exp.is_positive:
            return self.base.is_odd
        elif self.exp.is_nonnegative and self.base.is_odd:
            return True
        elif self.base is S.NegativeOne:
            return True

.sympy.functions.elementary.trigonometric.TrigonometricFunction._eval_is_algebraic

def _eval_is_algebraic(self):
    s = self.func(*self.args)
    if s.func == self.func:
        if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
            return False
        pi_coeff = _pi_coeff(self.args[0])
        if pi_coeff is not None and pi_coeff.is_rational:
            return True
    else:
        return s.is_algebraic

.sympy.core.function.count_ops

def count_ops(expr, visual=False):
    from sympy import Integral, Symbol
    from sympy.simplify.radsimp import fraction
    from sympy.logic.boolalg import BooleanFunction
    expr = sympify(expr)
    if isinstance(expr, Expr):
        ops = []
        args = [expr]
        NEG = Symbol('NEG')
        DIV = Symbol('DIV')
        SUB = Symbol('SUB')
        ADD = Symbol('ADD')
        while args:
            a = args.pop()
            if isinstance(a, string_types):
                continue
            if a.is_Rational:
                if a is not S.One:
                    if a.p < 0:
                        ops.append(NEG)
                    if a.q != 1:
                        ops.append(DIV)
                    continue
            elif a.is_Mul:
                if _coeff_isneg(a):
                    ops.append(NEG)
                    if a.args[0] is S.NegativeOne:
                        a = a.as_two_terms()[1]
                    else:
                        a = -a
                n, d = fraction(a)
                if n.is_Integer:
                    ops.append(DIV)
                    if n < 0:
                        ops.append(NEG)
                    args.append(d)
                    continue
                elif d is not S.One:
                    if not d.is_Integer:
                        args.append(d)
                    ops.append(DIV)
                    args.append(n)
                    continue
            elif a.is_Add:
                aargs = list(a.args)
                negs = 0
                for i, ai in enumerate(aargs):
                    if _coeff_isneg(ai):
                        negs += 1
                        args.append(-ai)
                        if i > 0:
                            ops.append(SUB)
                    else:
                        args.append(ai)
                        if i > 0:
                            ops.append(ADD)
                if negs == len(aargs):
                    ops.append(NEG)
                elif _coeff_isneg(aargs[0]):
                    ops.append(SUB - ADD)
                continue
            if a.is_Pow and a.exp is S.NegativeOne:
                ops.append(DIV)
                args.append(a.base)
                continue
            if a.is_Mul or a.is_Pow or a.is_Function or isinstance(a, Derivative) or isinstance(a, Integral):
                o = Symbol(a.func.__name__.upper())
                if a.is_Mul or isinstance(a, LatticeOp):
                    ops.append(o * (len(a.args) - 1))
                else:
                    ops.append(o)
            if not a.is_Symbol:
                args.extend(a.args)
    elif type(expr) is dict:
        ops = [count_ops(k, visual=visual) + count_ops(v, visual=visual) for k, v in expr.items()]
    elif iterable(expr):
        ops = [count_ops(i, visual=visual) for i in expr]
    elif isinstance(expr, BooleanFunction):
        ops = []
        for arg in expr.args:
            ops.append(count_ops(arg, visual=True))
        o = Symbol(expr.func.__name__.upper())
        ops.append(o)
    elif not isinstance(expr, Basic):
        ops = []
    elif not isinstance(expr, Basic):
        raise TypeError('Invalid type of expr')
    else:
        ops = []
        args = [expr]
        while args:
            a = args.pop()
            if isinstance(a, string_types):
                continue
            if a.args:
                o = Symbol(a.func.__name__.upper())
                if a.is_Boolean:
                    ops.append(o * (len(a.args) - 1))
                else:
                    ops.append(o)
                args.extend(a.args)
    if not ops:
        if visual:
            return S.Zero
        return 0
    ops = Add(*ops)
    if visual:
        return ops
    if ops.is_Number:
        return int(ops)
    return sum((int((a.args or [1])[0]) for a in Add.make_args(ops)))

.sympy.core.symbol.Symbol.__new__

def __new__(cls, name, **assumptions):
    cls._sanitize(assumptions, cls)
    return Symbol.__xnew_cached_(cls, name, **assumptions)

.sympy.core.symbol.Symbol._sanitize

def _sanitize(assumptions, obj=None):
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    if is_commutative is None:
        whose = '%s ' % obj.__name__ if obj else ''
        raise ValueError('%scommutativity must be True or False.' % whose)
    for key in list(assumptions.keys()):
        from collections import defaultdict
        from sympy.utilities.exceptions import SymPyDeprecationWarning
        keymap = defaultdict(lambda: None)
        keymap.update({'bounded': 'finite', 'unbounded': 'infinite', 'infinitesimal': 'zero'})
        if keymap[key]:
            SymPyDeprecationWarning(feature='%s assumption' % key, useinstead='%s' % keymap[key], issue=8071, deprecated_since_version='0.7.6').warn()
            assumptions[keymap[key]] = assumptions[key]
            assumptions.pop(key)
            key = keymap[key]
        v = assumptions[key]
        if v is None:
            assumptions.pop(key)
            continue
        assumptions[key] = bool(v)

.sympy.core.symbol.Symbol.__new_stage2__

def __new_stage2__(cls, name, **assumptions):
    if not isinstance(name, string_types):
        raise TypeError('name should be a string, not %s' % repr(type(name)))
    obj = Expr.__new__(cls)
    obj.name = name
    tmp_asm_copy = assumptions.copy()
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    assumptions['commutative'] = is_commutative
    obj._assumptions = StdFactKB(assumptions)
    obj._assumptions._generator = tmp_asm_copy
    return obj

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))

.sympy.core.numbers.Integer.__int__

def __int__(self):
    return self.p

.sympy.simplify.hyperexpand.hyperexpand

def hyperexpand(f, allow_hyper=False, rewrite='default', place=None):
    f = sympify(f)

    def do_replace(ap, bq, z):
        r = _hyperexpand(Hyper_Function(ap, bq), z, rewrite=rewrite)
        if r is None:
            return hyper(ap, bq, z)
        else:
            return r

    def do_meijer(ap, bq, z):
        r = _meijergexpand(G_Function(ap[0], ap[1], bq[0], bq[1]), z, allow_hyper, rewrite=rewrite, place=place)
        if not r.has(nan, zoo, oo, -oo):
            return r
    return f.replace(hyper, do_replace).replace(meijerg, do_meijer)

.sympy.core.basic.Basic.replace

def replace(self, query, value, map=False, simultaneous=True, exact=False):
    from sympy.core.symbol import Dummy
    from sympy.simplify.simplify import bottom_up
    try:
        query = sympify(query)
    except SympifyError:
        pass
    try:
        value = sympify(value)
    except SympifyError:
        pass
    if isinstance(query, type):
        _query = lambda expr: isinstance(expr, query)
        if isinstance(value, type):
            _value = lambda expr, result: value(*expr.args)
        elif callable(value):
            _value = lambda expr, result: value(*expr.args)
        else:
            raise TypeError('given a type, replace() expects another type or a callable')
    elif isinstance(query, Basic):
        _query = lambda expr: expr.match(query)
        if isinstance(value, Basic):
            if exact:
                _value = lambda expr, result: value.subs(result) if all((val for val in result.values())) else expr
            else:
                _value = lambda expr, result: value.subs(result)
        elif callable(value):
            if exact:
                _value = lambda expr, result: value(**dict([(str(key)[:-1], val) for key, val in result.items()])) if all((val for val in result.values())) else expr
            else:
                _value = lambda expr, result: value(**dict([(str(key)[:-1], val) for key, val in result.items()]))
        else:
            raise TypeError('given an expression, replace() expects another expression or a callable')
    elif callable(query):
        _query = query
        if callable(value):
            _value = lambda expr, result: value(expr)
        else:
            raise TypeError('given a callable, replace() expects another callable')
    else:
        raise TypeError('first argument to replace() must be a type, an expression or a callable')
    mapping = {}
    mask = []

    def rec_replace(expr):
        result = _query(expr)
        if result or result == {}:
            new = _value(expr, result)
            if new is not None and new != expr:
                mapping[expr] = new
                if simultaneous:
                    com = getattr(new, 'is_commutative', True)
                    if com is None:
                        com = True
                    d = Dummy(commutative=com)
                    mask.append((d, new))
                    expr = d
                else:
                    expr = new
        return expr
    rv = bottom_up(self, rec_replace, atoms=True)
    if simultaneous:
        mask = list(reversed(mask))
        for o, n in mask:
            r = {o: n}
            rv = rv.xreplace(r)
    if not map:
        return rv
    else:
        if simultaneous:
            for o, n in mask:
                r = {o: n}
                mapping = {k.xreplace(r): v.xreplace(r) for k, v in mapping.items()}
        return (rv, mapping)

.sympy.parsing.sympy_parser.parse_expr

def parse_expr(s, local_dict=None, transformations=standard_transformations, global_dict=None, evaluate=True):
    if local_dict is None:
        local_dict = {}
    if global_dict is None:
        global_dict = {}
        exec_('from sympy import *', global_dict)
    code = stringify_expr(s, local_dict, global_dict, transformations)
    if not evaluate:
        code = compile(evaluateFalse(code), '<string>', 'eval')
    return eval_expr(code, local_dict, global_dict)

.sympy.parsing.sympy_parser.stringify_expr

def stringify_expr(s, local_dict, global_dict, transformations):
    tokens = []
    input_code = StringIO(s.strip())
    for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):
        tokens.append((toknum, tokval))
    for transform in transformations:
        tokens = transform(tokens, local_dict, global_dict)
    return untokenize(tokens)

.sympy.parsing.sympy_tokenize.generate_tokens

def generate_tokens(readline):
    lnum = parenlev = continued = 0
    namechars, numchars = (string.ascii_letters + '_', '0123456789')
    contstr, needcont = ('', 0)
    contline = None
    indents = [0]
    while 1:
        try:
            line = readline()
        except StopIteration:
            line = ''
        lnum = lnum + 1
        pos, max = (0, len(line))
        if contstr:
            if not line:
                raise TokenError('EOF in multi-line string', strstart)
            endmatch = endprog.match(line)
            if endmatch:
                pos = end = endmatch.end(0)
                yield (STRING, contstr + line[:end], strstart, (lnum, end), contline + line)
                contstr, needcont = ('', 0)
                contline = None
            elif needcont and line[-2:] != '\\\n' and (line[-3:] != '\\\r\n'):
                yield (ERRORTOKEN, contstr + line, strstart, (lnum, len(line)), contline)
                contstr = ''
                contline = None
                continue
            else:
                contstr = contstr + line
                contline = contline + line
                continue
        elif parenlev == 0 and (not continued):
            if not line:
                break
            column = 0
            while pos < max:
                if line[pos] == ' ':
                    column = column + 1
                elif line[pos] == '\t':
                    column = (column / tabsize + 1) * tabsize
                elif line[pos] == '\x0c':
                    column = 0
                else:
                    break
                pos = pos + 1
            if pos == max:
                break
            if line[pos] in '#\r\n':
                if line[pos] == '#':
                    comment_token = line[pos:].rstrip('\r\n')
                    nl_pos = pos + len(comment_token)
                    yield (COMMENT, comment_token, (lnum, pos), (lnum, pos + len(comment_token)), line)
                    yield (NL, line[nl_pos:], (lnum, nl_pos), (lnum, len(line)), line)
                else:
                    yield ((NL, COMMENT)[line[pos] == '#'], line[pos:], (lnum, pos), (lnum, len(line)), line)
                continue
            if column > indents[-1]:
                indents.append(column)
                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
            while column < indents[-1]:
                if column not in indents:
                    raise IndentationError('unindent does not match any outer indentation level', ('<tokenize>', lnum, pos, line))
                indents = indents[:-1]
                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)
        else:
            if not line:
                raise TokenError('EOF in multi-line statement', (lnum, 0))
            continued = 0
        while pos < max:
            pseudomatch = pseudoprog.match(line, pos)
            if pseudomatch:
                start, end = pseudomatch.span(1)
                spos, epos, pos = ((lnum, start), (lnum, end), end)
                token, initial = (line[start:end], line[start])
                if initial in numchars or (initial == '.' and token != '.'):
                    yield (NUMBER, token, spos, epos, line)
                elif initial in '\r\n':
                    yield (NL if parenlev > 0 else NEWLINE, token, spos, epos, line)
                elif initial == '#':
                    if token.endswith('\n'):
                        raise ValueError('Token should not end with \n')
                    yield (COMMENT, token, spos, epos, line)
                elif token in triple_quoted:
                    endprog = endprogs[token]
                    endmatch = endprog.match(line, pos)
                    if endmatch:
                        pos = endmatch.end(0)
                        token = line[start:pos]
                        yield (STRING, token, spos, (lnum, pos), line)
                    else:
                        strstart = (lnum, start)
                        contstr = line[start:]
                        contline = line
                        break
                elif initial in single_quoted or token[:2] in single_quoted or token[:3] in single_quoted:
                    if token[-1] == '\n':
                        strstart = (lnum, start)
                        endprog = endprogs[initial] or endprogs[token[1]] or endprogs[token[2]]
                        contstr, needcont = (line[start:], 1)
                        contline = line
                        break
                    else:
                        yield (STRING, token, spos, epos, line)
                elif initial in namechars:
                    yield (NAME, token, spos, epos, line)
                elif initial == '\\':
                    continued = 1
                else:
                    if initial in '([{':
                        parenlev = parenlev + 1
                    elif initial in ')]}':
                        parenlev = parenlev - 1
                    yield (OP, token, spos, epos, line)
            else:
                yield (ERRORTOKEN, line[pos], (lnum, pos), (lnum, pos + 1), line)
                pos = pos + 1
    for indent in indents[1:]:
        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')
    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')

.sympy.parsing.sympy_parser.lambda_notation

def lambda_notation(tokens, local_dict, global_dict):
    result = []
    flag = False
    toknum, tokval = tokens[0]
    tokLen = len(tokens)
    if toknum == NAME and tokval == 'lambda':
        if tokLen == 2:
            result.extend(tokens)
        elif tokLen > 2:
            result.extend([(NAME, 'Lambda'), (OP, '('), (OP, '('), (OP, ')'), (OP, ')')])
            for tokNum, tokVal in tokens[1:]:
                if tokNum == OP and tokVal == ':':
                    tokVal = ','
                    flag = True
                if not flag and tokNum == OP and (tokVal in ['*', '**']):
                    raise TokenError('Starred arguments in lambda not supported')
                if flag:
                    result.insert(-1, (tokNum, tokVal))
                else:
                    result.insert(-2, (tokNum, tokVal))
    else:
        result.extend(tokens)
    return result

.sympy.parsing.sympy_parser.auto_symbol

def auto_symbol(tokens, local_dict, global_dict):
    result = []
    prevTok = (None, None)
    tokens.append((None, None))
    for tok, nextTok in zip(tokens, tokens[1:]):
        tokNum, tokVal = tok
        nextTokNum, nextTokVal = nextTok
        if tokNum == NAME:
            name = tokVal
            if name in ['True', 'False', 'None'] or iskeyword(name) or name in local_dict or (prevTok[0] == OP and prevTok[1] == '.') or (prevTok[0] == OP and prevTok[1] in ('(', ',') and (nextTokNum == OP) and (nextTokVal == '=')):
                result.append((NAME, name))
                continue
            elif name in global_dict:
                obj = global_dict[name]
                if isinstance(obj, (Basic, type)) or callable(obj):
                    result.append((NAME, name))
                    continue
            result.extend([(NAME, 'Symbol'), (OP, '('), (NAME, repr(str(name))), (OP, ')')])
        else:
            result.append((tokNum, tokVal))
        prevTok = (tokNum, tokVal)
    return result

.sympy.parsing.sympy_parser.auto_number

def auto_number(tokens, local_dict, global_dict):
    result = []
    prevtoken = ''
    for toknum, tokval in tokens:
        if toknum == NUMBER:
            number = tokval
            postfix = []
            if number.endswith('j') or number.endswith('J'):
                number = number[:-1]
                postfix = [(OP, '*'), (NAME, 'I')]
            if '.' in number or (('e' in number or 'E' in number) and (not (number.startswith('0x') or number.startswith('0X')))):
                match = _re_repeated.match(number)
                if match is not None:
                    pre, post, repetend = match.groups()
                    zeros = '0' * len(post)
                    post, repetends = [w.lstrip('0') for w in [post, repetend]]
                    a = pre or '0'
                    b, c = (post or '0', '1' + zeros)
                    d, e = (repetends, '9' * len(repetend) + zeros)
                    seq = [(OP, '('), (NAME, 'Integer'), (OP, '('), (NUMBER, a), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, b), (OP, ','), (NUMBER, c), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, d), (OP, ','), (NUMBER, e), (OP, ')'), (OP, ')')]
                else:
                    seq = [(NAME, 'Float'), (OP, '('), (NUMBER, repr(str(number))), (OP, ')')]
            else:
                seq = [(NAME, 'Integer'), (OP, '('), (NUMBER, number), (OP, ')')]
            result.extend(seq + postfix)
        else:
            result.append((toknum, tokval))
    return result

.sympy.parsing.sympy_parser.factorial_notation

def factorial_notation(tokens, local_dict, global_dict):
    result = []
    prevtoken = ''
    for toknum, tokval in tokens:
        if toknum == OP:
            op = tokval
            if op == '!!':
                if prevtoken == '!' or prevtoken == '!!':
                    raise TokenError
                result = _add_factorial_tokens('factorial2', result)
            elif op == '!':
                if prevtoken == '!' or prevtoken == '!!':
                    raise TokenError
                result = _add_factorial_tokens('factorial', result)
            else:
                result.append((OP, op))
        else:
            result.append((toknum, tokval))
        prevtoken = tokval
    return result

.sympy.parsing.sympy_parser.convert_xor

def convert_xor(tokens, local_dict, global_dict):
    result = []
    for toknum, tokval in tokens:
        if toknum == OP:
            if tokval == '^':
                result.append((OP, '**'))
            else:
                result.append((toknum, tokval))
        else:
            result.append((toknum, tokval))
    return result

.sympy.parsing.sympy_tokenize.untokenize

def untokenize(iterable):
    ut = Untokenizer()
    return ut.untokenize(iterable)

.sympy.parsing.sympy_tokenize.Untokenizer.__init__

def __init__(self):
    self.tokens = []
    self.prev_row = 1
    self.prev_col = 0

.sympy.parsing.sympy_tokenize.Untokenizer.untokenize

def untokenize(self, iterable):
    for t in iterable:
        if len(t) == 2:
            self.compat(t, iterable)
            break
        tok_type, token, start, end, line = t
        self.add_whitespace(start)
        self.tokens.append(token)
        self.prev_row, self.prev_col = end
        if tok_type in (NEWLINE, NL):
            self.prev_row += 1
            self.prev_col = 0
    return ''.join(self.tokens)

.sympy.parsing.sympy_tokenize.Untokenizer.compat

def compat(self, token, iterable):
    startline = False
    indents = []
    toks_append = self.tokens.append
    toknum, tokval = token
    if toknum in (NAME, NUMBER):
        tokval += ' '
    if toknum in (NEWLINE, NL):
        startline = True
    prevstring = False
    for tok in iterable:
        toknum, tokval = tok[:2]
        if toknum in (NAME, NUMBER):
            tokval += ' '
        if toknum == STRING:
            if prevstring:
                tokval = ' ' + tokval
            prevstring = True
        else:
            prevstring = False
        if toknum == INDENT:
            indents.append(tokval)
            continue
        elif toknum == DEDENT:
            indents.pop()
            continue
        elif toknum in (NEWLINE, NL):
            startline = True
        elif startline and indents:
            toks_append(indents[-1])
            startline = False
        toks_append(tokval)

.sympy.parsing.sympy_parser.eval_expr

def eval_expr(code, local_dict, global_dict):
    expr = eval(code, global_dict, local_dict)
    return expr

.sympy.core.basic.Basic.rec_replace

def rec_replace(expr):
    result = _query(expr)
    if result or result == {}:
        new = _value(expr, result)
        if new is not None and new != expr:
            mapping[expr] = new
            if simultaneous:
                com = getattr(new, 'is_commutative', True)
                if com is None:
                    com = True
                d = Dummy(commutative=com)
                mask.append((d, new))
                expr = d
            else:
                expr = new
    return expr

.sympy.functions.elementary.piecewise.piecewise_fold

def piecewise_fold(expr):
    if not isinstance(expr, Basic) or not expr.has(Piecewise):
        return expr
    new_args = []
    if isinstance(expr, (ExprCondPair, Piecewise)):
        for e, c in expr.args:
            if not isinstance(e, Piecewise):
                e = piecewise_fold(e)
            if isinstance(e, Piecewise):
                new_args.extend([(piecewise_fold(ei), And(ci, c)) for ei, ci in e.args])
            else:
                new_args.append((e, c))
    else:
        from sympy.utilities.iterables import cartes
        folded = list(map(piecewise_fold, expr.args))
        for ec in cartes(*[i.args if isinstance(i, Piecewise) else [(i, S.true)] for i in folded]):
            e, c = zip(*ec)
            new_args.append((expr.func(*e), And(*c)))
    return Piecewise(*new_args)

.sympy.simplify.trigsimp.trigsimp

def trigsimp(expr, **opts):
    from sympy.simplify.fu import fu
    expr = sympify(expr)
    try:
        return expr._eval_trigsimp(**opts)
    except AttributeError:
        pass
    old = opts.pop('old', False)
    if not old:
        opts.pop('deep', None)
        recursive = opts.pop('recursive', None)
        method = opts.pop('method', 'matching')
    else:
        method = 'old'

    def groebnersimp(ex, **opts):

        def traverse(e):
            if e.is_Atom:
                return e
            args = [traverse(x) for x in e.args]
            if e.is_Function or e.is_Pow:
                args = [trigsimp_groebner(x, **opts) for x in args]
            return e.func(*args)
        new = traverse(ex)
        if not isinstance(new, Expr):
            return new
        return trigsimp_groebner(new, **opts)
    trigsimpfunc = {'fu': lambda x: fu(x, **opts), 'matching': lambda x: futrig(x), 'groebner': lambda x: groebnersimp(x, **opts), 'combined': lambda x: futrig(groebnersimp(x, polynomial=True, hints=[2, tan])), 'old': lambda x: trigsimp_old(x, **opts)}[method]
    return trigsimpfunc(expr)

.sympy.simplify.trigsimp.futrig

def futrig(e, **kwargs):
    from sympy.simplify.fu import hyper_as_trig
    from sympy.simplify.simplify import bottom_up
    e = sympify(e)
    if not isinstance(e, Basic):
        return e
    if not e.args:
        return e
    old = e
    e = bottom_up(e, lambda x: _futrig(x, **kwargs))
    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):
        e, f = hyper_as_trig(e)
        e = f(_futrig(e))
    if e != old and e.is_Mul and e.args[0].is_Rational:
        e = Mul(*e.as_coeff_Mul())
    return e

.sympy.simplify.trigsimp._futrig

def _futrig(e, **kwargs):
    from sympy.simplify.fu import TR1, TR2, TR3, TR2i, TR10, L, TR10i, TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22, TR12
    from sympy.core.compatibility import _nodes
    if not e.has(TrigonometricFunction):
        return e
    if e.is_Mul:
        coeff, e = e.as_independent(TrigonometricFunction)
    else:
        coeff = S.One
    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)
    trigs = lambda x: x.has(TrigonometricFunction)
    tree = [identity, (TR3, TR1, TR12, lambda x: _eapply(factor, x, trigs), TR2, [identity, lambda x: _eapply(_mexpand, x, trigs)], TR2i, lambda x: _eapply(lambda i: factor(i.normal()), x, trigs), TR14, TR5, TR10, TR11, TR6, lambda x: _eapply(factor, x, trigs), TR14, [identity, lambda x: _eapply(_mexpand, x, trigs)], TRmorrie, TR10i, [identity, TR8], [identity, lambda x: TR2i(TR2(x))], [lambda x: _eapply(expand_mul, TR5(x), trigs), lambda x: _eapply(expand_mul, TR15(x), trigs)], [lambda x: _eapply(expand_mul, TR6(x), trigs), lambda x: _eapply(expand_mul, TR16(x), trigs)], TR111, [identity, TR2i], [identity, lambda x: _eapply(expand_mul, TR22(x), trigs)], TR1, TR2, TR2i, [identity, lambda x: _eapply(factor_terms, TR12(x), trigs)])]
    e = greedy(tree, objective=Lops)(e)
    return coeff * e

.sympy.strategies.tree.greedy

def greedy(tree, objective=identity, **kwargs):
    optimize = partial(minimize, objective=objective)
    return treeapply(tree, {list: optimize, tuple: chain}, **kwargs)

.sympy.strategies.tree.treeapply

def treeapply(tree, join, leaf=identity):
    for typ in join:
        if isinstance(tree, typ):
            return join[typ](*map(partial(treeapply, join=join, leaf=leaf), tree))
    return leaf(tree)

.sympy.strategies.core.minimize

def minimize(*rules, **kwargs):
    objective = kwargs.get('objective', identity)

    def minrule(expr):
        return min([rule(expr) for rule in rules], key=objective)
    return minrule

.sympy.strategies.core.chain

def chain(*rules):

    def chain_rl(expr):
        for rule in rules:
            expr = rule(expr)
        return expr
    return chain_rl

.sympy.strategies.core.minrule

def minrule(expr):
    return min([rule(expr) for rule in rules], key=objective)

.sympy.strategies.core.chain_rl

def chain_rl(expr):
    for rule in rules:
        expr = rule(expr)
    return expr

.sympy.simplify.fu.TR3

def TR3(rv):
    from sympy.simplify.simplify import signsimp

    def f(rv):
        if not isinstance(rv, TrigonometricFunction):
            return rv
        rv = rv.func(signsimp(rv.args[0]))
        if (rv.args[0] - S.Pi / 4).is_positive is (S.Pi / 2 - rv.args[0]).is_positive is True:
            fmap = {cos: sin, sin: cos, tan: cot, cot: tan, sec: csc, csc: sec}
            rv = fmap[rv.func](S.Pi / 2 - rv.args[0])
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.f

def f(rv):
    if not isinstance(rv, TrigonometricFunction):
        return rv
    const, x = rv.args[0].as_independent(d, as_Add=True)
    a = x.xreplace({d: S.One}) + const * I
    if isinstance(rv, sin):
        return sinh(a) / I
    elif isinstance(rv, cos):
        return cosh(a)
    elif isinstance(rv, tan):
        return tanh(a) / I
    elif isinstance(rv, cot):
        return coth(a) * I
    elif isinstance(rv, sec):
        return sech(a)
    elif isinstance(rv, csc):
        return csch(a) * I
    else:
        raise NotImplementedError('unhandled %s' % rv.func)

.sympy.core.numbers.Integer.__sub__

def __sub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

.sympy.core.numbers.Rational.__sub__

def __sub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p - self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return -other + self
        else:
            return Number.__sub__(self, other)
    return Number.__sub__(self, other)

.sympy.core.numbers.Number.__sub__

def __sub__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            return S.Infinity
    return AtomicExpr.__sub__(self, other)

.sympy.core.mul.Mul._eval_is_zero

def _eval_is_zero(self):
    zero = infinite = False
    for a in self.args:
        z = a.is_zero
        if z:
            if infinite:
                return
            zero = True
        else:
            if not a.is_finite:
                if zero:
                    return
                infinite = True
            if zero is False and z is None:
                zero = None
    return zero

.sympy.core.numbers.Number._eval_is_finite

def _eval_is_finite(self):
    return True

.sympy.core.mul.Mul._eval_evalf

def _eval_evalf(self, prec):
    c, m = self.as_coeff_Mul()
    if c is S.NegativeOne:
        if m.is_Mul:
            rv = -AssocOp._eval_evalf(m, prec)
        else:
            mnew = m._eval_evalf(prec)
            if mnew is not None:
                m = mnew
            rv = -m
    else:
        rv = AssocOp._eval_evalf(self, prec)
    if rv.is_number:
        return rv.expand()
    return rv

.sympy.core.numbers.Rational._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_rational(self.p, self.q, prec, rnd)

.sympy.core.numbers.Rational.__neg__

def __neg__(self):
    return Rational(-self.p, self.q)

.sympy.core.mul._unevaluated_Mul

def _unevaluated_Mul(*args):
    args = list(args)
    newargs = []
    ncargs = []
    co = S.One
    while args:
        a = args.pop()
        if a.is_Mul:
            c, nc = a.args_cnc()
            args.extend(c)
            if nc:
                ncargs.append(Mul._from_args(nc))
        elif a.is_Number:
            co *= a
        else:
            newargs.append(a)
    _mulsort(newargs)
    if co is not S.One:
        newargs.insert(0, co)
    if ncargs:
        newargs.append(Mul._from_args(ncargs))
    return Mul._from_args(newargs)

.sympy.core.numbers.NumberSymbol._eval_evalf

def _eval_evalf(self, prec):
    return Float._new(self._as_mpf_val(prec), prec)

.sympy.core.numbers.Pi._as_mpf_val

def _as_mpf_val(self, prec):
    return mpf_pi(prec)

.sympy.core.numbers.Float._eval_is_zero

def _eval_is_zero(self):
    return self._mpf_ == _mpf_zero

.sympy.core.numbers.Float.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        rhs, prec = other._as_mpf_op(self._prec)
        return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
    return Number.__mul__(self, other)

.sympy.core.mul.Mul._eval_is_algebraic

def _eval_is_algebraic(self):
    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.mul.Mul._eval_is_integer

def _eval_is_integer(self):
    is_rational = self.is_rational
    if is_rational:
        n, d = self.as_numer_denom()
        if d is S.One:
            return True
        elif d is S(2):
            return n.is_even
    elif is_rational is False:
        return False

.sympy.core.mul.Mul._eval_is_rational

def _eval_is_rational(self):
    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.numbers.Rational._eval_is_positive

def _eval_is_positive(self):
    return self.p > 0

.sympy.printing.str.StrPrinter._print_Pi

def _print_Pi(self, expr):
    return 'pi'

.sympy.core.basic.Atom.class_key

def class_key(cls):
    return (2, 0, cls.__name__)

.sympy.core.mul.Mul._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):
                return True
            return
        if a is None:
            return
    return False

.sympy.functions.elementary.trigonometric._peeloff_pi

def _peeloff_pi(arg):
    for a in Add.make_args(arg):
        if a is S.Pi:
            K = S.One
            break
        elif a.is_Mul:
            K, p = a.as_two_terms()
            if p is S.Pi and K.is_Rational:
                break
    else:
        return (arg, S.Zero)
    m1 = K % S.Half * S.Pi
    m2 = K * S.Pi - m1
    return (arg - m2, m2)

.sympy.core.mul.Mul.as_two_terms

def as_two_terms(self):
    args = self.args
    if len(args) == 1:
        return (S.One, self)
    elif len(args) == 2:
        return args
    else:
        return (args[0], self._new_rawargs(*args[1:]))

.sympy.core.numbers.Rational.__mod__

def __mod__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Rational):
            n = self.p * other.q // (other.p * self.q)
            return Rational(self.p * other.q - n * other.p * self.q, self.q * other.q)
        if isinstance(other, Float):
            return Float(self.__mod__(Rational(other)), precision=other._prec)
        return Number.__mod__(self, other)
    return Number.__mod__(self, other)

.sympy.core.expr.Expr.coeff

def coeff(self, x, n=1, right=False):
    x = sympify(x)
    if not isinstance(x, Basic):
        return S.Zero
    n = as_int(n)
    if not x:
        return S.Zero
    if x == self:
        if n == 1:
            return S.One
        return S.Zero
    if x is S.One:
        co = [a for a in Add.make_args(self) if a.as_coeff_Mul()[0] is S.One]
        if not co:
            return S.Zero
        return Add(*co)
    if n == 0:
        if x.is_Add and self.is_Add:
            c = self.coeff(x, right=right)
            if not c:
                return S.Zero
            if not right:
                return self - Add(*[a * x for a in Add.make_args(c)])
            return self - Add(*[x * a for a in Add.make_args(c)])
        return self.as_independent(x, as_Add=True)[0]
    x = x ** n

    def incommon(l1, l2):
        if not l1 or not l2:
            return []
        n = min(len(l1), len(l2))
        for i in range(n):
            if l1[i] != l2[i]:
                return l1[:i]
        return l1[:]

    def find(l, sub, first=True):
        if not sub or not l or len(sub) > len(l):
            return None
        n = len(sub)
        if not first:
            l.reverse()
            sub.reverse()
        for i in range(0, len(l) - n + 1):
            if all((l[i + j] == sub[j] for j in range(n))):
                break
        else:
            i = None
        if not first:
            l.reverse()
            sub.reverse()
        if i is not None and (not first):
            i = len(l) - (i + n)
        return i
    co = []
    args = Add.make_args(self)
    self_c = self.is_commutative
    x_c = x.is_commutative
    if self_c and (not x_c):
        return S.Zero
    if self_c:
        xargs = x.args_cnc(cset=True, warn=False)[0]
        for a in args:
            margs = a.args_cnc(cset=True, warn=False)[0]
            if len(xargs) > len(margs):
                continue
            resid = margs.difference(xargs)
            if len(resid) + len(xargs) == len(margs):
                co.append(Mul(*resid))
        if co == []:
            return S.Zero
        elif co:
            return Add(*co)
    elif x_c:
        xargs = x.args_cnc(cset=True, warn=False)[0]
        for a in args:
            margs, nc = a.args_cnc(cset=True)
            if len(xargs) > len(margs):
                continue
            resid = margs.difference(xargs)
            if len(resid) + len(xargs) == len(margs):
                co.append(Mul(*list(resid) + nc))
        if co == []:
            return S.Zero
        elif co:
            return Add(*co)
    else:
        xargs, nx = x.args_cnc(cset=True)
        for a in args:
            margs, nc = a.args_cnc(cset=True)
            if len(xargs) > len(margs):
                continue
            resid = margs.difference(xargs)
            if len(resid) + len(xargs) == len(margs):
                co.append((resid, nc))
        if not co:
            return S.Zero
        if all((n == co[0][1] for r, n in co)):
            ii = find(co[0][1], nx, right)
            if ii is not None:
                if not right:
                    return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
                else:
                    return Mul(*co[0][1][ii + len(nx):])
        beg = reduce(incommon, (n[1] for n in co))
        if beg:
            ii = find(beg, nx, right)
            if ii is not None:
                if not right:
                    gcdc = co[0][0]
                    for i in range(1, len(co)):
                        gcdc = gcdc.intersection(co[i][0])
                        if not gcdc:
                            break
                    return Mul(*list(gcdc) + beg[:ii])
                else:
                    m = ii + len(nx)
                    return Add(*[Mul(*list(r) + n[m:]) for r, n in co])
        end = list(reversed(reduce(incommon, (list(reversed(n[1])) for n in co))))
        if end:
            ii = find(end, nx, right)
            if ii is not None:
                if not right:
                    return Add(*[Mul(*list(r) + n[:-len(end) + ii]) for r, n in co])
                else:
                    return Mul(*end[ii + len(nx):])
        hit = None
        for i, (r, n) in enumerate(co):
            ii = find(n, nx, right)
            if ii is not None:
                if not hit:
                    hit = (ii, r, n)
                else:
                    break
        else:
            if hit:
                ii, r, n = hit
                if not right:
                    return Mul(*list(r) + n[:ii])
                else:
                    return Mul(*n[ii + len(nx):])
        return S.Zero

.sympy.core.numbers.NumberSymbol.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if self is other:
        return True
    if isinstance(other, Number) and self.is_irrational:
        return False
    return False

.sympy.functions.elementary.trigonometric.sin._eval_is_finite

def _eval_is_finite(self):
    arg = self.args[0]
    if arg.is_real:
        return True

.sympy.core.expr.Expr.__add__

def __add__(self, other):
    return Add(self, other)

.sympy.simplify.fu.TR1

def TR1(rv):

    def f(rv):
        if isinstance(rv, sec):
            a = rv.args[0]
            return S.One / cos(a)
        elif isinstance(rv, csc):
            a = rv.args[0]
            return S.One / sin(a)
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR12

def TR12(rv, first=True):

    def f(rv):
        if not rv.func == tan:
            return rv
        arg = rv.args[0]
        if arg.is_Add:
            if first:
                args = list(ordered(arg.args))
            else:
                args = list(arg.args)
            a = args.pop()
            b = Add._from_args(args)
            if b.is_Add:
                tb = TR12(tan(b), first=False)
            else:
                tb = tan(b)
            return (tan(a) + tb) / (1 - tan(a) * tb)
        return rv
    return bottom_up(rv, f)

.sympy.simplify.trigsimp._eapply

def _eapply(func, e, cond=None):
    if not isinstance(e, Expr):
        return e
    if _is_Expr(e) or not e.args:
        return func(e)
    return e.func(*[_eapply(func, ei) if cond is None or cond(ei) else ei for ei in e.args])

.sympy.simplify.trigsimp._is_Expr

def _is_Expr(e):
    if not isinstance(e, Expr):
        return False
    return all((_is_Expr(i) for i in e.args))

.sympy.polys.polytools.factor

def factor(f, *gens, **args):
    f = sympify(f)
    if args.pop('deep', False):
        partials = {}
        muladd = f.atoms(Mul, Add)
        for p in muladd:
            fac = factor(p, *gens, **args)
            if (fac.is_Mul or fac.is_Pow) and fac != p:
                partials[p] = fac
        return f.xreplace(partials)
    try:
        return _generic_factor(f, gens, args, method='factor')
    except PolynomialError as msg:
        if not f.is_commutative:
            from sympy.core.exprtools import factor_nc
            return factor_nc(f)
        else:
            raise PolynomialError(msg)

.sympy.polys.polytools._generic_factor

def _generic_factor(expr, gens, args, method):
    options.allowed_flags(args, [])
    opt = options.build_options(gens, args)
    return _symbolic_factor(sympify(expr), opt, method)

.sympy.polys.polytools._symbolic_factor

def _symbolic_factor(expr, opt, method):
    if isinstance(expr, Expr) and (not expr.is_Relational):
        if hasattr(expr, '_eval_factor'):
            return expr._eval_factor()
        coeff, factors = _symbolic_factor_list(together(expr), opt, method)
        return _keep_coeff(coeff, _factors_product(factors))
    elif hasattr(expr, 'args'):
        return expr.func(*[_symbolic_factor(arg, opt, method) for arg in expr.args])
    elif hasattr(expr, '__iter__'):
        return expr.__class__([_symbolic_factor(arg, opt, method) for arg in expr])
    else:
        return expr

.sympy.polys.polytools._symbolic_factor_list

def _symbolic_factor_list(expr, opt, method):
    coeff, factors = (S.One, [])
    args = [i._eval_factor() if hasattr(i, '_eval_factor') else i for i in Mul.make_args(expr)]
    for arg in args:
        if arg.is_Number:
            coeff *= arg
            continue
        if arg.is_Mul:
            args.extend(arg.args)
            continue
        if arg.is_Pow:
            base, exp = arg.args
            if base.is_Number and exp.is_Number:
                coeff *= arg
                continue
            if base.is_Number:
                factors.append((base, exp))
                continue
        else:
            base, exp = (arg, S.One)
        try:
            poly, _ = _poly_from_expr(base, opt)
        except PolificationFailed as exc:
            factors.append((exc.expr, exp))
        else:
            func = getattr(poly, method + '_list')
            _coeff, _factors = func()
            if _coeff is not S.One:
                if exp.is_Integer:
                    coeff *= _coeff ** exp
                elif _coeff.is_positive:
                    factors.append((_coeff, exp))
                else:
                    _factors.append((_coeff, S.One))
            if exp is S.One:
                factors.extend(_factors)
            elif exp.is_integer:
                factors.extend([(f, k * exp) for f, k in _factors])
            else:
                other = []
                for f, k in _factors:
                    if f.as_expr().is_positive:
                        factors.append((f, k * exp))
                    else:
                        other.append((f, k))
                factors.append((_factors_product(other), exp))
    return (coeff, factors)

.sympy.polys.polytools._poly_from_expr

def _poly_from_expr(expr, opt):
    orig, expr = (expr, sympify(expr))
    if not isinstance(expr, Basic):
        raise PolificationFailed(opt, orig, expr)
    elif expr.is_Poly:
        poly = expr.__class__._from_poly(expr, opt)
        opt.gens = poly.gens
        opt.domain = poly.domain
        if opt.polys is None:
            opt.polys = True
        return (poly, opt)
    elif opt.expand:
        expr = expr.expand()
    rep, opt = _dict_from_expr(expr, opt)
    if not opt.gens:
        raise PolificationFailed(opt, orig, expr)
    monoms, coeffs = list(zip(*list(rep.items())))
    domain = opt.domain
    if domain is None:
        opt.domain, coeffs = construct_domain(coeffs, opt=opt)
    else:
        coeffs = list(map(domain.from_sympy, coeffs))
    rep = dict(list(zip(monoms, coeffs)))
    poly = Poly._from_dict(rep, opt)
    if opt.polys is None:
        opt.polys = False
    return (poly, opt)

.sympy.polys.polyutils._dict_from_expr

def _dict_from_expr(expr, opt):
    if expr.is_commutative is False:
        raise PolynomialError('non-commutative expressions are not supported')

    def _is_expandable_pow(expr):
        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add
    if opt.expand is not False:
        if not isinstance(expr, Expr):
            raise PolynomialError('expression must be of type Expr')
        expr = expr.expand()
        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):
            expr = expand_multinomial(expr)
        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):
            expr = expand_mul(expr)
    if opt.gens:
        rep, gens = _dict_from_expr_if_gens(expr, opt)
    else:
        rep, gens = _dict_from_expr_no_gens(expr, opt)
    return (rep, opt.clone({'gens': gens}))

.sympy.polys.polyutils._is_expandable_pow

def _is_expandable_pow(expr):
    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add

.sympy.polys.polyutils._dict_from_expr_no_gens

def _dict_from_expr_no_gens(expr, opt):
    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)
    return (poly, gens)

.sympy.polys.polytools.Poly.factor_list

def factor_list(f):
    if hasattr(f.rep, 'factor_list'):
        try:
            coeff, factors = f.rep.factor_list()
        except DomainError:
            return (S.One, [(f, 1)])
    else:
        raise OperationNotSupported(f, 'factor_list')
    return (f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors])

.sympy.polys.polyclasses.DMP.factor_list

def factor_list(f):
    coeff, factors = dmp_factor_list(f.rep, f.lev, f.dom)
    return (coeff, [(f.per(g), k) for g, k in factors])

.sympy.polys.factortools.dmp_factor_list

def dmp_factor_list(f, u, K0):
    if not u:
        return dup_factor_list(f, K0)
    J, f = dmp_terms_gcd(f, u, K0)
    cont, f = dmp_ground_primitive(f, u, K0)
    if K0.is_FiniteField:
        coeff, factors = dmp_gf_factor(f, u, K0)
    elif K0.is_Algebraic:
        coeff, factors = dmp_ext_factor(f, u, K0)
    else:
        if not K0.is_Exact:
            K0_inexact, K0 = (K0, K0.get_exact())
            f = dmp_convert(f, u, K0_inexact, K0)
        else:
            K0_inexact = None
        if K0.is_Field:
            K = K0.get_ring()
            denom, f = dmp_clear_denoms(f, u, K0, K)
            f = dmp_convert(f, u, K0, K)
        else:
            K = K0
        if K.is_ZZ:
            levels, f, v = dmp_exclude(f, u, K)
            coeff, factors = dmp_zz_factor(f, v, K)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_include(f, levels, v, K), k)
        elif K.is_Poly:
            f, v = dmp_inject(f, u, K)
            coeff, factors = dmp_factor_list(f, v, K.dom)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_eject(f, v, K), k)
            coeff = K.convert(coeff, K.dom)
        else:
            raise DomainError('factorization not supported over %s' % K0)
        if K0.is_Field:
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_convert(f, u, K, K0), k)
            coeff = K0.convert(coeff, K)
            coeff = K0.quo(coeff, denom)
            if K0_inexact:
                for i, (f, k) in enumerate(factors):
                    max_norm = dmp_max_norm(f, u, K0)
                    f = dmp_quo_ground(f, max_norm, u, K0)
                    f = dmp_convert(f, u, K0, K0_inexact)
                    factors[i] = (f, k)
                    coeff = K0.mul(coeff, K0.pow(max_norm, k))
                coeff = K0_inexact.convert(coeff, K0)
                K0 = K0_inexact
    for i, j in enumerate(reversed(J)):
        if not j:
            continue
        term = {(0,) * (u - i) + (1,) + (0,) * i: K0.one}
        factors.insert(0, (dmp_from_dict(term, u, K0), j))
    return (coeff * cont, _sort_factors(factors))

.sympy.polys.factortools.dup_factor_list

def dup_factor_list(f, K0):
    j, f = dup_terms_gcd(f, K0)
    cont, f = dup_primitive(f, K0)
    if K0.is_FiniteField:
        coeff, factors = dup_gf_factor(f, K0)
    elif K0.is_Algebraic:
        coeff, factors = dup_ext_factor(f, K0)
    else:
        if not K0.is_Exact:
            K0_inexact, K0 = (K0, K0.get_exact())
            f = dup_convert(f, K0_inexact, K0)
        else:
            K0_inexact = None
        if K0.is_Field:
            K = K0.get_ring()
            denom, f = dup_clear_denoms(f, K0, K)
            f = dup_convert(f, K0, K)
        else:
            K = K0
        if K.is_ZZ:
            coeff, factors = dup_zz_factor(f, K)
        elif K.is_Poly:
            f, u = dmp_inject(f, 0, K)
            coeff, factors = dmp_factor_list(f, u, K.dom)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_eject(f, u, K), k)
            coeff = K.convert(coeff, K.dom)
        else:
            raise DomainError('factorization not supported over %s' % K0)
        if K0.is_Field:
            for i, (f, k) in enumerate(factors):
                factors[i] = (dup_convert(f, K, K0), k)
            coeff = K0.convert(coeff, K)
            coeff = K0.quo(coeff, denom)
            if K0_inexact:
                for i, (f, k) in enumerate(factors):
                    max_norm = dup_max_norm(f, K0)
                    f = dup_quo_ground(f, max_norm, K0)
                    f = dup_convert(f, K0, K0_inexact)
                    factors[i] = (f, k)
                    coeff = K0.mul(coeff, K0.pow(max_norm, k))
                coeff = K0_inexact.convert(coeff, K0)
                K0 = K0_inexact
    if j:
        factors.insert(0, ([K0.one, K0.zero], j))
    return (coeff * cont, _sort_factors(factors))

.sympy.polys.densebasic.dup_terms_gcd

def dup_terms_gcd(f, K):
    if dup_TC(f, K) or not f:
        return (0, f)
    i = 0
    for c in reversed(f):
        if not c:
            i += 1
        else:
            break
    return (i, f[:-i])

.sympy.polys.densebasic.poly_TC

def poly_TC(f, K):
    if not f:
        return K.zero
    else:
        return f[-1]

.sympy.polys.densetools.dup_primitive

def dup_primitive(f, K):
    if not f:
        return (K.zero, f)
    cont = dup_content(f, K)
    if K.is_one(cont):
        return (cont, f)
    else:
        return (cont, dup_quo_ground(f, cont, K))

.sympy.polys.densetools.dup_content

def dup_content(f, K):
    from sympy.polys.domains import QQ
    if not f:
        return K.zero
    cont = K.zero
    if K == QQ:
        for c in f:
            cont = K.gcd(cont, c)
    else:
        for c in f:
            cont = K.gcd(cont, c)
            if K.is_one(cont):
                break
    return cont

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.gcd

def gcd(self, a, b):
    return python_gcd(a, b)

.sympy.polys.domains.domain.Domain.is_one

def is_one(self, a):
    return a == self.one

.sympy.polys.factortools.dup_zz_factor

def dup_zz_factor(f, K):
    cont, g = dup_primitive(f, K)
    n = dup_degree(g)
    if dup_LC(g, K) < 0:
        cont, g = (-cont, dup_neg(g, K))
    if n <= 0:
        return (cont, [])
    elif n == 1:
        return (cont, [(g, 1)])
    if query('USE_IRREDUCIBLE_IN_FACTOR'):
        if dup_zz_irreducible_p(g, K):
            return (cont, [(g, 1)])
    g = dup_sqf_part(g, K)
    H = None
    if query('USE_CYCLOTOMIC_FACTOR'):
        H = dup_zz_cyclotomic_factor(g, K)
    if H is None:
        H = dup_zz_zassenhaus(g, K)
    factors = dup_trial_division(f, H, K)
    return (cont, factors)

.sympy.polys.densebasic.dup_degree

def dup_degree(f):
    if not f:
        return -oo
    return len(f) - 1

.sympy.polys.polyutils._sort_factors

def _sort_factors(factors, **args):

    def order_if_multiple_key(factor):
        f, n = factor
        return (len(f), n, f)

    def order_no_multiple_key(f):
        return (len(f), f)
    if args.get('multiple', True):
        return sorted(factors, key=order_if_multiple_key)
    else:
        return sorted(factors, key=order_no_multiple_key)

.sympy.polys.polyutils.order_if_multiple_key

def order_if_multiple_key(factor):
    f, n = factor
    return (len(f), n, f)

.sympy.polys.polytools._factors_product

def _factors_product(factors):
    return Mul(*[f.as_expr() ** k for f, k in factors])

.sympy.simplify.fu.TR2

def TR2(rv):

    def f(rv):
        if isinstance(rv, tan):
            a = rv.args[0]
            return sin(a) / cos(a)
        elif isinstance(rv, cot):
            a = rv.args[0]
            return cos(a) / sin(a)
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.L

def L(rv):
    return S(rv.count(TrigonometricFunction))

.sympy.core.basic.Basic.count

def count(self, query):
    query = _make_find_query(query)
    return sum((bool(query(sub)) for sub in preorder_traversal(self)))

.sympy.core.basic._make_find_query

def _make_find_query(query):
    try:
        query = sympify(query)
    except SympifyError:
        pass
    if isinstance(query, type):
        return lambda expr: isinstance(expr, query)
    elif isinstance(query, Basic):
        return lambda expr: expr.match(query) is not None
    return query

.sympy.core.expr.Expr.count_ops

def count_ops(self, visual=None):
    from .function import count_ops
    return count_ops(self, visual)

.sympy.core.compatibility._nodes

def _nodes(e):
    from .basic import Basic
    if isinstance(e, Basic):
        return e.count(Basic)
    elif iterable(e):
        return 1 + sum((_nodes(ei) for ei in e))
    elif isinstance(e, dict):
        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))
    else:
        return 1

.sympy.simplify.fu.TR2i

def TR2i(rv, half=False):

    def f(rv):
        if not rv.is_Mul:
            return rv
        n, d = rv.as_numer_denom()
        if n.is_Atom or d.is_Atom:
            return rv

        def ok(k, e):
            return (e.is_integer or k.is_positive) and (k.func in (sin, cos) or (half and k.is_Add and (len(k.args) >= 2) and any((any((isinstance(ai, cos) or (ai.is_Pow and ai.base is cos) for ai in Mul.make_args(a))) for a in k.args))))
        n = n.as_powers_dict()
        ndone = [(k, n.pop(k)) for k in list(n.keys()) if not ok(k, n[k])]
        if not n:
            return rv
        d = d.as_powers_dict()
        ddone = [(k, d.pop(k)) for k in list(d.keys()) if not ok(k, d[k])]
        if not d:
            return rv

        def factorize(d, ddone):
            newk = []
            for k in d:
                if k.is_Add and len(k.args) > 1:
                    knew = factor(k) if half else factor_terms(k)
                    if knew != k:
                        newk.append((k, knew))
            if newk:
                for i, (k, knew) in enumerate(newk):
                    del d[k]
                    newk[i] = knew
                newk = Mul(*newk).as_powers_dict()
                for k in newk:
                    v = d[k] + newk[k]
                    if ok(k, v):
                        d[k] = v
                    else:
                        ddone.append((k, v))
                del newk
        factorize(n, ndone)
        factorize(d, ddone)
        t = []
        for k in n:
            if isinstance(k, sin):
                a = cos(k.args[0], evaluate=False)
                if a in d and d[a] == n[k]:
                    t.append(tan(k.args[0]) ** n[k])
                    n[k] = d[a] = None
                elif half:
                    a1 = 1 + a
                    if a1 in d and d[a1] == n[k]:
                        t.append(tan(k.args[0] / 2) ** n[k])
                        n[k] = d[a1] = None
            elif isinstance(k, cos):
                a = sin(k.args[0], evaluate=False)
                if a in d and d[a] == n[k]:
                    t.append(tan(k.args[0]) ** (-n[k]))
                    n[k] = d[a] = None
            elif half and k.is_Add and (k.args[0] is S.One) and isinstance(k.args[1], cos):
                a = sin(k.args[1].args[0], evaluate=False)
                if a in d and d[a] == n[k] and (d[a].is_integer or a.is_positive):
                    t.append(tan(a.args[0] / 2) ** (-n[k]))
                    n[k] = d[a] = None
        if t:
            rv = Mul(*t + [b ** e for b, e in n.items() if e]) / Mul(*[b ** e for b, e in d.items() if e])
            rv *= Mul(*[b ** e for b, e in ndone]) / Mul(*[b ** e for b, e in ddone])
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR14

def TR14(rv, first=True):

    def f(rv):
        if not rv.is_Mul:
            return rv
        if first:
            n, d = rv.as_numer_denom()
            if d is not S.One:
                newn = TR14(n, first=False)
                newd = TR14(d, first=False)
                if newn != n or newd != d:
                    rv = newn / newd
                return rv
        other = []
        process = []
        for a in rv.args:
            if a.is_Pow:
                b, e = a.as_base_exp()
                if not (e.is_integer or b.is_positive):
                    other.append(a)
                    continue
                a = b
            else:
                e = S.One
            m = as_f_sign_1(a)
            if not m or m[1].func not in (cos, sin):
                if e is S.One:
                    other.append(a)
                else:
                    other.append(a ** e)
                continue
            g, f, si = m
            process.append((g, e.is_Number, e, f, si, a))
        process = list(ordered(process))
        nother = len(other)
        keys = g, t, e, f, si, a = list(range(6))
        while process:
            A = process.pop(0)
            if process:
                B = process[0]
                if A[e].is_Number and B[e].is_Number:
                    if A[f] == B[f]:
                        if A[si] != B[si]:
                            B = process.pop(0)
                            take = min(A[e], B[e])
                            if B[e] != take:
                                rem = [B[i] for i in keys]
                                rem[e] -= take
                                process.insert(0, rem)
                            elif A[e] != take:
                                rem = [A[i] for i in keys]
                                rem[e] -= take
                                process.insert(0, rem)
                            if isinstance(A[f], cos):
                                t = sin
                            else:
                                t = cos
                            other.append((-A[g] * B[g] * t(A[f].args[0]) ** 2) ** take)
                            continue
                elif A[e] == B[e]:
                    if A[f] == B[f]:
                        if A[si] != B[si]:
                            B = process.pop(0)
                            take = A[e]
                            if isinstance(A[f], cos):
                                t = sin
                            else:
                                t = cos
                            other.append((-A[g] * B[g] * t(A[f].args[0]) ** 2) ** take)
                            continue
            other.append(A[a] ** A[e])
        if len(other) != nother:
            rv = Mul(*other)
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR5

def TR5(rv, max=4, pow=False):
    return _TR56(rv, sin, cos, lambda x: 1 - x, max=max, pow=pow)

.sympy.simplify.fu._TR56

def _TR56(rv, f, g, h, max, pow):

    def _f(rv):
        if not (rv.is_Pow and rv.base.func == f):
            return rv
        if (rv.exp < 0) == True:
            return rv
        if (rv.exp > max) == True:
            return rv
        if rv.exp == 2:
            return h(g(rv.base.args[0]) ** 2)
        else:
            if rv.exp == 4:
                e = 2
            elif not pow:
                if rv.exp % 2:
                    return rv
                e = rv.exp // 2
            else:
                p = perfect_power(rv.exp)
                if not p:
                    return rv
                e = rv.exp // 2
            return h(g(rv.base.args[0]) ** 2) ** e
    return bottom_up(rv, _f)

.sympy.simplify.fu._f

def _f(rv):
    if not (rv.is_Pow and rv.base.func == f):
        return rv
    if (rv.exp < 0) == True:
        return rv
    if (rv.exp > max) == True:
        return rv
    if rv.exp == 2:
        return h(g(rv.base.args[0]) ** 2)
    else:
        if rv.exp == 4:
            e = 2
        elif not pow:
            if rv.exp % 2:
                return rv
            e = rv.exp // 2
        else:
            p = perfect_power(rv.exp)
            if not p:
                return rv
            e = rv.exp // 2
        return h(g(rv.base.args[0]) ** 2) ** e

.sympy.simplify.fu.TR10

def TR10(rv, first=True):

    def f(rv):
        if not rv.func in (cos, sin):
            return rv
        f = rv.func
        arg = rv.args[0]
        if arg.is_Add:
            if first:
                args = list(ordered(arg.args))
            else:
                args = list(arg.args)
            a = args.pop()
            b = Add._from_args(args)
            if b.is_Add:
                if f == sin:
                    return sin(a) * TR10(cos(b), first=False) + cos(a) * TR10(sin(b), first=False)
                else:
                    return cos(a) * TR10(cos(b), first=False) - sin(a) * TR10(sin(b), first=False)
            elif f == sin:
                return sin(a) * cos(b) + cos(a) * sin(b)
            else:
                return cos(a) * cos(b) - sin(a) * sin(b)
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR11

def TR11(rv, base=None):

    def f(rv):
        if not rv.func in (cos, sin):
            return rv
        if base:
            f = rv.func
            t = f(base * 2)
            co = S.One
            if t.is_Mul:
                co, t = t.as_coeff_Mul()
            if not t.func in (cos, sin):
                return rv
            if rv.args[0] == t.args[0]:
                c = cos(base)
                s = sin(base)
                if f is cos:
                    return (c ** 2 - s ** 2) / co
                else:
                    return 2 * c * s / co
            return rv
        elif not rv.args[0].is_Number:
            c, m = rv.args[0].as_coeff_Mul(rational=True)
            if c.p % 2 == 0:
                arg = c.p // 2 * m / c.q
                c = TR11(cos(arg))
                s = TR11(sin(arg))
                if rv.func == sin:
                    rv = 2 * s * c
                else:
                    rv = c ** 2 - s ** 2
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR6

def TR6(rv, max=4, pow=False):
    return _TR56(rv, cos, sin, lambda x: 1 - x, max=max, pow=pow)

.sympy.simplify.fu.TRmorrie

def TRmorrie(rv):

    def f(rv):
        if not rv.is_Mul:
            return rv
        args = defaultdict(list)
        coss = {}
        other = []
        for c in rv.args:
            b, e = c.as_base_exp()
            if e.is_Integer and isinstance(b, cos):
                co, a = b.args[0].as_coeff_Mul()
                args[a].append(co)
                coss[b] = e
            else:
                other.append(c)
        new = []
        for a in args:
            c = args[a]
            c.sort()
            no = []
            while c:
                k = 0
                cc = ci = c[0]
                while cc in c:
                    k += 1
                    cc *= 2
                if k > 1:
                    newarg = sin(2 ** k * ci * a) / 2 ** k / sin(ci * a)
                    take = None
                    ccs = []
                    for i in range(k):
                        cc /= 2
                        key = cos(a * cc, evaluate=False)
                        ccs.append(cc)
                        take = min(coss[key], take or coss[key])
                    for i in range(k):
                        cc = ccs.pop()
                        key = cos(a * cc, evaluate=False)
                        coss[key] -= take
                        if not coss[key]:
                            c.remove(cc)
                    new.append(newarg ** take)
                else:
                    no.append(c.pop(0))
            c[:] = no
        if new:
            rv = Mul(*new + other + [cos(k * a, evaluate=False) for a in args for k in args[a]])
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR10i

def TR10i(rv):
    global _ROOT2, _ROOT3, _invROOT3
    if _ROOT2 is None:
        _roots()

    def f(rv):
        if not rv.is_Add:
            return rv

        def do(rv, first=True):
            if not rv.is_Add:
                return rv
            args = list(ordered(rv.args))
            if len(args) != 2:
                hit = False
                for i in range(len(args)):
                    ai = args[i]
                    if ai is None:
                        continue
                    for j in range(i + 1, len(args)):
                        aj = args[j]
                        if aj is None:
                            continue
                        was = ai + aj
                        new = do(was)
                        if new != was:
                            args[i] = new
                            args[j] = None
                            hit = True
                            break
                if hit:
                    rv = Add(*[_f for _f in args if _f])
                    if rv.is_Add:
                        rv = do(rv)
                return rv
            split = trig_split(*args, two=True)
            if not split:
                return rv
            gcd, n1, n2, a, b, same = split
            if same:
                gcd = n1 * gcd
                if n1 == n2:
                    return gcd * cos(a - b)
                return gcd * cos(a + b)
            else:
                gcd = n1 * gcd
                if n1 == n2:
                    return gcd * sin(a + b)
                return gcd * sin(b - a)
        rv = process_common_addends(rv, do, lambda x: tuple(ordered(x.free_symbols)))
        while rv.is_Add:
            byrad = defaultdict(list)
            for a in rv.args:
                hit = 0
                if a.is_Mul:
                    for ai in a.args:
                        if ai.is_Pow and ai.exp is S.Half and ai.base.is_Integer:
                            byrad[ai].append(a)
                            hit = 1
                            break
                if not hit:
                    byrad[S.One].append(a)
            args = []
            for a in byrad:
                for b in [_ROOT3 * a, _invROOT3]:
                    if b in byrad:
                        for i in range(len(byrad[a])):
                            if byrad[a][i] is None:
                                continue
                            for j in range(len(byrad[b])):
                                if byrad[b][j] is None:
                                    continue
                                was = Add(byrad[a][i] + byrad[b][j])
                                new = do(was)
                                if new != was:
                                    args.append(new)
                                    byrad[a][i] = None
                                    byrad[b][j] = None
                                    break
            if args:
                rv = Add(*args + [Add(*[_f for _f in v if _f]) for v in byrad.values()])
            else:
                rv = do(rv)
                break
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu._roots

def _roots():
    global _ROOT2, _ROOT3, _invROOT3
    _ROOT2, _ROOT3 = (sqrt(2), sqrt(3))
    _invROOT3 = 1 / _ROOT3

.sympy.functions.elementary.miscellaneous.sqrt

def sqrt(arg):
    return Pow(arg, S.Half)

.sympy.core.power.integer_nthroot

def integer_nthroot(y, n):
    y, n = (as_int(y), as_int(n))
    if y < 0:
        raise ValueError('y must be nonnegative')
    if n < 1:
        raise ValueError('n must be positive')
    if y in (0, 1):
        return (y, True)
    if n == 1:
        return (y, True)
    if n == 2:
        x, rem = mpmath_sqrtrem(y)
        return (int(x), not rem)
    if n > y:
        return (1, False)
    try:
        guess = int(y ** (1.0 / n) + 0.5)
    except OverflowError:
        exp = _log(y, 2) / n
        if exp > 53:
            shift = int(exp - 53)
            guess = int(2.0 ** (exp - shift) + 1) << shift
        else:
            guess = int(2.0 ** exp)
    if guess > 2 ** 50:
        xprev, x = (-1, guess)
        while 1:
            t = x ** (n - 1)
            xprev, x = (x, ((n - 1) * x + y // t) // n)
            if abs(x - xprev) < 2:
                break
    else:
        x = guess
    t = x ** n
    while t < y:
        x += 1
        t = x ** n
    while t > y:
        x -= 1
        t = x ** n
    return (int(x), t == y)

.sympy.ntheory.factor_.perfect_power

def perfect_power(n, candidates=None, big=True, factor=True):
    n = int(n)
    if n < 3:
        return False
    logn = math.log(n, 2)
    max_possible = int(logn) + 2
    not_square = n % 10 in [2, 3, 7, 8]
    if not candidates:
        candidates = primerange(2 + not_square, max_possible)
    afactor = 2 + n % 2
    for e in candidates:
        if e < 3:
            if e == 1 or (e == 2 and not_square):
                continue
        if e > max_possible:
            return False
        if factor:
            if n % afactor == 0:
                if afactor == 2:
                    e = trailing(n)
                else:
                    e = multiplicity(afactor, n)
                if e == 1:
                    return False
                r, exact = integer_nthroot(n, e)
                if not exact:
                    n //= afactor ** e
                    m = perfect_power(n, candidates=primefactors(e), big=big)
                    if m is False:
                        return False
                    else:
                        r, m = m
                        g = igcd(m, e)
                        if g == 1:
                            return False
                        m //= g
                        e //= g
                        r, e = (r ** m * afactor ** e, g)
                if not big:
                    e0 = primefactors(e)
                    if len(e0) > 1 or e0[0] != e:
                        e0 = e0[0]
                        r, e = (r ** (e // e0), e0)
                return (r, e)
            else:
                afactor = nextprime(afactor)
        if logn / e < 40:
            b = 2.0 ** (logn / e)
            if abs(int(b + 0.5) - b) > 0.01:
                continue
        r, exact = integer_nthroot(n, e)
        if exact:
            if big:
                m = perfect_power(r, big=big, factor=factor)
                if m is not False:
                    r, e = (m[0], e * m[1])
            return (int(r), e)
    else:
        return False

.sympy.core.numbers.Rational.factors

def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):
    from sympy.ntheory import factorrat
    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()

.sympy.ntheory.factor_.factorrat

def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    from collections import defaultdict
    if multiple:
        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * (-1 * fac[p]) for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])
        return factorlist
    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()
    f = defaultdict(int, f)
    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():
        f[p] += -e
    if len(f) > 1 and 1 in f:
        del f[1]
    if not visual:
        return dict(f)
    else:
        if -1 in f:
            f.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])
        return Mul(*args, evaluate=False)

.sympy.ntheory.factor_.factorint

def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    if multiple:
        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * (-1 * fac[p]) for p in sorted(fac)), [])
        return factorlist
    factordict = {}
    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):
        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
    elif isinstance(n, Mul):
        factordict = dict([(int(k), int(v)) for k, v in list(n.as_powers_dict().items())])
    elif isinstance(n, dict):
        factordict = n
    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):
        for k in list(factordict.keys()):
            if isprime(k):
                continue
            e = factordict.pop(k)
            d = factorint(k, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
            for k, v in d.items():
                if k in factordict:
                    factordict[k] += v * e
                else:
                    factordict[k] = v * e
    if visual or (type(n) is dict and visual is not True and (visual is not False)):
        if factordict == {}:
            return S.One
        if -1 in factordict:
            factordict.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])
        return Mul(*args, evaluate=False)
    elif isinstance(n, dict) or isinstance(n, Mul):
        return factordict
    assert use_trial or use_rho or use_pm1
    from sympy.functions.combinatorial.factorials import factorial
    if isinstance(n, factorial) and n.args[0].is_Integer and (n.args[0] >= 20):
        x = n.args[0]
        factors = {}
        for p in sieve.primerange(2, x):
            m = 0
            d = p
            q = x // p
            while q != 0:
                m += q
                d *= p
                q = x // d
            factors[p] = m
        if factors and verbose:
            for k in sorted(factors):
                print(factor_msg % (k, factors[k]))
        if verbose:
            print(complete_msg)
        return factors
    n = as_int(n)
    if limit:
        limit = int(limit)
    if n < 0:
        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
        factors[-1] = 1
        return factors
    if limit and limit < 2:
        if n == 1:
            return {}
        return {n: 1}
    elif n < 10:
        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]
    factors = {}
    if verbose:
        sn = str(n)
        if len(sn) > 50:
            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])
        else:
            print('Factoring', n)
    if use_trial:
        small = 2 ** 15
        fail_max = 600
        small = min(small, limit or small)
        if verbose:
            print(trial_int_msg % (2, small, fail_max))
        n, next_p = _factorint_small(factors, n, small, fail_max)
    else:
        next_p = 2
    if factors and verbose:
        for k in sorted(factors):
            print(factor_msg % (k, factors[k]))
    if next_p == 0:
        if n > 1:
            factors[int(n)] = 1
        if verbose:
            print(complete_msg)
        return factors
    try:
        if limit and next_p > limit:
            if verbose:
                print('Exceeded limit:', limit)
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            if n > 1:
                factors[int(n)] = 1
            return factors
        else:
            sqrt_n = integer_nthroot(n, 2)[0]
            a = sqrt_n + 1
            a2 = a ** 2
            b2 = a2 - n
            for i in range(3):
                b, fermat = integer_nthroot(b2, 2)
                if fermat:
                    break
                b2 += 2 * a + 1
                a += 1
            if fermat:
                if verbose:
                    print(fermat_msg)
                if limit:
                    limit -= 1
                for r in [a - b, a + b]:
                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                    factors.update(facs)
                raise StopIteration
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
    except StopIteration:
        if verbose:
            print(complete_msg)
        return factors
    low, high = (next_p, 2 * next_p)
    limit = limit or sqrt_n
    limit += 1
    while 1:
        try:
            high_ = high
            if limit < high_:
                high_ = limit
            if use_trial:
                if verbose:
                    print(trial_msg % (low, high_))
                ps = sieve.primerange(low, high_)
                n, found_trial = _trial(factors, n, ps, verbose)
                if found_trial:
                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            else:
                found_trial = False
            if high > limit:
                if verbose:
                    print('Exceeded limit:', limit)
                if n > 1:
                    factors[int(n)] = 1
                raise StopIteration
            if not found_trial:
                if use_pm1 or use_rho:
                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)
                    if use_pm1:
                        if verbose:
                            print(pm1_msg % (high_root, high_))
                        c = pollard_pm1(n, B=high_root, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
                    if use_rho:
                        max_steps = high_root
                        if verbose:
                            print(rho_msg % (1, max_steps, high_))
                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
        except StopIteration:
            if verbose:
                print(complete_msg)
            return factors
        low, high = (high, high * 2)

.sympy.ntheory.generate.primerange

def primerange(a, b):
    from sympy.functions.elementary.integers import ceiling
    if a >= b:
        return
    if b <= sieve._list[-1]:
        for i in sieve.primerange(a, b):
            yield i
        return
    a = int(ceiling(a)) - 1
    b = int(ceiling(b))
    while 1:
        a = nextprime(a)
        if a < b:
            yield a
        else:
            return

.sympy.core.power.Pow._eval_power

def _eval_power(self, other):
    from sympy import Abs, arg, exp, floor, im, log, re, sign
    b, e = self.as_base_exp()
    if b is S.NaN:
        return (b ** e) ** other
    s = None
    if other.is_integer:
        s = 1
    elif b.is_polar:
        s = 1
    elif e.is_real is not None:

        def _half(e):
            if getattr(e, 'q', None) == 2:
                return True
            n, d = e.as_numer_denom()
            if n.is_integer and d == 2:
                return True

        def _n2(e):
            try:
                rv = e.evalf(2, strict=True)
                if rv.is_Number:
                    return rv
            except PrecisionExhausted:
                pass
        if e.is_real:
            if e == -1:
                if _half(other):
                    if b.is_negative is True:
                        return S.NegativeOne ** other * Pow(-b, e * other)
                    if b.is_real is False:
                        return Pow(b.conjugate() / Abs(b) ** 2, other)
            elif e.is_even:
                if b.is_real:
                    b = abs(b)
                if b.is_imaginary:
                    b = abs(im(b)) * S.ImaginaryUnit
            if (abs(e) < 1) == True or e == 1:
                s = 1
            elif b.is_nonnegative:
                s = 1
            elif re(b).is_nonnegative and (abs(e) < 2) == True:
                s = 1
            elif fuzzy_not(im(b).is_zero) and abs(e) == 2:
                s = 1
            elif _half(other):
                s = exp(2 * S.Pi * S.ImaginaryUnit * other * floor(S.Half - e * arg(b) / (2 * S.Pi)))
                if s.is_real and _n2(sign(s) - s) == 0:
                    s = sign(s)
                else:
                    s = None
        else:
            try:
                s = exp(2 * S.ImaginaryUnit * S.Pi * other * floor(S.Half - im(e * log(b)) / 2 / S.Pi))
                if s.is_real and _n2(sign(s) - s) == 0:
                    s = sign(s)
                else:
                    s = None
            except PrecisionExhausted:
                s = None
    if s is not None:
        return s * Pow(b, e * other)

.sympy.core.numbers.Rational._eval_power

def _eval_power(self, expt):
    if isinstance(expt, Number):
        if isinstance(expt, Float):
            return self._eval_evalf(expt._prec) ** expt
        if expt.is_negative:
            ne = -expt
            if ne is S.One:
                return Rational(self.q, self.p)
            if self.is_negative:
                if expt.q != 1:
                    return -S.NegativeOne ** (expt.p % expt.q / S(expt.q)) * Rational(self.q, -self.p) ** ne
                else:
                    return S.NegativeOne ** ne * Rational(self.q, -self.p) ** ne
            else:
                return Rational(self.q, self.p) ** ne
        if expt is S.Infinity:
            if self.p > self.q:
                return S.Infinity
            if self.p < -self.q:
                return S.Infinity + S.Infinity * S.ImaginaryUnit
            return S.Zero
        if isinstance(expt, Integer):
            return Rational(self.p ** expt.p, self.q ** expt.p, 1)
        if isinstance(expt, Rational):
            if self.p != 1:
                return Integer(self.p) ** expt * Integer(self.q) ** (-expt)
            return Integer(self.q) ** Rational(expt.p * (expt.q - 1), expt.q) / Integer(self.q) ** Integer(expt.p)
    if self.is_negative and expt.is_even:
        return (-self) ** expt
    return

.sympy.core.expr.Expr.__rmul__

def __rmul__(self, other):
    return Mul(other, self)

.sympy.simplify.fu.TR8

def TR8(rv, first=True):

    def f(rv):
        if not (rv.is_Mul or (rv.is_Pow and rv.base.func in (cos, sin) and (rv.exp.is_integer or rv.base.is_positive))):
            return rv
        if first:
            n, d = [expand_mul(i) for i in rv.as_numer_denom()]
            newn = TR8(n, first=False)
            newd = TR8(d, first=False)
            if newn != n or newd != d:
                rv = gcd_terms(newn / newd)
                if rv.is_Mul and rv.args[0].is_Rational and (len(rv.args) == 2) and rv.args[1].is_Add:
                    rv = Mul(*rv.as_coeff_Mul())
            return rv
        args = {cos: [], sin: [], None: []}
        for a in ordered(Mul.make_args(rv)):
            if a.func in (cos, sin):
                args[a.func].append(a.args[0])
            elif a.is_Pow and a.exp.is_Integer and (a.exp > 0) and (a.base.func in (cos, sin)):
                args[a.base.func].extend([a.base.args[0]] * a.exp)
            else:
                args[None].append(a)
        c = args[cos]
        s = args[sin]
        if not (c and s or len(c) > 1 or len(s) > 1):
            return rv
        args = args[None]
        n = min(len(c), len(s))
        for i in range(n):
            a1 = s.pop()
            a2 = c.pop()
            args.append((sin(a1 + a2) + sin(a1 - a2)) / 2)
        while len(c) > 1:
            a1 = c.pop()
            a2 = c.pop()
            args.append((cos(a1 + a2) + cos(a1 - a2)) / 2)
        if c:
            args.append(cos(c.pop()))
        while len(s) > 1:
            a1 = s.pop()
            a2 = s.pop()
            args.append((-cos(a1 + a2) + cos(a1 - a2)) / 2)
        if s:
            args.append(sin(s.pop()))
        return TR8(expand_mul(Mul(*args)))
    return bottom_up(rv, f)

.sympy.simplify.fu.TR15

def TR15(rv, max=4, pow=False):

    def f(rv):
        if not (isinstance(rv, Pow) and isinstance(rv.base, sin)):
            return rv
        ia = 1 / rv
        a = _TR56(ia, sin, cot, lambda x: 1 + x, max=max, pow=pow)
        if a != ia:
            rv = a
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR16

def TR16(rv, max=4, pow=False):

    def f(rv):
        if not (isinstance(rv, Pow) and isinstance(rv.base, cos)):
            return rv
        ia = 1 / rv
        a = _TR56(ia, cos, tan, lambda x: 1 + x, max=max, pow=pow)
        if a != ia:
            rv = a
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR111

def TR111(rv):

    def f(rv):
        if not (isinstance(rv, Pow) and (rv.base.is_positive or (rv.exp.is_integer and rv.exp.is_negative))):
            return rv
        if isinstance(rv.base, tan):
            return cot(rv.base.args[0]) ** (-rv.exp)
        elif isinstance(rv.base, sin):
            return csc(rv.base.args[0]) ** (-rv.exp)
        elif isinstance(rv.base, cos):
            return sec(rv.base.args[0]) ** (-rv.exp)
        return rv
    return bottom_up(rv, f)

.sympy.simplify.fu.TR22

def TR22(rv, max=4, pow=False):

    def f(rv):
        if not (isinstance(rv, Pow) and rv.base.func in (cot, tan)):
            return rv
        rv = _TR56(rv, tan, sec, lambda x: x - 1, max=max, pow=pow)
        rv = _TR56(rv, cot, csc, lambda x: x - 1, max=max, pow=pow)
        return rv
    return bottom_up(rv, f)

.sympy.core.numbers.Integer.__rmul__

def __rmul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(other * self.p)
        elif isinstance(other, Rational):
            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))
        return Rational.__rmul__(self, other)
    return Rational.__rmul__(self, other)

.sympy.core.numbers.Integer.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s > %s' % (self, other))
    if isinstance(other, Integer):
        return _sympify(self.p > other.p)
    return Rational.__gt__(self, other)

.sympy.core.expr.Expr.__rsub__

def __rsub__(self, other):
    return Add(other, -self)

.sympy.polys.densearith.dup_neg

def dup_neg(f, K):
    return [-coeff for coeff in f]

.sympy.polys.sqfreetools.dup_sqf_part

def dup_sqf_part(f, K):
    if K.is_FiniteField:
        return dup_gf_sqf_part(f, K)
    if not f:
        return f
    if K.is_negative(dup_LC(f, K)):
        f = dup_neg(f, K)
    gcd = dup_gcd(f, dup_diff(f, 1, K), K)
    sqf = dup_quo(f, gcd, K)
    if K.is_Field:
        return dup_monic(sqf, K)
    else:
        return dup_primitive(sqf, K)[1]

.sympy.polys.densetools.dup_diff

def dup_diff(f, m, K):
    if m <= 0:
        return f
    n = dup_degree(f)
    if n < m:
        return []
    deriv = []
    if m == 1:
        for coeff in f[:-m]:
            deriv.append(K(n) * coeff)
            n -= 1
    else:
        for coeff in f[:-m]:
            k = n
            for i in range(n - 1, n - m, -1):
                k *= i
            deriv.append(K(k) * coeff)
            n -= 1
    return dup_strip(deriv)

.sympy.polys.domains.domain.Domain.__call__

def __call__(self, *args):
    return self.new(*args)

.sympy.polys.domains.domain.Domain.new

def new(self, *args):
    return self.dtype(*args)

.sympy.polys.euclidtools.dup_gcd

def dup_gcd(f, g, K):
    return dup_inner_gcd(f, g, K)[0]

.sympy.polys.euclidtools.dup_inner_gcd

def dup_inner_gcd(f, g, K):
    if not K.is_Exact:
        try:
            exact = K.get_exact()
        except DomainError:
            return ([K.one], f, g)
        f = dup_convert(f, K, exact)
        g = dup_convert(g, K, exact)
        h, cff, cfg = dup_inner_gcd(f, g, exact)
        h = dup_convert(h, exact, K)
        cff = dup_convert(cff, exact, K)
        cfg = dup_convert(cfg, exact, K)
        return (h, cff, cfg)
    elif K.is_Field:
        if K.is_QQ and query('USE_HEU_GCD'):
            try:
                return dup_qq_heu_gcd(f, g, K)
            except HeuristicGCDFailed:
                pass
        return dup_ff_prs_gcd(f, g, K)
    else:
        if K.is_ZZ and query('USE_HEU_GCD'):
            try:
                return dup_zz_heu_gcd(f, g, K)
            except HeuristicGCDFailed:
                pass
        return dup_rr_prs_gcd(f, g, K)

.sympy.polys.euclidtools.dup_zz_heu_gcd

def dup_zz_heu_gcd(f, g, K):
    result = _dup_rr_trivial_gcd(f, g, K)
    if result is not None:
        return result
    df = dup_degree(f)
    dg = dup_degree(g)
    gcd, f, g = dup_extract(f, g, K)
    if df == 0 or dg == 0:
        return ([gcd], f, g)
    f_norm = dup_max_norm(f, K)
    g_norm = dup_max_norm(g, K)
    B = K(2 * min(f_norm, g_norm) + 29)
    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dup_LC(f, K)), g_norm // abs(dup_LC(g, K))) + 2)
    for i in range(0, HEU_GCD_MAX):
        ff = dup_eval(f, x, K)
        gg = dup_eval(g, x, K)
        if ff and gg:
            h = K.gcd(ff, gg)
            cff = ff // h
            cfg = gg // h
            h = _dup_zz_gcd_interpolate(h, x, K)
            h = dup_primitive(h, K)[1]
            cff_, r = dup_div(f, h, K)
            if not r:
                cfg_, r = dup_div(g, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff_, cfg_)
            cff = _dup_zz_gcd_interpolate(cff, x, K)
            h, r = dup_div(f, cff, K)
            if not r:
                cfg_, r = dup_div(g, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff, cfg_)
            cfg = _dup_zz_gcd_interpolate(cfg, x, K)
            h, r = dup_div(g, cfg, K)
            if not r:
                cff_, r = dup_div(f, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff_, cfg)
        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011
    raise HeuristicGCDFailed('no luck')

.sympy.polys.euclidtools._dup_rr_trivial_gcd

def _dup_rr_trivial_gcd(f, g, K):
    if not (f or g):
        return ([], [], [])
    elif not f:
        if K.is_nonnegative(dup_LC(g, K)):
            return (g, [], [K.one])
        else:
            return (dup_neg(g, K), [], [-K.one])
    elif not g:
        if K.is_nonnegative(dup_LC(f, K)):
            return (f, [K.one], [])
        else:
            return (dup_neg(f, K), [-K.one], [])
    return None

.sympy.polys.densetools.dup_extract

def dup_extract(f, g, K):
    fc = dup_content(f, K)
    gc = dup_content(g, K)
    gcd = K.gcd(fc, gc)
    if not K.is_one(gcd):
        f = dup_quo_ground(f, gcd, K)
        g = dup_quo_ground(g, gcd, K)
    return (gcd, f, g)

.sympy.polys.densearith.dup_max_norm

def dup_max_norm(f, K):
    if not f:
        return K.zero
    else:
        return max(dup_abs(f, K))

.sympy.polys.densearith.dup_abs

def dup_abs(f, K):
    return [K.abs(coeff) for coeff in f]

.sympy.polys.domains.domain.Domain.abs

def abs(self, a):
    return abs(a)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.sqrt

def sqrt(self, a):
    return python_sqrt(a)

.sympy.polys.domains.groundtypes.python_sqrt

def python_sqrt(n):
    return int(mlib.isqrt(n))

.sympy.polys.densetools.dup_eval

def dup_eval(f, a, K):
    if not a:
        return dup_TC(f, K)
    result = K.zero
    for c in f:
        result *= a
        result += c
    return result

.sympy.polys.euclidtools._dup_zz_gcd_interpolate

def _dup_zz_gcd_interpolate(h, x, K):
    f = []
    while h:
        g = h % x
        if g > x // 2:
            g -= x
        f.insert(0, g)
        h = (h - g) // x
    return f

.sympy.polys.densearith.dup_quo_ground

def dup_quo_ground(f, c, K):
    if not c:
        raise ZeroDivisionError('polynomial division')
    if not f:
        return f
    if K.is_Field:
        return [K.quo(cf, c) for cf in f]
    else:
        return [cf // c for cf in f]

.sympy.polys.densearith.dup_div

def dup_div(f, g, K):
    if K.is_Field:
        return dup_ff_div(f, g, K)
    else:
        return dup_rr_div(f, g, K)

.sympy.polys.densearith.dup_rr_div

def dup_rr_div(f, g, K):
    df = dup_degree(f)
    dg = dup_degree(g)
    q, r, dr = ([], f, df)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return (q, r)
    lc_g = dup_LC(g, K)
    while True:
        lc_r = dup_LC(r, K)
        if lc_r % lc_g:
            break
        c = K.exquo(lc_r, lc_g)
        j = dr - dg
        q = dup_add_term(q, c, j, K)
        h = dup_mul_term(g, c, j, K)
        r = dup_sub(r, h, K)
        _dr, dr = (dr, dup_degree(r))
        if dr < dg:
            break
        elif not dr < _dr:
            raise PolynomialDivisionFailed(f, g, K)
    return (q, r)

.sympy.polys.domains.ring.Ring.exquo

def exquo(self, a, b):
    if a % b:
        raise ExactQuotientFailed(a, b, self)
    else:
        return a // b

.sympy.polys.densearith.dup_add_term

def dup_add_term(f, c, i, K):
    if not c:
        return f
    n = len(f)
    m = n - i - 1
    if i == n - 1:
        return dup_strip([f[0] + c] + f[1:])
    elif i >= n:
        return [c] + [K.zero] * (i - n) + f
    else:
        return f[:m] + [f[m] + c] + f[m + 1:]

.sympy.polys.densearith.dup_mul_term

def dup_mul_term(f, c, i, K):
    if not c or not f:
        return []
    else:
        return [cf * c for cf in f] + [K.zero] * i

.sympy.polys.densearith.dup_sub

def dup_sub(f, g, K):
    if not f:
        return dup_neg(g, K)
    if not g:
        return f
    df = dup_degree(f)
    dg = dup_degree(g)
    if df == dg:
        return dup_strip([a - b for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (dup_neg(g[:k], K), g[k:])
        return h + [a - b for a, b in zip(f, g)]

.sympy.core.numbers.NegativeInfinity.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if other.is_real:
        if other.is_finite or other is S.Infinity:
            return S.true
        elif other.is_nonnegative:
            return S.true
        elif other.is_infinite and other.is_negative:
            return S.false
    return Expr.__lt__(self, other)

.sympy.polys.densearith.dup_mul_ground

def dup_mul_ground(f, c, K):
    if not c or not f:
        return []
    else:
        return [cf * c for cf in f]

.sympy.polys.densearith.dup_quo

def dup_quo(f, g, K):
    return dup_div(f, g, K)[0]

.sympy.polys.factortools.dup_zz_cyclotomic_factor

def dup_zz_cyclotomic_factor(f, K):
    lc_f, tc_f = (dup_LC(f, K), dup_TC(f, K))
    if dup_degree(f) <= 0:
        return None
    if lc_f != 1 or tc_f not in [-1, 1]:
        return None
    if any((bool(cf) for cf in f[1:-1])):
        return None
    n = dup_degree(f)
    F = _dup_cyclotomic_decompose(n, K)
    if not K.is_one(tc_f):
        return F
    else:
        H = []
        for h in _dup_cyclotomic_decompose(2 * n, K):
            if h not in F:
                H.append(h)
        return H

.sympy.polys.factortools._dup_cyclotomic_decompose

def _dup_cyclotomic_decompose(n, K):
    H = [[K.one, -K.one]]
    for p, k in factorint(n).items():
        Q = [dup_quo(dup_inflate(h, p, K), h, K) for h in H]
        H.extend(Q)
        for i in range(1, k):
            Q = [dup_inflate(q, p, K) for q in Q]
            H.extend(Q)
    return H

.sympy.polys.factortools.dup_trial_division

def dup_trial_division(f, factors, K):
    result = []
    for factor in factors:
        k = 0
        while True:
            q, r = dup_div(f, factor, K)
            if not r:
                f, k = (q, k + 1)
            else:
                break
        result.append((factor, k))
    return _sort_factors(result)

.sympy.simplify.fu.as_f_sign_1

def as_f_sign_1(e):
    if not e.is_Add or len(e.args) != 2:
        return
    a, b = e.args
    if a in (S.NegativeOne, S.One):
        g = S.One
        if b.is_Mul and b.args[0].is_Number and (b.args[0] < 0):
            a, b = (-a, -b)
            g = -g
        return (g, b, a)
    a, b = [Factors(i) for i in e.args]
    ua, ub = a.normal(b)
    gcd = a.gcd(b).as_expr()
    if S.NegativeOne in ua.factors:
        ua = ua.quo(S.NegativeOne)
        n1 = -1
        n2 = 1
    elif S.NegativeOne in ub.factors:
        ub = ub.quo(S.NegativeOne)
        n1 = 1
        n2 = -1
    else:
        n1 = n2 = 1
    a, b = [i.as_expr() for i in (ua, ub)]
    if a is S.One:
        a, b = (b, a)
        n1, n2 = (n2, n1)
    if n1 == -1:
        gcd = -gcd
        n2 = -n2
    if b is S.One:
        return (gcd, a, n2)

.sympy.core.basic.Basic.sort_key

def sort_key(self, order=None):

    def inner_key(arg):
        if isinstance(arg, Basic):
            return arg.sort_key(order)
        else:
            return arg
    args = self._sorted_args
    args = (len(args), tuple([inner_key(arg) for arg in args]))
    return (self.class_key(), args, S.One.sort_key(), S.One)

.sympy.core.basic.Basic._sorted_args

def _sorted_args(self):
    return self.args

.sympy.core.basic.Basic.class_key

def class_key(cls):
    return (5, 0, cls.__name__)

.sympy.core.numbers.Integer.__index__

def __index__(self):
    return self.p

.sympy.functions.elementary.trigonometric.ReciprocalTrigonometricFunction.eval

def eval(cls, arg):
    if arg.could_extract_minus_sign():
        if cls._is_even:
            return cls(-arg)
        if cls._is_odd:
            return -cls(-arg)
    pi_coeff = _pi_coeff(arg)
    if pi_coeff is not None and (not (2 * pi_coeff).is_integer) and pi_coeff.is_Rational:
        q = pi_coeff.q
        p = pi_coeff.p % (2 * q)
        if p > q:
            narg = (pi_coeff - 1) * S.Pi
            return -cls(narg)
        if 2 * p > q:
            narg = (1 - pi_coeff) * S.Pi
            if cls._is_odd:
                return cls(narg)
            elif cls._is_even:
                return -cls(narg)
    t = cls._reciprocal_of.eval(arg)
    if hasattr(arg, 'inverse') and arg.inverse() == cls:
        return arg.args[0]
    return 1 / t if t != None else t

.sympy.core.add.Add._eval_is_nonnegative

def _eval_is_nonnegative(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_nonnegative:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_nonnegative:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_nonnegative:
                        return True

.sympy.functions.elementary.trigonometric.cos._eval_is_finite

def _eval_is_finite(self):
    arg = self.args[0]
    if arg.is_real:
        return True

.sympy.core.mul.Mul._eval_is_even

def _eval_is_even(self):
    is_integer = self.is_integer
    if is_integer:
        return fuzzy_not(self.is_odd)
    elif is_integer is False:
        return False

.sympy.polys.densebasic.dmp_terms_gcd

def dmp_terms_gcd(f, u, K):
    if dmp_ground_TC(f, u, K) or dmp_zero_p(f, u):
        return ((0,) * (u + 1), f)
    F = dmp_to_dict(f, u)
    G = monomial_min(*list(F.keys()))
    if all((g == 0 for g in G)):
        return (G, f)
    f = {}
    for monom, coeff in F.items():
        f[monomial_div(monom, G)] = coeff
    return (G, dmp_from_dict(f, u, K))

.sympy.polys.densebasic.dmp_ground_TC

def dmp_ground_TC(f, u, K):
    while u:
        f = dmp_TC(f, K)
        u -= 1
    return dup_TC(f, K)

.sympy.polys.densetools.dmp_ground_primitive

def dmp_ground_primitive(f, u, K):
    if not u:
        return dup_primitive(f, K)
    if dmp_zero_p(f, u):
        return (K.zero, f)
    cont = dmp_ground_content(f, u, K)
    if K.is_one(cont):
        return (cont, f)
    else:
        return (cont, dmp_quo_ground(f, cont, u, K))

.sympy.polys.densetools.dmp_ground_content

def dmp_ground_content(f, u, K):
    from sympy.polys.domains import QQ
    if not u:
        return dup_content(f, K)
    if dmp_zero_p(f, u):
        return K.zero
    cont, v = (K.zero, u - 1)
    if K == QQ:
        for c in f:
            cont = K.gcd(cont, dmp_ground_content(c, v, K))
    else:
        for c in f:
            cont = K.gcd(cont, dmp_ground_content(c, v, K))
            if K.is_one(cont):
                break
    return cont

.sympy.polys.densebasic.dmp_exclude

def dmp_exclude(f, u, K):
    if not u or dmp_ground_p(f, None, u):
        return ([], f, u)
    J, F = ([], dmp_to_dict(f, u))
    for j in range(0, u + 1):
        for monom in F.keys():
            if monom[j]:
                break
        else:
            J.append(j)
    if not J:
        return ([], f, u)
    f = {}
    for monom, coeff in F.items():
        monom = list(monom)
        for j in reversed(J):
            del monom[j]
        f[tuple(monom)] = coeff
    u -= len(J)
    return (J, dmp_from_dict(f, u, K), u)

.sympy.polys.factortools.dmp_zz_factor

def dmp_zz_factor(f, u, K):
    if not u:
        return dup_zz_factor(f, K)
    if dmp_zero_p(f, u):
        return (K.zero, [])
    cont, g = dmp_ground_primitive(f, u, K)
    if dmp_ground_LC(g, u, K) < 0:
        cont, g = (-cont, dmp_neg(g, u, K))
    if all((d <= 0 for d in dmp_degree_list(g, u))):
        return (cont, [])
    G, g = dmp_primitive(g, u, K)
    factors = []
    if dmp_degree(g, u) > 0:
        g = dmp_sqf_part(g, u, K)
        H = dmp_zz_wang(g, u, K)
        factors = dmp_trial_division(f, H, u, K)
    for g, k in dmp_zz_factor(G, u - 1, K)[1]:
        factors.insert(0, ([g], k))
    return (cont, _sort_factors(factors))

.sympy.polys.densebasic.dmp_degree_list

def dmp_degree_list(f, u):
    degs = [-oo] * (u + 1)
    _rec_degree_list(f, u, 0, degs)
    return tuple(degs)

.sympy.polys.densebasic._rec_degree_list

def _rec_degree_list(g, v, i, degs):
    degs[i] = max(degs[i], dmp_degree(g, v))
    if v > 0:
        v, i = (v - 1, i + 1)
        for c in g:
            _rec_degree_list(c, v, i, degs)

.sympy.core.numbers.NegativeInfinity.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s > %s' % (self, other))
    if other.is_real:
        return S.false
    return Expr.__gt__(self, other)

.sympy.polys.euclidtools.dmp_primitive

def dmp_primitive(f, u, K):
    cont, v = (dmp_content(f, u, K), u - 1)
    if dmp_zero_p(f, u) or dmp_one_p(cont, v, K):
        return (cont, f)
    else:
        return (cont, [dmp_quo(c, cont, v, K) for c in f])

.sympy.polys.euclidtools.dmp_content

def dmp_content(f, u, K):
    cont, v = (dmp_LC(f, K), u - 1)
    if dmp_zero_p(f, u):
        return cont
    for c in f[1:]:
        cont = dmp_gcd(cont, c, v, K)
        if dmp_one_p(cont, v, K):
            break
    if K.is_negative(dmp_ground_LC(cont, v, K)):
        return dmp_neg(cont, v, K)
    else:
        return cont

.sympy.polys.euclidtools.dmp_gcd

def dmp_gcd(f, g, u, K):
    return dmp_inner_gcd(f, g, u, K)[0]

.sympy.polys.domains.domain.Domain.is_nonnegative

def is_nonnegative(self, a):
    return a >= 0

.sympy.polys.sqfreetools.dmp_sqf_part

def dmp_sqf_part(f, u, K):
    if not u:
        return dup_sqf_part(f, K)
    if K.is_FiniteField:
        return dmp_gf_sqf_part(f, u, K)
    if dmp_zero_p(f, u):
        return f
    if K.is_negative(dmp_ground_LC(f, u, K)):
        f = dmp_neg(f, u, K)
    gcd = dmp_gcd(f, dmp_diff(f, 1, u, K), u, K)
    sqf = dmp_quo(f, gcd, u, K)
    if K.is_Field:
        return dmp_ground_monic(sqf, u, K)
    else:
        return dmp_ground_primitive(sqf, u, K)[1]

.sympy.polys.densetools.dmp_diff

def dmp_diff(f, m, u, K):
    if not u:
        return dup_diff(f, m, K)
    if m <= 0:
        return f
    n = dmp_degree(f, u)
    if n < m:
        return dmp_zero(u)
    deriv, v = ([], u - 1)
    if m == 1:
        for coeff in f[:-m]:
            deriv.append(dmp_mul_ground(coeff, K(n), v, K))
            n -= 1
    else:
        for coeff in f[:-m]:
            k = n
            for i in range(n - 1, n - m, -1):
                k *= i
            deriv.append(dmp_mul_ground(coeff, K(k), v, K))
            n -= 1
    return dmp_strip(deriv, u)

.sympy.polys.densearith.dmp_mul_ground

def dmp_mul_ground(f, c, u, K):
    if not u:
        return dup_mul_ground(f, c, K)
    v = u - 1
    return [dmp_mul_ground(cf, c, v, K) for cf in f]

.sympy.polys.euclidtools._dmp_simplify_gcd

def _dmp_simplify_gcd(f, g, u, K):
    df = dmp_degree(f, u)
    dg = dmp_degree(g, u)
    if df > 0 and dg > 0:
        return None
    if not (df or dg):
        F = dmp_LC(f, K)
        G = dmp_LC(g, K)
    elif not df:
        F = dmp_LC(f, K)
        G = dmp_content(g, u, K)
    else:
        F = dmp_content(f, u, K)
        G = dmp_LC(g, K)
    v = u - 1
    h = dmp_gcd(F, G, v, K)
    cff = [dmp_quo(cf, h, v, K) for cf in f]
    cfg = [dmp_quo(cg, h, v, K) for cg in g]
    return ([h], cff, cfg)

.sympy.polys.densetools.dmp_ground_extract

def dmp_ground_extract(f, g, u, K):
    fc = dmp_ground_content(f, u, K)
    gc = dmp_ground_content(g, u, K)
    gcd = K.gcd(fc, gc)
    if not K.is_one(gcd):
        f = dmp_quo_ground(f, gcd, u, K)
        g = dmp_quo_ground(g, gcd, u, K)
    return (gcd, f, g)

.sympy.polys.densearith.dmp_max_norm

def dmp_max_norm(f, u, K):
    if not u:
        return dup_max_norm(f, K)
    v = u - 1
    return max([dmp_max_norm(c, v, K) for c in f])

.sympy.polys.densetools.dmp_eval

def dmp_eval(f, a, u, K):
    if not u:
        return dup_eval(f, a, K)
    if not a:
        return dmp_TC(f, K)
    result, v = (dmp_LC(f, K), u - 1)
    for coeff in f[1:]:
        result = dmp_mul_ground(result, a, v, K)
        result = dmp_add(result, coeff, v, K)
    return result

.sympy.polys.densearith.dmp_add

def dmp_add(f, g, u, K):
    if not u:
        return dup_add(f, g, K)
    df = dmp_degree(f, u)
    if df < 0:
        return g
    dg = dmp_degree(g, u)
    if dg < 0:
        return f
    v = u - 1
    if df == dg:
        return dmp_strip([dmp_add(a, b, v, K) for a, b in zip(f, g)], u)
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [dmp_add(a, b, v, K) for a, b in zip(f, g)]

.sympy.polys.densearith.dup_add

def dup_add(f, g, K):
    if not f:
        return g
    if not g:
        return f
    df = dup_degree(f)
    dg = dup_degree(g)
    if df == dg:
        return dup_strip([a + b for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [a + b for a, b in zip(f, g)]

.sympy.polys.euclidtools._dmp_zz_gcd_interpolate

def _dmp_zz_gcd_interpolate(h, x, v, K):
    f = []
    while not dmp_zero_p(h, v):
        g = dmp_ground_trunc(h, x, v, K)
        f.insert(0, g)
        h = dmp_sub(h, g, v, K)
        h = dmp_quo_ground(h, x, v, K)
    if K.is_negative(dmp_ground_LC(f, v + 1, K)):
        return dmp_neg(f, v + 1, K)
    else:
        return f

.sympy.polys.densetools.dmp_ground_trunc

def dmp_ground_trunc(f, p, u, K):
    if not u:
        return dup_trunc(f, p, K)
    v = u - 1
    return dmp_strip([dmp_ground_trunc(c, p, v, K) for c in f], u)

.sympy.polys.densetools.dup_trunc

def dup_trunc(f, p, K):
    if K.is_ZZ:
        g = []
        for c in f:
            c = c % p
            if c > p // 2:
                g.append(c - p)
            else:
                g.append(c)
    else:
        g = [c % p for c in f]
    return dup_strip(g)

.sympy.polys.densearith.dmp_sub

def dmp_sub(f, g, u, K):
    if not u:
        return dup_sub(f, g, K)
    df = dmp_degree(f, u)
    if df < 0:
        return dmp_neg(g, u, K)
    dg = dmp_degree(g, u)
    if dg < 0:
        return f
    v = u - 1
    if df == dg:
        return dmp_strip([dmp_sub(a, b, v, K) for a, b in zip(f, g)], u)
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (dmp_neg(g[:k], u, K), g[k:])
        return h + [dmp_sub(a, b, v, K) for a, b in zip(f, g)]

.sympy.polys.densearith.dmp_quo_ground

def dmp_quo_ground(f, c, u, K):
    if not u:
        return dup_quo_ground(f, c, K)
    v = u - 1
    return [dmp_quo_ground(cf, c, v, K) for cf in f]

.sympy.polys.densearith.dmp_div

def dmp_div(f, g, u, K):
    if K.is_Field:
        return dmp_ff_div(f, g, u, K)
    else:
        return dmp_rr_div(f, g, u, K)

.sympy.polys.densearith.dmp_rr_div

def dmp_rr_div(f, g, u, K):
    if not u:
        return dup_rr_div(f, g, K)
    df = dmp_degree(f, u)
    dg = dmp_degree(g, u)
    if dg < 0:
        raise ZeroDivisionError('polynomial division')
    q, r, dr = (dmp_zero(u), f, df)
    if df < dg:
        return (q, r)
    lc_g, v = (dmp_LC(g, K), u - 1)
    while True:
        lc_r = dmp_LC(r, K)
        c, R = dmp_rr_div(lc_r, lc_g, v, K)
        if not dmp_zero_p(R, v):
            break
        j = dr - dg
        q = dmp_add_term(q, c, j, u, K)
        h = dmp_mul_term(g, c, j, u, K)
        r = dmp_sub(r, h, u, K)
        _dr, dr = (dr, dmp_degree(r, u))
        if dr < dg:
            break
        elif not dr < _dr:
            raise PolynomialDivisionFailed(f, g, K)
    return (q, r)

.sympy.polys.densearith.dmp_add_term

def dmp_add_term(f, c, i, u, K):
    if not u:
        return dup_add_term(f, c, i, K)
    v = u - 1
    if dmp_zero_p(c, v):
        return f
    n = len(f)
    m = n - i - 1
    if i == n - 1:
        return dmp_strip([dmp_add(f[0], c, v, K)] + f[1:], u)
    elif i >= n:
        return [c] + dmp_zeros(i - n, v, K) + f
    else:
        return f[:m] + [dmp_add(f[m], c, v, K)] + f[m + 1:]

.sympy.polys.densebasic.dmp_zeros

def dmp_zeros(n, u, K):
    if not n:
        return []
    if u < 0:
        return [K.zero] * n
    else:
        return [dmp_zero(u) for i in range(n)]

.sympy.polys.densearith.dmp_mul_term

def dmp_mul_term(f, c, i, u, K):
    if not u:
        return dup_mul_term(f, c, i, K)
    v = u - 1
    if dmp_zero_p(f, u):
        return f
    if dmp_zero_p(c, v):
        return dmp_zero(u)
    else:
        return [dmp_mul(cf, c, v, K) for cf in f] + dmp_zeros(i, v, K)

.sympy.polys.densearith.dmp_mul

def dmp_mul(f, g, u, K):
    if not u:
        return dup_mul(f, g, K)
    if f == g:
        return dmp_sqr(f, u, K)
    df = dmp_degree(f, u)
    if df < 0:
        return f
    dg = dmp_degree(g, u)
    if dg < 0:
        return g
    h, v = ([], u - 1)
    for i in range(0, df + dg + 1):
        coeff = dmp_zero(v)
        for j in range(max(0, i - dg), min(df, i) + 1):
            coeff = dmp_add(coeff, dmp_mul(f[j], g[i - j], v, K), v, K)
        h.append(coeff)
    return dmp_strip(h, u)

.sympy.polys.densearith.dup_mul

def dup_mul(f, g, K):
    if f == g:
        return dup_sqr(f, K)
    if not (f and g):
        return []
    df = dup_degree(f)
    dg = dup_degree(g)
    n = max(df, dg) + 1
    if n < 100:
        h = []
        for i in range(0, df + dg + 1):
            coeff = K.zero
            for j in range(max(0, i - dg), min(df, i) + 1):
                coeff += f[j] * g[i - j]
            h.append(coeff)
        return dup_strip(h)
    else:
        n2 = n // 2
        fl, gl = (dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K))
        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)
        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)
        lo, hi = (dup_mul(fl, gl, K), dup_mul(fh, gh, K))
        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)
        mid = dup_sub(mid, dup_add(lo, hi, K), K)
        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K), dup_lshift(hi, 2 * n2, K), K)

.sympy.polys.densearith.dup_sqr

def dup_sqr(f, K):
    df, h = (len(f) - 1, [])
    for i in range(0, 2 * df + 1):
        c = K.zero
        jmin = max(0, i - df)
        jmax = min(i, df)
        n = jmax - jmin + 1
        jmax = jmin + n // 2 - 1
        for j in range(jmin, jmax + 1):
            c += f[j] * f[i - j]
        c += c
        if n & 1:
            elem = f[jmax + 1]
            c += elem ** 2
        h.append(c)
    return dup_strip(h)

.sympy.polys.densearith.dmp_quo

def dmp_quo(f, g, u, K):
    return dmp_div(f, g, u, K)[0]

.sympy.polys.factortools.dmp_zz_wang

def dmp_zz_wang(f, u, K, mod=None, seed=None):
    from sympy.utilities.randtest import _randint
    randint = _randint(seed)
    ct, T = dmp_zz_factor(dmp_LC(f, K), u - 1, K)
    b = dmp_zz_mignotte_bound(f, u, K)
    p = K(nextprime(b))
    if mod is None:
        if u == 1:
            mod = 2
        else:
            mod = 1
    history, configs, A, r = (set([]), [], [K.zero] * u, None)
    try:
        cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
        _, H = dup_zz_factor_sqf(s, K)
        r = len(H)
        if r == 1:
            return [f]
        configs = [(s, cs, E, H, A)]
    except EvaluationFailed:
        pass
    eez_num_configs = query('EEZ_NUMBER_OF_CONFIGS')
    eez_num_tries = query('EEZ_NUMBER_OF_TRIES')
    eez_mod_step = query('EEZ_MODULUS_STEP')
    while len(configs) < eez_num_configs:
        for _ in range(eez_num_tries):
            A = [K(randint(-mod, mod)) for _ in range(u)]
            if tuple(A) not in history:
                history.add(tuple(A))
            else:
                continue
            try:
                cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
            except EvaluationFailed:
                continue
            _, H = dup_zz_factor_sqf(s, K)
            rr = len(H)
            if r is not None:
                if rr != r:
                    if rr < r:
                        configs, r = ([], rr)
                    else:
                        continue
            else:
                r = rr
            if r == 1:
                return [f]
            configs.append((s, cs, E, H, A))
            if len(configs) == eez_num_configs:
                break
        else:
            mod += eez_mod_step
    s_norm, s_arg, i = (None, 0, 0)
    for s, _, _, _, _ in configs:
        _s_norm = dup_max_norm(s, K)
        if s_norm is not None:
            if _s_norm < s_norm:
                s_norm = _s_norm
                s_arg = i
        else:
            s_norm = _s_norm
        i += 1
    _, cs, E, H, A = configs[s_arg]
    orig_f = f
    try:
        f, H, LC = dmp_zz_wang_lead_coeffs(f, T, cs, E, H, A, u, K)
        factors = dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K)
    except ExtraneousFactors:
        if query('EEZ_RESTART_IF_NEEDED'):
            return dmp_zz_wang(orig_f, u, K, mod + 1)
        else:
            raise ExtraneousFactors('we need to restart algorithm with better parameters')
    negative, result = (0, [])
    for f in factors:
        _, f = dmp_ground_primitive(f, u, K)
        if K.is_negative(dmp_ground_LC(f, u, K)):
            f = dmp_neg(f, u, K)
        result.append(f)
    return result

.sympy.utilities.randtest._randint

def _randint(seed=None):
    if seed is None:
        return random.randint
    elif isinstance(seed, int):
        return random.Random(seed).randint
    elif is_sequence(seed):
        seed = list(seed)
        seed.reverse()

        def give(a, b, seq=seed):
            a, b = (as_int(a), as_int(b))
            w = b - a
            if w < 0:
                raise ValueError('_randint got empty range')
            try:
                x = seq.pop()
            except AttributeError:
                raise ValueError('_randint expects a list-like sequence')
            except IndexError:
                raise ValueError('_randint sequence was too short')
            if a <= x <= b:
                return x
            else:
                return give(a, b, seq)
        return give
    else:
        raise ValueError('_randint got an unexpected seed')

.sympy.polys.factortools.dmp_zz_mignotte_bound

def dmp_zz_mignotte_bound(f, u, K):
    a = dmp_max_norm(f, u, K)
    b = abs(dmp_ground_LC(f, u, K))
    n = sum(dmp_degree_list(f, u))
    return K.sqrt(K(n + 1)) * 2 ** n * a * b

.sympy.ntheory.generate.nextprime

def nextprime(n, ith=1):
    n = int(n)
    i = as_int(ith)
    if i > 1:
        pr = n
        j = 1
        while 1:
            pr = nextprime(pr)
            j += 1
            if j > i:
                break
        return pr
    if n < 2:
        return 2
    if n < 7:
        return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]
    if n <= sieve._list[-2]:
        l, u = sieve.search(n)
        if l == u:
            return sieve[u + 1]
        else:
            return sieve[u]
    nn = 6 * (n // 6)
    if nn == n:
        n += 1
        if isprime(n):
            return n
        n += 4
    elif n - nn == 5:
        n += 2
        if isprime(n):
            return n
        n += 4
    else:
        n = nn + 5
    while 1:
        if isprime(n):
            return n
        n += 2
        if isprime(n):
            return n
        n += 4

.sympy.ntheory.primetest.isprime

def isprime(n):
    if isinstance(n, (Float, float)):
        return False
    n = int(n)
    if n in [2, 3, 5]:
        return True
    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):
        return False
    if n < 49:
        return True
    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):
        return False
    if n < 2809:
        return True
    if n <= 23001:
        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]
    from sympy.ntheory.generate import sieve as s
    if n <= s._list[-1]:
        l, u = s.search(n)
        return l == u
    from sympy.core.compatibility import HAS_GMPY
    if HAS_GMPY == 2:
        from gmpy2 import is_strong_prp, is_strong_selfridge_prp
        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)
    if n < 341531:
        return mr(n, [9345883071009581737])
    if n < 885594169:
        return mr(n, [725270293939359937, 3569819667048198375])
    if n < 350269456337:
        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])
    if n < 55245642489451:
        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])
    if n < 7999252175582851:
        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])
    if n < 585226005592931977:
        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])
    if n < 18446744073709551616:
        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])
    return mr(n, [2]) and is_strong_lucas_prp(n)

.sympy.polys.factortools.dmp_zz_wang_test_points

def dmp_zz_wang_test_points(f, T, ct, A, u, K):
    if not dmp_eval_tail(dmp_LC(f, K), A, u - 1, K):
        raise EvaluationFailed('no luck')
    g = dmp_eval_tail(f, A, u, K)
    if not dup_sqf_p(g, K):
        raise EvaluationFailed('no luck')
    c, h = dup_primitive(g, K)
    if K.is_negative(dup_LC(h, K)):
        c, h = (-c, dup_neg(h, K))
    v = u - 1
    E = [dmp_eval_tail(t, A, v, K) for t, _ in T]
    D = dmp_zz_wang_non_divisors(E, c, ct, K)
    if D is not None:
        return (c, h, E)
    else:
        raise EvaluationFailed('no luck')

.sympy.polys.densetools.dmp_eval_tail

def dmp_eval_tail(f, A, u, K):
    if not A:
        return f
    if dmp_zero_p(f, u):
        return dmp_zero(u - len(A))
    e = _rec_eval_tail(f, 0, A, u, K)
    if u == len(A) - 1:
        return e
    else:
        return dmp_strip(e, u - len(A))

.sympy.polys.densetools._rec_eval_tail

def _rec_eval_tail(g, i, A, u, K):
    if i == u:
        return dup_eval(g, A[-1], K)
    else:
        h = [_rec_eval_tail(c, i + 1, A, u, K) for c in g]
        if i < u - len(A) + 1:
            return h
        else:
            return dup_eval(h, A[-u + i - 1], K)

.sympy.polys.sqfreetools.dup_sqf_p

def dup_sqf_p(f, K):
    if not f:
        return True
    else:
        return not dup_degree(dup_gcd(f, dup_diff(f, 1, K), K))

.sympy.polys.factortools.dmp_zz_wang_non_divisors

def dmp_zz_wang_non_divisors(E, cs, ct, K):
    result = [cs * ct]
    for q in E:
        q = abs(q)
        for r in reversed(result):
            while r != 1:
                r = K.gcd(r, q)
                q = q // r
            if K.is_one(q):
                return None
        result.append(q)
    return result[1:]

.sympy.polys.factortools.dup_zz_factor_sqf

def dup_zz_factor_sqf(f, K):
    cont, g = dup_primitive(f, K)
    n = dup_degree(g)
    if dup_LC(g, K) < 0:
        cont, g = (-cont, dup_neg(g, K))
    if n <= 0:
        return (cont, [])
    elif n == 1:
        return (cont, [g])
    if query('USE_IRREDUCIBLE_IN_FACTOR'):
        if dup_zz_irreducible_p(g, K):
            return (cont, [g])
    factors = None
    if query('USE_CYCLOTOMIC_FACTOR'):
        factors = dup_zz_cyclotomic_factor(g, K)
    if factors is None:
        factors = dup_zz_zassenhaus(g, K)
    return (cont, _sort_factors(factors, multiple=False))

.sympy.polys.polyutils.order_no_multiple_key

def order_no_multiple_key(f):
    return (len(f), f)

.sympy.polys.factortools.dup_zz_zassenhaus

def dup_zz_zassenhaus(f, K):
    n = dup_degree(f)
    if n == 1:
        return [f]
    fc = f[-1]
    A = dup_max_norm(f, K)
    b = dup_LC(f, K)
    B = int(abs(K.sqrt(K(n + 1)) * 2 ** n * A * b))
    C = int((n + 1) ** (2 * n) * A ** (2 * n - 1))
    gamma = int(_ceil(2 * _log(C, 2)))
    bound = int(2 * gamma * _log(gamma))
    a = []
    for px in range(3, bound + 1):
        if not isprime(px) or b % px == 0:
            continue
        px = K.convert(px)
        F = gf_from_int_poly(f, px)
        if not gf_sqf_p(F, px, K):
            continue
        fsqfx = gf_factor_sqf(F, px, K)[1]
        a.append((px, fsqfx))
        if len(fsqfx) < 15 or len(a) > 4:
            break
    p, fsqf = min(a, key=lambda x: len(x[1]))
    l = int(_ceil(_log(2 * B + 1, p)))
    modular = [gf_to_int_poly(ff, p) for ff in fsqf]
    g = dup_zz_hensel_lift(p, f, modular, l, K)
    sorted_T = range(len(g))
    T = set(sorted_T)
    factors, s = ([], 1)
    pl = p ** l
    while 2 * s <= len(T):
        for S in subsets(sorted_T, s):
            if b == 1:
                q = 1
                for i in S:
                    q = q * g[i][-1]
                q = q % pl
                if not _test_pl(fc, q, pl):
                    continue
            else:
                G = [b]
                for i in S:
                    G = dup_mul(G, g[i], K)
                G = dup_trunc(G, pl, K)
                G = dup_primitive(G, K)[1]
                q = G[-1]
                if q and fc % q != 0:
                    continue
            H = [b]
            S = set(S)
            T_S = T - S
            if b == 1:
                G = [b]
                for i in S:
                    G = dup_mul(G, g[i], K)
                G = dup_trunc(G, pl, K)
            for i in T_S:
                H = dup_mul(H, g[i], K)
            H = dup_trunc(H, pl, K)
            G_norm = dup_l1_norm(G, K)
            H_norm = dup_l1_norm(H, K)
            if G_norm * H_norm <= B:
                T = T_S
                sorted_T = [i for i in sorted_T if i not in S]
                G = dup_primitive(G, K)[1]
                f = dup_primitive(H, K)[1]
                factors.append(G)
                b = dup_LC(f, K)
                break
        else:
            s += 1
    return factors + [f]

.sympy.polys.galoistools.gf_from_int_poly

def gf_from_int_poly(f, p):
    return gf_trunc(f, p)

.sympy.polys.galoistools.gf_trunc

def gf_trunc(f, p):
    return gf_strip([a % p for a in f])

.sympy.polys.galoistools.gf_strip

def gf_strip(f):
    if not f or f[0]:
        return f
    k = 0
    for coeff in f:
        if coeff:
            break
        else:
            k += 1
    return f[k:]

.sympy.polys.galoistools.gf_sqf_p

def gf_sqf_p(f, p, K):
    _, f = gf_monic(f, p, K)
    if not f:
        return True
    else:
        return gf_gcd(f, gf_diff(f, p, K), p, K) == [K.one]

.sympy.polys.galoistools.gf_monic

def gf_monic(f, p, K):
    if not f:
        return (K.zero, [])
    else:
        lc = f[0]
        if K.is_one(lc):
            return (lc, list(f))
        else:
            return (lc, gf_quo_ground(f, lc, p, K))

.sympy.polys.galoistools.gf_diff

def gf_diff(f, p, K):
    df = gf_degree(f)
    h, n = ([K.zero] * df, df)
    for coeff in f[:-1]:
        coeff *= K(n)
        coeff %= p
        if coeff:
            h[df - n] = coeff
        n -= 1
    return gf_strip(h)

.sympy.polys.galoistools.gf_degree

def gf_degree(f):
    return len(f) - 1

.sympy.polys.galoistools.gf_gcd

def gf_gcd(f, g, p, K):
    while g:
        f, g = (g, gf_rem(f, g, p, K))
    return gf_monic(f, p, K)[1]

.sympy.polys.galoistools.gf_rem

def gf_rem(f, g, p, K):
    return gf_div(f, g, p, K)[1]

.sympy.polys.galoistools.gf_div

def gf_div(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return ([], f)
    inv = K.invert(g[0], p)
    h, dq, dr = (list(f), df - dg, dg - 1)
    for i in range(0, df + 1):
        coeff = h[i]
        for j in range(max(0, dg - i), min(df - i, dr) + 1):
            coeff -= h[i + j - dg] * g[dg - j]
        if i <= dq:
            coeff *= inv
        h[i] = coeff % p
    return (h[:dq + 1], gf_strip(h[dq + 1:]))

.sympy.polys.domains.ring.Ring.invert

def invert(self, a, b):
    s, t, h = self.gcdex(a, b)
    if self.is_one(h):
        return s % b
    else:
        raise NotInvertible('zero divisor')

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.gcdex

def gcdex(self, a, b):
    return python_gcdex(a, b)

.sympy.core.numbers.igcdex

def igcdex(a, b):
    if not a and (not b):
        return (0, 1, 0)
    if not a:
        return (0, b // abs(b), abs(b))
    if not b:
        return (a // abs(a), 0, abs(a))
    if a < 0:
        a, x_sign = (-a, -1)
    else:
        x_sign = 1
    if b < 0:
        b, y_sign = (-b, -1)
    else:
        y_sign = 1
    x, y, r, s = (1, 0, 0, 1)
    while b:
        c, q = (a % b, a // b)
        a, b, r, s, x, y = (b, c, x - q * r, y - q * s, r, s)
    return (x * x_sign, y * y_sign, a)

.sympy.polys.galoistools.gf_quo_ground

def gf_quo_ground(f, a, p, K):
    return gf_mul_ground(f, K.invert(a, p), p, K)

.sympy.polys.galoistools.gf_mul_ground

def gf_mul_ground(f, a, p, K):
    if not a:
        return []
    else:
        return [a * b % p for b in f]

.sympy.polys.galoistools.gf_factor_sqf

def gf_factor_sqf(f, p, K, method=None):
    lc, f = gf_monic(f, p, K)
    if gf_degree(f) < 1:
        return (lc, [])
    method = method or query('GF_FACTOR_METHOD')
    if method is not None:
        factors = _factor_methods[method](f, p, K)
    else:
        factors = gf_zassenhaus(f, p, K)
    return (lc, factors)

.sympy.polys.galoistools.gf_zassenhaus

def gf_zassenhaus(f, p, K):
    factors = []
    for factor, n in gf_ddf_zassenhaus(f, p, K):
        factors += gf_edf_zassenhaus(factor, n, p, K)
    return _sort_factors(factors, multiple=False)

.sympy.polys.galoistools.gf_ddf_zassenhaus

def gf_ddf_zassenhaus(f, p, K):
    i, g, factors = (1, [K.one, K.zero], [])
    b = gf_frobenius_monomial_base(f, p, K)
    while 2 * i <= gf_degree(f):
        g = gf_frobenius_map(g, f, b, p, K)
        h = gf_gcd(f, gf_sub(g, [K.one, K.zero], p, K), p, K)
        if h != [K.one]:
            factors.append((h, i))
            f = gf_quo(f, h, p, K)
            g = gf_rem(g, f, p, K)
            b = gf_frobenius_monomial_base(f, p, K)
        i += 1
    if f != [K.one]:
        return factors + [(f, gf_degree(f))]
    else:
        return factors

.sympy.polys.galoistools.gf_frobenius_monomial_base

def gf_frobenius_monomial_base(g, p, K):
    n = gf_degree(g)
    if n == 0:
        return []
    b = [0] * n
    b[0] = [1]
    if p < n:
        for i in range(1, n):
            mon = gf_lshift(b[i - 1], p, K)
            b[i] = gf_rem(mon, g, p, K)
    elif n > 1:
        b[1] = gf_pow_mod([K.one, K.zero], p, g, p, K)
        for i in range(2, n):
            b[i] = gf_mul(b[i - 1], b[1], p, K)
            b[i] = gf_rem(b[i], g, p, K)
    return b

.sympy.polys.galoistools.gf_pow_mod

def gf_pow_mod(f, n, g, p, K):
    if not n:
        return [K.one]
    elif n == 1:
        return gf_rem(f, g, p, K)
    elif n == 2:
        return gf_rem(gf_sqr(f, p, K), g, p, K)
    h = [K.one]
    while True:
        if n & 1:
            h = gf_mul(h, f, p, K)
            h = gf_rem(h, g, p, K)
            n -= 1
        n >>= 1
        if not n:
            break
        f = gf_sqr(f, p, K)
        f = gf_rem(f, g, p, K)
    return h

.sympy.polys.galoistools.gf_mul

def gf_mul(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    dh = df + dg
    h = [0] * (dh + 1)
    for i in range(0, dh + 1):
        coeff = K.zero
        for j in range(max(0, i - dg), min(i, df) + 1):
            coeff += f[j] * g[i - j]
        h[i] = coeff % p
    return gf_strip(h)

.sympy.polys.galoistools.gf_sqr

def gf_sqr(f, p, K):
    df = gf_degree(f)
    dh = 2 * df
    h = [0] * (dh + 1)
    for i in range(0, dh + 1):
        coeff = K.zero
        jmin = max(0, i - df)
        jmax = min(i, df)
        n = jmax - jmin + 1
        jmax = jmin + n // 2 - 1
        for j in range(jmin, jmax + 1):
            coeff += f[j] * f[i - j]
        coeff += coeff
        if n & 1:
            elem = f[jmax + 1]
            coeff += elem ** 2
        h[i] = coeff % p
    return gf_strip(h)

.sympy.polys.galoistools.gf_frobenius_map

def gf_frobenius_map(f, g, b, p, K):
    m = gf_degree(g)
    if gf_degree(f) >= m:
        f = gf_rem(f, g, p, K)
    if not f:
        return []
    n = gf_degree(f)
    sf = [f[-1]]
    for i in range(1, n + 1):
        v = gf_mul_ground(b[i], f[n - i], p, K)
        sf = gf_add(sf, v, p, K)
    return sf

.sympy.polys.galoistools.gf_add

def gf_add(f, g, p, K):
    if not f:
        return g
    if not g:
        return f
    df = gf_degree(f)
    dg = gf_degree(g)
    if df == dg:
        return gf_strip([(a + b) % p for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [(a + b) % p for a, b in zip(f, g)]

.sympy.polys.galoistools.gf_sub

def gf_sub(f, g, p, K):
    if not g:
        return f
    if not f:
        return gf_neg(g, p, K)
    df = gf_degree(f)
    dg = gf_degree(g)
    if df == dg:
        return gf_strip([(a - b) % p for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (gf_neg(g[:k], p, K), g[k:])
        return h + [(a - b) % p for a, b in zip(f, g)]

.sympy.polys.galoistools.gf_edf_zassenhaus

def gf_edf_zassenhaus(f, n, p, K):
    factors, q = ([f], int(p))
    if gf_degree(f) <= n:
        return factors
    N = gf_degree(f) // n
    if p != 2:
        b = gf_frobenius_monomial_base(f, p, K)
    while len(factors) < N:
        r = gf_random(2 * n - 1, p, K)
        if p == 2:
            h = r
            for i in range(0, 2 ** (n * N - 1)):
                r = gf_pow_mod(r, 2, f, p, K)
                h = gf_add(h, r, p, K)
            g = gf_gcd(f, h, p, K)
        else:
            h = _gf_pow_pnm1d2(r, n, f, b, p, K)
            g = gf_gcd(f, gf_sub_ground(h, K.one, p, K), p, K)
        if g != [K.one] and g != f:
            factors = gf_edf_zassenhaus(g, n, p, K) + gf_edf_zassenhaus(gf_quo(f, g, p, K), n, p, K)
    return _sort_factors(factors, multiple=False)

.sympy.polys.galoistools.gf_to_int_poly

def gf_to_int_poly(f, p, symmetric=True):
    if symmetric:
        return [gf_int(c, p) for c in f]
    else:
        return f

.sympy.polys.galoistools.gf_int

def gf_int(a, p):
    if a <= p // 2:
        return a
    else:
        return a - p

.sympy.polys.factortools.dup_zz_hensel_lift

def dup_zz_hensel_lift(p, f, f_list, l, K):
    r = len(f_list)
    lc = dup_LC(f, K)
    if r == 1:
        F = dup_mul_ground(f, K.gcdex(lc, p ** l)[0], K)
        return [dup_trunc(F, p ** l, K)]
    m = p
    k = r // 2
    d = int(_ceil(_log(l, 2)))
    g = gf_from_int_poly([lc], p)
    for f_i in f_list[:k]:
        g = gf_mul(g, gf_from_int_poly(f_i, p), p, K)
    h = gf_from_int_poly(f_list[k], p)
    for f_i in f_list[k + 1:]:
        h = gf_mul(h, gf_from_int_poly(f_i, p), p, K)
    s, t, _ = gf_gcdex(g, h, p, K)
    g = gf_to_int_poly(g, p)
    h = gf_to_int_poly(h, p)
    s = gf_to_int_poly(s, p)
    t = gf_to_int_poly(t, p)
    for _ in range(1, d + 1):
        (g, h, s, t), m = (dup_zz_hensel_step(m, f, g, h, s, t, K), m ** 2)
    return dup_zz_hensel_lift(p, g, f_list[:k], l, K) + dup_zz_hensel_lift(p, h, f_list[k:], l, K)

.sympy.polys.factortools.dmp_trial_division

def dmp_trial_division(f, factors, u, K):
    result = []
    for factor in factors:
        k = 0
        while True:
            q, r = dmp_div(f, factor, u, K)
            if dmp_zero_p(r, u):
                f, k = (q, k + 1)
            else:
                break
        result.append((factor, k))
    return _sort_factors(result)

.sympy.polys.densebasic.dmp_include

def dmp_include(f, J, u, K):
    if not J:
        return f
    F, f = (dmp_to_dict(f, u), {})
    for monom, coeff in F.items():
        monom = list(monom)
        for j in J:
            monom.insert(j, 0)
        f[tuple(monom)] = coeff
    u += len(J)
    return dmp_from_dict(f, u, K)

.sympy.core.function.expand_power_exp

def expand_power_exp(expr, deep=True):
    return sympify(expr).expand(deep=deep, complex=False, basic=False, log=False, mul=False, power_exp=True, power_base=False, multinomial=False)

.sympy.core.rules.Transform.__init__

def __init__(self, transform, filter=lambda x: True):
    self._transform = transform
    self._filter = filter

.sympy.core.basic.Atom.xreplace

def xreplace(self, rule, hack2=False):
    return rule.get(self, self)

.sympy.core.rules.Transform.get

def get(self, item, default=None):
    if item in self:
        return self[item]
    else:
        return default

.sympy.core.rules.Transform.__contains__

def __contains__(self, item):
    return self._filter(item)

.sympy.core.numbers.GoldenRatio._as_mpf_val

def _as_mpf_val(self, prec):
    rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
    return mpf_norm(rv, prec)

.sympy.core.evalf.evalf_symbol

def evalf_symbol(x, prec, options):
    val = options['subs'][x]
    if isinstance(val, mpf):
        if not val:
            return (None, None, None, None)
        return (val._mpf_, None, prec, None)
    else:
        if not '_cache' in options:
            options['_cache'] = {}
        cache = options['_cache']
        cached, cached_prec = cache.get(x, (None, MINUS_INF))
        if cached_prec >= prec:
            return cached
        v = evalf(sympify(val), prec, options)
        cache[x] = (v, prec)
        return v

.sympy.core.expr.Expr.__int__

def __int__(self):
    from sympy import Dummy
    if not self.is_number:
        raise TypeError("can't convert symbols to int")
    r = self.round(2)
    if not r.is_Number:
        raise TypeError("can't convert complex to int")
    if r in (S.NaN, S.Infinity, S.NegativeInfinity):
        raise TypeError("can't convert %s to int" % r)
    i = int(r)
    if not i:
        return 0
    if i == r and (not (self - i).equals(0)):
        isign = 1 if i > 0 else -1
        x = Dummy()
        diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
        if diff_sign != isign:
            i -= isign
    return i

.sympy.core.expr.Expr.round

def round(self, p=0):
    from sympy import Float
    x = self
    if not x.is_number:
        raise TypeError("can't round symbolic expression")
    if not x.is_Atom:
        xn = x.n(2)
        if not pure_complex(xn, or_real=True):
            raise TypeError('Expected a number but got %s:' % getattr(getattr(x, 'func', x), '__name__', type(x)))
    elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
        return x
    if not x.is_real:
        i, r = x.as_real_imag()
        return i.round(p) + S.ImaginaryUnit * r.round(p)
    if not x:
        return x
    p = int(p)
    precs = [f._prec for f in x.atoms(Float)]
    dps = prec_to_dps(max(precs)) if precs else None
    mag_first_dig = _mag(x)
    allow = digits_needed = mag_first_dig + p
    if dps is not None and allow > dps:
        allow = dps
    mag = Pow(10, p)
    xwas = x
    x += 1 / (2 * mag)
    i10 = 10 * mag * x.n((dps if dps is not None else digits_needed) + 1)
    if i10.is_negative:
        x = xwas - 1 / (2 * mag)
        i10 = 10 * mag * x.n((dps if dps is not None else digits_needed) + 1)
        rv = -(Integer(-i10) // 10)
    else:
        rv = Integer(i10) // 10
    q = 1
    if p > 0:
        q = mag
    elif p < 0:
        rv /= mag
    rv = Rational(rv, q)
    if rv.is_Integer:
        return Float(str(rv), digits_needed)
    else:
        if not allow and rv > self:
            allow += 1
        return Float(rv, allow)

.sympy.core.numbers.Number.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            return S.Infinity
        elif other is S.NegativeInfinity:
            return S.NegativeInfinity
    return AtomicExpr.__add__(self, other)

.sympy.core.add.Add.as_real_imag

def as_real_imag(self, deep=True, **hints):
    sargs, terms = (self.args, [])
    re_part, im_part = ([], [])
    for term in sargs:
        re, im = term.as_real_imag(deep=deep)
        re_part.append(re)
        im_part.append(im)
    return (self.func(*re_part), self.func(*im_part))

.sympy.core.mul.Mul.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import Abs, expand_mul, im, re
    other = []
    coeffr = []
    coeffi = []
    addterms = S.One
    for a in self.args:
        r, i = a.as_real_imag()
        if i.is_zero:
            coeffr.append(r)
        elif r.is_zero:
            coeffi.append(i * S.ImaginaryUnit)
        elif a.is_commutative:
            for i, x in enumerate(other):
                if x == a.conjugate():
                    coeffr.append(Abs(x) ** 2)
                    del other[i]
                    break
            else:
                if a.is_Add:
                    addterms *= a
                else:
                    other.append(a)
        else:
            other.append(a)
    m = self.func(*other)
    if hints.get('ignore') == m:
        return
    if len(coeffi) % 2:
        imco = im(coeffi.pop(0))
    else:
        imco = S.Zero
    reco = self.func(*coeffr + coeffi)
    r, i = (reco * re(m), reco * im(m))
    if addterms == 1:
        if m == 1:
            if imco is S.Zero:
                return (reco, S.Zero)
            else:
                return (S.Zero, reco * imco)
        if imco is S.Zero:
            return (r, i)
        return (-imco * i, imco * r)
    addre, addim = expand_mul(addterms, deep=False).as_real_imag()
    if imco is S.Zero:
        return (r * addre - i * addim, i * addre + r * addim)
    else:
        r, i = (-imco * i, imco * r)
        return (r * addre - i * addim, r * addim + i * addre)

.sympy.core.expr._mag

def _mag(x):
    from math import log10, ceil, log
    from sympy import Float
    xpos = abs(x.n())
    if not xpos:
        return S.Zero
    try:
        mag_first_dig = int(ceil(log10(xpos)))
    except (ValueError, OverflowError):
        mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53)) / log(10)))
    if xpos / 10 ** mag_first_dig >= 1:
        assert 1 <= xpos / 10 ** mag_first_dig < 10
        mag_first_dig += 1
    return mag_first_dig

.sympy.core.numbers.Float.__abs__

def __abs__(self):
    return Float._new(mlib.mpf_abs(self._mpf_), self._prec)

.sympy.core.numbers.Float.__nonzero__

def __nonzero__(self):
    return self._mpf_ != _mpf_zero

.sympy.core.numbers.Float.__div__

def __div__(self, other):
    if isinstance(other, Number) and other != 0 and global_evaluate[0]:
        rhs, prec = other._as_mpf_op(self._prec)
        return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
    return Number.__div__(self, other)

.sympy.core.numbers.Float.__ge__

def __ge__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s >= %s' % (self, other))
    if isinstance(other, NumberSymbol):
        return other.__le__(self)
    if other.is_comparable:
        other = other.evalf()
    if isinstance(other, Number) and other is not S.NaN:
        return _sympify(bool(mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))
    return Expr.__ge__(self, other)

.sympy.core.numbers.Float.__int__

def __int__(self):
    if self._mpf_ == _mpf_zero:
        return 0
    return int(mlib.to_int(self._mpf_))

.sympy.core.numbers.Integer.__floordiv__

def __floordiv__(self, other):
    return Integer(self.p // Integer(other).p)

.sympy.core.numbers.Float.__new__

def __new__(cls, num, dps=None, prec=None, precision=None):
    if prec is not None:
        SymPyDeprecationWarning(feature="Using 'prec=XX' to denote decimal precision", useinstead="'dps=XX' for decimal precision and 'precision=XX' for binary precision", issue=12820, deprecated_since_version='1.1').warn()
        dps = prec
    del prec
    if dps is not None and precision is not None:
        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')
    if isinstance(num, string_types):
        num = num.replace(' ', '')
        if num.startswith('.') and len(num) > 1:
            num = '0' + num
        elif num.startswith('-.') and len(num) > 2:
            num = '-0.' + num[2:]
    elif isinstance(num, float) and num == 0:
        num = '0'
    elif isinstance(num, (SYMPY_INTS, Integer)):
        num = str(num)
    elif num is S.Infinity:
        num = '+inf'
    elif num is S.NegativeInfinity:
        num = '-inf'
    elif isinstance(num, mpmath.mpf):
        if precision is None:
            if dps is None:
                precision = num.context.prec
        num = num._mpf_
    if dps is None and precision is None:
        dps = 15
        if isinstance(num, Float):
            return num
        if isinstance(num, string_types) and _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                dps = max(15, dps)
                precision = mlib.libmpf.dps_to_prec(dps)
    elif precision == '' and dps is None or (precision is None and dps == ''):
        if not isinstance(num, string_types):
            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')
        ok = None
        if _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                    precision = mlib.libmpf.dps_to_prec(dps)
                ok = True
        if ok is None:
            raise ValueError('string-float not recognized: %s' % num)
    if precision is None or precision == '':
        precision = mlib.libmpf.dps_to_prec(dps)
    precision = int(precision)
    if isinstance(num, float):
        _mpf_ = mlib.from_float(num, precision, rnd)
    elif isinstance(num, string_types):
        _mpf_ = mlib.from_str(num, precision, rnd)
    elif isinstance(num, decimal.Decimal):
        if num.is_finite():
            _mpf_ = mlib.from_str(str(num), precision, rnd)
        elif num.is_nan():
            _mpf_ = _mpf_nan
        elif num.is_infinite():
            if num > 0:
                _mpf_ = _mpf_inf
            else:
                _mpf_ = _mpf_ninf
        else:
            raise ValueError('unexpected decimal value %s' % str(num))
    elif isinstance(num, tuple) and len(num) in (3, 4):
        if type(num[1]) is str:
            num = list(num)
            num[1] = long(num[1], 16)
            _mpf_ = tuple(num)
        elif len(num) == 4:
            return Float._new(num, precision)
        else:
            return (S.NegativeOne ** num[0] * num[1] * S(2) ** num[2]).evalf(precision)
    else:
        try:
            _mpf_ = num._as_mpf_val(precision)
        except (NotImplementedError, AttributeError):
            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
    if _mpf_ == _mpf_zero:
        pass
    elif _mpf_ == _mpf_nan:
        return S.NaN
    obj = Expr.__new__(cls)
    obj._mpf_ = _mpf_
    obj._prec = precision
    return obj

.sympy.core.basic.Atom.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)

.sympy.printing.str.StrPrinter._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return 'I'

.sympy.core.basic.Basic.subs

def subs(self, *args, **kwargs):
    from sympy.core.containers import Dict
    from sympy.utilities import default_sort_key
    from sympy import Dummy, Symbol
    unordered = False
    if len(args) == 1:
        sequence = args[0]
        if isinstance(sequence, set):
            unordered = True
        elif isinstance(sequence, (Dict, Mapping)):
            unordered = True
            sequence = sequence.items()
        elif not iterable(sequence):
            from sympy.utilities.misc import filldedent
            raise ValueError(filldedent('\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.'))
    elif len(args) == 2:
        sequence = [args]
    else:
        raise ValueError('subs accepts either 1 or 2 arguments')
    sequence = list(sequence)
    for i in range(len(sequence)):
        s = list(sequence[i])
        for j, si in enumerate(s):
            try:
                si = sympify(si, strict=True)
            except SympifyError:
                if type(si) is str:
                    si = Symbol(si)
                else:
                    sequence[i] = None
                    break
            s[j] = si
        else:
            sequence[i] = None if _aresame(*s) else tuple(s)
    sequence = list(filter(None, sequence))
    if unordered:
        sequence = dict(sequence)
        if not all((k.is_Atom for k in sequence)):
            d = {}
            for o, n in sequence.items():
                try:
                    ops = (o.count_ops(), len(o.args))
                except TypeError:
                    ops = (0, 0)
                d.setdefault(ops, []).append((o, n))
            newseq = []
            for k in sorted(d.keys(), reverse=True):
                newseq.extend(sorted([v[0] for v in d[k]], key=default_sort_key))
            sequence = [(k, sequence[k]) for k in newseq]
            del newseq, d
        else:
            sequence = sorted([(k, v) for k, v in sequence.items()], key=default_sort_key)
    if kwargs.pop('simultaneous', False):
        reps = {}
        rv = self
        kwargs['hack2'] = True
        m = Dummy()
        for old, new in sequence:
            d = Dummy(commutative=new.is_commutative)
            rv = rv._subs(old, d * m, **kwargs)
            if not isinstance(rv, Basic):
                break
            reps[d] = new
        reps[m] = S.One
        return rv.xreplace(reps)
    else:
        rv = self
        for old, new in sequence:
            rv = rv._subs(old, new, **kwargs)
            if not isinstance(rv, Basic):
                break
        return rv

.sympy.core.basic._aresame

def _aresame(a, b):
    from .function import AppliedUndef, UndefinedFunction as UndefFunc
    for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):
        if i != j or type(i) != type(j):
            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):
                if i.class_key() != j.class_key():
                    return False
            else:
                return False
    else:
        return True

.sympy.core.symbol.Symbol.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)

.sympy.printing.str.StrPrinter._print_Symbol

def _print_Symbol(self, expr):
    return expr.name

.sympy.core.basic.Basic._subs

def _subs(self, old, new, **hints):

    def fallback(self, old, new):
        hit = False
        args = list(self.args)
        for i, arg in enumerate(args):
            if not hasattr(arg, '_eval_subs'):
                continue
            arg = arg._subs(old, new, **hints)
            if not _aresame(arg, args[i]):
                hit = True
                args[i] = arg
        if hit:
            rv = self.func(*args)
            hack2 = hints.get('hack2', False)
            if hack2 and self.is_Mul and (not rv.is_Mul):
                coeff = S.One
                nonnumber = []
                for i in args:
                    if i.is_Number:
                        coeff *= i
                    else:
                        nonnumber.append(i)
                nonnumber = self.func(*nonnumber)
                if coeff is S.One:
                    return nonnumber
                else:
                    return self.func(coeff, nonnumber, evaluate=False)
            return rv
        return self
    if _aresame(self, old):
        return new
    rv = self._eval_subs(old, new)
    if rv is None:
        rv = fallback(self, old, new)
    return rv

.sympy.core.function.Application._eval_subs

def _eval_subs(self, old, new):
    if old.is_Function and new.is_Function and callable(old) and callable(new) and (old == self.func) and (len(self.args) in new.nargs):
        return new(*self.args)

.sympy.core.basic.Basic.fallback

def fallback(self, old, new):
    hit = False
    args = list(self.args)
    for i, arg in enumerate(args):
        if not hasattr(arg, '_eval_subs'):
            continue
        arg = arg._subs(old, new, **hints)
        if not _aresame(arg, args[i]):
            hit = True
            args[i] = arg
    if hit:
        rv = self.func(*args)
        hack2 = hints.get('hack2', False)
        if hack2 and self.is_Mul and (not rv.is_Mul):
            coeff = S.One
            nonnumber = []
            for i in args:
                if i.is_Number:
                    coeff *= i
                else:
                    nonnumber.append(i)
            nonnumber = self.func(*nonnumber)
            if coeff is S.One:
                return nonnumber
            else:
                return self.func(coeff, nonnumber, evaluate=False)
        return rv
    return self

.sympy.core.mul.Mul._eval_is_imaginary

def _eval_is_imaginary(self):
    z = self.is_zero
    if z:
        return False
    elif z is False:
        return self._eval_real_imag(False)

.sympy.core.basic.Basic._has_matcher

def _has_matcher(self):
    return lambda other: self == other

.sympy.core.numbers.Number.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    if rational and (not self.is_Rational):
        return (S.One, self)
    return (self, S.One) if self else (S.One, self)

.sympy.printing.str.StrPrinter._print_Float

def _print_Float(self, expr):
    prec = expr._prec
    if prec < 5:
        dps = 0
    else:
        dps = prec_to_dps(expr._prec)
    if self._settings['full_prec'] is True:
        strip = False
    elif self._settings['full_prec'] is False:
        strip = True
    elif self._settings['full_prec'] == 'auto':
        strip = self._print_level > 1
    rv = mlib.to_str(expr._mpf_, dps, strip_zeros=strip)
    if rv.startswith('-.0'):
        rv = '-0.' + rv[3:]
    elif rv.startswith('.0'):
        rv = '0.' + rv[2:]
    if rv.startswith('+'):
        rv = rv[1:]
    return rv

.sympy.printing.precedence.precedence_Float

def precedence_Float(item):
    if item < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Atom']

.sympy.core.numbers.Float.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.numbers.Float._eval_is_positive

def _eval_is_positive(self):
    if self._mpf_ == _mpf_inf:
        return True
    if self._mpf_ == _mpf_ninf:
        return False
    return self.num > 0

.sympy.core.numbers.Float.__neg__

def __neg__(self):
    return Float._new(mlib.mpf_neg(self._mpf_), self._prec)


[/PYTHON]
What will be the output of `get_integer_part`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "expr": "5*sqrt(42949673)",
        "no": 1,
        "options": {}
    },
    "kwargs": {
        "return_ints": true
    }
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[THOUGHT]
