You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
from sympy.core import S, Rational, Pow, Basic, Mul
from sympy.core.mul import _keep_coeff
from .printer import Printer
from sympy.printing.precedence import precedence, PRECEDENCE
import mpmath.libmp as mlib
from mpmath.libmp import prec_to_dps
from sympy.utilities import default_sort_key
from sympy.combinatorics.permutations import Permutation, Cycle
from sympy.polys.polyerrors import PolynomialError
from sympy.matrices import Matrix
from sympy.core.sympify import SympifyError

def sstr(expr, **settings):
    p = StrPrinter(settings)
    s = p.doprint(expr)
    return s
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.printing.printer.Printer.__init__

def __init__(self, settings=None):
    self._str = str
    self._settings = self._default_settings.copy()
    for key, val in self._global_settings.items():
        if key in self._default_settings:
            self._settings[key] = val
    if settings is not None:
        self._settings.update(settings)
        if len(self._settings) > len(self._default_settings):
            for key in self._settings:
                if key not in self._default_settings:
                    raise TypeError("Unknown setting '%s'." % key)
    self._print_level = 0

.sympy.printing.printer.Printer.doprint

def doprint(self, expr):
    return self._str(self._print(expr))

.sympy.printing.printer.Printer._print

def _print(self, expr, *args, **kwargs):
    self._print_level += 1
    try:
        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):
            return getattr(expr, self.printmethod)(self, *args, **kwargs)
        for cls in type(expr).__mro__:
            printmethod = '_print_' + cls.__name__
            if hasattr(self, printmethod):
                return getattr(self, printmethod)(expr, *args, **kwargs)
        return self.emptyPrinter(expr)
    finally:
        self._print_level -= 1

.sympy.printing.str.StrPrinter._print_Symbol

def _print_Symbol(self, expr):
    return expr.name

.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.printing.str.StrPrinter._print_Function

def _print_Function(self, expr):
    return expr.func.__name__ + '(%s)' % self.stringify(expr.args, ', ')

.sympy.core.function.Application.func

def func(self):
    return self.__class__

.sympy.printing.str.StrPrinter.stringify

def stringify(self, args, sep, level=0):
    return sep.join([self.parenthesize(item, level) for item in args])

.sympy.printing.str.StrPrinter.parenthesize

def parenthesize(self, item, level, strict=False):
    if precedence(item) < level or (not strict and precedence(item) <= level):
        return '(%s)' % self._print(item)
    else:
        return self._print(item)

.sympy.printing.precedence.precedence

def precedence(item):
    if hasattr(item, 'precedence'):
        return item.precedence
    try:
        mro = item.__class__.__mro__
    except AttributeError:
        return PRECEDENCE['Atom']
    for i in mro:
        n = i.__name__
        if n in PRECEDENCE_FUNCTIONS:
            return PRECEDENCE_FUNCTIONS[n](item)
        elif n in PRECEDENCE_VALUES:
            return PRECEDENCE_VALUES[n]
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Rational

def _print_Rational(self, expr):
    if expr.q == 1:
        return str(expr.p)
    else:
        if self._settings.get('sympy_integers', False):
            return 'S(%s)/%s' % (expr.p, expr.q)
        return '%s/%s' % (expr.p, expr.q)

.sympy.printing.str.StrPrinter._print_Dummy

def _print_Dummy(self, expr):
    return '_' + expr.name

.sympy.printing.str.StrPrinter._print_Catalan

def _print_Catalan(self, expr):
    return 'Catalan'

.sympy.printing.str.StrPrinter._print_ComplexInfinity

def _print_ComplexInfinity(self, expr):
    return 'zoo'

.sympy.printing.str.StrPrinter._print_Derivative

def _print_Derivative(self, expr):
    dexpr = expr.expr
    dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
    return 'Derivative(%s)' % ', '.join(map(self._print, [dexpr] + dvars))

.sympy.core.function.Derivative.expr

def expr(self):
    return self._args[0]

.sympy.core.function.Derivative.variable_count

def variable_count(self):
    return self._args[1:]

.sympy.core.containers.Tuple.__getitem__

def __getitem__(self, i):
    if isinstance(i, slice):
        indices = i.indices(len(self))
        return Tuple(*(self.args[j] for j in range(*indices)))
    return self.args[i]

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, integer_types):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.printing.str.StrPrinter._print_Pow

def _print_Pow(self, expr, rational=False):
    PREC = precedence(expr)
    if expr.exp is S.Half and (not rational):
        return 'sqrt(%s)' % self._print(expr.base)
    if expr.is_commutative:
        if -expr.exp is S.Half and (not rational):
            return '%s/sqrt(%s)' % tuple(map(self._print, (S.One, expr.base)))
        if expr.exp is -S.One:
            return '%s/%s' % (self._print(S.One), self.parenthesize(expr.base, PREC, strict=False))
    e = self.parenthesize(expr.exp, PREC, strict=False)
    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and (expr.exp.q != 1):
        if e.startswith('(Rational'):
            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.core.numbers.Integer.__neg__

def __neg__(self):
    return Integer(-self.p)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, string_types):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Integer can only work with integer expressions.')
    try:
        return _intcache[ival]
    except KeyError:
        obj = Expr.__new__(cls)
        obj.p = ival
        _intcache[ival] = obj
        return obj

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.printing.precedence.precedence_Integer

def precedence_Integer(item):
    if item.p < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Integer

def _print_Integer(self, expr):
    if self._settings.get('sympy_integers', False):
        return 'S(%s)' % expr
    return str(expr.p)

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.printing.str.StrPrinter._print_EulerGamma

def _print_EulerGamma(self, expr):
    return 'EulerGamma'

.sympy.printing.str.StrPrinter._print_Exp1

def _print_Exp1(self, expr):
    return 'E'

.sympy.printing.str.StrPrinter._print_WildFunction

def _print_WildFunction(self, expr):
    return expr.name + '_'

.sympy.printing.str.StrPrinter._print_tuple

def _print_tuple(self, expr):
    if len(expr) == 1:
        return '(%s,)' % self._print(expr[0])
    else:
        return '(%s)' % self.stringify(expr, ', ')

.sympy.printing.str.StrPrinter._print_Zero

def _print_Zero(self, expr):
    if self._settings.get('sympy_integers', False):
        return 'S(0)'
    return '0'

.sympy.printing.str.StrPrinter._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    return 'GoldenRatio'

.sympy.printing.str.StrPrinter._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return 'I'

.sympy.printing.str.StrPrinter._print_Infinity

def _print_Infinity(self, expr):
    return 'oo'

.sympy.printing.str.StrPrinter._print_Integral

def _print_Integral(self, expr):

    def _xab_tostr(xab):
        if len(xab) == 1:
            return self._print(xab[0])
        else:
            return self._print((xab[0],) + tuple(xab[1:]))
    L = ', '.join([_xab_tostr(l) for l in expr.limits])
    return 'Integral(%s, %s)' % (self._print(expr.function), L)

.sympy.concrete.expr_with_limits.ExprWithLimits.limits

def limits(self):
    return self._args[1:]

.sympy.printing.str.StrPrinter._xab_tostr

def _xab_tostr(xab):
    if len(xab) == 1:
        return self._print(xab[0])
    else:
        return self._print((xab[0],) + tuple(xab[1:]))

.sympy.core.containers.Tuple.__len__

def __len__(self):
    return len(self.args)

.sympy.concrete.expr_with_limits.ExprWithLimits.function

def function(self):
    return self._args[0]

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    if evaluate is None:
        if global_evaluate[0] is False:
            evaluate = global_evaluate[0]
        else:
            evaluate = True
    try:
        if a in sympy_classes:
            return a
    except TypeError:
        pass
    try:
        cls = a.__class__
    except AttributeError:
        cls = type(a)
    if cls in sympy_classes:
        return a
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a)
    try:
        return converter[cls](a)
    except KeyError:
        for superclass in getmro(cls):
            try:
                return converter[superclass](a)
            except KeyError:
                continue
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    try:
        return a._sympy_()
    except AttributeError:
        pass
    if not strict:
        try:
            from ..tensor.array import Array
            return Array(a.flat, a.shape)
        except AttributeError:
            pass
    if not isinstance(a, string_types):
        for coerce in (float, int):
            try:
                return sympify(coerce(a))
            except (TypeError, ValueError, AttributeError, SympifyError):
                continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
        from .compatibility import unicode
        a = unicode(a)
    except Exception as exc:
        raise SympifyError(a, exc)
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.printing.str.StrPrinter._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-oo'

.sympy.printing.str.StrPrinter._print_AccumulationBounds

def _print_AccumulationBounds(self, i):
    return 'AccumBounds(%s, %s)' % (self._print(i.min), self._print(i.max))

.sympy.calculus.util.AccumulationBounds.min

def min(self):
    return self.args[0]

.sympy.calculus.util.AccumulationBounds.max

def max(self):
    return self.args[1]

.sympy.core.numbers.NegativeOne.__neg__

def __neg__():
    return S.One

.sympy.printing.str.StrPrinter._print_list

def _print_list(self, expr):
    return '[%s]' % self.stringify(expr, ', ')

.sympy.matrices.matrices.MatrixBase.__getattr__

def __getattr__(self, attr):
    if attr in ('diff', 'integrate', 'limit'):

        def doit(*args):
            item_doit = lambda item: getattr(item, attr)(*args)
            return self.applyfunc(item_doit)
        return doit
    else:
        raise AttributeError('%s has no attribute %s.' % (self.__class__.__name__, attr))

.sympy.printing.str.StrPrinter._print_MatrixBase

def _print_MatrixBase(self, expr):
    return expr._format_str(self)

.sympy.matrices.matrices.MatrixBase._format_str

def _format_str(self, printer=None):
    if not printer:
        from sympy.printing.str import StrPrinter
        printer = StrPrinter()
    if self.rows == 0 or self.cols == 0:
        return 'Matrix(%s, %s, [])' % (self.rows, self.cols)
    if self.rows == 1:
        return 'Matrix([%s])' % self.table(printer, rowsep=',\n')
    return 'Matrix([\n%s])' % self.table(printer, rowsep=',\n')

.sympy.matrices.matrices.MatrixBase.table

def table(self, printer, rowstart='[', rowend=']', rowsep='\n', colsep=', ', align='right'):
    if self.rows == 0 or self.cols == 0:
        return '[]'
    res = []
    maxlen = [0] * self.cols
    for i in range(self.rows):
        res.append([])
        for j in range(self.cols):
            s = printer._print(self[i, j])
            res[-1].append(s)
            maxlen[j] = max(len(s), maxlen[j])
    align = {'left': 'ljust', 'right': 'rjust', 'center': 'center', '<': 'ljust', '>': 'rjust', '^': 'center'}[align]
    for i, row in enumerate(res):
        for j, elem in enumerate(row):
            row[j] = getattr(elem, align)(maxlen[j])
        res[i] = rowstart + colsep.join(row) + rowend
    return rowsep.join(res)

.sympy.matrices.dense.DenseMatrix.__getitem__

def __getitem__(self, key):
    if isinstance(key, tuple):
        i, j = key
        try:
            i, j = self.key2ij(key)
            return self._mat[i * self.cols + j]
        except (TypeError, IndexError):
            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):
                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):
                    raise ValueError('index out of boundary')
                from sympy.matrices.expressions.matexpr import MatrixElement
                return MatrixElement(self, i, j)
            if isinstance(i, slice):
                i = list(range(self.rows))[i]
            elif is_sequence(i):
                pass
            else:
                i = [i]
            if isinstance(j, slice):
                j = list(range(self.cols))[j]
            elif is_sequence(j):
                pass
            else:
                j = [j]
            return self.extract(i, j)
    else:
        if isinstance(key, slice):
            return self._mat[key]
        return self._mat[a2idx(key)]

.sympy.matrices.matrices.MatrixBase.key2ij

def key2ij(self, key):
    if is_sequence(key):
        if not len(key) == 2:
            raise TypeError('key must be a sequence of length 2')
        return [a2idx(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)]
    elif isinstance(key, slice):
        return key.indices(len(self))[:2]
    else:
        return divmod(a2idx(key, len(self)), self.cols)

.sympy.core.compatibility.is_sequence

def is_sequence(i, include=None):
    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))

.sympy.core.compatibility.iterable

def iterable(i, exclude=(string_types, dict, NotIterable)):
    if hasattr(i, '_iterable'):
        return i._iterable
    try:
        iter(i)
    except TypeError:
        return False
    if exclude:
        return not isinstance(i, exclude)
    return True

.sympy.matrices.common.MatrixShaping.shape

def shape(self):
    return (self.rows, self.cols)

.sympy.matrices.matrices.a2idx

def a2idx(j, n=None):
    if type(j) is not int:
        try:
            j = j.__index__()
        except AttributeError:
            raise IndexError('Invalid index a[%r]' % (j,))
    if n is not None:
        if j < 0:
            j += n
        if not (j >= 0 and j < n):
            raise IndexError('Index out of range: a[%s]' % j)
    return int(j)

.sympy.printing.str.StrPrinter._print_Mul

def _print_Mul(self, expr):
    prec = precedence(expr)
    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = '-'
    else:
        sign = ''
    a = []
    b = []
    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        args = Mul.make_args(expr)
    for item in args:
        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                b.append(Pow(item.base, -item.exp))
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append(Rational(item.p))
            if item.q != 1:
                b.append(Rational(item.q))
        else:
            a.append(item)
    a = a or [S.One]
    a_str = [self.parenthesize(x, prec, strict=False) for x in a]
    b_str = [self.parenthesize(x, prec, strict=False) for x in b]
    if len(b) == 0:
        return sign + '*'.join(a_str)
    elif len(b) == 1:
        return sign + '*'.join(a_str) + '/' + b_str[0]
    else:
        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)

.sympy.printing.precedence.precedence_Mul

def precedence_Mul(item):
    if _coeff_isneg(item):
        return PRECEDENCE['Add']
    return PRECEDENCE['Mul']

.sympy.core.function._coeff_isneg

def _coeff_isneg(a):
    if a.is_Mul:
        a = a.args[0]
    return a.is_Number and a.is_negative

.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.core.numbers.Integer.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if other.is_Integer:
        return _sympify(self.p < other.p)
    return Rational.__lt__(self, other)

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.logic.boolalg.BooleanFalse.__nonzero__

def __nonzero__(self):
    return False

.sympy.printing.printer.Printer.order

def order(self):
    if 'order' in self._settings:
        return self._settings['order']
    else:
        raise AttributeError('No order defined.')

.sympy.core.mul.Mul.as_ordered_factors

def as_ordered_factors(self, order=None):
    cpart, ncpart = self.args_cnc()
    cpart.sort(key=lambda expr: expr.sort_key(order=order))
    return cpart + ncpart

.sympy.core.expr.Expr.args_cnc

def args_cnc(self, cset=False, warn=True, split_1=True):
    if self.is_Mul:
        args = list(self.args)
    else:
        args = [self]
    for i, mi in enumerate(args):
        if not mi.is_commutative:
            c = args[:i]
            nc = args[i:]
            break
    else:
        c = args
        nc = []
    if c and split_1 and (c[0].is_Number and c[0].is_negative and (c[0] is not S.NegativeOne)):
        c[:1] = [S.NegativeOne, -c[0]]
    if cset:
        clen = len(c)
        c = set(c)
        if clen and warn and (len(c) != clen):
            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])
    return [c, nc]

.sympy.core.numbers.Number.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (0, ()), (), self)

.sympy.core.numbers.Number.class_key

def class_key(cls):
    return (1, 0, 'Number')

.sympy.core.expr.Expr.sort_key

def sort_key(self, order=None):
    coeff, expr = self.as_coeff_Mul()
    if expr.is_Pow:
        expr, exp = expr.args
    else:
        expr, exp = (expr, S.One)
    if expr.is_Dummy:
        args = (expr.sort_key(),)
    elif expr.is_Atom:
        args = (str(expr),)
    else:
        if expr.is_Add:
            args = expr.as_ordered_terms(order=order)
        elif expr.is_Mul:
            args = expr.as_ordered_factors(order=order)
        else:
            args = expr.args
        args = tuple([default_sort_key(arg, order=order) for arg in args])
    args = (len(args), tuple(args))
    exp = exp.sort_key(order=order)
    return (expr.class_key(), args, exp, coeff)

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (S.One, self)

.sympy.core.basic.Basic.class_key

def class_key(cls):
    return (5, 0, cls.__name__)

.sympy.core.numbers.Rational.__new__

def __new__(cls, p, q=None, gcd=None):
    if q is None:
        if isinstance(p, Rational):
            return p
        if isinstance(p, string_types):
            if p.count('/') > 1:
                raise TypeError('invalid input: %s' % p)
            pq = p.rsplit('/', 1)
            if len(pq) == 2:
                p, q = pq
                fp = fractions.Fraction(p)
                fq = fractions.Fraction(q)
                f = fp / fq
                return Rational(f.numerator, f.denominator, 1)
            p = p.replace(' ', '')
            try:
                p = fractions.Fraction(p)
            except ValueError:
                pass
        if not isinstance(p, string_types):
            try:
                if isinstance(p, fractions.Fraction):
                    return Rational(p.numerator, p.denominator, 1)
            except NameError:
                pass
            if isinstance(p, (float, Float)):
                return Rational(*_as_integer_ratio(p))
        if not isinstance(p, SYMPY_INTS + (Rational,)):
            raise TypeError('invalid input: %s' % p)
        q = q or S.One
        gcd = 1
    else:
        p = Rational(p)
        q = Rational(q)
    if isinstance(q, Rational):
        p *= q.q
        q = q.p
    if isinstance(p, Rational):
        q *= p.q
        p = p.p
    if q == 0:
        if p == 0:
            if _errdict['divide']:
                raise ValueError('Indeterminate 0/0')
            else:
                return S.NaN
        return S.ComplexInfinity
    if q < 0:
        q = -q
        p = -p
    if not gcd:
        gcd = igcd(abs(p), q)
    if gcd > 1:
        p //= gcd
        q //= gcd
    if q == 1:
        return Integer(p)
    if p == 1 and q == 2:
        return S.Half
    obj = Expr.__new__(cls)
    obj.p = p
    obj.q = q
    return obj

.sympy.printing.str.StrPrinter._print_Basic

def _print_Basic(self, expr):
    l = [self._print(o) for o in expr.args]
    return expr.__class__.__name__ + '(%s)' % ', '.join(l)

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    assumptions._tell(fact, None)
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.numbers.Float._eval_is_negative

def _eval_is_negative(self):
    if self._mpf_ == _mpf_ninf:
        return True
    if self._mpf_ == _mpf_inf:
        return False
    return self.num < 0

.sympy.core.numbers.Float.num

def num(self):
    return mpmath.mpf(self._mpf_)

.sympy.core.numbers.Float.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if other.is_NumberSymbol:
        return other.__gt__(self)
    if other.is_Rational and (not other.is_Integer):
        self *= other.q
        other = _sympify(other.p)
    elif other.is_comparable:
        other = other.evalf()
    if other.is_Number and other is not S.NaN:
        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))
    return Expr.__lt__(self, other)

.sympy.core.basic.Basic.is_comparable

def is_comparable(self):
    is_real = self.is_real
    if is_real is False:
        return False
    if not self.is_number:
        return False
    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]
    if not (i.is_Number and n.is_Number):
        return False
    if i:
        return False
    else:
        return n._prec != 1

.sympy.core.expr.Expr.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import im, re
    if hints.get('ignore') == self:
        return None
    else:
        return (re(self), im(self))

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Number:
        if other.is_Rational:
            return self.p == other.p and self.q == other.q
        if other.is_Float:
            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
    return False

.sympy.core.sympify.SympifyError.__init__

def __init__(self, expr, base_exc=None):
    self.expr = expr
    self.base_exc = base_exc

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_evaluate[0])
    result = super(Function, cls).__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(mlib.libmpf.prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return EmptySet()
    else:
        args = list(map(sympify, args))
    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._elements = frozenset(args)
    return obj

.sympy.core.compatibility.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                from sympy.utilities.iterables import uniq
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        for v in d[k]:
            yield v
        d.pop(k)

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super(Infinity, self).__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super(Number, self).__hash__()

.sympy.core.basic.Basic.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    symb = sympify(self.contains(other))
    if not (symb is S.true or symb is S.false):
        raise TypeError('contains did not evaluate to a bool: %r' % symb)
    return bool(symb)

.sympy.sets.sets.Set.contains

def contains(self, other):
    other = sympify(other, strict=True)
    ret = sympify(self._contains(other))
    if ret is None:
        ret = Contains(other, self, evaluate=False)
    return ret

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    r = false
    for e in self._elements:
        t = Eq(e, other, evaluate=True)
        if t is true:
            return t
        elif t is not false:
            r = None
    return r

.sympy.core.relational.Equality.__new__

def __new__(cls, lhs, rhs=0, **options):
    from sympy.core.add import Add
    from sympy.core.logic import fuzzy_bool
    from sympy.core.expr import _n2
    from sympy.simplify.simplify import clear_coefficients
    lhs = _sympify(lhs)
    rhs = _sympify(rhs)
    evaluate = options.pop('evaluate', global_evaluate[0])
    if evaluate:
        if hasattr(lhs, '_eval_Eq'):
            r = lhs._eval_Eq(rhs)
            if r is not None:
                return r
        if hasattr(rhs, '_eval_Eq'):
            r = rhs._eval_Eq(lhs)
            if r is not None:
                return r
        if lhs == rhs:
            return S.true
        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):
            return S.false
        elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):
            return S.false
        fin = L, R = [i.is_finite for i in (lhs, rhs)]
        if None not in fin:
            if L != R:
                return S.false
            if L is False:
                if lhs == -rhs:
                    return S.false
                return S.true
        elif None in fin and False in fin:
            return Relational.__new__(cls, lhs, rhs, **options)
        if all((isinstance(i, Expr) for i in (lhs, rhs))):
            dif = lhs - rhs
            z = dif.is_zero
            if z is not None:
                if z is False and dif.is_commutative:
                    return S.false
                if z:
                    return S.true
            n2 = _n2(lhs, rhs)
            if n2 is not None:
                return _sympify(n2 == 0)
            n, d = dif.as_numer_denom()
            rv = None
            if n.is_zero:
                rv = d.is_nonzero
            elif n.is_finite:
                if d.is_infinite:
                    rv = S.true
                elif n.is_zero is False:
                    rv = d.is_infinite
                    if rv is None:
                        l, r = clear_coefficients(d, S.Infinity)
                        args = [_.subs(l, r) for _ in (lhs, rhs)]
                        if args != [lhs, rhs]:
                            rv = fuzzy_bool(Eq(*args))
                            if rv is True:
                                rv = None
            elif any((a.is_infinite for a in Add.make_args(n))):
                rv = S.false
            if rv is not None:
                return _sympify(rv)
    return Relational.__new__(cls, lhs, rhs, **options)

.sympy.logic.boolalg.BooleanTrue.__hash__

def __hash__(self):
    return hash(True)

.sympy.logic.boolalg.BooleanTrue.__nonzero__

def __nonzero__(self):
    return True

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_evaluate[0])
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super(Application, cls).__new__(cls, *args, **options)
    try:
        if is_sequence(obj.nargs):
            nargs = tuple(ordered(set(obj.nargs)))
        elif obj.nargs is not None:
            nargs = (as_int(obj.nargs),)
        else:
            nargs = None
    except AttributeError:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.functions.elementary.complexes.re.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_real:
        return arg
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:
        return S.Zero
    elif arg.is_Matrix:
        return arg.as_real_imag()[0]
    elif arg.is_Function and isinstance(arg, conjugate):
        return re(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_real:
                    reverted.append(coeff)
            elif not term.has(S.ImaginaryUnit) and term.is_real:
                excluded.append(term)
            else:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[0])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) - im(b) + c

.sympy.functions.elementary.complexes.im.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_real:
        return S.Zero
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:
        return -S.ImaginaryUnit * arg
    elif arg.is_Matrix:
        return arg.as_real_imag()[1]
    elif arg.is_Function and isinstance(arg, conjugate):
        return -im(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_real:
                    reverted.append(coeff)
                else:
                    excluded.append(coeff)
            elif term.has(S.ImaginaryUnit) or not term.is_real:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[1])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) + re(b) + c

.sympy.core.numbers.Zero.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.evalf.EvalfMixin.evalf

def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
    from sympy import Float, Number
    n = n if n is not None else 15
    if subs and is_sequence(subs):
        raise TypeError('subs must be given as a dictionary')
    if n == 1 and isinstance(self, Number):
        from sympy.core.expr import _mag
        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
        m = _mag(rv)
        rv = rv.round(1 - m)
        return rv
    if not evalf_table:
        _create_evalf_table()
    prec = dps_to_prec(n)
    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}
    if subs is not None:
        options['subs'] = subs
    if quad is not None:
        options['quad'] = quad
    try:
        result = evalf(self, prec + 4, options)
    except NotImplementedError:
        v = self._eval_evalf(prec)
        if v is None:
            return self
        try:
            result = evalf(v, prec, options)
        except NotImplementedError:
            return v
    re, im, re_acc, im_acc = result
    if re:
        p = max(min(prec, re_acc), 1)
        re = Float._new(re, p)
    else:
        re = S.Zero
    if im:
        p = max(min(prec, im_acc), 1)
        im = Float._new(im, p)
        return re + im * S.ImaginaryUnit
    else:
        return re

.sympy.core.evalf.evalf

def evalf(x, prec, options):
    from sympy import re as re_, im as im_
    try:
        rf = evalf_table[x.func]
        r = rf(x, prec, options)
    except KeyError:
        try:
            if 'subs' in options:
                x = x.subs(evalf_subs(prec, options['subs']))
            xe = x._eval_evalf(prec)
            re, im = xe.as_real_imag()
            if re.has(re_) or im.has(im_):
                raise NotImplementedError
            if re == 0:
                re = None
                reprec = None
            elif re.is_number:
                re = re._to_mpmath(prec, allow_ints=False)._mpf_
                reprec = prec
            else:
                raise NotImplementedError
            if im == 0:
                im = None
                imprec = None
            elif im.is_number:
                im = im._to_mpmath(prec, allow_ints=False)._mpf_
                imprec = prec
            else:
                raise NotImplementedError
            r = (re, im, reprec, imprec)
        except AttributeError:
            raise NotImplementedError
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50))
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.numbers.Integer._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_int(self.p, prec, rnd)

.sympy.printing.precedence.precedence_Float

def precedence_Float(item):
    if item < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Float

def _print_Float(self, expr):
    prec = expr._prec
    if prec < 5:
        dps = 0
    else:
        dps = prec_to_dps(expr._prec)
    if self._settings['full_prec'] is True:
        strip = False
    elif self._settings['full_prec'] is False:
        strip = True
    elif self._settings['full_prec'] == 'auto':
        strip = self._print_level > 1
    rv = mlib.to_str(expr._mpf_, dps, strip_zeros=strip)
    if rv.startswith('-.0'):
        rv = '-0.' + rv[3:]
    elif rv.startswith('.0'):
        rv = '0.' + rv[2:]
    if rv.startswith('+'):
        rv = rv[1:]
    return rv

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, **kwargs):
    if kwargs.pop('reeval', True) and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super(AssocOp, cls).__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.printing.str.StrPrinter._print_NaN

def _print_NaN(self, expr):
    return 'nan'

.sympy.printing.str.StrPrinter._print_Order

def _print_Order(self, expr):
    if all((p is S.Zero for p in expr.point)) or not len(expr.variables):
        if len(expr.variables) <= 1:
            return 'O(%s)' % self._print(expr.expr)
        else:
            return 'O(%s)' % self.stringify((expr.expr,) + expr.variables, ', ', 0)
    else:
        return 'O(%s)' % self.stringify(expr.args, ', ', 0)

.sympy.series.order.Order.point

def point(self):
    if self.args[1:]:
        return tuple((x[1] for x in self.args[1:]))
    else:
        return ()

.sympy.series.order.Order.variables

def variables(self):
    if self.args[1:]:
        return tuple((x[0] for x in self.args[1:]))
    else:
        return ()

.sympy.series.order.Order.expr

def expr(self):
    return self.args[0]

.sympy.printing.str.StrPrinter._print_Tuple

def _print_Tuple(self, expr):
    return self._print_tuple(expr)

.sympy.printing.str.StrPrinter._print_Permutation

def _print_Permutation(self, expr):
    from sympy.combinatorics.permutations import Permutation, Cycle
    if Permutation.print_cyclic:
        if not expr.size:
            return '()'
        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]
        last = s.rfind('(')
        if not last == 0 and ',' not in s[last:]:
            s = s[last:] + s[:last]
        s = s.replace(',', '')
        return s
    else:
        s = expr.support()
        if not s:
            if expr.size < 5:
                return 'Permutation(%s)' % str(expr.array_form)
            return 'Permutation([], size=%s)' % expr.size
        trim = str(expr.array_form[:s[-1] + 1]) + ', size=%s' % expr.size
        use = full = str(expr.array_form)
        if len(trim) < len(full):
            use = trim
        return 'Permutation(%s)' % use

.sympy.combinatorics.permutations.Permutation.support

def support(self):
    a = self.array_form
    return [i for i, e in enumerate(a) if a[i] != i]

.sympy.combinatorics.permutations.Permutation.array_form

def array_form(self):
    return self._array_form[:]

.sympy.combinatorics.permutations.Permutation.size

def size(self):
    return self._size

.sympy.combinatorics.permutations.Cycle.__init__

def __init__(self, *args):
    if not args:
        return
    if len(args) == 1:
        if isinstance(args[0], Permutation):
            for c in args[0].cyclic_form:
                self.update(self(*c))
            return
        elif isinstance(args[0], Cycle):
            for k, v in args[0].items():
                self[k] = v
            return
    args = [as_int(a) for a in args]
    if any((i < 0 for i in args)):
        raise ValueError('negative integers are not allowed in a cycle.')
    if has_dups(args):
        raise ValueError('All elements must be unique in a cycle.')
    for i in range(-len(args), 0):
        self[args[i]] = args[i + 1]

.sympy.combinatorics.permutations.Permutation.cyclic_form

def cyclic_form(self):
    if self._cyclic_form is not None:
        return list(self._cyclic_form)
    array_form = self.array_form
    unchecked = [True] * len(array_form)
    cyclic_form = []
    for i in range(len(array_form)):
        if unchecked[i]:
            cycle = []
            cycle.append(i)
            unchecked[i] = False
            j = i
            while unchecked[array_form[j]]:
                j = array_form[j]
                cycle.append(j)
                unchecked[j] = False
            if len(cycle) > 1:
                cyclic_form.append(cycle)
                assert cycle == list(minlex(cycle, is_set=True))
    cyclic_form.sort()
    self._cyclic_form = cyclic_form[:]
    return cyclic_form

.sympy.combinatorics.permutations.Cycle.__call__

def __call__(self, *other):
    rv = Cycle(*other)
    for k, v in zip(list(self.keys()), [rv[self[k]] for k in self.keys()]):
        rv[k] = v
    return rv

.sympy.core.compatibility.as_int

def as_int(n):
    try:
        result = int(n)
        if result != n:
            raise TypeError
    except TypeError:
        raise ValueError('%s is not an integer' % (n,))
    return result

.sympy.utilities.iterables.has_dups

def has_dups(seq):
    from sympy.core.containers import Dict
    from sympy.sets.sets import Set
    if isinstance(seq, (dict, set, Dict, Set)):
        return False
    uniq = set()
    return any((True for s in seq if s in uniq or uniq.add(s)))

.sympy.combinatorics.permutations.Cycle.__repr__

def __repr__(self):
    if not self:
        return 'Cycle()'
    cycles = Permutation(self).cyclic_form
    s = ''.join((str(tuple(c)) for c in cycles))
    big = self.size - 1
    if not any((i == big for c in cycles for i in c)):
        s += '(%s)' % big
    return 'Cycle%s' % s

.sympy.combinatorics.permutations.Permutation.__new__

def __new__(cls, *args, **kwargs):
    size = kwargs.pop('size', None)
    if size is not None:
        size = int(size)
    ok = True
    if not args:
        return cls._af_new(list(range(size or 0)))
    elif len(args) > 1:
        return cls._af_new(Cycle(*args).list(size))
    if len(args) == 1:
        a = args[0]
        if isinstance(a, cls):
            if size is None or size == a.size:
                return a
            return cls(a.array_form, size=size)
        if isinstance(a, Cycle):
            return cls._af_new(a.list(size))
        if not is_sequence(a):
            return cls._af_new(list(range(a + 1)))
        if has_variety((is_sequence(ai) for ai in a)):
            ok = False
    else:
        ok = False
    if not ok:
        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')
    args = list(args[0])
    is_cycle = args and is_sequence(args[0])
    if is_cycle:
        args = [[int(i) for i in c] for c in args]
    else:
        args = [int(i) for i in args]
    temp = flatten(args)
    if has_dups(temp) and (not is_cycle):
        raise ValueError('there were repeated elements.')
    temp = set(temp)
    if not is_cycle and any((i not in temp for i in range(len(temp)))):
        raise ValueError('Integers 0 through %s must be present.' % max(temp))
    if is_cycle:
        c = Cycle()
        for ci in args:
            c = c(*ci)
        aform = c.list()
    else:
        aform = list(args)
    if size and size > len(aform):
        aform.extend(list(range(len(aform), size)))
    return cls._af_new(aform)

.sympy.combinatorics.permutations.Cycle.list

def list(self, size=None):
    if not self and size is None:
        raise ValueError('must give size for empty Cycle')
    if size is not None:
        big = max([i for i in self.keys() if self[i] != i] + [0])
        size = max(size, big + 1)
    else:
        size = self.size
    return [self[i] for i in range(size)]

.sympy.combinatorics.permutations.Cycle.size

def size(self):
    if not self:
        return 0
    return max(self.keys()) + 1

.sympy.combinatorics.permutations.Permutation._af_new

def _af_new(cls, perm):
    p = Basic.__new__(cls, perm)
    p._array_form = perm
    p._size = len(perm)
    return p

.sympy.combinatorics.permutations.Cycle.__missing__

def __missing__(self, arg):
    arg = as_int(arg)
    self[arg] = arg
    return arg

.sympy.utilities.iterables.minlex

def minlex(seq, directed=True, is_set=False, small=None):
    is_str = isinstance(seq, str)
    seq = list(seq)
    if small is None:
        small = min(seq, key=default_sort_key)
    if is_set:
        i = seq.index(small)
        if not directed:
            n = len(seq)
            p = (i + 1) % n
            m = (i - 1) % n
            if default_sort_key(seq[p]) > default_sort_key(seq[m]):
                seq = list(reversed(seq))
                i = n - i - 1
        if i:
            seq = rotate_left(seq, i)
        best = seq
    else:
        count = seq.count(small)
        if count == 1 and directed:
            best = rotate_left(seq, seq.index(small))
        else:
            best = seq
            for i in range(count):
                seq = rotate_left(seq, seq.index(small, count != 1))
                if seq < best:
                    best = seq
                if not directed:
                    seq = rotate_left(seq, 1)
                    seq = list(reversed(seq))
                    if seq < best:
                        best = seq
                    seq = list(reversed(seq))
                    seq = rotate_right(seq, 1)
    if is_str:
        return ''.join(best)
    return tuple(best)

.sympy.core.compatibility.default_sort_key

def default_sort_key(item, order=None):
    from .singleton import S
    from .basic import Basic
    from .sympify import sympify, SympifyError
    from .compatibility import iterable
    if isinstance(item, Basic):
        return item.sort_key(order=order)
    if iterable(item, exclude=string_types):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            args = list(item)
            unordered = False
        args = [default_sort_key(arg, order=order) for arg in args]
        if unordered:
            args = sorted(args)
        cls_index, args = (10, (len(args), tuple(args)))
    else:
        if not isinstance(item, string_types):
            try:
                item = sympify(item)
            except SympifyError:
                pass
            else:
                if isinstance(item, Basic):
                    return default_sort_key(item)
        cls_index, args = (0, (1, (str(item),)))
    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)

.sympy.printing.str.StrPrinter._print_Pi

def _print_Pi(self, expr):
    return 'pi'

.sympy.printing.str.StrPrinter._print_Poly

def _print_Poly(self, expr):
    ATOM_PREC = PRECEDENCE['Atom'] - 1
    terms, gens = ([], [self.parenthesize(s, ATOM_PREC) for s in expr.gens])
    for monom, coeff in expr.terms():
        s_monom = []
        for i, exp in enumerate(monom):
            if exp > 0:
                if exp == 1:
                    s_monom.append(gens[i])
                else:
                    s_monom.append(gens[i] + '**%d' % exp)
        s_monom = '*'.join(s_monom)
        if coeff.is_Add:
            if s_monom:
                s_coeff = '(' + self._print(coeff) + ')'
            else:
                s_coeff = self._print(coeff)
        else:
            if s_monom:
                if coeff is S.One:
                    terms.extend(['+', s_monom])
                    continue
                if coeff is S.NegativeOne:
                    terms.extend(['-', s_monom])
                    continue
            s_coeff = self._print(coeff)
        if not s_monom:
            s_term = s_coeff
        else:
            s_term = s_coeff + '*' + s_monom
        if s_term.startswith('-'):
            terms.extend(['-', s_term[1:]])
        else:
            terms.extend(['+', s_term])
    if terms[0] in ['-', '+']:
        modifier = terms.pop(0)
        if modifier == '-':
            terms[0] = '-' + terms[0]
    format = expr.__class__.__name__ + '(%s, %s'
    from sympy.polys.polyerrors import PolynomialError
    try:
        format += ', modulus=%s' % expr.get_modulus()
    except PolynomialError:
        format += ", domain='%s'" % expr.get_domain()
    format += ')'
    for index, item in enumerate(gens):
        if len(item) > 2 and (item[:1] == '(' and item[len(item) - 1:] == ')'):
            gens[index] = item[1:len(item) - 1]
    return format % (' '.join(terms), ', '.join(gens))

.sympy.polys.polytools.Poly.terms

def terms(f, order=None):
    return [(m, f.rep.dom.to_sympy(c)) for m, c in f.rep.terms(order=order)]

.sympy.polys.polyclasses.DMP.terms

def terms(f, order=None):
    return dmp_list_terms(f.rep, f.lev, f.dom, order=order)

.sympy.polys.densebasic.dmp_list_terms

def dmp_list_terms(f, u, K, order=None):

    def sort(terms, O):
        return sorted(terms, key=lambda term: O(term[0]), reverse=True)
    terms = _rec_list_terms(f, u, ())
    if not terms:
        return [((0,) * (u + 1), K.zero)]
    if order is None:
        return terms
    else:
        return sort(terms, monomial_key(order))

.sympy.polys.densebasic._rec_list_terms

def _rec_list_terms(g, v, monom):
    d, terms = (dmp_degree(g, v), [])
    if not v:
        for i, c in enumerate(g):
            if not c:
                continue
            terms.append((monom + (d - i,), c))
    else:
        w = v - 1
        for i, c in enumerate(g):
            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))
    return terms

.sympy.polys.densebasic.dmp_degree

def dmp_degree(f, u):
    if dmp_zero_p(f, u):
        return -oo
    else:
        return len(f) - 1

.sympy.polys.densebasic.dmp_zero_p

def dmp_zero_p(f, u):
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    return not f

.sympy.core.numbers.Infinity.__neg__

def __neg__(self):
    return S.NegativeInfinity

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.to_sympy

def to_sympy(self, a):
    return SymPyInteger(a)

.sympy.polys.polytools.Poly.get_modulus

def get_modulus(f):
    domain = f.get_domain()
    if domain.is_FiniteField:
        return Integer(domain.characteristic())
    else:
        raise PolynomialError('not a polynomial over a Galois field')

.sympy.polys.polytools.Poly.get_domain

def get_domain(f):
    return f.rep.dom

.sympy.polys.domains.domain.Domain.__str__

def __str__(self):
    return self.rep

.sympy.core.expr.Expr.__neg__

def __neg__(self):
    return Mul(S.NegativeOne, self)

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, **options):
    from sympy import Order
    args = list(map(_sympify, args))
    args = [a for a in args if a is not cls.identity]
    if not options.pop('evaluate', global_evaluate[0]):
        return cls._from_args(args)
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        return Order(obj, *order_symbols)
    return obj

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        assert not a is S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    rv = ([cls(a * r, b, evaluate=False)], [], None)
                elif global_distribute[0] and b.is_commutative:
                    r, b = b.as_coeff_Add()
                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
                    _addsort(bargs)
                    ar = a * r
                    if ar:
                        bargs.insert(0, ar)
                    bargs = [Add._from_args(bargs)]
                    rv = (bargs, [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number:
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            if coeff is S.ComplexInfinity:
                return ([S.ComplexInfinity], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
                elif b is S.ImaginaryUnit and e.is_Rational:
                    neg1e += e / 2
                    continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):
                    return ([S.NaN], [], None)
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff is S.Infinity or coeff is S.NegativeInfinity:

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_positive:
                    continue
                if t.is_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]
    elif coeff is S.Zero:
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.expr.Expr.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.numbers.Rational.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (self, S.One)

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            if i in Basic._constructor_postprocessor_mapping:
                for k, v in Basic._constructor_postprocessor_mapping[i].items():
                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
            else:
                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
                for k, v in chain.from_iterable(postprocessor_mappings):
                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:
        Basic._constructor_postprocessor_mapping[obj] = postprocessors
    return obj

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.__nonzero__

def __nonzero__(f):
    return f.ex != 0

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    from sympy import Pow
    if self is other:
        return True
    if type(self) is not type(other):
        try:
            other = _sympify(other)
        except SympifyError:
            return NotImplemented
        if type(self) != type(other):
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.polys.domains.expressiondomain.ExpressionDomain.to_sympy

def to_sympy(self, a):
    return a.as_expr()

.sympy.polys.domains.expressiondomain.ExpressionDomain.Expression.as_expr

def as_expr(f):
    return f.ex

.sympy.core.mul._keep_coeff

def _keep_coeff(coeff, factors, clear=True, sign=False):
    if not coeff.is_Number:
        if factors.is_Number:
            factors, coeff = (coeff, factors)
        else:
            return coeff * factors
    if coeff is S.One:
        return factors
    elif coeff is S.NegativeOne and (not sign):
        return -factors
    elif factors.is_Add:
        if not clear and coeff.is_Rational and (coeff.q != 1):
            q = S(coeff.q)
            for i in factors.args:
                c, t = i.as_coeff_Mul()
                r = c / q
                if r == int(r):
                    return coeff * factors
        return Mul._from_args((coeff, factors))
    elif factors.is_Mul:
        margs = list(factors.args)
        if margs[0].is_Number:
            margs[0] *= coeff
            if margs[0] == 1:
                margs.pop(0)
        else:
            margs.insert(0, coeff)
        return Mul._from_args(margs)
    else:
        return coeff * factors

.sympy.core.expr.Expr.as_ordered_factors

def as_ordered_factors(self, order=None):
    return [self]

.sympy.printing.str.StrPrinter._print_PolyRing

def _print_PolyRing(self, ring):
    return 'Polynomial ring in %s over %s with %s order' % (', '.join(map(self._print, ring.symbols)), ring.domain, ring.order)

.sympy.polys.orderings.MonomialOrder.__str__

def __str__(self):
    return self.alias

.sympy.printing.str.StrPrinter._print_FracField

def _print_FracField(self, field):
    return 'Rational function field in %s over %s with %s order' % (', '.join(map(self._print, field.symbols)), field.domain, field.order)

.sympy.printing.str.StrPrinter._print_PolyElement

def _print_PolyElement(self, poly):
    return poly.str(self, PRECEDENCE, '%s**%s', '*')

.sympy.polys.rings.PolyElement.str

def str(self, printer, precedence, exp_pattern, mul_symbol):
    if not self:
        return printer._print(self.ring.domain.zero)
    prec_add = precedence['Add']
    prec_mul = precedence['Mul']
    prec_atom = precedence['Atom']
    ring = self.ring
    symbols = ring.symbols
    ngens = ring.ngens
    zm = ring.zero_monom
    sexpvs = []
    for expv, coeff in self.terms():
        positive = ring.domain.is_positive(coeff)
        sign = ' + ' if positive else ' - '
        sexpvs.append(sign)
        if expv == zm:
            scoeff = printer._print(coeff)
            if scoeff.startswith('-'):
                scoeff = scoeff[1:]
        else:
            if not positive:
                coeff = -coeff
            if coeff != 1:
                scoeff = printer.parenthesize(coeff, prec_mul, strict=True)
            else:
                scoeff = ''
        sexpv = []
        for i in range(ngens):
            exp = expv[i]
            if not exp:
                continue
            symbol = printer.parenthesize(symbols[i], prec_atom, strict=True)
            if exp != 1:
                if exp != int(exp) or exp < 0:
                    sexp = printer.parenthesize(exp, prec_atom, strict=False)
                else:
                    sexp = exp
                sexpv.append(exp_pattern % (symbol, sexp))
            else:
                sexpv.append('%s' % symbol)
        if scoeff:
            sexpv = [scoeff] + sexpv
        sexpvs.append(mul_symbol.join(sexpv))
    if sexpvs[0] in [' + ', ' - ']:
        head = sexpvs.pop(0)
        if head == ' - ':
            sexpvs.insert(0, '-')
    return ''.join(sexpvs)

.sympy.polys.domains.polynomialring.PolynomialRing.zero

def zero(self):
    return self.ring.zero

.sympy.polys.rings.PolyRing.zero

def zero(self):
    return self.dtype()

.sympy.printing.str.StrPrinter._print_int

def _print_int(self, expr):
    return str(expr)

.sympy.polys.rings.PolyElement.terms

def terms(self, order=None):
    return self._sorted(list(self.items()), order)

.sympy.polys.rings.PolyElement._sorted

def _sorted(self, seq, order):
    if order is None:
        order = self.ring.order
    else:
        order = OrderOpt.preprocess(order)
    if order is lex:
        return sorted(seq, key=lambda monom: monom[0], reverse=True)
    else:
        return sorted(seq, key=lambda monom: order(monom[0]), reverse=True)

.sympy.polys.domains.polynomialring.PolynomialRing.is_positive

def is_positive(self, a):
    return self.domain.is_positive(a.LC)

.sympy.polys.rings.PolyElement.LC

def LC(self):
    return self._get_coeff(self.leading_expv())

.sympy.polys.rings.PolyElement.leading_expv

def leading_expv(self):
    if self:
        return self.ring.leading_expv(self)
    else:
        return None

.sympy.polys.rings.PolyElement._get_coeff

def _get_coeff(self, expv):
    return self.get(expv, self.ring.domain.zero)

.sympy.polys.domains.domain.Domain.is_positive

def is_positive(self, a):
    return a > 0

.sympy.polys.rings.PolyElement.__ne__

def __ne__(p1, p2):
    return not p1 == p2

.sympy.polys.rings.PolyElement.__eq__

def __eq__(p1, p2):
    if not p2:
        return not p1
    elif isinstance(p2, PolyElement) and p2.ring == p1.ring:
        return dict.__eq__(p1, p2)
    elif len(p1) > 1:
        return False
    else:
        return p1.get(p1.ring.zero_monom) == p2

.sympy.polys.domains.pythonrational.PythonRational.__eq__

def __eq__(self, other):
    if isinstance(other, PythonRational):
        return self.q == other.q and self.p == other.p
    elif isinstance(other, integer_types):
        return self.q == 1 and self.p == other
    else:
        return False

.sympy.polys.domains.pythonrational.PythonRational.__nonzero__

def __nonzero__(self):
    return self.p != 0

.sympy.polys.domains.pythonrational.PythonRational.__ne__

def __ne__(self, other):
    return not self == other

.sympy.polys.domains.pythonrational.PythonRational.__int__

def __int__(self):
    p, q = (self.p, self.q)
    if p < 0:
        return -(-p // q)
    return p // q

.sympy.printing.str.StrPrinter._print_PythonRational

def _print_PythonRational(self, expr):
    if expr.q == 1:
        return str(expr.p)
    else:
        return '%d/%d' % (expr.p, expr.q)

.sympy.printing.precedence.precedence_PolyElement

def precedence_PolyElement(item):
    if item.is_generator:
        return PRECEDENCE['Atom']
    elif item.is_ground:
        return precedence(item.coeff(1))
    elif item.is_term:
        return PRECEDENCE['Mul']
    else:
        return PRECEDENCE['Add']

.sympy.polys.rings.PolyElement.is_generator

def is_generator(self):
    return self in self.ring._gens_set

.sympy.polys.rings.PolyElement.__hash__

def __hash__(self):
    _hash = self._hash
    if _hash is None:
        self._hash = _hash = hash((self.ring, frozenset(self.items())))
    return _hash

.sympy.polys.rings.PolyRing.__hash__

def __hash__(self):
    return self._hash

.sympy.polys.rings.PolyElement.is_ground

def is_ground(self):
    return not self or (len(self) == 1 and self.ring.zero_monom in self)

.sympy.polys.rings.PolyElement.is_term

def is_term(self):
    return len(self) <= 1

.sympy.polys.rings.PolyElement.__neg__

def __neg__(self):
    return self.new([(monom, -coeff) for monom, coeff in self.iterterms()])

.sympy.polys.rings.PolyElement.iterterms

def iterterms(self):
    return iter(self.items())

.sympy.polys.rings.PolyElement.new

def new(self, init):
    return self.__class__(init)

.sympy.printing.str.StrPrinter._print_FracElement

def _print_FracElement(self, frac):
    if frac.denom == 1:
        return self._print(frac.numer)
    else:
        numer = self.parenthesize(frac.numer, PRECEDENCE['Mul'], strict=True)
        denom = self.parenthesize(frac.denom, PRECEDENCE['Atom'], strict=True)
        return numer + '/' + denom

.sympy.polys.fields.FracElement.__eq__

def __eq__(f, g):
    if isinstance(g, FracElement) and f.field == g.field:
        return f.numer == g.numer and f.denom == g.denom
    else:
        return f.numer == g and f.denom == f.field.ring.one

.sympy.polys.rings.PolyRing.one

def one(self):
    return self.dtype(self._one)

.sympy.polys.rings.PolyRing.__eq__

def __eq__(self, other):
    return isinstance(other, PolyRing) and (self.symbols, self.domain, self.ngens, self.order) == (other.symbols, other.domain, other.ngens, other.order)

.sympy.polys.domains.fractionfield.FractionField.zero

def zero(self):
    return self.field.zero

.sympy.polys.domains.fractionfield.FractionField.is_positive

def is_positive(self, a):
    return self.domain.is_positive(a.numer.LC)

.sympy.polys.fields.FracElement.__ne__

def __ne__(f, g):
    return not f == g

.sympy.polys.fields.FracElement.__hash__

def __hash__(self):
    _hash = self._hash
    if _hash is None:
        self._hash = _hash = hash((self.field, self.numer, self.denom))
    return _hash

.sympy.polys.fields.FracField.__hash__

def __hash__(self):
    return self._hash

.sympy.polys.fields.FracField.__eq__

def __eq__(self, other):
    return isinstance(other, FracField) and (self.symbols, self.ngens, self.domain, self.order) == (other.symbols, other.ngens, other.domain, other.order)

.sympy.polys.rings.PolyElement.coeff

def coeff(self, element):
    if element == 1:
        return self._get_coeff(self.ring.zero_monom)
    elif isinstance(element, self.ring.dtype):
        terms = list(element.iterterms())
        if len(terms) == 1:
            monom, coeff = terms[0]
            if coeff == self.ring.domain.one:
                return self._get_coeff(monom)
    raise ValueError('expected a monomial, got %s' % element)

.sympy.printing.precedence.precedence_FracElement

def precedence_FracElement(item):
    if item.denom == 1:
        return precedence_PolyElement(item.numer)
    else:
        return PRECEDENCE['Mul']

.sympy.polys.fields.FracElement.__neg__

def __neg__(f):
    return f.raw_new(-f.numer, f.denom)

.sympy.polys.fields.FracElement.raw_new

def raw_new(f, numer, denom):
    return f.__class__(numer, denom)

.sympy.polys.fields.FracElement.__init__

def __init__(self, numer, denom=None):
    if denom is None:
        denom = self.field.ring.one
    elif not denom:
        raise ZeroDivisionError('zero denominator')
    self.numer = numer
    self.denom = denom

.sympy.core.numbers.Rational.__neg__

def __neg__(self):
    return Rational(-self.p, self.q)

.sympy.core.numbers.igcd

def igcd(*args):
    if len(args) < 2:
        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))
    if 1 in args:
        a = 1
        k = 0
    else:
        a = abs(as_int(args[0]))
        k = 1
    if a != 1:
        while k < len(args):
            b = args[k]
            k += 1
            try:
                a = _gcdcache[a, b]
            except KeyError:
                b = as_int(b)
                if not b:
                    continue
                if b == 1:
                    a = 1
                    break
                if b < 0:
                    b = -b
                t = (a, b)
                a = igcd2(a, b)
                _gcdcache[t] = _gcdcache[t[1], t[0]] = a
    while k < len(args):
        ok = as_int(args[k])
        k += 1
    return a

.sympy.printing.precedence.precedence_Rational

def precedence_Rational(item):
    if item.p < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Mul']

.sympy.core.numbers.Float.__neg__

def __neg__(self):
    return Float._new(mlib.mpf_neg(self._mpf_), self._prec)

.sympy.core.numbers.Float._new

def _new(cls, _mpf_, _prec):
    if _mpf_ == _mpf_zero:
        return S.Zero
    elif _mpf_ == _mpf_nan:
        return S.NaN
    obj = Expr.__new__(cls)
    obj._mpf_ = mpf_norm(_mpf_, _prec)
    obj._prec = _prec
    return obj

.sympy.core.numbers.mpf_norm

def mpf_norm(mpf, prec):
    sign, man, expt, bc = mpf
    if not man:
        if not bc:
            return _mpf_zero
        else:
            return mpf
    from mpmath.libmp.backend import MPZ
    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
    return rv

.sympy.printing.str.StrPrinter._print_Relational

def _print_Relational(self, expr):
    charmap = {'==': 'Eq', '!=': 'Ne', ':=': 'Assignment', '+=': 'AddAugmentedAssignment', '-=': 'SubAugmentedAssignment', '*=': 'MulAugmentedAssignment', '/=': 'DivAugmentedAssignment', '%=': 'ModAugmentedAssignment'}
    if expr.rel_op in charmap:
        return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)
    return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)), self._relationals.get(expr.rel_op) or expr.rel_op, self.parenthesize(expr.rhs, precedence(expr)))

.sympy.core.relational.Relational.lhs

def lhs(self):
    return self._args[0]

.sympy.core.relational.Relational.rhs

def rhs(self):
    return self._args[1]

.sympy.printing.str.StrPrinter._print_GroebnerBasis

def _print_GroebnerBasis(self, basis):
    cls = basis.__class__.__name__
    exprs = [self._print_Add(arg, order=basis.order) for arg in basis.exprs]
    exprs = '[%s]' % ', '.join(exprs)
    gens = [self._print(gen) for gen in basis.gens]
    domain = "domain='%s'" % self._print(basis.domain)
    order = "order='%s'" % self._print(basis.order)
    args = [exprs] + gens + [domain, order]
    return '%s(%s)' % (cls, ', '.join(args))

.sympy.polys.polytools.GroebnerBasis.exprs

def exprs(self):
    return [poly.as_expr() for poly in self._basis]

.sympy.polys.polytools.GroebnerBasis.gens

def gens(self):
    return self._options.gens

.sympy.polys.polyoptions.OptionType.getter

def getter(self):
    try:
        return self[cls.option]
    except KeyError:
        return cls.default()

.sympy.polys.polytools.GroebnerBasis.domain

def domain(self):
    return self._options.domain

.sympy.printing.str.StrPrinter.emptyPrinter

def emptyPrinter(self, expr):
    if isinstance(expr, str):
        return expr
    elif isinstance(expr, Basic):
        if hasattr(expr, 'args'):
            return repr(expr)
        else:
            raise
    else:
        return str(expr)

.sympy.polys.polytools.GroebnerBasis.order

def order(self):
    return self._options.order

.sympy.polys.polyoptions.Order.default

def default(cls):
    return sympy.polys.orderings.lex

.sympy.printing.str.StrPrinter._print_set

def _print_set(self, s):
    items = sorted(s, key=default_sort_key)
    args = ', '.join((self._print(item) for item in items))
    if not args:
        return 'set()'
    return '{%s}' % args

.sympy.printing.str.StrPrinter._print_frozenset

def _print_frozenset(self, s):
    if not s:
        return 'frozenset()'
    return 'frozenset(%s)' % self._print_set(s)

.sympy.core.numbers.Integer.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s > %s' % (self, other))
    if other.is_Integer:
        return _sympify(self.p > other.p)
    return Rational.__gt__(self, other)

.sympy.printing.str.StrPrinter._print_Quaternion

def _print_Quaternion(self, expr):
    s = [self.parenthesize(i, PRECEDENCE['Mul'], strict=True) for i in expr.args]
    a = [s[0]] + [i + '*' + j for i, j in zip(s[1:], 'ijk')]
    return ' + '.join(a)

.sympy.printing.str.StrPrinter._print_Wild

def _print_Wild(self, expr):
    return expr.name + '_'

.sympy.printing.str.StrPrinter._print_str

def _print_str(self, expr):
    return expr

.sympy.printing.str.StrPrinter._print_FiniteSet

def _print_FiniteSet(self, s):
    s = sorted(s, key=default_sort_key)
    if len(s) > 10:
        printset = s[:3] + ['...'] + s[-3:]
    else:
        printset = s
    return '{' + ', '.join((self._print(el) for el in printset)) + '}'

.sympy.sets.sets.FiniteSet.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.sets.sets.FiniteSet.__len__

def __len__(self):
    return len(self.args)

.sympy.polys.domains.pythonrational.PythonRational.__hash__

def __hash__(self):
    if self.q == 1:
        return hash(self.p)
    else:
        return hash((self.p, self.q))

.sympy.polys.domains.pythonrational.PythonRational.__gt__

def __gt__(self, other):
    return self._cmp(other, operator.gt)

.sympy.polys.domains.pythonrational.PythonRational._cmp

def _cmp(self, other, op):
    try:
        diff = self - other
    except TypeError:
        return NotImplemented
    else:
        return op(diff.p, 0)

.sympy.polys.domains.pythonrational.PythonRational.__sub__

def __sub__(self, other):
    from sympy.polys.domains.groundtypes import python_gcd as gcd
    if isinstance(other, PythonRational):
        ap, aq, bp, bq = (self.p, self.q, other.p, other.q)
        g = gcd(aq, bq)
        if g == 1:
            p = ap * bq - aq * bp
            q = bq * aq
        else:
            q1, q2 = (aq // g, bq // g)
            p, q = (ap * q2 - bp * q1, q1 * q2)
            g2 = gcd(p, g)
            p, q = (p // g2, q * (g // g2))
    elif isinstance(other, integer_types):
        p = self.p - self.q * other
        q = self.q
    else:
        return NotImplemented
    return self.__class__(p, q, _gcd=False)

.sympy.polys.domains.pythonrational.PythonRational.__init__

def __init__(self, p, q=1, _gcd=True):
    from sympy.polys.domains.groundtypes import python_gcd as gcd
    if isinstance(p, Integer):
        p = p.p
    elif isinstance(p, Rational):
        p, q = (p.p, p.q)
    if not q:
        raise ZeroDivisionError('rational number')
    elif q < 0:
        p, q = (-p, -q)
    if not p:
        self.p = 0
        self.q = 1
    elif p == 1 or q == 1:
        self.p = p
        self.q = q
    else:
        if _gcd:
            x = gcd(p, q)
            if x != 1:
                p //= x
                q //= x
        self.p = p
        self.q = q

.sympy.printing.str.StrPrinter._print_Object

def _print_Object(self, object):
    return 'Object("%s")' % object.name

.sympy.printing.str.StrPrinter._print_Category

def _print_Category(self, category):
    return 'Category("%s")' % category.name

.sympy.categories.baseclasses.Category.name

def name(self):
    return self.args[0].name

.sympy.printing.str.StrPrinter._print_Tr

def _print_Tr(self, expr):
    return '%s(%s)' % ('Tr', self._print(expr.args[0]))

.sympy.printing.str.StrPrinter._print_MatMul

def _print_MatMul(self, expr):
    return '*'.join([self.parenthesize(arg, precedence(expr)) for arg in expr.args])

.sympy.printing.str.StrPrinter._print_MatAdd

def _print_MatAdd(self, expr):
    return ' + '.join([self.parenthesize(arg, precedence(expr)) for arg in expr.args])

.sympy.matrices.expressions.matexpr.MatrixSymbol.name

def name(self):
    return self.args[0]

.sympy.printing.str.StrPrinter._print_MatrixSlice

def _print_MatrixSlice(self, expr):

    def strslice(x):
        x = list(x)
        if x[2] == 1:
            del x[2]
        if x[1] == x[0] + 1:
            del x[1]
        if x[0] == 0:
            x[0] = ''
        return ':'.join(map(self._print, x))
    return self._print(expr.parent) + '[' + strslice(expr.rowslice) + ', ' + strslice(expr.colslice) + ']'

.sympy.printing.str.StrPrinter.strslice

def strslice(x):
    x = list(x)
    if x[2] == 1:
        del x[2]
    if x[1] == x[0] + 1:
        del x[1]
    if x[0] == 0:
        x[0] = ''
    return ':'.join(map(self._print, x))

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.printing.str.StrPrinter._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return 'True'

.sympy.printing.str.StrPrinter._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return 'False'

.sympy.printing.str.StrPrinter._print_Complement

def _print_Complement(self, expr):
    return ' \\ '.join((self._print(set) for set in expr.args))

.sympy.printing.str.StrPrinter._print_Reals

def _print_Reals(self, expr):
    return 'S.Reals'

.sympy.printing.str.StrPrinter._print_Naturals

def _print_Naturals(self, expr):
    return 'S.Naturals'


[/PYTHON]
What will be the output of `sstr`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "expr": {
            "_array_form": null,
            "_size": 6
        }
    },
    "kwargs": {
        "order": null
    }
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[THOUGHT]
