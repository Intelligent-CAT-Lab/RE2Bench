You will be given:
1. A Python code snippet wrapped in [PYTHON] ... [/PYTHON]. The code includes branch markers in comments of the form # [STATE]{VARIABLE_NAME}=??[/STATE].
2. A method input wrapped in [INPUT] ... [/INPUT].
Your task is to replace every "??" beween [STATE] and [/STATE] with your prediction of the state of variables associated with LOOPS.

Detailed Instructions:
* Replace ?? with a list.
* You need to predict the states of variables in For loops, While loops, or List Comprehensions.
* If the value of a varibale stays the same through K iterations, repeat its value for K times as its state.
* Determine variable states by tracing the code step by step. Wrap your reasoning in [THOUGHT] ... [/THOUGHT]
* Output the fully annotated code (with ?? replaced) wrapped in [ANSWER] ... [/ANSWER]
* Do not remove, reorder, or add any code lines. 
* Preserve the original line numbers exactly as they appear in the [PYTHON] ... [/PYTHON] block.

Please follow the format in the example below:

[EXAMPLE]
[PYTHON]
1 class CaesarCipher:
2     def __init__(self, shift: int = 3):
3         self.shift = shift
4     
5     @classmethod
6     def _alpha_index(cls, ch: str) -> int:
7         if "A" <= ch <= "Z":
8             return ord(ch) - ord("A")
9         if "a" <= ch <= "z":
10            return ord(ch) - ord("a")
11        return -1
12
13    @classmethod
14    def _shift_char(cls, ch: str, k: int) -> str:
15        idx = cls._alpha_index(ch)
16        if idx == -1:
17            return ch
18        base = ord("A") if ch.isupper() else ord("a")
19        return chr(base + (idx + k) % 26)
20
21    @classmethod
22    def normalize(cls, text: str) -> str:
23        return str(text).replace("\r\n", "\n").replace("\r", "\n")
24    
25    @classmethod
26    def _transform(cls, text: str, k: int) -> str:
27        text = cls.normalize(text)
28        out = []
29        for c in text: ## [STATE]c=??[/STATE] [STATE]t=??[/STATE]
30            out.append(cls._shift_char(c, k))
31        return "".join(out)
[/PYTHON]
The input to method ```_transform```isï¼š
[INPUT]
{
    "self": {
        "shift": 5
    },
    "args": {
        "text": "#test",
        "k": 2
    },
    "kwargs": {}
}
[/INPUT]

Complete the loop annotations in the code with variable states.

[THOUGHT]
Given the call: ```text = "#test" ,k = 2```:
Inside `_transform`, after:
```
text = cls.normalize(text)
out = []
```, we still have: `text` = "#test" (no \r/\n to normalize).
At the loop, `c` takes each character of `text` in order:
1. First iteration: c = "#", t = "#test"
2. Second iteration: c = "t", t = "#test"
3. Third iteration: c = "e", t = "#test"
4. Fourth iteration: c = "s", t = "#test"
5. Fifth iteration: c = "t", t = "#test"
[/THOUGHT]

[ANSWER]
1 class CaesarCipher:
2     def __init__(self, shift: int = 3):
3         self.shift = shift
4     
5     @classmethod
6     def _alpha_index(cls, ch: str) -> int:
7         if "A" <= ch <= "Z":
8             return ord(ch) - ord("A")
9         if "a" <= ch <= "z":
10            return ord(ch) - ord("a")
11        return -1
12
13    @classmethod
14    def _shift_char(cls, ch: str, k: int) -> str:
15        idx = cls._alpha_index(ch)
16        if idx == -1:
17            return ch
18        base = ord("A") if ch.isupper() else ord("a")
19        return chr(base + (idx + k) % 26)
20
21    @classmethod
22    def normalize(cls, text: str) -> str:
23        return str(text).replace("\r\n", "\n").replace("\r", "\n")
24    
25    @classmethod
26    def _transform(cls, text: str, k: int) -> str:
27        text = cls.normalize(text)
28        out = []
29        for c in text: ## [STATE]c=["#", "t", "e", "s", "t"][/STATE] [STATE]t=["#test", "#test", "#test", "#test", "#test"][/STATE]
30            out.append(cls._shift_char(c, k))
31        return "".join(out)
[/ANSWER]
[/EXAMPLE]

1 class BinaryDataProcessor():
2 
3     def __init__(self, binary_string):
4         self.binary_string = binary_string
5         self.clean_non_binary_chars()
6 
7     def convert_to_ascii(self):
8         byte_array = bytearray()
9         for i in range(0, len(self.binary_string), 8):## [STATE]i=??[/STATE] [STATE]range(0, len(self.binary_string), 8)=??[/STATE]
10             byte = self.binary_string[i:(i + 8)]
11             decimal = int(byte, 2)
12             byte_array.append(decimal)
13         return byte_array.decode('ascii')

The input to the method ```convert_to_ascii``` is: 
 {
    "self": {
        "binary_string": "01101000011001010110001001101111"
    },
    "args": {},
    "kwargs": {}
}

Complete the loop annotations in the code with variable states.
