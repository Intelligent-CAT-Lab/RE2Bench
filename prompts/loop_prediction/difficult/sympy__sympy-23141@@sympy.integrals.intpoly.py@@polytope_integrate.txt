You will be given:
1. A Python code snippet wrapped in [PYTHON] ... [/PYTHON]. The code includes branch markers in comments of the form # [STATE]{VARIABLE_NAME}=??[/STATE].
2. A method input wrapped in [INPUT] ... [/INPUT].
Your task is to replace every "??" beween [STATE] and [/STATE] with your prediction of the state of variables associated with LOOPS.

Detailed Instructions:
* Replace ?? with a list.
* You need to predict the states of variables in For loops, While loops, or List Comprehensions.
* If the value of a varibale stays the same through K iterations, repeat its value for K times as its state.
* Determine variable states by tracing the code step by step. Wrap your reasoning in [THOUGHT] ... [/THOUGHT]
* Output the fully annotated code (with ?? replaced) wrapped in [ANSWER] ... [/ANSWER]
* Do not remove, reorder, or add any code lines. 
* Preserve the original line numbers exactly as they appear in the [PYTHON] ... [/PYTHON] block.

Please follow the format in the example below:

[EXAMPLE]
[PYTHON]
1 from __future__ import print_function, division
2 import re
3 import itertools
4 
5 _name_with_digits_p = re.compile(r'^([a-zA-Z]+)([0-9]+)$')
6 
7 def split_sup_sub(text):
8     if not text:
9         return text, [], []
10     n = len(text)
11     name = None
12     supers, subs = [], []
13     buf = []
14     mode = "name" 
15     for i, ch in enumerate(itertools.chain(text, "\0")): ## [STATE]i=??[/STATE] [STATE]ch=??[/STATE] [STATE] itertools.chain(text, "\0")=??[/STATE] 
16         if ch in "^_\0":
17             part = "".join(buf)
18             buf = []
19 
20             if mode == "name":
21                 name = part
22             elif mode == "super":
23                 supers.append(part)
24             elif mode == "sub":
25                 subs.append(part)
26 
27             if ch == "^":
28                 mode = "super"
29             elif ch == "_":
30                 if i + 1 < n and text[i + 1] == "_":
31                     mode = "super"
32                 else:
33                     mode = "sub"
34             else:
35                 mode = "name"
36         else:
37             if ch == "_" and i > 0 and text[i - 1] == "_":
38                 continue
39             buf.append(ch)
40 
41     if name is None:
42         name = ""
43 
44     m = _name_with_digits_p.match(name)
45     if m:
46         name, sub = m.groups()
47         subs.insert(0, sub)
48 
49     return name, supers, subs
[/PYTHON]
The input to the method ```split_sup_sub``` is :
[INPUT]
{
    "self": {},
    "args": {
        "text": "2^x"
    },
    "kwargs": {}
}
[/INPUT]

Complete the loop annotations in the code with variable states.

[THOUGHT]
Input:`text = "2^x"` â‡’ `n = len(text) = 3`.

- Iterable in the loop (line 15): `itertools.chain(text, "\0")` yields all chars of `text` plus a sentinel `"\x00"` at the end:
  - Yields: `["2", "^", "x", "\x00"]`

- Enumerate behavior: `enumerate(...)` pairs each yielded char with a 0-based index:
  - `(i, ch)` sequence:
    - `(0, "2")`
    - `(1, "^")`
    - `(2, "x")`
    - `(3, "\x00")`

- Therefore at the loop header:
  - `i` takes: `0, 1, 2, 3`
  - `ch` takes: `"2", "^", "x", "\x00"`
  - `itertools.chain(text, "\0")` is: ['2', '^', 'x', '\x00']

[/THOUGHT]

[ANSWER]
1 from __future__ import print_function, division
2 import re
3 import itertools
4 
5 _name_with_digits_p = re.compile(r'^([a-zA-Z]+)([0-9]+)$')
6 
7 def split_sup_sub(text):
8     if not text:
9         return text, [], []
10     n = len(text)
11     name = None
12     supers, subs = [], []
13     buf = []
14     mode = "name" 
15     for i, ch in enumerate(itertools.chain(text, "\0")): ## [STATE]i=[0,1,2,3][/STATE] [STATE]ch=['2','^','x','\x00'][/STATE] [STATE] itertools.chain(text, "\0")=[['2', '^', 'x', '\x00'], ['2', '^', 'x', '\x00'], ['2', '^', 'x', '\x00'], ['2', '^', 'x', '\x00']][/STATE] 
16         if ch in "^_\0":
17             part = "".join(buf)
18             buf = []
19 
20             if mode == "name":
21                 name = part
22             elif mode == "super":
23                 supers.append(part)
24             elif mode == "sub":
25                 subs.append(part)
26 
27             if ch == "^":
28                 mode = "super"
29             elif ch == "_":
30                 if i + 1 < n and text[i + 1] == "_":
31                     mode = "super"
32                 else:
33                     mode = "sub"
34             else:
35                 mode = "name"
36         else:
37             if ch == "_" and i > 0 and text[i - 1] == "_":
38                 continue
39             buf.append(ch)
40 
41     if name is None:
42         name = ""
43 
44     m = _name_with_digits_p.match(name)
45     if m:
46         name, sub = m.groups()
47         subs.insert(0, sub)
48 
49     return name, supers, subs
[/ANSWER]
[/EXAMPLE]

1 from functools import cmp_to_key
2 from sympy.abc import x, y, z
3 from sympy.core import S, diff, Expr, Symbol
4 from sympy.core.sympify import _sympify
5 from sympy.geometry import Segment2D, Polygon, Point, Point2D
6 from sympy.polys.polytools import LC, gcd_list, degree_list, Poly
7 from sympy.simplify.simplify import nsimplify
8 from sympy.plotting.plot import Plot, List2DSeries
9 from sympy.plotting.plot import plot3d, plot
10 
11 def polytope_integrate(poly, expr=None, *, clockwise=False, max_degree=None):
12     if clockwise:
13         if isinstance(poly, Polygon):
14             poly = Polygon(*point_sort(poly.vertices), evaluate=False)
15         else:
16             raise TypeError("clockwise=True works for only 2-Polytope"
17                             "V-representation input")
18 
19     if isinstance(poly, Polygon):
20         hp_params = hyperplane_parameters(poly)
21         facets = poly.sides
22     elif len(poly[0]) == 2:
23         plen = len(poly)
24         if len(poly[0][0]) == 2:
25             intersections = [intersection(poly[(i - 1) % plen], poly[i],
26                                           "plane2D")
27                              for i in range(0, plen)]
28             hp_params = poly
29             lints = len(intersections)
30             facets = [Segment2D(intersections[i],
31                                 intersections[(i + 1) % lints])
32                       for i in range(0, lints)]
33         else:
34             raise NotImplementedError("Integration for H-representation 3D"
35                                       "case not implemented yet.")
36     else:
37         vertices = poly[0]
38         facets = poly[1:]
39         hp_params = hyperplane_parameters(facets, vertices)
40 
41         if max_degree is None:
42             if expr is None:
43                 raise TypeError('Input expression must be a valid SymPy expression')
44             return main_integrate3d(expr, facets, vertices, hp_params)
45 
46     if max_degree is not None:
47         result = {}
48         if expr is not None:
49             f_expr = []
50             for e in expr:## [STATE]e=??[/STATE] [STATE]expr=??[/STATE]
51                 _ = decompose(e)
52                 if len(_) == 1 and not _.popitem()[0]:
53                     f_expr.append(e)
54                 elif Poly(e).total_degree() <= max_degree:
55                     f_expr.append(e)
56             expr = f_expr
57 
58         if not isinstance(expr, list) and expr is not None:
59             raise TypeError('Input polynomials must be list of expressions')
60 
61         if len(hp_params[0][0]) == 3:
62             result_dict = main_integrate3d(0, facets, vertices, hp_params,
63                                            max_degree)
64         else:
65             result_dict = main_integrate(0, facets, hp_params, max_degree)
66 
67         if expr is None:
68             return result_dict
69 
70         for poly in expr:## [STATE]poly=??[/STATE] [STATE]expr=??[/STATE]
71             poly = _sympify(poly)
72             if poly not in result:
73                 if poly.is_zero:
74                     result[S.Zero] = S.Zero
75                     continue
76                 integral_value = S.Zero
77                 monoms = decompose(poly, separate=True)
78                 for monom in monoms:## [STATE]monom=??[/STATE] [STATE]monoms=??[/STATE]
79                     monom = nsimplify(monom)
80                     coeff, m = strip(monom)
81                     integral_value += result_dict[m] * coeff
82                 result[poly] = integral_value
83         return result
84 
85     if expr is None:
86         raise TypeError('Input expression must be a valid SymPy expression')
87 
88     return main_integrate(expr, facets, hp_params)

The input to the method ```polytope_integrate``` is: 
 {
    "self": {},
    "args": {
        "poly": "Polygon(Point(0, 0), Point(0, 1), Point(1, 1), Point(1, 0))",
        "expr": [
            1,
            "x",
            "y",
            "x*y",
            "x**2*y",
            "x*y**2"
        ]
    },
    "kwargs": {
        "max_degree": 3
    }
}

Complete the loop annotations in the code with variable states.
