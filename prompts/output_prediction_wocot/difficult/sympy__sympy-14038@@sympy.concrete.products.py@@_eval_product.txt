You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
from sympy.tensor.indexed import Idx
from sympy.core.mul import Mul
from sympy.core.singleton import S
from sympy.core.symbol import symbols
from sympy.concrete.expr_with_intlimits import ExprWithIntLimits
from sympy.core.exprtools import factor_terms
from sympy.functions.elementary.exponential import exp, log
from sympy.polys import quo, roots
from sympy.simplify import powsimp
from sympy.core.compatibility import range
from sympy.concrete.summations import Sum
from sympy.concrete.delta import deltaproduct, _has_simple_delta
from sympy.concrete.summations import summation
from sympy.functions import KroneckerDelta, RisingFactorial
from sympy.simplify.simplify import product_simplify
from sympy.concrete.summations import Sum

class Product(ExprWithIntLimits):
    __slots__ = ['is_commutative']
    function = term

    def _eval_product(self, term, limits):
        from sympy.concrete.delta import deltaproduct, _has_simple_delta
        from sympy.concrete.summations import summation
        from sympy.functions import KroneckerDelta, RisingFactorial
        k, a, n = limits
        if k not in term.free_symbols:
            if (term - 1).is_zero:
                return S.One
            return term ** (n - a + 1)
        if a == n:
            return term.subs(k, a)
        if term.has(KroneckerDelta) and _has_simple_delta(term, limits[0]):
            return deltaproduct(term, limits)
        dif = n - a
        if dif.is_Integer:
            return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])
        elif term.is_polynomial(k):
            poly = term.as_poly(k)
            A = B = Q = S.One
            all_roots = roots(poly)
            M = 0
            for r, m in all_roots.items():
                M += m
                A *= RisingFactorial(a - r, n - a + 1) ** m
                Q *= (n - r) ** m
            if M < poly.degree():
                arg = quo(poly, Q.as_poly(k))
                B = self.func(arg, (k, a, n)).doit()
            return poly.LC() ** (n - a + 1) * A * B
        elif term.is_Add:
            factored = factor_terms(term, fraction=True)
            if factored.is_Mul:
                return self._eval_product(factored, (k, a, n))
        elif term.is_Mul:
            exclude, include = ([], [])
            for t in term.args:
                p = self._eval_product(t, (k, a, n))
                if p is not None:
                    exclude.append(p)
                else:
                    include.append(t)
            if not exclude:
                return None
            else:
                arg = term._new_rawargs(*include)
                A = Mul(*exclude)
                B = self.func(arg, (k, a, n)).doit()
                return A * B
        elif term.is_Pow:
            if not term.base.has(k):
                s = summation(term.exp, (k, a, n))
                return term.base ** s
            elif not term.exp.has(k):
                p = self._eval_product(term.base, (k, a, n))
                if p is not None:
                    return p ** term.exp
        elif isinstance(term, Product):
            evaluated = term.doit()
            f = self._eval_product(evaluated, limits)
            if f is None:
                return self.func(evaluated, limits)
            else:
                return f
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.cache.__cacheit_nocache

def __cacheit_nocache(func):
    return func

.sympy.core.basic.Basic.free_symbols

def free_symbols(self):
    return set().union(*[a.free_symbols for a in self.args])

.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.core.symbol.Symbol.free_symbols

def free_symbols(self):
    return {self}

.sympy.core.basic.Basic.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    from sympy import Pow
    if self is other:
        return True
    if type(self) is not type(other):
        try:
            other = _sympify(other)
        except SympifyError:
            return NotImplemented
        if type(self) != type(other):
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    if evaluate is None:
        if global_evaluate[0] is False:
            evaluate = global_evaluate[0]
        else:
            evaluate = True
    try:
        if a in sympy_classes:
            return a
    except TypeError:
        pass
    try:
        cls = a.__class__
    except AttributeError:
        cls = type(a)
    if cls in sympy_classes:
        return a
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a)
    try:
        return converter[cls](a)
    except KeyError:
        for superclass in getmro(cls):
            try:
                return converter[superclass](a)
            except KeyError:
                continue
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    try:
        return a._sympy_()
    except AttributeError:
        pass
    if not strict:
        try:
            from ..tensor.array import Array
            return Array(a.flat, a.shape)
        except AttributeError:
            pass
    if not isinstance(a, string_types):
        for coerce in (float, int):
            try:
                return sympify(coerce(a))
            except (TypeError, ValueError, AttributeError, SympifyError):
                continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
        from .compatibility import unicode
        a = unicode(a)
    except Exception as exc:
        raise SympifyError(a, exc)
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.basic.Basic.has

def has(self, *patterns):
    return any((self._has(pattern) for pattern in patterns))

.sympy.core.basic.Basic._has

def _has(self, pattern):
    from sympy.core.function import UndefinedFunction, Function
    if isinstance(pattern, UndefinedFunction):
        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))
    pattern = sympify(pattern)
    if isinstance(pattern, BasicMeta):
        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))
    try:
        match = pattern._has_matcher()
        return any((match(arg) for arg in preorder_traversal(self)))
    except AttributeError:
        return any((arg == pattern for arg in preorder_traversal(self)))

.sympy.core.basic.preorder_traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

.sympy.core.basic.preorder_traversal.__iter__

def __iter__(self):
    return self

.sympy.core.basic.preorder_traversal.__next__

def __next__(self):
    return next(self._pt)

.sympy.core.basic.preorder_traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            for subtree in self._preorder_traversal(arg, keys):
                yield subtree
    elif iterable(node):
        for item in node:
            for subtree in self._preorder_traversal(item, keys):
                yield subtree

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            try:
                f = getattr(other, method_name)
            except AttributeError:
                pass
            else:
                return f(self)
    return func(self, other)

.sympy.core.expr.Expr.__sub__

def __sub__(self, other):
    return Add(self, -other)

.sympy.core.expr.Expr.__neg__

def __neg__(self):
    return Mul(S.NegativeOne, self)

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, **options):
    from sympy import Order
    args = list(map(_sympify, args))
    args = [a for a in args if a is not cls.identity]
    if not options.pop('evaluate', global_evaluate[0]):
        return cls._from_args(args)
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        return Order(obj, *order_symbols)
    return obj

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        assert not a is S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    rv = ([cls(a * r, b, evaluate=False)], [], None)
                elif global_distribute[0] and b.is_commutative:
                    r, b = b.as_coeff_Add()
                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
                    _addsort(bargs)
                    ar = a * r
                    if ar:
                        bargs.insert(0, ar)
                    bargs = [Add._from_args(bargs)]
                    rv = (bargs, [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number:
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            if coeff is S.ComplexInfinity:
                return ([S.ComplexInfinity], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
                elif b is S.ImaginaryUnit and e.is_Rational:
                    neg1e += e / 2
                    continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):
                    return ([S.NaN], [], None)
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff is S.Infinity or coeff is S.NegativeInfinity:

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_positive:
                    continue
                if t.is_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]
    elif coeff is S.Zero:
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (S.One, self)

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, string_types):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Integer can only work with integer expressions.')
    try:
        return _intcache[ival]
    except KeyError:
        obj = Expr.__new__(cls)
        obj.p = ival
        _intcache[ival] = obj
        return obj

.sympy.core.expr.Expr.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.numbers.Rational.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (self, S.One)

.sympy.core.numbers.Zero.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super(AssocOp, cls).__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            if i in Basic._constructor_postprocessor_mapping:
                for k, v in Basic._constructor_postprocessor_mapping[i].items():
                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
            else:
                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
                for k, v in chain.from_iterable(postprocessor_mappings):
                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:
        Basic._constructor_postprocessor_mapping[obj] = postprocessors
    return obj

.sympy.core.basic.Basic._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.add.Add.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        if a.is_Rational:
            if b.is_Mul:
                rv = ([a, b], [], None)
        if rv:
            if all((s.is_commutative for s in rv[0])):
                return rv
            return ([], rv[0], None)
    terms = {}
    coeff = S.Zero
    order_factors = []
    for o in seq:
        if o.is_Order:
            for o1 in order_factors:
                if o1.contains(o):
                    o = None
                    break
            if o is None:
                continue
            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):
                return ([S.NaN], [], None)
            if coeff.is_Number:
                coeff += o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__add__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            coeff = o.__add__(coeff) if coeff else o
            continue
        elif o is S.ComplexInfinity:
            if coeff.is_finite is False:
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o.is_Add:
            seq.extend(o.args)
            continue
        elif o.is_Mul:
            c, s = o.as_coeff_Mul()
        elif o.is_Pow:
            b, e = o.as_base_exp()
            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):
                seq.append(b ** e)
                continue
            c, s = (S.One, o)
        else:
            c = S.One
            s = o
        if s in terms:
            terms[s] += c
            if terms[s] is S.NaN:
                return ([S.NaN], [], None)
        else:
            terms[s] = c
    newseq = []
    noncommutative = False
    for s, c in terms.items():
        if c is S.Zero:
            continue
        elif c is S.One:
            newseq.append(s)
        elif s.is_Mul:
            cs = s._new_rawargs(*(c,) + s.args)
            newseq.append(cs)
        elif s.is_Add:
            newseq.append(Mul(c, s, evaluate=False))
        else:
            newseq.append(Mul(c, s))
        noncommutative = noncommutative or not s.is_commutative
    if coeff is S.Infinity:
        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]
    elif coeff is S.NegativeInfinity:
        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]
    if coeff is S.ComplexInfinity:
        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]
    if order_factors:
        newseq2 = []
        for t in newseq:
            for o in order_factors:
                if o.contains(t):
                    t = None
                    break
            if t is not None:
                newseq2.append(t)
        newseq = newseq2 + order_factors
        for o in order_factors:
            if o.contains(coeff):
                coeff = S.Zero
                break
    _addsort(newseq)
    if coeff is not S.Zero:
        newseq.insert(0, coeff)
    if noncommutative:
        return ([], newseq, None)
    else:
        return (newseq, [], None)

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.core.add._addsort

def _addsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.expr.Expr.is_polynomial

def is_polynomial(self, *syms):
    if syms:
        syms = set(map(sympify, syms))
    else:
        syms = self.free_symbols
    if syms.intersection(self.free_symbols) == set([]):
        return True
    else:
        return self._eval_is_polynomial(syms)

.sympy.core.power.Pow._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    if self.exp.has(*syms):
        return False
    if self.base.has(*syms):
        return bool(self.base._eval_is_polynomial(syms) and self.exp.is_Integer and (self.exp >= 0))
    else:
        return True

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.core.basic.Basic._has_matcher

def _has_matcher(self):
    return lambda other: self == other

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.expr.AtomicExpr._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    return True

.sympy.core.numbers.Integer.__ge__

def __ge__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s >= %s' % (self, other))
    if other.is_Integer:
        return _sympify(self.p >= other.p)
    return Rational.__ge__(self, other)

.sympy.logic.boolalg.BooleanTrue.__nonzero__

def __nonzero__(self):
    return True

.sympy.core.basic.Basic.as_poly

def as_poly(self, *gens, **args):
    from sympy.polys import Poly, PolynomialError
    try:
        poly = Poly(self, *gens, **args)
        if not poly.is_Poly:
            return None
        else:
            return poly
    except PolynomialError:
        return None

.sympy.polys.polytools.Poly.__new__

def __new__(cls, rep, *gens, **args):
    opt = options.build_options(gens, args)
    if 'order' in opt:
        raise NotImplementedError("'order' keyword is not implemented yet")
    if iterable(rep, exclude=str):
        if isinstance(rep, dict):
            return cls._from_dict(rep, opt)
        else:
            return cls._from_list(list(rep), opt)
    else:
        rep = sympify(rep)
        if rep.is_Poly:
            return cls._from_poly(rep, opt)
        else:
            return cls._from_expr(rep, opt)

.sympy.polys.polyoptions.build_options

def build_options(gens, args=None):
    if args is None:
        gens, args = ((), gens)
    if len(args) != 1 or 'opt' not in args or gens:
        return Options(gens, args)
    else:
        return args['opt']

.sympy.polys.polyoptions.Options.__init__

def __init__(self, gens, args, flags=None, strict=False):
    dict.__init__(self)
    if gens and args.get('gens', ()):
        raise OptionError("both '*gens' and keyword argument 'gens' supplied")
    elif gens:
        args = dict(args)
        args['gens'] = gens
    defaults = args.pop('defaults', {})

    def preprocess_options(args):
        for option, value in args.items():
            try:
                cls = self.__options__[option]
            except KeyError:
                raise OptionError("'%s' is not a valid option" % option)
            if issubclass(cls, Flag):
                if flags is None or option not in flags:
                    if strict:
                        raise OptionError("'%s' flag is not allowed in this context" % option)
            if value is not None:
                self[option] = cls.preprocess(value)
    preprocess_options(args)
    for key, value in dict(defaults).items():
        if key in self:
            del defaults[key]
        else:
            for option in self.keys():
                cls = self.__options__[option]
                if key in cls.excludes:
                    del defaults[key]
                    break
    preprocess_options(defaults)
    for option in self.keys():
        cls = self.__options__[option]
        for require_option in cls.requires:
            if self.get(require_option) is None:
                raise OptionError("'%s' option is only allowed together with '%s'" % (option, require_option))
        for exclude_option in cls.excludes:
            if self.get(exclude_option) is not None:
                raise OptionError("'%s' option is not allowed together with '%s'" % (option, exclude_option))
    for option in self.__order__:
        self.__options__[option].postprocess(self)

.sympy.polys.polyoptions.Options.preprocess_options

def preprocess_options(args):
    for option, value in args.items():
        try:
            cls = self.__options__[option]
        except KeyError:
            raise OptionError("'%s' is not a valid option" % option)
        if issubclass(cls, Flag):
            if flags is None or option not in flags:
                if strict:
                    raise OptionError("'%s' flag is not allowed in this context" % option)
        if value is not None:
            self[option] = cls.preprocess(value)

.sympy.polys.polyoptions.Gens.preprocess

def preprocess(cls, gens):
    if isinstance(gens, Basic):
        gens = (gens,)
    elif len(gens) == 1 and hasattr(gens[0], '__iter__'):
        gens = gens[0]
    if gens == (None,):
        gens = ()
    elif has_dups(gens):
        raise GeneratorsError('duplicated generators: %s' % str(gens))
    elif any((gen.is_commutative is False for gen in gens)):
        raise GeneratorsError('non-commutative generators: %s' % str(gens))
    return tuple(gens)

.sympy.core.sympify.SympifyError.__init__

def __init__(self, expr, base_exc=None):
    self.expr = expr
    self.base_exc = base_exc

.sympy.utilities.iterables.has_dups

def has_dups(seq):
    from sympy.core.containers import Dict
    from sympy.sets.sets import Set
    if isinstance(seq, (dict, set, Dict, Set)):
        return False
    uniq = set()
    return any((True for s in seq if s in uniq or uniq.add(s)))

.sympy.polys.polyoptions.Option.postprocess

def postprocess(cls, options):
    pass

.sympy.polys.polyoptions.Extension.postprocess

def postprocess(cls, options):
    if 'extension' in options and options['extension'] is not True:
        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])

.sympy.polys.polyoptions.Gaussian.postprocess

def postprocess(cls, options):
    if 'gaussian' in options and options['gaussian'] is True:
        options['extension'] = set([S.ImaginaryUnit])
        Extension.postprocess(options)

.sympy.polys.polyoptions.Domain.postprocess

def postprocess(cls, options):
    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):
        raise GeneratorsError('ground domain and generators interfere together')
    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):
        raise GeneratorsError('you have to provide generators because EX domain was requested')

.sympy.polys.polyoptions.Auto.postprocess

def postprocess(cls, options):
    if ('domain' in options or 'field' in options) and 'auto' not in options:
        options['auto'] = False

.sympy.polys.polyoptions.Modulus.postprocess

def postprocess(cls, options):
    if 'modulus' in options:
        modulus = options['modulus']
        symmetric = options.get('symmetric', True)
        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)

.sympy.polys.polyoptions.Split.postprocess

def postprocess(cls, options):
    if 'split' in options:
        raise NotImplementedError("'split' option is not implemented yet")

.sympy.core.compatibility.iterable

def iterable(i, exclude=(string_types, dict, NotIterable)):
    if hasattr(i, '_iterable'):
        return i._iterable
    try:
        iter(i)
    except TypeError:
        return False
    if exclude:
        return not isinstance(i, exclude)
    return True

.sympy.polys.polytools.Poly._from_expr

def _from_expr(cls, rep, opt):
    rep, opt = _dict_from_expr(rep, opt)
    return cls._from_dict(rep, opt)

.sympy.polys.polyutils._dict_from_expr

def _dict_from_expr(expr, opt):
    if expr.is_commutative is False:
        raise PolynomialError('non-commutative expressions are not supported')

    def _is_expandable_pow(expr):
        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add
    if opt.expand is not False:
        if not isinstance(expr, Expr):
            raise PolynomialError('expression must be of type Expr')
        expr = expr.expand()
        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):
            expr = expand_multinomial(expr)
        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):
            expr = expand_mul(expr)
    if opt.gens:
        rep, gens = _dict_from_expr_if_gens(expr, opt)
    else:
        rep, gens = _dict_from_expr_no_gens(expr, opt)
    return (rep, opt.clone({'gens': gens}))

.sympy.polys.polyoptions.OptionType.getter

def getter(self):
    try:
        return self[cls.option]
    except KeyError:
        return cls.default()

.sympy.polys.polyoptions.Expand.default

def default(cls):
    return True

.sympy.core.expr.Expr.expand

def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):
    from sympy.simplify.radsimp import fraction
    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)
    expr = self
    if hints.pop('frac', False):
        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]
        return n / d
    elif hints.pop('denom', False):
        n, d = fraction(self)
        return n / d.expand(deep=deep, modulus=modulus, **hints)
    elif hints.pop('numer', False):
        n, d = fraction(self)
        return n.expand(deep=deep, modulus=modulus, **hints) / d

    def _expand_hint_key(hint):
        if hint == 'mul':
            return 'mulz'
        return hint
    for hint in sorted(hints.keys(), key=_expand_hint_key):
        use_hint = hints[hint]
        if use_hint:
            hint = '_eval_expand_' + hint
            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
    while True:
        was = expr
        if hints.get('multinomial', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)
        if hints.get('mul', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)
        if hints.get('log', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)
        if expr == was:
            break
    if modulus is not None:
        modulus = sympify(modulus)
        if not modulus.is_Integer or modulus <= 0:
            raise ValueError('modulus must be a positive integer, got %s' % modulus)
        terms = []
        for term in Add.make_args(expr):
            coeff, tail = term.as_coeff_Mul(rational=True)
            coeff %= modulus
            if coeff:
                terms.append(coeff * tail)
        expr = Add(*terms)
    return expr

.sympy.core.expr.Expr._expand_hint_key

def _expand_hint_key(hint):
    if hint == 'mul':
        return 'mulz'
    return hint

.sympy.core.expr.Expr._expand_hint

def _expand_hint(expr, hint, deep=True, **hints):
    hit = False
    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):
        sargs = []
        for arg in expr.args:
            arg, arghit = Expr._expand_hint(arg, hint, **hints)
            hit |= arghit
            sargs.append(arg)
        if hit:
            expr = expr.func(*sargs)
    if hasattr(expr, hint):
        newexpr = getattr(expr, hint)(**hints)
        if newexpr != expr:
            return (newexpr, True)
    return (expr, hit)

.sympy.core.power.Pow._eval_expand_multinomial

def _eval_expand_multinomial(self, **hints):
    base, exp = self.args
    result = self
    if exp.is_Rational and exp.p > 0 and base.is_Add:
        if not exp.is_Integer:
            n = Integer(exp.p // exp.q)
            if not n:
                return result
            else:
                radical, result = (self.func(base, exp - n), [])
                expanded_base_n = self.func(base, n)
                if expanded_base_n.is_Pow:
                    expanded_base_n = expanded_base_n._eval_expand_multinomial()
                for term in Add.make_args(expanded_base_n):
                    result.append(term * radical)
                return Add(*result)
        n = int(exp)
        if base.is_commutative:
            order_terms, other_terms = ([], [])
            for b in base.args:
                if b.is_Order:
                    order_terms.append(b)
                else:
                    other_terms.append(b)
            if order_terms:
                f = Add(*other_terms)
                o = Add(*order_terms)
                if n == 2:
                    return expand_multinomial(f ** n, deep=False) + n * f * o
                else:
                    g = expand_multinomial(f ** (n - 1), deep=False)
                    return expand_mul(f * g, deep=False) + n * g * o
            if base.is_number:
                a, b = base.as_real_imag()
                if a.is_Rational and b.is_Rational:
                    if not a.is_Integer:
                        if not b.is_Integer:
                            k = self.func(a.q * b.q, n)
                            a, b = (a.p * b.q, a.q * b.p)
                        else:
                            k = self.func(a.q, n)
                            a, b = (a.p, a.q * b)
                    elif not b.is_Integer:
                        k = self.func(b.q, n)
                        a, b = (a * b.q, b.p)
                    else:
                        k = 1
                    a, b, c, d = (int(a), int(b), 1, 0)
                    while n:
                        if n & 1:
                            c, d = (a * c - b * d, b * c + a * d)
                            n -= 1
                        a, b = (a * a - b * b, 2 * a * b)
                        n //= 2
                    I = S.ImaginaryUnit
                    if k == 1:
                        return c + I * d
                    else:
                        return Integer(c) / k + I * d / k
            p = other_terms
            from sympy import multinomial_coefficients
            from sympy.polys.polyutils import basic_from_dict
            expansion_dict = multinomial_coefficients(len(p), n)
            return basic_from_dict(expansion_dict, *p)
        elif n == 2:
            return Add(*[f * g for f in base.args for g in base.args])
        else:
            multi = (base ** (n - 1))._eval_expand_multinomial()
            if multi.is_Add:
                return Add(*[f * g for f in base.args for g in multi.args])
            else:
                return Add(*[f * multi for f in base.args])
    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):
        return 1 / self.func(base, -exp)._eval_expand_multinomial()
    elif exp.is_Add and base.is_Number:
        coeff, tail = (S.One, S.Zero)
        for term in exp.args:
            if term.is_Number:
                coeff *= self.func(base, term)
            else:
                tail += term
        return coeff * self.func(base, tail)
    else:
        return result

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.power.Pow._eval_expand_power_base

def _eval_expand_power_base(self, **hints):
    force = hints.get('force', False)
    b = self.base
    e = self.exp
    if not b.is_Mul:
        return self
    cargs, nc = b.args_cnc(split_1=False)
    if nc:
        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]
        if e.is_Integer:
            if e.is_positive:
                rv = Mul(*nc * e)
            else:
                rv = 1 / Mul(*nc * -e)
            if cargs:
                rv *= Mul(*cargs) ** e
            return rv
        if not cargs:
            return self.func(Mul(*nc), e, evaluate=False)
        nc = [Mul(*nc)]
    other, maybe_real = sift(cargs, lambda x: x.is_real is False, binary=True)

    def pred(x):
        if x is S.ImaginaryUnit:
            return S.ImaginaryUnit
        polar = x.is_polar
        if polar:
            return True
        if polar is None:
            return fuzzy_bool(x.is_nonnegative)
    sifted = sift(maybe_real, pred)
    nonneg = sifted[True]
    other += sifted[None]
    neg = sifted[False]
    imag = sifted[S.ImaginaryUnit]
    if imag:
        I = S.ImaginaryUnit
        i = len(imag) % 4
        if i == 0:
            pass
        elif i == 1:
            other.append(I)
        elif i == 2:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
        else:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
            other.append(I)
        del imag
    if force or e.is_integer:
        cargs = nonneg + neg + other
        other = nc
    else:
        assert not e.is_Integer
        if len(neg) > 1:
            o = S.One
            if not other and neg[0].is_Number:
                o *= neg.pop(0)
            if len(neg) % 2:
                o = -o
            for n in neg:
                nonneg.append(-n)
            if o is not S.One:
                other.append(o)
        elif neg and other:
            if neg[0].is_Number and neg[0] is not S.NegativeOne:
                other.append(S.NegativeOne)
                nonneg.append(-neg[0])
            else:
                other.extend(neg)
        else:
            other.extend(neg)
        del neg
        cargs = nonneg
        other += nc
    rv = S.One
    if cargs:
        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])
    if other:
        rv *= self.func(Mul(*other), e, evaluate=False)
    return rv

.sympy.core.power.Pow._eval_expand_power_exp

def _eval_expand_power_exp(self, **hints):
    b = self.base
    e = self.exp
    if e.is_Add and e.is_commutative:
        expr = []
        for x in e.args:
            expr.append(self.func(self.base, x))
        return Mul(*expr)
    return self.func(b, e)

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.power.Pow.__new__

def __new__(cls, b, e, evaluate=None):
    if evaluate is None:
        evaluate = global_evaluate[0]
    from sympy.functions.elementary.exponential import exp_polar
    b = _sympify(b)
    e = _sympify(e)
    if evaluate:
        if e is S.ComplexInfinity:
            return S.NaN
        if e is S.Zero:
            return S.One
        elif e is S.One:
            return b
        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):
            if e.is_even:
                b = -b
            elif e.is_odd:
                return -Pow(-b, e)
        if S.NaN in (b, e):
            return S.NaN
        elif b is S.One:
            if abs(e).is_infinite:
                return S.NaN
            return S.One
        else:
            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):
                from sympy import numer, denom, log, sign, im, factor_terms
                c, ex = factor_terms(e, sign=False).as_coeff_Mul()
                den = denom(ex)
                if isinstance(den, log) and den.args[0] == b:
                    return S.Exp1 ** (c * numer(ex))
                elif den.is_Add:
                    s = sign(im(b))
                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):
                        return S.Exp1 ** (c * numer(ex))
            obj = b._eval_power(e)
            if obj is not None:
                return obj
    obj = Expr.__new__(cls, b, e)
    obj = cls._exec_constructor_postprocessors(obj)
    if not isinstance(obj, Pow):
        return obj
    obj.is_commutative = b.is_commutative and e.is_commutative
    return obj

.sympy.core.function._coeff_isneg

def _coeff_isneg(a):
    if a.is_Mul:
        a = a.args[0]
    return a.is_Number and a.is_negative

.sympy.core.numbers.NaN.__hash__

def __hash__(self):
    return super(NaN, self).__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super(Number, self).__hash__()

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, integer_types):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Number:
        if other.is_Rational:
            return self.p == other.p and self.q == other.q
        if other.is_Float:
            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
    return False

.sympy.core.expr.Expr._eval_power

def _eval_power(self, other):
    return None

.sympy.core.operations.AssocOp.make_args

def make_args(cls, expr):
    if isinstance(expr, cls):
        return expr.args
    else:
        return (sympify(expr),)

.sympy.polys.polyutils._is_expandable_pow

def _is_expandable_pow(expr):
    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    assumptions._tell(fact, None)
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.numbers.Rational._eval_is_positive

def _eval_is_positive(self):
    return self.p > 0

.sympy.polys.polyutils._dict_from_expr_if_gens

def _dict_from_expr_if_gens(expr, opt):
    (poly,), gens = _parallel_dict_from_expr_if_gens((expr,), opt)
    return (poly, gens)

.sympy.polys.polyutils._parallel_dict_from_expr_if_gens

def _parallel_dict_from_expr_if_gens(exprs, opt):
    k, indices = (len(opt.gens), {})
    for i, g in enumerate(opt.gens):
        indices[g] = i
    polys = []
    for expr in exprs:
        poly = {}
        if expr.is_Equality:
            expr = expr.lhs - expr.rhs
        for term in Add.make_args(expr):
            coeff, monom = ([], [0] * k)
            for factor in Mul.make_args(term):
                if not _not_a_coeff(factor) and factor.is_Number:
                    coeff.append(factor)
                else:
                    try:
                        if opt.series is False:
                            base, exp = decompose_power(factor)
                            if exp < 0:
                                exp, base = (-exp, Pow(base, -S.One))
                        else:
                            base, exp = decompose_power_rat(factor)
                        monom[indices[base]] = exp
                    except KeyError:
                        if not factor.free_symbols.intersection(opt.gens):
                            coeff.append(factor)
                        else:
                            raise PolynomialError('%s contains an element of the generators set' % factor)
            monom = tuple(monom)
            if monom in poly:
                poly[monom] += Mul(*coeff)
            else:
                poly[monom] = Mul(*coeff)
        polys.append(poly)
    return (polys, opt.gens)

.sympy.polys.polyutils._not_a_coeff

def _not_a_coeff(expr):
    return expr in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]

.sympy.core.numbers.NaN.__eq__

def __eq__(self, other):
    return other is S.NaN

.sympy.core.numbers.Infinity.__eq__

def __eq__(self, other):
    return other is S.Infinity

.sympy.core.numbers.NegativeInfinity.__eq__

def __eq__(self, other):
    return other is S.NegativeInfinity

.sympy.polys.polyoptions.Series.default

def default(cls):
    return False

.sympy.core.exprtools.decompose_power

def decompose_power(expr):
    base, exp = expr.as_base_exp()
    if exp.is_Number:
        if exp.is_Rational:
            if not exp.is_Integer:
                base = Pow(base, Rational(1, exp.q))
            exp = exp.p
        else:
            base, exp = (expr, 1)
    else:
        exp, tail = exp.as_coeff_Mul(rational=True)
        if exp is S.NegativeOne:
            base, exp = (Pow(base, tail), -1)
        elif exp is not S.One:
            tail = _keep_coeff(Rational(1, exp.q), tail)
            base, exp = (Pow(base, tail), exp.p)
        else:
            base, exp = (expr, 1)
    return (base, exp)

.sympy.core.power.Pow.as_base_exp

def as_base_exp(self):
    b, e = self.args
    if b.is_Rational and b.p == 1 and (b.q != 1):
        return (Integer(b.q), -e)
    return (b, e)

.sympy.polys.polyoptions.Options.clone

def clone(self, updates={}):
    obj = dict.__new__(self.__class__)
    for option, value in self.items():
        obj[option] = value
    for option, value in updates.items():
        obj[option] = value
    return obj

.sympy.polys.polytools.Poly._from_dict

def _from_dict(cls, rep, opt):
    gens = opt.gens
    if not gens:
        raise GeneratorsNeeded("can't initialize from 'dict' without generators")
    level = len(gens) - 1
    domain = opt.domain
    if domain is None:
        domain, rep = construct_domain(rep, opt=opt)
    else:
        for monom, coeff in rep.items():
            rep[monom] = domain.convert(coeff)
    return cls.new(DMP.from_dict(rep, level, domain), *gens)

.sympy.polys.polyoptions.Option.default

def default(cls):
    return None

.sympy.polys.constructor.construct_domain

def construct_domain(obj, **args):
    opt = build_options(args)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            if not obj:
                monoms, coeffs = ([], [])
            else:
                monoms, coeffs = list(zip(*list(obj.items())))
        else:
            coeffs = obj
    else:
        coeffs = [obj]
    coeffs = list(map(sympify, coeffs))
    result = _construct_simple(coeffs, opt)
    if result is not None:
        if result is not False:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    else:
        if opt.composite is False:
            result = None
        else:
            result = _construct_composite(coeffs, opt)
        if result is not None:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            return (domain, dict(list(zip(monoms, coeffs))))
        else:
            return (domain, coeffs)
    else:
        return (domain, coeffs[0])

.sympy.polys.constructor._construct_simple

def _construct_simple(coeffs, opt):
    result, rationals, reals, algebraics = ({}, False, False, False)
    if opt.extension is True:
        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic
    else:
        is_algebraic = lambda coeff: False
    for coeff in coeffs:
        if coeff.is_Rational:
            if not coeff.is_Integer:
                rationals = True
        elif coeff.is_Float:
            if not algebraics:
                reals = True
            else:
                return False
        elif is_algebraic(coeff):
            if not reals:
                algebraics = True
            else:
                return False
        else:
            return None
    if algebraics:
        domain, result = _construct_algebraic(coeffs, opt)
    else:
        if reals:
            max_prec = max([c._prec for c in coeffs])
            domain = RealField(prec=max_prec)
        elif opt.field or rationals:
            domain = QQ
        else:
            domain = ZZ
        result = []
        for coeff in coeffs:
            result.append(domain.from_sympy(coeff))
    return (domain, result)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.from_sympy

def from_sympy(self, a):
    if a.is_Integer:
        return PythonInteger(a.p)
    elif a.is_Float and int(a) == a:
        return PythonInteger(int(a))
    else:
        raise CoercionFailed('expected an integer, got %s' % a)

.sympy.polys.polyclasses.DMP.from_dict

def from_dict(cls, rep, lev, dom):
    return cls(dmp_from_dict(rep, lev, dom), dom, lev)

.sympy.polys.densebasic.dmp_from_dict

def dmp_from_dict(f, u, K):
    if not u:
        return dup_from_dict(f, K)
    if not f:
        return dmp_zero(u)
    coeffs = {}
    for monom, coeff in f.items():
        head, tail = (monom[0], monom[1:])
        if head in coeffs:
            coeffs[head][tail] = coeff
        else:
            coeffs[head] = {tail: coeff}
    n, v, h = (max(coeffs.keys()), u - 1, [])
    for k in range(n, -1, -1):
        coeff = coeffs.get(k)
        if coeff is not None:
            h.append(dmp_from_dict(coeff, v, K))
        else:
            h.append(dmp_zero(v))
    return dmp_strip(h, u)

.sympy.polys.densebasic.dup_from_dict

def dup_from_dict(f, K):
    if not f:
        return []
    n, h = (max(f.keys()), [])
    if type(n) is int:
        for k in range(n, -1, -1):
            h.append(f.get(k, K.zero))
    else:
        n, = n
        for k in range(n, -1, -1):
            h.append(f.get((k,), K.zero))
    return dup_strip(h)

.sympy.polys.densebasic.dup_strip

def dup_strip(f):
    if not f or f[0]:
        return f
    i = 0
    for cf in f:
        if cf:
            break
        else:
            i += 1
    return f[i:]

.sympy.polys.polyclasses.DMP.__init__

def __init__(self, rep, dom, lev=None, ring=None):
    if lev is not None:
        if type(rep) is dict:
            rep = dmp_from_dict(rep, lev, dom)
        elif type(rep) is not list:
            rep = dmp_ground(dom.convert(rep), lev)
    else:
        rep, lev = dmp_validate(rep)
    self.rep = rep
    self.lev = lev
    self.dom = dom
    self.ring = ring

.sympy.polys.polytools.Poly.new

def new(cls, rep, *gens):
    if not isinstance(rep, DMP):
        raise PolynomialError('invalid polynomial representation: %s' % rep)
    elif rep.lev != len(gens) - 1:
        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))
    obj = Basic.__new__(cls)
    obj.rep = rep
    obj.gens = gens
    return obj

.sympy.polys.polyroots.roots

def roots(f, *gens, **flags):
    from sympy.polys.polytools import to_rational_coeffs
    flags = dict(flags)
    auto = flags.pop('auto', True)
    cubics = flags.pop('cubics', True)
    trig = flags.pop('trig', False)
    quartics = flags.pop('quartics', True)
    quintics = flags.pop('quintics', False)
    multiple = flags.pop('multiple', False)
    filter = flags.pop('filter', None)
    predicate = flags.pop('predicate', None)
    if isinstance(f, list):
        if gens:
            raise ValueError('redundant generators given')
        x = Dummy('x')
        poly, i = ({}, len(f) - 1)
        for coeff in f:
            poly[i], i = (sympify(coeff), i - 1)
        f = Poly(poly, x, field=True)
    else:
        try:
            f = Poly(f, *gens, **flags)
            if f.length == 2 and f.degree() != 1:
                n = f.degree()
                npow_bases = []
                expr = f.as_expr()
                con = expr.as_independent(*gens)[0]
                for p in Mul.make_args(con):
                    if p.is_Pow and (not p.exp % n):
                        npow_bases.append(p.base ** (p.exp / n))
                    else:
                        other.append(p)
                    if npow_bases:
                        b = Mul(*npow_bases)
                        B = Dummy()
                        d = roots(Poly(expr - con + B ** n * Mul(*others), *gens, **flags), *gens, **flags)
                        rv = {}
                        for k, v in d.items():
                            rv[k.subs(B, b)] = v
                        return rv
        except GeneratorsNeeded:
            if multiple:
                return []
            else:
                return {}
        if f.is_multivariate:
            raise PolynomialError('multivariate polynomials are not supported')

    def _update_dict(result, root, k):
        if root in result:
            result[root] += k
        else:
            result[root] = k

    def _try_decompose(f):
        factors, roots = (f.decompose(), [])
        for root in _try_heuristics(factors[0]):
            roots.append(root)
        for factor in factors[1:]:
            previous, roots = (list(roots), [])
            for root in previous:
                g = factor - Poly(root, f.gen)
                for root in _try_heuristics(g):
                    roots.append(root)
        return roots

    def _try_heuristics(f):
        if f.is_ground:
            return []
        if f.is_monomial:
            return [S(0)] * f.degree()
        if f.length() == 2:
            if f.degree() == 1:
                return list(map(cancel, roots_linear(f)))
            else:
                return roots_binomial(f)
        result = []
        for i in [-1, 1]:
            if not f.eval(i):
                f = f.quo(Poly(f.gen - i, f.gen))
                result.append(i)
                break
        n = f.degree()
        if n == 1:
            result += list(map(cancel, roots_linear(f)))
        elif n == 2:
            result += list(map(cancel, roots_quadratic(f)))
        elif f.is_cyclotomic:
            result += roots_cyclotomic(f)
        elif n == 3 and cubics:
            result += roots_cubic(f, trig=trig)
        elif n == 4 and quartics:
            result += roots_quartic(f)
        elif n == 5 and quintics:
            result += roots_quintic(f)
        return result
    (k,), f = f.terms_gcd()
    if not k:
        zeros = {}
    else:
        zeros = {S(0): k}
    coeff, f = preprocess_roots(f)
    if auto and f.get_domain().is_Ring:
        f = f.to_field()
    rescale_x = None
    translate_x = None
    result = {}
    if not f.is_ground:
        if not f.get_domain().is_Exact:
            for r in f.nroots():
                _update_dict(result, r, 1)
        elif f.degree() == 1:
            result[roots_linear(f)[0]] = 1
        elif f.length() == 2:
            roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial
            for r in roots_fun(f):
                _update_dict(result, r, 1)
        else:
            _, factors = Poly(f.as_expr()).factor_list()
            if len(factors) == 1 and f.degree() == 2:
                for r in roots_quadratic(f):
                    _update_dict(result, r, 1)
            elif len(factors) == 1 and factors[0][1] == 1:
                if f.get_domain().is_EX:
                    res = to_rational_coeffs(f)
                    if res:
                        if res[0] is None:
                            translate_x, f = res[2:]
                        else:
                            rescale_x, f = (res[1], res[-1])
                        result = roots(f)
                        if not result:
                            for root in _try_decompose(f):
                                _update_dict(result, root, 1)
                    else:
                        for r in _try_heuristics(f):
                            _update_dict(result, r, 1)
                else:
                    for root in _try_decompose(f):
                        _update_dict(result, root, 1)
            else:
                for factor, k in factors:
                    for r in _try_heuristics(Poly(factor, f.gen, field=True)):
                        _update_dict(result, r, k)
    if coeff is not S.One:
        _result, result = (result, {})
        for root, k in _result.items():
            result[coeff * root] = k
    result.update(zeros)
    if filter not in [None, 'C']:
        handlers = {'Z': lambda r: r.is_Integer, 'Q': lambda r: r.is_Rational, 'R': lambda r: r.is_real, 'I': lambda r: r.is_imaginary}
        try:
            query = handlers[filter]
        except KeyError:
            raise ValueError('Invalid filter: %s' % filter)
        for zero in dict(result).keys():
            if not query(zero):
                del result[zero]
    if predicate is not None:
        for zero in dict(result).keys():
            if not predicate(zero):
                del result[zero]
    if rescale_x:
        result1 = {}
        for k, v in result.items():
            result1[k * rescale_x] = v
        result = result1
    if translate_x:
        result1 = {}
        for k, v in result.items():
            result1[k + translate_x] = v
        result = result1
    if not multiple:
        return result
    else:
        zeros = []
        for zero in ordered(result):
            zeros.extend([zero] * result[zero])
        return zeros

.sympy.polys.polytools.Poly.__hash__

def __hash__(self):
    return super(Poly, self).__hash__()

.sympy.polys.polytools.Poly._hashable_content

def _hashable_content(self):
    return (self.rep, self.gens)

.sympy.polys.polyclasses.DMP.__hash__

def __hash__(f):
    return hash((f.__class__.__name__, f.to_tuple(), f.lev, f.dom, f.ring))

.sympy.polys.polyclasses.DMP.to_tuple

def to_tuple(f):
    return dmp_to_tuple(f.rep, f.lev)

.sympy.polys.densebasic.dmp_to_tuple

def dmp_to_tuple(f, u):
    if not u:
        return tuple(f)
    v = u - 1
    return tuple((dmp_to_tuple(c, v) for c in f))

.sympy.polys.domains.domain.Domain.__hash__

def __hash__(self):
    return hash((self.__class__.__name__, self.dtype))

.sympy.polys.polytools.Poly._from_poly

def _from_poly(cls, rep, opt):
    if cls != rep.__class__:
        rep = cls.new(rep.rep, *rep.gens)
    gens = opt.gens
    field = opt.field
    domain = opt.domain
    if gens and rep.gens != gens:
        if set(rep.gens) != set(gens):
            return cls._from_expr(rep.as_expr(), opt)
        else:
            rep = rep.reorder(*gens)
    if 'domain' in opt and domain:
        rep = rep.set_domain(domain)
    elif field is True:
        rep = rep.to_field()
    return rep

.sympy.polys.polyoptions.Gens.default

def default(cls):
    return ()

.sympy.polys.polytools.Poly.is_multivariate

def is_multivariate(f):
    return len(f.gens) != 1

.sympy.polys.polytools.Poly.terms_gcd

def terms_gcd(f):
    if hasattr(f.rep, 'terms_gcd'):
        J, result = f.rep.terms_gcd()
    else:
        raise OperationNotSupported(f, 'terms_gcd')
    return (J, f.per(result))

.sympy.polys.polyclasses.DMP.terms_gcd

def terms_gcd(f):
    J, F = dmp_terms_gcd(f.rep, f.lev, f.dom)
    return (J, f.per(F))

.sympy.polys.densebasic.dmp_terms_gcd

def dmp_terms_gcd(f, u, K):
    if dmp_ground_TC(f, u, K) or dmp_zero_p(f, u):
        return ((0,) * (u + 1), f)
    F = dmp_to_dict(f, u)
    G = monomial_min(*list(F.keys()))
    if all((g == 0 for g in G)):
        return (G, f)
    f = {}
    for monom, coeff in F.items():
        f[monomial_div(monom, G)] = coeff
    return (G, dmp_from_dict(f, u, K))

.sympy.polys.densebasic.dmp_ground_TC

def dmp_ground_TC(f, u, K):
    while u:
        f = dmp_TC(f, K)
        u -= 1
    return dup_TC(f, K)

.sympy.polys.densebasic.poly_TC

def poly_TC(f, K):
    if not f:
        return K.zero
    else:
        return f[-1]

.sympy.polys.densebasic.dmp_zero_p

def dmp_zero_p(f, u):
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    return not f

.sympy.polys.densebasic.dmp_to_dict

def dmp_to_dict(f, u, K=None, zero=False):
    if not u:
        return dup_to_dict(f, K, zero=zero)
    if dmp_zero_p(f, u) and zero:
        return {(0,) * (u + 1): K.zero}
    n, v, result = (dmp_degree(f, u), u - 1, {})
    if n == -oo:
        n = -1
    for k in range(0, n + 1):
        h = dmp_to_dict(f[n - k], v)
        for exp, coeff in h.items():
            result[(k,) + exp] = coeff
    return result

.sympy.polys.densebasic.dup_to_dict

def dup_to_dict(f, K=None, zero=False):
    if not f and zero:
        return {(0,): K.zero}
    n, result = (len(f) - 1, {})
    for k in range(0, n + 1):
        if f[n - k]:
            result[k,] = f[n - k]
    return result

.sympy.polys.monomials.monomial_min

def monomial_min(*monoms):
    M = list(monoms[0])
    for N in monoms[1:]:
        for i, n in enumerate(N):
            M[i] = min(M[i], n)
    return tuple(M)

.sympy.polys.monomials.monomial_div

def monomial_div(A, B):
    C = monomial_ldiv(A, B)
    if all((c >= 0 for c in C)):
        return tuple(C)
    else:
        return None

.sympy.polys.monomials.monomial_ldiv

def monomial_ldiv(A, B):
    return tuple([a - b for a, b in zip(A, B)])

.sympy.polys.polyclasses.DMP.per

def per(f, rep, dom=None, kill=False, ring=None):
    lev = f.lev
    if kill:
        if not lev:
            return rep
        else:
            lev -= 1
    if dom is None:
        dom = f.dom
    if ring is None:
        ring = f.ring
    return DMP(rep, dom, lev, ring)

.sympy.polys.polytools.Poly.per

def per(f, rep, gens=None, remove=None):
    if gens is None:
        gens = f.gens
    if remove is not None:
        gens = gens[:remove] + gens[remove + 1:]
        if not gens:
            return f.rep.dom.to_sympy(rep)
    return f.__class__.new(rep, *gens)

.sympy.polys.polyroots.preprocess_roots

def preprocess_roots(poly):
    coeff = S.One
    try:
        _, poly = poly.clear_denoms(convert=True)
    except DomainError:
        return (coeff, poly)
    poly = poly.primitive()[1]
    poly = poly.retract()
    if poly.get_domain().is_Poly and all((c.is_term for c in poly.rep.coeffs())):
        poly = poly.inject()
        strips = list(zip(*poly.monoms()))
        gens = list(poly.gens[1:])
        base, strips = (strips[0], strips[1:])
        for gen, strip in zip(list(gens), strips):
            reverse = False
            if strip[0] < strip[-1]:
                strip = reversed(strip)
                reverse = True
            ratio = None
            for a, b in zip(base, strip):
                if not a and (not b):
                    continue
                elif not a or not b:
                    break
                elif b % a != 0:
                    break
                else:
                    _ratio = b // a
                    if ratio is None:
                        ratio = _ratio
                    elif ratio != _ratio:
                        break
            else:
                if reverse:
                    ratio = -ratio
                poly = poly.eval(gen, 1)
                coeff *= gen ** (-ratio)
                gens.remove(gen)
        if gens:
            poly = poly.eject(*gens)
    if poly.is_univariate and poly.get_domain().is_ZZ:
        basis = _integer_basis(poly)
        if basis is not None:
            n = poly.degree()

            def func(k, coeff):
                return coeff // basis ** (n - k[0])
            poly = poly.termwise(func)
            coeff *= basis
    return (coeff, poly)

.sympy.polys.polytools.Poly.clear_denoms

def clear_denoms(self, convert=False):
    f = self
    if not f.rep.dom.is_Field:
        return (S.One, f)
    dom = f.get_domain()
    if dom.has_assoc_Ring:
        dom = f.rep.dom.get_ring()
    if hasattr(f.rep, 'clear_denoms'):
        coeff, result = f.rep.clear_denoms()
    else:
        raise OperationNotSupported(f, 'clear_denoms')
    coeff, f = (dom.to_sympy(coeff), f.per(result))
    if not convert or not dom.has_assoc_Ring:
        return (coeff, f)
    else:
        return (coeff, f.to_ring())

.sympy.polys.polytools.Poly.primitive

def primitive(f):
    if hasattr(f.rep, 'primitive'):
        cont, result = f.rep.primitive()
    else:
        raise OperationNotSupported(f, 'primitive')
    return (f.rep.dom.to_sympy(cont), f.per(result))

.sympy.polys.polyclasses.DMP.primitive

def primitive(f):
    cont, F = dmp_ground_primitive(f.rep, f.lev, f.dom)
    return (cont, f.per(F))

.sympy.polys.densetools.dmp_ground_primitive

def dmp_ground_primitive(f, u, K):
    if not u:
        return dup_primitive(f, K)
    if dmp_zero_p(f, u):
        return (K.zero, f)
    cont = dmp_ground_content(f, u, K)
    if K.is_one(cont):
        return (cont, f)
    else:
        return (cont, dmp_quo_ground(f, cont, u, K))

.sympy.polys.densetools.dup_primitive

def dup_primitive(f, K):
    if not f:
        return (K.zero, f)
    cont = dup_content(f, K)
    if K.is_one(cont):
        return (cont, f)
    else:
        return (cont, dup_quo_ground(f, cont, K))

.sympy.polys.densetools.dup_content

def dup_content(f, K):
    from sympy.polys.domains import QQ
    if not f:
        return K.zero
    cont = K.zero
    if K == QQ:
        for c in f:
            cont = K.gcd(cont, c)
    else:
        for c in f:
            cont = K.gcd(cont, c)
            if K.is_one(cont):
                break
    return cont

.sympy.polys.domains.domain.Domain.__eq__

def __eq__(self, other):
    return isinstance(other, Domain) and self.dtype == other.dtype

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.gcd

def gcd(self, a, b):
    return python_gcd(a, b)

.sympy.polys.domains.domain.Domain.is_one

def is_one(self, a):
    return a == self.one

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.to_sympy

def to_sympy(self, a):
    return SymPyInteger(a)

.sympy.polys.polytools.Poly.retract

def retract(f, field=None):
    dom, rep = construct_domain(f.as_dict(zero=True), field=field, composite=f.domain.is_Composite or None)
    return f.from_dict(rep, f.gens, domain=dom)

.sympy.polys.polytools.Poly.as_dict

def as_dict(f, native=False, zero=False):
    if native:
        return f.rep.to_dict(zero=zero)
    else:
        return f.rep.to_sympy_dict(zero=zero)

.sympy.polys.polyclasses.DMP.to_sympy_dict

def to_sympy_dict(f, zero=False):
    rep = dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)
    for k, v in rep.items():
        rep[k] = f.dom.to_sympy(v)
    return rep

.sympy.polys.polytools.Poly.domain

def domain(self):
    return self.get_domain()

.sympy.polys.polytools.Poly.get_domain

def get_domain(f):
    return f.rep.dom

.sympy.polys.polytools.Poly.from_dict

def from_dict(cls, rep, *gens, **args):
    opt = options.build_options(gens, args)
    return cls._from_dict(rep, opt)

.sympy.polys.polyoptions.Domain.preprocess

def preprocess(cls, domain):
    if isinstance(domain, sympy.polys.domains.Domain):
        return domain
    elif hasattr(domain, 'to_domain'):
        return domain.to_domain()
    elif isinstance(domain, string_types):
        if domain in ['Z', 'ZZ']:
            return sympy.polys.domains.ZZ
        if domain in ['Q', 'QQ']:
            return sympy.polys.domains.QQ
        if domain == 'EX':
            return sympy.polys.domains.EX
        r = cls._re_realfield.match(domain)
        if r is not None:
            _, _, prec = r.groups()
            if prec is None:
                return sympy.polys.domains.RR
            else:
                return sympy.polys.domains.RealField(int(prec))
        r = cls._re_complexfield.match(domain)
        if r is not None:
            _, _, prec = r.groups()
            if prec is None:
                return sympy.polys.domains.CC
            else:
                return sympy.polys.domains.ComplexField(int(prec))
        r = cls._re_finitefield.match(domain)
        if r is not None:
            return sympy.polys.domains.FF(int(r.groups()[1]))
        r = cls._re_polynomial.match(domain)
        if r is not None:
            ground, gens = r.groups()
            gens = list(map(sympify, gens.split(',')))
            if ground in ['Z', 'ZZ']:
                return sympy.polys.domains.ZZ.poly_ring(*gens)
            else:
                return sympy.polys.domains.QQ.poly_ring(*gens)
        r = cls._re_fraction.match(domain)
        if r is not None:
            ground, gens = r.groups()
            gens = list(map(sympify, gens.split(',')))
            if ground in ['Z', 'ZZ']:
                return sympy.polys.domains.ZZ.frac_field(*gens)
            else:
                return sympy.polys.domains.QQ.frac_field(*gens)
        r = cls._re_algebraic.match(domain)
        if r is not None:
            gens = list(map(sympify, r.groups()[1].split(',')))
            return sympy.polys.domains.QQ.algebraic_field(*gens)
    raise OptionError('expected a valid domain specification, got %s' % domain)

.sympy.polys.domains.domain.Domain.convert

def convert(self, element, base=None):
    if base is not None:
        return self.convert_from(element, base)
    if self.of_type(element):
        return element
    from sympy.polys.domains import PythonIntegerRing, GMPYIntegerRing, GMPYRationalField, RealField, ComplexField
    if isinstance(element, integer_types):
        return self.convert_from(element, PythonIntegerRing())
    if HAS_GMPY:
        integers = GMPYIntegerRing()
        if isinstance(element, integers.tp):
            return self.convert_from(element, integers)
        rationals = GMPYRationalField()
        if isinstance(element, rationals.tp):
            return self.convert_from(element, rationals)
    if isinstance(element, float):
        parent = RealField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, complex):
        parent = ComplexField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, DomainElement):
        return self.convert_from(element, element.parent())
    if self.is_Numerical and getattr(element, 'is_ground', False):
        return self.convert(element.LC())
    if isinstance(element, Basic):
        try:
            return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    elif not is_sequence(element):
        try:
            element = sympify(element)
            if isinstance(element, Basic):
                return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    raise CoercionFailed("can't convert %s of type %s to %s" % (element, type(element), self))

.sympy.polys.domains.domain.Domain.of_type

def of_type(self, element):
    return isinstance(element, self.tp)

.sympy.polys.domains.domain.Domain.tp

def tp(self):
    return self.dtype

.sympy.polys.polytools.Poly.is_univariate

def is_univariate(f):
    return len(f.gens) == 1

.sympy.polys.polyroots._integer_basis

def _integer_basis(poly):
    monoms, coeffs = list(zip(*poly.terms()))
    monoms, = list(zip(*monoms))
    coeffs = list(map(abs, coeffs))
    if coeffs[0] < coeffs[-1]:
        coeffs = list(reversed(coeffs))
        n = monoms[0]
        monoms = [n - i for i in reversed(monoms)]
    else:
        return None
    monoms = monoms[:-1]
    coeffs = coeffs[:-1]
    divs = reversed(divisors(gcd_list(coeffs))[1:])
    try:
        div = next(divs)
    except StopIteration:
        return None
    while True:
        for monom, coeff in zip(monoms, coeffs):
            if coeff % div ** monom != 0:
                try:
                    div = next(divs)
                except StopIteration:
                    return None
                else:
                    break
        else:
            return div

.sympy.polys.polytools.Poly.terms

def terms(f, order=None):
    return [(m, f.rep.dom.to_sympy(c)) for m, c in f.rep.terms(order=order)]

.sympy.polys.polyclasses.DMP.terms

def terms(f, order=None):
    return dmp_list_terms(f.rep, f.lev, f.dom, order=order)

.sympy.polys.densebasic.dmp_list_terms

def dmp_list_terms(f, u, K, order=None):

    def sort(terms, O):
        return sorted(terms, key=lambda term: O(term[0]), reverse=True)
    terms = _rec_list_terms(f, u, ())
    if not terms:
        return [((0,) * (u + 1), K.zero)]
    if order is None:
        return terms
    else:
        return sort(terms, monomial_key(order))

.sympy.polys.densebasic._rec_list_terms

def _rec_list_terms(g, v, monom):
    d, terms = (dmp_degree(g, v), [])
    if not v:
        for i, c in enumerate(g):
            if not c:
                continue
            terms.append((monom + (d - i,), c))
    else:
        w = v - 1
        for i, c in enumerate(g):
            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))
    return terms

.sympy.polys.densebasic.dmp_degree

def dmp_degree(f, u):
    if dmp_zero_p(f, u):
        return -oo
    else:
        return len(f) - 1

.sympy.core.numbers.One.__abs__

def __abs__():
    return S.One

.sympy.core.numbers.Integer.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if other.is_Integer:
        return _sympify(self.p < other.p)
    return Rational.__lt__(self, other)

.sympy.logic.boolalg.BooleanFalse.__nonzero__

def __nonzero__(self):
    return False

.sympy.polys.polytools.Poly.to_field

def to_field(f):
    if hasattr(f.rep, 'to_field'):
        result = f.rep.to_field()
    else:
        raise OperationNotSupported(f, 'to_field')
    return f.per(result)

.sympy.polys.polyclasses.DMP.to_field

def to_field(f):
    return f.convert(f.dom.get_field())

.sympy.polys.domains.integerring.IntegerRing.get_field

def get_field(self):
    from sympy.polys.domains import QQ
    return QQ

.sympy.polys.polyclasses.DMP.convert

def convert(f, dom):
    if f.dom == dom:
        return f
    else:
        return DMP(dmp_convert(f.rep, f.lev, f.dom, dom), dom, f.lev)

.sympy.polys.densebasic.dmp_convert

def dmp_convert(f, u, K0, K1):
    if not u:
        return dup_convert(f, K0, K1)
    if K0 is not None and K0 == K1:
        return f
    v = u - 1
    return dmp_strip([dmp_convert(c, v, K0, K1) for c in f], u)

.sympy.polys.densebasic.dup_convert

def dup_convert(f, K0, K1):
    if K0 is not None and K0 == K1:
        return f
    else:
        return dup_strip([K1.convert(c, K0) for c in f])

.sympy.polys.domains.domain.Domain.convert_from

def convert_from(self, element, base):
    if base.alias is not None:
        method = 'from_' + base.alias
    else:
        method = 'from_' + base.__class__.__name__
    _convert = getattr(self, method)
    if _convert is not None:
        result = _convert(element, base)
        if result is not None:
            return result
    raise CoercionFailed("can't convert %s of type %s from %s to %s" % (element, type(element), base, self))

.sympy.polys.domains.pythonrationalfield.PythonRationalField.from_ZZ_python

def from_ZZ_python(K1, a, K0):
    return PythonRational(a)

.sympy.polys.domains.pythonrational.PythonRational.__init__

def __init__(self, p, q=1, _gcd=True):
    from sympy.polys.domains.groundtypes import python_gcd as gcd
    if isinstance(p, Integer):
        p = p.p
    elif isinstance(p, Rational):
        p, q = (p.p, p.q)
    if not q:
        raise ZeroDivisionError('rational number')
    elif q < 0:
        p, q = (-p, -q)
    if not p:
        self.p = 0
        self.q = 1
    elif p == 1 or q == 1:
        self.p = p
        self.q = q
    else:
        if _gcd:
            x = gcd(p, q)
            if x != 1:
                p //= x
                q //= x
        self.p = p
        self.q = q

.sympy.polys.domains.pythonrational.PythonRational.__nonzero__

def __nonzero__(self):
    return self.p != 0

.sympy.polys.polytools.Poly.is_ground

def is_ground(f):
    return f.rep.is_ground

.sympy.polys.polyclasses.DMP.is_ground

def is_ground(f):
    return dmp_ground_p(f.rep, None, f.lev)

.sympy.polys.densebasic.dmp_ground_p

def dmp_ground_p(f, c, u):
    if c is not None and (not c):
        return dmp_zero_p(f, u)
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    if c is None:
        return len(f) <= 1
    else:
        return f == [c]

.sympy.core.numbers.Zero.__neg__

def __neg__():
    return S.Zero

.sympy.core.expr.Expr.__add__

def __add__(self, other):
    return Add(self, other)

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_evaluate[0])
    result = super(Function, cls).__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(mlib.libmpf.prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return EmptySet()
    else:
        args = list(map(sympify, args))
    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._elements = frozenset(args)
    return obj

.sympy.core.compatibility.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                from sympy.utilities.iterables import uniq
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        for v in d[k]:
            yield v
        d.pop(k)

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super(Infinity, self).__hash__()

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    symb = sympify(self.contains(other))
    if not (symb is S.true or symb is S.false):
        raise TypeError('contains did not evaluate to a bool: %r' % symb)
    return bool(symb)

.sympy.sets.sets.Set.contains

def contains(self, other):
    other = sympify(other, strict=True)
    ret = sympify(self._contains(other))
    if ret is None:
        ret = Contains(other, self, evaluate=False)
    return ret

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    r = false
    for e in self._elements:
        t = Eq(e, other, evaluate=True)
        if t is true:
            return t
        elif t is not false:
            r = None
    return r

.sympy.core.relational.Equality.__new__

def __new__(cls, lhs, rhs=0, **options):
    from sympy.core.add import Add
    from sympy.core.logic import fuzzy_bool
    from sympy.core.expr import _n2
    from sympy.simplify.simplify import clear_coefficients
    lhs = _sympify(lhs)
    rhs = _sympify(rhs)
    evaluate = options.pop('evaluate', global_evaluate[0])
    if evaluate:
        if hasattr(lhs, '_eval_Eq'):
            r = lhs._eval_Eq(rhs)
            if r is not None:
                return r
        if hasattr(rhs, '_eval_Eq'):
            r = rhs._eval_Eq(lhs)
            if r is not None:
                return r
        if lhs == rhs:
            return S.true
        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):
            return S.false
        elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):
            return S.false
        fin = L, R = [i.is_finite for i in (lhs, rhs)]
        if None not in fin:
            if L != R:
                return S.false
            if L is False:
                if lhs == -rhs:
                    return S.false
                return S.true
        elif None in fin and False in fin:
            return Relational.__new__(cls, lhs, rhs, **options)
        if all((isinstance(i, Expr) for i in (lhs, rhs))):
            dif = lhs - rhs
            z = dif.is_zero
            if z is not None:
                if z is False and dif.is_commutative:
                    return S.false
                if z:
                    return S.true
            n2 = _n2(lhs, rhs)
            if n2 is not None:
                return _sympify(n2 == 0)
            n, d = dif.as_numer_denom()
            rv = None
            if n.is_zero:
                rv = d.is_nonzero
            elif n.is_finite:
                if d.is_infinite:
                    rv = S.true
                elif n.is_zero is False:
                    rv = d.is_infinite
                    if rv is None:
                        l, r = clear_coefficients(d, S.Infinity)
                        args = [_.subs(l, r) for _ in (lhs, rhs)]
                        if args != [lhs, rhs]:
                            rv = fuzzy_bool(Eq(*args))
                            if rv is True:
                                rv = None
            elif any((a.is_infinite for a in Add.make_args(n))):
                rv = S.false
            if rv is not None:
                return _sympify(rv)
    return Relational.__new__(cls, lhs, rhs, **options)

.sympy.logic.boolalg.BooleanTrue.__hash__

def __hash__(self):
    return hash(True)

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_evaluate[0])
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super(Application, cls).__new__(cls, *args, **options)
    try:
        if is_sequence(obj.nargs):
            nargs = tuple(ordered(set(obj.nargs)))
        elif obj.nargs is not None:
            nargs = (as_int(obj.nargs),)
        else:
            nargs = None
    except AttributeError:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.functions.combinatorial.factorials.RisingFactorial.eval

def eval(cls, x, k):
    x = sympify(x)
    k = sympify(k)
    if x is S.NaN or k is S.NaN:
        return S.NaN
    elif x is S.One:
        return factorial(k)
    elif k.is_Integer:
        if k is S.Zero:
            return S.One
        elif k.is_positive:
            if x is S.Infinity:
                return S.Infinity
            elif x is S.NegativeInfinity:
                if k.is_odd:
                    return S.NegativeInfinity
                else:
                    return S.Infinity
            elif isinstance(x, Poly):
                gens = x.gens
                if len(gens) != 1:
                    raise ValueError('rf only defined for polynomials on one generator')
                else:
                    return reduce(lambda r, i: r * x.shift(i).expand(), range(0, int(k)), 1)
            else:
                return reduce(lambda r, i: r * (x + i), range(0, int(k)), 1)
        elif x is S.Infinity:
            return S.Infinity
        elif x is S.NegativeInfinity:
            return S.Infinity
        elif isinstance(x, Poly):
            gens = x.gens
            if len(gens) != 1:
                raise ValueError('rf only defined for polynomials on one generator')
            else:
                return 1 / reduce(lambda r, i: r * x.shift(-i).expand(), range(1, abs(int(k)) + 1), 1)
        else:
            return 1 / reduce(lambda r, i: r * (x - i), range(1, abs(int(k)) + 1), 1)

.sympy.core.function.Function._should_evalf

def _should_evalf(cls, arg):
    from sympy.core.evalf import pure_complex
    if arg.is_Float:
        return arg._prec
    if not arg.is_Add:
        return -1
    m = pure_complex(arg)
    if m is None or not (m[0].is_Float or m[1].is_Float):
        return -1
    l = [i._prec for i in m if i.is_Float]
    l.append(-1)
    return max(l)

.sympy.core.expr.Expr.__pow__

def __pow__(self, other, mod=None):
    if mod is None:
        return self._pow(other)
    try:
        _self, other, mod = (as_int(self), as_int(other), as_int(mod))
        if other >= 0:
            return pow(_self, other, mod)
        else:
            from sympy.core.numbers import mod_inverse
            return mod_inverse(pow(_self, -other, mod), mod)
    except ValueError:
        power = self._pow(other)
        try:
            return power % mod
        except TypeError:
            return NotImplemented

.sympy.core.expr.Expr._pow

def _pow(self, other):
    return Pow(self, other)

.sympy.core.expr.Expr.is_number

def is_number(self):
    return all((obj.is_number for obj in self.args))

.sympy.core.function.Function.is_commutative

def is_commutative(self):
    if all((getattr(t, 'is_commutative') for t in self.args)):
        return True
    else:
        return False

.sympy.core.numbers.Rational.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))
        elif isinstance(other, Float):
            return other * self
        else:
            return Number.__mul__(self, other)
    return Number.__mul__(self, other)

.sympy.core.numbers.Number.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.Infinity
            else:
                return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.NegativeInfinity
            else:
                return S.Infinity
    elif isinstance(other, Tuple):
        return NotImplemented
    return AtomicExpr.__mul__(self, other)

.sympy.core.expr.Expr.__mul__

def __mul__(self, other):
    return Mul(self, other)

.sympy.core.add.Add._eval_power

def _eval_power(self, e):
    if e.is_Rational and self.is_number:
        from sympy.core.evalf import pure_complex
        from sympy.core.mul import _unevaluated_Mul
        from sympy.core.exprtools import factor_terms
        from sympy.core.function import expand_multinomial
        from sympy.functions.elementary.complexes import sign
        from sympy.functions.elementary.miscellaneous import sqrt
        ri = pure_complex(self)
        if ri:
            r, i = ri
            if e.q == 2:
                D = sqrt(r ** 2 + i ** 2)
                if D.is_Rational:
                    root = sqrt(factor_terms((D - r) / 2)) ** e.p
                    return root * expand_multinomial(((D + r) / abs(i) + sign(i) * S.ImaginaryUnit) ** e.p)
            elif e == -1:
                return _unevaluated_Mul(r - i * S.ImaginaryUnit, 1 / (r ** 2 + i ** 2))

.sympy.polys.polytools.Poly.degree

def degree(f, gen=0):
    j = f._gen_to_level(gen)
    if hasattr(f.rep, 'degree'):
        return f.rep.degree(j)
    else:
        raise OperationNotSupported(f, 'degree')

.sympy.polys.polytools.Poly._gen_to_level

def _gen_to_level(f, gen):
    if isinstance(gen, int):
        length = len(f.gens)
        if -length <= gen < length:
            if gen < 0:
                return length + gen
            else:
                return gen
        else:
            raise PolynomialError('-%s <= gen < %s expected, got %s' % (length, length, gen))
    else:
        try:
            return f.gens.index(sympify(gen))
        except ValueError:
            raise PolynomialError('a valid generator expected, got %s' % gen)

.sympy.polys.polyclasses.DMP.degree

def degree(f, j=0):
    if isinstance(j, int):
        return dmp_degree_in(f.rep, j, f.lev)
    else:
        raise TypeError('``int`` expected, got %s' % type(j))

.sympy.polys.densebasic.dmp_degree_in

def dmp_degree_in(f, j, u):
    if not j:
        return dmp_degree(f, u)
    if j < 0 or j > u:
        raise IndexError('0 <= j <= %s expected, got %s' % (u, j))
    return _rec_degree_in(f, u, 0, j)

.sympy.core.add.Add.__neg__

def __neg__(self):
    return self * -1

.sympy.core.add.Add.as_coeff_Add

def as_coeff_Add(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number and (not rational) or coeff.is_Rational:
        return (coeff, self._new_rawargs(*args))
    return (S.Zero, self)

.sympy.core.mul._keep_coeff

def _keep_coeff(coeff, factors, clear=True, sign=False):
    if not coeff.is_Number:
        if factors.is_Number:
            factors, coeff = (coeff, factors)
        else:
            return coeff * factors
    if coeff is S.One:
        return factors
    elif coeff is S.NegativeOne and (not sign):
        return -factors
    elif factors.is_Add:
        if not clear and coeff.is_Rational and (coeff.q != 1):
            q = S(coeff.q)
            for i in factors.args:
                c, t = i.as_coeff_Mul()
                r = c / q
                if r == int(r):
                    return coeff * factors
        return Mul._from_args((coeff, factors))
    elif factors.is_Mul:
        margs = list(factors.args)
        if margs[0].is_Number:
            margs[0] *= coeff
            if margs[0] == 1:
                margs.pop(0)
        else:
            margs.insert(0, coeff)
        return Mul._from_args(margs)
    else:
        return coeff * factors

.sympy.core.basic.Basic.compare

def compare(self, other):
    if self is other:
        return 0
    n1 = self.__class__
    n2 = other.__class__
    c = (n1 > n2) - (n1 < n2)
    if c:
        return c
    st = self._hashable_content()
    ot = other._hashable_content()
    c = (len(st) > len(ot)) - (len(st) < len(ot))
    if c:
        return c
    for l, r in zip(st, ot):
        l = Basic(*l) if isinstance(l, frozenset) else l
        r = Basic(*r) if isinstance(r, frozenset) else r
        if isinstance(l, Basic):
            c = l.compare(r)
        else:
            c = (l > r) - (l < r)
        if c:
            return c
    return 0

.sympy.core.core.BasicMeta.__gt__

def __gt__(cls, other):
    if cls.__cmp__(other) == 1:
        return True
    return False

.sympy.core.core.BasicMeta.__cmp__

def __cmp__(cls, other):
    if not isinstance(other, BasicMeta):
        return -1
    n1 = cls.__name__
    n2 = other.__name__
    if n1 == n2:
        return 0
    UNKNOWN = len(ordering_of_classes) + 1
    try:
        i1 = ordering_of_classes.index(n1)
    except ValueError:
        i1 = UNKNOWN
    try:
        i2 = ordering_of_classes.index(n2)
    except ValueError:
        i2 = UNKNOWN
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)
    return (i1 > i2) - (i1 < i2)

.sympy.core.core.BasicMeta.__lt__

def __lt__(cls, other):
    if cls.__cmp__(other) == -1:
        return True
    return False

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))

.sympy.core.logic.fuzzy_and

def fuzzy_and(args):
    rv = True
    for ai in args:
        ai = fuzzy_bool(ai)
        if ai is False:
            return False
        if rv:
            rv = ai
    return rv

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.evalf.pure_complex

def pure_complex(v, or_real=False):
    h, t = v.as_coeff_Add()
    if not t:
        if or_real:
            return (h, t)
        return
    c, i = t.as_coeff_Mul()
    if i is S.ImaginaryUnit:
        return (h, c)

.sympy.core.numbers.Integer.__sub__

def __sub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

.sympy.core.add.Add._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    return all((term._eval_is_polynomial(syms) for term in self.args))

.sympy.core.mul.Mul._eval_is_polynomial

def _eval_is_polynomial(self, syms):
    return all((term._eval_is_polynomial(syms) for term in self.args))

.sympy.core.mul.Mul._eval_expand_mul

def _eval_expand_mul(self, **hints):
    from sympy import fraction
    expr = self
    n, d = fraction(expr)
    if d.is_Mul:
        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]
        expr = n / d
        if not expr.is_Mul:
            return expr
    plain, sums, rewrite = ([], [], False)
    for factor in expr.args:
        if factor.is_Add:
            sums.append(factor)
            rewrite = True
        elif factor.is_commutative:
            plain.append(factor)
        else:
            sums.append(Basic(factor))
    if not rewrite:
        return expr
    else:
        plain = self.func(*plain)
        if sums:
            deep = hints.get('deep', False)
            terms = self.func._expandsums(sums)
            args = []
            for term in terms:
                t = self.func(plain, term)
                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:
                    t = t._eval_expand_mul()
                args.append(t)
            return Add(*args)
        else:
            return plain

.sympy.simplify.radsimp.fraction

def fraction(expr, exact=False):
    expr = sympify(expr)
    numer, denom = ([], [])
    for term in Mul.make_args(expr):
        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):
            b, ex = term.as_base_exp()
            if ex.is_negative:
                if ex is S.NegativeOne:
                    denom.append(b)
                elif exact:
                    if ex.is_constant():
                        denom.append(Pow(b, -ex))
                    else:
                        numer.append(term)
                else:
                    denom.append(Pow(b, -ex))
            elif ex.is_positive:
                numer.append(term)
            elif not exact and ex.is_Mul:
                n, d = term.as_numer_denom()
                numer.append(n)
                denom.append(d)
            else:
                numer.append(term)
        elif term.is_Rational:
            n, d = term.as_numer_denom()
            numer.append(n)
            denom.append(d)
        else:
            numer.append(term)
    if exact:
        return (Mul(*numer, evaluate=False), Mul(*denom, evaluate=False))
    else:
        return (Mul(*numer), Mul(*denom))

.sympy.core.numbers.Integer.as_numer_denom

def as_numer_denom(self):
    return (self, S.One)

.sympy.core.numbers.Integer.__abs__

def __abs__(self):
    if self.p >= 0:
        return self
    else:
        return Integer(-self.p)

.sympy.polys.polytools.gcd_list

def gcd_list(seq, *gens, **args):
    seq = sympify(seq)

    def try_non_polynomial_gcd(seq):
        if not gens and (not args):
            domain, numbers = construct_domain(seq)
            if not numbers:
                return domain.zero
            elif domain.is_Numerical:
                result, numbers = (numbers[0], numbers[1:])
                for number in numbers:
                    result = domain.gcd(result, number)
                    if domain.is_one(result):
                        break
                return domain.to_sympy(result)
        return None
    result = try_non_polynomial_gcd(seq)
    if result is not None:
        return result
    options.allowed_flags(args, ['polys'])
    try:
        polys, opt = parallel_poly_from_expr(seq, *gens, **args)
    except PolificationFailed as exc:
        result = try_non_polynomial_gcd(exc.exprs)
        if result is not None:
            return result
        else:
            raise ComputationFailed('gcd_list', len(seq), exc)
    if not polys:
        if not opt.polys:
            return S.Zero
        else:
            return Poly(0, opt=opt)
    result, polys = (polys[0], polys[1:])
    for poly in polys:
        result = result.gcd(poly)
        if result.is_one:
            break
    if not opt.polys:
        return result.as_expr()
    else:
        return result

.sympy.polys.polytools.try_non_polynomial_gcd

def try_non_polynomial_gcd(seq):
    if not gens and (not args):
        domain, numbers = construct_domain(seq)
        if not numbers:
            return domain.zero
        elif domain.is_Numerical:
            result, numbers = (numbers[0], numbers[1:])
            for number in numbers:
                result = domain.gcd(result, number)
                if domain.is_one(result):
                    break
            return domain.to_sympy(result)
    return None

.sympy.ntheory.factor_.divisors

def divisors(n, generator=False):
    n = as_int(abs(n))
    if isprime(n):
        return [1, n]
    if n == 1:
        return [1]
    if n == 0:
        return []
    rv = _divisors(n)
    if not generator:
        return sorted(rv)
    return rv

.sympy.core.compatibility.as_int

def as_int(n):
    try:
        result = int(n)
        if result != n:
            raise TypeError
    except TypeError:
        raise ValueError('%s is not an integer' % (n,))
    return result

.sympy.core.numbers.Integer.__int__

def __int__(self):
    return self.p

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.ntheory.primetest.isprime

def isprime(n):
    if isinstance(n, (Float, float)):
        return False
    n = int(n)
    if n in [2, 3, 5]:
        return True
    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):
        return False
    if n < 49:
        return True
    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):
        return False
    if n < 2809:
        return True
    if n <= 23001:
        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]
    from sympy.ntheory.generate import sieve as s
    if n <= s._list[-1]:
        l, u = s.search(n)
        return l == u
    from sympy.core.compatibility import HAS_GMPY
    if HAS_GMPY == 2:
        from gmpy2 import is_strong_prp, is_strong_selfridge_prp
        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)
    if n < 341531:
        return mr(n, [9345883071009581737])
    if n < 885594169:
        return mr(n, [725270293939359937, 3569819667048198375])
    if n < 350269456337:
        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])
    if n < 55245642489451:
        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])
    if n < 7999252175582851:
        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])
    if n < 585226005592931977:
        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])
    if n < 18446744073709551616:
        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])
    return mr(n, [2]) and is_strong_lucas_prp(n)

.sympy.polys.polytools.Poly.length

def length(f):
    return len(f.as_dict())

.sympy.polys.domains.pythonrationalfield.PythonRationalField.to_sympy

def to_sympy(self, a):
    return SymPyRational(a.numerator, a.denominator)

.sympy.polys.domains.pythonrational.PythonRational.numer

def numer(self):
    return self.p

.sympy.polys.domains.pythonrational.PythonRational.denom

def denom(self):
    return self.q

.sympy.core.numbers.Rational.__new__

def __new__(cls, p, q=None, gcd=None):
    if q is None:
        if isinstance(p, Rational):
            return p
        if isinstance(p, string_types):
            if p.count('/') > 1:
                raise TypeError('invalid input: %s' % p)
            pq = p.rsplit('/', 1)
            if len(pq) == 2:
                p, q = pq
                fp = fractions.Fraction(p)
                fq = fractions.Fraction(q)
                f = fp / fq
                return Rational(f.numerator, f.denominator, 1)
            p = p.replace(' ', '')
            try:
                p = fractions.Fraction(p)
            except ValueError:
                pass
        if not isinstance(p, string_types):
            try:
                if isinstance(p, fractions.Fraction):
                    return Rational(p.numerator, p.denominator, 1)
            except NameError:
                pass
            if isinstance(p, (float, Float)):
                return Rational(*_as_integer_ratio(p))
        if not isinstance(p, SYMPY_INTS + (Rational,)):
            raise TypeError('invalid input: %s' % p)
        q = q or S.One
        gcd = 1
    else:
        p = Rational(p)
        q = Rational(q)
    if isinstance(q, Rational):
        p *= q.q
        q = q.p
    if isinstance(p, Rational):
        q *= p.q
        p = p.p
    if q == 0:
        if p == 0:
            if _errdict['divide']:
                raise ValueError('Indeterminate 0/0')
            else:
                return S.NaN
        return S.ComplexInfinity
    if q < 0:
        q = -q
        p = -p
    if not gcd:
        gcd = igcd(abs(p), q)
    if gcd > 1:
        p //= gcd
        q //= gcd
    if q == 1:
        return Integer(p)
    if p == 1 and q == 2:
        return S.Half
    obj = Expr.__new__(cls)
    obj.p = p
    obj.q = q
    return obj

.sympy.core.numbers.igcd

def igcd(*args):
    if len(args) < 2:
        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))
    if 1 in args:
        a = 1
        k = 0
    else:
        a = abs(as_int(args[0]))
        k = 1
    if a != 1:
        while k < len(args):
            b = args[k]
            k += 1
            try:
                a = _gcdcache[a, b]
            except KeyError:
                b = as_int(b)
                if not b:
                    continue
                if b == 1:
                    a = 1
                    break
                if b < 0:
                    b = -b
                t = (a, b)
                a = igcd2(a, b)
                _gcdcache[t] = _gcdcache[t[1], t[0]] = a
    while k < len(args):
        ok = as_int(args[k])
        k += 1
    return a

.sympy.polys.polytools.Poly.as_expr

def as_expr(f, *gens):
    if not gens:
        gens = f.gens
    elif len(gens) == 1 and isinstance(gens[0], dict):
        mapping = gens[0]
        gens = list(f.gens)
        for gen, value in mapping.items():
            try:
                index = gens.index(gen)
            except ValueError:
                raise GeneratorsError("%s doesn't have %s as generator" % (f, gen))
            else:
                gens[index] = value
    return basic_from_dict(f.rep.to_sympy_dict(), *gens)

.sympy.polys.polyutils.expr_from_dict

def expr_from_dict(rep, *gens):
    result = []
    for monom, coeff in rep.items():
        term = [coeff]
        for g, m in zip(gens, monom):
            if m:
                term.append(Pow(g, m))
        result.append(Mul(*term))
    return Add(*result)

.sympy.polys.polyutils._dict_from_expr_no_gens

def _dict_from_expr_no_gens(expr, opt):
    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)
    return (poly, gens)

.sympy.polys.polyutils._parallel_dict_from_expr_no_gens

def _parallel_dict_from_expr_no_gens(exprs, opt):
    if opt.domain is not None:

        def _is_coeff(factor):
            return factor in opt.domain
    elif opt.extension is True:

        def _is_coeff(factor):
            return factor.is_algebraic
    elif opt.greedy is not False:

        def _is_coeff(factor):
            return False
    else:

        def _is_coeff(factor):
            return factor.is_number
    gens, reprs = (set([]), [])
    for expr in exprs:
        terms = []
        if expr.is_Equality:
            expr = expr.lhs - expr.rhs
        for term in Add.make_args(expr):
            coeff, elements = ([], {})
            for factor in Mul.make_args(term):
                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):
                    coeff.append(factor)
                else:
                    if opt.series is False:
                        base, exp = decompose_power(factor)
                        if exp < 0:
                            exp, base = (-exp, Pow(base, -S.One))
                    else:
                        base, exp = decompose_power_rat(factor)
                    elements[base] = elements.setdefault(base, 0) + exp
                    gens.add(base)
            terms.append((coeff, elements))
        reprs.append(terms)
    gens = _sort_gens(gens, opt=opt)
    k, indices = (len(gens), {})
    for i, g in enumerate(gens):
        indices[g] = i
    polys = []
    for terms in reprs:
        poly = {}
        for coeff, term in terms:
            monom = [0] * k
            for base, exp in term.items():
                monom[indices[base]] = exp
            monom = tuple(monom)
            if monom in poly:
                poly[monom] += Mul(*coeff)
            else:
                poly[monom] = Mul(*coeff)
        polys.append(poly)
    return (polys, tuple(gens))

.sympy.polys.polyutils._is_coeff

def _is_coeff(factor):
    return factor.is_number

.sympy.polys.polyutils._sort_gens

def _sort_gens(gens, **args):
    opt = build_options(args)
    gens_order, wrt = ({}, None)
    if opt is not None:
        gens_order, wrt = ({}, opt.wrt)
        for i, gen in enumerate(opt.sort):
            gens_order[gen] = i + 1

    def order_key(gen):
        gen = str(gen)
        if wrt is not None:
            try:
                return (-len(wrt) + wrt.index(gen), gen, 0)
            except ValueError:
                pass
        name, index = _re_gen.match(gen).groups()
        if index:
            index = int(index)
        else:
            index = 0
        try:
            return (gens_order[name], name, index)
        except KeyError:
            pass
        try:
            return (_gens_order[name], name, index)
        except KeyError:
            pass
        return (_max_order, name, index)
    try:
        gens = sorted(gens, key=order_key)
    except TypeError:
        pass
    return tuple(gens)

.sympy.polys.polyoptions.Sort.default

def default(cls):
    return []

.sympy.polys.polyutils.order_key

def order_key(gen):
    gen = str(gen)
    if wrt is not None:
        try:
            return (-len(wrt) + wrt.index(gen), gen, 0)
        except ValueError:
            pass
    name, index = _re_gen.match(gen).groups()
    if index:
        index = int(index)
    else:
        index = 0
    try:
        return (gens_order[name], name, index)
    except KeyError:
        pass
    try:
        return (_gens_order[name], name, index)
    except KeyError:
        pass
    return (_max_order, name, index)

.sympy.core.basic.Basic.__str__

def __str__(self):
    from sympy.printing import sstr
    return sstr(self, order=None)

.sympy.printing.str.sstr

def sstr(expr, **settings):
    p = StrPrinter(settings)
    s = p.doprint(expr)
    return s

.sympy.printing.printer.Printer.__init__

def __init__(self, settings=None):
    self._str = str
    self._settings = self._default_settings.copy()
    for key, val in self._global_settings.items():
        if key in self._default_settings:
            self._settings[key] = val
    if settings is not None:
        self._settings.update(settings)
        if len(self._settings) > len(self._default_settings):
            for key in self._settings:
                if key not in self._default_settings:
                    raise TypeError("Unknown setting '%s'." % key)
    self._print_level = 0

.sympy.printing.printer.Printer.doprint

def doprint(self, expr):
    return self._str(self._print(expr))

.sympy.printing.printer.Printer._print

def _print(self, expr, *args, **kwargs):
    self._print_level += 1
    try:
        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):
            return getattr(expr, self.printmethod)(self, *args, **kwargs)
        classes = type(expr).__mro__
        if AppliedUndef in classes:
            classes = classes[classes.index(AppliedUndef):]
        if UndefinedFunction in classes:
            classes = classes[classes.index(UndefinedFunction):]
        if Function in classes:
            i = classes.index(Function)
            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]
        for cls in classes:
            printmethod = '_print_' + cls.__name__
            if hasattr(self, printmethod):
                return getattr(self, printmethod)(expr, *args, **kwargs)
        return self.emptyPrinter(expr)
    finally:
        self._print_level -= 1

.sympy.printing.str.StrPrinter._print_Symbol

def _print_Symbol(self, expr):
    return expr.name

.sympy.polys.polytools.Poly.factor_list

def factor_list(f):
    if hasattr(f.rep, 'factor_list'):
        try:
            coeff, factors = f.rep.factor_list()
        except DomainError:
            return (S.One, [(f, 1)])
    else:
        raise OperationNotSupported(f, 'factor_list')
    return (f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors])

.sympy.polys.polyclasses.DMP.factor_list

def factor_list(f):
    coeff, factors = dmp_factor_list(f.rep, f.lev, f.dom)
    return (coeff, [(f.per(g), k) for g, k in factors])

.sympy.polys.factortools.dmp_factor_list

def dmp_factor_list(f, u, K0):
    if not u:
        return dup_factor_list(f, K0)
    J, f = dmp_terms_gcd(f, u, K0)
    cont, f = dmp_ground_primitive(f, u, K0)
    if K0.is_FiniteField:
        coeff, factors = dmp_gf_factor(f, u, K0)
    elif K0.is_Algebraic:
        coeff, factors = dmp_ext_factor(f, u, K0)
    else:
        if not K0.is_Exact:
            K0_inexact, K0 = (K0, K0.get_exact())
            f = dmp_convert(f, u, K0_inexact, K0)
        else:
            K0_inexact = None
        if K0.is_Field:
            K = K0.get_ring()
            denom, f = dmp_clear_denoms(f, u, K0, K)
            f = dmp_convert(f, u, K0, K)
        else:
            K = K0
        if K.is_ZZ:
            levels, f, v = dmp_exclude(f, u, K)
            coeff, factors = dmp_zz_factor(f, v, K)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_include(f, levels, v, K), k)
        elif K.is_Poly:
            f, v = dmp_inject(f, u, K)
            coeff, factors = dmp_factor_list(f, v, K.dom)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_eject(f, v, K), k)
            coeff = K.convert(coeff, K.dom)
        else:
            raise DomainError('factorization not supported over %s' % K0)
        if K0.is_Field:
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_convert(f, u, K, K0), k)
            coeff = K0.convert(coeff, K)
            coeff = K0.quo(coeff, denom)
            if K0_inexact:
                for i, (f, k) in enumerate(factors):
                    max_norm = dmp_max_norm(f, u, K0)
                    f = dmp_quo_ground(f, max_norm, u, K0)
                    f = dmp_convert(f, u, K0, K0_inexact)
                    factors[i] = (f, k)
                    coeff = K0.mul(coeff, K0.pow(max_norm, k))
                coeff = K0_inexact.convert(coeff, K0)
                K0 = K0_inexact
    for i, j in enumerate(reversed(J)):
        if not j:
            continue
        term = {(0,) * (u - i) + (1,) + (0,) * i: K0.one}
        factors.insert(0, (dmp_from_dict(term, u, K0), j))
    return (coeff * cont, _sort_factors(factors))

.sympy.polys.factortools.dup_factor_list

def dup_factor_list(f, K0):
    j, f = dup_terms_gcd(f, K0)
    cont, f = dup_primitive(f, K0)
    if K0.is_FiniteField:
        coeff, factors = dup_gf_factor(f, K0)
    elif K0.is_Algebraic:
        coeff, factors = dup_ext_factor(f, K0)
    else:
        if not K0.is_Exact:
            K0_inexact, K0 = (K0, K0.get_exact())
            f = dup_convert(f, K0_inexact, K0)
        else:
            K0_inexact = None
        if K0.is_Field:
            K = K0.get_ring()
            denom, f = dup_clear_denoms(f, K0, K)
            f = dup_convert(f, K0, K)
        else:
            K = K0
        if K.is_ZZ:
            coeff, factors = dup_zz_factor(f, K)
        elif K.is_Poly:
            f, u = dmp_inject(f, 0, K)
            coeff, factors = dmp_factor_list(f, u, K.dom)
            for i, (f, k) in enumerate(factors):
                factors[i] = (dmp_eject(f, u, K), k)
            coeff = K.convert(coeff, K.dom)
        else:
            raise DomainError('factorization not supported over %s' % K0)
        if K0.is_Field:
            for i, (f, k) in enumerate(factors):
                factors[i] = (dup_convert(f, K, K0), k)
            coeff = K0.convert(coeff, K)
            coeff = K0.quo(coeff, denom)
            if K0_inexact:
                for i, (f, k) in enumerate(factors):
                    max_norm = dup_max_norm(f, K0)
                    f = dup_quo_ground(f, max_norm, K0)
                    f = dup_convert(f, K0, K0_inexact)
                    factors[i] = (f, k)
                    coeff = K0.mul(coeff, K0.pow(max_norm, k))
                coeff = K0_inexact.convert(coeff, K0)
                K0 = K0_inexact
    if j:
        factors.insert(0, ([K0.one, K0.zero], j))
    return (coeff * cont, _sort_factors(factors))

.sympy.polys.densebasic.dup_terms_gcd

def dup_terms_gcd(f, K):
    if dup_TC(f, K) or not f:
        return (0, f)
    i = 0
    for c in reversed(f):
        if not c:
            i += 1
        else:
            break
    return (i, f[:-i])

.sympy.polys.factortools.dup_zz_factor

def dup_zz_factor(f, K):
    cont, g = dup_primitive(f, K)
    n = dup_degree(g)
    if dup_LC(g, K) < 0:
        cont, g = (-cont, dup_neg(g, K))
    if n <= 0:
        return (cont, [])
    elif n == 1:
        return (cont, [(g, 1)])
    if query('USE_IRREDUCIBLE_IN_FACTOR'):
        if dup_zz_irreducible_p(g, K):
            return (cont, [(g, 1)])
    g = dup_sqf_part(g, K)
    H = None
    if query('USE_CYCLOTOMIC_FACTOR'):
        H = dup_zz_cyclotomic_factor(g, K)
    if H is None:
        H = dup_zz_zassenhaus(g, K)
    factors = dup_trial_division(f, H, K)
    return (cont, factors)

.sympy.polys.densebasic.dup_degree

def dup_degree(f):
    if not f:
        return -oo
    return len(f) - 1

.sympy.polys.densebasic.poly_LC

def poly_LC(f, K):
    if not f:
        return K.zero
    else:
        return f[0]

.sympy.polys.polyconfig.query

def query(key):
    return _current_config.get(key.upper(), None)

.sympy.polys.sqfreetools.dup_sqf_part

def dup_sqf_part(f, K):
    if K.is_FiniteField:
        return dup_gf_sqf_part(f, K)
    if not f:
        return f
    if K.is_negative(dup_LC(f, K)):
        f = dup_neg(f, K)
    gcd = dup_gcd(f, dup_diff(f, 1, K), K)
    sqf = dup_quo(f, gcd, K)
    if K.is_Field:
        return dup_monic(sqf, K)
    else:
        return dup_primitive(sqf, K)[1]

.sympy.polys.domains.domain.Domain.is_negative

def is_negative(self, a):
    return a < 0

.sympy.polys.densetools.dup_diff

def dup_diff(f, m, K):
    if m <= 0:
        return f
    n = dup_degree(f)
    if n < m:
        return []
    deriv = []
    if m == 1:
        for coeff in f[:-m]:
            deriv.append(K(n) * coeff)
            n -= 1
    else:
        for coeff in f[:-m]:
            k = n
            for i in range(n - 1, n - m, -1):
                k *= i
            deriv.append(K(k) * coeff)
            n -= 1
    return dup_strip(deriv)

.sympy.polys.domains.domain.Domain.__call__

def __call__(self, *args):
    return self.new(*args)

.sympy.polys.domains.domain.Domain.new

def new(self, *args):
    return self.dtype(*args)

.sympy.polys.euclidtools.dup_gcd

def dup_gcd(f, g, K):
    return dup_inner_gcd(f, g, K)[0]

.sympy.polys.euclidtools.dup_inner_gcd

def dup_inner_gcd(f, g, K):
    if not K.is_Exact:
        try:
            exact = K.get_exact()
        except DomainError:
            return ([K.one], f, g)
        f = dup_convert(f, K, exact)
        g = dup_convert(g, K, exact)
        h, cff, cfg = dup_inner_gcd(f, g, exact)
        h = dup_convert(h, exact, K)
        cff = dup_convert(cff, exact, K)
        cfg = dup_convert(cfg, exact, K)
        return (h, cff, cfg)
    elif K.is_Field:
        if K.is_QQ and query('USE_HEU_GCD'):
            try:
                return dup_qq_heu_gcd(f, g, K)
            except HeuristicGCDFailed:
                pass
        return dup_ff_prs_gcd(f, g, K)
    else:
        if K.is_ZZ and query('USE_HEU_GCD'):
            try:
                return dup_zz_heu_gcd(f, g, K)
            except HeuristicGCDFailed:
                pass
        return dup_rr_prs_gcd(f, g, K)

.sympy.polys.euclidtools.dup_zz_heu_gcd

def dup_zz_heu_gcd(f, g, K):
    result = _dup_rr_trivial_gcd(f, g, K)
    if result is not None:
        return result
    df = dup_degree(f)
    dg = dup_degree(g)
    gcd, f, g = dup_extract(f, g, K)
    if df == 0 or dg == 0:
        return ([gcd], f, g)
    f_norm = dup_max_norm(f, K)
    g_norm = dup_max_norm(g, K)
    B = K(2 * min(f_norm, g_norm) + 29)
    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dup_LC(f, K)), g_norm // abs(dup_LC(g, K))) + 2)
    for i in range(0, HEU_GCD_MAX):
        ff = dup_eval(f, x, K)
        gg = dup_eval(g, x, K)
        if ff and gg:
            h = K.gcd(ff, gg)
            cff = ff // h
            cfg = gg // h
            h = _dup_zz_gcd_interpolate(h, x, K)
            h = dup_primitive(h, K)[1]
            cff_, r = dup_div(f, h, K)
            if not r:
                cfg_, r = dup_div(g, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff_, cfg_)
            cff = _dup_zz_gcd_interpolate(cff, x, K)
            h, r = dup_div(f, cff, K)
            if not r:
                cfg_, r = dup_div(g, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff, cfg_)
            cfg = _dup_zz_gcd_interpolate(cfg, x, K)
            h, r = dup_div(g, cfg, K)
            if not r:
                cff_, r = dup_div(f, h, K)
                if not r:
                    h = dup_mul_ground(h, gcd, K)
                    return (h, cff_, cfg)
        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011
    raise HeuristicGCDFailed('no luck')

.sympy.polys.euclidtools._dup_rr_trivial_gcd

def _dup_rr_trivial_gcd(f, g, K):
    if not (f or g):
        return ([], [], [])
    elif not f:
        if K.is_nonnegative(dup_LC(g, K)):
            return (g, [], [K.one])
        else:
            return (dup_neg(g, K), [], [-K.one])
    elif not g:
        if K.is_nonnegative(dup_LC(f, K)):
            return (f, [K.one], [])
        else:
            return (dup_neg(f, K), [-K.one], [])
    return None

.sympy.polys.densetools.dup_extract

def dup_extract(f, g, K):
    fc = dup_content(f, K)
    gc = dup_content(g, K)
    gcd = K.gcd(fc, gc)
    if not K.is_one(gcd):
        f = dup_quo_ground(f, gcd, K)
        g = dup_quo_ground(g, gcd, K)
    return (gcd, f, g)

.sympy.polys.densearith.dup_max_norm

def dup_max_norm(f, K):
    if not f:
        return K.zero
    else:
        return max(dup_abs(f, K))

.sympy.polys.densearith.dup_abs

def dup_abs(f, K):
    return [K.abs(coeff) for coeff in f]

.sympy.polys.domains.domain.Domain.abs

def abs(self, a):
    return abs(a)

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.sqrt

def sqrt(self, a):
    return python_sqrt(a)

.sympy.polys.domains.groundtypes.python_sqrt

def python_sqrt(n):
    return int(mlib.isqrt(n))

.sympy.polys.densetools.dup_eval

def dup_eval(f, a, K):
    if not a:
        return dup_TC(f, K)
    result = K.zero
    for c in f:
        result *= a
        result += c
    return result

.sympy.polys.euclidtools._dup_zz_gcd_interpolate

def _dup_zz_gcd_interpolate(h, x, K):
    f = []
    while h:
        g = h % x
        if g > x // 2:
            g -= x
        f.insert(0, g)
        h = (h - g) // x
    return f

.sympy.polys.densearith.dup_quo_ground

def dup_quo_ground(f, c, K):
    if not c:
        raise ZeroDivisionError('polynomial division')
    if not f:
        return f
    if K.is_Field:
        return [K.quo(cf, c) for cf in f]
    else:
        return [cf // c for cf in f]

.sympy.polys.densearith.dup_div

def dup_div(f, g, K):
    if K.is_Field:
        return dup_ff_div(f, g, K)
    else:
        return dup_rr_div(f, g, K)

.sympy.polys.densearith.dup_rr_div

def dup_rr_div(f, g, K):
    df = dup_degree(f)
    dg = dup_degree(g)
    q, r, dr = ([], f, df)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return (q, r)
    lc_g = dup_LC(g, K)
    while True:
        lc_r = dup_LC(r, K)
        if lc_r % lc_g:
            break
        c = K.exquo(lc_r, lc_g)
        j = dr - dg
        q = dup_add_term(q, c, j, K)
        h = dup_mul_term(g, c, j, K)
        r = dup_sub(r, h, K)
        _dr, dr = (dr, dup_degree(r))
        if dr < dg:
            break
        elif not dr < _dr:
            raise PolynomialDivisionFailed(f, g, K)
    return (q, r)

.sympy.polys.domains.ring.Ring.exquo

def exquo(self, a, b):
    if a % b:
        raise ExactQuotientFailed(a, b, self)
    else:
        return a // b

.sympy.polys.densearith.dup_add_term

def dup_add_term(f, c, i, K):
    if not c:
        return f
    n = len(f)
    m = n - i - 1
    if i == n - 1:
        return dup_strip([f[0] + c] + f[1:])
    elif i >= n:
        return [c] + [K.zero] * (i - n) + f
    else:
        return f[:m] + [f[m] + c] + f[m + 1:]

.sympy.polys.densearith.dup_mul_term

def dup_mul_term(f, c, i, K):
    if not c or not f:
        return []
    else:
        return [cf * c for cf in f] + [K.zero] * i

.sympy.polys.densearith.dup_sub

def dup_sub(f, g, K):
    if not f:
        return dup_neg(g, K)
    if not g:
        return f
    df = dup_degree(f)
    dg = dup_degree(g)
    if df == dg:
        return dup_strip([a - b for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (dup_neg(g[:k], K), g[k:])
        return h + [a - b for a, b in zip(f, g)]

.sympy.core.numbers.Infinity.__neg__

def __neg__(self):
    return S.NegativeInfinity

.sympy.core.numbers.NegativeInfinity.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s < %s' % (self, other))
    if other.is_real:
        if other.is_finite or other is S.Infinity:
            return S.true
        elif other.is_nonnegative:
            return S.true
        elif other.is_infinite and other.is_negative:
            return S.false
    return Expr.__lt__(self, other)

.sympy.polys.densearith.dup_mul_ground

def dup_mul_ground(f, c, K):
    if not c or not f:
        return []
    else:
        return [cf * c for cf in f]

.sympy.polys.densearith.dup_quo

def dup_quo(f, g, K):
    return dup_div(f, g, K)[0]

.sympy.polys.factortools.dup_zz_cyclotomic_factor

def dup_zz_cyclotomic_factor(f, K):
    lc_f, tc_f = (dup_LC(f, K), dup_TC(f, K))
    if dup_degree(f) <= 0:
        return None
    if lc_f != 1 or tc_f not in [-1, 1]:
        return None
    if any((bool(cf) for cf in f[1:-1])):
        return None
    n = dup_degree(f)
    F = _dup_cyclotomic_decompose(n, K)
    if not K.is_one(tc_f):
        return F
    else:
        H = []
        for h in _dup_cyclotomic_decompose(2 * n, K):
            if h not in F:
                H.append(h)
        return H

.sympy.polys.factortools.dup_zz_zassenhaus

def dup_zz_zassenhaus(f, K):
    n = dup_degree(f)
    if n == 1:
        return [f]
    fc = f[-1]
    A = dup_max_norm(f, K)
    b = dup_LC(f, K)
    B = int(abs(K.sqrt(K(n + 1)) * 2 ** n * A * b))
    C = int((n + 1) ** (2 * n) * A ** (2 * n - 1))
    gamma = int(_ceil(2 * _log(C, 2)))
    bound = int(2 * gamma * _log(gamma))
    a = []
    for px in range(3, bound + 1):
        if not isprime(px) or b % px == 0:
            continue
        px = K.convert(px)
        F = gf_from_int_poly(f, px)
        if not gf_sqf_p(F, px, K):
            continue
        fsqfx = gf_factor_sqf(F, px, K)[1]
        a.append((px, fsqfx))
        if len(fsqfx) < 15 or len(a) > 4:
            break
    p, fsqf = min(a, key=lambda x: len(x[1]))
    l = int(_ceil(_log(2 * B + 1, p)))
    modular = [gf_to_int_poly(ff, p) for ff in fsqf]
    g = dup_zz_hensel_lift(p, f, modular, l, K)
    sorted_T = range(len(g))
    T = set(sorted_T)
    factors, s = ([], 1)
    pl = p ** l
    while 2 * s <= len(T):
        for S in subsets(sorted_T, s):
            if b == 1:
                q = 1
                for i in S:
                    q = q * g[i][-1]
                q = q % pl
                if not _test_pl(fc, q, pl):
                    continue
            else:
                G = [b]
                for i in S:
                    G = dup_mul(G, g[i], K)
                G = dup_trunc(G, pl, K)
                G = dup_primitive(G, K)[1]
                q = G[-1]
                if q and fc % q != 0:
                    continue
            H = [b]
            S = set(S)
            T_S = T - S
            if b == 1:
                G = [b]
                for i in S:
                    G = dup_mul(G, g[i], K)
                G = dup_trunc(G, pl, K)
            for i in T_S:
                H = dup_mul(H, g[i], K)
            H = dup_trunc(H, pl, K)
            G_norm = dup_l1_norm(G, K)
            H_norm = dup_l1_norm(H, K)
            if G_norm * H_norm <= B:
                T = T_S
                sorted_T = [i for i in sorted_T if i not in S]
                G = dup_primitive(G, K)[1]
                f = dup_primitive(H, K)[1]
                factors.append(G)
                b = dup_LC(f, K)
                break
        else:
            s += 1
    return factors + [f]

.sympy.polys.galoistools.gf_from_int_poly

def gf_from_int_poly(f, p):
    return gf_trunc(f, p)

.sympy.polys.galoistools.gf_trunc

def gf_trunc(f, p):
    return gf_strip([a % p for a in f])

.sympy.polys.galoistools.gf_strip

def gf_strip(f):
    if not f or f[0]:
        return f
    k = 0
    for coeff in f:
        if coeff:
            break
        else:
            k += 1
    return f[k:]

.sympy.polys.galoistools.gf_sqf_p

def gf_sqf_p(f, p, K):
    _, f = gf_monic(f, p, K)
    if not f:
        return True
    else:
        return gf_gcd(f, gf_diff(f, p, K), p, K) == [K.one]

.sympy.polys.galoistools.gf_monic

def gf_monic(f, p, K):
    if not f:
        return (K.zero, [])
    else:
        lc = f[0]
        if K.is_one(lc):
            return (lc, list(f))
        else:
            return (lc, gf_quo_ground(f, lc, p, K))

.sympy.polys.galoistools.gf_diff

def gf_diff(f, p, K):
    df = gf_degree(f)
    h, n = ([K.zero] * df, df)
    for coeff in f[:-1]:
        coeff *= K(n)
        coeff %= p
        if coeff:
            h[df - n] = coeff
        n -= 1
    return gf_strip(h)

.sympy.polys.galoistools.gf_degree

def gf_degree(f):
    return len(f) - 1

.sympy.polys.galoistools.gf_gcd

def gf_gcd(f, g, p, K):
    while g:
        f, g = (g, gf_rem(f, g, p, K))
    return gf_monic(f, p, K)[1]

.sympy.polys.galoistools.gf_rem

def gf_rem(f, g, p, K):
    return gf_div(f, g, p, K)[1]

.sympy.polys.galoistools.gf_div

def gf_div(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return ([], f)
    inv = K.invert(g[0], p)
    h, dq, dr = (list(f), df - dg, dg - 1)
    for i in range(0, df + 1):
        coeff = h[i]
        for j in range(max(0, dg - i), min(df - i, dr) + 1):
            coeff -= h[i + j - dg] * g[dg - j]
        if i <= dq:
            coeff *= inv
        h[i] = coeff % p
    return (h[:dq + 1], gf_strip(h[dq + 1:]))

.sympy.polys.domains.ring.Ring.invert

def invert(self, a, b):
    s, t, h = self.gcdex(a, b)
    if self.is_one(h):
        return s % b
    else:
        raise NotInvertible('zero divisor')

.sympy.polys.domains.pythonintegerring.PythonIntegerRing.gcdex

def gcdex(self, a, b):
    return python_gcdex(a, b)

.sympy.core.numbers.igcdex

def igcdex(a, b):
    if not a and (not b):
        return (0, 1, 0)
    if not a:
        return (0, b // abs(b), abs(b))
    if not b:
        return (a // abs(a), 0, abs(a))
    if a < 0:
        a, x_sign = (-a, -1)
    else:
        x_sign = 1
    if b < 0:
        b, y_sign = (-b, -1)
    else:
        y_sign = 1
    x, y, r, s = (1, 0, 0, 1)
    while b:
        c, q = (a % b, a // b)
        a, b, r, s, x, y = (b, c, x - q * r, y - q * s, r, s)
    return (x * x_sign, y * y_sign, a)

.sympy.polys.galoistools.gf_quo_ground

def gf_quo_ground(f, a, p, K):
    return gf_mul_ground(f, K.invert(a, p), p, K)

.sympy.polys.galoistools.gf_mul_ground

def gf_mul_ground(f, a, p, K):
    if not a:
        return []
    else:
        return [a * b % p for b in f]

.sympy.polys.galoistools.gf_factor_sqf

def gf_factor_sqf(f, p, K, method=None):
    lc, f = gf_monic(f, p, K)
    if gf_degree(f) < 1:
        return (lc, [])
    method = method or query('GF_FACTOR_METHOD')
    if method is not None:
        factors = _factor_methods[method](f, p, K)
    else:
        factors = gf_zassenhaus(f, p, K)
    return (lc, factors)

.sympy.polys.galoistools.gf_zassenhaus

def gf_zassenhaus(f, p, K):
    factors = []
    for factor, n in gf_ddf_zassenhaus(f, p, K):
        factors += gf_edf_zassenhaus(factor, n, p, K)
    return _sort_factors(factors, multiple=False)

.sympy.polys.galoistools.gf_ddf_zassenhaus

def gf_ddf_zassenhaus(f, p, K):
    i, g, factors = (1, [K.one, K.zero], [])
    b = gf_frobenius_monomial_base(f, p, K)
    while 2 * i <= gf_degree(f):
        g = gf_frobenius_map(g, f, b, p, K)
        h = gf_gcd(f, gf_sub(g, [K.one, K.zero], p, K), p, K)
        if h != [K.one]:
            factors.append((h, i))
            f = gf_quo(f, h, p, K)
            g = gf_rem(g, f, p, K)
            b = gf_frobenius_monomial_base(f, p, K)
        i += 1
    if f != [K.one]:
        return factors + [(f, gf_degree(f))]
    else:
        return factors

.sympy.polys.galoistools.gf_frobenius_monomial_base

def gf_frobenius_monomial_base(g, p, K):
    n = gf_degree(g)
    if n == 0:
        return []
    b = [0] * n
    b[0] = [1]
    if p < n:
        for i in range(1, n):
            mon = gf_lshift(b[i - 1], p, K)
            b[i] = gf_rem(mon, g, p, K)
    elif n > 1:
        b[1] = gf_pow_mod([K.one, K.zero], p, g, p, K)
        for i in range(2, n):
            b[i] = gf_mul(b[i - 1], b[1], p, K)
            b[i] = gf_rem(b[i], g, p, K)
    return b

.sympy.polys.galoistools.gf_pow_mod

def gf_pow_mod(f, n, g, p, K):
    if not n:
        return [K.one]
    elif n == 1:
        return gf_rem(f, g, p, K)
    elif n == 2:
        return gf_rem(gf_sqr(f, p, K), g, p, K)
    h = [K.one]
    while True:
        if n & 1:
            h = gf_mul(h, f, p, K)
            h = gf_rem(h, g, p, K)
            n -= 1
        n >>= 1
        if not n:
            break
        f = gf_sqr(f, p, K)
        f = gf_rem(f, g, p, K)
    return h

.sympy.polys.galoistools.gf_mul

def gf_mul(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    dh = df + dg
    h = [0] * (dh + 1)
    for i in range(0, dh + 1):
        coeff = K.zero
        for j in range(max(0, i - dg), min(i, df) + 1):
            coeff += f[j] * g[i - j]
        h[i] = coeff % p
    return gf_strip(h)

.sympy.polys.galoistools.gf_sqr

def gf_sqr(f, p, K):
    df = gf_degree(f)
    dh = 2 * df
    h = [0] * (dh + 1)
    for i in range(0, dh + 1):
        coeff = K.zero
        jmin = max(0, i - df)
        jmax = min(i, df)
        n = jmax - jmin + 1
        jmax = jmin + n // 2 - 1
        for j in range(jmin, jmax + 1):
            coeff += f[j] * f[i - j]
        coeff += coeff
        if n & 1:
            elem = f[jmax + 1]
            coeff += elem ** 2
        h[i] = coeff % p
    return gf_strip(h)

.sympy.polys.galoistools.gf_frobenius_map

def gf_frobenius_map(f, g, b, p, K):
    m = gf_degree(g)
    if gf_degree(f) >= m:
        f = gf_rem(f, g, p, K)
    if not f:
        return []
    n = gf_degree(f)
    sf = [f[-1]]
    for i in range(1, n + 1):
        v = gf_mul_ground(b[i], f[n - i], p, K)
        sf = gf_add(sf, v, p, K)
    return sf

.sympy.polys.galoistools.gf_add

def gf_add(f, g, p, K):
    if not f:
        return g
    if not g:
        return f
    df = gf_degree(f)
    dg = gf_degree(g)
    if df == dg:
        return gf_strip([(a + b) % p for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [(a + b) % p for a, b in zip(f, g)]

.sympy.polys.galoistools.gf_sub

def gf_sub(f, g, p, K):
    if not g:
        return f
    if not f:
        return gf_neg(g, p, K)
    df = gf_degree(f)
    dg = gf_degree(g)
    if df == dg:
        return gf_strip([(a - b) % p for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (gf_neg(g[:k], p, K), g[k:])
        return h + [(a - b) % p for a, b in zip(f, g)]

.sympy.polys.galoistools.gf_quo

def gf_quo(f, g, p, K):
    df = gf_degree(f)
    dg = gf_degree(g)
    if not g:
        raise ZeroDivisionError('polynomial division')
    elif df < dg:
        return []
    inv = K.invert(g[0], p)
    h, dq, dr = (f[:], df - dg, dg - 1)
    for i in range(0, dq + 1):
        coeff = h[i]
        for j in range(max(0, dg - i), min(df - i, dr) + 1):
            coeff -= h[i + j - dg] * g[dg - j]
        h[i] = coeff * inv % p
    return h[:dq + 1]

.sympy.polys.galoistools.gf_edf_zassenhaus

def gf_edf_zassenhaus(f, n, p, K):
    factors, q = ([f], int(p))
    if gf_degree(f) <= n:
        return factors
    N = gf_degree(f) // n
    if p != 2:
        b = gf_frobenius_monomial_base(f, p, K)
    while len(factors) < N:
        r = gf_random(2 * n - 1, p, K)
        if p == 2:
            h = r
            for i in range(0, 2 ** (n * N - 1)):
                r = gf_pow_mod(r, 2, f, p, K)
                h = gf_add(h, r, p, K)
            g = gf_gcd(f, h, p, K)
        else:
            h = _gf_pow_pnm1d2(r, n, f, b, p, K)
            g = gf_gcd(f, gf_sub_ground(h, K.one, p, K), p, K)
        if g != [K.one] and g != f:
            factors = gf_edf_zassenhaus(g, n, p, K) + gf_edf_zassenhaus(gf_quo(f, g, p, K), n, p, K)
    return _sort_factors(factors, multiple=False)

.sympy.polys.galoistools.gf_random

def gf_random(n, p, K):
    return [K.one] + [K(int(uniform(0, p))) for i in range(0, n)]

.sympy.polys.galoistools._gf_pow_pnm1d2

def _gf_pow_pnm1d2(f, n, g, b, p, K):
    f = gf_rem(f, g, p, K)
    h = f
    r = f
    for i in range(1, n):
        h = gf_frobenius_map(h, g, b, p, K)
        r = gf_mul(r, h, p, K)
        r = gf_rem(r, g, p, K)
    res = gf_pow_mod(r, (p - 1) // 2, g, p, K)
    return res

.sympy.polys.galoistools.gf_sub_ground

def gf_sub_ground(f, a, p, K):
    if not f:
        a = -a % p
    else:
        a = (f[-1] - a) % p
        if len(f) > 1:
            return f[:-1] + [a]
    if not a:
        return []
    else:
        return [a]

.sympy.polys.polyutils._sort_factors

def _sort_factors(factors, **args):

    def order_if_multiple_key(factor):
        f, n = factor
        return (len(f), n, f)

    def order_no_multiple_key(f):
        return (len(f), f)
    if args.get('multiple', True):
        return sorted(factors, key=order_if_multiple_key)
    else:
        return sorted(factors, key=order_no_multiple_key)

.sympy.polys.polyutils.order_no_multiple_key

def order_no_multiple_key(f):
    return (len(f), f)

.sympy.polys.galoistools.gf_to_int_poly

def gf_to_int_poly(f, p, symmetric=True):
    if symmetric:
        return [gf_int(c, p) for c in f]
    else:
        return f

.sympy.polys.galoistools.gf_int

def gf_int(a, p):
    if a <= p // 2:
        return a
    else:
        return a - p

.sympy.polys.factortools.dup_zz_hensel_lift

def dup_zz_hensel_lift(p, f, f_list, l, K):
    r = len(f_list)
    lc = dup_LC(f, K)
    if r == 1:
        F = dup_mul_ground(f, K.gcdex(lc, p ** l)[0], K)
        return [dup_trunc(F, p ** l, K)]
    m = p
    k = r // 2
    d = int(_ceil(_log(l, 2)))
    g = gf_from_int_poly([lc], p)
    for f_i in f_list[:k]:
        g = gf_mul(g, gf_from_int_poly(f_i, p), p, K)
    h = gf_from_int_poly(f_list[k], p)
    for f_i in f_list[k + 1:]:
        h = gf_mul(h, gf_from_int_poly(f_i, p), p, K)
    s, t, _ = gf_gcdex(g, h, p, K)
    g = gf_to_int_poly(g, p)
    h = gf_to_int_poly(h, p)
    s = gf_to_int_poly(s, p)
    t = gf_to_int_poly(t, p)
    for _ in range(1, d + 1):
        (g, h, s, t), m = (dup_zz_hensel_step(m, f, g, h, s, t, K), m ** 2)
    return dup_zz_hensel_lift(p, g, f_list[:k], l, K) + dup_zz_hensel_lift(p, h, f_list[k:], l, K)

.sympy.polys.galoistools.gf_gcdex

def gf_gcdex(f, g, p, K):
    if not (f or g):
        return ([K.one], [], [])
    p0, r0 = gf_monic(f, p, K)
    p1, r1 = gf_monic(g, p, K)
    if not f:
        return ([], [K.invert(p1, p)], r1)
    if not g:
        return ([K.invert(p0, p)], [], r0)
    s0, s1 = ([K.invert(p0, p)], [])
    t0, t1 = ([], [K.invert(p1, p)])
    while True:
        Q, R = gf_div(r0, r1, p, K)
        if not R:
            break
        (lc, r1), r0 = (gf_monic(R, p, K), r1)
        inv = K.invert(lc, p)
        s = gf_sub_mul(s0, s1, Q, p, K)
        t = gf_sub_mul(t0, t1, Q, p, K)
        s1, s0 = (gf_mul_ground(s, inv, p, K), s1)
        t1, t0 = (gf_mul_ground(t, inv, p, K), t1)
    return (s1, t1, r1)

.sympy.polys.galoistools.gf_sub_mul

def gf_sub_mul(f, g, h, p, K):
    return gf_sub(f, gf_mul(g, h, p, K), p, K)

.sympy.polys.galoistools.gf_neg

def gf_neg(f, p, K):
    return [-coeff % p for coeff in f]

.sympy.polys.factortools.dup_zz_hensel_step

def dup_zz_hensel_step(m, f, g, h, s, t, K):
    M = m ** 2
    e = dup_sub_mul(f, g, h, K)
    e = dup_trunc(e, M, K)
    q, r = dup_div(dup_mul(s, e, K), h, K)
    q = dup_trunc(q, M, K)
    r = dup_trunc(r, M, K)
    u = dup_add(dup_mul(t, e, K), dup_mul(q, g, K), K)
    G = dup_trunc(dup_add(g, u, K), M, K)
    H = dup_trunc(dup_add(h, r, K), M, K)
    u = dup_add(dup_mul(s, G, K), dup_mul(t, H, K), K)
    b = dup_trunc(dup_sub(u, [K.one], K), M, K)
    c, d = dup_div(dup_mul(s, b, K), H, K)
    c = dup_trunc(c, M, K)
    d = dup_trunc(d, M, K)
    u = dup_add(dup_mul(t, b, K), dup_mul(c, G, K), K)
    S = dup_trunc(dup_sub(s, d, K), M, K)
    T = dup_trunc(dup_sub(t, u, K), M, K)
    return (G, H, S, T)

.sympy.polys.densearith.dup_sub_mul

def dup_sub_mul(f, g, h, K):
    return dup_sub(f, dup_mul(g, h, K), K)

.sympy.polys.densearith.dup_mul

def dup_mul(f, g, K):
    if f == g:
        return dup_sqr(f, K)
    if not (f and g):
        return []
    df = dup_degree(f)
    dg = dup_degree(g)
    n = max(df, dg) + 1
    if n < 100:
        h = []
        for i in range(0, df + dg + 1):
            coeff = K.zero
            for j in range(max(0, i - dg), min(df, i) + 1):
                coeff += f[j] * g[i - j]
            h.append(coeff)
        return dup_strip(h)
    else:
        n2 = n // 2
        fl, gl = (dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K))
        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)
        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)
        lo, hi = (dup_mul(fl, gl, K), dup_mul(fh, gh, K))
        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)
        mid = dup_sub(mid, dup_add(lo, hi, K), K)
        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K), dup_lshift(hi, 2 * n2, K), K)

.sympy.polys.densetools.dup_trunc

def dup_trunc(f, p, K):
    if K.is_ZZ:
        g = []
        for c in f:
            c = c % p
            if c > p // 2:
                g.append(c - p)
            else:
                g.append(c)
    else:
        g = [c % p for c in f]
    return dup_strip(g)

.sympy.polys.densearith.dup_add

def dup_add(f, g, K):
    if not f:
        return g
    if not g:
        return f
    df = dup_degree(f)
    dg = dup_degree(g)
    if df == dg:
        return dup_strip([a + b for a, b in zip(f, g)])
    else:
        k = abs(df - dg)
        if df > dg:
            h, f = (f[:k], f[k:])
        else:
            h, g = (g[:k], g[k:])
        return h + [a + b for a, b in zip(f, g)]

.sympy.utilities.iterables.subsets

def subsets(seq, k=None, repetition=False):
    if k is None:
        for k in range(len(seq) + 1):
            for i in subsets(seq, k, repetition):
                yield i
    elif not repetition:
        for i in combinations(seq, k):
            yield i
    else:
        for i in combinations_with_replacement(seq, k):
            yield i

.sympy.polys.factortools._test_pl

def _test_pl(fc, q, pl):
    if q > pl // 2:
        q = q - pl
    if not q:
        return True
    return fc % q == 0

.sympy.polys.densearith.dup_l1_norm

def dup_l1_norm(f, K):
    if not f:
        return K.zero
    else:
        return sum(dup_abs(f, K))

.sympy.polys.factortools.dup_trial_division

def dup_trial_division(f, factors, K):
    result = []
    for factor in factors:
        k = 0
        while True:
            q, r = dup_div(f, factor, K)
            if not r:
                f, k = (q, k + 1)
            else:
                break
        result.append((factor, k))
    return _sort_factors(result)

.sympy.polys.polyutils.order_if_multiple_key

def order_if_multiple_key(factor):
    f, n = factor
    return (len(f), n, f)

.sympy.polys.polytools.Poly.gen

def gen(self):
    return self.gens[0]

.sympy.polys.polyoptions.BooleanOption.preprocess

def preprocess(cls, value):
    if value in [True, False]:
        return bool(value)
    else:
        raise OptionError("'%s' must have a boolean value assigned, got %s" % (cls.option, value))

.sympy.polys.polyroots._try_heuristics

def _try_heuristics(f):
    if f.is_ground:
        return []
    if f.is_monomial:
        return [S(0)] * f.degree()
    if f.length() == 2:
        if f.degree() == 1:
            return list(map(cancel, roots_linear(f)))
        else:
            return roots_binomial(f)
    result = []
    for i in [-1, 1]:
        if not f.eval(i):
            f = f.quo(Poly(f.gen - i, f.gen))
            result.append(i)
            break
    n = f.degree()
    if n == 1:
        result += list(map(cancel, roots_linear(f)))
    elif n == 2:
        result += list(map(cancel, roots_quadratic(f)))
    elif f.is_cyclotomic:
        result += roots_cyclotomic(f)
    elif n == 3 and cubics:
        result += roots_cubic(f, trig=trig)
    elif n == 4 and quartics:
        result += roots_quartic(f)
    elif n == 5 and quintics:
        result += roots_quintic(f)
    return result

.sympy.polys.polytools.Poly.is_monomial

def is_monomial(f):
    return f.rep.is_monomial

.sympy.polys.polyclasses.DMP.is_monomial

def is_monomial(f):
    return len(f.to_dict()) <= 1

.sympy.polys.polyclasses.DMP.to_dict

def to_dict(f, zero=False):
    return dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)

.sympy.polys.polyroots.roots_linear

def roots_linear(f):
    r = -f.nth(0) / f.nth(1)
    dom = f.get_domain()
    if not dom.is_Numerical:
        if dom.is_Composite:
            r = factor(r)
        else:
            r = simplify(r)
    return [r]

.sympy.polys.polytools.Poly.nth

def nth(f, *N):
    if hasattr(f.rep, 'nth'):
        if len(N) != len(f.gens):
            raise ValueError('exponent of each generator must be specified')
        result = f.rep.nth(*list(map(int, N)))
    else:
        raise OperationNotSupported(f, 'nth')
    return f.rep.dom.to_sympy(result)

.sympy.polys.polyclasses.DMP.nth

def nth(f, *N):
    if all((isinstance(n, int) for n in N)):
        return dmp_ground_nth(f.rep, N, f.lev, f.dom)
    else:
        raise TypeError('a sequence of integers expected')

.sympy.polys.densebasic.dmp_ground_nth

def dmp_ground_nth(f, N, u, K):
    v = u
    for n in N:
        if n < 0:
            raise IndexError('`n` must be non-negative, got %i' % n)
        elif n >= len(f):
            return K.zero
        else:
            d = dmp_degree(f, v)
            if d == -oo:
                d = -1
            f, v = (f[d - n], v - 1)
    return f

.sympy.core.numbers.NegativeOne.__neg__

def __neg__():
    return S.One

.sympy.core.numbers.Rational.__div__

def __div__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            if self.p and other.p == S.Zero:
                return S.ComplexInfinity
            else:
                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))
        elif isinstance(other, Rational):
            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))
        elif isinstance(other, Float):
            return self * (1 / other)
        else:
            return Number.__div__(self, other)
    return Number.__div__(self, other)

.sympy.polys.polytools.cancel

def cancel(f, *gens, **args):
    from sympy.core.exprtools import factor_terms
    from sympy.functions.elementary.piecewise import Piecewise
    options.allowed_flags(args, ['polys'])
    f = sympify(f)
    if not isinstance(f, (tuple, Tuple)):
        if f.is_Number or isinstance(f, Relational) or (not isinstance(f, Expr)):
            return f
        f = factor_terms(f, radical=True)
        p, q = f.as_numer_denom()
    elif len(f) == 2:
        p, q = f
    elif isinstance(f, Tuple):
        return factor_terms(f)
    else:
        raise ValueError('unexpected argument: %s' % f)
    try:
        (F, G), opt = parallel_poly_from_expr((p, q), *gens, **args)
    except PolificationFailed:
        if not isinstance(f, (tuple, Tuple)):
            return f
        else:
            return (S.One, p, q)
    except PolynomialError as msg:
        if f.is_commutative and (not f.has(Piecewise)):
            raise PolynomialError(msg)
        if f.is_Add or f.is_Mul:
            c, nc = sift(f.args, lambda x: x.is_commutative is True and (not x.has(Piecewise)), binary=True)
            nc = [cancel(i) for i in nc]
            return f.func(cancel(f.func._from_args(c)), *nc)
        else:
            reps = []
            pot = preorder_traversal(f)
            next(pot)
            for e in pot:
                if isinstance(e, (tuple, Tuple, BooleanAtom)):
                    continue
                try:
                    reps.append((e, cancel(e)))
                    pot.skip()
                except NotImplementedError:
                    pass
            return f.xreplace(dict(reps))
    c, P, Q = F.cancel(G)
    if not isinstance(f, (tuple, Tuple)):
        return c * (P.as_expr() / Q.as_expr())
    elif not opt.polys:
        return (c, P.as_expr(), Q.as_expr())
    else:
        return (c, P, Q)

.sympy.polys.polyoptions.allowed_flags

def allowed_flags(args, flags):
    flags = set(flags)
    for arg in args.keys():
        try:
            if Options.__options__[arg].is_Flag and (not arg in flags):
                raise FlagError("'%s' flag is not allowed in this context" % arg)
        except KeyError:
            raise OptionError("'%s' is not a valid option" % arg)

.sympy.polys.polyroots._update_dict

def _update_dict(result, root, k):
    if root in result:
        result[root] += k
    else:
        result[root] = k

.sympy.core.numbers.Integer.__neg__

def __neg__(self):
    return Integer(-self.p)

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, **kwargs):
    if kwargs.pop('reeval', True) and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.functions.combinatorial.factorials.RisingFactorial._eval_is_integer

def _eval_is_integer(self):
    return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer, self.args[1].is_nonnegative))

.sympy.core.logic._fuzzy_group

def _fuzzy_group(args, quick_exit=False):
    saw_other = False
    for a in args:
        if a is True:
            continue
        if a is None:
            return
        if quick_exit and saw_other:
            return
        saw_other = True
    return not saw_other

.sympy.core.expr.Expr._eval_is_negative

def _eval_is_negative(self):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
            if n2 is None:
                raise AttributeError
            if n2._prec == 1:
                raise AttributeError
            if n2 == S.NaN:
                raise AttributeError
        except (AttributeError, ValueError):
            return None
        n, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not n.is_Number:
            return False
        if n._prec != 1 and i._prec != 1:
            return bool(not i and n < 0)
        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.expr.Expr._eval_is_positive

def _eval_is_positive(self):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
            if n2 is None:
                raise AttributeError
            if n2._prec == 1:
                raise AttributeError
            if n2 == S.NaN:
                raise AttributeError
        except (AttributeError, ValueError):
            return None
        n, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not n.is_Number:
            return False
        if n._prec != 1 and i._prec != 1:
            return bool(not i and n > 0)
        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.function.Function._eval_is_complex

def _eval_is_complex(self):
    return fuzzy_and((a.is_complex for a in self.args))

.sympy.core.function.Function.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.add.Add._eval_is_zero

def _eval_is_zero(self):
    if self.is_commutative is False:
        return
    nz = []
    z = 0
    im_or_z = False
    im = False
    for a in self.args:
        if a.is_real:
            if a.is_zero:
                z += 1
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im = True
        elif (S.ImaginaryUnit * a).is_real:
            im_or_z = True
        else:
            return
    if z == len(self.args):
        return True
    if len(nz) == len(self.args):
        return None
    b = self.func(*nz)
    if b.is_zero:
        if not im_or_z and (not im):
            return True
        if im and (not im_or_z):
            return False
    if b.is_zero is False:
        return False

.sympy.core.add.Add._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all((x.is_rational is True for x in others)):
                return True
            return None
        if a is None:
            return
    return False

.sympy.core.add.Add._eval_is_positive

def _eval_is_positive(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_positive()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_positive and a.is_nonnegative:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_positive:
                    return True
    pos = nonneg = nonpos = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        ispos = a.is_positive
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((ispos, a.is_nonnegative)))
            if True in saw_INF and False in saw_INF:
                return
        if ispos:
            pos = True
            continue
        elif a.is_nonnegative:
            nonneg = True
            continue
        elif a.is_nonpositive:
            nonpos = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonpos and (not nonneg) and pos:
        return True
    elif not nonpos and pos:
        return True
    elif not pos and (not nonneg):
        return False

.sympy.core.exprtools._monotonic_sign

def _monotonic_sign(self):
    if not self.is_real:
        return
    if (-self).is_Symbol:
        rv = _monotonic_sign(-self)
        return rv if rv is None else -rv
    if not self.is_Add and self.as_numer_denom()[1].is_number:
        s = self
        if s.is_prime:
            if s.is_odd:
                return S(3)
            else:
                return S(2)
        elif s.is_composite:
            if s.is_odd:
                return S(9)
            else:
                return S(4)
        elif s.is_positive:
            if s.is_even:
                if s.is_prime is False:
                    return S(4)
                else:
                    return S(2)
            elif s.is_integer:
                return S.One
            else:
                return _eps
        elif s.is_negative:
            if s.is_even:
                return S(-2)
            elif s.is_integer:
                return S.NegativeOne
            else:
                return -_eps
        if s.is_zero or s.is_nonpositive or s.is_nonnegative:
            return S.Zero
        return None
    free = self.free_symbols
    if len(free) == 1:
        if self.is_polynomial():
            from sympy.polys.polytools import real_roots
            from sympy.polys.polyroots import roots
            from sympy.polys.polyerrors import PolynomialError
            x = free.pop()
            x0 = _monotonic_sign(x)
            if x0 == _eps or x0 == -_eps:
                x0 = S.Zero
            if x0 is not None:
                d = self.diff(x)
                if d.is_number:
                    roots = []
                else:
                    try:
                        roots = real_roots(d)
                    except (PolynomialError, NotImplementedError):
                        roots = [r for r in roots(d, x) if r.is_real]
                y = self.subs(x, x0)
                if x.is_nonnegative and all((r <= x0 for r in roots)):
                    if y.is_nonnegative and d.is_positive:
                        if y:
                            return y if y.is_positive else Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_negative:
                        if y:
                            return y if y.is_negative else Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
                elif x.is_nonpositive and all((r >= x0 for r in roots)):
                    if y.is_nonnegative and d.is_negative:
                        if y:
                            return Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_positive:
                        if y:
                            return Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
        else:
            n, d = self.as_numer_denom()
            den = None
            if n.is_number:
                den = _monotonic_sign(d)
            elif not d.is_number:
                if _monotonic_sign(n) is not None:
                    den = _monotonic_sign(d)
            if den is not None and (den.is_positive or den.is_negative):
                v = n * den
                if v.is_positive:
                    return Dummy('pos', positive=True)
                elif v.is_nonnegative:
                    return Dummy('nneg', nonnegative=True)
                elif v.is_negative:
                    return Dummy('neg', negative=True)
                elif v.is_nonpositive:
                    return Dummy('npos', nonpositive=True)
        return None
    c, a = self.as_coeff_Add()
    v = None
    if not a.is_polynomial():
        n, d = a.as_numer_denom()
        if not (n.is_number or d.is_number):
            return
        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):
            v = S(1)
            for ai in Mul.make_args(a):
                if ai.is_number:
                    v *= ai
                    continue
                reps = {}
                for x in ai.free_symbols:
                    reps[x] = _monotonic_sign(x)
                    if reps[x] is None:
                        return
                v *= ai.subs(reps)
    elif c:
        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):
            free = list(a.free_symbols)
            p = {}
            for i in free:
                v = _monotonic_sign(i)
                if v is None:
                    return
                p[i] = v or (_eps if i.is_nonnegative else -_eps)
            v = a.xreplace(p)
    if v is not None:
        rv = v + c
        if v.is_nonnegative and rv.is_positive:
            return rv.subs(_eps, 0)
        if v.is_nonpositive and rv.is_negative:
            return rv.subs(_eps, 0)

.sympy.core.add.Add._eval_is_negative

def _eval_is_negative(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_negative()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_negative and a.is_nonpositive:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_negative:
                    return True
    neg = nonpos = nonneg = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        isneg = a.is_negative
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((isneg, a.is_nonpositive)))
            if True in saw_INF and False in saw_INF:
                return
        if isneg:
            neg = True
            continue
        elif a.is_nonpositive:
            nonpos = True
            continue
        elif a.is_nonnegative:
            nonneg = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonneg and (not nonpos) and neg:
        return True
    elif not nonneg and neg:
        return True
    elif not neg and (not nonpos):
        return False

.sympy.core.add.Add._eval_is_nonpositive

def _eval_is_nonpositive(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_nonpositive:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_nonpositive:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_nonpositive:
                        return True

.sympy.core.add.Add._eval_is_odd

def _eval_is_odd(self):
    l = [f for f in self.args if not f.is_even is True]
    if not l:
        return False
    if l[0].is_odd:
        return self._new_rawargs(*l[1:]).is_even

.sympy.core.add.Add._eval_is_nonnegative

def _eval_is_nonnegative(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_nonnegative:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_nonnegative:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_nonnegative:
                        return True

.sympy.core.add.Add._eval_is_imaginary

def _eval_is_imaginary(self):
    nz = []
    im_I = []
    for a in self.args:
        if a.is_real:
            if a.is_zero:
                pass
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im_I.append(a * S.ImaginaryUnit)
        elif (S.ImaginaryUnit * a).is_real:
            im_I.append(a * S.ImaginaryUnit)
        else:
            return
    b = self.func(*nz)
    if b.is_zero:
        return fuzzy_not(self.func(*im_I).is_zero)
    elif b.is_zero is False:
        return False

.sympy.core.numbers.Rational._hashable_content

def _hashable_content(self):
    return (self.p, self.q)

.sympy.core.function.Function._eval_is_commutative

def _eval_is_commutative(self):
    return fuzzy_and((a.is_commutative for a in self.args))


[/PYTHON]
What will be the output of `_eval_product`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "term": "1 + n**(-2/3)",
        "limits": [
            "1",
            "oo"
        ]
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
