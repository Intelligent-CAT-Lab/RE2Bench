You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from sympy.matrices.dense import eye
from sympy.core.numbers import Rational, oo
from sympy.matrices.dense import Matrix
from sympy.matrices.dense import Matrix

class LRASolver:

    def __init__(self, A, slack_variables, nonslack_variables, enc_to_boundary, s_subs, testing_mode):
        self.run_checks = testing_mode
        self.s_subs = s_subs
        if any((not isinstance(a, Rational) for a in A)):
            raise UnhandledInput('Non-rational numbers are not handled')
        if any((not isinstance(b.bound, Rational) for b in enc_to_boundary.values())):
            raise UnhandledInput('Non-rational numbers are not handled')
        m, n = (len(slack_variables), len(slack_variables) + len(nonslack_variables))
        if m != 0:
            assert A.shape == (m, n)
        if self.run_checks:
            assert A[:, n - m:] == -eye(m)
        self.enc_to_boundary = enc_to_boundary
        self.boundary_to_enc = {value: key for key, value in enc_to_boundary.items()}
        self.A = A
        self.slack = slack_variables
        self.nonslack = nonslack_variables
        self.all_var = nonslack_variables + slack_variables
        self.slack_set = set(slack_variables)
        self.is_sat = True
        self.result = None

    def _assert_lower(self, xi, ci, from_equality=False, from_neg=False):
        if self.result:
            assert self.result[0] != False
        self.result = None
        if ci <= xi.lower:
            return None
        if ci > xi.upper:
            assert (xi.upper[1] <= 0) is True
            assert (ci[1] >= 0) is True
            lit1, neg1 = Boundary.from_upper(xi)
            lit2 = Boundary(var=xi, const=ci[0], strict=ci[1] != 0, upper=False, equality=from_equality)
            if from_neg:
                lit2 = lit2.get_negated()
            neg2 = -1 if from_neg else 1
            conflict = [-neg1 * self.boundary_to_enc[lit1], -neg2 * self.boundary_to_enc[lit2]]
            self.result = (False, conflict)
            return self.result
        xi.lower = ci
        xi.lower_from_eq = from_equality
        xi.lower_from_neg = from_neg
        if xi in self.nonslack and xi.assign < ci:
            self._update(xi, ci)
        if self.run_checks and all((v.assign[0] != float('inf') and v.assign[0] != -float('inf') for v in self.all_var)):
            M = self.A
            X = Matrix([v.assign[0] for v in self.all_var])
            assert all((abs(val) < 10 ** (-10) for val in M * X))
        return None

    def _update(self, xi, v):
        i = xi.col_idx
        for j, b in enumerate(self.slack):
            aji = self.A[j, i]
            b.assign = b.assign + (v - xi.assign) * aji
        xi.assign = v
[/PYTHON]

Functions called during the execution:
[PYTHON]
sympy.sympy.core.decorators.binary_op_wrapper

@wraps(func)
def binary_op_wrapper(self: T1, other: T2) -> T3:
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:  # type: ignore
            f: Union[Callable[[T1], T3], None] = getattr(other, method_name, None)
            if f is not None:
                return f(self)
    return func(self, other)

sympy.sympy.logic.algorithms.lra_theory.<genexpr>

assert all(abs(val) < 10 ** (-10) for val in M * X)



sympy.sympy.logic.algorithms.lra_theory.<listcomp>

X = Matrix([v.assign[0] for v in self.all_var])


sympy.sympy.logic.algorithms.lra_theory._update

def _update(self, xi, v):
    """
    Updates all slack variables that have equations that contain
    variable xi so that they stay satisfied given xi is equal to v.
    """
    i = xi.col_idx
    for j, b in enumerate(self.slack):
        aji = self.A[j, i]
        b.assign = b.assign + (v - xi.assign)*aji
    xi.assign = v

sympy.sympy.logic.algorithms.lra_theory.__init__

def __init__(self, var, const, upper, equality, strict=None):
    if not equality in [True, False]:
        assert equality in [True, False]


    self.var = var
    if isinstance(const, tuple):
        s = const[1] != 0
        if strict:
            assert s == strict
        self.bound = const[0]
        self.strict = s
    else:
        self.bound = const
        self.strict = strict
    self.upper = upper if not equality else None
    self.equality = equality
    self.strict = strict
    assert self.strict is not None

sympy.sympy.logic.algorithms.lra_theory.from_upper

@staticmethod
def from_upper(var):
    neg = -1 if var.upper_from_neg else 1
    b = Boundary(var, var.upper[0], True, var.upper_from_eq, var.upper[1] != 0)
    if neg < 0:
        b = b.get_negated()
    return b, neg

sympy.sympy.logic.algorithms.lra_theory.get_negated

def get_negated(self):
    return Boundary(self.var, self.bound, not self.upper, self.equality, not self.strict)

sympy.sympy.logic.algorithms.lra_theory.__eq__

def __eq__(self, other):
    if not isinstance(other, LRAVariable):
        return False
    return other.var == self.var

sympy.sympy.logic.algorithms.lra_theory.__hash__

def __hash__(self):
    return hash((self.var, self.bound, self.strict, self.upper, self.equality))

sympy.sympy.logic.algorithms.lra_theory.__lt__

def __lt__(self, other):
    return self.value < other.value

sympy.sympy.logic.algorithms.lra_theory.__le__

def __le__(self, other):
    return self.value <= other.value

sympy.sympy.logic.algorithms.lra_theory.__getitem__

def __getitem__(self, index):
    return self.value[index]

sympy.sympy.logic.boolalg.__bool__

def __bool__(self):
    return False

sympy.sympy.matrices.repmatrix.__new__

def __new__(cls, *args, **kwargs):
    return cls._new(*args, **kwargs)


[/PYTHON]
What will be the output of `_assert_lower`, given the following input:
[INPUT]
```
{
    "self": {
        "run_checks": false,
        "s_subs": {},
        "enc_to_boundary": {
            "2": "'Boundary(Eq(x, 0))'"
        },
        "boundary_to_enc": {
            "'Boundary(Eq(x, 0))'": 2
        },
        "A": "Matrix(0, 1, [])",
        "slack": [],
        "nonslack": [
            "x"
        ],
        "all_var": [
            "x"
        ],
        "slack_set": [],
        "is_sat": true,
        "result": null
    },
    "args": {
        "xi": "x",
        "ci": "(0, 0)",
        "from_equality": true,
        "from_neg": false
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
