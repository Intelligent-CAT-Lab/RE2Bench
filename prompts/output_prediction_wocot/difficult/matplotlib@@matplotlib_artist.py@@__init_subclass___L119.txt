You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from inspect import Signature, Parameter
import matplotlib as mpl
from . import _api, cbook

class Artist:
    zorder = 0

    def __init_subclass__(cls):
        if not hasattr(cls.draw, '_supports_rasterization'):
            cls.draw = _prevent_rasterization(cls.draw)
        if not hasattr(cls.set, '_autogenerated_signature'):
            return
        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
        cls.set.__name__ = 'set'
        cls.set.__qualname__ = f'{cls.__qualname__}.set'
        cls._update_set_signature_and_docstring()
    _PROPERTIES_EXCLUDED_FROM_SET = ['navigate_mode', 'figure', '3d_properties']

    @classmethod
    def _update_set_signature_and_docstring(cls):
        cls.set.__signature__ = Signature([Parameter('self', Parameter.POSITIONAL_OR_KEYWORD), *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_api.UNSET) for prop in ArtistInspector(cls).get_setters() if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])
        cls.set._autogenerated_signature = True
        cls.set.__doc__ = 'Set multiple properties at once.\n\nSupported properties are\n\n' + kwdoc(cls)

    def __init__(self):
        self._stale = True
        self.stale_callback = None
        self._axes = None
        self._parent_figure = None
        self._transform = None
        self._transformSet = False
        self._visible = True
        self._animated = False
        self._alpha = None
        self.clipbox = None
        self._clippath = None
        self._clipon = True
        self._label = ''
        self._picker = None
        self._rasterized = False
        self._agg_filter = None
        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data
        self._callbacks = cbook.CallbackRegistry(signals=['pchanged'])
        try:
            self.axes = None
        except AttributeError:
            pass
        self._remove_method = None
        self._url = None
        self._gid = None
        self._snap = None
        self._sketch = mpl.rcParams['path.sketch']
        self._path_effects = mpl.rcParams['path.effects']
        self._sticky_edges = _XYPair([], [])
        self._in_layout = True

    @property
    def axes(self):
        return self._axes

    @axes.setter
    def axes(self, new_axes):
        if new_axes is not None and self._axes is not None and (new_axes != self._axes):
            raise ValueError('Can not reset the Axes. You are probably trying to reuse an artist in more than one Axes which is not supported')
        self._axes = new_axes
        if new_axes is not None and new_axes is not self:
            self.stale_callback = _stale_axes_callback

    @property
    def stale(self):
        return self._stale

    @stale.setter
    def stale(self, val):
        self._stale = val
        if self._animated:
            return
        if val and self.stale_callback is not None:
            self.stale_callback(self, val)

    def pchanged(self):
        self._callbacks.process('pchanged')
    figure = property(get_figure, set_figure, doc='The (Sub)Figure that the artist is on.  For more control, use the `get_figure` method.')

    def get_visible(self):
        return self._visible

    def draw(self, renderer):
        if not self.get_visible():
            return
        self.stale = False

    def _update_props(self, props, errfmt):
        ret = []
        with cbook._setattr_cm(self, eventson=False):
            for k, v in props.items():
                if k == 'axes':
                    ret.append(setattr(self, k, v))
                else:
                    func = getattr(self, f'set_{k}', None)
                    if not callable(func):
                        raise AttributeError(errfmt.format(cls=type(self), prop_name=k), name=k)
                    ret.append(func(v))
        if ret:
            self.pchanged()
            self.stale = True
        return ret

    def _internal_update(self, kwargs):
        return self._update_props(kwargs, '{cls.__name__}.set() got an unexpected keyword argument {prop_name!r}')

    def set(self, **kwargs):
        return self._internal_update(cbook.normalize_kwargs(kwargs, self))
    mouseover = property(get_mouseover, set_mouseover)
[/PYTHON]

Functions called during the execution:
[PYTHON]
matplotlib.lib.matplotlib.artist._update_set_signature_and_docstring

@classmethod
def _update_set_signature_and_docstring(cls):
    """
    Update the signature of the set function to list all properties
    as keyword arguments.

    Property aliases are not listed in the signature for brevity, but
    are still accepted as keyword arguments.
    """
    cls.set.__signature__ = Signature(
        [Parameter("self", Parameter.POSITIONAL_OR_KEYWORD),
         *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_api.UNSET)
           for prop in ArtistInspector(cls).get_setters()
           if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])
    cls.set._autogenerated_signature = True

    cls.set.__doc__ = (
        "Set multiple properties at once.\n\n"
        "Supported properties are\n\n"
        + kwdoc(cls))

matplotlib.lib.matplotlib.artist._prevent_rasterization

def _prevent_rasterization(draw):
    # We assume that by default artists are not allowed to rasterize (unless
    # its draw method is explicitly decorated). If it is being drawn after a
    # rasterized artist and it has reached a raster_depth of 0, we stop
    # rasterization so that it does not affect the behavior of normal artist
    # (e.g., change in dpi).

    @wraps(draw)
    def draw_wrapper(artist, renderer, *args, **kwargs):
        if renderer._raster_depth == 0 and renderer._rasterizing:
            # Only stop when we are not in a rasterized parent
            # and something has been rasterized since last stop.
            renderer.stop_rasterizing()
            renderer._rasterizing = False

        return draw(artist, renderer, *args, **kwargs)

    draw_wrapper._supports_rasterization = False
    return draw_wrapper


[/PYTHON]
What will be the output of `__init_subclass__`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "cls": "<class 'matplotlib.tests.test_artist.test_artist_inspector_get_valid_values.<locals>.TestArtist'>"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
