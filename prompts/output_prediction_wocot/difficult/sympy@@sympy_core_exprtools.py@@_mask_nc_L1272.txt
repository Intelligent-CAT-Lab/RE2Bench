You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. The output structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict output variable values to fill out placeholders XXX in the structure, and print output between [OUTPUT] and [/OUTPUT]. You should maintain the structure when printing output. Do not change anything else. ONLY print the output, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from .sorting import default_sort_key, ordered
from .symbol import Dummy
from .traversal import preorder_traversal
from .symbol import Dummy

def _mask_nc(eq, name=None):
    name = name or 'mask'

    def numbered_names():
        i = 0
        while True:
            yield (name + str(i))
            i += 1
    names = numbered_names()

    def Dummy(*args, **kwargs):
        from .symbol import Dummy
        return Dummy(next(names), *args, **kwargs)
    expr = eq
    if expr.is_commutative:
        return (eq, {}, [])
    rep = []
    nc_obj = set()
    nc_syms = set()
    pot = preorder_traversal(expr, keys=default_sort_key)
    for a in pot:
        if any((a == r[0] for r in rep)):
            pot.skip()
        elif not a.is_commutative:
            if a.is_symbol:
                nc_syms.add(a)
                pot.skip()
            elif not (a.is_Add or a.is_Mul or a.is_Pow):
                nc_obj.add(a)
                pot.skip()
    if len(nc_obj) == 1 and (not nc_syms):
        rep.append((nc_obj.pop(), Dummy()))
    elif len(nc_syms) == 1 and (not nc_obj):
        rep.append((nc_syms.pop(), Dummy()))
    nc_obj = sorted(nc_obj, key=default_sort_key)
    for n in nc_obj:
        nc = Dummy(commutative=False)
        rep.append((n, nc))
        nc_syms.add(nc)
    expr = expr.subs(rep)
    nc_syms = list(nc_syms)
    nc_syms.sort(key=default_sort_key)
    return (expr, {v: k for k, v in rep}, nc_syms)
[/PYTHON]

Functions called during the execution:
[PYTHON]
sympy.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

sympy.sympy.core.basic.__hash__

def __hash__(self) -> int:
    # hash cannot be cached using cache_it because infinite recurrence
    # occurs as hash is needed for setting cache dictionary keys
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

sympy.sympy.core.basic.__eq__

def __eq__(self, other):
    """Return a boolean indicating whether a == b on the basis of
    their symbolic trees.

    This is the same as a.compare(b) == 0 but faster.

    Notes
    =====

    If a class that overrides __eq__() needs to retain the
    implementation of __hash__() from a parent class, the
    interpreter must be told this explicitly by setting
    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.
    Otherwise the inheritance of __hash__() will be blocked,
    just as if __hash__ had been explicitly set to None.

    References
    ==========

    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__
    """
    if self is other:
        return True

    if not isinstance(other, Basic):
        return self._do_eq_sympify(other)

    # check for pure number expr
    if  not (self.is_Number and other.is_Number) and (
            type(self) != type(other)):
        return False
    a, b = self._hashable_content(), other._hashable_content()
    if a != b:
        return False
    # check number *in* an expression
    for a, b in zip(a, b):
        if not isinstance(a, Basic):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

sympy.sympy.core.basic.subs

def subs(self, arg1: Mapping[Basic | complex, Basic | complex]
        | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex,
         arg2: Basic | complex | None = None, **kwargs: Any) -> Basic:
    """
    Substitutes old for new in an expression after sympifying args.

    `args` is either:
      - two arguments, e.g. foo.subs(old, new)
      - one iterable argument, e.g. foo.subs(iterable). The iterable may be
         o an iterable container with (old, new) pairs. In this case the
           replacements are processed in the order given with successive
           patterns possibly affecting replacements already made.
         o a dict or set whose key/value items correspond to old/new pairs.
           In this case the old/new pairs will be sorted by op count and in
           case of a tie, by number of args and the default_sort_key. The
           resulting sorted list is then processed as an iterable container
           (see previous).

    If the keyword ``simultaneous`` is True, the subexpressions will not be
    evaluated until all the substitutions have been made.

    Examples
    ========

    >>> from sympy import pi, exp, limit, oo
    >>> from sympy.abc import x, y
    >>> (1 + x*y).subs(x, pi)
    pi*y + 1
    >>> (1 + x*y).subs({x:pi, y:2})
    1 + 2*pi
    >>> (1 + x*y).subs([(x, pi), (y, 2)])
    1 + 2*pi
    >>> reps = [(y, x**2), (x, 2)]
    >>> (x + y).subs(reps)
    6
    >>> (x + y).subs(reversed(reps))
    x**2 + 2

    >>> (x**2 + x**4).subs(x**2, y)
    y**2 + y

    To replace only the x**2 but not the x**4, use xreplace:

    >>> (x**2 + x**4).xreplace({x**2: y})
    x**4 + y

    To delay evaluation until all substitutions have been made,
    set the keyword ``simultaneous`` to True:

    >>> (x/y).subs([(x, 0), (y, 0)])
    0
    >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
    nan

    This has the added feature of not allowing subsequent substitutions
    to affect those already made:

    >>> ((x + y)/y).subs({x + y: y, y: x + y})
    1
    >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
    y/(x + y)

    In order to obtain a canonical result, unordered iterables are
    sorted by count_op length, number of arguments and by the
    default_sort_key to break any ties. All other iterables are left
    unsorted.

    >>> from sympy import sqrt, sin, cos
    >>> from sympy.abc import a, b, c, d, e

    >>> A = (sqrt(sin(2*x)), a)
    >>> B = (sin(2*x), b)
    >>> C = (cos(2*x), c)
    >>> D = (x, d)
    >>> E = (exp(x), e)

    >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)

    >>> expr.subs(dict([A, B, C, D, E]))
    a*c*sin(d*e) + b

    The resulting expression represents a literal replacement of the
    old arguments with the new arguments. This may not reflect the
    limiting behavior of the expression:

    >>> (x**3 - 3*x).subs({x: oo})
    nan

    >>> limit(x**3 - 3*x, x, oo)
    oo

    If the substitution will be followed by numerical
    evaluation, it is better to pass the substitution to
    evalf as

    >>> (1/x).evalf(subs={x: 3.0}, n=21)
    0.333333333333333333333

    rather than

    >>> (1/x).subs({x: 3.0}).evalf(21)
    0.333333333333333314830

    as the former will ensure that the desired level of precision is
    obtained.

    See Also
    ========
    replace: replacement capable of doing wildcard-like matching,
             parsing of match, and conditional replacements
    xreplace: exact node replacement in expr tree; also capable of
              using matching rules
    sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision

    """
    from .containers import Dict
    from .symbol import Dummy, Symbol
    from .numbers import _illegal

    items: Iterable[tuple[Basic | complex, Basic | complex]]

    unordered = False
    if arg2 is None:

        if isinstance(arg1, set):
            items = arg1
            unordered = True
        elif isinstance(arg1, (Dict, Mapping)):
            unordered = True
            items = arg1.items() # type: ignore
        elif not iterable(arg1):
            raise ValueError(filldedent("""
               When a single argument is passed to subs
               it should be a dictionary of old: new pairs or an iterable
               of (old, new) tuples."""))
        else:
            items = arg1 # type: ignore
    else:
        items = [(arg1, arg2)] # type: ignore

    def sympify_old(old) -> Basic:
        if isinstance(old, str):
            # Use Symbol rather than parse_expr for old
            return Symbol(old)
        elif isinstance(old, type):
            # Allow a type e.g. Function('f') or sin
            return sympify(old, strict=False)
        else:
            return sympify(old, strict=True)

    def sympify_new(new) -> Basic:
        if isinstance(new, (str, type)):
            # Allow a type or parse a string input
            return sympify(new, strict=False)
        else:
            return sympify(new, strict=True)

    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in items]

    # skip if there is no change
    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]

    simultaneous = kwargs.pop('simultaneous', False)

    if unordered:
        from .sorting import _nodes, default_sort_key
        sequence_dict = dict(sequence)
        # order so more complex items are first and items
        # of identical complexity are ordered so
        # f(x) < f(y) < x < y
        # \___ 2 __/    \_1_/  <- number of nodes
        #
        # For more complex ordering use an unordered sequence.
        k = list(ordered(sequence_dict, default=False, keys=(
            lambda x: -_nodes(x),
            default_sort_key,
            )))
        sequence = [(k, sequence_dict[k]) for k in k]
        # do infinities first
        if not simultaneous:
            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]
            for i in reversed(redo):
                sequence.insert(0, sequence.pop(i))

    if simultaneous:  # XXX should this be the default for dict subs?
        reps = {}
        rv = self
        kwargs['hack2'] = True
        m = Dummy('subs_m')
        for old, new in sequence:
            com = new.is_commutative
            if com is None:
                com = True
            d = Dummy('subs_d', commutative=com)
            # using d*m so Subs will be used on dummy variables
            # in things like Derivative(f(x, y), x) in which x
            # is both free and bound
            rv = rv._subs(old, d*m, **kwargs)
            if not isinstance(rv, Basic):
                break
            reps[d] = new
        reps[m] = S.One  # get rid of m
        return rv.xreplace(reps)
    else:
        rv = self
        for old, new in sequence:
            rv = rv._subs(old, new, **kwargs)
            if not isinstance(rv, Basic):
                break
        return rv

sympy.sympy.core.exprtools.Dummy

def Dummy(*args, **kwargs):
    from .symbol import Dummy
    return Dummy(next(names), *args, **kwargs)

sympy.sympy.core.exprtools.<genexpr>

if any(a == r[0] for r in rep):
    pot.skip()


sympy.sympy.core.exprtools.<dictcomp>

return expr, {v: k for k, v in rep}, nc_syms




sympy.sympy.core.sorting.default_sort_key

def default_sort_key(item, order=None):
    """Return a key that can be used for sorting.

    The key has the structure:

    (class_key, (len(args), args), exponent.sort_key(), coefficient)

    This key is supplied by the sort_key routine of Basic objects when
    ``item`` is a Basic object or an object (other than a string) that
    sympifies to a Basic object. Otherwise, this function produces the
    key.

    The ``order`` argument is passed along to the sort_key routine and is
    used to determine how the terms *within* an expression are ordered.
    (See examples below) ``order`` options are: 'lex', 'grlex', 'grevlex',
    and reversed values of the same (e.g. 'rev-lex'). The default order
    value is None (which translates to 'lex').

    Examples
    ========

    >>> from sympy import S, I, default_sort_key, sin, cos, sqrt
    >>> from sympy.core.function import UndefinedFunction
    >>> from sympy.abc import x

    The following are equivalent ways of getting the key for an object:

    >>> x.sort_key() == default_sort_key(x)
    True

    Here are some examples of the key that is produced:

    >>> default_sort_key(UndefinedFunction('f'))
    ((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),
        (0, ()), (), 1), 1)
    >>> default_sort_key('1')
    ((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)
    >>> default_sort_key(S.One)
    ((1, 0, 'Number'), (0, ()), (), 1)
    >>> default_sort_key(2)
    ((1, 0, 'Number'), (0, ()), (), 2)

    While sort_key is a method only defined for SymPy objects,
    default_sort_key will accept anything as an argument so it is
    more robust as a sorting key. For the following, using key=
    lambda i: i.sort_key() would fail because 2 does not have a sort_key
    method; that's why default_sort_key is used. Note, that it also
    handles sympification of non-string items likes ints:

    >>> a = [2, I, -I]
    >>> sorted(a, key=default_sort_key)
    [2, -I, I]

    The returned key can be used anywhere that a key can be specified for
    a function, e.g. sort, min, max, etc...:

    >>> a.sort(key=default_sort_key); a[0]
    2
    >>> min(a, key=default_sort_key)
    2

    Notes
    =====

    The key returned is useful for getting items into a canonical order
    that will be the same across platforms. It is not directly useful for
    sorting lists of expressions:

    >>> a, b = x, 1/x

    Since ``a`` has only 1 term, its value of sort_key is unaffected by
    ``order``:

    >>> a.sort_key() == a.sort_key('rev-lex')
    True

    If ``a`` and ``b`` are combined then the key will differ because there
    are terms that can be ordered:

    >>> eq = a + b
    >>> eq.sort_key() == eq.sort_key('rev-lex')
    False
    >>> eq.as_ordered_terms()
    [x, 1/x]
    >>> eq.as_ordered_terms('rev-lex')
    [1/x, x]

    But since the keys for each of these terms are independent of ``order``'s
    value, they do not sort differently when they appear separately in a list:

    >>> sorted(eq.args, key=default_sort_key)
    [1/x, x]
    >>> sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))
    [1/x, x]

    The order of terms obtained when using these keys is the order that would
    be obtained if those terms were *factors* in a product.

    Although it is useful for quickly putting expressions in canonical order,
    it does not sort expressions based on their complexity defined by the
    number of operations, power of variables and others:

    >>> sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)
    [sin(x)*cos(x), sin(x)]
    >>> sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)
    [sqrt(x), x, x**2, x**3]

    See Also
    ========

    ordered, sympy.core.expr.Expr.as_ordered_factors, sympy.core.expr.Expr.as_ordered_terms

    """
    from .basic import Basic
    from .singleton import S

    if isinstance(item, Basic):
        return item.sort_key(order=order)

    if iterable(item, exclude=str):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            # e.g. tuple, list
            args = list(item)
            unordered = False

        args = [default_sort_key(arg, order=order) for arg in args]

        if unordered:
            # e.g. dict, set
            args = sorted(args)

        cls_index, args = 10, (len(args), tuple(args))
    else:
        if not isinstance(item, str):
            try:
                item = sympify(item, strict=True)
            except SympifyError:
                # e.g. lambda x: x
                pass
            else:
                if isinstance(item, Basic):
                    # e.g int -> Integer
                    return default_sort_key(item)
                # e.g. UndefinedFunction

        # e.g. str
        cls_index, args = 0, (1, (str(item),))

    return (cls_index, 0, item.__class__.__name__
            ), args, S.One.sort_key(), S.One

sympy.sympy.core.traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

sympy.sympy.core.traversal.skip

def skip(self):
    """
    Skip yielding current node's (last yielded node's) subtrees.

    Examples
    ========

    >>> from sympy import preorder_traversal, symbols
    >>> x, y, z = symbols('x y z')
    >>> pt = preorder_traversal((x + y*z)*z)
    >>> for i in pt:
    ...     print(i)
    ...     if i == x + y*z:
    ...             pt.skip()
    z*(x + y*z)
    z
    x + y*z
    """
    self._skip_flag = True

sympy.sympy.core.traversal.__next__

def __next__(self):
    return next(self._pt)

sympy.sympy.core.traversal.__iter__

def __iter__(self) -> Iterator[Basic]:
    return self


[/PYTHON]
What will be the output of `_mask_nc`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "eq": "2 - 2*cos(phi)",
        "name": null
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
