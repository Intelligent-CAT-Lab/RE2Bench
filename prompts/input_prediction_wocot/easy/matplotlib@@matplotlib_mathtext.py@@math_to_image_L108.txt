You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [/INPUT]. You should maintain the structure when printing inputs. Do not change anything else.  ONLY print the input, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from matplotlib import figure

def math_to_image(s, filename_or_obj, prop=None, dpi=None, format=None, *, color=None):
    from matplotlib import figure
    parser = MathTextParser('path')
    width, height, depth, _, _ = parser.parse(s, dpi=72, prop=prop)
    fig = figure.Figure(figsize=(width / 72.0, height / 72.0))
    fig.text(0, depth / height, s, fontproperties=prop, color=color)
    fig.savefig(filename_or_obj, dpi=dpi, format=format)
    return depth
[/PYTHON]

Functions called during the execution:
[PYTHON]
matplotlib.lib.matplotlib.figure.text

@_docstring.interpd
def text(self, x, y, s, fontdict=None, **kwargs):
    """
    Add text to figure.

    Parameters
    ----------
    x, y : float
        The position to place the text. By default, this is in figure
        coordinates, floats in [0, 1]. The coordinate system can be changed
        using the *transform* keyword.

    s : str
        The text string.

    fontdict : dict, optional
        A dictionary to override the default text properties. If not given,
        the defaults are determined by :rc:`font.*`. Properties passed as
        *kwargs* override the corresponding ones given in *fontdict*.

    Returns
    -------
    `~.text.Text`

    Other Parameters
    ----------------
    **kwargs : `~matplotlib.text.Text` properties
        Other miscellaneous text parameters.

        %(Text:kwdoc)s

    See Also
    --------
    .Axes.text
    .pyplot.text
    """
    effective_kwargs = {
        'transform': self.transSubfigure,
        **(fontdict if fontdict is not None else {}),
        **kwargs,
    }
    text = Text(x=x, y=y, text=s, **effective_kwargs)
    text.set_figure(self)
    text.stale_callback = _stale_figure_callback

    self.texts.append(text)
    text._remove_method = self.texts.remove
    self.stale = True
    return text

matplotlib.lib.matplotlib.figure.__init__

    def __init__(self,
                 figsize=None,
                 dpi=None,
                 *,
                 facecolor=None,
                 edgecolor=None,
                 linewidth=0.0,
                 frameon=None,
                 subplotpars=None,  # rc figure.subplot.*
                 tight_layout=None,  # rc figure.autolayout
                 constrained_layout=None,  # rc figure.constrained_layout.use
                 layout=None,
                 **kwargs
                 ):
        """
        Parameters
        ----------
        figsize : (float, float) or (float, float, str), default: :rc:`figure.figsize`
            The figure dimensions. This can be

            - a tuple ``(width, height, unit)``, where *unit* is one of "in" (inch),
              "cm" (centimenter), "px" (pixel).
            - a tuple ``(width, height)``, which is interpreted in inches, i.e. as
              ``(width, height, "in")``.

        dpi : float, default: :rc:`figure.dpi`
            Dots per inch.

        facecolor : default: :rc:`figure.facecolor`
            The figure patch facecolor.

        edgecolor : default: :rc:`figure.edgecolor`
            The figure patch edge color.

        linewidth : float
            The linewidth of the frame (i.e. the edge linewidth of the figure
            patch).

        frameon : bool, default: :rc:`figure.frameon`
            If ``False``, suppress drawing the figure background patch.

        subplotpars : `~matplotlib.gridspec.SubplotParams`
            Subplot parameters. If not given, the default subplot
            parameters :rc:`figure.subplot.*` are used.

        tight_layout : bool or dict, default: :rc:`figure.autolayout`
            Whether to use the tight layout mechanism. See `.set_tight_layout`.

            .. admonition:: Discouraged

                The use of this parameter is discouraged. Please use
                ``layout='tight'`` instead for the common case of
                ``tight_layout=True`` and use `.set_tight_layout` otherwise.

        constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
            This is equal to ``layout='constrained'``.

            .. admonition:: Discouraged

                The use of this parameter is discouraged. Please use
                ``layout='constrained'`` instead.

        layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
None}, default: None
            The layout mechanism for positioning of plot elements to avoid
            overlapping Axes decorations (labels, ticks, etc). Note that
            layout managers can have significant performance penalties.

            - 'constrained': The constrained layout solver adjusts Axes sizes
              to avoid overlapping Axes decorations.  Can handle complex plot
              layouts and colorbars, and is thus recommended.

              See :ref:`constrainedlayout_guide` for examples.

            - 'compressed': uses the same algorithm as 'constrained', but
              removes extra space between fixed-aspect-ratio Axes.  Best for
              simple grids of Axes.

            - 'tight': Use the tight layout mechanism. This is a relatively
              simple algorithm that adjusts the subplot parameters so that
              decorations do not overlap.

              See :ref:`tight_layout_guide` for examples.

            - 'none': Do not use a layout engine.

            - A `.LayoutEngine` instance. Builtin layout classes are
              `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
              accessible by 'constrained' and 'tight'.  Passing an instance
              allows third parties to provide their own layout engine.

            If not given, fall back to using the parameters *tight_layout* and
            *constrained_layout*, including their config defaults
            :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.

        Other Parameters
        ----------------
        **kwargs : `.Figure` properties, optional

            %(Figure:kwdoc)s
        """
        super().__init__(**kwargs)
        self._root_figure = self
        self._layout_engine = None

        if layout is not None:
            if (tight_layout is not None):
                _api.warn_external(
                    "The Figure parameters 'layout' and 'tight_layout' cannot "
                    "be used together. Please use 'layout' only.")
            if (constrained_layout is not None):
                _api.warn_external(
                    "The Figure parameters 'layout' and 'constrained_layout' "
                    "cannot be used together. Please use 'layout' only.")
            self.set_layout_engine(layout=layout)
        elif tight_layout is not None:
            if constrained_layout is not None:
                _api.warn_external(
                    "The Figure parameters 'tight_layout' and "
                    "'constrained_layout' cannot be used together. Please use "
                    "'layout' parameter")
            self.set_layout_engine(layout='tight')
            if isinstance(tight_layout, dict):
                self.get_layout_engine().set(**tight_layout)
        elif constrained_layout is not None:
            if isinstance(constrained_layout, dict):
                self.set_layout_engine(layout='constrained')
                self.get_layout_engine().set(**constrained_layout)
            elif constrained_layout:
                self.set_layout_engine(layout='constrained')

        else:
            # everything is None, so use default:
            self.set_layout_engine(layout=layout)

        # Callbacks traditionally associated with the canvas (and exposed with
        # a proxy property), but that actually need to be on the figure for
        # pickling.
        self._canvas_callbacks = cbook.CallbackRegistry(
            signals=FigureCanvasBase.events)
        connect = self._canvas_callbacks._connect_picklable
        self._mouse_key_ids = [
            connect('key_press_event', backend_bases._key_handler),
            connect('key_release_event', backend_bases._key_handler),
            connect('key_release_event', backend_bases._key_handler),
            connect('button_press_event', backend_bases._mouse_handler),
            connect('button_release_event', backend_bases._mouse_handler),
            connect('scroll_event', backend_bases._mouse_handler),
            connect('motion_notify_event', backend_bases._mouse_handler),
        ]
        self._button_pick_id = connect('button_press_event', self.pick)
        self._scroll_pick_id = connect('scroll_event', self.pick)

        figsize = mpl._val_or_rc(figsize, 'figure.figsize')
        dpi = mpl._val_or_rc(dpi, 'figure.dpi')
        facecolor = mpl._val_or_rc(facecolor, 'figure.facecolor')
        edgecolor = mpl._val_or_rc(edgecolor, 'figure.edgecolor')
        frameon = mpl._val_or_rc(frameon, 'figure.frameon')

        figsize = _parse_figsize(figsize, dpi)

        if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
            raise ValueError('figure size must be positive finite not '
                             f'{figsize}')
        self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)

        self.dpi_scale_trans = Affine2D().scale(dpi)
        # do not use property as it will trigger
        self._dpi = dpi
        self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
        self.figbbox = self.bbox
        self.transFigure = BboxTransformTo(self.bbox)
        self.transSubfigure = self.transFigure

        self.patch = Rectangle(
            xy=(0, 0), width=1, height=1, visible=frameon,
            facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
            # Don't let the figure patch influence bbox calculation.
            in_layout=False)
        self._set_artist_props(self.patch)
        self.patch.set_antialiased(False)

        self._set_base_canvas()

        if subplotpars is None:
            subplotpars = SubplotParams()

        self.subplotpars = subplotpars

        self._axstack = _AxesStack()  # track all figure Axes and current Axes
        self.clear()

matplotlib.lib.matplotlib.figure.savefig

def savefig(self, fname, *, transparent=None, **kwargs):
    """
    Save the current figure as an image or vector graphic to a file.

    Call signature::

      savefig(fname, *, transparent=None, dpi='figure', format=None,
              metadata=None, bbox_inches=None, pad_inches=0.1,
              facecolor='auto', edgecolor='auto', backend=None,
              **kwargs
             )

    The available output formats depend on the backend being used.

    Parameters
    ----------
    fname : str or path-like or binary file-like
        A path, or a Python file-like object, or
        possibly some backend-dependent object such as
        `matplotlib.backends.backend_pdf.PdfPages`.

        If *format* is set, it determines the output format, and the file
        is saved as *fname*.  Note that *fname* is used verbatim, and there
        is no attempt to make the extension, if any, of *fname* match
        *format*, and no extension is appended.

        If *format* is not set, then the format is inferred from the
        extension of *fname*, if there is one.  If *format* is not
        set and *fname* has no extension, then the file is saved with
        :rc:`savefig.format` and the appropriate extension is appended to
        *fname*.

    Other Parameters
    ----------------
    transparent : bool, default: :rc:`savefig.transparent`
        If *True*, the Axes patches will all be transparent; the
        Figure patch will also be transparent unless *facecolor*
        and/or *edgecolor* are specified via kwargs.

        If *False* has no effect and the color of the Axes and
        Figure patches are unchanged (unless the Figure patch
        is specified via the *facecolor* and/or *edgecolor* keyword
        arguments in which case those colors are used).

        The transparency of these patches will be restored to their
        original values upon exit of this function.

        This is useful, for example, for displaying
        a plot on top of a colored background on a web page.

    dpi : float or 'figure', default: :rc:`savefig.dpi`
        The resolution in dots per inch.  If 'figure', use the figure's
        dpi value.

    format : str
        The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
        this is unset is documented under *fname*.

    metadata : dict, optional
        Key/value pairs to store in the image metadata. The supported keys
        and defaults depend on the image format and backend:

        - 'png' with Agg backend: See the parameter ``metadata`` of
          `~.FigureCanvasAgg.print_png`.
        - 'pdf' with pdf backend: See the parameter ``metadata`` of
          `~.backend_pdf.PdfPages`.
        - 'svg' with svg backend: See the parameter ``metadata`` of
          `~.FigureCanvasSVG.print_svg`.
        - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.

        Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
        embedding metadata.
        Does not currently support 'jpg', 'tiff', or 'webp', but may include
        embedding EXIF metadata in the future.

    bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
        Bounding box in inches: only the given portion of the figure is
        saved.  If 'tight', try to figure out the tight bbox of the figure.

    pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
        Amount of padding in inches around the figure when bbox_inches is
        'tight'. If 'layout' use the padding from the constrained or
        compressed layout engine; ignored if one of those engines is not in
        use.

    facecolor : :mpltype:`color` or 'auto', default: :rc:`savefig.facecolor`
        The facecolor of the figure.  If 'auto', use the current figure
        facecolor.

    edgecolor : :mpltype:`color` or 'auto', default: :rc:`savefig.edgecolor`
        The edgecolor of the figure.  If 'auto', use the current figure
        edgecolor.

    backend : str, optional
        Use a non-default backend to render the file, e.g. to render a
        png file with the "cairo" backend rather than the default "agg",
        or a pdf file with the "pgf" backend rather than the default
        "pdf".  Note that the default backend is normally sufficient.  See
        :ref:`the-builtin-backends` for a list of valid backends for each
        file format.  Custom backends can be referenced as "module://...".

    orientation : {'landscape', 'portrait'}
        Currently only supported by the postscript backend.

    papertype : str
        One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
        'a10', 'b0' through 'b10'. Only supported for postscript
        output.

    bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
        A list of extra artists that will be considered when the
        tight bbox is calculated.

    pil_kwargs : dict, optional
        Additional keyword arguments that are passed to
        `PIL.Image.Image.save` when saving the figure.

    """

    kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
    transparent = mpl._val_or_rc(transparent, 'savefig.transparent')

    with ExitStack() as stack:
        if transparent:
            def _recursively_make_subfig_transparent(exit_stack, subfig):
                exit_stack.enter_context(
                    subfig.patch._cm_set(
                        facecolor="none", edgecolor="none"))
                for ax in subfig.axes:
                    exit_stack.enter_context(
                        ax.patch._cm_set(
                            facecolor="none", edgecolor="none"))
                for sub_subfig in subfig.subfigs:
                    _recursively_make_subfig_transparent(
                        exit_stack, sub_subfig)

            def _recursively_make_axes_transparent(exit_stack, ax):
                exit_stack.enter_context(
                    ax.patch._cm_set(facecolor="none", edgecolor="none"))
                for child_ax in ax.child_axes:
                    exit_stack.enter_context(
                        child_ax.patch._cm_set(
                            facecolor="none", edgecolor="none"))
                for child_childax in ax.child_axes:
                    _recursively_make_axes_transparent(
                        exit_stack, child_childax)

            kwargs.setdefault('facecolor', 'none')
            kwargs.setdefault('edgecolor', 'none')
            # set subfigure to appear transparent in printed image
            for subfig in self.subfigs:
                _recursively_make_subfig_transparent(stack, subfig)
            # set Axes to be transparent
            for ax in self.axes:
                _recursively_make_axes_transparent(stack, ax)
        self.canvas.print_figure(fname, **kwargs)

matplotlib.lib.matplotlib.mathtext.__init__

def __init__(self, output):
    """
    Create a MathTextParser for the given backend *output*.

    Parameters
    ----------
    output : {"path", "agg"}
        Whether to return a `VectorParse` ("path") or a
        `RasterParse` ("agg", or its synonym "macosx").
    """
    self._output_type = _api.check_getitem(
        {"path": "vector", "agg": "raster", "macosx": "raster"},
        output=output.lower())

matplotlib.lib.matplotlib.mathtext.parse

def parse(self, s, dpi=72, prop=None, *, antialiased=None):
    """
    Parse the given math expression *s* at the given *dpi*.  If *prop* is
    provided, it is a `.FontProperties` object specifying the "default"
    font to use in the math expression, used for all non-math text.

    The results are cached, so multiple calls to `parse`
    with the same expression should be fast.

    Depending on the *output* type, this returns either a `VectorParse` or
    a `RasterParse`.
    """
    # lru_cache can't decorate parse() directly because prop is
    # mutable, so we key the cache using an internal copy (see
    # Text._get_text_metrics_with_cache for a similar case); likewise,
    # we need to check the mutable state of the text.antialiased and
    # text.hinting rcParams.
    prop = prop.copy() if prop is not None else None
    antialiased = mpl._val_or_rc(antialiased, 'text.antialiased')
    from matplotlib.backends import backend_agg
    load_glyph_flags = {
        "vector": LoadFlags.NO_HINTING,
        "raster": backend_agg.get_hinting_flag(),
    }[self._output_type]
    return self._parse_cached(s, dpi, prop, antialiased, load_glyph_flags)


[/PYTHON]
What will be the input of `math_to_image`, given the following output:
[OUTPUT]
```
{
    "output": 1.0
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {},
    "args": {
        "s": XXX,
        "filename_or_obj": XXX,
        "prop": XXX,
        "dpi": XXX,
        "format": XXX,
        "color": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
