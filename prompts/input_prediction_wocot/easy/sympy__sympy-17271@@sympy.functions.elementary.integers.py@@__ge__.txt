You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [/INPUT]. You should maintain the structure when printing inputs. Do not change anything else.  ONLY print the input, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
from sympy.core import Add, S
from sympy.core.evalf import get_integer_part, PrecisionExhausted
from sympy.core.function import Function
from sympy.core.logic import fuzzy_or
from sympy.core.numbers import Integer
from sympy.core.relational import Gt, Lt, Ge, Le, Relational
from sympy.core.symbol import Symbol
from sympy.core.sympify import _sympify
from sympy import im
from sympy import AccumBounds, im

class ceiling(RoundFunction):
    _dir = 1

    def __ge__(self, other):
        if self.args[0] == other and other.is_real:
            return S.true
        if other is S.NegativeInfinity and self.is_real:
            return S.true
        return Ge(self, other, evaluate=False)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    super(StdFactKB, self).__init__(_assume_rules)
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.facts.FactKB.__init__

def __init__(self, rules):
    self.rules = rules

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    assumptions._tell(fact, None)
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.functions.elementary.integers.frac._eval_is_integer

def _eval_is_integer(self):
    return self.args[0].is_integer

.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.functions.elementary.integers.frac._eval_is_finite

def _eval_is_finite(self):
    return True

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.functions.elementary.integers.frac._eval_is_imaginary

def _eval_is_imaginary(self):
    return self.args[0].is_imaginary

.sympy.functions.elementary.integers.frac._eval_is_zero

def _eval_is_zero(self):
    return fuzzy_or([self.args[0].is_zero, self.args[0].is_integer])

.sympy.core.logic.fuzzy_or

def fuzzy_or(args):
    return fuzzy_not(fuzzy_and((fuzzy_not(i) for i in args)))

.sympy.core.logic.fuzzy_and

def fuzzy_and(args):
    rv = True
    for ai in args:
        ai = fuzzy_bool(ai)
        if ai is False:
            return False
        if rv:
            rv = ai
    return rv

.sympy.core.logic.fuzzy_not

def fuzzy_not(v):
    if v is None:
        return v
    else:
        return not v

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.function.Function._eval_is_commutative

def _eval_is_commutative(self):
    return fuzzy_and((a.is_commutative for a in self.args))

.sympy.core.expr.Expr._eval_is_positive

def _eval_is_positive(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_positive = self.is_extended_positive
    if finite is True:
        return extended_positive
    if extended_positive is False:
        return False

.sympy.core.expr.Expr._eval_is_extended_positive

def _eval_is_extended_positive(self):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_extended_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
        except ValueError:
            return None
        if n2 is None:
            return None
        if getattr(n2, '_prec', 1) == 1:
            return None
        if n2 == S.NaN:
            return None
        r, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not r.is_Number:
            return False
        if r._prec != 1 and i._prec != 1:
            return bool(not i and r > 0)
        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.expr.Expr.is_number

def is_number(self):
    return all((obj.is_number for obj in self.args))

.sympy.core.expr.Expr._eval_is_extended_negative

def _eval_is_extended_negative(self):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_extended_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
        except ValueError:
            return None
        if n2 is None:
            return None
        if getattr(n2, '_prec', 1) == 1:
            return None
        if n2 == S.NaN:
            return None
        r, i = self.evalf(2).as_real_imag()
        if not i.is_Number or not r.is_Number:
            return False
        if r._prec != 1 and i._prec != 1:
            return bool(not i and r < 0)
        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.functions.elementary.integers.frac._eval_is_negative

def _eval_is_negative(self):
    return False

.sympy.functions.elementary.integers.frac._eval_is_real

def _eval_is_real(self):
    return self.args[0].is_extended_real

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    try:
        if a in sympy_classes:
            return a
    except TypeError:
        pass
    cls = getattr(a, '__class__', None)
    if cls is None:
        cls = type(a)
    if cls in sympy_classes:
        return a
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    try:
        return converter[cls](a)
    except KeyError:
        for superclass in getmro(cls):
            try:
                return converter[superclass](a)
            except KeyError:
                continue
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if evaluate is None:
        if global_evaluate[0] is False:
            evaluate = global_evaluate[0]
        else:
            evaluate = True
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
    _sympy_ = getattr(a, '_sympy_', None)
    if _sympy_ is not None:
        try:
            return a._sympy_()
        except AttributeError:
            pass
    if not strict:
        flat = getattr(a, 'flat', None)
        if flat is not None:
            shape = getattr(a, 'shape', None)
            if shape is not None:
                from ..tensor.array import Array
                return Array(a.flat, a.shape)
    if not isinstance(a, string_types):
        for coerce in (float, int):
            try:
                coerced = coerce(a)
            except (TypeError, ValueError):
                continue
            except AttributeError:
                continue
            try:
                return sympify(coerced)
            except SympifyError:
                continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
        from .compatibility import unicode
        a = unicode(a)
    except Exception as exc:
        raise SympifyError(a, exc)
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.expr.Expr.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.functions.elementary.integers.frac._value_one_or_more

def _value_one_or_more(self, other):
    if other.is_extended_real:
        if other.is_number:
            res = other >= 1
            if res and (not isinstance(res, Relational)):
                return S.true
        if other.is_integer and other.is_positive:
            return S.true

.sympy.core.function.Function._eval_is_complex

def _eval_is_complex(self):
    return fuzzy_and((a.is_complex for a in self.args))

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super(Infinity, self).__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super(Number, self).__hash__()

.sympy.core.numbers.Infinity.__ge__

def __ge__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s >= %s' % (self, other))
    if other.is_extended_real:
        return S.true
    return Expr.__ge__(self, other)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, string_types):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)
    if ival == 1:
        return S.One
    if ival == -1:
        return S.NegativeOne
    if ival == 0:
        return S.Zero
    obj = Expr.__new__(cls)
    obj.p = ival
    return obj

.sympy.logic.boolalg.BooleanTrue.__nonzero__

def __nonzero__(self):
    return True

.sympy.core.numbers.NegativeInfinity.__hash__

def __hash__(self):
    return super(NegativeInfinity, self).__hash__()

.sympy.core.numbers.Integer.__ge__

def __ge__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s >= %s' % (self, other))
    if other.is_Integer:
        return _sympify(self.p >= other.p)
    return Rational.__ge__(self, other)

.sympy.core.expr.Expr._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.numbers.Rational.__hash__

def __hash__(self):
    return super(Rational, self).__hash__()

.sympy.core.power.Pow._eval_is_extended_negative

def _eval_is_extended_negative(self):
    if self.base.is_extended_negative:
        if self.exp.is_odd and self.base.is_finite:
            return True
        if self.exp.is_even:
            return False
    elif self.base.is_extended_positive:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_extended_nonnegative:
        if self.exp.is_extended_nonnegative:
            return False
    elif self.base.is_extended_nonpositive:
        if self.exp.is_even:
            return False
    elif self.base.is_extended_real:
        if self.exp.is_even:
            return False

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.numbers.Number._eval_evalf

def _eval_evalf(self, prec):
    return Float._new(self._as_mpf_val(prec), prec)

.sympy.core.numbers.Integer._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_int(self.p, prec, rnd)

.sympy.core.numbers.Float._new

def _new(cls, _mpf_, _prec, zero=True):
    if zero and _mpf_ == fzero:
        return S.Zero
    elif _mpf_ == _mpf_nan:
        return S.NaN
    elif _mpf_ == _mpf_inf:
        return S.Infinity
    elif _mpf_ == _mpf_ninf:
        return S.NegativeInfinity
    obj = Expr.__new__(cls)
    obj._mpf_ = mpf_norm(_mpf_, _prec)
    obj._prec = _prec
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.numbers.mpf_norm

def mpf_norm(mpf, prec):
    sign, man, expt, bc = mpf
    if not man:
        if not bc:
            return fzero
        else:
            return mpf
    from mpmath.libmp.backend import MPZ
    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
    return rv

.sympy.core.numbers.Float.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not self:
        return not other
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Float:
        return self._mpf_ == other._mpf_
    if other.is_Rational:
        return other.__eq__(self)
    if other.is_Number:
        ompf = other._as_mpf_val(self._prec)
        return bool(mlib.mpf_eq(self._mpf_, ompf))
    return False

.sympy.core.numbers.NaN.__hash__

def __hash__(self):
    return super(NaN, self).__hash__()

.sympy.core.numbers.Float.__nonzero__

def __nonzero__(self):
    return self._mpf_ != fzero

.sympy.core.numbers.NaN._as_mpf_val

def _as_mpf_val(self, prec):
    return _mpf_nan

.sympy.core.evalf.EvalfMixin.evalf

def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
    from sympy import Float, Number
    n = n if n is not None else 15
    if subs and is_sequence(subs):
        raise TypeError('subs must be given as a dictionary')
    if n == 1 and isinstance(self, Number):
        from sympy.core.expr import _mag
        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
        m = _mag(rv)
        rv = rv.round(1 - m)
        return rv
    if not evalf_table:
        _create_evalf_table()
    prec = dps_to_prec(n)
    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}
    if subs is not None:
        options['subs'] = subs
    if quad is not None:
        options['quad'] = quad
    try:
        result = evalf(self, prec + 4, options)
    except NotImplementedError:
        v = self._eval_evalf(prec)
        if v is None:
            return self
        elif not v.is_number:
            return v
        try:
            result = evalf(v, prec, options)
        except NotImplementedError:
            return v
    re, im, re_acc, im_acc = result
    if re:
        p = max(min(prec, re_acc), 1)
        re = Float._new(re, p)
    else:
        re = S.Zero
    if im:
        p = max(min(prec, im_acc), 1)
        im = Float._new(im, p)
        return re + im * S.ImaginaryUnit
    else:
        return re

.sympy.core.evalf.evalf

def evalf(x, prec, options):
    from sympy import re as re_, im as im_
    try:
        rf = evalf_table[x.func]
        r = rf(x, prec, options)
    except KeyError:
        if 'subs' in options:
            x = x.subs(evalf_subs(prec, options['subs']))
        xe = x._eval_evalf(prec)
        if xe is None:
            raise NotImplementedError
        as_real_imag = getattr(xe, 'as_real_imag', None)
        if as_real_imag is None:
            raise NotImplementedError
        re, im = as_real_imag()
        if re.has(re_) or im.has(im_):
            raise NotImplementedError
        if re == 0:
            re = None
            reprec = None
        elif re.is_number:
            re = re._to_mpmath(prec, allow_ints=False)._mpf_
            reprec = prec
        else:
            raise NotImplementedError
        if im == 0:
            im = None
            imprec = None
        elif im.is_number:
            im = im._to_mpmath(prec, allow_ints=False)._mpf_
            imprec = prec
        else:
            raise NotImplementedError
        r = (re, im, reprec, imprec)
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50))
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.expr.Expr.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import im, re
    if hints.get('ignore') == self:
        return None
    else:
        return (re(self), im(self))

.sympy.core.sympify.SympifyError.__init__

def __init__(self, expr, base_exc=None):
    self.expr = expr
    self.base_exc = base_exc

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_evaluate[0])
    result = super(Function, cls).__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(mlib.libmpf.prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_evaluate[0])
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return EmptySet()
    else:
        args = list(map(sympify, args))
    args = list(ordered(set(args), Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.compatibility.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                from sympy.utilities.iterables import uniq
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        for v in d[k]:
            yield v
        d.pop(k)

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    other = sympify(other)
    c = self._contains(other)
    b = tfn[c]
    if b is None:
        raise TypeError('did not evaluate to a bool: %r' % c)
    return b

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    return fuzzy_or([tfn[Eq(e, other, evaluate=True)] for e in self.args])

.sympy.core.relational.Equality.__new__

def __new__(cls, lhs, rhs=None, **options):
    from sympy.core.add import Add
    from sympy.core.logic import fuzzy_bool
    from sympy.core.expr import _n2
    from sympy.simplify.simplify import clear_coefficients
    if rhs is None:
        SymPyDeprecationWarning(feature='Eq(expr) with rhs default to 0', useinstead='Eq(expr, 0)', issue=16587, deprecated_since_version='1.5').warn()
        rhs = 0
    lhs = _sympify(lhs)
    rhs = _sympify(rhs)
    evaluate = options.pop('evaluate', global_evaluate[0])
    if evaluate:
        if hasattr(lhs, '_eval_Eq'):
            r = lhs._eval_Eq(rhs)
            if r is not None:
                return r
        if hasattr(rhs, '_eval_Eq'):
            r = rhs._eval_Eq(lhs)
            if r is not None:
                return r
        if lhs == rhs:
            return S.true
        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):
            return S.false
        elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):
            return S.false
        fin = L, R = [i.is_finite for i in (lhs, rhs)]
        if None not in fin:
            if L != R:
                return S.false
            if L is False:
                if lhs == -rhs:
                    return S.false
                return S.true
        elif None in fin and False in fin:
            return Relational.__new__(cls, lhs, rhs, **options)
        if all((isinstance(i, Expr) for i in (lhs, rhs))):
            dif = lhs - rhs
            z = dif.is_zero
            if z is not None:
                if z is False and dif.is_commutative:
                    return S.false
                if z:
                    return S.true
            n2 = _n2(lhs, rhs)
            if n2 is not None:
                return _sympify(n2 == 0)
            n, d = dif.as_numer_denom()
            rv = None
            if n.is_zero:
                rv = d.is_nonzero
            elif n.is_finite:
                if d.is_infinite:
                    rv = S.true
                elif n.is_zero is False:
                    rv = d.is_infinite
                    if rv is None:
                        l, r = clear_coefficients(d, S.Infinity)
                        args = [_.subs(l, r) for _ in (lhs, rhs)]
                        if args != [lhs, rhs]:
                            rv = fuzzy_bool(Eq(*args))
                            if rv is True:
                                rv = None
            elif any((a.is_infinite for a in Add.make_args(n))):
                rv = S.false
            if rv is not None:
                return _sympify(rv)
    return Relational.__new__(cls, lhs, rhs, **options)

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, integer_types):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.logic.boolalg.BooleanTrue.__hash__

def __hash__(self):
    return hash(True)

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    if self is other:
        return True
    tself = type(self)
    tother = type(other)
    if tself is not tother:
        try:
            other = _sympify(other)
            tother = type(other)
        except SympifyError:
            return NotImplemented
        if PY3 or type(tself).__ne__ is not type.__ne__:
            if tself != tother:
                return False
        elif tself is not tother:
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.core.basic.Basic._hashable_content

def _hashable_content(self):
    return self._args

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_evaluate[0])
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super(Application, cls).__new__(cls, *args, **options)
    sentinel = object()
    objnargs = getattr(obj, 'nargs', sentinel)
    if objnargs is not sentinel:
        if is_sequence(objnargs):
            nargs = tuple(ordered(set(objnargs)))
        elif objnargs is not None:
            nargs = (as_int(objnargs),)
        else:
            nargs = None
    else:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.core.numbers.Float.__hash__

def __hash__(self):
    return super(Float, self).__hash__()

.sympy.core.numbers.Float._hashable_content

def _hashable_content(self):
    return (self._mpf_, self._prec)

.sympy.functions.elementary.complexes.re.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_extended_real:
        return arg
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:
        return S.Zero
    elif arg.is_Matrix:
        return arg.as_real_imag()[0]
    elif arg.is_Function and isinstance(arg, conjugate):
        return re(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_extended_real:
                    reverted.append(coeff)
            elif not term.has(S.ImaginaryUnit) and term.is_extended_real:
                excluded.append(term)
            else:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[0])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) - im(b) + c

.sympy.functions.elementary.complexes.im.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_extended_real:
        return S.Zero
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:
        return -S.ImaginaryUnit * arg
    elif arg.is_Matrix:
        return arg.as_real_imag()[1]
    elif arg.is_Function and isinstance(arg, conjugate):
        return -im(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_extended_real:
                    reverted.append(coeff)
                else:
                    excluded.append(coeff)
            elif term.has(S.ImaginaryUnit) or not term.is_extended_real:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[1])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) + re(b) + c

.sympy.core.numbers.Zero.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.numbers.Float.__gt__

def __gt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__lt__(self)
    rv = self._Frel(other, mlib.mpf_gt)
    if rv is None:
        return Expr.__gt__(self, other)
    return rv

.sympy.core.numbers.Float._Frel

def _Frel(self, other, op):
    from sympy.core.evalf import evalf
    from sympy.core.numbers import prec_to_dps
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s > %s' % (self, other))
    if other.is_Rational:
        '\n        >>> f = Float(.1,2)\n        >>> i = 1234567890\n        >>> (f*i)._mpf_\n        (0, 471, 18, 9)\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\n        (0, 505555550955, -12, 39)\n        '
        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
        ompf = mlib.from_int(other.p)
        return _sympify(bool(op(smpf, ompf)))
    elif other.is_Float:
        return _sympify(bool(op(self._mpf_, other._mpf_)))
    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):
        other = other.evalf(prec_to_dps(self._prec))
        if other._prec > 1:
            if other.is_Number:
                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.core.power.Pow._eval_is_composite

def _eval_is_composite(self):
    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):
        return True

.sympy.core.power.Pow._eval_is_imaginary

def _eval_is_imaginary(self):
    from sympy import arg, log
    if self.base.is_imaginary:
        if self.exp.is_integer:
            odd = self.exp.is_odd
            if odd is not None:
                return odd
            return
    if self.exp.is_imaginary:
        imlog = log(self.base).is_imaginary
        if imlog is not None:
            return False
    if self.base.is_extended_real and self.exp.is_extended_real:
        if self.base.is_positive:
            return False
        else:
            rat = self.exp.is_rational
            if not rat:
                return rat
            if self.exp.is_integer:
                return False
            else:
                half = (2 * self.exp).is_integer
                if half:
                    return self.base.is_negative
                return half
    if self.base.is_extended_real is False:
        i = arg(self.base) * self.exp / S.Pi
        isodd = (2 * i).is_odd
        if isodd is not None:
            return isodd
    if self.exp.is_negative:
        return (1 / self).is_imaginary

.sympy.core.power.Pow._eval_is_finite

def _eval_is_finite(self):
    if self.exp.is_negative:
        if self.base.is_zero:
            return False
        if self.base.is_infinite or self.base.is_nonzero:
            return True
    c1 = self.base.is_finite
    if c1 is None:
        return
    c2 = self.exp.is_finite
    if c2 is None:
        return
    if c1 and c2:
        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):
            return True

.sympy.core.power.Pow._eval_is_extended_real

def _eval_is_extended_real(self):
    from sympy import arg, exp, log, Mul
    real_b = self.base.is_extended_real
    if real_b is None:
        if self.base.func == exp and self.base.args[0].is_imaginary:
            return self.exp.is_imaginary
        return
    real_e = self.exp.is_extended_real
    if real_e is None:
        return
    if real_b and real_e:
        if self.base.is_extended_positive:
            return True
        elif self.base.is_extended_nonnegative:
            if self.exp.is_extended_nonnegative:
                return True
        elif self.exp.is_integer:
            return True
        elif self.base.is_extended_negative:
            if self.exp.is_Rational:
                return False
    if real_e and self.exp.is_extended_negative:
        return Pow(self.base, -self.exp).is_extended_real
    im_b = self.base.is_imaginary
    im_e = self.exp.is_imaginary
    if im_b:
        if self.exp.is_integer:
            if self.exp.is_even:
                return True
            elif self.exp.is_odd:
                return False
        elif im_e and log(self.base).is_imaginary:
            return True
        elif self.exp.is_Add:
            c, a = self.exp.as_coeff_Add()
            if c and c.is_Integer:
                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real
        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
            if (self.exp / 2).is_integer is False:
                return False
    if real_b and im_e:
        if self.base is S.NegativeOne:
            return True
        c = self.exp.coeff(S.ImaginaryUnit)
        if c:
            ok = (c * log(self.base) / S.Pi).is_Integer
            if ok is not None:
                return ok
    if real_b is False:
        i = arg(self.base) * self.exp / S.Pi
        return i.is_integer

.sympy.core.power.Pow._eval_is_positive

def _eval_is_positive(self):
    ext_pos = Pow._eval_is_extended_positive(self)
    if ext_pos is True:
        return self.is_finite
    return ext_pos

.sympy.core.power.Pow._eval_is_extended_positive

def _eval_is_extended_positive(self):
    from sympy import log
    if self.base == self.exp:
        if self.base.is_extended_nonnegative:
            return True
    elif self.base.is_positive:
        if self.exp.is_extended_real:
            return True
    elif self.base.is_extended_negative:
        if self.exp.is_even:
            return True
        if self.exp.is_odd:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return self.exp.is_zero
    elif self.base.is_extended_nonpositive:
        if self.exp.is_odd:
            return False
    elif self.base.is_imaginary:
        if self.exp.is_integer:
            m = self.exp % 4
            if m.is_zero:
                return True
            if m.is_integer and m.is_zero is False:
                return False
        if self.exp.is_imaginary:
            return log(self.base).is_imaginary

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    from sympy.core.power import integer_log
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not isinstance(other, Number):
        return False
    if not self:
        return not other
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Rational:
        return self.p == other.p and self.q == other.q
    if other.is_Float:
        if self.q & self.q - 1:
            return False
        s, m, t = other._mpf_[:3]
        if s:
            m = -m
        if not t:
            if not self.is_Integer or self.is_even:
                return False
            return m == self.p
        if t > 0:
            if not self.is_Integer:
                return False
            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))
        if self.is_Integer:
            return False
        return m == self.p and integer_log(self.q, 2) == (-t, True)
    return False

.sympy.core.power.Pow._eval_is_rational

def _eval_is_rational(self):
    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):
        return True
    p = self.func(*self.as_base_exp())
    if not p.is_Pow:
        return p.is_rational
    b, e = p.as_base_exp()
    if e.is_Rational and b.is_Rational:
        return False
    if e.is_integer:
        if b.is_rational:
            if fuzzy_not(b.is_zero) or e.is_nonnegative:
                return True
            if b == e:
                return True
        elif b.is_irrational:
            return e.is_zero

.sympy.core.power.Pow.as_base_exp

def as_base_exp(self):
    b, e = self.args
    if b.is_Rational and b.p == 1 and (b.q != 1):
        return (Integer(b.q), -e)
    return (b, e)

.sympy.core.power.Pow.__new__

def __new__(cls, b, e, evaluate=None):
    if evaluate is None:
        evaluate = global_evaluate[0]
    from sympy.functions.elementary.exponential import exp_polar
    b = _sympify(b)
    e = _sympify(e)
    if evaluate:
        if e is S.ComplexInfinity:
            return S.NaN
        if e is S.Zero:
            return S.One
        elif e is S.One:
            return b
        elif e == -1 and (not b):
            return S.ComplexInfinity
        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):
            if e.is_even:
                b = -b
            elif e.is_odd:
                return -Pow(-b, e)
        if S.NaN in (b, e):
            return S.NaN
        elif b is S.One:
            if abs(e).is_infinite:
                return S.NaN
            return S.One
        else:
            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):
                from sympy import numer, denom, log, sign, im, factor_terms
                c, ex = factor_terms(e, sign=False).as_coeff_Mul()
                den = denom(ex)
                if isinstance(den, log) and den.args[0] == b:
                    return S.Exp1 ** (c * numer(ex))
                elif den.is_Add:
                    s = sign(im(b))
                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):
                        return S.Exp1 ** (c * numer(ex))
            obj = b._eval_power(e)
            if obj is not None:
                return obj
    obj = Expr.__new__(cls, b, e)
    obj = cls._exec_constructor_postprocessors(obj)
    if not isinstance(obj, Pow):
        return obj
    obj.is_commutative = b.is_commutative and e.is_commutative
    return obj

.sympy.core.numbers.Integer._eval_power

def _eval_power(self, expt):
    from sympy.ntheory.factor_ import perfect_power
    if expt is S.Infinity:
        if self.p > S.One:
            return S.Infinity
        return S.Infinity + S.ImaginaryUnit * S.Infinity
    if expt is S.NegativeInfinity:
        return Rational(1, self) ** S.Infinity
    if not isinstance(expt, Number):
        if self.is_negative and expt.is_even:
            return (-self) ** expt
    if isinstance(expt, Float):
        return super(Integer, self)._eval_power(expt)
    if not isinstance(expt, Rational):
        return
    if expt is S.Half and self.is_negative:
        return S.ImaginaryUnit * Pow(-self, expt)
    if expt.is_negative:
        ne = -expt
        if self.is_negative:
            return S.NegativeOne ** expt * Rational(1, -self) ** ne
        else:
            return Rational(1, self.p) ** ne
    x, xexact = integer_nthroot(abs(self.p), expt.q)
    if xexact:
        result = Integer(x ** abs(expt.p))
        if self.is_negative:
            result *= S.NegativeOne ** expt
        return result
    b_pos = int(abs(self.p))
    p = perfect_power(b_pos)
    if p is not False:
        dict = {p[0]: p[1]}
    else:
        dict = Integer(b_pos).factors(limit=2 ** 15)
    out_int = 1
    out_rad = 1
    sqr_int = 1
    sqr_gcd = 0
    sqr_dict = {}
    for prime, exponent in dict.items():
        exponent *= expt.p
        div_e, div_m = divmod(exponent, expt.q)
        if div_e > 0:
            out_int *= prime ** div_e
        if div_m > 0:
            g = igcd(div_m, expt.q)
            if g != 1:
                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))
            else:
                sqr_dict[prime] = div_m
    for p, ex in sqr_dict.items():
        if sqr_gcd == 0:
            sqr_gcd = ex
        else:
            sqr_gcd = igcd(sqr_gcd, ex)
            if sqr_gcd == 1:
                break
    for k, v in sqr_dict.items():
        sqr_int *= k ** (v // sqr_gcd)
    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):
        result = None
    else:
        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))
        if self.is_negative:
            result *= Pow(S.NegativeOne, expt)
    return result

.sympy.core.power.integer_nthroot

def integer_nthroot(y, n):
    y, n = (as_int(y), as_int(n))
    if y < 0:
        raise ValueError('y must be nonnegative')
    if n < 1:
        raise ValueError('n must be positive')
    if y in (0, 1):
        return (y, True)
    if n == 1:
        return (y, True)
    if n == 2:
        x, rem = mpmath_sqrtrem(y)
        return (int(x), not rem)
    if n > y:
        return (1, False)
    try:
        guess = int(y ** (1.0 / n) + 0.5)
    except OverflowError:
        exp = _log(y, 2) / n
        if exp > 53:
            shift = int(exp - 53)
            guess = int(2.0 ** (exp - shift) + 1) << shift
        else:
            guess = int(2.0 ** exp)
    if guess > 2 ** 50:
        xprev, x = (-1, guess)
        while 1:
            t = x ** (n - 1)
            xprev, x = (x, ((n - 1) * x + y // t) // n)
            if abs(x - xprev) < 2:
                break
    else:
        x = guess
    t = x ** n
    while t < y:
        x += 1
        t = x ** n
    while t > y:
        x -= 1
        t = x ** n
    return (int(x), t == y)

.sympy.core.compatibility.as_int

def as_int(n, strict=True):
    from sympy.core.numbers import Integer
    try:
        if strict and (not isinstance(n, SYMPY_INTS + (Integer,))):
            raise TypeError
        result = int(n)
        if result != n:
            raise TypeError
        return result
    except TypeError:
        raise ValueError('%s is not an integer' % (n,))

.sympy.ntheory.factor_.perfect_power

def perfect_power(n, candidates=None, big=True, factor=True):
    from sympy.core.power import integer_nthroot
    n = as_int(n)
    if n < 3:
        if n < 1:
            raise ValueError('expecting positive n')
        return False
    logn = math.log(n, 2)
    max_possible = int(logn) + 2
    not_square = n % 10 in [2, 3, 7, 8]
    min_possible = 2 + not_square
    if not candidates:
        candidates = primerange(min_possible, max_possible)
    else:
        candidates = sorted([i for i in candidates if min_possible <= i < max_possible])
        if n % 2 == 0:
            e = trailing(n)
            candidates = [i for i in candidates if e % i == 0]
        if big:
            candidates = reversed(candidates)
        for e in candidates:
            r, ok = integer_nthroot(n, e)
            if ok:
                return (r, e)
        return False

    def _factors():
        rv = 2 + n % 2
        while True:
            yield rv
            rv = nextprime(rv)
    for fac, e in zip(_factors(), candidates):
        if factor and n % fac == 0:
            if fac == 2:
                e = trailing(n)
            else:
                e = multiplicity(fac, n)
            if e == 1:
                return False
            r, exact = integer_nthroot(n, e)
            if not exact:
                m = n // fac ** e
                rE = perfect_power(m, candidates=divisors(e, generator=True))
                if not rE:
                    return False
                else:
                    r, E = rE
                    r, e = (fac ** (e // E) * r, E)
            if not big:
                e0 = primefactors(e)
                if e0[0] != e:
                    r, e = (r ** (e // e0[0]), e0[0])
            return (r, e)
        if logn / e < 40:
            b = 2.0 ** (logn / e)
            if abs(int(b + 0.5) - b) > 0.01:
                continue
        r, exact = integer_nthroot(n, e)
        if exact:
            if big:
                m = perfect_power(r, big=big, factor=factor)
                if m:
                    r, e = (m[0], e * m[1])
            return (int(r), e)
    return False

.sympy.core.numbers.Rational.factors

def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):
    from sympy.ntheory import factorrat
    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()

.sympy.ntheory.factor_.factorrat

def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    from collections import defaultdict
    if multiple:
        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])
        return factorlist
    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()
    f = defaultdict(int, f)
    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():
        f[p] += -e
    if len(f) > 1 and 1 in f:
        del f[1]
    if not visual:
        return dict(f)
    else:
        if -1 in f:
            f.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])
        return Mul(*args, evaluate=False)

.sympy.ntheory.factor_.factorint

def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    if isinstance(n, Dict):
        n = dict(n)
    if multiple:
        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * -fac[p] for p in sorted(fac)), [])
        return factorlist
    factordict = {}
    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):
        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
    elif isinstance(n, Mul):
        factordict = {int(k): int(v) for k, v in n.as_powers_dict().items()}
    elif isinstance(n, dict):
        factordict = n
    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):
        for key in list(factordict.keys()):
            if isprime(key):
                continue
            e = factordict.pop(key)
            d = factorint(key, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
            for k, v in d.items():
                if k in factordict:
                    factordict[k] += v * e
                else:
                    factordict[k] = v * e
    if visual or (type(n) is dict and visual is not True and (visual is not False)):
        if factordict == {}:
            return S.One
        if -1 in factordict:
            factordict.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])
        return Mul(*args, evaluate=False)
    elif isinstance(n, dict) or isinstance(n, Mul):
        return factordict
    assert use_trial or use_rho or use_pm1
    from sympy.functions.combinatorial.factorials import factorial
    if isinstance(n, factorial):
        x = as_int(n.args[0])
        if x >= 20:
            factors = {}
            m = 2
            for p in sieve.primerange(2, x + 1):
                if m > 1:
                    m, q = (0, x // p)
                    while q != 0:
                        m += q
                        q //= p
                factors[p] = m
            if factors and verbose:
                for k in sorted(factors):
                    print(factor_msg % (k, factors[k]))
            if verbose:
                print(complete_msg)
            return factors
        else:
            n = n.func(x)
    n = as_int(n)
    if limit:
        limit = int(limit)
    if n < 0:
        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
        factors[-1] = 1
        return factors
    if limit and limit < 2:
        if n == 1:
            return {}
        return {n: 1}
    elif n < 10:
        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]
    factors = {}
    if verbose:
        sn = str(n)
        if len(sn) > 50:
            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])
        else:
            print('Factoring', n)
    if use_trial:
        small = 2 ** 15
        fail_max = 600
        small = min(small, limit or small)
        if verbose:
            print(trial_int_msg % (2, small, fail_max))
        n, next_p = _factorint_small(factors, n, small, fail_max)
    else:
        next_p = 2
    if factors and verbose:
        for k in sorted(factors):
            print(factor_msg % (k, factors[k]))
    if next_p == 0:
        if n > 1:
            factors[int(n)] = 1
        if verbose:
            print(complete_msg)
        return factors
    try:
        if limit and next_p > limit:
            if verbose:
                print('Exceeded limit:', limit)
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            if n > 1:
                factors[int(n)] = 1
            return factors
        else:
            sqrt_n = integer_nthroot(n, 2)[0]
            a = sqrt_n + 1
            a2 = a ** 2
            b2 = a2 - n
            for i in range(3):
                b, fermat = integer_nthroot(b2, 2)
                if fermat:
                    break
                b2 += 2 * a + 1
                a += 1
            if fermat:
                if verbose:
                    print(fermat_msg)
                if limit:
                    limit -= 1
                for r in [a - b, a + b]:
                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                    factors.update(facs)
                raise StopIteration
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
    except StopIteration:
        if verbose:
            print(complete_msg)
        return factors
    low, high = (next_p, 2 * next_p)
    limit = limit or sqrt_n
    limit += 1
    while 1:
        try:
            high_ = high
            if limit < high_:
                high_ = limit
            if use_trial:
                if verbose:
                    print(trial_msg % (low, high_))
                ps = sieve.primerange(low, high_)
                n, found_trial = _trial(factors, n, ps, verbose)
                if found_trial:
                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            else:
                found_trial = False
            if high > limit:
                if verbose:
                    print('Exceeded limit:', limit)
                if n > 1:
                    factors[int(n)] = 1
                raise StopIteration
            if not found_trial:
                if use_pm1 or use_rho:
                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)
                    if use_pm1:
                        if verbose:
                            print(pm1_msg % (high_root, high_))
                        c = pollard_pm1(n, B=high_root, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
                    if use_rho:
                        max_steps = high_root
                        if verbose:
                            print(rho_msg % (1, max_steps, high_))
                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
        except StopIteration:
            if verbose:
                print(complete_msg)
            return factors
        low, high = (high, high * 2)

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
            for k, v in chain.from_iterable(postprocessor_mappings):
                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    return obj

.sympy.core.expr.Expr.__ge__

def __ge__(self, other):
    from sympy import GreaterThan
    try:
        other = _sympify(other)
    except SympifyError:
        raise TypeError('Invalid comparison %s >= %s' % (self, other))
    for me in (self, other):
        if me.is_complex and me.is_extended_real is False:
            raise TypeError('Invalid comparison of complex %s' % me)
        if me is S.NaN:
            raise TypeError('Invalid NaN comparison')
    n2 = _n2(self, other)
    if n2 is not None:
        return _sympify(n2 >= 0)
    if self.is_extended_real and other.is_extended_real:
        if self.is_infinite and self.is_extended_positive or (other.is_infinite and other.is_extended_negative):
            return S.true
        nneg = (self - other).is_extended_nonnegative
        if nneg is not None:
            return sympify(nneg)
    return GreaterThan(self, other, evaluate=False)

.sympy.core.expr._n2

def _n2(a, b):
    if a.is_comparable and b.is_comparable:
        dif = (a - b).evalf(2)
        if dif.is_comparable:
            return dif

.sympy.core.basic.Basic.is_comparable

def is_comparable(self):
    is_extended_real = self.is_extended_real
    if is_extended_real is False:
        return False
    if not self.is_number:
        return False
    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]
    if not (i.is_Number and n.is_Number):
        return False
    if i:
        return False
    else:
        return n._prec != 1

.sympy.core.power.Pow.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import atan2, cos, im, re, sin
    from sympy.polys.polytools import poly
    if self.exp.is_Integer:
        exp = self.exp
        re, im = self.base.as_real_imag(deep=deep)
        if not im:
            return (self, S.Zero)
        a, b = symbols('a b', cls=Dummy)
        if exp >= 0:
            if re.is_Number and im.is_Number:
                expr = expand_multinomial(self.base ** exp)
                if expr != self:
                    return expr.as_real_imag()
            expr = poly((a + b) ** exp)
        else:
            mag = re ** 2 + im ** 2
            re, im = (re / mag, -im / mag)
            if re.is_Number and im.is_Number:
                expr = expand_multinomial((re + im * S.ImaginaryUnit) ** (-exp))
                if expr != self:
                    return expr.as_real_imag()
            expr = poly((a + b) ** (-exp))
        r = [i for i in expr.terms() if not i[0][1] % 2]
        re_part = Add(*[cc * a ** aa * b ** bb for (aa, bb), cc in r])
        r = [i for i in expr.terms() if i[0][1] % 4 == 1]
        im_part1 = Add(*[cc * a ** aa * b ** bb for (aa, bb), cc in r])
        r = [i for i in expr.terms() if i[0][1] % 4 == 3]
        im_part3 = Add(*[cc * a ** aa * b ** bb for (aa, bb), cc in r])
        return (re_part.subs({a: re, b: S.ImaginaryUnit * im}), im_part1.subs({a: re, b: im}) + im_part3.subs({a: re, b: -im}))
    elif self.exp.is_Rational:
        re, im = self.base.as_real_imag(deep=deep)
        if im.is_zero and self.exp is S.Half:
            if re.is_extended_nonnegative:
                return (self, S.Zero)
            if re.is_extended_nonpositive:
                return (S.Zero, (-self.base) ** self.exp)
        r = self.func(self.func(re, 2) + self.func(im, 2), S.Half)
        t = atan2(im, re)
        rp, tp = (self.func(r, self.exp), t * self.exp)
        return (rp * cos(tp), rp * sin(tp))
    elif deep:
        hints['complex'] = False
        expanded = self.expand(deep, **hints)
        if hints.get('ignore') == expanded:
            return None
        else:
            return (re(expanded), im(expanded))
    else:
        return (re(self), im(self))

.sympy.core.evalf.evalf_pow

def evalf_pow(v, prec, options):
    target_prec = prec
    base, exp = v.args
    if exp.is_Integer:
        p = exp.p
        if not p:
            return (fone, None, prec, None)
        prec += int(math.log(abs(p), 2))
        re, im, re_acc, im_acc = evalf(base, prec + 5, options)
        if re and (not im):
            return (mpf_pow_int(re, p, target_prec), None, target_prec, None)
        if im and (not re):
            z = mpf_pow_int(im, p, target_prec)
            case = p % 4
            if case == 0:
                return (z, None, target_prec, None)
            if case == 1:
                return (None, z, None, target_prec)
            if case == 2:
                return (mpf_neg(z), None, target_prec, None)
            if case == 3:
                return (None, mpf_neg(z), None, target_prec)
        if not re:
            return (None, None, None, None)
        re, im = libmp.mpc_pow_int((re, im), p, prec)
        return finalize_complex(re, im, target_prec)
    if exp is S.Half:
        xre, xim, _, _ = evalf(base, prec + 5, options)
        if xim:
            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)
            return finalize_complex(re, im, prec)
        if not xre:
            return (None, None, None, None)
        if mpf_lt(xre, fzero):
            return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)
        return (mpf_sqrt(xre, prec), None, prec, None)
    prec += 10
    yre, yim, _, _ = evalf(exp, prec, options)
    if not (yre or yim):
        return (fone, None, prec, None)
    ysize = fastlog(yre)
    if ysize > 5:
        prec += ysize
        yre, yim, _, _ = evalf(exp, prec, options)
    if base is S.Exp1:
        if yim:
            re, im = libmp.mpc_exp((yre or fzero, yim), prec)
            return finalize_complex(re, im, target_prec)
        return (mpf_exp(yre, target_prec), None, target_prec, None)
    xre, xim, _, _ = evalf(base, prec + 5, options)
    if not (xre or xim):
        return (None, None, None, None)
    if yim:
        re, im = libmp.mpc_pow((xre or fzero, xim or fzero), (yre or fzero, yim), target_prec)
        return finalize_complex(re, im, target_prec)
    if xim:
        re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)
        return finalize_complex(re, im, target_prec)
    elif mpf_lt(xre, fzero):
        re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)
        return finalize_complex(re, im, target_prec)
    else:
        return (mpf_pow(xre, yre, target_prec), None, target_prec, None)

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            f = getattr(other, method_name, None)
            if f is not None:
                return f(self)
    return func(self, other)

.sympy.core.expr.Expr.__sub__

def __sub__(self, other):
    return Add(self, -other)

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, **options):
    from sympy import Order
    args = list(map(_sympify, args))
    args = [a for a in args if a is not cls.identity]
    evaluate = options.get('evaluate')
    if evaluate is None:
        evaluate = global_evaluate[0]
    if not evaluate:
        obj = cls._from_args(args)
        obj = cls._exec_constructor_postprocessors(obj)
        return obj
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        return Order(obj, *order_symbols)
    return obj

.sympy.core.add.Add.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    from sympy.tensor.tensor import TensExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        if a.is_Rational:
            if b.is_Mul:
                rv = ([a, b], [], None)
        if rv:
            if all((s.is_commutative for s in rv[0])):
                return rv
            return ([], rv[0], None)
    terms = {}
    coeff = S.Zero
    order_factors = []
    extra = []
    for o in seq:
        if o.is_Order:
            for o1 in order_factors:
                if o1.contains(o):
                    o = None
                    break
            if o is None:
                continue
            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]
            continue
        elif o.is_Number:
            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):
                return ([S.NaN], [], None)
            if coeff.is_Number:
                coeff += o
                if coeff is S.NaN and (not extra):
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__add__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            extra.append(o)
            continue
        elif isinstance(o, TensExpr):
            coeff = o.__add__(coeff) if coeff else o
            continue
        elif o is S.ComplexInfinity:
            if coeff.is_finite is False and (not extra):
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o.is_Add:
            seq.extend(o.args)
            continue
        elif o.is_Mul:
            c, s = o.as_coeff_Mul()
        elif o.is_Pow:
            b, e = o.as_base_exp()
            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):
                seq.append(b ** e)
                continue
            c, s = (S.One, o)
        else:
            c = S.One
            s = o
        if s in terms:
            terms[s] += c
            if terms[s] is S.NaN and (not extra):
                return ([S.NaN], [], None)
        else:
            terms[s] = c
    newseq = []
    noncommutative = False
    for s, c in terms.items():
        if c is S.Zero:
            continue
        elif c is S.One:
            newseq.append(s)
        elif s.is_Mul:
            cs = s._new_rawargs(*(c,) + s.args)
            newseq.append(cs)
        elif s.is_Add:
            newseq.append(Mul(c, s, evaluate=False))
        else:
            newseq.append(Mul(c, s))
        noncommutative = noncommutative or not s.is_commutative
    if coeff is S.Infinity:
        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]
    elif coeff is S.NegativeInfinity:
        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]
    if coeff is S.ComplexInfinity:
        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]
    if order_factors:
        newseq2 = []
        for t in newseq:
            for o in order_factors:
                if o.contains(t):
                    t = None
                    break
            if t is not None:
                newseq2.append(t)
        newseq = newseq2 + order_factors
        for o in order_factors:
            if o.contains(coeff):
                coeff = S.Zero
                break
    _addsort(newseq)
    if coeff is not S.Zero:
        newseq.insert(0, coeff)
    if extra:
        newseq += extra
        noncommutative = True
    if noncommutative:
        return ([], newseq, None)
    else:
        return (newseq, [], None)

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.core.add._addsort

def _addsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super(AssocOp, cls).__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.core.evalf.evalf_add

def evalf_add(v, prec, options):
    res = pure_complex(v)
    if res:
        h, c = res
        re, _, re_acc, _ = evalf(h, prec, options)
        im, _, im_acc, _ = evalf(c, prec, options)
        return (re, im, re_acc, im_acc)
    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
    i = 0
    target_prec = prec
    while 1:
        options['maxprec'] = min(oldmaxprec, 2 * prec)
        terms = [evalf(arg, prec + 10, options) for arg in v.args]
        re, re_acc = add_terms([a[0::2] for a in terms if a[0]], prec, target_prec)
        im, im_acc = add_terms([a[1::2] for a in terms if a[1]], prec, target_prec)
        acc = complex_accuracy((re, im, re_acc, im_acc))
        if acc >= target_prec:
            if options.get('verbose'):
                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)
            break
        else:
            if prec - target_prec > options['maxprec']:
                break
            prec = prec + max(10 + 2 ** i, target_prec - acc)
            i += 1
            if options.get('verbose'):
                print('ADD: restarting with prec', prec)
    options['maxprec'] = oldmaxprec
    if iszero(re, scaled=True):
        re = scaled_zero(re)
    if iszero(im, scaled=True):
        im = scaled_zero(im)
    return (re, im, re_acc, im_acc)

.sympy.core.evalf.pure_complex

def pure_complex(v, or_real=False):
    h, t = v.as_coeff_Add()
    if not t:
        if or_real:
            return (h, t)
        return
    c, i = t.as_coeff_Mul()
    if i is S.ImaginaryUnit:
        return (h, c)

.sympy.core.add.Add.as_coeff_Add

def as_coeff_Add(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number and (not rational) or coeff.is_Rational:
        return (coeff, self._new_rawargs(*args))
    return (S.Zero, self)

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, **kwargs):
    if kwargs.pop('reeval', True) and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (S.One, self)

.sympy.core.evalf.add_terms

def add_terms(terms, prec, target_prec):
    terms = [t for t in terms if not iszero(t[0])]
    if not terms:
        return (None, None)
    elif len(terms) == 1:
        return terms[0]
    special = []
    from sympy.core.numbers import Float
    for t in terms:
        arg = Float._new(t[0], 1)
        if arg is S.NaN or arg.is_infinite:
            special.append(arg)
    if special:
        from sympy.core.add import Add
        rv = evalf(Add(*special), prec + 4, {})
        return (rv[0], rv[2])
    working_prec = 2 * prec
    sum_man, sum_exp, absolute_error = (0, 0, MINUS_INF)
    for x, accuracy in terms:
        sign, man, exp, bc = x
        if sign:
            man = -man
        absolute_error = max(absolute_error, bc + exp - accuracy)
        delta = exp - sum_exp
        if exp >= sum_exp:
            if delta > working_prec and (not sum_man or delta - bitcount(abs(sum_man)) > working_prec):
                sum_man = man
                sum_exp = exp
            else:
                sum_man += man << delta
        else:
            delta = -delta
            if delta - bc > working_prec:
                if not sum_man:
                    sum_man, sum_exp = (man, exp)
            else:
                sum_man = (sum_man << delta) + man
                sum_exp = exp
    if not sum_man:
        return scaled_zero(absolute_error)
    if sum_man < 0:
        sum_sign = 1
        sum_man = -sum_man
    else:
        sum_sign = 0
    sum_bc = bitcount(sum_man)
    sum_accuracy = sum_exp + sum_bc - absolute_error
    r = (normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec, rnd), sum_accuracy)
    return r

.sympy.core.evalf.iszero

def iszero(mpf, scaled=False):
    if not scaled:
        return not mpf or (not mpf[1] and (not mpf[-1]))
    return mpf and type(mpf[0]) is list and (mpf[1] == mpf[-1] == 1)

.sympy.core.evalf.bitcount

def bitcount(n):
    return mpmath_bitcount(abs(int(n)))

.sympy.core.evalf.complex_accuracy

def complex_accuracy(result):
    re, im, re_acc, im_acc = result
    if not im:
        if not re:
            return INF
        return re_acc
    if not re:
        return im_acc
    re_size = fastlog(re)
    im_size = fastlog(im)
    absolute_error = max(re_size - re_acc, im_size - im_acc)
    relative_error = absolute_error - max(re_size, im_size)
    return -relative_error

.sympy.core.numbers.Float.__ge__

def __ge__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__le__(self)
    rv = self._Frel(other, mlib.mpf_ge)
    if rv is None:
        return Expr.__ge__(self, other)
    return rv

.sympy.core.add.Add._eval_is_extended_nonpositive

def _eval_is_extended_nonpositive(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonpositive:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonpositive:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonpositive:
                        return True

.sympy.core.add.Add._eval_is_extended_negative

def _eval_is_extended_negative(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_extended_negative()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_negative and a.is_extended_nonpositive:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_negative:
                    return True
    neg = nonpos = nonneg = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        isneg = a.is_extended_negative
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))
            if True in saw_INF and False in saw_INF:
                return
        if isneg:
            neg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonneg and (not nonpos) and neg:
        return True
    elif not nonneg and neg:
        return True
    elif not neg and (not nonpos):
        return False

.sympy.core.logic._fuzzy_group

def _fuzzy_group(args, quick_exit=False):
    saw_other = False
    for a in args:
        if a is True:
            continue
        if a is None:
            return
        if quick_exit and saw_other:
            return
        saw_other = True
    return not saw_other

.sympy.core.mul.Mul._eval_is_extended_real

def _eval_is_extended_real(self):
    return self._eval_real_imag(True)

.sympy.core.mul.Mul._eval_real_imag

def _eval_real_imag(self, real):
    zero = False
    t_not_re_im = None
    for t in self.args:
        if t.is_complex is False and t.is_extended_real is False:
            return False
        elif t.is_imaginary:
            real = not real
        elif t.is_extended_real:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_extended_real is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        elif t.is_imaginary is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        else:
            return
    if t_not_re_im:
        if t_not_re_im.is_extended_real is False:
            if real:
                return zero
        if t_not_re_im.is_imaginary is False:
            if not real:
                return zero
    elif zero is False:
        return real
    elif real:
        return real

.sympy.core.power.Pow._eval_is_complex

def _eval_is_complex(self):
    if all((a.is_complex for a in self.args)):
        return True

.sympy.core.numbers.Rational._eval_is_positive

def _eval_is_positive(self):
    return self.p > 0

.sympy.core.power.Pow._eval_is_zero

def _eval_is_zero(self):
    if self.base.is_zero:
        if self.exp.is_extended_positive:
            return True
        elif self.exp.is_extended_nonpositive:
            return False
    elif self.base.is_zero is False:
        if self.exp.is_negative:
            return self.base.is_infinite
        elif self.exp.is_nonnegative:
            return False
        elif self.exp.is_infinite:
            if (1 - abs(self.base)).is_extended_positive:
                return self.exp.is_extended_positive
            elif (1 - abs(self.base)).is_extended_negative:
                return self.exp.is_extended_negative
    else:
        return None

.sympy.core.operations.AssocOp._eval_evalf

def _eval_evalf(self, prec):
    from .add import Add
    from .mul import Mul
    from .symbol import Symbol
    from .function import AppliedUndef
    if isinstance(self, (Mul, Add)):
        x, tail = self.as_independent(Symbol, AppliedUndef)
        if not (tail is self.identity or (isinstance(x, AssocOp) and x.is_Function) or (x is self.identity and isinstance(tail, AssocOp))):
            x = x._evalf(prec) if x is not self.identity else self.identity
            args = []
            tail_args = tuple(self.func.make_args(tail))
            for a in tail_args:
                newa = a._eval_evalf(prec)
                if newa is None:
                    args.append(a)
                else:
                    args.append(newa)
            return self.func(x, *args)
    args = []
    for a in self.args:
        newa = a._eval_evalf(prec)
        if newa is None:
            args.append(a)
        else:
            args.append(newa)
    return self.func(*args)

.sympy.core.expr.Expr.as_independent

def as_independent(self, *deps, **hint):
    from .symbol import Symbol
    from .add import _unevaluated_Add
    from .mul import _unevaluated_Mul
    from sympy.utilities.iterables import sift
    if self.is_zero:
        return (S.Zero, S.Zero)
    func = self.func
    if hint.get('as_Add', isinstance(self, Add)):
        want = Add
    else:
        want = Mul
    sym = set()
    other = []
    for d in deps:
        if isinstance(d, Symbol):
            sym.add(d)
        else:
            other.append(d)

    def has(e):
        has_other = e.has(*other)
        if not sym:
            return has_other
        return has_other or e.has(*e.free_symbols & sym)
    if want is not func or (func is not Add and func is not Mul):
        if has(self):
            return (want.identity, self)
        else:
            return (self, want.identity)
    elif func is Add:
        args = list(self.args)
    else:
        args, nc = self.args_cnc()
    d = sift(args, lambda x: has(x))
    depend = d[True]
    indep = d[False]
    if func is Add:
        return (Add(*indep), _unevaluated_Add(*depend))
    else:
        for i, n in enumerate(nc):
            if has(n):
                depend.extend(nc[i:])
                break
            indep.append(n)
        return (Mul(*indep), Mul(*depend, evaluate=False) if nc else _unevaluated_Mul(*depend))

.sympy.core.add.Add._eval_is_zero

def _eval_is_zero(self):
    if self.is_commutative is False:
        return
    nz = []
    z = 0
    im_or_z = False
    im = False
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                z += 1
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im = True
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_or_z = True
        else:
            return
    if z == len(self.args):
        return True
    if len(nz) == 0 or len(nz) == len(self.args):
        return None
    b = self.func(*nz)
    if b.is_zero:
        if not im_or_z and (not im):
            return True
        if im and (not im_or_z):
            return False
    if b.is_zero is False:
        return False

.sympy.core.mul.Mul._eval_is_zero

def _eval_is_zero(self):
    zero = infinite = False
    for a in self.args:
        z = a.is_zero
        if z:
            if infinite:
                return
            zero = True
        else:
            if not a.is_finite:
                if zero:
                    return
                infinite = True
            if zero is False and z is None:
                zero = None
    return zero

.sympy.core.add.Add._eval_is_extended_nonnegative

def _eval_is_extended_nonnegative(self):
    from sympy.core.exprtools import _monotonic_sign
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonnegative:
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonnegative:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonnegative:
                        return True

.sympy.core.add.Add._eval_is_extended_positive

def _eval_is_extended_positive(self):
    from sympy.core.exprtools import _monotonic_sign
    if self.is_number:
        return super(Add, self)._eval_is_extended_positive()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_positive and a.is_extended_nonnegative:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_positive:
                    return True
    pos = nonneg = nonpos = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        ispos = a.is_extended_positive
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))
            if True in saw_INF and False in saw_INF:
                return
        if ispos:
            pos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonpos and (not nonneg) and pos:
        return True
    elif not nonpos and pos:
        return True
    elif not pos and (not nonneg):
        return False

.sympy.utilities.iterables.sift

def sift(seq, keyfunc, binary=False):
    if not binary:
        m = defaultdict(list)
        for i in seq:
            m[keyfunc(i)].append(i)
        return m
    sift = F, T = ([], [])
    for i in seq:
        try:
            sift[keyfunc(i)].append(i)
        except (IndexError, TypeError):
            raise ValueError('keyfunc gave non-binary output')
    return (T, F)

.sympy.core.expr.Expr.has

def has(e):
    has_other = e.has(*other)
    if not sym:
        return has_other
    return has_other or e.has(*e.free_symbols & sym)

.sympy.core.basic.Basic.has

def has(self, *patterns):
    return any((self._has(pattern) for pattern in patterns))

.sympy.core.basic.Basic._has

def _has(self, pattern):
    from sympy.core.function import UndefinedFunction, Function
    if isinstance(pattern, UndefinedFunction):
        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))
    pattern = sympify(pattern)
    if isinstance(pattern, BasicMeta):
        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))
    _has_matcher = getattr(pattern, '_has_matcher', None)
    if _has_matcher is not None:
        match = _has_matcher()
        return any((match(arg) for arg in preorder_traversal(self)))
    else:
        return any((arg == pattern for arg in preorder_traversal(self)))

.sympy.core.basic.preorder_traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

.sympy.core.basic.preorder_traversal.__iter__

def __iter__(self):
    return self

.sympy.core.basic.preorder_traversal.__next__

def __next__(self):
    return next(self._pt)

.sympy.core.basic.preorder_traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            for subtree in self._preorder_traversal(arg, keys):
                yield subtree
    elif iterable(node):
        for item in node:
            for subtree in self._preorder_traversal(item, keys):
                yield subtree

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_extended_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.util import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
            seq = [a, b]
        assert not a is S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    rv = ([cls(a * r, b, evaluate=False)], [], None)
                elif global_distribute[0] and b.is_commutative:
                    r, b = b.as_coeff_Add()
                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
                    _addsort(bargs)
                    ar = a * r
                    if ar:
                        bargs.insert(0, ar)
                    bargs = [Add._from_args(bargs)]
                    rv = (bargs, [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number or isinstance(coeff, AccumBounds):
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            if coeff is S.ComplexInfinity:
                return ([S.ComplexInfinity], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):
                    return ([S.NaN], [], None)
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff is S.Infinity or coeff is S.NegativeInfinity:

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_extended_positive:
                    continue
                if t.is_extended_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
    elif coeff is S.Zero:
        if any((isinstance(c, MatrixExpr) for c in nc_part)):
            return ([coeff], nc_part, order_symbols)
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.operations.AssocOp.make_args

def make_args(cls, expr):
    if isinstance(expr, cls):
        return expr.args
    else:
        return (sympify(expr),)

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.basic.Basic.compare

def compare(self, other):
    if self is other:
        return 0
    n1 = self.__class__
    n2 = other.__class__
    c = (n1 > n2) - (n1 < n2)
    if c:
        return c
    st = self._hashable_content()
    ot = other._hashable_content()
    c = (len(st) > len(ot)) - (len(st) < len(ot))
    if c:
        return c
    for l, r in zip(st, ot):
        l = Basic(*l) if isinstance(l, frozenset) else l
        r = Basic(*r) if isinstance(r, frozenset) else r
        if isinstance(l, Basic):
            c = l.compare(r)
        else:
            c = (l > r) - (l < r)
        if c:
            return c
    return 0

.sympy.core.core.BasicMeta.__gt__

def __gt__(cls, other):
    if cls.__cmp__(other) == 1:
        return True
    return False

.sympy.core.core.BasicMeta.__cmp__

def __cmp__(cls, other):
    if not isinstance(other, BasicMeta):
        return -1
    n1 = cls.__name__
    n2 = other.__name__
    if n1 == n2:
        return 0
    UNKNOWN = len(ordering_of_classes) + 1
    try:
        i1 = ordering_of_classes.index(n1)
    except ValueError:
        i1 = UNKNOWN
    try:
        i2 = ordering_of_classes.index(n2)
    except ValueError:
        i2 = UNKNOWN
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)
    return (i1 > i2) - (i1 < i2)

.sympy.core.core.BasicMeta.__lt__

def __lt__(cls, other):
    if cls.__cmp__(other) == -1:
        return True
    return False

.sympy.core.add._unevaluated_Add

def _unevaluated_Add(*args):
    args = list(args)
    newargs = []
    co = S.Zero
    while args:
        a = args.pop()
        if a.is_Add:
            args.extend(a.args)
        elif a.is_Number:
            co += a
        else:
            newargs.append(a)
    _addsort(newargs)
    if co:
        newargs.insert(0, co)
    return Add._from_args(newargs)

.sympy.core.power.Pow._eval_evalf

def _eval_evalf(self, prec):
    base, exp = self.as_base_exp()
    base = base._evalf(prec)
    if not exp.is_Integer:
        exp = exp._evalf(prec)
    if exp.is_negative and base.is_number and (base.is_extended_real is False):
        base = base.conjugate() / (base * base.conjugate())._evalf(prec)
        exp = -exp
        return self.func(base, exp).expand()
    return self.func(base, exp)

.sympy.core.evalf.EvalfMixin._evalf

def _evalf(self, prec):
    r = self._eval_evalf(prec)
    if r is None:
        r = self
    return r

.sympy.core.numbers.Rational._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_rational(self.p, self.q, prec, rnd)

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.numbers.Float._eval_is_negative

def _eval_is_negative(self):
    if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
        return False
    return self.num < 0

.sympy.core.numbers.Float.num

def num(self):
    return mpmath.mpf(self._mpf_)

.sympy.core.numbers.Float._eval_is_integer

def _eval_is_integer(self):
    return self._mpf_ == fzero

.sympy.core.numbers.Float._eval_power

def _eval_power(self, expt):
    if self == 0:
        if expt.is_positive:
            return S.Zero
        if expt.is_negative:
            return S.Infinity
    if isinstance(expt, Number):
        if isinstance(expt, Integer):
            prec = self._prec
            return Float._new(mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
        elif isinstance(expt, Rational) and expt.p == 1 and expt.q % 2 and self.is_negative:
            return Pow(S.NegativeOne, expt, evaluate=False) * (-self)._eval_power(expt)
        expt, prec = expt._as_mpf_op(self._prec)
        mpfself = self._mpf_
        try:
            y = mpf_pow(mpfself, expt, prec, rnd)
            return Float._new(y, prec)
        except mlib.ComplexResult:
            re, im = mlib.mpc_pow((mpfself, fzero), (expt, fzero), prec, rnd)
            return Float._new(re, prec) + Float._new(im, prec) * S.ImaginaryUnit

.sympy.core.numbers.Float._as_mpf_op

def _as_mpf_op(self, prec):
    return (self._mpf_, max(prec, self._prec))

.sympy.core.mul.Mul._eval_evalf

def _eval_evalf(self, prec):
    c, m = self.as_coeff_Mul()
    if c is S.NegativeOne:
        if m.is_Mul:
            rv = -AssocOp._eval_evalf(m, prec)
        else:
            mnew = m._eval_evalf(prec)
            if mnew is not None:
                m = mnew
            rv = -m
    else:
        rv = AssocOp._eval_evalf(self, prec)
    if rv.is_number:
        return rv.expand()
    return rv

.sympy.core.numbers.Float.__neg__

def __neg__(self):
    return Float._new(mlib.mpf_neg(self._mpf_), self._prec)

.sympy.core.expr.Expr.expand

def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):
    from sympy.simplify.radsimp import fraction
    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)
    expr = self
    if hints.pop('frac', False):
        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]
        return n / d
    elif hints.pop('denom', False):
        n, d = fraction(self)
        return n / d.expand(deep=deep, modulus=modulus, **hints)
    elif hints.pop('numer', False):
        n, d = fraction(self)
        return n.expand(deep=deep, modulus=modulus, **hints) / d

    def _expand_hint_key(hint):
        if hint == 'mul':
            return 'mulz'
        return hint
    for hint in sorted(hints.keys(), key=_expand_hint_key):
        use_hint = hints[hint]
        if use_hint:
            hint = '_eval_expand_' + hint
            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
    while True:
        was = expr
        if hints.get('multinomial', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)
        if hints.get('mul', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)
        if hints.get('log', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)
        if expr == was:
            break
    if modulus is not None:
        modulus = sympify(modulus)
        if not modulus.is_Integer or modulus <= 0:
            raise ValueError('modulus must be a positive integer, got %s' % modulus)
        terms = []
        for term in Add.make_args(expr):
            coeff, tail = term.as_coeff_Mul(rational=True)
            coeff %= modulus
            if coeff:
                terms.append(coeff * tail)
        expr = Add(*terms)
    return expr

.sympy.core.expr.Expr._expand_hint_key

def _expand_hint_key(hint):
    if hint == 'mul':
        return 'mulz'
    return hint

.sympy.core.expr.Expr._expand_hint

def _expand_hint(expr, hint, deep=True, **hints):
    hit = False
    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):
        sargs = []
        for arg in expr.args:
            arg, arghit = Expr._expand_hint(arg, hint, **hints)
            hit |= arghit
            sargs.append(arg)
        if hit:
            expr = expr.func(*sargs)
    if hasattr(expr, hint):
        newexpr = getattr(expr, hint)(**hints)
        if newexpr != expr:
            return (newexpr, True)
    return (expr, hit)

.sympy.core.numbers.Rational.__add__

def __add__(self, other):
    if global_evaluate[0]:
        if isinstance(other, Integer):
            return Rational(self.p + self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return other + self
        else:
            return Number.__add__(self, other)
    return Number.__add__(self, other)

.sympy.core.numbers.Float.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_evaluate[0]:
        rhs, prec = other._as_mpf_op(self._prec)
        return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
    return Number.__add__(self, other)

.sympy.core.numbers.Number._as_mpf_op

def _as_mpf_op(self, prec):
    prec = max(prec, self._prec)
    return (self._as_mpf_val(prec), prec)

.sympy.core.evalf.evalf_mul

def evalf_mul(v, prec, options):
    res = pure_complex(v)
    if res:
        _, h = res
        im, _, im_acc, _ = evalf(h, prec, options)
        return (None, im, None, im_acc)
    args = list(v.args)
    special = []
    from sympy.core.numbers import Float
    for arg in args:
        arg = evalf(arg, prec, options)
        if arg[0] is None:
            continue
        arg = Float._new(arg[0], 1)
        if arg is S.NaN or arg.is_infinite:
            special.append(arg)
    if special:
        from sympy.core.mul import Mul
        special = Mul(*special)
        return evalf(special, prec + 4, {})
    acc = prec
    working_prec = prec + len(args) + 5
    start = man, exp, bc = (MPZ(1), 0, 1)
    last = len(args)
    direction = 0
    args.append(S.One)
    complex_factors = []
    for i, arg in enumerate(args):
        if i != last and pure_complex(arg):
            args[-1] = (args[-1] * arg).expand()
            continue
        elif i == last and arg is S.One:
            continue
        re, im, re_acc, im_acc = evalf(arg, working_prec, options)
        if re and im:
            complex_factors.append((re, im, re_acc, im_acc))
            continue
        elif re:
            (s, m, e, b), w_acc = (re, re_acc)
        elif im:
            (s, m, e, b), w_acc = (im, im_acc)
            direction += 1
        else:
            return (None, None, None, None)
        direction += 2 * s
        man *= m
        exp += e
        bc += b
        if bc > 3 * working_prec:
            man >>= working_prec
            exp += working_prec
        acc = min(acc, w_acc)
    sign = (direction & 2) >> 1
    if not complex_factors:
        v = normalize(sign, man, exp, bitcount(man), prec, rnd)
        if direction & 1:
            return (None, v, None, acc)
        else:
            return (v, None, acc, None)
    else:
        if (man, exp, bc) != start:
            re, im = ((sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0))
            i0 = 0
        else:
            wre, wim, wre_acc, wim_acc = complex_factors[0]
            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))
            re = wre
            im = wim
            i0 = 1
        for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:
            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))
            use_prec = working_prec
            A = mpf_mul(re, wre, use_prec)
            B = mpf_mul(mpf_neg(im), wim, use_prec)
            C = mpf_mul(re, wim, use_prec)
            D = mpf_mul(im, wre, use_prec)
            re = mpf_add(A, B, use_prec)
            im = mpf_add(C, D, use_prec)
        if options.get('verbose'):
            print('MUL: wanted', prec, 'accurate bits, got', acc)
        if direction & 1:
            re, im = (mpf_neg(im), re)
        return (re, im, acc, acc)

.sympy.core.expr.Expr.as_coeff_Add

def as_coeff_Add(self, rational=False):
    return (S.Zero, self)

.sympy.core.numbers.Rational.as_coeff_Add

def as_coeff_Add(self, rational=False):
    return (self, S.Zero)

.sympy.core.numbers.Float.__lt__

def __lt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__gt__(self)
    rv = self._Frel(other, mlib.mpf_lt)
    if rv is None:
        return Expr.__lt__(self, other)
    return rv

.sympy.logic.boolalg.BooleanFalse.__nonzero__

def __nonzero__(self):
    return False

.sympy.core.add.Add.as_real_imag

def as_real_imag(self, deep=True, **hints):
    sargs = self.args
    re_part, im_part = ([], [])
    for term in sargs:
        re, im = term.as_real_imag(deep=deep)
        re_part.append(re)
        im_part.append(im)
    return (self.func(*re_part), self.func(*im_part))

.sympy.core.mul.Mul.as_real_imag

def as_real_imag(self, deep=True, **hints):
    from sympy import Abs, expand_mul, im, re
    other = []
    coeffr = []
    coeffi = []
    addterms = S.One
    for a in self.args:
        r, i = a.as_real_imag()
        if i.is_zero:
            coeffr.append(r)
        elif r.is_zero:
            coeffi.append(i * S.ImaginaryUnit)
        elif a.is_commutative:
            for i, x in enumerate(other):
                if x == a.conjugate():
                    coeffr.append(Abs(x) ** 2)
                    del other[i]
                    break
            else:
                if a.is_Add:
                    addterms *= a
                else:
                    other.append(a)
        else:
            other.append(a)
    m = self.func(*other)
    if hints.get('ignore') == m:
        return
    if len(coeffi) % 2:
        imco = im(coeffi.pop(0))
    else:
        imco = S.Zero
    reco = self.func(*coeffr + coeffi)
    r, i = (reco * re(m), reco * im(m))
    if addterms == 1:
        if m == 1:
            if imco is S.Zero:
                return (reco, S.Zero)
            else:
                return (S.Zero, reco * imco)
        if imco is S.Zero:
            return (r, i)
        return (-imco * i, imco * r)
    addre, addim = expand_mul(addterms, deep=False).as_real_imag()
    if imco is S.Zero:
        return (r * addre - i * addim, i * addre + r * addim)
    else:
        r, i = (-imco * i, imco * r)
        return (r * addre - i * addim, r * addim + i * addre)

.sympy.core.expr.Expr.__mul__

def __mul__(self, other):
    return Mul(self, other)

.sympy.logic.boolalg.BooleanFalse.__hash__

def __hash__(self):
    return hash(False)

.sympy.core.power.Pow._eval_is_integer

def _eval_is_integer(self):
    b, e = self.args
    if b.is_rational:
        if b.is_integer is False and e.is_positive:
            return False
    if b.is_integer and e.is_integer:
        if b is S.NegativeOne:
            return True
        if e.is_nonnegative or e.is_positive:
            return True
    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
            return False
    if b.is_Number and e.is_Number:
        check = self.func(*self.args)
        return check.is_Integer

.sympy.ntheory.factor_._factors

def _factors():
    rv = 2 + n % 2
    while True:
        yield rv
        rv = nextprime(rv)

.sympy.ntheory.generate.primerange

def primerange(a, b):
    from sympy.functions.elementary.integers import ceiling
    if a >= b:
        return
    if b <= sieve._list[-1]:
        for i in sieve.primerange(a, b):
            yield i
        return
    a = as_int(ceiling(a)) - 1
    b = as_int(ceiling(b))
    while 1:
        a = nextprime(a)
        if a < b:
            yield a
        else:
            return

.sympy.core.mul.Mul._eval_is_integer

def _eval_is_integer(self):
    is_rational = self.is_rational
    if is_rational:
        n, d = self.as_numer_denom()
        if d is S.One:
            return True
        elif d is S(2):
            return n.is_even
    elif is_rational is False:
        return False

.sympy.core.mul.Mul._eval_is_rational

def _eval_is_rational(self):
    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.power.Pow._eval_is_negative

def _eval_is_negative(self):
    ext_neg = Pow._eval_is_extended_negative(self)
    if ext_neg is True:
        return self.is_finite
    return ext_neg

.sympy.core.mul.Mul._eval_is_hermitian

def _eval_is_hermitian(self):
    return self._eval_herm_antiherm(True)

.sympy.core.mul.Mul._eval_herm_antiherm

def _eval_herm_antiherm(self, real):
    one_nc = zero = one_neither = False
    for t in self.args:
        if not t.is_commutative:
            if one_nc:
                return
            one_nc = True
        if t.is_antihermitian:
            real = not real
        elif t.is_hermitian:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_hermitian is False:
            if one_neither:
                return
            one_neither = True
        else:
            return
    if one_neither:
        if real:
            return zero
    elif zero is False or real:
        return real

.sympy.core.mul.Mul._eval_is_finite

def _eval_is_finite(self):
    if all((a.is_finite for a in self.args)):
        return True
    if any((a.is_infinite for a in self.args)):
        if all((a.is_zero is False for a in self.args)):
            return False

.sympy.core.add.Add._eval_is_odd

def _eval_is_odd(self):
    l = [f for f in self.args if not f.is_even is True]
    if not l:
        return False
    if l[0].is_odd:
        return self._new_rawargs(*l[1:]).is_even

.sympy.core.add.Add._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all((x.is_rational is True for x in others)):
                return True
            return None
        if a is None:
            return
    return False

.sympy.core.power.Pow._eval_is_algebraic

def _eval_is_algebraic(self):

    def _is_one(expr):
        try:
            return (expr - 1).is_zero
        except ValueError:
            return False
    if self.base.is_zero or _is_one(self.base):
        return True
    elif self.exp.is_rational:
        if self.base.is_algebraic is False:
            return self.exp.is_zero
        return self.base.is_algebraic
    elif self.base.is_algebraic and self.exp.is_algebraic:
        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:
            return self.exp.is_rational

.sympy.core.power.Pow._is_one

def _is_one(expr):
    try:
        return (expr - 1).is_zero
    except ValueError:
        return False

.sympy.core.numbers.Integer.__sub__

def __sub__(self, other):
    if global_evaluate[0]:
        if isinstance(other, integer_types):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

.sympy.core.numbers.Rational._eval_is_zero

def _eval_is_zero(self):
    return self.p == 0

.sympy.core.mul.Mul._eval_is_algebraic

def _eval_is_algebraic(self):
    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.expr.Expr._eval_is_negative

def _eval_is_negative(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_negative = self.is_extended_negative
    if finite is True:
        return extended_negative
    if extended_negative is False:
        return False


[/PYTHON]
What will be the input of `__ge__`, given the following output:
[OUTPUT]
```
{
    "output": "ceiling(x) >= x"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "nargs": {}
    },
    "args": {
        "other": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
