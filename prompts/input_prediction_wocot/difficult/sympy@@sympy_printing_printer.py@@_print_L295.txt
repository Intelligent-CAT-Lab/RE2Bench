You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [/INPUT]. You should maintain the structure when printing inputs. Do not change anything else.  ONLY print the input, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from typing import Any, Type
from sympy.core.basic import Basic
from sympy.core.function import AppliedUndef, UndefinedFunction, Function

class Printer:
    _global_settings: dict[str, Any] = {}
    _default_settings: dict[str, Any] = {}
    printmethod: str = None

    @classmethod
    def _get_initial_settings(cls):
        settings = cls._default_settings.copy()
        for key, val in cls._global_settings.items():
            if key in cls._default_settings:
                settings[key] = val
        return settings

    def __init__(self, settings=None):
        self._str = str
        self._settings = self._get_initial_settings()
        self._context = {}
        if settings is not None:
            self._settings.update(settings)
            if len(self._settings) > len(self._default_settings):
                for key in self._settings:
                    if key not in self._default_settings:
                        raise TypeError("Unknown setting '%s'." % key)
        self._print_level = 0

    def _print(self, expr, **kwargs) -> str:
        self._print_level += 1
        try:
            if self.printmethod and hasattr(expr, self.printmethod):
                if not (isinstance(expr, type) and issubclass(expr, Basic)):
                    return getattr(expr, self.printmethod)(self, **kwargs)
            classes = type(expr).__mro__
            if AppliedUndef in classes:
                classes = classes[classes.index(AppliedUndef):]
            if UndefinedFunction in classes:
                classes = classes[classes.index(UndefinedFunction):]
            if Function in classes:
                i = classes.index(Function)
                classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]
            for cls in classes:
                printmethodname = '_print_' + cls.__name__
                printmethod = getattr(self, printmethodname, None)
                if printmethod is not None:
                    return printmethod(expr, **kwargs)
            return self.emptyPrinter(expr)
        finally:
            self._print_level -= 1

    def emptyPrinter(self, expr):
        return str(expr)
[/PYTHON]

Functions called during the execution:
[PYTHON]
sympy.sympy.codegen.ast._sympystr

def _sympystr(self, printer, *args, **kwargs):
    return self.text

sympy.sympy.codegen.ast._sympyrepr

def _sympyrepr(self, printer, *args, joiner=', ', **kwargs):
    from sympy.printing.printer import printer_context
    exclude = kwargs.get('exclude', ())
    values = [getattr(self, k) for k in self._fields]
    indent_level = printer._context.get('indent_level', 0)

    arg_reprs = []

    for i, (attr, value) in enumerate(zip(self._fields, values)):
        if attr in exclude:
            continue

        # Skip attributes which have the default value
        if attr in self.defaults and value == self.defaults[attr]:
            continue

        ilvl = indent_level + 4 if attr in self.indented_args else 0
        with printer_context(printer, indent_level=ilvl):
            indented = self._indented(printer, attr, value, *args, **kwargs)
        arg_reprs.append(('{1}' if i == 0 else '{0}={1}').format(attr, indented.lstrip()))

    return "{}({})".format(self.__class__.__name__, joiner.join(arg_reprs))

sympy.sympy.codegen.fnodes._sympystr

def _sympystr(self, printer):
    if len(self.args) == 0:
        return ':'
    return ":".join(str(arg) for arg in self.args)

sympy.sympy.codegen.fnodes._fcode

def _fcode(self, printer, *args, **kwargs):
    mantissa, sgnd_ex = ('%.{}e'.format(self._decimals) % self).split('e')
    mantissa = mantissa.strip('0').rstrip('.')
    ex_sgn, ex_num = sgnd_ex[0], sgnd_ex[1:].lstrip('0')
    ex_sgn = '' if ex_sgn == '+' else ex_sgn
    return (mantissa or '0') + self._token + ex_sgn + (ex_num or '0')

sympy.sympy.core.function._print_Dummy

def _print_Dummy(self, expr):
    return str(expr) + str(expr.dummy_index)

sympy.sympy.core.function.__eq__

def __eq__(self, other):
    return (isinstance(other, self.__class__) and
        self.class_key() == other.class_key() and
        self._kwargs == other._kwargs)

sympy.sympy.core.numbers._latex

def _latex(self, printer):
    return printer._settings['imaginary_unit_latex']

sympy.sympy.core.traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            # LatticeOp keeps args as a set. We should use this if we
            # don't care about the order, to prevent unnecessary sorting.
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            yield from self._preorder_traversal(arg, keys)
    elif iterable(node):
        for item in node:
            yield from self._preorder_traversal(item, keys)

sympy.sympy.functions.elementary.complexes._latex

def _latex(self, printer, exp=None, *args):
    arg = printer._print(self.args[0])
    tex = r'%s^{\dagger}' % arg
    if exp:
        tex = r'\left(%s\right)^{%s}' % (tex, exp)
    return tex

sympy.sympy.functions.elementary.complexes._pretty

def _pretty(self, printer, *args):
    from sympy.printing.pretty.stringpict import prettyForm
    pform = printer._print(self.args[0], *args)
    if printer._use_unicode:
        pform = pform**prettyForm('\N{DAGGER}')
    else:
        pform = pform**prettyForm('+')
    return pform

sympy.sympy.physics.biomechanics.curve._latex

def _latex(self, printer):
    """Print a LaTeX representation of the function defining the curve.

    Parameters
    ==========

    printer : Printer
        The printer to be used to print the LaTeX string representation.

    """
    fl_M_pas = self.args[0]
    _fl_M_pas = printer._print(fl_M_pas)
    return r'\left( \operatorname{fl}^M_{pas} \right)^{-1} \left( %s \right)' % _fl_M_pas

sympy.sympy.physics.biomechanics.curve._print_code

def _print_code(self, printer):
    """Print code for the function defining the curve using a printer.

    Explanation
    ===========

    The order of operations may need to be controlled as constant folding
    the numeric terms within the equations of a musculotendon
    characteristic curve can sometimes results in a numerically-unstable
    expression.

    Parameters
    ==========

    printer : Printer
        The printer to be used to print a string representation of the
        characteristic curve as valid code in the target language.

    """
    return printer._print(printer.parenthesize(
        self.doit(deep=False, evaluate=False), PRECEDENCE['Atom'],
    ))

sympy.sympy.physics.quantum.anticommutator._sympyrepr

def _sympyrepr(self, printer, *args):
    return "%s(%s,%s)" % (
        self.__class__.__name__, printer._print(
            self.args[0]), printer._print(self.args[1])
    )

sympy.sympy.physics.quantum.anticommutator._sympystr

def _sympystr(self, printer, *args):
    return "{%s,%s}" % (
        printer._print(self.args[0]), printer._print(self.args[1]))

sympy.sympy.physics.quantum.anticommutator._pretty

def _pretty(self, printer, *args):
    pform = printer._print(self.args[0], *args)
    pform = prettyForm(*pform.right(prettyForm(',')))
    pform = prettyForm(*pform.right(printer._print(self.args[1], *args)))
    pform = prettyForm(*pform.parens(left='{', right='}'))
    return pform

sympy.sympy.physics.quantum.anticommutator._latex

def _latex(self, printer, *args):
    return "\\left\\{%s,%s\\right\\}" % tuple([
        printer._print(arg, *args) for arg in self.args])

sympy.sympy.physics.quantum.cg._pretty

def _pretty(self, printer, *args):
    m = (
        (printer._print(
            self.j1), printer._print(self.j3), printer._print(self.j13)),
        (printer._print(
            self.j2), printer._print(self.j4), printer._print(self.j24)),
        (printer._print(self.j12), printer._print(self.j34), printer._print(self.j)))
    hsep = 2
    vsep = 1
    maxw = [-1]*3
    for j in range(3):
        maxw[j] = max(m[j][i].width() for i in range(3))
    D = None
    for i in range(3):
        D_row = None
        for j in range(3):
            s = m[j][i]
            wdelta = maxw[j] - s.width()
            wleft = wdelta //2
            wright = wdelta - wleft

            s = prettyForm(*s.right(' '*wright))
            s = prettyForm(*s.left(' '*wleft))

            if D_row is None:
                D_row = s
                continue
            D_row = prettyForm(*D_row.right(' '*hsep))
            D_row = prettyForm(*D_row.right(s))
        if D is None:
            D = D_row
            continue
        for _ in range(vsep):
            D = prettyForm(*D.below(' '))
        D = prettyForm(*D.below(D_row))
    D = prettyForm(*D.parens(left='{', right='}'))
    return D

sympy.sympy.physics.quantum.cg._latex

def _latex(self, printer, *args):
    label = map(printer._print, (self.j1, self.j2, self.j12, self.j3,
            self.j4, self.j34, self.j13, self.j24, self.j))
    return r'\left\{\begin{array}{ccc} %s & %s & %s \\ %s & %s & %s \\ %s & %s & %s \end{array}\right\}' % \
        tuple(label)

sympy.sympy.physics.quantum.commutator._sympyrepr

def _sympyrepr(self, printer, *args):
    return "%s(%s,%s)" % (
        self.__class__.__name__, printer._print(
            self.args[0]), printer._print(self.args[1])
    )

sympy.sympy.physics.quantum.commutator._sympystr

def _sympystr(self, printer, *args):
    return "[%s,%s]" % (
        printer._print(self.args[0]), printer._print(self.args[1]))

sympy.sympy.physics.quantum.commutator._pretty

def _pretty(self, printer, *args):
    pform = printer._print(self.args[0], *args)
    pform = prettyForm(*pform.right(prettyForm(',')))
    pform = prettyForm(*pform.right(printer._print(self.args[1], *args)))
    pform = prettyForm(*pform.parens(left='[', right=']'))
    return pform

sympy.sympy.physics.quantum.commutator._latex

def _latex(self, printer, *args):
    return "\\left[%s,%s\\right]" % tuple([
        printer._print(arg, *args) for arg in self.args])

sympy.sympy.physics.quantum.constants._sympyrepr

def _sympyrepr(self, printer, *args):
    return 'HBar()'

sympy.sympy.physics.quantum.constants._sympystr

def _sympystr(self, printer, *args):
    return 'hbar'

sympy.sympy.physics.quantum.constants._pretty

def _pretty(self, printer, *args):
    if printer._use_unicode:
        return prettyForm('\N{PLANCK CONSTANT OVER TWO PI}')
    return prettyForm('hbar')

sympy.sympy.physics.quantum.constants._latex

def _latex(self, printer, *args):
    return r'\hbar'

sympy.sympy.physics.quantum.dagger.<lambda>

adjoint._sympyrepr = lambda a, b: "Dagger(%s)" % b._print(a.args[0])


sympy.sympy.physics.quantum.gate._sympystr

def _sympystr(self, printer, *args):
    label = self._print_label(printer, *args)
    return '%s(%s)' % (self.gate_name, label)

sympy.sympy.physics.quantum.gate._pretty

def _pretty(self, printer, *args):
    return Gate._pretty(self, printer, *args)

sympy.sympy.physics.quantum.gate._latex

def _latex(self, printer, *args):
    return Gate._latex(self, printer, *args)

sympy.sympy.physics.quantum.hilbert._sympystr

def _sympystr(self, printer, *args):
    return "%s**%s" % (printer._print(self.base, *args),
    printer._print(self.exp, *args))

sympy.sympy.physics.quantum.hilbert._pretty

def _pretty(self, printer, *args):
    pform_exp = printer._print(self.exp, *args)
    if printer._use_unicode:
        pform_exp = prettyForm(*pform_exp.left(prettyForm('\N{N-ARY CIRCLED TIMES OPERATOR}')))
    else:
        pform_exp = prettyForm(*pform_exp.left(prettyForm('x')))
    pform_base = printer._print(self.base, *args)
    return pform_base**pform_exp

sympy.sympy.physics.quantum.hilbert._latex

def _latex(self, printer, *args):
    base = printer._print(self.base, *args)
    exp = printer._print(self.exp, *args)
    return r'{%s}^{\otimes %s}' % (base, exp)

sympy.sympy.physics.quantum.hilbert._sympyrepr

def _sympyrepr(self, printer, *args):
    return "TensorPowerHilbertSpace(%s,%s)" % (printer._print(self.base,
    *args), printer._print(self.exp, *args))

sympy.sympy.physics.quantum.innerproduct._sympystr

def _sympystr(self, printer, *args):
    sbra = printer._print(self.bra)
    sket = printer._print(self.ket)
    return '%s|%s' % (sbra[:-1], sket[1:])

sympy.sympy.physics.quantum.innerproduct._pretty

def _pretty(self, printer, *args):
    # Print state contents
    bra = self.bra._print_contents_pretty(printer, *args)
    ket = self.ket._print_contents_pretty(printer, *args)
    # Print brackets
    height = max(bra.height(), ket.height())
    use_unicode = printer._use_unicode
    lbracket, _ = self.bra._pretty_brackets(height, use_unicode)
    cbracket, rbracket = self.ket._pretty_brackets(height, use_unicode)
    # Build innerproduct
    pform = prettyForm(*bra.left(lbracket))
    pform = prettyForm(*pform.right(cbracket))
    pform = prettyForm(*pform.right(ket))
    pform = prettyForm(*pform.right(rbracket))
    return pform

sympy.sympy.physics.quantum.innerproduct._latex

def _latex(self, printer, *args):
    bra_label = self.bra._print_contents_latex(printer, *args)
    ket = printer._print(self.ket, *args)
    return r'\left\langle %s \right. %s' % (bra_label, ket)

sympy.sympy.physics.quantum.innerproduct._sympyrepr

def _sympyrepr(self, printer, *args):
    return '%s(%s,%s)' % (self.__class__.__name__,
        printer._print(self.bra, *args), printer._print(self.ket, *args))

sympy.sympy.physics.quantum.operator._sympystr

def _sympystr(self, printer, *args):
    return printer._print(self.ket) + printer._print(self.bra)

sympy.sympy.physics.quantum.operator._sympyrepr

def _sympyrepr(self, printer, *args):
    return '%s(%s,%s)' % (self.__class__.__name__,
        printer._print(self.ket, *args), printer._print(self.bra, *args))

sympy.sympy.physics.quantum.operator._pretty

def _pretty(self, printer, *args):
    pform = self.ket._pretty(printer, *args)
    return prettyForm(*pform.right(self.bra._pretty(printer, *args)))

sympy.sympy.physics.quantum.operator._latex

def _latex(self, printer, *args):
    k = printer._print(self.ket, *args)
    b = printer._print(self.bra, *args)
    return k + b

sympy.sympy.physics.quantum.qexpr._sympystr

def _sympystr(self, printer, *args):
    """Default printing behavior of QExpr objects

    Handles the default printing of a QExpr. To add other things to the
    printing of the object, such as an operator name to operators or
    brackets to states, the class should override the _print/_pretty/_latex
    functions directly and make calls to _print_contents where appropriate.
    This allows things like InnerProduct to easily control its printing the
    printing of contents.
    """
    return self._print_contents(printer, *args)

sympy.sympy.physics.quantum.qexpr._sympyrepr

def _sympyrepr(self, printer, *args):
    classname = self.__class__.__name__
    label = self._print_label_repr(printer, *args)
    return '%s(%s)' % (classname, label)

sympy.sympy.physics.quantum.qexpr._pretty

def _pretty(self, printer, *args):
    pform = self._print_contents_pretty(printer, *args)
    return pform

sympy.sympy.physics.quantum.qexpr._latex

def _latex(self, printer, *args):
    return self._print_contents_latex(printer, *args)

sympy.sympy.physics.quantum.spin._latex

def _latex(self, printer, *args):
    if self.alpha == 0 and self.gamma == 0:
        return r'd^{%s}_{%s,%s}\left(%s\right)' % \
            (
                printer._print(self.j), printer._print(
                    self.m), printer._print(self.mp),
                printer._print(self.beta) )
    return r'D^{%s}_{%s,%s}\left(%s,%s,%s\right)' % \
        (
            printer._print(
                self.j), printer._print(self.m), printer._print(self.mp),
            printer._print(self.alpha), printer._print(self.beta), printer._print(self.gamma) )

sympy.sympy.physics.quantum.spin._pretty

def _pretty(self, printer, *args):
    top = printer._print(self.j)

    bot = printer._print(self.m)
    bot = prettyForm(*bot.right(','))
    bot = prettyForm(*bot.right(printer._print(self.mp)))

    pad = max(top.width(), bot.width())
    top = prettyForm(*top.left(' '))
    bot = prettyForm(*bot.left(' '))
    if pad > top.width():
        top = prettyForm(*top.right(' '*(pad - top.width())))
    if pad > bot.width():
        bot = prettyForm(*bot.right(' '*(pad - bot.width())))
    if self.alpha == 0 and self.gamma == 0:
        args = printer._print(self.beta)
        s = stringPict('d' + ' '*pad)
    else:
        args = printer._print(self.alpha)
        args = prettyForm(*args.right(','))
        args = prettyForm(*args.right(printer._print(self.beta)))
        args = prettyForm(*args.right(','))
        args = prettyForm(*args.right(printer._print(self.gamma)))

        s = stringPict('D' + ' '*pad)

    args = prettyForm(*args.parens())
    s = prettyForm(*s.above(top))
    s = prettyForm(*s.below(bot))
    s = prettyForm(*s.right(args))
    return s

sympy.sympy.physics.quantum.state._sympystr

def _sympystr(self, printer, *args):
    contents = self._print_contents(printer, *args)
    return '%s%s%s' % (getattr(self, 'lbracket', ""), contents, getattr(self, 'rbracket', ""))

sympy.sympy.physics.quantum.state._pretty

def _pretty(self, printer, *args):
    from sympy.printing.pretty.stringpict import prettyForm
    # Get brackets
    pform = self._print_contents_pretty(printer, *args)
    lbracket, rbracket = self._pretty_brackets(
        pform.height(), printer._use_unicode)
    # Put together state
    pform = prettyForm(*pform.left(lbracket))
    pform = prettyForm(*pform.right(rbracket))
    return pform

sympy.sympy.physics.quantum.state._latex

def _latex(self, printer, *args):
    contents = self._print_contents_latex(printer, *args)
    # The extra {} brackets are needed to get matplotlib's latex
    # rendered to render this properly.
    return '{%s%s%s}' % (getattr(self, 'lbracket_latex', ""), contents, getattr(self, 'rbracket_latex', ""))

sympy.sympy.physics.quantum.tensorproduct._sympystr

def _sympystr(self, printer, *args):
    length = len(self.args)
    s = ''
    for i in range(length):
        if isinstance(self.args[i], (Add, Pow, Mul)):
            s = s + '('
        s = s + printer._print(self.args[i])
        if isinstance(self.args[i], (Add, Pow, Mul)):
            s = s + ')'
        if i != length - 1 and not isinstance(self.args[i], (KetBase, BraBase)):
            s = s + 'x'
    return s

sympy.sympy.physics.quantum.tensorproduct._pretty

def _pretty(self, printer, *args):

    if (_combined_printing and
            (all(isinstance(arg, Ket) for arg in self.args) or
             all(isinstance(arg, Bra) for arg in self.args))):

        length = len(self.args)
        pform = printer._print('', *args)
        for i in range(length):
            next_pform = printer._print('', *args)
            length_i = len(self.args[i].args)
            for j in range(length_i):
                part_pform = printer._print(self.args[i].args[j], *args)
                next_pform = prettyForm(*next_pform.right(part_pform))
                if j != length_i - 1:
                    next_pform = prettyForm(*next_pform.right(', '))

            if len(self.args[i].args) > 1:
                next_pform = prettyForm(
                    *next_pform.parens(left='{', right='}'))
            pform = prettyForm(*pform.right(next_pform))
            if i != length - 1:
                pform = prettyForm(*pform.right(',' + ' '))

        pform = prettyForm(*pform.left(self.args[0].lbracket))
        pform = prettyForm(*pform.right(self.args[0].rbracket))
        return pform

    length = len(self.args)
    pform = printer._print('', *args)
    for i in range(length):
        next_pform = printer._print(self.args[i], *args)
        if isinstance(self.args[i], (Add, Mul)):
            next_pform = prettyForm(
                *next_pform.parens(left='(', right=')')
            )
        pform = prettyForm(*pform.right(next_pform))
        if i != length - 1 and not isinstance(self.args[i], (KetBase, BraBase)):
            if printer._use_unicode:
                pform = prettyForm(*pform.right('\N{N-ARY CIRCLED TIMES OPERATOR}' + ' '))
            else:
                pform = prettyForm(*pform.right('x' + ' '))
    return pform

sympy.sympy.physics.quantum.tensorproduct._latex

def _latex(self, printer, *args):

    if (_combined_printing and
            (all(isinstance(arg, Ket) for arg in self.args) or
             all(isinstance(arg, Bra) for arg in self.args))):

        def _label_wrap(label, nlabels):
            return label if nlabels == 1 else r"\left\{%s\right\}" % label

        s = r", ".join([_label_wrap(arg._print_label_latex(printer, *args),
                                    len(arg.args)) for arg in self.args])

        return r"{%s%s%s}" % (self.args[0].lbracket_latex, s,
                              self.args[0].rbracket_latex)

    length = len(self.args)
    s = ''
    for i in range(length):
        if isinstance(self.args[i], (Add, Mul)):
            s = s + '\\left('
        # The extra {} brackets are needed to get matplotlib's latex
        # rendered to render this properly.
        s = s + '{' + printer._print(self.args[i], *args) + '}'
        if isinstance(self.args[i], (Add, Mul)):
            s = s + '\\right)'
        if i != length - 1 and not isinstance(self.args[i], (KetBase, BraBase)):
            s = s + '\\otimes '
    return s

sympy.sympy.physics.secondquant._latex

def _latex(self, printer):
    return "%s%s%s" % (getattr(self, 'lbracket_latex', ""), printer._print(self._labels()), getattr(self, 'rbracket_latex', ""))

sympy.sympy.physics.secondquant._print_Dummy

def _print_Dummy(self, expr):
    return "(%s_%i)" % (expr.name, expr.dummy_index)

sympy.sympy.physics.units.prefixes._latex

def _latex(self, printer):
    if self._latex_repr is None:
        return r'\text{%s}' % self._abbrev
    return self._latex_repr

sympy.sympy.physics.units.quantities._latex

def _latex(self, printer):
    if self._latex_repr:
        return self._latex_repr
    else:
        return r'\text{{{}}}'.format(self.args[1] \
                      if len(self.args) >= 2 else self.args[0])

sympy.sympy.physics.vector.dyadic._latex

def _latex(self, printer):
    ar = self.args  # just to shorten things
    if len(ar) == 0:
        return str(0)
    ol = []  # output list, to be concatenated to a string
    for v in ar:
        # if the coef of the dyadic is 1, we skip the 1
        if v[0] == 1:
            ol.append(' + ' + printer._print(v[1]) + r"\otimes " +
                      printer._print(v[2]))
        # if the coef of the dyadic is -1, we skip the 1
        elif v[0] == -1:
            ol.append(' - ' +
                      printer._print(v[1]) +
                      r"\otimes " +
                      printer._print(v[2]))
        # If the coefficient of the dyadic is not 1 or -1,
        # we might wrap it in parentheses, for readability.
        elif v[0] != 0:
            arg_str = printer._print(v[0])
            if isinstance(v[0], Add):
                arg_str = '(%s)' % arg_str
            if arg_str.startswith('-'):
                arg_str = arg_str[1:]
                str_start = ' - '
            else:
                str_start = ' + '
            ol.append(str_start + arg_str + printer._print(v[1]) +
                      r"\otimes " + printer._print(v[2]))
    outstr = ''.join(ol)
    if outstr.startswith(' + '):
        outstr = outstr[3:]
    elif outstr.startswith(' '):
        outstr = outstr[1:]
    return outstr

sympy.sympy.physics.vector.dyadic._pretty

def _pretty(self, printer):
    e = self

    class Fake:
        baseline = 0

        def render(self, *args, **kwargs):
            ar = e.args  # just to shorten things
            mpp = printer
            if len(ar) == 0:
                return str(0)
            bar = "\N{CIRCLED TIMES}" if printer._use_unicode else "|"
            ol = []  # output list, to be concatenated to a string
            for v in ar:
                # if the coef of the dyadic is 1, we skip the 1
                if v[0] == 1:
                    ol.extend([" + ",
                              mpp.doprint(v[1]),
                              bar,
                              mpp.doprint(v[2])])

                # if the coef of the dyadic is -1, we skip the 1
                elif v[0] == -1:
                    ol.extend([" - ",
                              mpp.doprint(v[1]),
                              bar,
                              mpp.doprint(v[2])])

                # If the coefficient of the dyadic is not 1 or -1,
                # we might wrap it in parentheses, for readability.
                elif v[0] != 0:
                    if isinstance(v[0], Add):
                        arg_str = mpp._print(
                            v[0]).parens()[0]
                    else:
                        arg_str = mpp.doprint(v[0])
                    if arg_str.startswith("-"):
                        arg_str = arg_str[1:]
                        str_start = " - "
                    else:
                        str_start = " + "
                    ol.extend([str_start, arg_str, " ",
                              mpp.doprint(v[1]),
                              bar,
                              mpp.doprint(v[2])])

            outstr = "".join(ol)
            if outstr.startswith(" + "):
                outstr = outstr[3:]
            elif outstr.startswith(" "):
                outstr = outstr[1:]
            return outstr
    return Fake()

sympy.sympy.physics.vector.dyadic._sympystr

def _sympystr(self, printer):
    """Printing method. """
    ar = self.args  # just to shorten things
    if len(ar) == 0:
        return printer._print(0)
    ol = []  # output list, to be concatenated to a string
    for v in ar:
        # if the coef of the dyadic is 1, we skip the 1
        if v[0] == 1:
            ol.append(' + (' + printer._print(v[1]) + '|' +
                      printer._print(v[2]) + ')')
        # if the coef of the dyadic is -1, we skip the 1
        elif v[0] == -1:
            ol.append(' - (' + printer._print(v[1]) + '|' +
                      printer._print(v[2]) + ')')
        # If the coefficient of the dyadic is not 1 or -1,
        # we might wrap it in parentheses, for readability.
        elif v[0] != 0:
            arg_str = printer._print(v[0])
            if isinstance(v[0], Add):
                arg_str = "(%s)" % arg_str
            if arg_str[0] == '-':
                arg_str = arg_str[1:]
                str_start = ' - '
            else:
                str_start = ' + '
            ol.append(str_start + arg_str + '*(' +
                      printer._print(v[1]) +
                      '|' + printer._print(v[2]) + ')')
    outstr = ''.join(ol)
    if outstr.startswith(' + '):
        outstr = outstr[3:]
    elif outstr.startswith(' '):
        outstr = outstr[1:]
    return outstr

sympy.sympy.physics.vector.printing._print_Derivative

def _print_Derivative(self, der_expr):
    from sympy.physics.vector.functions import dynamicsymbols
    # make sure it is in the right form
    der_expr = der_expr.doit()
    if not isinstance(der_expr, Derivative):
        return r"\left(%s\right)" % self.doprint(der_expr)

    # check if expr is a dynamicsymbol
    t = dynamicsymbols._t
    expr = der_expr.expr
    red = expr.atoms(AppliedUndef)
    syms = der_expr.variables
    test1 = not all(True for i in red if i.free_symbols == {t})
    test2 = not all(t == i for i in syms)
    if test1 or test2:
        return super()._print_Derivative(der_expr)

    # done checking
    dots = len(syms)
    base = self._print_Function(expr)
    base_split = base.split('_', 1)
    base = base_split[0]
    if dots == 1:
        base = r"\dot{%s}" % base
    elif dots == 2:
        base = r"\ddot{%s}" % base
    elif dots == 3:
        base = r"\dddot{%s}" % base
    elif dots == 4:
        base = r"\ddddot{%s}" % base
    else:  # Fallback to standard printing
        return super()._print_Derivative(der_expr)
    if len(base_split) != 1:
        base += '_' + base_split[1]
    return base

sympy.sympy.physics.vector.printing._print_Function

def _print_Function(self, expr, exp=None):
    from sympy.physics.vector.functions import dynamicsymbols
    func = expr.func.__name__
    t = dynamicsymbols._t

    if (hasattr(self, '_print_' + func) and not
        isinstance(type(expr), UndefinedFunction)):
        return getattr(self, '_print_' + func)(expr, exp)
    elif isinstance(type(expr), UndefinedFunction) and (expr.args == (t,)):
        # treat this function like a symbol
        expr = Symbol(func)
        if exp is not None:
            # copied from LatexPrinter._helper_print_standard_power, which
            # we can't call because we only have exp as a string.
            base = self.parenthesize(expr, PRECEDENCE['Pow'])
            base = self.parenthesize_super(base)
            return r"%s^{%s}" % (base, exp)
        else:
            return super()._print(expr)
    else:
        return super()._print_Function(expr, exp)

sympy.sympy.physics.vector.vector._latex

def _latex(self, printer):
    """Latex Printing method. """

    ar = self.args  # just to shorten things
    if len(ar) == 0:
        return str(0)
    ol = []  # output list, to be concatenated to a string
    for v in ar:
        for j in 0, 1, 2:
            # if the coef of the basis vector is 1, we skip the 1
            if v[0][j] == 1:
                ol.append(' + ' + v[1].latex_vecs[j])
            # if the coef of the basis vector is -1, we skip the 1
            elif v[0][j] == -1:
                ol.append(' - ' + v[1].latex_vecs[j])
            elif v[0][j] != 0:
                # If the coefficient of the basis vector is not 1 or -1;
                # also, we might wrap it in parentheses, for readability.
                arg_str = printer._print(v[0][j])
                if isinstance(v[0][j], Add):
                    arg_str = "(%s)" % arg_str
                if arg_str[0] == '-':
                    arg_str = arg_str[1:]
                    str_start = ' - '
                else:
                    str_start = ' + '
                ol.append(str_start + arg_str + v[1].latex_vecs[j])
    outstr = ''.join(ol)
    if outstr.startswith(' + '):
        outstr = outstr[3:]
    elif outstr.startswith(' '):
        outstr = outstr[1:]
    return outstr

sympy.sympy.physics.vector.vector._pretty

def _pretty(self, printer):
    """Pretty Printing method. """
    from sympy.printing.pretty.stringpict import prettyForm

    terms = []

    def juxtapose(a, b):
        pa = printer._print(a)
        pb = printer._print(b)
        if a.is_Add:
            pa = prettyForm(*pa.parens())
        return printer._print_seq([pa, pb], delimiter=' ')

    for M, N in self.args:
        for i in range(3):
            if M[i] == 0:
                continue
            elif M[i] == 1:
                terms.append(prettyForm(N.pretty_vecs[i]))
            elif M[i] == -1:
                terms.append(prettyForm("-1") * prettyForm(N.pretty_vecs[i]))
            else:
                terms.append(juxtapose(M[i], N.pretty_vecs[i]))

    if terms:
        pretty_result = prettyForm.__add__(*terms)
    else:
        pretty_result = prettyForm("0")

    return pretty_result

sympy.sympy.physics.vector.vector._sympystr

def _sympystr(self, printer, order=True):
    """Printing method. """
    if not order or len(self.args) == 1:
        ar = list(self.args)
    elif len(self.args) == 0:
        return printer._print(0)
    else:
        d = {v[1]: v[0] for v in self.args}
        keys = sorted(d.keys(), key=lambda x: x.index)
        ar = []
        for key in keys:
            ar.append((d[key], key))
    ol = []  # output list, to be concatenated to a string
    for v in ar:
        for j in 0, 1, 2:
            # if the coef of the basis vector is 1, we skip the 1
            if v[0][j] == 1:
                ol.append(' + ' + v[1].str_vecs[j])
            # if the coef of the basis vector is -1, we skip the 1
            elif v[0][j] == -1:
                ol.append(' - ' + v[1].str_vecs[j])
            elif v[0][j] != 0:
                # If the coefficient of the basis vector is not 1 or -1;
                # also, we might wrap it in parentheses, for readability.
                arg_str = printer._print(v[0][j])
                if isinstance(v[0][j], Add):
                    arg_str = "(%s)" % arg_str
                if arg_str[0] == '-':
                    arg_str = arg_str[1:]
                    str_start = ' - '
                else:
                    str_start = ' + '
                ol.append(str_start + arg_str + '*' + v[1].str_vecs[j])
    outstr = ''.join(ol)
    if outstr.startswith(' + '):
        outstr = outstr[3:]
    elif outstr.startswith(' '):
        outstr = outstr[1:]
    return outstr

sympy.sympy.printing.c._meth_wrapper

@wraps(meth)
def _meth_wrapper(self, expr, **kwargs):
    if expr in self.math_macros:
        return '%s%s' % (self.math_macros[expr], self._get_math_macro_suffix(real))
    else:
        return meth(self, expr, **kwargs)

sympy.sympy.printing.c._print_Mod

def _print_Mod(self, expr):
    num, den = expr.args
    if num.is_integer and den.is_integer:
        PREC = precedence(expr)
        snum, sden = [self.parenthesize(arg, PREC) for arg in expr.args]
        # % is remainder (same sign as numerator), not modulo (same sign as
        # denominator), in C. Hence, % only works as modulo if both numbers
        # have the same sign
        if (num.is_nonnegative and den.is_nonnegative or
            num.is_nonpositive and den.is_nonpositive):
            return f"{snum} % {sden}"
        return f"(({snum} % {sden}) + {sden}) % {sden}"
    # Not guaranteed integer
    return self._print_math_func(expr, known='fmod')

sympy.sympy.printing.c._print_Rational

def _print_Rational(self, expr):
    p, q = int(expr.p), int(expr.q)
    suffix = self._get_literal_suffix(real)
    return '%d.0%s/%d.0%s' % (p, suffix, q, suffix)

sympy.sympy.printing.c._print_Indexed

def _print_Indexed(self, expr):
    # calculate index for 1d array
    offset = getattr(expr.base, 'offset', S.Zero)
    strides = getattr(expr.base, 'strides', None)
    indices = expr.indices

    if strides is None or isinstance(strides, str):
        dims = expr.shape
        shift = S.One
        temp = ()
        if strides == 'C' or strides is None:
            traversal = reversed(range(expr.rank))
            indices = indices[::-1]
        elif strides == 'F':
            traversal = range(expr.rank)

        for i in traversal:
            temp += (shift,)
            shift *= dims[i]
        strides = temp
    flat_index = sum(x[0]*x[1] for x in zip(indices, strides)) + offset
    return "%s[%s]" % (self._print(expr.base.label),
                       self._print(flat_index))

sympy.sympy.printing.c._print_Infinity

def _print_Infinity(self, expr):
    return 'INFINITY'

sympy.sympy.printing.c._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-INFINITY'

sympy.sympy.printing.c._print_Piecewise

def _print_Piecewise(self, expr):
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []
    if expr.has(Assignment):
        for i, (e, c) in enumerate(expr.args):
            if i == 0:
                lines.append("if (%s) {" % self._print(c))
            elif i == len(expr.args) - 1 and c == True:
                lines.append("else {")
            else:
                lines.append("else if (%s) {" % self._print(c))
            code0 = self._print(e)
            lines.append(code0)
            lines.append("}")
        return "\n".join(lines)
    else:
        # The piecewise was used in an expression, need to do inline
        # operators. This has the downside that inline operators will
        # not work for statements that span multiple lines (Matrix or
        # Indexed expressions).
        ecpairs = ["((%s) ? (\n%s\n)\n" % (self._print(c),
                                           self._print(e))
                for e, c in expr.args[:-1]]
        last_line = ": (\n%s\n)" % self._print(expr.args[-1].expr)
        return ": ".join(ecpairs) + last_line + " ".join([")"*len(ecpairs)])

sympy.sympy.printing.c._print_ITE

def _print_ITE(self, expr):
    from sympy.functions import Piecewise
    return self._print(expr.rewrite(Piecewise, deep=False))

sympy.sympy.printing.c._print_MatrixElement

def _print_MatrixElement(self, expr):
    return "{}[{}]".format(self.parenthesize(expr.parent, PRECEDENCE["Atom"],
        strict=True), expr.j + expr.i*expr.parent.shape[1])

sympy.sympy.printing.c._print_Symbol

def _print_Symbol(self, expr):
    name = super()._print_Symbol(expr)
    if expr in self._settings['dereference']:
        return '(*{})'.format(name)
    else:
        return name

sympy.sympy.printing.c._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.c._print_For

def _print_For(self, expr):
    target = self._print(expr.target)
    if isinstance(expr.iterable, Range):
        start, stop, step = expr.iterable.args
    else:
        raise NotImplementedError("Only iterable currently supported is Range")
    body = self._print(expr.body)
    return ('for ({target} = {start}; {target} < {stop}; {target} += '
            '{step}) {{\n{body}\n}}').format(target=target, start=start,
            stop=stop, step=step, body=body)

sympy.sympy.printing.c._print_sign

def _print_sign(self, func):
    return '((({0}) > 0) - (({0}) < 0))'.format(self._print(func.args[0]))

sympy.sympy.printing.c._print_Max

def _print_Max(self, expr):
    return self._print_math_func(expr, nest=True)

sympy.sympy.printing.c._print_Min

def _print_Min(self, expr):
    return self._print_math_func(expr, nest=True)

sympy.sympy.printing.c._print_Tuple

def _print_Tuple(self, expr):
    return '{'+', '.join(self._print(e) for e in expr)+'}'

sympy.sympy.printing.c._print_Type

def _print_Type(self, type_):
    self.headers.update(self.type_headers.get(type_, set()))
    self.macros.update(self.type_macros.get(type_, set()))
    return self._print(self.type_mappings.get(type_, type_.name))

sympy.sympy.printing.c._print_Declaration

def _print_Declaration(self, decl):
    from sympy.codegen.cnodes import restrict
    var = decl.variable
    val = var.value
    if var.type == untyped:
        raise ValueError("C does not support untyped variables")

    if isinstance(var, Pointer):
        result = '{vc}{t} *{pc} {r}{s}'.format(
            vc='const ' if value_const in var.attrs else '',
            t=self._print(var.type),
            pc=' const' if pointer_const in var.attrs else '',
            r='restrict ' if restrict in var.attrs else '',
            s=self._print(var.symbol)
        )
    elif isinstance(var, Variable):
        result = '{vc}{t} {s}'.format(
            vc='const ' if value_const in var.attrs else '',
            t=self._print(var.type),
            s=self._print(var.symbol)
        )
    else:
        raise NotImplementedError("Unknown type of var: %s" % type(var))
    if val != None: # Must be "!= None", cannot be "is not None"
        result += ' = %s' % self._print(val)
    return result

sympy.sympy.printing.c._print_Float

def _print_Float(self, flt):
    type_ = self.type_aliases.get(real, real)
    self.macros.update(self.type_macros.get(type_, set()))
    suffix = self._get_literal_suffix(type_)
    num = str(flt.evalf(type_.decimal_dig))
    if 'e' not in num and '.' not in num:
        num += '.0'
    num_parts = num.split('e')
    num_parts[0] = num_parts[0].rstrip('0')
    if num_parts[0].endswith('.'):
        num_parts[0] += '0'
    return 'e'.join(num_parts) + suffix

sympy.sympy.printing.c._print_Element

def _print_Element(self, elem):
    if elem.strides == None: # Must be "== None", cannot be "is None"
        if elem.offset != None: # Must be "!= None", cannot be "is not None"
            raise ValueError("Expected strides when offset is given")
        idxs = ']['.join((self._print(arg) for arg in elem.indices))
    else:
        global_idx = sum(i*s for i, s in zip(elem.indices, elem.strides))
        if elem.offset != None: # Must be "!= None", cannot be "is not None"
            global_idx += elem.offset
        idxs = self._print(global_idx)

    return "{symb}[{idxs}]".format(
        symb=self._print(elem.symbol),
        idxs=idxs
    )

sympy.sympy.printing.c._print_CodeBlock

def _print_CodeBlock(self, expr):
    """ Elements of code blocks printed as statements. """
    return '\n'.join([self._get_statement(self._print(i)) for i in expr.args])

sympy.sympy.printing.c._print_While

def _print_While(self, expr):
    return 'while ({condition}) {{\n{body}\n}}'.format(**expr.kwargs(
        apply=lambda arg: self._print(arg)))

sympy.sympy.printing.c._print_Scope

def _print_Scope(self, expr):
    return '{\n%s\n}' % self._print_CodeBlock(expr.body)

sympy.sympy.printing.c._print_Stream

def _print_Stream(self, strm):
    return strm.name

sympy.sympy.printing.c._print_FunctionPrototype

def _print_FunctionPrototype(self, expr):
    pars = ', '.join((self._print(Declaration(arg)) for arg in expr.parameters))
    return "%s %s(%s)" % (
        tuple((self._print(arg) for arg in (expr.return_type, expr.name))) + (pars,)
    )

sympy.sympy.printing.c._print_FunctionDefinition

def _print_FunctionDefinition(self, expr):
    return "%s%s" % (self._print_FunctionPrototype(expr),
                     self._print_Scope(expr))

sympy.sympy.printing.c._print_Return

def _print_Return(self, expr):
    arg, = expr.args
    return 'return %s' % self._print(arg)

sympy.sympy.printing.c._print_CommaOperator

def _print_CommaOperator(self, expr):
    return '(%s)' % ', '.join((self._print(arg) for arg in expr.args))

sympy.sympy.printing.c._print_Label

def _print_Label(self, expr):
    if expr.body == none:
        return '%s:' % str(expr.name)
    if len(expr.body.args) == 1:
        return '%s:\n%s' % (str(expr.name), self._print_CodeBlock(expr.body))
    return '%s:\n{\n%s\n}' % (str(expr.name), self._print_CodeBlock(expr.body))

sympy.sympy.printing.c._print_goto

def _print_goto(self, expr):
    return 'goto %s' % expr.label.name

sympy.sympy.printing.c._print_PreIncrement

def _print_PreIncrement(self, expr):
    arg, = expr.args
    return '++(%s)' % self._print(arg)

sympy.sympy.printing.c._print_PostIncrement

def _print_PostIncrement(self, expr):
    arg, = expr.args
    return '(%s)++' % self._print(arg)

sympy.sympy.printing.c._print_PreDecrement

def _print_PreDecrement(self, expr):
    arg, = expr.args
    return '--(%s)' % self._print(arg)

sympy.sympy.printing.c._print_PostDecrement

def _print_PostDecrement(self, expr):
    arg, = expr.args
    return '(%s)--' % self._print(arg)

sympy.sympy.printing.c._print_struct

def _print_struct(self, expr):
    return "%(keyword)s %(name)s {\n%(lines)s}" % {
        "keyword": expr.__class__.__name__, "name": expr.name, "lines": ';\n'.join(
            [self._print(decl) for decl in expr.declarations] + [''])
    }

sympy.sympy.printing.c._print_NaN

def _print_NaN(self, expr):
    return 'NAN'

sympy.sympy.printing.codeprinter._method_wrapper

def _method_wrapper(self_, *args, **kwargs):
    for k, v in self._req.items():
        getattr(self_, k).update(v)
    return method(self_, *args, **kwargs)

sympy.sympy.printing.codeprinter._print_Dummy

def _print_Dummy(self, expr):
    if expr.name.startswith('Dummy_'):
        return '_' + expr.name
    else:
        return '%s_%d' % (expr.name, expr.dummy_index)

sympy.sympy.printing.codeprinter._print_Idx

def _print_Idx(self, expr):
    return self._print(expr.label)

sympy.sympy.printing.codeprinter._print_CodeBlock

def _print_CodeBlock(self, expr):
    return '\n'.join([self._print(i) for i in expr.args])

sympy.sympy.printing.codeprinter._print_String

def _print_String(self, string):
    return str(string)

sympy.sympy.printing.codeprinter._print_QuotedString

def _print_QuotedString(self, arg):
    return '"%s"' % arg.text

sympy.sympy.printing.codeprinter._print_Comment

def _print_Comment(self, string):
    return self._get_comment(str(string))

sympy.sympy.printing.codeprinter._print_Assignment

def _print_Assignment(self, expr):
    from sympy.codegen.ast import Assignment
    from sympy.functions.elementary.piecewise import Piecewise
    from sympy.matrices.expressions.matexpr import MatrixSymbol
    from sympy.tensor.indexed import IndexedBase
    lhs = expr.lhs
    rhs = expr.rhs
    # We special case assignments that take multiple lines
    if isinstance(expr.rhs, Piecewise):
        # Here we modify Piecewise so each expression is now
        # an Assignment, and then continue on the print.
        expressions = []
        conditions = []
        for (e, c) in rhs.args:
            expressions.append(Assignment(lhs, e))
            conditions.append(c)
        temp = Piecewise(*zip(expressions, conditions))
        return self._print(temp)
    elif isinstance(lhs, MatrixSymbol):
        # Here we form an Assignment for each element in the array,
        # printing each one.
        lines = []
        for (i, j) in self._traverse_matrix_indices(lhs):
            temp = Assignment(lhs[i, j], rhs[i, j])
            code0 = self._print(temp)
            lines.append(code0)
        return "\n".join(lines)
    elif self._settings.get("contract", False) and (lhs.has(IndexedBase) or
            rhs.has(IndexedBase)):
        # Here we check if there is looping to be done, and if so
        # print the required loops.
        return self._doprint_loops(rhs, lhs)
    else:
        lhs_code = self._print(lhs)
        rhs_code = self._print(rhs)
        return self._get_statement("%s = %s" % (lhs_code, rhs_code))

sympy.sympy.printing.codeprinter._print_AugmentedAssignment

def _print_AugmentedAssignment(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    return self._get_statement("{} {} {}".format(
        *(self._print(arg) for arg in [lhs_code, expr.op, rhs_code])))

sympy.sympy.printing.codeprinter._print_FunctionCall

def _print_FunctionCall(self, expr):
    return '%s(%s)' % (
        expr.name,
        ', '.join((self._print(arg) for arg in expr.function_args)))

sympy.sympy.printing.codeprinter._print_Variable

def _print_Variable(self, expr):
    return self._print(expr.symbol)

sympy.sympy.printing.codeprinter._print_Symbol

def _print_Symbol(self, expr):
    name = super()._print_Symbol(expr)

    if name in self.reserved_words:
        if self._settings['error_on_reserved']:
            msg = ('This expression includes the symbol "{}" which is a '
                   'reserved keyword in this language.')
            raise ValueError(msg.format(name))
        return name + self._settings['reserved_word_suffix']
    else:
        return name

sympy.sympy.printing.codeprinter._print_Function

def _print_Function(self, expr):
    if expr.func.__name__ in self.known_functions:
        cond_func = self.known_functions[expr.func.__name__]
        if isinstance(cond_func, str):
            return "%s(%s)" % (cond_func, self.stringify(expr.args, ", "))
        else:
            for cond, func in cond_func:
                if cond(*expr.args):
                    break
            if func is not None:
                try:
                    return func(*[self.parenthesize(item, 0) for item in expr.args])
                except TypeError:
                    return "%s(%s)" % (func, self.stringify(expr.args, ", "))
    elif hasattr(expr, '_imp_') and isinstance(expr._imp_, Lambda):
        # inlined function
        return self._print(expr._imp_(*expr.args))
    elif expr.func.__name__ in self._rewriteable_functions:
        # Simple rewrite to supported function possible
        target_f, required_fs = self._rewriteable_functions[expr.func.__name__]
        if self._can_print(target_f) and all(self._can_print(f) for f in required_fs):
            return '(' + self._print(expr.rewrite(target_f)) + ')'

    if expr.is_Function and self._settings.get('allow_unknown_functions', False):
        return '%s(%s)' % (self._print(expr.func), ', '.join(map(self._print, expr.args)))
    else:
        return self._print_not_supported(expr)

sympy.sympy.printing.codeprinter._print_Derivative

def _print_Derivative(self, expr):
    obj, *wrt_order_pairs = expr.args
    for func_arg in obj.args:
        if not func_arg.is_Symbol:
            raise ValueError("%s._print_Derivative(...) only supports functions with symbols as arguments." %
                             self.__class__.__name__)
    meth_name = '_print_Derivative_%s' % obj.func.__name__
    pmeth = getattr(self, meth_name, None)
    if pmeth is None:
        if self._settings.get('strict', False):
            raise PrintMethodNotImplementedError(
                f"Unsupported by {type(self)}: {type(expr)}" +
                f"\nPrinter has no method: {meth_name}" +
                "\nSet the printer option 'strict' to False in order to generate partially printed code."
            )
        return self._print_not_supported(expr)
    orders = dict(wrt_order_pairs)
    seq_orders = [orders[arg] for arg in obj.args]
    return pmeth(obj.args, seq_orders)

sympy.sympy.printing.codeprinter._print_Catalan

def _print_Catalan(self, expr):
    return self._print_NumberSymbol(expr)

sympy.sympy.printing.codeprinter._print_EulerGamma

def _print_EulerGamma(self, expr):
    return self._print_NumberSymbol(expr)

sympy.sympy.printing.codeprinter._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    return self._print_NumberSymbol(expr)

sympy.sympy.printing.codeprinter._print_Exp1

def _print_Exp1(self, expr):
    return self._print_NumberSymbol(expr)

sympy.sympy.printing.codeprinter._print_Pi

def _print_Pi(self, expr):
    return self._print_NumberSymbol(expr)

sympy.sympy.printing.codeprinter._print_And

def _print_And(self, expr):
    PREC = precedence(expr)
    return (" %s " % self._operators['and']).join(self.parenthesize(a, PREC)
            for a in sorted(expr.args, key=default_sort_key))

sympy.sympy.printing.codeprinter._print_Or

def _print_Or(self, expr):
    PREC = precedence(expr)
    return (" %s " % self._operators['or']).join(self.parenthesize(a, PREC)
            for a in sorted(expr.args, key=default_sort_key))

sympy.sympy.printing.codeprinter._print_Xor

def _print_Xor(self, expr):
    if self._operators.get('xor') is None:
        return self._print(expr.to_nnf())
    PREC = precedence(expr)
    return (" %s " % self._operators['xor']).join(self.parenthesize(a, PREC)
            for a in expr.args)

sympy.sympy.printing.codeprinter._print_Equivalent

def _print_Equivalent(self, expr):
    if self._operators.get('equivalent') is None:
        return self._print(expr.to_nnf())
    PREC = precedence(expr)
    return (" %s " % self._operators['equivalent']).join(self.parenthesize(a, PREC)
            for a in expr.args)

sympy.sympy.printing.codeprinter._print_Not

def _print_Not(self, expr):
    PREC = precedence(expr)
    return self._operators['not'] + self.parenthesize(expr.args[0], PREC)

sympy.sympy.printing.codeprinter._print_BooleanFunction

def _print_BooleanFunction(self, expr):
    return self._print(expr.to_nnf())

sympy.sympy.printing.codeprinter._print_isnan

def _print_isnan(self, arg):
    return 'isnan(%s)' % self._print(*arg.args)

sympy.sympy.printing.codeprinter._print_isinf

def _print_isinf(self, arg):
    return 'isinf(%s)' % self._print(*arg.args)

sympy.sympy.printing.codeprinter._print_Mul

def _print_Mul(self, expr):

    prec = precedence(expr)

    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = "-"
    else:
        sign = ""

    a = []  # items in the numerator
    b = []  # items that are in the denominator (if any)

    pow_paren = []  # Will collect all pow with more than one base element and exp = -1

    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        # use make_args in case expr was something like -x -> x
        args = Mul.make_args(expr)

    # Gather args for numerator/denominator
    for item in args:
        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160
                    pow_paren.append(item)
                b.append(Pow(item.base, -item.exp))
        else:
            a.append(item)

    a = a or [S.One]

    if len(a) == 1 and sign == "-":
        # Unary minus does not have a SymPy class, and hence there's no
        # precedence weight associated with it, Python's unary minus has
        # an operator precedence between multiplication and exponentiation,
        # so we use this to compute a weight.
        a_str = [self.parenthesize(a[0], 0.5*(PRECEDENCE["Pow"]+PRECEDENCE["Mul"]))]
    else:
        a_str = [self.parenthesize(x, prec) for x in a]
    b_str = [self.parenthesize(x, prec) for x in b]

    # To parenthesize Pow with exp = -1 and having more than one Symbol
    for item in pow_paren:
        if item.base in b:
            b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]

    if not b:
        return sign + '*'.join(a_str)
    elif len(b) == 1:
        return sign + '*'.join(a_str) + "/" + b_str[0]
    else:
        return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)

sympy.sympy.printing.codeprinter._print_not_supported

def _print_not_supported(self, expr):
    if self._settings.get('strict', False):
        raise PrintMethodNotImplementedError(
            f"Unsupported by {type(self)}: {type(expr)}" +
            "\nSet the printer option 'strict' to False in order to generate partially printed code."
        )
    try:
        self._not_supported.add(expr)
    except TypeError:
        # not hashable
        pass
    return self.emptyPrinter(expr)

sympy.sympy.printing.cxx._print_using

def _print_using(self, expr):
    if expr.alias == none:
        return super()._print_using(expr)
    else:
        return 'using %(alias)s = %(type)s' % expr.kwargs(apply=self._print)

sympy.sympy.printing.cxx._print_beta

def _print_beta(self, expr):
    return self._print_math_func(expr)

sympy.sympy.printing.cxx._print_Ei

def _print_Ei(self, expr):
    return self._print_math_func(expr)

sympy.sympy.printing.cxx._print_zeta

def _print_zeta(self, expr):
    return self._print_math_func(expr)

sympy.sympy.printing.fortran._print_Symbol

def _print_Symbol(self, expr):
    if self._settings['name_mangling'] == True:
        if expr not in self.mangled_symbols:
            name = expr.name
            while name.lower() in self.used_name:
                name += '_'
            self.used_name.append(name.lower())
            if name == expr.name:
                self.mangled_symbols[expr] = expr
            else:
                self.mangled_symbols[expr] = Symbol(name)

        expr = expr.xreplace(self.mangled_symbols)

    name = super()._print_Symbol(expr)
    return name

sympy.sympy.printing.fortran._print_sign

def _print_sign(self, expr):
    from sympy.functions.elementary.complexes import Abs
    arg, = expr.args
    if arg.is_integer:
        new_expr = merge(0, isign(1, arg), Eq(arg, 0))
    elif (arg.is_complex or arg.is_infinite):
        new_expr = merge(cmplx(literal_dp(0), literal_dp(0)), arg/Abs(arg), Eq(Abs(arg), literal_dp(0)))
    else:
        new_expr = merge(literal_dp(0), dsign(literal_dp(1), arg), Eq(arg, literal_dp(0)))
    return self._print(new_expr)

sympy.sympy.printing.fortran._print_Piecewise

def _print_Piecewise(self, expr):
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []
    if expr.has(Assignment):
        for i, (e, c) in enumerate(expr.args):
            if i == 0:
                lines.append("if (%s) then" % self._print(c))
            elif i == len(expr.args) - 1 and c == True:
                lines.append("else")
            else:
                lines.append("else if (%s) then" % self._print(c))
            lines.append(self._print(e))
        lines.append("end if")
        return "\n".join(lines)
    elif self._settings["standard"] >= 95:
        # Only supported in F95 and newer:
        # The piecewise was used in an expression, need to do inline
        # operators. This has the downside that inline operators will
        # not work for statements that span multiple lines (Matrix or
        # Indexed expressions).
        pattern = "merge({T}, {F}, {COND})"
        code = self._print(expr.args[-1].expr)
        terms = list(expr.args[:-1])
        while terms:
            e, c = terms.pop()
            expr = self._print(e)
            cond = self._print(c)
            code = pattern.format(T=expr, F=code, COND=cond)
        return code
    else:
        # `merge` is not supported prior to F95
        raise NotImplementedError("Using Piecewise as an expression using "
                                  "inline operators is not supported in "
                                  "standards earlier than Fortran95.")

sympy.sympy.printing.fortran._print_MatrixElement

def _print_MatrixElement(self, expr):
    return "{}({}, {})".format(self.parenthesize(expr.parent,
            PRECEDENCE["Atom"], strict=True), expr.i + 1, expr.j + 1)

sympy.sympy.printing.fortran._print_Add

def _print_Add(self, expr):
    # purpose: print complex numbers nicely in Fortran.
    # collect the purely real and purely imaginary parts:
    pure_real = []
    pure_imaginary = []
    mixed = []
    for arg in expr.args:
        if arg.is_number and arg.is_real:
            pure_real.append(arg)
        elif arg.is_number and arg.is_imaginary:
            pure_imaginary.append(arg)
        else:
            mixed.append(arg)
    if pure_imaginary:
        if mixed:
            PREC = precedence(expr)
            term = Add(*mixed)
            t = self._print(term)
            if t.startswith('-'):
                sign = "-"
                t = t[1:]
            else:
                sign = "+"
            if precedence(term) < PREC:
                t = "(%s)" % t

            return "cmplx(%s,%s) %s %s" % (
                self._print(Add(*pure_real)),
                self._print(-S.ImaginaryUnit*Add(*pure_imaginary)),
                sign, t,
            )
        else:
            return "cmplx(%s,%s)" % (
                self._print(Add(*pure_real)),
                self._print(-S.ImaginaryUnit*Add(*pure_imaginary)),
            )
    else:
        return CodePrinter._print_Add(self, expr)

sympy.sympy.printing.fortran._print_Function

def _print_Function(self, expr):
    # All constant function args are evaluated as floats
    prec =  self._settings['precision']
    args = [N(a, prec) for a in expr.args]
    eval_expr = expr.func(*args)
    if not isinstance(eval_expr, Function):
        return self._print(eval_expr)
    else:
        return CodePrinter._print_Function(self, expr.func(*args))

sympy.sympy.printing.fortran._print_Mod

def _print_Mod(self, expr):
    # NOTE : Fortran has the functions mod() and modulo(). modulo() behaves
    # the same wrt to the sign of the arguments as Python and SymPy's
    # modulus computations (% and Mod()) but is not available in Fortran 66
    # or Fortran 77, thus we raise an error.
    if self._settings['standard'] in [66, 77]:
        msg = ("Python % operator and SymPy's Mod() function are not "
               "supported by Fortran 66 or 77 standards.")
        raise NotImplementedError(msg)
    else:
        x, y = expr.args
        return "      modulo({}, {})".format(self._print(x), self._print(y))

sympy.sympy.printing.fortran._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    # purpose: print complex numbers nicely in Fortran.
    return "cmplx(0,1)"

sympy.sympy.printing.fortran._print_int

def _print_int(self, expr):
    return str(expr)

sympy.sympy.printing.fortran._print_Mul

def _print_Mul(self, expr):
    # purpose: print complex numbers nicely in Fortran.
    if expr.is_number and expr.is_imaginary:
        return "cmplx(0,%s)" % (
            self._print(-S.ImaginaryUnit*expr)
        )
    else:
        return CodePrinter._print_Mul(self, expr)

sympy.sympy.printing.fortran._print_Pow

def _print_Pow(self, expr):
    PREC = precedence(expr)
    if equal_valued(expr.exp, -1):
        return '%s/%s' % (
            self._print(literal_dp(1)),
            self.parenthesize(expr.base, PREC)
        )
    elif equal_valued(expr.exp, 0.5):
        if expr.base.is_integer:
            # Fortran intrinsic sqrt() does not accept integer argument
            if expr.base.is_Number:
                return 'sqrt(%s.0d0)' % self._print(expr.base)
            else:
                return 'sqrt(dble(%s))' % self._print(expr.base)
        else:
            return 'sqrt(%s)' % self._print(expr.base)
    else:
        return CodePrinter._print_Pow(self, expr)

sympy.sympy.printing.fortran._print_Rational

def _print_Rational(self, expr):
    p, q = int(expr.p), int(expr.q)
    return "%d.0d0/%d.0d0" % (p, q)

sympy.sympy.printing.fortran._print_Float

def _print_Float(self, expr):
    printed = CodePrinter._print_Float(self, expr)
    e = printed.find('e')
    if e > -1:
        return "%sd%s" % (printed[:e], printed[e + 1:])
    return "%sd0" % printed

sympy.sympy.printing.fortran._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    op = op if op not in self._relationals else self._relationals[op]
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.fortran._print_Indexed

def _print_Indexed(self, expr):
    inds = [ self._print(i) for i in expr.indices ]
    return "%s(%s)" % (self._print(expr.base.label), ", ".join(inds))

sympy.sympy.printing.fortran._print_AugmentedAssignment

def _print_AugmentedAssignment(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    return self._get_statement("{0} = {0} {1} {2}".format(
        self._print(lhs_code), self._print(expr.binop), self._print(rhs_code)))

sympy.sympy.printing.fortran._print_sum_

def _print_sum_(self, sm):
    params = self._print(sm.array)
    if sm.dim != None: # Must use '!= None', cannot use 'is not None'
        params += ', ' + self._print(sm.dim)
    if sm.mask != None: # Must use '!= None', cannot use 'is not None'
        params += ', mask=' + self._print(sm.mask)
    return '%s(%s)' % (sm.__class__.__name__.rstrip('_'), params)

sympy.sympy.printing.fortran._print_Do

def _print_Do(self, do):
    excl = ['concurrent']
    if do.step == 1:
        excl.append('step')
        step = ''
    else:
        step = ', {step}'

    return (
        'do {concurrent}{counter} = {first}, {last}'+step+'\n'
        '{body}\n'
        'end do\n'
    ).format(
        concurrent='concurrent ' if do.concurrent else '',
        **do.kwargs(apply=lambda arg: self._print(arg), exclude=excl)
    )

sympy.sympy.printing.fortran._print_ImpliedDoLoop

def _print_ImpliedDoLoop(self, idl):
    step = '' if idl.step == 1 else ', {step}'
    return ('({expr}, {counter} = {first}, {last}'+step+')').format(
        **idl.kwargs(apply=lambda arg: self._print(arg))
    )

sympy.sympy.printing.fortran._print_For

def _print_For(self, expr):
    target = self._print(expr.target)
    if isinstance(expr.iterable, Range):
        start, stop, step = expr.iterable.args
    else:
        raise NotImplementedError("Only iterable currently supported is Range")
    body = self._print(expr.body)
    return ('do {target} = {start}, {stop}, {step}\n'
            '{body}\n'
            'end do').format(target=target, start=start, stop=stop - 1,
                    step=step, body=body)

sympy.sympy.printing.fortran._print_Type

def _print_Type(self, type_):
    type_ = self.type_aliases.get(type_, type_)
    type_str = self.type_mappings.get(type_, type_.name)
    module_uses = self.type_modules.get(type_)
    if module_uses:
        for k, v in module_uses:
            self.module_uses[k].add(v)
    return type_str

sympy.sympy.printing.fortran._print_Element

def _print_Element(self, elem):
    return '{symbol}({idxs})'.format(
        symbol=self._print(elem.symbol),
        idxs=', '.join((self._print(arg) for arg in elem.indices))
    )

sympy.sympy.printing.fortran._print_Extent

def _print_Extent(self, ext):
    return str(ext)

sympy.sympy.printing.fortran._print_Declaration

def _print_Declaration(self, expr):
    var = expr.variable
    val = var.value
    dim = var.attr_params('dimension')
    intents = [intent in var.attrs for intent in (intent_in, intent_out, intent_inout)]
    if intents.count(True) == 0:
        intent = ''
    elif intents.count(True) == 1:
        intent = ', intent(%s)' % ['in', 'out', 'inout'][intents.index(True)]
    else:
        raise ValueError("Multiple intents specified for %s" % self)

    if isinstance(var, Pointer):
        raise NotImplementedError("Pointers are not available by default in Fortran.")
    if self._settings["standard"] >= 90:
        result = '{t}{vc}{dim}{intent}{alloc} :: {s}'.format(
            t=self._print(var.type),
            vc=', parameter' if value_const in var.attrs else '',
            dim=', dimension(%s)' % ', '.join((self._print(arg) for arg in dim)) if dim else '',
            intent=intent,
            alloc=', allocatable' if allocatable in var.attrs else '',
            s=self._print(var.symbol)
        )
        if val != None: # Must be "!= None", cannot be "is not None"
            result += ' = %s' % self._print(val)
    else:
        if value_const in var.attrs or val:
            raise NotImplementedError("F77 init./parameter statem. req. multiple lines.")
        result = ' '.join((self._print(arg) for arg in [var.type, var.symbol]))

    return result

sympy.sympy.printing.fortran._print_While

def _print_While(self, expr):
    return 'do while ({condition})\n{body}\nend do'.format(**expr.kwargs(
        apply=lambda arg: self._print(arg)))

sympy.sympy.printing.fortran._print_Program

def _print_Program(self, prog):
    return (
        "program {name}\n"
        "{body}\n"
        "end program\n"
    ).format(**prog.kwargs(apply=lambda arg: self._print(arg)))

sympy.sympy.printing.fortran._print_Module

def _print_Module(self, mod):
    return (
        "module {name}\n"
        "{declarations}\n"
        "\ncontains\n\n"
        "{definitions}\n"
        "end module\n"
    ).format(**mod.kwargs(apply=lambda arg: self._print(arg)))

sympy.sympy.printing.fortran._print_Print

def _print_Print(self, ps):
    if ps.format_string == none: # Must be '!= None', cannot be 'is not None'
        template = "print {fmt}, {iolist}"
        fmt = '*'
    else:
        template = 'write(%(out)s, fmt="{fmt}", advance="no"), {iolist}' % {
            'out': {stderr: '0', stdout: '6'}.get(ps.file, '*')
        }
        fmt = self._print(ps.format_string)
    return template.format(fmt=fmt, iolist=', '.join(
        (self._print(arg) for arg in ps.print_args)))

sympy.sympy.printing.fortran._print_Return

def _print_Return(self, rs):
    arg, = rs.args
    return "{result_name} = {arg}".format(
        result_name=self._context.get('result_name', 'sympy_result'),
        arg=self._print(arg)
    )

sympy.sympy.printing.fortran._print_FunctionPrototype

def _print_FunctionPrototype(self, fp):
    entity = "{} function ".format(self._print(fp.return_type))
    return (
        "interface\n"
        "{function_head}\n"
        "end function\n"
        "end interface"
    ).format(function_head=self._head(entity, fp))

sympy.sympy.printing.fortran._print_FunctionDefinition

def _print_FunctionDefinition(self, fd):
    if elemental in fd.attrs:
        prefix = 'elemental '
    elif pure in fd.attrs:
        prefix = 'pure '
    else:
        prefix = ''

    entity = "{} function ".format(self._print(fd.return_type))
    with printer_context(self, result_name=fd.name):
        return (
            "{prefix}{function_head}\n"
            "{body}\n"
            "end function\n"
        ).format(
            prefix=prefix,
            function_head=self._head(entity, fd),
            body=self._print(fd.body)
        )

sympy.sympy.printing.fortran._print_Subroutine

def _print_Subroutine(self, sub):
    return (
        '{subroutine_head}\n'
        '{body}\n'
        'end subroutine\n'
    ).format(
        subroutine_head=self._head('subroutine ', sub),
        body=self._print(sub.body)
    )

sympy.sympy.printing.fortran._print_SubroutineCall

def _print_SubroutineCall(self, scall):
    return 'call {name}({args})'.format(
        name=self._print(scall.name),
        args=', '.join((self._print(arg) for arg in scall.subroutine_args))
    )

sympy.sympy.printing.fortran._print_use

def _print_use(self, use):
    result = 'use %s' % self._print(use.namespace)
    if use.rename != None: # Must be '!= None', cannot be 'is not None'
        result += ', ' + ', '.join([self._print(rnm) for rnm in use.rename])
    if use.only != None: # Must be '!= None', cannot be 'is not None'
        result += ', only: ' + ', '.join([self._print(nly) for nly in use.only])
    return result

sympy.sympy.printing.fortran._print_ArrayConstructor

def _print_ArrayConstructor(self, ac):
    fmtstr = "[%s]" if self._settings["standard"] >= 2003 else '(/%s/)'
    return fmtstr % ', '.join((self._print(arg) for arg in ac.elements))

sympy.sympy.printing.fortran._print_KeywordFunctionCall

def _print_KeywordFunctionCall(self, expr):
    args = [self._print(arg) for arg in expr.function_args]

    for key, value in expr.keyword_args.items():
        args.append(f"{key}={self._print(value)}")

    return '{name}({args})'.format(
        name=self._print(expr.name),
        args=', '.join(args)
    )

sympy.sympy.printing.fortran._print_ArrayElement

def _print_ArrayElement(self, elem):
    return '{symbol}({idxs})'.format(
        symbol=self._print(elem.name),
        idxs=', '.join((self._print(arg) for arg in elem.indices))
    )

sympy.sympy.printing.glsl._print_MatrixBase

def _print_MatrixBase(self, mat):
    mat_separator = self._settings['mat_separator']
    mat_transpose = self._settings['mat_transpose']
    column_vector = (mat.rows == 1) if mat_transpose else (mat.cols == 1)
    A = mat.transpose() if mat_transpose != column_vector else mat

    glsl_types = self._settings['glsl_types']
    array_type = self._settings['array_type']
    array_size = A.cols*A.rows
    array_constructor = "{}[{}]".format(array_type, array_size)

    if A.cols == 1:
        return self._print(A[0])
    if A.rows <= 4 and A.cols <= 4 and glsl_types:
        if A.rows == 1:
            return "vec{}{}".format(
                A.cols, A.table(self,rowstart='(',rowend=')')
            )
        elif A.rows == A.cols:
            return "mat{}({})".format(
                A.rows, A.table(self,rowsep=', ',
                rowstart='',rowend='')
            )
        else:
            return "mat{}x{}({})".format(
                A.cols, A.rows,
                A.table(self,rowsep=', ',
                rowstart='',rowend='')
            )
    elif S.One in A.shape:
        return "{}({})".format(
            array_constructor,
            A.table(self,rowsep=mat_separator,rowstart='',rowend='')
        )
    elif not self._settings['mat_nested']:
        return "{}(\n{}\n) /* a {}x{} matrix */".format(
            array_constructor,
            A.table(self,rowsep=mat_separator,rowstart='',rowend=''),
            A.rows, A.cols
        )
    elif self._settings['mat_nested']:
        return "{}[{}][{}](\n{}\n)".format(
            array_type, A.rows, A.cols,
            A.table(self,rowsep=mat_separator,rowstart='float[](',rowend=')')
        )

sympy.sympy.printing.glsl._print_MatrixElement

def _print_MatrixElement(self, expr):
    # print('begin _print_MatrixElement')
    nest = self._settings['mat_nested']
    glsl_types = self._settings['glsl_types']
    mat_transpose = self._settings['mat_transpose']
    if mat_transpose:
        cols,rows = expr.parent.shape
        i,j = expr.j,expr.i
    else:
        rows,cols = expr.parent.shape
        i,j = expr.i,expr.j
    pnt = self._print(expr.parent)
    if glsl_types and ((rows <= 4 and cols <=4) or nest):
        return "{}[{}][{}]".format(pnt, i, j)
    else:
        return "{}[{}]".format(pnt, i + j*rows)

sympy.sympy.printing.glsl._print_list

def _print_list(self, expr):
    l = ', '.join(self._print(item) for item in expr)
    glsl_types = self._settings['glsl_types']
    array_type = self._settings['array_type']
    array_size = len(expr)
    array_constructor = '{}[{}]'.format(array_type, array_size)

    if array_size <= 4 and glsl_types:
        return 'vec{}({})'.format(array_size, l)
    else:
        return '{}({})'.format(array_constructor, l)

sympy.sympy.printing.glsl._print_Piecewise

def _print_Piecewise(self, expr):
    from sympy.codegen.ast import Assignment
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []
    if expr.has(Assignment):
        for i, (e, c) in enumerate(expr.args):
            if i == 0:
                lines.append("if (%s) {" % self._print(c))
            elif i == len(expr.args) - 1 and c == True:
                lines.append("else {")
            else:
                lines.append("else if (%s) {" % self._print(c))
            code0 = self._print(e)
            lines.append(code0)
            lines.append("}")
        return "\n".join(lines)
    else:
        # The piecewise was used in an expression, need to do inline
        # operators. This has the downside that inline operators will
        # not work for statements that span multiple lines (Matrix or
        # Indexed expressions).
        ecpairs = ["((%s) ? (\n%s\n)\n" % (self._print(c),
                                           self._print(e))
                for e, c in expr.args[:-1]]
        last_line = ": (\n%s\n)" % self._print(expr.args[-1].expr)
        return ": ".join(ecpairs) + last_line + " ".join([")"*len(ecpairs)])

sympy.sympy.printing.glsl._print_Indexed

def _print_Indexed(self, expr):
    # calculate index for 1d array
    dims = expr.shape
    elem = S.Zero
    offset = S.One
    for i in reversed(range(expr.rank)):
        elem += expr.indices[i]*offset
        offset *= dims[i]
    return "{}[{}]".format(
        self._print(expr.base.label),
        self._print(elem)
    )

sympy.sympy.printing.glsl._print_Pow

def _print_Pow(self, expr):
    PREC = precedence(expr)
    if equal_valued(expr.exp, -1):
        return '1.0/%s' % (self.parenthesize(expr.base, PREC))
    elif equal_valued(expr.exp, 0.5):
        return 'sqrt(%s)' % self._print(expr.base)
    else:
        try:
            e = self._print(float(expr.exp))
        except TypeError:
            e = self._print(expr.exp)
        return self._print_Function_with_args('pow', (
            self._print(expr.base),
            e
        ))

sympy.sympy.printing.glsl._print_int

def _print_int(self, expr):
    return str(float(expr))

sympy.sympy.printing.glsl._print_Rational

def _print_Rational(self, expr):
    return "{}.0/{}.0".format(expr.p, expr.q)

sympy.sympy.printing.glsl._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.glsl._print_Add

def _print_Add(self, expr, order=None):
    if self._settings['use_operators']:
        return CodePrinter._print_Add(self, expr, order=order)

    terms = expr.as_ordered_terms()

    def partition(p,l):
        return reduce(lambda x, y: (x[0]+[y], x[1]) if p(y) else (x[0], x[1]+[y]), l,  ([], []))
    def add(a,b):
        return self._print_Function_with_args('add', (a, b))
        # return self.known_functions['add']+'(%s, %s)' % (a,b)
    neg, pos = partition(lambda arg: arg.could_extract_minus_sign(), terms)
    if pos:
        s = pos = reduce(lambda a,b: add(a,b), (self._print(t) for t in pos))
    else:
        s = pos = self._print(self._settings['zero'])

    if neg:
        # sum the absolute values of the negative terms
        neg = reduce(lambda a,b: add(a,b), (self._print(-n) for n in neg))
        # then subtract them from the positive terms
        s = self._print_Function_with_args('sub', (pos,neg))
        # s = self.known_functions['sub']+'(%s, %s)' % (pos,neg)
    return s

sympy.sympy.printing.glsl._print_Mul

def _print_Mul(self, expr, **kwargs):
    if self._settings['use_operators']:
        return CodePrinter._print_Mul(self, expr, **kwargs)
    terms = expr.as_ordered_factors()
    def mul(a,b):
        # return self.known_functions['mul']+'(%s, %s)' % (a,b)
        return self._print_Function_with_args('mul', (a,b))

    s = reduce(lambda a,b: mul(a,b), (self._print(t) for t in terms))
    return s

sympy.sympy.printing.jscode._print_Rational

def _print_Rational(self, expr):
    p, q = int(expr.p), int(expr.q)
    return '%d/%d' % (p, q)

sympy.sympy.printing.jscode._print_Mod

def _print_Mod(self, expr):
    num, den = expr.args
    PREC = precedence(expr)
    snum, sden = [self.parenthesize(arg, PREC) for arg in expr.args]
    # % is remainder (same sign as numerator), not modulo (same sign as
    # denominator), in js. Hence, % only works as modulo if both numbers
    # have the same sign
    if (num.is_nonnegative and den.is_nonnegative or
        num.is_nonpositive and den.is_nonpositive):
        return f"{snum} % {sden}"
    return f"(({snum} % {sden}) + {sden}) % {sden}"

sympy.sympy.printing.jscode._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.jscode._print_Indexed

def _print_Indexed(self, expr):
    # calculate index for 1d array
    dims = expr.shape
    elem = S.Zero
    offset = S.One
    for i in reversed(range(expr.rank)):
        elem += expr.indices[i]*offset
        offset *= dims[i]
    return "%s[%s]" % (self._print(expr.base.label), self._print(elem))

sympy.sympy.printing.jscode._print_Exp1

def _print_Exp1(self, expr):
    return "Math.E"

sympy.sympy.printing.jscode._print_Pi

def _print_Pi(self, expr):
    return 'Math.PI'

sympy.sympy.printing.jscode._print_Infinity

def _print_Infinity(self, expr):
    return 'Number.POSITIVE_INFINITY'

sympy.sympy.printing.jscode._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return 'Number.NEGATIVE_INFINITY'

sympy.sympy.printing.jscode._print_Piecewise

def _print_Piecewise(self, expr):
    from sympy.codegen.ast import Assignment
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []
    if expr.has(Assignment):
        for i, (e, c) in enumerate(expr.args):
            if i == 0:
                lines.append("if (%s) {" % self._print(c))
            elif i == len(expr.args) - 1 and c == True:
                lines.append("else {")
            else:
                lines.append("else if (%s) {" % self._print(c))
            code0 = self._print(e)
            lines.append(code0)
            lines.append("}")
        return "\n".join(lines)
    else:
        # The piecewise was used in an expression, need to do inline
        # operators. This has the downside that inline operators will
        # not work for statements that span multiple lines (Matrix or
        # Indexed expressions).
        ecpairs = ["((%s) ? (\n%s\n)\n" % (self._print(c), self._print(e))
                for e, c in expr.args[:-1]]
        last_line = ": (\n%s\n)" % self._print(expr.args[-1].expr)
        return ": ".join(ecpairs) + last_line + " ".join([")"*len(ecpairs)])

sympy.sympy.printing.jscode._print_MatrixElement

def _print_MatrixElement(self, expr):
    return "{}[{}]".format(self.parenthesize(expr.parent,
        PRECEDENCE["Atom"], strict=True),
        expr.j + expr.i*expr.parent.shape[1])

sympy.sympy.printing.jscode._print_Pow

def _print_Pow(self, expr):
    PREC = precedence(expr)
    if equal_valued(expr.exp, -1):
        return '1/%s' % (self.parenthesize(expr.base, PREC))
    elif equal_valued(expr.exp, 0.5):
        return 'Math.sqrt(%s)' % self._print(expr.base)
    elif expr.exp == S.One/3:
        return 'Math.cbrt(%s)' % self._print(expr.base)
    else:
        return 'Math.pow(%s, %s)' % (self._print(expr.base),
                             self._print(expr.exp))

sympy.sympy.printing.julia._print_Mul

def _print_Mul(self, expr):
    # print complex numbers nicely in Julia
    if (expr.is_number and expr.is_imaginary and
            expr.as_coeff_Mul()[0].is_integer):
        return "%sim" % self._print(-S.ImaginaryUnit*expr)

    # cribbed from str.py
    prec = precedence(expr)

    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = "-"
    else:
        sign = ""

    a = []  # items in the numerator
    b = []  # items that are in the denominator (if any)

    pow_paren = []  # Will collect all pow with more than one base element and exp = -1

    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        # use make_args in case expr was something like -x -> x
        args = Mul.make_args(expr)

    # Gather args for numerator/denominator
    for item in args:
        if (item.is_commutative and item.is_Pow and item.exp.is_Rational
                and item.exp.is_negative):
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160
                    pow_paren.append(item)
                b.append(Pow(item.base, -item.exp))
        elif item.is_Rational and item is not S.Infinity and item.p == 1:
            # Save the Rational type in julia Unless the numerator is 1.
            # For example:
            # julia_code(Rational(3, 7)*x) --> (3 // 7) * x
            # julia_code(x/3) --> x / 3 but not x * (1 // 3)
            b.append(Rational(item.q))
        else:
            a.append(item)

    a = a or [S.One]

    a_str = [self.parenthesize(x, prec) for x in a]
    b_str = [self.parenthesize(x, prec) for x in b]

    # To parenthesize Pow with exp = -1 and having more than one Symbol
    for item in pow_paren:
        if item.base in b:
            b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]

    # from here it differs from str.py to deal with "*" and ".*"
    def multjoin(a, a_str):
        # here we probably are assuming the constants will come first
        r = a_str[0]
        for i in range(1, len(a)):
            mulsym = '*' if a[i-1].is_number else '.*'
            r = "%s %s %s" % (r, mulsym, a_str[i])
        return r

    if not b:
        return sign + multjoin(a, a_str)
    elif len(b) == 1:
        divsym = '/' if b[0].is_number else './'
        return "%s %s %s" % (sign+multjoin(a, a_str), divsym, b_str[0])
    else:
        divsym = '/' if all(bi.is_number for bi in b) else './'
        return "%s %s (%s)" % (sign + multjoin(a, a_str), divsym, multjoin(b, b_str))

sympy.sympy.printing.julia._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.julia._print_Pow

def _print_Pow(self, expr):
    powsymbol = '^' if all(x.is_number for x in expr.args) else '.^'

    PREC = precedence(expr)

    if equal_valued(expr.exp, 0.5):
        return "sqrt(%s)" % self._print(expr.base)

    if expr.is_commutative:
        if equal_valued(expr.exp, -0.5):
            sym = '/' if expr.base.is_number else './'
            return "1 %s sqrt(%s)" % (sym, self._print(expr.base))
        if equal_valued(expr.exp, -1):
            sym = '/' if expr.base.is_number else './'
            return  "1 %s %s" % (sym, self.parenthesize(expr.base, PREC))

    return '%s %s %s' % (self.parenthesize(expr.base, PREC), powsymbol,
                       self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.julia._print_MatPow

def _print_MatPow(self, expr):
    PREC = precedence(expr)
    return '%s ^ %s' % (self.parenthesize(expr.base, PREC),
                      self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.julia._print_Pi

def _print_Pi(self, expr):
    if self._settings["inline"]:
        return "pi"
    else:
        return super()._print_NumberSymbol(expr)

sympy.sympy.printing.julia._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return "im"

sympy.sympy.printing.julia._print_Exp1

def _print_Exp1(self, expr):
    if self._settings["inline"]:
        return "e"
    else:
        return super()._print_NumberSymbol(expr)

sympy.sympy.printing.julia._print_EulerGamma

def _print_EulerGamma(self, expr):
    if self._settings["inline"]:
        return "eulergamma"
    else:
        return super()._print_NumberSymbol(expr)

sympy.sympy.printing.julia._print_Catalan

def _print_Catalan(self, expr):
    if self._settings["inline"]:
        return "catalan"
    else:
        return super()._print_NumberSymbol(expr)

sympy.sympy.printing.julia._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    if self._settings["inline"]:
        return "golden"
    else:
        return super()._print_NumberSymbol(expr)

sympy.sympy.printing.julia._print_Assignment

def _print_Assignment(self, expr):
    from sympy.codegen.ast import Assignment
    from sympy.functions.elementary.piecewise import Piecewise
    from sympy.tensor.indexed import IndexedBase
    # Copied from codeprinter, but remove special MatrixSymbol treatment
    lhs = expr.lhs
    rhs = expr.rhs
    # We special case assignments that take multiple lines
    if not self._settings["inline"] and isinstance(expr.rhs, Piecewise):
        # Here we modify Piecewise so each expression is now
        # an Assignment, and then continue on the print.
        expressions = []
        conditions = []
        for (e, c) in rhs.args:
            expressions.append(Assignment(lhs, e))
            conditions.append(c)
        temp = Piecewise(*zip(expressions, conditions))
        return self._print(temp)
    if self._settings["contract"] and (lhs.has(IndexedBase) or
            rhs.has(IndexedBase)):
        # Here we check if there is looping to be done, and if so
        # print the required loops.
        return self._doprint_loops(rhs, lhs)
    else:
        lhs_code = self._print(lhs)
        rhs_code = self._print(rhs)
        return self._get_statement("%s = %s" % (lhs_code, rhs_code))

sympy.sympy.printing.julia._print_Infinity

def _print_Infinity(self, expr):
    return 'Inf'

sympy.sympy.printing.julia._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-Inf'

sympy.sympy.printing.julia._print_NaN

def _print_NaN(self, expr):
    return 'NaN'

sympy.sympy.printing.julia._print_tuple

def _print_tuple(self, expr):
    if len(expr) == 1:
        return "(%s,)" % self._print(expr[0])
    else:
        return "(%s)" % self.stringify(expr, ", ")

sympy.sympy.printing.julia._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return "true"

sympy.sympy.printing.julia._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return "false"

sympy.sympy.printing.julia._print_MatrixBase

def _print_MatrixBase(self, A):
    # Handle zero dimensions:
    if S.Zero in A.shape:
        return 'zeros(%s, %s)' % (A.rows, A.cols)
    elif (A.rows, A.cols) == (1, 1):
        return "[%s]" % A[0, 0]
    elif A.rows == 1:
        return "[%s]" % A.table(self, rowstart='', rowend='', colsep=' ')
    elif A.cols == 1:
        # note .table would unnecessarily equispace the rows
        return "[%s]" % ", ".join([self._print(a) for a in A])
    return "[%s]" % A.table(self, rowstart='', rowend='',
                            rowsep=';\n', colsep=' ')

sympy.sympy.printing.julia._print_SparseRepMatrix

def _print_SparseRepMatrix(self, A):
    from sympy.matrices import Matrix
    L = A.col_list()
    # make row vectors of the indices and entries
    I = Matrix([k[0] + 1 for k in L])
    J = Matrix([k[1] + 1 for k in L])
    AIJ = Matrix([k[2] for k in L])
    return "sparse(%s, %s, %s, %s, %s)" % (self._print(I), self._print(J),
                                        self._print(AIJ), A.rows, A.cols)

sympy.sympy.printing.julia._print_MatrixElement

def _print_MatrixElement(self, expr):
    return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
        + '[%s,%s]' % (expr.i + 1, expr.j + 1)

sympy.sympy.printing.julia._print_MatrixSlice

def _print_MatrixSlice(self, expr):
    def strslice(x, lim):
        l = x[0] + 1
        h = x[1]
        step = x[2]
        lstr = self._print(l)
        hstr = 'end' if h == lim else self._print(h)
        if step == 1:
            if l == 1 and h == lim:
                return ':'
            if l == h:
                return lstr
            else:
                return lstr + ':' + hstr
        else:
            return ':'.join((lstr, self._print(step), hstr))
    return (self._print(expr.parent) + '[' +
            strslice(expr.rowslice, expr.parent.shape[0]) + ',' +
            strslice(expr.colslice, expr.parent.shape[1]) + ']')

sympy.sympy.printing.julia._print_Indexed

def _print_Indexed(self, expr):
    inds = [ self._print(i) for i in expr.indices ]
    return "%s[%s]" % (self._print(expr.base.label), ",".join(inds))

sympy.sympy.printing.julia._print_Identity

def _print_Identity(self, expr):
    return "eye(%s)" % self._print(expr.shape[0])

sympy.sympy.printing.julia._print_HadamardProduct

def _print_HadamardProduct(self, expr):
    return ' .* '.join([self.parenthesize(arg, precedence(expr))
                      for arg in expr.args])

sympy.sympy.printing.julia._print_Rational

def _print_Rational(self, expr):
    if expr.q == 1:
        return str(expr.p)
    return "%s // %s" % (expr.p, expr.q)

sympy.sympy.printing.julia._print_jn

def _print_jn(self, expr):
    from sympy.functions import sqrt, besselj
    x = expr.argument
    expr2 = sqrt(S.Pi/(2*x))*besselj(expr.order + S.Half, x)
    return self._print(expr2)

sympy.sympy.printing.julia._print_yn

def _print_yn(self, expr):
    from sympy.functions import sqrt, bessely
    x = expr.argument
    expr2 = sqrt(S.Pi/(2*x))*bessely(expr.order + S.Half, x)
    return self._print(expr2)

sympy.sympy.printing.julia._print_sinc

def _print_sinc(self, expr):
    # Julia has the normalized sinc function
    return "sinc({})".format(self._print(expr.args[0] / S.Pi))

sympy.sympy.printing.julia._print_Piecewise

def _print_Piecewise(self, expr):
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []
    if self._settings["inline"]:
        # Express each (cond, expr) pair in a nested Horner form:
        #   (condition) .* (expr) + (not cond) .* (<others>)
        # Expressions that result in multiple statements won't work here.
        ecpairs = ["({}) ? ({}) :".format
                   (self._print(c), self._print(e))
                   for e, c in expr.args[:-1]]
        elast = " (%s)" % self._print(expr.args[-1].expr)
        pw = "\n".join(ecpairs) + elast
        # Note: current need these outer brackets for 2*pw.  Would be
        # nicer to teach parenthesize() to do this for us when needed!
        return "(" + pw + ")"
    else:
        for i, (e, c) in enumerate(expr.args):
            if i == 0:
                lines.append("if (%s)" % self._print(c))
            elif i == len(expr.args) - 1 and c == True:
                lines.append("else")
            else:
                lines.append("elseif (%s)" % self._print(c))
            code0 = self._print(e)
            lines.append(code0)
            if i == len(expr.args) - 1:
                lines.append("end")
        return "\n".join(lines)

sympy.sympy.printing.julia._print_MatMul

def _print_MatMul(self, expr):
    c, m = expr.as_coeff_mmul()

    sign = ""
    if c.is_number:
        re, im = c.as_real_imag()
        if im.is_zero and re.is_negative:
            expr = _keep_coeff(-c, m)
            sign = "-"
        elif re.is_zero and im.is_negative:
            expr = _keep_coeff(-c, m)
            sign = "-"

    return sign + ' * '.join(
        (self.parenthesize(arg, precedence(expr)) for arg in expr.args)
    )

sympy.sympy.printing.lambdarepr._print_Piecewise

def _print_Piecewise(self, expr):
    "Piecewise function printer"
    exprs = [self._print(arg.expr) for arg in expr.args]
    conds = [self._print(arg.cond) for arg in expr.args]
    # If [default_value, True] is a (expr, cond) sequence in a Piecewise object
    #     it will behave the same as passing the 'default' kwarg to select()
    #     *as long as* it is the last element in expr.args.
    # If this is not the case, it may be triggered prematurely.
    ans = []
    parenthesis_count = 0
    is_last_cond_True = False
    for cond, expr in zip(conds, exprs):
        if cond == 'True':
            ans.append(expr)
            is_last_cond_True = True
            break
        else:
            ans.append('where(%s, %s, ' % (cond, expr))
            parenthesis_count += 1
    if not is_last_cond_True:
        # See https://github.com/pydata/numexpr/issues/298
        #
        # simplest way to put a nan but raises
        # 'RuntimeWarning: invalid value encountered in log'
        #
        # There are other ways to do this such as
        #
        #   >>> import numexpr as ne
        #   >>> nan = float('nan')
        #   >>> ne.evaluate('where(x < 0, -1, nan)', {'x': [-1, 2, 3], 'nan':nan})
        #   array([-1., nan, nan])
        #
        # That needs to be handled in the lambdified function though rather
        # than here in the printer.
        ans.append('log(-1)')
    return ''.join(ans) + ')' * parenthesis_count

sympy.sympy.printing.lambdarepr._print_ITE

def _print_ITE(self, expr):
    from sympy.functions.elementary.piecewise import Piecewise
    return self._print(expr.rewrite(Piecewise))

sympy.sympy.printing.lambdarepr._print_NumExprEvaluate

def _print_NumExprEvaluate(self, expr):
    evaluate = self._module_format(self.module +".evaluate")
    return "%s('%s', truediv=True)" % (evaluate, self._print(expr.expr))

sympy.sympy.printing.lambdarepr._print_Return

def _print_Return(self, expr):
    from sympy.codegen.pynodes import NumExprEvaluate
    r, = expr.args
    if not isinstance(r, NumExprEvaluate):
        expr = expr.func(NumExprEvaluate(r))
    return super()._print_Return(expr)

sympy.sympy.printing.lambdarepr._print_Assignment

def _print_Assignment(self, expr):
    from sympy.codegen.pynodes import NumExprEvaluate
    lhs, rhs, *args = expr.args
    if not isinstance(rhs, NumExprEvaluate):
        expr = expr.func(lhs, NumExprEvaluate(rhs), *args)
    return super()._print_Assignment(expr)

sympy.sympy.printing.lambdarepr._print_Integer

def _print_Integer(self, expr):
    return "mpi('%s')" % super(PythonCodePrinter, self)._print_Integer(expr)

sympy.sympy.printing.lambdarepr._print_Rational

def _print_Rational(self, expr):
    return "mpi('%s')" % super(PythonCodePrinter, self)._print_Rational(expr)

sympy.sympy.printing.lambdarepr._print_Half

def _print_Half(self, expr):
    return "mpi('%s')" % super(PythonCodePrinter, self)._print_Rational(expr)

sympy.sympy.printing.lambdarepr._print_Pow

def _print_Pow(self, expr, **kwargs):
    # XXX Temporary workaround. Should Python math printer be
    # isolated from PythonCodePrinter?
    return super(PythonCodePrinter, self)._print_Pow(expr, **kwargs)

sympy.sympy.printing.lambdarepr._print_And

def _print_And(self, expr):
    result = ['(']
    for arg in sorted(expr.args, key=default_sort_key):
        result.extend(['(', self._print(arg), ')'])
        result.append(' and ')
    result = result[:-1]
    result.append(')')
    return ''.join(result)

sympy.sympy.printing.lambdarepr._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return "True"

sympy.sympy.printing.lambdarepr._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return "False"

sympy.sympy.printing.latex._print_UndefinedFunction

def _print_UndefinedFunction(self, expr):
    return self._hprint_Function(str(expr))

sympy.sympy.printing.latex._print_ElementwiseApplyFunction

def _print_ElementwiseApplyFunction(self, expr):
    return r"{%s}_{\circ}\left({%s}\right)" % (
        self._print(expr.function),
        self._print(expr.expr),
    )

sympy.sympy.printing.latex._print_FunctionClass

def _print_FunctionClass(self, expr):
    for cls in self._special_function_classes:
        if issubclass(expr, cls) and expr.__name__ == cls.__name__:
            return self._special_function_classes[cls]
    return self._hprint_Function(str(expr))

sympy.sympy.printing.latex._print_Lambda

def _print_Lambda(self, expr):
    symbols, expr = expr.args

    if len(symbols) == 1:
        symbols = self._print(symbols[0])
    else:
        symbols = self._print(tuple(symbols))

    tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))

    return tex

sympy.sympy.printing.latex._print_IdentityFunction

def _print_IdentityFunction(self, expr):
    return r"\left( x \mapsto x \right)"

sympy.sympy.printing.latex._hprint_variadic_function

def _hprint_variadic_function(self, expr, exp=None) -> str:
    args = sorted(expr.args, key=default_sort_key)
    texargs = [r"%s" % self._print(symbol) for symbol in args]
    tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
                                   ", ".join(texargs))
    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_floor

def _print_floor(self, expr, exp=None):
    tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_ceiling

def _print_ceiling(self, expr, exp=None):
    tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_log

def _print_log(self, expr, exp=None):
    if len(expr.args) == 2:
        argument = self._print(expr.args[0])
        base = self._print(expr.args[1])
        if len(base) == 1:
            tex = r"\log_%s{\left(%s \right)}" % (base, argument)
        else:
            tex = r"\log_{%s}{\left(%s \right)}" % (base, argument)
    elif not self._settings["ln_notation"]:
        tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
    else:
        tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_Abs

def _print_Abs(self, expr, exp=None):
    tex = r"\left|{%s}\right|" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_re

def _print_re(self, expr, exp=None):
    if self._settings['gothic_re_im']:
        tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
    else:
        tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))

    return self._do_exponent(tex, exp)

sympy.sympy.printing.latex._print_im

def _print_im(self, expr, exp=None):
    if self._settings['gothic_re_im']:
        tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
    else:
        tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))

    return self._do_exponent(tex, exp)

sympy.sympy.printing.latex._print_Not

def _print_Not(self, e):
    from sympy.logic.boolalg import (Equivalent, Implies)
    if isinstance(e.args[0], Equivalent):
        return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
    if isinstance(e.args[0], Implies):
        return self._print_Implies(e.args[0], r"\not\Rightarrow")
    if (e.args[0].is_Boolean):
        return r"\neg \left(%s\right)" % self._print(e.args[0])
    else:
        return r"\neg %s" % self._print(e.args[0])

sympy.sympy.printing.latex._print_And

def _print_And(self, e):
    args = sorted(e.args, key=default_sort_key)
    return self._print_LogOp(args, r"\wedge")

sympy.sympy.printing.latex._print_Or

def _print_Or(self, e):
    args = sorted(e.args, key=default_sort_key)
    return self._print_LogOp(args, r"\vee")

sympy.sympy.printing.latex._print_Xor

def _print_Xor(self, e):
    args = sorted(e.args, key=default_sort_key)
    return self._print_LogOp(args, r"\veebar")

sympy.sympy.printing.latex._print_Implies

def _print_Implies(self, e, altchar=None):
    return self._print_LogOp(e.args, altchar or r"\Rightarrow")

sympy.sympy.printing.latex._print_Equivalent

def _print_Equivalent(self, e, altchar=None):
    args = sorted(e.args, key=default_sort_key)
    return self._print_LogOp(args, altchar or r"\Leftrightarrow")

sympy.sympy.printing.latex._print_conjugate

def _print_conjugate(self, expr, exp=None):
    tex = r"\overline{%s}" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_polar_lift

def _print_polar_lift(self, expr, exp=None):
    func = r"\operatorname{polar\_lift}"
    arg = r"{\left(%s \right)}" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}%s" % (func, exp, arg)
    else:
        return r"%s%s" % (func, arg)

sympy.sympy.printing.latex._print_ExpBase

def _print_ExpBase(self, expr, exp=None):
    # TODO should exp_polar be printed differently?
    #      what about exp_polar(0), exp_polar(1)?
    tex = r"e^{%s}" % self._print(expr.args[0])
    return self._do_exponent(tex, exp)

sympy.sympy.printing.latex._print_elliptic_k

def _print_elliptic_k(self, expr, exp=None):
    tex = r"\left(%s\right)" % self._print(expr.args[0])
    if exp is not None:
        return r"K^{%s}%s" % (exp, tex)
    else:
        return r"K%s" % tex

sympy.sympy.printing.latex._print_elliptic_f

def _print_elliptic_f(self, expr, exp=None):
    tex = r"\left(%s\middle| %s\right)" % \
        (self._print(expr.args[0]), self._print(expr.args[1]))
    if exp is not None:
        return r"F^{%s}%s" % (exp, tex)
    else:
        return r"F%s" % tex

sympy.sympy.printing.latex._print_elliptic_e

def _print_elliptic_e(self, expr, exp=None):
    if len(expr.args) == 2:
        tex = r"\left(%s\middle| %s\right)" % \
            (self._print(expr.args[0]), self._print(expr.args[1]))
    else:
        tex = r"\left(%s\right)" % self._print(expr.args[0])
    if exp is not None:
        return r"E^{%s}%s" % (exp, tex)
    else:
        return r"E%s" % tex

sympy.sympy.printing.latex._print_elliptic_pi

def _print_elliptic_pi(self, expr, exp=None):
    if len(expr.args) == 3:
        tex = r"\left(%s; %s\middle| %s\right)" % \
            (self._print(expr.args[0]), self._print(expr.args[1]),
             self._print(expr.args[2]))
    else:
        tex = r"\left(%s\middle| %s\right)" % \
            (self._print(expr.args[0]), self._print(expr.args[1]))
    if exp is not None:
        return r"\Pi^{%s}%s" % (exp, tex)
    else:
        return r"\Pi%s" % tex

sympy.sympy.printing.latex._print_beta

def _print_beta(self, expr, exp=None):
    x = expr.args[0]
    # Deal with unevaluated single argument beta
    y = expr.args[0] if len(expr.args) == 1 else expr.args[1]
    tex = rf"\left({x}, {y}\right)"

    if exp is not None:
        return r"\operatorname{B}^{%s}%s" % (exp, tex)
    else:
        return r"\operatorname{B}%s" % tex

sympy.sympy.printing.latex._print_uppergamma

def _print_uppergamma(self, expr, exp=None):
    tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
                                    self._print(expr.args[1]))

    if exp is not None:
        return r"\Gamma^{%s}%s" % (exp, tex)
    else:
        return r"\Gamma%s" % tex

sympy.sympy.printing.latex._print_lowergamma

def _print_lowergamma(self, expr, exp=None):
    tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
                                    self._print(expr.args[1]))

    if exp is not None:
        return r"\gamma^{%s}%s" % (exp, tex)
    else:
        return r"\gamma%s" % tex

sympy.sympy.printing.latex._hprint_one_arg_func

def _hprint_one_arg_func(self, expr, exp=None) -> str:
    tex = r"\left(%s\right)" % self._print(expr.args[0])

    if exp is not None:
        return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
    else:
        return r"%s%s" % (self._print(expr.func), tex)

sympy.sympy.printing.latex._print_Chi

def _print_Chi(self, expr, exp=None):
    tex = r"\left(%s\right)" % self._print(expr.args[0])

    if exp is not None:
        return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
    else:
        return r"\operatorname{Chi}%s" % tex

sympy.sympy.printing.latex._print_expint

def _print_expint(self, expr, exp=None):
    tex = r"\left(%s\right)" % self._print(expr.args[1])
    nu = self._print(expr.args[0])

    if exp is not None:
        return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
    else:
        return r"\operatorname{E}_{%s}%s" % (nu, tex)

sympy.sympy.printing.latex._print_fresnels

def _print_fresnels(self, expr, exp=None):
    tex = r"\left(%s\right)" % self._print(expr.args[0])

    if exp is not None:
        return r"S^{%s}%s" % (exp, tex)
    else:
        return r"S%s" % tex

sympy.sympy.printing.latex._print_fresnelc

def _print_fresnelc(self, expr, exp=None):
    tex = r"\left(%s\right)" % self._print(expr.args[0])

    if exp is not None:
        return r"C^{%s}%s" % (exp, tex)
    else:
        return r"C%s" % tex

sympy.sympy.printing.latex._print_subfactorial

def _print_subfactorial(self, expr, exp=None):
    tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])

    if exp is not None:
        return r"\left(%s\right)^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_factorial

def _print_factorial(self, expr, exp=None):
    tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_factorial2

def _print_factorial2(self, expr, exp=None):
    tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_binomial

def _print_binomial(self, expr, exp=None):
    tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
                                 self._print(expr.args[1]))

    if exp is not None:
        return r"%s^{%s}" % (tex, exp)
    else:
        return tex

sympy.sympy.printing.latex._print_RisingFactorial

def _print_RisingFactorial(self, expr, exp=None):
    n, k = expr.args
    base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])

    tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))

    return self._do_exponent(tex, exp)

sympy.sympy.printing.latex._print_FallingFactorial

def _print_FallingFactorial(self, expr, exp=None):
    n, k = expr.args
    sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])

    tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)

    return self._do_exponent(tex, exp)

sympy.sympy.printing.latex._print_besselj

def _print_besselj(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'J')

sympy.sympy.printing.latex._print_besseli

def _print_besseli(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'I')

sympy.sympy.printing.latex._print_besselk

def _print_besselk(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'K')

sympy.sympy.printing.latex._print_bessely

def _print_bessely(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'Y')

sympy.sympy.printing.latex._print_yn

def _print_yn(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'y')

sympy.sympy.printing.latex._print_jn

def _print_jn(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'j')

sympy.sympy.printing.latex._print_hankel1

def _print_hankel1(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'H^{(1)}')

sympy.sympy.printing.latex._print_hankel2

def _print_hankel2(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'H^{(2)}')

sympy.sympy.printing.latex._print_hn1

def _print_hn1(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'h^{(1)}')

sympy.sympy.printing.latex._print_hn2

def _print_hn2(self, expr, exp=None):
    return self._hprint_BesselBase(expr, exp, 'h^{(2)}')

sympy.sympy.printing.latex._print_hyper

def _print_hyper(self, expr, exp=None):
    tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
          r"\middle| {%s} \right)}" % \
        (self._print(len(expr.ap)), self._print(len(expr.bq)),
          self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
          self._print(expr.argument))

    if exp is not None:
        tex = r"{%s}^{%s}" % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_meijerg

def _print_meijerg(self, expr, exp=None):
    tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
          r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
        (self._print(len(expr.ap)), self._print(len(expr.bq)),
          self._print(len(expr.bm)), self._print(len(expr.an)),
          self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
          self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
          self._print(expr.argument))

    if exp is not None:
        tex = r"{%s}^{%s}" % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_dirichlet_eta

def _print_dirichlet_eta(self, expr, exp=None):
    tex = r"\left(%s\right)" % self._print(expr.args[0])
    if exp is not None:
        return r"\eta^{%s}%s" % (exp, tex)
    return r"\eta%s" % tex

sympy.sympy.printing.latex._print_zeta

def _print_zeta(self, expr, exp=None):
    if len(expr.args) == 2:
        tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
    else:
        tex = r"\left(%s\right)" % self._print(expr.args[0])
    if exp is not None:
        return r"\zeta^{%s}%s" % (exp, tex)
    return r"\zeta%s" % tex

sympy.sympy.printing.latex._print_stieltjes

def _print_stieltjes(self, expr, exp=None):
    if len(expr.args) == 2:
        tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
    else:
        tex = r"_{%s}" % self._print(expr.args[0])
    if exp is not None:
        return r"\gamma%s^{%s}" % (tex, exp)
    return r"\gamma%s" % tex

sympy.sympy.printing.latex._print_lerchphi

def _print_lerchphi(self, expr, exp=None):
    tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
    if exp is None:
        return r"\Phi%s" % tex
    return r"\Phi^{%s}%s" % (exp, tex)

sympy.sympy.printing.latex._print_polylog

def _print_polylog(self, expr, exp=None):
    s, z = map(self._print, expr.args)
    tex = r"\left(%s\right)" % z
    if exp is None:
        return r"\operatorname{Li}_{%s}%s" % (s, tex)
    return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)

sympy.sympy.printing.latex._print_jacobi

def _print_jacobi(self, expr, exp=None):
    n, a, b, x = map(self._print, expr.args)
    tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_gegenbauer

def _print_gegenbauer(self, expr, exp=None):
    n, a, x = map(self._print, expr.args)
    tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_chebyshevt

def _print_chebyshevt(self, expr, exp=None):
    n, x = map(self._print, expr.args)
    tex = r"T_{%s}\left(%s\right)" % (n, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_chebyshevu

def _print_chebyshevu(self, expr, exp=None):
    n, x = map(self._print, expr.args)
    tex = r"U_{%s}\left(%s\right)" % (n, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_legendre

def _print_legendre(self, expr, exp=None):
    n, x = map(self._print, expr.args)
    tex = r"P_{%s}\left(%s\right)" % (n, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_assoc_legendre

def _print_assoc_legendre(self, expr, exp=None):
    n, a, x = map(self._print, expr.args)
    tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_hermite

def _print_hermite(self, expr, exp=None):
    n, x = map(self._print, expr.args)
    tex = r"H_{%s}\left(%s\right)" % (n, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_laguerre

def _print_laguerre(self, expr, exp=None):
    n, x = map(self._print, expr.args)
    tex = r"L_{%s}\left(%s\right)" % (n, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_assoc_laguerre

def _print_assoc_laguerre(self, expr, exp=None):
    n, a, x = map(self._print, expr.args)
    tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_Ynm

def _print_Ynm(self, expr, exp=None):
    n, m, theta, phi = map(self._print, expr.args)
    tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_Znm

def _print_Znm(self, expr, exp=None):
    n, m, theta, phi = map(self._print, expr.args)
    tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
    if exp is not None:
        tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
    return tex

sympy.sympy.printing.latex._print_mathieuc

def _print_mathieuc(self, expr, exp=None):
    return self.__print_mathieu_functions("C", expr.args, exp=exp)

sympy.sympy.printing.latex._print_mathieus

def _print_mathieus(self, expr, exp=None):
    return self.__print_mathieu_functions("S", expr.args, exp=exp)

sympy.sympy.printing.latex._print_mathieucprime

def _print_mathieucprime(self, expr, exp=None):
    return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)

sympy.sympy.printing.latex._print_mathieusprime

def _print_mathieusprime(self, expr, exp=None):
    return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)

sympy.sympy.printing.latex._print_Rational

def _print_Rational(self, expr):
    if expr.q != 1:
        sign = ""
        p = expr.p
        if expr.p < 0:
            sign = "- "
            p = -p
        if self._settings['fold_short_frac']:
            return r"%s%d / %d" % (sign, p, expr.q)
        return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
    else:
        return self._print(expr.p)

sympy.sympy.printing.latex._print_Order

def _print_Order(self, expr):
    s = self._print(expr.expr)
    if expr.point and any(p != S.Zero for p in expr.point) or \
       len(expr.variables) > 1:
        s += '; '
        if len(expr.variables) > 1:
            s += self._print(expr.variables)
        elif expr.variables:
            s += self._print(expr.variables[0])
        s += r'\rightarrow '
        if len(expr.point) > 1:
            s += self._print(expr.point)
        else:
            s += self._print(expr.point[0])
    return r"O\left(%s\right)" % s

sympy.sympy.printing.latex._print_Symbol

def _print_Symbol(self, expr: Symbol, style='plain'):
    name: str = self._settings['symbol_names'].get(expr)
    if name is not None:
        return name

    return self._deal_with_super_sub(expr.name, style=style)

sympy.sympy.printing.latex._print_Relational

def _print_Relational(self, expr):
    if self._settings['itex']:
        gt = r"\gt"
        lt = r"\lt"
    else:
        gt = ">"
        lt = "<"

    charmap = {
        "==": "=",
        ">": gt,
        "<": lt,
        ">=": r"\geq",
        "<=": r"\leq",
        "!=": r"\neq",
    }

    return "%s %s %s" % (self._print(expr.lhs),
                         charmap[expr.rel_op], self._print(expr.rhs))

sympy.sympy.printing.latex._print_Piecewise

def _print_Piecewise(self, expr):
    ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
               for e, c in expr.args[:-1]]
    if expr.args[-1].cond == true:
        ecpairs.append(r"%s & \text{otherwise}" %
                       self._print(expr.args[-1].expr))
    else:
        ecpairs.append(r"%s & \text{for}\: %s" %
                       (self._print(expr.args[-1].expr),
                        self._print(expr.args[-1].cond)))
    tex = r"\begin{cases} %s \end{cases}"
    return tex % r" \\".join(ecpairs)

sympy.sympy.printing.latex._print_MatrixBase

def _print_MatrixBase(self, expr):
    out_str = self._print_matrix_contents(expr)
    if self._settings['mat_delim']:
        left_delim = self._settings['mat_delim']
        right_delim = self._delim_dict[left_delim]
        out_str = r'\left' + left_delim + out_str + \
                  r'\right' + right_delim
    return out_str

sympy.sympy.printing.latex._print_MatrixElement

def _print_MatrixElement(self, expr):
    matrix_part = self.parenthesize(expr.parent, PRECEDENCE['Atom'], strict=True)
    index_part = f"{self._print(expr.i)},{self._print(expr.j)}"
    return f"{{{matrix_part}}}_{{{index_part}}}"

sympy.sympy.printing.latex._print_MatrixSlice

def _print_MatrixSlice(self, expr):
    def latexslice(x, dim):
        x = list(x)
        if x[2] == 1:
            del x[2]
        if x[0] == 0:
            x[0] = None
        if x[1] == dim:
            x[1] = None
        return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
    return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
            latexslice(expr.rowslice, expr.parent.rows) + ', ' +
            latexslice(expr.colslice, expr.parent.cols) + r'\right]')

sympy.sympy.printing.latex._print_BlockMatrix

def _print_BlockMatrix(self, expr):
    return self._print(expr.blocks)

sympy.sympy.printing.latex._print_Transpose

def _print_Transpose(self, expr):
    mat = expr.arg
    from sympy.matrices import MatrixSymbol, BlockMatrix
    if (not isinstance(mat, MatrixSymbol) and
        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):
        return r"\left(%s\right)^{T}" % self._print(mat)
    else:
        s = self.parenthesize(mat, precedence_traditional(expr), True)
        if '^' in s:
            return r"\left(%s\right)^{T}" % s
        else:
            return "%s^{T}" % s

sympy.sympy.printing.latex._print_Trace

def _print_Trace(self, expr):
    mat = expr.arg
    return r"\operatorname{tr}\left(%s \right)" % self._print(mat)

sympy.sympy.printing.latex._print_Adjoint

def _print_Adjoint(self, expr):
    style_to_latex = {
        "dagger"   : r"\dagger",
        "star"     : r"\ast",
        "hermitian": r"\mathsf{H}"
    }
    adjoint_style = style_to_latex.get(self._settings["adjoint_style"], r"\dagger")
    mat = expr.arg
    from sympy.matrices import MatrixSymbol, BlockMatrix
    if (not isinstance(mat, MatrixSymbol) and
        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):
        return r"\left(%s\right)^{%s}" % (self._print(mat), adjoint_style)
    else:
        s = self.parenthesize(mat, precedence_traditional(expr), True)
        if '^' in s:
            return r"\left(%s\right)^{%s}" % (s, adjoint_style)
        else:
            return r"%s^{%s}" % (s, adjoint_style)

sympy.sympy.printing.latex._print_MatMul

def _print_MatMul(self, expr):
    from sympy import MatMul

    # Parenthesize nested MatMul but not other types of Mul objects:
    parens = lambda x: self._print(x) if isinstance(x, Mul) and not isinstance(x, MatMul) else \
        self.parenthesize(x, precedence_traditional(expr), False)

    args = list(expr.args)
    if expr.could_extract_minus_sign():
        if args[0] == -1:
            args = args[1:]
        else:
            args[0] = -args[0]
        return '- ' + ' '.join(map(parens, args))
    else:
        return ' '.join(map(parens, args))

sympy.sympy.printing.latex._print_DotProduct

def _print_DotProduct(self, expr):
    level = precedence_traditional(expr)
    left, right = expr.args
    return rf"{self.parenthesize(left, level)} \cdot {self.parenthesize(right, level)}"

sympy.sympy.printing.latex._print_Determinant

def _print_Determinant(self, expr):
    mat = expr.arg
    if mat.is_MatrixExpr:
        from sympy.matrices.expressions.blockmatrix import BlockMatrix
        if isinstance(mat, BlockMatrix):
            return r"\left|{%s}\right|" % self._print_matrix_contents(mat.blocks)
        return r"\left|{%s}\right|" % self._print(mat)
    return r"\left|{%s}\right|" % self._print_matrix_contents(mat)

sympy.sympy.printing.latex._print_Mod

def _print_Mod(self, expr, exp=None):
    if exp is not None:
        return r'\left(%s \bmod %s\right)^{%s}' % \
            (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
                               strict=True),
             self.parenthesize(expr.args[1], PRECEDENCE['Mul'],
                               strict=True),
             exp)
    return r'%s \bmod %s' % (self.parenthesize(expr.args[0],
                                               PRECEDENCE['Mul'],
                                               strict=True),
                             self.parenthesize(expr.args[1],
                                               PRECEDENCE['Mul'],
                                               strict=True))

sympy.sympy.printing.latex._print_HadamardProduct

def _print_HadamardProduct(self, expr):
    args = expr.args
    prec = PRECEDENCE['Pow']
    parens = self.parenthesize

    return r' \circ '.join(
        (parens(arg, prec, strict=True) for arg in args))

sympy.sympy.printing.latex._print_HadamardPower

def _print_HadamardPower(self, expr):
    if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
        template = r"%s^{\circ \left({%s}\right)}"
    else:
        template = r"%s^{\circ {%s}}"
    return self._helper_print_standard_power(expr, template)

sympy.sympy.printing.latex._print_KroneckerProduct

def _print_KroneckerProduct(self, expr):
    args = expr.args
    prec = PRECEDENCE['Pow']
    parens = self.parenthesize

    return r' \otimes '.join(
        (parens(arg, prec, strict=True) for arg in args))

sympy.sympy.printing.latex._print_MatPow

def _print_MatPow(self, expr):
    base, exp = expr.base, expr.exp
    from sympy.matrices import MatrixSymbol
    if not isinstance(base, MatrixSymbol) and base.is_MatrixExpr:
        return "\\left(%s\\right)^{%s}" % (self._print(base),
                                          self._print(exp))
    else:
        base_str = self._print(base)
        if '^' in base_str:
            return r"\left(%s\right)^{%s}" % (base_str, self._print(exp))
        else:
            return "%s^{%s}" % (base_str, self._print(exp))

sympy.sympy.printing.latex._print_MatrixSymbol

def _print_MatrixSymbol(self, expr):
    return self._print_Symbol(expr, style=self._settings[
        'mat_symbol_style'])

sympy.sympy.printing.latex._print_MatrixUnit

def _print_MatrixUnit(self, E):
    return "E_{%s,%s}" % (self._print(E._i), self._print(E._j)) \
        if self._settings['mat_symbol_style'] == 'plain' else r"\mathcal{E}_{%s,%s}" % (self._print(E._i), self._print(E._j))

sympy.sympy.printing.latex._print_ZeroMatrix

def _print_ZeroMatrix(self, Z):
    return "0" if self._settings[
        'mat_symbol_style'] == 'plain' else r"\mathbf{0}"

sympy.sympy.printing.latex._print_OneMatrix

def _print_OneMatrix(self, O):
    return "1" if self._settings[
        'mat_symbol_style'] == 'plain' else r"\mathbf{1}"

sympy.sympy.printing.latex._print_Identity

def _print_Identity(self, I):
    return r"\mathbb{I}" if self._settings[
        'mat_symbol_style'] == 'plain' else r"\mathbf{I}"

sympy.sympy.printing.latex._print_PermutationMatrix

def _print_PermutationMatrix(self, P):
    perm_str = self._print(P.args[0])
    return "P_{%s}" % perm_str

sympy.sympy.printing.latex._print_NDimArray

def _print_NDimArray(self, expr: NDimArray):

    if expr.rank() == 0:
        return self._print(expr[()])

    mat_str = self._settings['mat_str']
    if mat_str is None:
        if self._settings['mode'] == 'inline':
            mat_str = 'smallmatrix'
        else:
            if (expr.rank() == 0) or (expr.shape[-1] <= 10):
                mat_str = 'matrix'
            else:
                mat_str = 'array'
    block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
    block_str = block_str.replace('%MATSTR%', mat_str)
    if mat_str == 'array':
        block_str = block_str.replace('%s', '{' + 'c'*expr.shape[0] + '}%s')

    if self._settings['mat_delim']:
        left_delim: str = self._settings['mat_delim']
        right_delim = self._delim_dict[left_delim]
        block_str = r'\left' + left_delim + block_str + \
                    r'\right' + right_delim

    if expr.rank() == 0:
        return block_str % ""

    level_str: list[list[str]] = [[] for i in range(expr.rank() + 1)]
    shape_ranges = [list(range(i)) for i in expr.shape]
    for outer_i in itertools.product(*shape_ranges):
        level_str[-1].append(self._print(expr[outer_i]))
        even = True
        for back_outer_i in range(expr.rank()-1, -1, -1):
            if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
                break
            if even:
                level_str[back_outer_i].append(
                    r" & ".join(level_str[back_outer_i+1]))
            else:
                level_str[back_outer_i].append(
                    block_str % (r"\\".join(level_str[back_outer_i+1])))
                if len(level_str[back_outer_i+1]) == 1:
                    level_str[back_outer_i][-1] = r"\left[" + \
                        level_str[back_outer_i][-1] + r"\right]"
            even = not even
            level_str[back_outer_i+1] = []

    out_str = level_str[0][0]

    if expr.rank() % 2 == 1:
        out_str = block_str % out_str

    return out_str

sympy.sympy.printing.latex._print_Tensor

def _print_Tensor(self, expr):
    name = expr.args[0].args[0]
    indices = expr.get_indices()
    return self._printer_tensor_indices(name, indices, {})

sympy.sympy.printing.latex._print_TensorElement

def _print_TensorElement(self, expr):
    name = expr.expr.args[0].args[0]
    indices = expr.expr.get_indices()
    index_map = expr.index_map
    return self._printer_tensor_indices(name, indices, index_map)

sympy.sympy.printing.latex._print_TensMul

def _print_TensMul(self, expr):
    # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
    sign, args = expr._get_args_for_traditional_printer()
    return sign + "".join(
        [self.parenthesize(arg, precedence(expr)) for arg in args]
    )

sympy.sympy.printing.latex._print_TensAdd

def _print_TensAdd(self, expr):
    a = []
    args = expr.args
    for x in args:
        a.append(self.parenthesize(x, precedence(expr)))
    a.sort()
    s = ' + '.join(a)
    s = s.replace('+ -', '- ')
    return s

sympy.sympy.printing.latex._print_TensorIndex

def _print_TensorIndex(self, expr):
    return "{}%s{%s}" % (
        "^" if expr.is_up else "_",
        self._print(expr.args[0])
    )

sympy.sympy.printing.latex._print_PartialDerivative

def _print_PartialDerivative(self, expr):
    if len(expr.variables) == 1:
        return r"\frac{\partial}{\partial {%s}}{%s}" % (
            self._print(expr.variables[0]),
            self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
        )
    else:
        return r"\frac{\partial^{%s}}{%s}{%s}" % (
            len(expr.variables),
            " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
            self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
        )

sympy.sympy.printing.latex._print_ArraySymbol

def _print_ArraySymbol(self, expr):
    return self._print(expr.name)

sympy.sympy.printing.latex._print_ArrayElement

def _print_ArrayElement(self, expr):
    return "{{%s}_{%s}}" % (
        self.parenthesize(expr.name, PRECEDENCE["Func"], True),
        ", ".join([f"{self._print(i)}" for i in expr.indices]))

sympy.sympy.printing.latex._print_UniversalSet

def _print_UniversalSet(self, expr):
    return r"\mathbb{U}"

sympy.sympy.printing.latex._print_frac

def _print_frac(self, expr, exp=None):
    if exp is None:
        return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
    else:
        return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
                self._print(expr.args[0]), exp)

sympy.sympy.printing.latex._print_tuple

def _print_tuple(self, expr):
    if self._settings['decimal_separator'] == 'comma':
        sep = ";"
    elif self._settings['decimal_separator'] == 'period':
        sep = ","
    else:
        raise ValueError('Unknown Decimal Separator')

    if len(expr) == 1:
        # 1-tuple needs a trailing separator
        return self._add_parens_lspace(self._print(expr[0]) + sep)
    else:
        return self._add_parens_lspace(
            (sep + r" \  ").join([self._print(i) for i in expr]))

sympy.sympy.printing.latex._print_TensorProduct

def _print_TensorProduct(self, expr):
    elements = [self._print(a) for a in expr.args]
    return r' \otimes '.join(elements)

sympy.sympy.printing.latex._print_WedgeProduct

def _print_WedgeProduct(self, expr):
    elements = [self._print(a) for a in expr.args]
    return r' \wedge '.join(elements)

sympy.sympy.printing.latex._print_Tuple

def _print_Tuple(self, expr):
    return self._print_tuple(expr)

sympy.sympy.printing.latex._print_list

def _print_list(self, expr):
    if self._settings['decimal_separator'] == 'comma':
        return r"\left[ %s\right]" % \
            r"; \  ".join([self._print(i) for i in expr])
    elif self._settings['decimal_separator'] == 'period':
        return r"\left[ %s\right]" % \
            r", \  ".join([self._print(i) for i in expr])
    else:
        raise ValueError('Unknown Decimal Separator')

sympy.sympy.printing.latex._print_dict

def _print_dict(self, d):
    keys = sorted(d.keys(), key=default_sort_key)
    items = []

    for key in keys:
        val = d[key]
        items.append("%s : %s" % (self._print(key), self._print(val)))

    return r"\left\{ %s\right\}" % r", \  ".join(items)

sympy.sympy.printing.latex._print_Dict

def _print_Dict(self, expr):
    return self._print_dict(expr)

sympy.sympy.printing.latex._print_DiracDelta

def _print_DiracDelta(self, expr, exp=None):
    if len(expr.args) == 1 or expr.args[1] == 0:
        tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
    else:
        tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
            self._print(expr.args[1]), self._print(expr.args[0]))
    if exp:
        tex = r"\left(%s\right)^{%s}" % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_SingularityFunction

def _print_SingularityFunction(self, expr, exp=None):
    shift = self._print(expr.args[0] - expr.args[1])
    power = self._print(expr.args[2])
    tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
    if exp is not None:
        tex = r"{\left({\langle %s \rangle}^{%s}\right)}^{%s}" % (shift, power, exp)
    return tex

sympy.sympy.printing.latex._print_Heaviside

def _print_Heaviside(self, expr, exp=None):
    pargs = ', '.join(self._print(arg) for arg in expr.pargs)
    tex = r"\theta\left(%s\right)" % pargs
    if exp:
        tex = r"\left(%s\right)^{%s}" % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_KroneckerDelta

def _print_KroneckerDelta(self, expr, exp=None):
    i = self._print(expr.args[0])
    j = self._print(expr.args[1])
    if expr.args[0].is_Atom and expr.args[1].is_Atom:
        tex = r'\delta_{%s %s}' % (i, j)
    else:
        tex = r'\delta_{%s, %s}' % (i, j)
    if exp is not None:
        tex = r'\left(%s\right)^{%s}' % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_LeviCivita

def _print_LeviCivita(self, expr, exp=None):
    indices = map(self._print, expr.args)
    if all(x.is_Atom for x in expr.args):
        tex = r'\varepsilon_{%s}' % " ".join(indices)
    else:
        tex = r'\varepsilon_{%s}' % ", ".join(indices)
    if exp:
        tex = r'\left(%s\right)^{%s}' % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_RandomDomain

def _print_RandomDomain(self, d):
    if hasattr(d, 'as_boolean'):
        return '\\text{Domain: }' + self._print(d.as_boolean())
    elif hasattr(d, 'set'):
        return ('\\text{Domain: }' + self._print(d.symbols) + ' \\in ' +
                self._print(d.set))
    elif hasattr(d, 'symbols'):
        return '\\text{Domain on }' + self._print(d.symbols)
    else:
        return self._print(None)

sympy.sympy.printing.latex._print_FiniteSet

def _print_FiniteSet(self, s):
    items = sorted(s.args, key=default_sort_key)
    return self._print_set(items)

sympy.sympy.printing.latex._print_set

def _print_set(self, s):
    items = sorted(s, key=default_sort_key)
    if self._settings['decimal_separator'] == 'comma':
        items = "; ".join(map(self._print, items))
    elif self._settings['decimal_separator'] == 'period':
        items = ", ".join(map(self._print, items))
    else:
        raise ValueError('Unknown Decimal Separator')
    return r"\left\{%s\right\}" % items

sympy.sympy.printing.latex._print_Range

def _print_Range(self, s):
    def _print_symbolic_range():
        # Symbolic Range that cannot be resolved
        if s.args[0] == 0:
            if s.args[2] == 1:
                cont = self._print(s.args[1])
            else:
                cont = ", ".join(self._print(arg) for arg in s.args)
        else:
            if s.args[2] == 1:
                cont = ", ".join(self._print(arg) for arg in s.args[:2])
            else:
                cont = ", ".join(self._print(arg) for arg in s.args)

        return(f"\\text{{Range}}\\left({cont}\\right)")

    dots = object()

    if s.start.is_infinite and s.stop.is_infinite:
        if s.step.is_positive:
            printset = dots, -1, 0, 1, dots
        else:
            printset = dots, 1, 0, -1, dots
    elif s.start.is_infinite:
        printset = dots, s[-1] - s.step, s[-1]
    elif s.stop.is_infinite:
        it = iter(s)
        printset = next(it), next(it), dots
    elif s.is_empty is not None:
        if (s.size < 4) == True:
            printset = tuple(s)
        elif s.is_iterable:
            it = iter(s)
            printset = next(it), next(it), dots, s[-1]
        else:
            return _print_symbolic_range()
    else:
        return _print_symbolic_range()
    return (r"\left\{" +
            r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
            r"\right\}")

sympy.sympy.printing.latex._print_bernoulli

def _print_bernoulli(self, expr, exp=None):
    return self.__print_number_polynomial(expr, "B", exp)

sympy.sympy.printing.latex._print_genocchi

def _print_genocchi(self, expr, exp=None):
    return self.__print_number_polynomial(expr, "G", exp)

sympy.sympy.printing.latex._print_bell

def _print_bell(self, expr, exp=None):
    if len(expr.args) == 3:
        tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
                            self._print(expr.args[1]))
        tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
                                           el in expr.args[2])
        if exp is not None:
            tex = r"%s^{%s}%s" % (tex1, exp, tex2)
        else:
            tex = tex1 + tex2
        return tex
    return self.__print_number_polynomial(expr, "B", exp)

sympy.sympy.printing.latex._print_fibonacci

def _print_fibonacci(self, expr, exp=None):
    return self.__print_number_polynomial(expr, "F", exp)

sympy.sympy.printing.latex._print_lucas

def _print_lucas(self, expr, exp=None):
    tex = r"L_{%s}" % self._print(expr.args[0])
    if exp is not None:
        tex = r"%s^{%s}" % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_tribonacci

def _print_tribonacci(self, expr, exp=None):
    return self.__print_number_polynomial(expr, "T", exp)

sympy.sympy.printing.latex._print_mobius

def _print_mobius(self, expr, exp=None):
    if exp is None:
        return r'\mu\left(%s\right)' % self._print(expr.args[0])
    return r'\mu^{%s}\left(%s\right)' % (exp, self._print(expr.args[0]))

sympy.sympy.printing.latex._print_SeqFormula

def _print_SeqFormula(self, s):
    dots = object()
    if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
        return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
            self._print(s.formula),
            self._print(s.variables[0]),
            self._print(s.start),
            self._print(s.stop)
        )
    if s.start is S.NegativeInfinity:
        stop = s.stop
        printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
                    s.coeff(stop - 1), s.coeff(stop))
    elif s.stop is S.Infinity or s.length > 4:
        printset = s[:4]
        printset.append(dots)
    else:
        printset = tuple(s)

    return (r"\left[" +
            r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
            r"\right]")

sympy.sympy.printing.latex._print_Interval

def _print_Interval(self, i):
    if i.start == i.end:
        return r"\left\{%s\right\}" % self._print(i.start)

    else:
        if i.left_open:
            left = '('
        else:
            left = '['

        if i.right_open:
            right = ')'
        else:
            right = ']'

        return r"\left%s%s, %s\right%s" % \
               (left, self._print(i.start), self._print(i.end), right)

sympy.sympy.printing.latex._print_AccumulationBounds

def _print_AccumulationBounds(self, i):
    return r"\left\langle %s, %s\right\rangle" % \
            (self._print(i.min), self._print(i.max))

sympy.sympy.printing.latex._print_Union

def _print_Union(self, u):
    prec = precedence_traditional(u)
    args_str = [self.parenthesize(i, prec) for i in u.args]
    return r" \cup ".join(args_str)

sympy.sympy.printing.latex._print_Complement

def _print_Complement(self, u):
    prec = precedence_traditional(u)
    args_str = [self.parenthesize(i, prec) for i in u.args]
    return r" \setminus ".join(args_str)

sympy.sympy.printing.latex._print_Intersection

def _print_Intersection(self, u):
    prec = precedence_traditional(u)
    args_str = [self.parenthesize(i, prec) for i in u.args]
    return r" \cap ".join(args_str)

sympy.sympy.printing.latex._print_SymmetricDifference

def _print_SymmetricDifference(self, u):
    prec = precedence_traditional(u)
    args_str = [self.parenthesize(i, prec) for i in u.args]
    return r" \triangle ".join(args_str)

sympy.sympy.printing.latex._print_ProductSet

def _print_ProductSet(self, p):
    prec = precedence_traditional(p)
    if len(p.sets) >= 1 and not has_variety(p.sets):
        return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
    return r" \times ".join(
        self.parenthesize(set, prec) for set in p.sets)

sympy.sympy.printing.latex._print_EmptySet

def _print_EmptySet(self, e):
    return r"\emptyset"

sympy.sympy.printing.latex._print_Naturals

def _print_Naturals(self, n):
    return r"\mathbb{N}"

sympy.sympy.printing.latex._print_Naturals0

def _print_Naturals0(self, n):
    return r"\mathbb{N}_0"

sympy.sympy.printing.latex._print_Integers

def _print_Integers(self, i):
    return r"\mathbb{Z}"

sympy.sympy.printing.latex._print_Rationals

def _print_Rationals(self, i):
    return r"\mathbb{Q}"

sympy.sympy.printing.latex._print_Reals

def _print_Reals(self, i):
    return r"\mathbb{R}"

sympy.sympy.printing.latex._print_Complexes

def _print_Complexes(self, i):
    return r"\mathbb{C}"

sympy.sympy.printing.latex._print_ImageSet

def _print_ImageSet(self, s):
    expr = s.lamda.expr
    sig = s.lamda.signature
    xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
    xinys = r", ".join(r"%s \in %s" % xy for xy in xys)
    return r"\left\{%s\; \middle|\; %s\right\}" % (self._print(expr), xinys)

sympy.sympy.printing.latex._print_ConditionSet

def _print_ConditionSet(self, s):
    vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
    if s.base_set is S.UniversalSet:
        return r"\left\{%s\; \middle|\; %s \right\}" % \
            (vars_print, self._print(s.condition))

    return r"\left\{%s\; \middle|\; %s \in %s \wedge %s \right\}" % (
        vars_print,
        vars_print,
        self._print(s.base_set),
        self._print(s.condition))

sympy.sympy.printing.latex._print_PowerSet

def _print_PowerSet(self, expr):
    arg_print = self._print(expr.args[0])
    return r"\mathcal{{P}}\left({}\right)".format(arg_print)

sympy.sympy.printing.latex._print_ComplexRegion

def _print_ComplexRegion(self, s):
    vars_print = ', '.join([self._print(var) for var in s.variables])
    return r"\left\{%s\; \middle|\; %s \in %s \right\}" % (
        self._print(s.expr),
        vars_print,
        self._print(s.sets))

sympy.sympy.printing.latex._print_Contains

def _print_Contains(self, e):
    return r"%s \in %s" % tuple(self._print(a) for a in e.args)

sympy.sympy.printing.latex._print_FourierSeries

def _print_FourierSeries(self, s):
    if s.an.formula is S.Zero and s.bn.formula is S.Zero:
        return self._print(s.a0)
    return self._print_Add(s.truncate()) + r' + \ldots'

sympy.sympy.printing.latex._print_FormalPowerSeries

def _print_FormalPowerSeries(self, s):
    return self._print_Add(s.infinite)

sympy.sympy.printing.latex._print_IntegerRing

def _print_IntegerRing(self, expr):
    return r"\mathbb{Z}"

sympy.sympy.printing.latex._print_RationalField

def _print_RationalField(self, expr):
    return r"\mathbb{Q}"

sympy.sympy.printing.latex._print_RealField

def _print_RealField(self, expr):
    return r"\mathbb{R}"

sympy.sympy.printing.latex._print_PolynomialRing

def _print_PolynomialRing(self, expr):
    domain = self._print(expr.domain)
    symbols = ", ".join(map(self._print, expr.symbols))
    return r"%s\left[%s\right]" % (domain, symbols)

sympy.sympy.printing.latex._print_FractionField

def _print_FractionField(self, expr):
    domain = self._print(expr.domain)
    symbols = ", ".join(map(self._print, expr.symbols))
    return r"%s\left(%s\right)" % (domain, symbols)

sympy.sympy.printing.latex._print_PolynomialRingBase

def _print_PolynomialRingBase(self, expr):
    domain = self._print(expr.domain)
    symbols = ", ".join(map(self._print, expr.symbols))
    inv = ""
    if not expr.is_Poly:
        inv = r"S_<^{-1}"
    return r"%s%s\left[%s\right]" % (inv, domain, symbols)

sympy.sympy.printing.latex._print_Poly

def _print_Poly(self, poly):
    cls = poly.__class__.__name__
    terms = []
    for monom, coeff in poly.terms():
        s_monom = ''
        for i, exp in enumerate(monom):
            if exp > 0:
                if exp == 1:
                    s_monom += self._print(poly.gens[i])
                else:
                    s_monom += self._print(pow(poly.gens[i], exp))

        if coeff.is_Add:
            if s_monom:
                s_coeff = r"\left(%s\right)" % self._print(coeff)
            else:
                s_coeff = self._print(coeff)
        else:
            if s_monom:
                if coeff is S.One:
                    terms.extend(['+', s_monom])
                    continue

                if coeff is S.NegativeOne:
                    terms.extend(['-', s_monom])
                    continue

            s_coeff = self._print(coeff)

        if not s_monom:
            s_term = s_coeff
        else:
            s_term = s_coeff + " " + s_monom

        if s_term.startswith('-'):
            terms.extend(['-', s_term[1:]])
        else:
            terms.extend(['+', s_term])

    if terms[0] in ('-', '+'):
        modifier = terms.pop(0)

        if modifier == '-':
            terms[0] = '-' + terms[0]

    expr = ' '.join(terms)
    gens = list(map(self._print, poly.gens))
    domain = "domain=%s" % self._print(poly.get_domain())

    args = ", ".join([expr] + gens + [domain])
    if cls in accepted_latex_functions:
        tex = r"\%s {\left(%s \right)}" % (cls, args)
    else:
        tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)

    return tex

sympy.sympy.printing.latex._print_ComplexRootOf

def _print_ComplexRootOf(self, root):
    cls = root.__class__.__name__
    if cls == "ComplexRootOf":
        cls = "CRootOf"
    expr = self._print(root.expr)
    index = root.index
    if cls in accepted_latex_functions:
        return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
    else:
        return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
                                                             index)

sympy.sympy.printing.latex._print_RootSum

def _print_RootSum(self, expr):
    cls = expr.__class__.__name__
    args = [self._print(expr.expr)]

    if expr.fun is not S.IdentityFunction:
        args.append(self._print(expr.fun))

    if cls in accepted_latex_functions:
        return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
    else:
        return r"\operatorname{%s} {\left(%s\right)}" % (cls,
                                                         ", ".join(args))

sympy.sympy.printing.latex._print_OrdinalOmega

def _print_OrdinalOmega(self, expr):
    return r"\omega"

sympy.sympy.printing.latex._print_OmegaPower

def _print_OmegaPower(self, expr):
    exp, mul = expr.args
    if mul != 1:
        if exp != 1:
            return r"{} \omega^{{{}}}".format(mul, exp)
        else:
            return r"{} \omega".format(mul)
    else:
        if exp != 1:
            return r"\omega^{{{}}}".format(exp)
        else:
            return r"\omega"

sympy.sympy.printing.latex._print_Ordinal

def _print_Ordinal(self, expr):
    return " + ".join([self._print(arg) for arg in expr.args])

sympy.sympy.printing.latex._print_PolyElement

def _print_PolyElement(self, poly):
    mul_symbol = self._settings['mul_symbol_latex']
    return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)

sympy.sympy.printing.latex._print_FracElement

def _print_FracElement(self, frac):
    if frac.denom == 1:
        return self._print(frac.numer)
    else:
        numer = self._print(frac.numer)
        denom = self._print(frac.denom)
        return r"\frac{%s}{%s}" % (numer, denom)

sympy.sympy.printing.latex._print_euler

def _print_euler(self, expr, exp=None):
    m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
    tex = r"E_{%s}" % self._print(m)
    if exp is not None:
        tex = r"%s^{%s}" % (tex, exp)
    if x is not None:
        tex = r"%s\left(%s\right)" % (tex, self._print(x))
    return tex

sympy.sympy.printing.latex._print_catalan

def _print_catalan(self, expr, exp=None):
    tex = r"C_{%s}" % self._print(expr.args[0])
    if exp is not None:
        tex = r"%s^{%s}" % (tex, exp)
    return tex

sympy.sympy.printing.latex._print_MellinTransform

def _print_MellinTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'M')

sympy.sympy.printing.latex._print_InverseMellinTransform

def _print_InverseMellinTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'M', True)

sympy.sympy.printing.latex._print_LaplaceTransform

def _print_LaplaceTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'L')

sympy.sympy.printing.latex._print_InverseLaplaceTransform

def _print_InverseLaplaceTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'L', True)

sympy.sympy.printing.latex._print_FourierTransform

def _print_FourierTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'F')

sympy.sympy.printing.latex._print_InverseFourierTransform

def _print_InverseFourierTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'F', True)

sympy.sympy.printing.latex._print_SineTransform

def _print_SineTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'SIN')

sympy.sympy.printing.latex._print_InverseSineTransform

def _print_InverseSineTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'SIN', True)

sympy.sympy.printing.latex._print_CosineTransform

def _print_CosineTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'COS')

sympy.sympy.printing.latex._print_InverseCosineTransform

def _print_InverseCosineTransform(self, expr):
    return self._print_UnifiedTransform(expr, 'COS', True)

sympy.sympy.printing.latex._print_Object

def _print_Object(self, object):
    return self._print(Symbol(object.name))

sympy.sympy.printing.latex._print_LambertW

def _print_LambertW(self, expr, exp=None):
    arg0 = self._print(expr.args[0])
    exp = r"^{%s}" % (exp,) if exp is not None else ""
    if len(expr.args) == 1:
        result = r"W%s\left(%s\right)" % (exp, arg0)
    else:
        arg1 = self._print(expr.args[1])
        result = "W{0}_{{{1}}}\\left({2}\\right)".format(exp, arg1, arg0)
    return result

sympy.sympy.printing.latex._print_Expectation

def _print_Expectation(self, expr):
    return r"\operatorname{{E}}\left[{}\right]".format(self._print(expr.args[0]))

sympy.sympy.printing.latex._print_Variance

def _print_Variance(self, expr):
    return r"\operatorname{{Var}}\left({}\right)".format(self._print(expr.args[0]))

sympy.sympy.printing.latex._print_Covariance

def _print_Covariance(self, expr):
    return r"\operatorname{{Cov}}\left({}\right)".format(", ".join(self._print(arg) for arg in expr.args))

sympy.sympy.printing.latex._print_Probability

def _print_Probability(self, expr):
    return r"\operatorname{{P}}\left({}\right)".format(self._print(expr.args[0]))

sympy.sympy.printing.latex._print_TransferFunction

def _print_TransferFunction(self, expr):
    num, den = self._print(expr.num), self._print(expr.den)
    return r"\frac{%s}{%s}" % (num, den)

sympy.sympy.printing.latex._print_DiscreteTransferFunction

def _print_DiscreteTransferFunction(self, expr):
    num, den = self._print(expr.num), self._print(expr.den)
    sampling_time = self._print(expr.sampling_time)
    return r"\frac{%s}{%s} \text{ [st: } {%s} \text{]}" % \
        (num, den, sampling_time)

sympy.sympy.printing.latex._print_Series

def _print_Series(self, expr):
    args = list(expr.args)
    parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
                                        False)
    return ' '.join(map(parens, args))

sympy.sympy.printing.latex._print_MIMOSeries

def _print_MIMOSeries(self, expr):
    from sympy.physics.control.lti import MIMOParallel
    args = list(expr.args)[::-1]
    parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
                                         False) if isinstance(x, MIMOParallel) else self._print(x)
    return r"\cdot".join(map(parens, args))

sympy.sympy.printing.latex._print_Parallel

def _print_Parallel(self, expr):
    return ' + '.join(map(self._print, expr.args))

sympy.sympy.printing.latex._print_MIMOParallel

def _print_MIMOParallel(self, expr):
    return ' + '.join(map(self._print, expr.args))

sympy.sympy.printing.latex._print_Feedback

def _print_Feedback(self, expr):
    from sympy.physics.control import TransferFunction, Series

    num, tf = expr.sys1, TransferFunction(1, 1, expr.var)
    num_arg_list = list(num.args) if isinstance(num, Series) else [num]
    den_arg_list = list(expr.sys2.args) if \
        isinstance(expr.sys2, Series) else [expr.sys2]
    den_term_1 = tf

    if isinstance(num, Series) and isinstance(expr.sys2, Series):
        den_term_2 = Series(*num_arg_list, *den_arg_list)
    elif isinstance(num, Series) and isinstance(expr.sys2, TransferFunction):
        if expr.sys2 == tf:
            den_term_2 = Series(*num_arg_list)
        else:
            den_term_2 = tf, Series(*num_arg_list, expr.sys2)
    elif isinstance(num, TransferFunction) and isinstance(expr.sys2, Series):
        if num == tf:
            den_term_2 = Series(*den_arg_list)
        else:
            den_term_2 = Series(num, *den_arg_list)
    else:
        if num == tf:
            den_term_2 = Series(*den_arg_list)
        elif expr.sys2 == tf:
            den_term_2 = Series(*num_arg_list)
        else:
            den_term_2 = Series(*num_arg_list, *den_arg_list)

    numer = self._print(num)
    denom_1 = self._print(den_term_1)
    denom_2 = self._print(den_term_2)
    _sign = "+" if expr.sign == -1 else "-"

    return r"\frac{%s}{%s %s %s}" % (numer, denom_1, _sign, denom_2)

sympy.sympy.printing.latex._print_MIMOFeedback

def _print_MIMOFeedback(self, expr):
    from sympy.physics.control import MIMOSeries
    inv_mat = self._print(MIMOSeries(expr.sys2, expr.sys1))
    sys1 = self._print(expr.sys1)
    _sign = "+" if expr.sign == -1 else "-"
    return r"\left(I_{\tau} %s %s\right)^{-1} \cdot %s" % (_sign, inv_mat,
                                                           sys1)

sympy.sympy.printing.latex._print_TransferFunctionMatrix

def _print_TransferFunctionMatrix(self, expr):
    mat = self._print(expr._expr_mat)
    if expr.sampling_time == 0:
        print_mat = r"%s_\tau" % mat
    else:
        print_mat = r"\underset{[st:\ {%s}]}{%s_k}" %\
                    (expr.sampling_time, mat)
    return print_mat

sympy.sympy.printing.latex._print_DFT

def _print_DFT(self, expr):
    return r"\text{{{}}}_{{{}}}".format(expr.__class__.__name__, expr.n)

sympy.sympy.printing.latex._print_NamedMorphism

def _print_NamedMorphism(self, morphism):
    pretty_name = self._print(Symbol(morphism.name))
    pretty_morphism = self._print_Morphism(morphism)
    return "%s:%s" % (pretty_name, pretty_morphism)

sympy.sympy.printing.latex._print_IdentityMorphism

def _print_IdentityMorphism(self, morphism):
    from sympy.categories import NamedMorphism
    return self._print_NamedMorphism(NamedMorphism(
        morphism.domain, morphism.codomain, "id"))

sympy.sympy.printing.latex._print_CompositeMorphism

def _print_CompositeMorphism(self, morphism):
    # All components of the morphism have names and it is thus
    # possible to build the name of the composite.
    component_names_list = [self._print(Symbol(component.name)) for
                            component in morphism.components]
    component_names_list.reverse()
    component_names = "\\circ ".join(component_names_list) + ":"

    pretty_morphism = self._print_Morphism(morphism)
    return component_names + pretty_morphism

sympy.sympy.printing.latex._print_Category

def _print_Category(self, morphism):
    return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))

sympy.sympy.printing.latex._print_Diagram

def _print_Diagram(self, diagram):
    if not diagram.premises:
        # This is an empty diagram.
        return self._print(S.EmptySet)

    latex_result = self._print(diagram.premises)
    if diagram.conclusions:
        latex_result += "\\Longrightarrow %s" % \
                        self._print(diagram.conclusions)

    return latex_result

sympy.sympy.printing.latex._print_DiagramGrid

def _print_DiagramGrid(self, grid):
    latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)

    for i in range(grid.height):
        for j in range(grid.width):
            if grid[i, j]:
                latex_result += latex(grid[i, j])
            latex_result += " "
            if j != grid.width - 1:
                latex_result += "& "

        if i != grid.height - 1:
            latex_result += "\\\\"
        latex_result += "\n"

    latex_result += "\\end{array}\n"
    return latex_result

sympy.sympy.printing.latex._print_FreeModule

def _print_FreeModule(self, M):
    return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))

sympy.sympy.printing.latex._print_SubModule

def _print_SubModule(self, m):
    gens = [[self._print(m.ring.to_sympy(x)) for x in g] for g in m.gens]
    curly = lambda o: r"{" + o + r"}"
    square = lambda o: r"\left[ " + o + r" \right]"
    gens_latex = ",".join(curly(square(",".join(curly(x) for x in g))) for g in gens)
    return r"\left\langle {} \right\rangle".format(gens_latex)

sympy.sympy.printing.latex._print_SubQuotientModule

def _print_SubQuotientModule(self, m):
    gens_latex = ",".join(["{" + self._print(g) + "}" for g in m.gens])
    return r"\left\langle {} \right\rangle".format(gens_latex)

sympy.sympy.printing.latex._print_ModuleImplementedIdeal

def _print_ModuleImplementedIdeal(self, m):
    gens = [m.ring.to_sympy(x) for [x] in m._module.gens]
    gens_latex = ",".join('{' + self._print(x) + '}' for x in gens)
    return r"\left\langle {} \right\rangle".format(gens_latex)

sympy.sympy.printing.latex._print_Quaternion

def _print_Quaternion(self, expr):
    # TODO: This expression is potentially confusing,
    # shall we print it as `Quaternion( ... )`?
    s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
         for i in expr.args]
    a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
    return " + ".join(a)

sympy.sympy.printing.latex._print_QuotientRing

def _print_QuotientRing(self, R):
    # TODO nicer fractions for few generators...
    return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
             self._print(R.base_ideal))

sympy.sympy.printing.latex._print_QuotientRingElement

def _print_QuotientRingElement(self, x):
    x_latex = self._print(x.ring.to_sympy(x))
    return r"{{{}}} + {{{}}}".format(x_latex,
             self._print(x.ring.base_ideal))

sympy.sympy.printing.latex._print_QuotientModuleElement

def _print_QuotientModuleElement(self, m):
    data = [m.module.ring.to_sympy(x) for x in m.data]
    data_latex = r"\left[ {} \right]".format(",".join(
        '{' + self._print(x) + '}' for x in data))
    return r"{{{}}} + {{{}}}".format(data_latex,
             self._print(m.module.killed_module))

sympy.sympy.printing.latex._print_QuotientModule

def _print_QuotientModule(self, M):
    # TODO nicer fractions for few generators...
    return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
             self._print(M.killed_module))

sympy.sympy.printing.latex._print_MatrixHomomorphism

def _print_MatrixHomomorphism(self, h):
    return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
        self._print(h.domain), self._print(h.codomain))

sympy.sympy.printing.latex._print_Manifold

def _print_Manifold(self, manifold):
    name, supers, subs = self._split_super_sub(manifold.name.name)

    name = r'\text{%s}' % name
    if supers:
        name += "^{%s}" % " ".join(supers)
    if subs:
        name += "_{%s}" % " ".join(subs)

    return name

sympy.sympy.printing.latex._print_Patch

def _print_Patch(self, patch):
    return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))

sympy.sympy.printing.latex._print_CoordSystem

def _print_CoordSystem(self, coordsys):
    return r'\text{%s}^{\text{%s}}_{%s}' % (
        self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
    )

sympy.sympy.printing.latex._print_BaseScalarField

def _print_BaseScalarField(self, field):
    string = field._coord_sys.symbols[field._index].name
    return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))

sympy.sympy.printing.latex._print_Differential

def _print_Differential(self, diff):
    field = diff._form_field
    if hasattr(field, '_coord_sys'):
        string = field._coord_sys.symbols[field._index].name
        return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
    else:
        string = self._print(field)
        return r'\operatorname{{d}}\left({}\right)'.format(string)

sympy.sympy.printing.latex._print_Tr

def _print_Tr(self, p):
    # TODO: Handle indices
    contents = self._print(p.args[0])
    return r'\operatorname{{tr}}\left({}\right)'.format(contents)

sympy.sympy.printing.latex._print_totient

def _print_totient(self, expr, exp=None):
    if exp is not None:
        return r'\left(\phi\left(%s\right)\right)^{%s}' % \
            (self._print(expr.args[0]), exp)
    return r'\phi\left(%s\right)' % self._print(expr.args[0])

sympy.sympy.printing.latex._print_reduced_totient

def _print_reduced_totient(self, expr, exp=None):
    if exp is not None:
        return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
            (self._print(expr.args[0]), exp)
    return r'\lambda\left(%s\right)' % self._print(expr.args[0])

sympy.sympy.printing.latex._print_divisor_sigma

def _print_divisor_sigma(self, expr, exp=None):
    if len(expr.args) == 2:
        tex = r"_%s\left(%s\right)" % tuple(map(self._print,
                                            (expr.args[1], expr.args[0])))
    else:
        tex = r"\left(%s\right)" % self._print(expr.args[0])
    if exp is not None:
        return r"\sigma^{%s}%s" % (exp, tex)
    return r"\sigma%s" % tex

sympy.sympy.printing.latex._print_udivisor_sigma

def _print_udivisor_sigma(self, expr, exp=None):
    if len(expr.args) == 2:
        tex = r"_%s\left(%s\right)" % tuple(map(self._print,
                                            (expr.args[1], expr.args[0])))
    else:
        tex = r"\left(%s\right)" % self._print(expr.args[0])
    if exp is not None:
        return r"\sigma^*^{%s}%s" % (exp, tex)
    return r"\sigma^*%s" % tex

sympy.sympy.printing.latex._print_primenu

def _print_primenu(self, expr, exp=None):
    if exp is not None:
        return r'\left(\nu\left(%s\right)\right)^{%s}' % \
            (self._print(expr.args[0]), exp)
    return r'\nu\left(%s\right)' % self._print(expr.args[0])

sympy.sympy.printing.latex._print_primeomega

def _print_primeomega(self, expr, exp=None):
    if exp is not None:
        return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
            (self._print(expr.args[0]), exp)
    return r'\Omega\left(%s\right)' % self._print(expr.args[0])

sympy.sympy.printing.latex._print_Str

def _print_Str(self, s):
    return str(s.name)

sympy.sympy.printing.latex._print_float

def _print_float(self, expr):
    return self._print(Float(expr))

sympy.sympy.printing.latex._print_int

def _print_int(self, expr):
    return str(expr)

sympy.sympy.printing.latex.emptyPrinter

def emptyPrinter(self, expr):
    # default to just printing as monospace, like would normally be shown
    s = super().emptyPrinter(expr)

    return r"\mathtt{\text{%s}}" % latex_escape(s)

sympy.sympy.printing.latex._print_Basic

def _print_Basic(self, expr):
    name = self._deal_with_super_sub(expr.__class__.__name__)
    if expr.args:
        ls = [self._print(o) for o in expr.args]
        s = r"\operatorname{{{}}}\left({}\right)"
        return s.format(name, ", ".join(ls))
    else:
        return r"\text{{{}}}".format(name)

sympy.sympy.printing.latex._print_bool

def _print_bool(self, e: bool | BooleanTrue | BooleanFalse):
    return r"\text{%s}" % e

sympy.sympy.printing.latex._print_NoneType

def _print_NoneType(self, e):
    return r"\text{%s}" % e

sympy.sympy.printing.latex._print_Add

def _print_Add(self, expr, order=None):
    terms = self._as_ordered_terms(expr, order=order)

    tex = ""
    for i, term in enumerate(terms):
        if i == 0:
            pass
        elif term.could_extract_minus_sign():
            tex += " - "
            term = -term
        else:
            tex += " + "
        term_tex = self._print(term)
        if self._needs_add_brackets(term):
            term_tex = r"\left(%s\right)" % term_tex
        tex += term_tex

    return tex

sympy.sympy.printing.latex._print_Cycle

def _print_Cycle(self, expr):
    from sympy.combinatorics.permutations import Permutation
    if expr.size == 0:
        return r"\left( \right)"
    expr = Permutation(expr)
    expr_perm = expr.cyclic_form
    siz = expr.size
    if expr.array_form[-1] == siz - 1:
        expr_perm = expr_perm + [[siz - 1]]
    term_tex = ''
    for i in expr_perm:
        term_tex += str(i).replace(',', r"\;")
    term_tex = term_tex.replace('[', r"\left( ")
    term_tex = term_tex.replace(']', r"\right)")
    return term_tex

sympy.sympy.printing.latex._print_Permutation

def _print_Permutation(self, expr):
    from sympy.combinatorics.permutations import Permutation
    from sympy.utilities.exceptions import sympy_deprecation_warning

    perm_cyclic = Permutation.print_cyclic
    if perm_cyclic is not None:
        sympy_deprecation_warning(
            f"""
            Setting Permutation.print_cyclic is deprecated. Instead use
            init_printing(perm_cyclic={perm_cyclic}).
            """,
            deprecated_since_version="1.6",
            active_deprecations_target="deprecated-permutation-print_cyclic",
            stacklevel=8,
        )
    else:
        perm_cyclic = self._settings.get("perm_cyclic", True)

    if perm_cyclic:
        return self._print_Cycle(expr)

    if expr.size == 0:
        return r"\left( \right)"

    lower = [self._print(arg) for arg in expr.array_form]
    upper = [self._print(arg) for arg in range(len(lower))]

    row1 = " & ".join(upper)
    row2 = " & ".join(lower)
    mat = r" \\ ".join((row1, row2))
    return r"\begin{pmatrix} %s \end{pmatrix}" % mat

sympy.sympy.printing.latex._print_AppliedPermutation

def _print_AppliedPermutation(self, expr):
    perm, var = expr.args
    return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))

sympy.sympy.printing.latex._print_Float

def _print_Float(self, expr):
    # Based off of that in StrPrinter
    dps = prec_to_dps(expr._prec)
    strip = False if self._settings['full_prec'] else True
    low = self._settings["min"] if "min" in self._settings else None
    high = self._settings["max"] if "max" in self._settings else None
    str_real = mlib_to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)

    # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
    # thus we use the number separator
    separator = self._settings['mul_symbol_latex_numbers']

    if 'e' in str_real:
        (mant, exp) = str_real.split('e')

        if exp[0] == '+':
            exp = exp[1:]
        if self._settings['decimal_separator'] == 'comma':
            mant = mant.replace('.','{,}')

        return r"%s%s10^{%s}" % (mant, separator, exp)
    elif str_real == "+inf":
        return r"\infty"
    elif str_real == "-inf":
        return r"- \infty"
    else:
        if self._settings['decimal_separator'] == 'comma':
            str_real = str_real.replace('.','{,}')
        return str_real

sympy.sympy.printing.latex._print_Cross

def _print_Cross(self, expr):
    vec1 = expr._expr1
    vec2 = expr._expr2
    return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
                              self.parenthesize(vec2, PRECEDENCE['Mul']))

sympy.sympy.printing.latex._print_Curl

def _print_Curl(self, expr):
    vec = expr._expr
    return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])

sympy.sympy.printing.latex._print_Divergence

def _print_Divergence(self, expr):
    vec = expr._expr
    return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])

sympy.sympy.printing.latex._print_Dot

def _print_Dot(self, expr):
    vec1 = expr._expr1
    vec2 = expr._expr2
    return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
                             self.parenthesize(vec2, PRECEDENCE['Mul']))

sympy.sympy.printing.latex._print_Gradient

def _print_Gradient(self, expr):
    func = expr._expr
    return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])

sympy.sympy.printing.latex._print_Laplacian

def _print_Laplacian(self, expr):
    func = expr._expr
    return r"\Delta %s" % self.parenthesize(func, PRECEDENCE['Mul'])

sympy.sympy.printing.latex._print_Mul

def _print_Mul(self, expr: Expr):
    from sympy.simplify import fraction
    separator: str = self._settings['mul_symbol_latex']
    numbersep: str = self._settings['mul_symbol_latex_numbers']

    def convert(expr) -> str:
        if not expr.is_Mul:
            return str(self._print(expr))
        else:
            if self.order not in ('old', 'none'):
                args = expr.as_ordered_factors()
            else:
                args = list(expr.args)

            # If there are quantities or prefixes, append them at the back.
            units, nonunits = sift(args, lambda x: (hasattr(x, "_scale_factor") or hasattr(x, "is_physical_constant")) or
                          (isinstance(x, Pow) and
                           hasattr(x.base, "is_physical_constant")), binary=True)
            prefixes, units = sift(units, lambda x: hasattr(x, "_scale_factor"), binary=True)
            return convert_args(nonunits + prefixes + units)

    def convert_args(args) -> str:
        _tex = last_term_tex = ""

        for i, term in enumerate(args):
            term_tex = self._print(term)
            if not (hasattr(term, "_scale_factor") or hasattr(term, "is_physical_constant")):
                if self._needs_mul_brackets(term, first=(i == 0),
                                            last=(i == len(args) - 1)):
                    term_tex = r"\left(%s\right)" % term_tex

                if  _between_two_numbers_p[0].search(last_term_tex) and \
                    _between_two_numbers_p[1].match(term_tex):
                    # between two numbers
                    _tex += numbersep
                elif _tex:
                    _tex += separator
            elif _tex:
                _tex += separator

            _tex += term_tex
            last_term_tex = term_tex
        return _tex

    # Check for unevaluated Mul. In this case we need to make sure the
    # identities are visible, multiple Rational factors are not combined
    # etc so we display in a straight-forward form that fully preserves all
    # args and their order.
    # XXX: _print_Pow calls this routine with instances of Pow...
    if isinstance(expr, Mul):
        args = expr.args
        if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
            return convert_args(args)

    include_parens = False
    if expr.could_extract_minus_sign():
        expr = -expr
        tex = "- "
        if expr.is_Add:
            tex += "("
            include_parens = True
    else:
        tex = ""

    numer, denom = fraction(expr, exact=True)

    if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
        # use the original expression here, since fraction() may have
        # altered it when producing numer and denom
        tex += convert(expr)

    else:
        snumer = convert(numer)
        sdenom = convert(denom)
        ldenom = len(sdenom.split())
        ratio = self._settings['long_frac_ratio']
        if self._settings['fold_short_frac'] and ldenom <= 2 and \
                "^" not in sdenom:
            # handle short fractions
            if self._needs_mul_brackets(numer, last=False):
                tex += r"\left(%s\right) / %s" % (snumer, sdenom)
            else:
                tex += r"%s / %s" % (snumer, sdenom)
        elif ratio is not None and \
                len(snumer.split()) > ratio*ldenom:
            # handle long fractions
            if self._needs_mul_brackets(numer, last=True):
                tex += r"\frac{1}{%s}%s\left(%s\right)" \
                    % (sdenom, separator, snumer)
            elif numer.is_Mul:
                # split a long numerator
                a = S.One
                b = S.One
                for x in numer.args:
                    if self._needs_mul_brackets(x, last=False) or \
                            len(convert(a*x).split()) > ratio*ldenom or \
                            (b.is_commutative is x.is_commutative is False):
                        b *= x
                    else:
                        a *= x
                if self._needs_mul_brackets(b, last=True):
                    tex += r"\frac{%s}{%s}%s\left(%s\right)" \
                        % (convert(a), sdenom, separator, convert(b))
                else:
                    tex += r"\frac{%s}{%s}%s%s" \
                        % (convert(a), sdenom, separator, convert(b))
            else:
                tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
        else:
            tex += r"\frac{%s}{%s}" % (snumer, sdenom)

    if include_parens:
        tex += ")"
    return tex

sympy.sympy.printing.latex._print_AlgebraicNumber

def _print_AlgebraicNumber(self, expr):
    if expr.is_aliased:
        return self._print(expr.as_poly().as_expr())
    else:
        return self._print(expr.as_expr())

sympy.sympy.printing.latex._print_PrimeIdeal

def _print_PrimeIdeal(self, expr):
    p = self._print(expr.p)
    if expr.is_inert:
        return rf'\left({p}\right)'
    alpha = self._print(expr.alpha.as_expr())
    return rf'\left({p}, {alpha}\right)'

sympy.sympy.printing.latex._print_Pow

def _print_Pow(self, expr: Pow):
    # Treat x**Rational(1,n) as special case
    if expr.exp.is_Rational:
        p: int = expr.exp.p  # type: ignore
        q: int = expr.exp.q  # type: ignore
        if abs(p) == 1 and q != 1 and self._settings['root_notation']:
            base = self._print(expr.base)
            if q == 2:
                tex = r"\sqrt{%s}" % base
            elif self._settings['itex']:
                tex = r"\root{%d}{%s}" % (q, base)
            else:
                tex = r"\sqrt[%d]{%s}" % (q, base)
            if expr.exp.is_negative:
                return r"\frac{1}{%s}" % tex
            else:
                return tex
        elif self._settings['fold_frac_powers'] and q != 1:
            base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
            # issue #12886: add parentheses for superscripts raised to powers
            if expr.base.is_Symbol:
                base = self.parenthesize_super(base)
            if expr.base.is_Function:
                return self._print(expr.base, exp="%s/%s" % (p, q))
            return r"%s^{%s/%s}" % (base, p, q)
        elif expr.exp.is_negative and expr.base.is_commutative:
            # special case for 1^(-x), issue 9216
            if expr.base == 1:
                return r"%s^{%s}" % (expr.base, expr.exp)
            # special case for (1/x)^(-y) and (-1/-x)^(-y), issue 20252
            if expr.base.is_Rational:
                base_p: int = expr.base.p  # type: ignore
                base_q: int = expr.base.q  # type: ignore
                if base_p * base_q == abs(base_q):
                    if expr.exp == -1:
                        return r"\frac{1}{\frac{%s}{%s}}" % (base_p, base_q)
                    else:
                        return r"\frac{1}{(\frac{%s}{%s})^{%s}}" % (base_p, base_q, abs(expr.exp))
            # things like 1/x
            return self._print_Mul(expr)
    if expr.base.is_Function:
        return self._print(expr.base, exp=self._print(expr.exp))
    tex = r"%s^{%s}"
    return self._helper_print_standard_power(expr, tex)

sympy.sympy.printing.latex._print_UnevaluatedExpr

def _print_UnevaluatedExpr(self, expr):
    return self._print(expr.args[0])

sympy.sympy.printing.latex._print_Sum

def _print_Sum(self, expr):
    if len(expr.limits) == 1:
        tex = r"\sum_{%s=%s}^{%s} " % \
            tuple([self._print(i) for i in expr.limits[0]])
    else:
        def _format_ineq(l):
            return r"%s \leq %s \leq %s" % \
                tuple([self._print(s) for s in (l[1], l[0], l[2])])

        tex = r"\sum_{\substack{%s}} " % \
            str.join('\\\\', [_format_ineq(l) for l in expr.limits])

    if isinstance(expr.function, Add):
        tex += r"\left(%s\right)" % self._print(expr.function)
    else:
        tex += self._print(expr.function)

    return tex

sympy.sympy.printing.latex._print_Product

def _print_Product(self, expr):
    if len(expr.limits) == 1:
        tex = r"\prod_{%s=%s}^{%s} " % \
            tuple([self._print(i) for i in expr.limits[0]])
    else:
        def _format_ineq(l):
            return r"%s \leq %s \leq %s" % \
                tuple([self._print(s) for s in (l[1], l[0], l[2])])

        tex = r"\prod_{\substack{%s}} " % \
            str.join('\\\\', [_format_ineq(l) for l in expr.limits])

    if isinstance(expr.function, Add):
        tex += r"\left(%s\right)" % self._print(expr.function)
    else:
        tex += self._print(expr.function)

    return tex

sympy.sympy.printing.latex._print_BasisDependent

def _print_BasisDependent(self, expr: 'BasisDependent'):
    from sympy.vector import Vector

    o1: list[str] = []
    if expr == expr.zero:
        return expr.zero._latex_form
    if isinstance(expr, Vector):
        items = expr.separate().items()
    else:
        items = [(0, expr)]

    for system, vect in items:
        inneritems = list(vect.components.items())
        inneritems.sort(key=lambda x: x[0].__str__())
        for k, v in inneritems:
            if v == 1:
                o1.append(' + ' + k._latex_form)
            elif v == -1:
                o1.append(' - ' + k._latex_form)
            else:
                arg_str = r'\left(' + self._print(v) + r'\right)'
                o1.append(' + ' + arg_str + k._latex_form)

    outstr = (''.join(o1))
    if outstr[1] != '-':
        outstr = outstr[3:]
    else:
        outstr = outstr[1:]
    return outstr

sympy.sympy.printing.latex._print_Indexed

def _print_Indexed(self, expr):
    tex_base = self._print(expr.base)
    tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
        map(self._print, expr.indices))
    return tex

sympy.sympy.printing.latex._print_IndexedBase

def _print_IndexedBase(self, expr):
    return self._print(expr.label)

sympy.sympy.printing.latex._print_Idx

def _print_Idx(self, expr):
    label = self._print(expr.label)
    if expr.upper is not None:
        upper = self._print(expr.upper)
        if expr.lower is not None:
            lower = self._print(expr.lower)
        else:
            lower = self._print(S.Zero)
        interval = '{lower}\\mathrel{{..}}\\nobreak {upper}'.format(
                lower = lower, upper = upper)
        return '{{{label}}}_{{{interval}}}'.format(
            label = label, interval = interval)
    #if no bounds are defined this just prints the label
    return label

sympy.sympy.printing.latex._print_Derivative

def _print_Derivative(self, expr):
    if requires_partial(expr.expr):
        diff_symbol = r'\partial'
    else:
        diff_symbol = self._settings["diff_operator_latex"]

    tex = ""
    dim = 0
    for x, num in reversed(expr.variable_count):
        dim += num
        if num == 1:
            tex += r"%s %s" % (diff_symbol, self._print(x))
        else:
            tex += r"%s %s^{%s}" % (diff_symbol,
                                    self.parenthesize_super(self._print(x)),
                                    self._print(num))

    if dim == 1:
        tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
    else:
        tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)

    precedence = PRECEDENCE["Mul"]
    if self._settings['mul_symbol']:
        # Nudge up the precedence so d/dx (f(x) * g(x)) also gets parenthesized
        precedence += 1
    if any(i.could_extract_minus_sign() for i in expr.args):
        return r"%s %s" % (tex, self.parenthesize(expr.expr,
                                              precedence,
                                              is_neg=True,
                                              strict=True))

    return r"%s %s" % (tex, self.parenthesize(expr.expr,
                                              precedence,
                                              is_neg=False,
                                              strict=True))

sympy.sympy.printing.latex._print_Subs

def _print_Subs(self, subs):
    expr, old, new = subs.args
    latex_expr = self._print(expr)
    latex_old = (self._print(e) for e in old)
    latex_new = (self._print(e) for e in new)
    latex_subs = r'\\ '.join(
        e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
    return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
                                                     latex_subs)

sympy.sympy.printing.latex.<genexpr>

latex_new = (self._print(e) for e in new)


sympy.sympy.printing.latex._print_Integral

def _print_Integral(self, expr):
    tex, symbols = "", []
    diff_symbol = self._settings["diff_operator_latex"]

    # Only up to \iiiint exists
    if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
        # Use len(expr.limits)-1 so that syntax highlighters don't think
        # \" is an escaped quote
        tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
        symbols = [r"\, %s%s" % (diff_symbol, self._print(symbol[0]))
                   for symbol in expr.limits]

    else:
        for lim in reversed(expr.limits):
            symbol = lim[0]
            tex += r"\int"

            if len(lim) > 1:
                if self._settings['mode'] != 'inline' \
                        and not self._settings['itex']:
                    tex += r"\limits"

                if len(lim) == 3:
                    tex += "_{%s}^{%s}" % (self._print(lim[1]),
                                           self._print(lim[2]))
                if len(lim) == 2:
                    tex += "^{%s}" % (self._print(lim[1]))

            symbols.insert(0, r"\, %s%s" % (diff_symbol, self._print(symbol)))

    return r"%s %s%s" % (tex, self.parenthesize(expr.function,
                                                PRECEDENCE["Mul"],
                                                is_neg=any(i.could_extract_minus_sign() for i in expr.args),
                                                strict=True),
                         "".join(symbols))

sympy.sympy.printing.latex._print_Limit

def _print_Limit(self, expr):
    e, z, z0, dir = expr.args

    tex = r"\lim_{%s \to " % self._print(z)
    if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
        tex += r"%s}" % self._print(z0)
    else:
        tex += r"%s^%s}" % (self._print(z0), self._print(dir))

    if isinstance(e, AssocOp):
        return r"%s\left(%s\right)" % (tex, self._print(e))
    else:
        return r"%s %s" % (tex, self._print(e))

sympy.sympy.printing.latex._print_Function

def _print_Function(self, expr: Function, exp=None) -> str:
    r'''
    Render functions to LaTeX, handling functions that LaTeX knows about
    e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
    For single-letter function names, render them as regular LaTeX math
    symbols. For multi-letter function names that LaTeX does not know
    about, (e.g., Li, sech) use \operatorname{} so that the function name
    is rendered in Roman font and LaTeX handles spacing properly.

    expr is the expression involving the function
    exp is an exponent
    '''
    func = expr.func.__name__
    if hasattr(self, '_print_' + func) and \
            not isinstance(expr, AppliedUndef):
        return getattr(self, '_print_' + func)(expr, exp)
    else:
        args = [str(self._print(arg)) for arg in expr.args]
        # How inverse trig functions should be displayed, formats are:
        # abbreviated: asin, full: arcsin, power: sin^-1
        inv_trig_style = self._settings['inv_trig_style']
        # If we are dealing with a power-style inverse trig function
        inv_trig_power_case = False
        # If it is applicable to fold the argument brackets
        can_fold_brackets = self._settings['fold_func_brackets'] and \
            len(args) == 1 and \
            not self._needs_function_brackets(expr.args[0])

        inv_trig_table = [
            "asin", "acos", "atan",
            "acsc", "asec", "acot",
            "asinh", "acosh", "atanh",
            "acsch", "asech", "acoth",
        ]

        # If the function is an inverse trig function, handle the style
        if func in inv_trig_table:
            if inv_trig_style == "abbreviated":
                pass
            elif inv_trig_style == "full":
                func = ("ar" if func[-1] == "h" else "arc") + func[1:]
            elif inv_trig_style == "power":
                func = func[1:]
                inv_trig_power_case = True

                # Can never fold brackets if we're raised to a power
                if exp is not None:
                    can_fold_brackets = False

        if inv_trig_power_case:
            if func in accepted_latex_functions:
                name = r"\%s^{-1}" % func
            else:
                name = r"\operatorname{%s}^{-1}" % func
        elif exp is not None:
            func_tex = self._hprint_Function(func)
            func_tex = self.parenthesize_super(func_tex)
            name = r'%s^{%s}' % (func_tex, exp)
        else:
            name = self._hprint_Function(func)

        if can_fold_brackets:
            if func in accepted_latex_functions:
                # Wrap argument safely to avoid parse-time conflicts
                # with the function name itself
                name += r" {%s}"
            else:
                name += r"%s"
        else:
            name += r"{\left(%s \right)}"

        if inv_trig_power_case and exp is not None:
            name += r"^{%s}" % exp

        return name % ",".join(args)

sympy.sympy.printing.maple._print_Tuple

def _print_Tuple(self, expr):
    return self._print(list(expr))

sympy.sympy.printing.maple._print_Assignment

def _print_Assignment(self, expr):
    lhs = self._print(expr.lhs)
    rhs = self._print(expr.rhs)
    return "{lhs} := {rhs}".format(lhs=lhs, rhs=rhs)

sympy.sympy.printing.maple._print_Pow

def _print_Pow(self, expr, **kwargs):
    PREC = precedence(expr)
    if equal_valued(expr.exp, -1):
        return '1/%s' % (self.parenthesize(expr.base, PREC))
    elif equal_valued(expr.exp, 0.5):
        return 'sqrt(%s)' % self._print(expr.base)
    elif equal_valued(expr.exp, -0.5):
        return '1/sqrt(%s)' % self._print(expr.base)
    else:
        return '{base}^{exp}'.format(
            base=self.parenthesize(expr.base, PREC),
            exp=self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.maple._print_Piecewise

def _print_Piecewise(self, expr):
    if (expr.args[-1].cond is not True) and (expr.args[-1].cond != S.BooleanTrue):
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    _coup_list = [
        ("{c}, {e}".format(c=self._print(c),
                           e=self._print(e)) if c is not True and c is not S.BooleanTrue else "{e}".format(
            e=self._print(e)))
        for e, c in expr.args]
    _inbrace = ', '.join(_coup_list)
    return 'piecewise({_inbrace})'.format(_inbrace=_inbrace)

sympy.sympy.printing.maple._print_Rational

def _print_Rational(self, expr):
    p, q = int(expr.p), int(expr.q)
    return "{p}/{q}".format(p=str(p), q=str(q))

sympy.sympy.printing.maple._print_Relational

def _print_Relational(self, expr):
    PREC=precedence(expr)
    lhs_code = self.parenthesize(expr.lhs, PREC)
    rhs_code = self.parenthesize(expr.rhs, PREC)
    op = expr.rel_op
    if op in spec_relational_ops:
        op = spec_relational_ops[op]
    return "{lhs} {rel_op} {rhs}".format(lhs=lhs_code, rel_op=op, rhs=rhs_code)

sympy.sympy.printing.maple._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-infinity'

sympy.sympy.printing.maple._print_Infinity

def _print_Infinity(self, expr):
    return 'infinity'

sympy.sympy.printing.maple._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return "true"

sympy.sympy.printing.maple._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return "false"

sympy.sympy.printing.maple._print_NaN

def _print_NaN(self, expr):
    return 'undefined'

sympy.sympy.printing.maple._print_MatrixElement

def _print_MatrixElement(self, expr):
    return "{parent}[{i_maple}, {j_maple}]".format(
        parent=self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True),
        i_maple=self._print(expr.i + 1),
        j_maple=self._print(expr.j + 1))

sympy.sympy.printing.maple._print_MatrixBase

def _print_MatrixBase(self, expr):
    return self._get_matrix(expr, sparse=False)

sympy.sympy.printing.maple._print_SparseRepMatrix

def _print_SparseRepMatrix(self, expr):
    return self._get_matrix(expr, sparse=True)

sympy.sympy.printing.maple._print_Identity

def _print_Identity(self, expr):
    if isinstance(expr.rows, (Integer, IntegerConstant)):
        return self._print(sympy.SparseMatrix(expr))
    else:
        return "Matrix({var_size}, shape = identity)".format(var_size=self._print(expr.rows))

sympy.sympy.printing.maple._print_MatMul

def _print_MatMul(self, expr):
    PREC=precedence(expr)
    _fact_list = list(expr.args)
    _const = None
    if not isinstance(_fact_list[0], (sympy.MatrixBase, sympy.MatrixExpr,
                                      sympy.MatrixSlice, sympy.MatrixSymbol)):
        _const, _fact_list = _fact_list[0], _fact_list[1:]

    if _const is None or _const == 1:
        return '.'.join(self.parenthesize(_m, PREC) for _m in _fact_list)
    else:
        return '{c}*{m}'.format(c=_const, m='.'.join(self.parenthesize(_m, PREC) for _m in _fact_list))

sympy.sympy.printing.maple._print_MatPow

def _print_MatPow(self, expr):
    # This function requires LinearAlgebra Function in Maple
    return 'MatrixPower({A}, {n})'.format(A=self._print(expr.base), n=self._print(expr.exp))

sympy.sympy.printing.maple._print_HadamardProduct

def _print_HadamardProduct(self, expr):
    PREC = precedence(expr)
    _fact_list = list(expr.args)
    return '*'.join(self.parenthesize(_m, PREC) for _m in _fact_list)

sympy.sympy.printing.maple._print_Derivative

def _print_Derivative(self, expr):
    _f, (_var, _order) = expr.args

    if _order != 1:
        _second_arg = '{var}${order}'.format(var=self._print(_var),
                                             order=self._print(_order))
    else:
        _second_arg = '{var}'.format(var=self._print(_var))
    return 'diff({func_expr}, {sec_arg})'.format(func_expr=self._print(_f), sec_arg=_second_arg)

sympy.sympy.printing.mathematica._print_Pow

def _print_Pow(self, expr):
    PREC = precedence(expr)
    return '%s^%s' % (self.parenthesize(expr.base, PREC),
                      self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.mathematica._print_Mul

def _print_Mul(self, expr):
    PREC = precedence(expr)
    c, nc = expr.args_cnc()
    res = super()._print_Mul(expr.func(*c))
    if nc:
        res += '*'
        res += '**'.join(self.parenthesize(a, PREC) for a in nc)
    return res

sympy.sympy.printing.mathematica._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.mathematica._print_Zero

def _print_Zero(self, expr):
    return '0'

sympy.sympy.printing.mathematica._print_One

def _print_One(self, expr):
    return '1'

sympy.sympy.printing.mathematica._print_NegativeOne

def _print_NegativeOne(self, expr):
    return '-1'

sympy.sympy.printing.mathematica._print_Half

def _print_Half(self, expr):
    return '1/2'

sympy.sympy.printing.mathematica._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return 'I'

sympy.sympy.printing.mathematica._print_Infinity

def _print_Infinity(self, expr):
    return 'Infinity'

sympy.sympy.printing.mathematica._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-Infinity'

sympy.sympy.printing.mathematica._print_ComplexInfinity

def _print_ComplexInfinity(self, expr):
    return 'ComplexInfinity'

sympy.sympy.printing.mathematica._print_NaN

def _print_NaN(self, expr):
    return 'Indeterminate'

sympy.sympy.printing.mathematica._print_Exp1

def _print_Exp1(self, expr):
    return 'E'

sympy.sympy.printing.mathematica._print_Pi

def _print_Pi(self, expr):
    return 'Pi'

sympy.sympy.printing.mathematica._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    return 'GoldenRatio'

sympy.sympy.printing.mathematica._print_TribonacciConstant

def _print_TribonacciConstant(self, expr):
    expanded = expr.expand(func=True)
    PREC = precedence(expr)
    return self.parenthesize(expanded, PREC)

sympy.sympy.printing.mathematica._print_EulerGamma

def _print_EulerGamma(self, expr):
    return 'EulerGamma'

sympy.sympy.printing.mathematica._print_Catalan

def _print_Catalan(self, expr):
    return 'Catalan'

sympy.sympy.printing.mathematica._print_list

def _print_list(self, expr):
    return '{' + ', '.join(self.doprint(a) for a in expr) + '}'

sympy.sympy.printing.mathematica._print_ImmutableDenseMatrix

def _print_ImmutableDenseMatrix(self, expr):
    return self.doprint(expr.tolist())

sympy.sympy.printing.mathematica._print_ImmutableSparseMatrix

def _print_ImmutableSparseMatrix(self, expr):

    def print_rule(pos, val):
        return '{} -> {}'.format(
        self.doprint((pos[0]+1, pos[1]+1)), self.doprint(val))

    def print_data():
        items = sorted(expr.todok().items(), key=default_sort_key)
        return '{' + \
            ', '.join(print_rule(k, v) for k, v in items) + \
            '}'

    def print_dims():
        return self.doprint(expr.shape)

    return 'SparseArray[{}, {}]'.format(print_data(), print_dims())

sympy.sympy.printing.mathematica._print_ImmutableDenseNDimArray

def _print_ImmutableDenseNDimArray(self, expr):
    return self.doprint(expr.tolist())

sympy.sympy.printing.mathematica._print_ImmutableSparseNDimArray

def _print_ImmutableSparseNDimArray(self, expr):
    def print_string_list(string_list):
        return '{' + ', '.join(a for a in string_list) + '}'

    def to_mathematica_index(*args):
        """Helper function to change Python style indexing to
        Pathematica indexing.

        Python indexing (0, 1 ... n-1)
        -> Mathematica indexing (1, 2 ... n)
        """
        return tuple(i + 1 for i in args)

    def print_rule(pos, val):
        """Helper function to print a rule of Mathematica"""
        return '{} -> {}'.format(self.doprint(pos), self.doprint(val))

    def print_data():
        """Helper function to print data part of Mathematica
        sparse array.

        It uses the fourth notation ``SparseArray[data,{d1,d2,...}]``
        from
        https://reference.wolfram.com/language/ref/SparseArray.html

        ``data`` must be formatted with rule.
        """
        return print_string_list(
            [print_rule(
                to_mathematica_index(*(expr._get_tuple_index(key))),
                value)
            for key, value in sorted(expr._sparse_array.items())]
        )

    def print_dims():
        """Helper function to print dimensions part of Mathematica
        sparse array.

        It uses the fourth notation ``SparseArray[data,{d1,d2,...}]``
        from
        https://reference.wolfram.com/language/ref/SparseArray.html
        """
        return self.doprint(expr.shape)

    return 'SparseArray[{}, {}]'.format(print_data(), print_dims())

sympy.sympy.printing.mathematica._print_Function

def _print_Function(self, expr):
    if expr.func.__name__ in self.known_functions:
        cond_mfunc = self.known_functions[expr.func.__name__]
        for cond, mfunc in cond_mfunc:
            if cond(*expr.args):
                return "%s[%s]" % (mfunc, self.stringify(expr.args, ", "))
    elif expr.func.__name__ in self._rewriteable_functions:
        # Simple rewrite to supported function possible
        target_f, required_fs = self._rewriteable_functions[expr.func.__name__]
        if self._can_print(target_f) and all(self._can_print(f) for f in required_fs):
            return self._print(expr.rewrite(target_f))
    return expr.func.__name__ + "[%s]" % self.stringify(expr.args, ", ")

sympy.sympy.printing.mathematica._print_LambertW

def _print_LambertW(self, expr):
    if len(expr.args) == 1:
        return "ProductLog[{}]".format(self._print(expr.args[0]))
    return "ProductLog[{}, {}]".format(
        self._print(expr.args[1]), self._print(expr.args[0]))

sympy.sympy.printing.mathematica._print_atan2

def _print_atan2(self, expr):
    return "ArcTan[{}, {}]".format(
        self._print(expr.args[1]), self._print(expr.args[0]))

sympy.sympy.printing.mathematica._print_Integral

def _print_Integral(self, expr):
    if len(expr.variables) == 1 and not expr.limits[0][1:]:
        args = [expr.args[0], expr.variables[0]]
    else:
        args = expr.args
    return "Hold[Integrate[" + ', '.join(self.doprint(a) for a in args) + "]]"

sympy.sympy.printing.mathematica._print_Sum

def _print_Sum(self, expr):
    return "Hold[Sum[" + ', '.join(self.doprint(a) for a in expr.args) + "]]"

sympy.sympy.printing.mathematica._print_Derivative

def _print_Derivative(self, expr):
    dexpr = expr.expr
    dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
    return "Hold[D[" + ', '.join(self.doprint(a) for a in [dexpr] + dvars) + "]]"

sympy.sympy.printing.mathml._print_MatrixSymbol

def _print_MatrixSymbol(self, sym):
    return self._print_Symbol(sym,
                              style=self._settings['mat_symbol_style'])

sympy.sympy.printing.mathml._print_conjugate

def _print_conjugate(self, expr):
    enc = self.dom.createElement('menclose')
    enc.setAttribute('notation', 'top')
    enc.appendChild(self._print(expr.args[0]))
    return enc

sympy.sympy.printing.mathml._print_factorial

def _print_factorial(self, expr):
    return self._print_operator_after('!', expr.args[0])

sympy.sympy.printing.mathml._print_factorial2

def _print_factorial2(self, expr):
    return self._print_operator_after('!!', expr.args[0])

sympy.sympy.printing.mathml._print_binomial

def _print_binomial(self, expr):
    frac = self.dom.createElement('mfrac')
    frac.setAttribute('linethickness', '0')
    frac.appendChild(self._print(expr.args[0]))
    frac.appendChild(self._print(expr.args[1]))
    brac = self.dom.createElement('mrow')
    brac.appendChild(self._l_paren())
    brac.appendChild(frac)
    brac.appendChild(self._r_paren())
    return brac

sympy.sympy.printing.mathml._print_Pow

def _print_Pow(self, e):
    # Here we use root instead of power if the exponent is the reciprocal
    # of an integer
    if (self._settings['root_notation'] and e.exp.is_Rational
            and e.exp.p == 1):
        x = self.dom.createElement('apply')
        x.appendChild(self.dom.createElement('root'))
        if e.exp.q != 2:
            xmldeg = self.dom.createElement('degree')
            xmlcn = self.dom.createElement('cn')
            xmlcn.appendChild(self.dom.createTextNode(str(e.exp.q)))
            xmldeg.appendChild(xmlcn)
            x.appendChild(xmldeg)
        x.appendChild(self._print(e.base))
        return x

    x = self.dom.createElement('apply')
    x_1 = self.dom.createElement(self.mathml_tag(e))
    x.appendChild(x_1)
    x.appendChild(self._print(e.base))
    x.appendChild(self._print(e.exp))
    return x

sympy.sympy.printing.mathml._print_AccumulationBounds

def _print_AccumulationBounds(self, i):
    left = self.dom.createElement('mo')
    left.appendChild(self.dom.createTextNode('\u27e8'))
    right = self.dom.createElement('mo')
    right.appendChild(self.dom.createTextNode('\u27e9'))
    brac = self.dom.createElement('mrow')
    brac.appendChild(left)
    brac.appendChild(self._print(i.min))
    brac.appendChild(self._comma())
    brac.appendChild(self._print(i.max))
    brac.appendChild(right)
    return brac

sympy.sympy.printing.mathml._print_Derivative

def _print_Derivative(self, e):
    x = self.dom.createElement('apply')
    diff_symbol = self.mathml_tag(e)
    if requires_partial(e.expr):
        diff_symbol = 'partialdiff'
    x.appendChild(self.dom.createElement(diff_symbol))
    x_1 = self.dom.createElement('bvar')

    for sym, times in reversed(e.variable_count):
        x_1.appendChild(self._print(sym))
        if times > 1:
            degree = self.dom.createElement('degree')
            degree.appendChild(self._print(sympify(times)))
            x_1.appendChild(degree)

    x.appendChild(x_1)
    x.appendChild(self._print(e.expr))
    return x

sympy.sympy.printing.mathml._print_Function

def _print_Function(self, e):
    x = self.dom.createElement("apply")
    x.appendChild(self.dom.createElement(self.mathml_tag(e)))
    for arg in e.args:
        x.appendChild(self._print(arg))
    return x

sympy.sympy.printing.mathml._print_Float

def _print_Float(self, e):
    x = self.dom.createElement(self.mathml_tag(e))
    repr_e = mlib_to_str(e._mpf_, repr_dps(e._prec))
    x.appendChild(self.dom.createTextNode(repr_e))
    return x

sympy.sympy.printing.mathml._print_polylog

def _print_polylog(self, expr):
    mrow = self.dom.createElement('mrow')
    m = self.dom.createElement('msub')

    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode('Li'))
    m.appendChild(mi)
    m.appendChild(self._print(expr.args[0]))
    mrow.appendChild(m)
    brac = self.dom.createElement('mrow')
    brac.appendChild(self._l_paren())
    brac.appendChild(self._print(expr.args[1]))
    brac.appendChild(self._r_paren())
    mrow.appendChild(brac)
    return mrow

sympy.sympy.printing.mathml._print_Basic

def _print_Basic(self, e):
    x = self.dom.createElement(self.mathml_tag(e))
    for arg in e.args:
        x.appendChild(self._print(arg))
    return x

sympy.sympy.printing.mathml._print_Tuple

def _print_Tuple(self, e):
    return self._paren_comma_separated(*e.args)

sympy.sympy.printing.mathml._print_Interval

def _print_Interval(self, i):
    right = self.dom.createElement('mo')
    if i.right_open:
        right.appendChild(self.dom.createTextNode(')'))
    else:
        right.appendChild(self.dom.createTextNode(']'))
    left = self.dom.createElement('mo')
    if i.left_open:
        left.appendChild(self.dom.createTextNode('('))
    else:
        left.appendChild(self.dom.createTextNode('['))
    mrow = self.dom.createElement('mrow')
    mrow.appendChild(left)
    mrow.appendChild(self._print(i.start))
    mrow.appendChild(self._comma())
    mrow.appendChild(self._print(i.end))
    mrow.appendChild(right)
    return mrow

sympy.sympy.printing.mathml._print_Abs

def _print_Abs(self, expr, exp=None):
    mrow = self.dom.createElement('mrow')
    mrow.appendChild(self._bar())
    mrow.appendChild(self._print(expr.args[0]))
    mrow.appendChild(self._bar())
    return mrow

sympy.sympy.printing.mathml._print_re

def _print_re(self, expr, exp=None):
    return self._print_re_im('\u211C', expr.args[0])

sympy.sympy.printing.mathml._print_im

def _print_im(self, expr, exp=None):
    return self._print_re_im('\u2111', expr.args[0])

sympy.sympy.printing.mathml._print_AssocOp

def _print_AssocOp(self, e):
    x = self.dom.createElement('apply')
    x_1 = self.dom.createElement(self.mathml_tag(e))
    x.appendChild(x_1)
    for arg in e.args:
        x.appendChild(self._print(arg))
    return x

sympy.sympy.printing.mathml._print_Union

def _print_Union(self, expr):
    prec = PRECEDENCE_TRADITIONAL['Union']
    return self._print_SetOp(expr, '&#x222A;', prec)

sympy.sympy.printing.mathml._print_Intersection

def _print_Intersection(self, expr):
    prec = PRECEDENCE_TRADITIONAL['Intersection']
    return self._print_SetOp(expr, '&#x2229;', prec)

sympy.sympy.printing.mathml._print_Complement

def _print_Complement(self, e):
    x = self.dom.createElement('apply')
    x.appendChild(self.dom.createElement('setdiff'))
    for arg in e.args:
        x.appendChild(self._print(arg))
    return x

sympy.sympy.printing.mathml._print_SymmetricDifference

def _print_SymmetricDifference(self, expr):
    prec = PRECEDENCE_TRADITIONAL['SymmetricDifference']
    return self._print_SetOp(expr, '&#x2206;', prec)

sympy.sympy.printing.mathml._print_ProductSet

def _print_ProductSet(self, e):
    x = self.dom.createElement('apply')
    x.appendChild(self.dom.createElement('cartesianproduct'))
    for arg in e.args:
        x.appendChild(self._print(arg))
    return x

sympy.sympy.printing.mathml._print_FiniteSet

def _print_FiniteSet(self, e):
    x = self.dom.createElement('set')
    for arg in e.args:
        x.appendChild(self._print(arg))
    return x

sympy.sympy.printing.mathml._print_set

def _print_set(self, s):
    items = sorted(s, key=default_sort_key)
    brac = self.dom.createElement('mrow')
    brac.appendChild(self._l_brace())
    for i, item in enumerate(items):
        if i:
            brac.appendChild(self._comma())
        brac.appendChild(self._print(item))
    brac.appendChild(self._r_brace())
    return brac

sympy.sympy.printing.mathml._print_BasisDependent

def _print_BasisDependent(self, expr):
    from sympy.vector import Vector

    if expr == expr.zero:
        # Not clear if this is ever called
        return self._print(expr.zero)
    if isinstance(expr, Vector):
        items = expr.separate().items()
    else:
        items = [(0, expr)]

    mrow = self.dom.createElement('mrow')
    for system, vect in items:
        inneritems = list(vect.components.items())
        inneritems.sort(key = lambda x:x[0].__str__())
        for i, (k, v) in enumerate(inneritems):
            if v == 1:
                if i: # No + for first item
                    mo = self.dom.createElement('mo')
                    mo.appendChild(self.dom.createTextNode('+'))
                    mrow.appendChild(mo)
                mrow.appendChild(self._print(k))
            elif v == -1:
                mo = self.dom.createElement('mo')
                mo.appendChild(self.dom.createTextNode('-'))
                mrow.appendChild(mo)
                mrow.appendChild(self._print(k))
            else:
                if i: # No + for first item
                    mo = self.dom.createElement('mo')
                    mo.appendChild(self.dom.createTextNode('+'))
                    mrow.appendChild(mo)
                mbrac = self.dom.createElement('mrow')
                mbrac.appendChild(self._l_paren())
                mbrac.appendChild(self._print(v))
                mbrac.appendChild(self._r_paren())
                mrow.appendChild(mbrac)
                mo = self.dom.createElement('mo')
                mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))
                mrow.appendChild(mo)
                mrow.appendChild(self._print(k))
    return mrow

sympy.sympy.printing.mathml._print_And

def _print_And(self, expr):
    args = sorted(expr.args, key=default_sort_key)
    return self._print_LogOp(args, '&#x2227;')

sympy.sympy.printing.mathml._print_Or

def _print_Or(self, expr):
    args = sorted(expr.args, key=default_sort_key)
    return self._print_LogOp(args, '&#x2228;')

sympy.sympy.printing.mathml._print_Xor

def _print_Xor(self, expr):
    args = sorted(expr.args, key=default_sort_key)
    return self._print_LogOp(args, '&#x22BB;')

sympy.sympy.printing.mathml._print_Implies

def _print_Implies(self, expr):
    return self._print_LogOp(expr.args, '&#x21D2;')

sympy.sympy.printing.mathml._print_Equivalent

def _print_Equivalent(self, expr):
    args = sorted(expr.args, key=default_sort_key)
    return self._print_LogOp(args, '&#x21D4;')

sympy.sympy.printing.mathml._print_Not

def _print_Not(self, e):
    mrow = self.dom.createElement('mrow')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#xAC;'))
    mrow.appendChild(mo)
    if (e.args[0].is_Boolean):
        x = self.dom.createElement('mrow')
        x.appendChild(self._l_paren())
        x.appendChild(self._print(e.args[0]))
        x.appendChild(self._r_paren())
    else:
        x = self._print(e.args[0])
    mrow.appendChild(x)
    return mrow

sympy.sympy.printing.mathml._print_bool

def _print_bool(self, e):
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
    return mi

sympy.sympy.printing.mathml._print_NoneType

def _print_NoneType(self, e):
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
    return mi

sympy.sympy.printing.mathml._print_Range

def _print_Range(self, s):
    dots = "\u2026"
    if s.start.is_infinite and s.stop.is_infinite:
        if s.step.is_positive:
            printset = dots, -1, 0, 1, dots
        else:
            printset = dots, 1, 0, -1, dots
    elif s.start.is_infinite:
        printset = dots, s[-1] - s.step, s[-1]
    elif s.stop.is_infinite:
        it = iter(s)
        printset = next(it), next(it), dots
    elif len(s) > 4:
        it = iter(s)
        printset = next(it), next(it), dots, s[-1]
    else:
        printset = tuple(s)
    brac = self.dom.createElement('mrow')
    brac.appendChild(self._l_brace())
    for i, el in enumerate(printset):
        if i:
            brac.appendChild(self._comma())
        if el == dots:
            mi = self.dom.createElement('mi')
            mi.appendChild(self.dom.createTextNode(dots))
            brac.appendChild(mi)
        else:
            brac.appendChild(self._print(el))
    brac.appendChild(self._r_brace())
    return brac

sympy.sympy.printing.mathml._hprint_variadic_function

def _hprint_variadic_function(self, expr):
    args = sorted(expr.args, key=default_sort_key)
    mrow = self.dom.createElement('mrow')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode((str(expr.func)).lower()))
    mrow.appendChild(mo)
    mrow.appendChild(self._paren_comma_separated(*args))
    return mrow

sympy.sympy.printing.mathml._print_exp

def _print_exp(self, expr):
    msup = self.dom.createElement('msup')
    msup.appendChild(self._print_Exp1(None))
    msup.appendChild(self._print(expr.args[0]))
    return msup

sympy.sympy.printing.mathml._print_Relational

def _print_Relational(self, e):
    x = self.dom.createElement('apply')
    x.appendChild(self.dom.createElement(self.mathml_tag(e)))
    x.appendChild(self._print(e.lhs))
    x.appendChild(self._print(e.rhs))
    return x

sympy.sympy.printing.mathml._print_int

def _print_int(self, p):
    dom_element = self.dom.createElement(self.mathml_tag(p))
    dom_element.appendChild(self.dom.createTextNode(str(p)))
    return dom_element

sympy.sympy.printing.mathml._print_BaseScalar

def _print_BaseScalar(self, e):
    msub = self.dom.createElement('msub')
    index, system = e._id
    mi = self.dom.createElement('mi')
    mi.setAttribute('mathvariant', 'bold')
    mi.appendChild(self.dom.createTextNode(system._variable_names[index]))
    msub.appendChild(mi)
    mi = self.dom.createElement('mi')
    mi.setAttribute('mathvariant', 'bold')
    mi.appendChild(self.dom.createTextNode(system._name))
    msub.appendChild(mi)
    return msub

sympy.sympy.printing.mathml._print_BaseVector

def _print_BaseVector(self, e):
    msub = self.dom.createElement('msub')
    index, system = e._id
    mover = self.dom.createElement('mover')
    mi = self.dom.createElement('mi')
    mi.setAttribute('mathvariant', 'bold')
    mi.appendChild(self.dom.createTextNode(system._vector_names[index]))
    mover.appendChild(mi)
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('^'))
    mover.appendChild(mo)
    msub.appendChild(mover)
    mi = self.dom.createElement('mi')
    mi.setAttribute('mathvariant', 'bold')
    mi.appendChild(self.dom.createTextNode(system._name))
    msub.appendChild(mi)
    return msub

sympy.sympy.printing.mathml._print_Mul

def _print_Mul(self, expr):

    def multiply(expr, mrow):
        from sympy.simplify import fraction
        numer, denom = fraction(expr)
        if denom is not S.One:
            frac = self.dom.createElement('mfrac')
            if self._settings["fold_short_frac"] and len(str(expr)) < 7:
                frac.setAttribute('bevelled', 'true')
            xnum = self._print(numer)
            xden = self._print(denom)
            frac.appendChild(xnum)
            frac.appendChild(xden)
            mrow.appendChild(frac)
            return mrow

        coeff, terms = expr.as_coeff_mul()
        if coeff is S.One and len(terms) == 1:
            mrow.appendChild(self._print(terms[0]))
            return mrow
        if self.order != 'old':
            terms = Mul._from_args(terms).as_ordered_factors()

        if coeff != 1:
            x = self._print(coeff)
            y = self.dom.createElement('mo')
            y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))
            mrow.appendChild(x)
            mrow.appendChild(y)
        for term in terms:
            mrow.appendChild(self.parenthesize(term, PRECEDENCE['Mul']))
            if not term == terms[-1]:
                y = self.dom.createElement('mo')
                y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))
                mrow.appendChild(y)
        return mrow
    mrow = self.dom.createElement('mrow')
    if expr.could_extract_minus_sign():
        x = self.dom.createElement('mo')
        x.appendChild(self.dom.createTextNode('-'))
        mrow.appendChild(x)
        mrow = multiply(-expr, mrow)
    else:
        mrow = multiply(expr, mrow)

    return mrow

sympy.sympy.printing.mathml._print_Cross

def _print_Cross(self, expr):
    mrow = self.dom.createElement('mrow')
    vec1 = expr._expr1
    vec2 = expr._expr2
    mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#xD7;'))
    mrow.appendChild(mo)
    mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))
    return mrow

sympy.sympy.printing.mathml._print_Curl

def _print_Curl(self, expr):
    mrow = self.dom.createElement('mrow')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x2207;'))
    mrow.appendChild(mo)
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#xD7;'))
    mrow.appendChild(mo)
    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
    return mrow

sympy.sympy.printing.mathml._print_Divergence

def _print_Divergence(self, expr):
    mrow = self.dom.createElement('mrow')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x2207;'))
    mrow.appendChild(mo)
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#xB7;'))
    mrow.appendChild(mo)
    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
    return mrow

sympy.sympy.printing.mathml._print_Dot

def _print_Dot(self, expr):
    mrow = self.dom.createElement('mrow')
    vec1 = expr._expr1
    vec2 = expr._expr2
    mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#xB7;'))
    mrow.appendChild(mo)
    mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))
    return mrow

sympy.sympy.printing.mathml._print_Gradient

def _print_Gradient(self, expr):
    mrow = self.dom.createElement('mrow')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x2207;'))
    mrow.appendChild(mo)
    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
    return mrow

sympy.sympy.printing.mathml._print_Laplacian

def _print_Laplacian(self, expr):
    mrow = self.dom.createElement('mrow')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x2206;'))
    mrow.appendChild(mo)
    mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
    return mrow

sympy.sympy.printing.mathml._print_Integers

def _print_Integers(self, e):
    x = self.dom.createElement('mi')
    x.setAttribute('mathvariant', 'normal')
    x.appendChild(self.dom.createTextNode('&#x2124;'))
    return x

sympy.sympy.printing.mathml._print_Complexes

def _print_Complexes(self, e):
    x = self.dom.createElement('mi')
    x.setAttribute('mathvariant', 'normal')
    x.appendChild(self.dom.createTextNode('&#x2102;'))
    return x

sympy.sympy.printing.mathml._print_Reals

def _print_Reals(self, e):
    x = self.dom.createElement('mi')
    x.setAttribute('mathvariant', 'normal')
    x.appendChild(self.dom.createTextNode('&#x211D;'))
    return x

sympy.sympy.printing.mathml._print_Naturals

def _print_Naturals(self, e):
    x = self.dom.createElement('mi')
    x.setAttribute('mathvariant', 'normal')
    x.appendChild(self.dom.createTextNode('&#x2115;'))
    return x

sympy.sympy.printing.mathml._print_Naturals0

def _print_Naturals0(self, e):
    sub = self.dom.createElement('msub')
    x = self.dom.createElement('mi')
    x.setAttribute('mathvariant', 'normal')
    x.appendChild(self.dom.createTextNode('&#x2115;'))
    sub.appendChild(x)
    sub.appendChild(self._print(S.Zero))
    return sub

sympy.sympy.printing.mathml._print_SingularityFunction

def _print_SingularityFunction(self, expr):
    shift = expr.args[0] - expr.args[1]
    power = expr.args[2]
    left = self.dom.createElement('mo')
    left.appendChild(self.dom.createTextNode('\u27e8'))
    right = self.dom.createElement('mo')
    right.appendChild(self.dom.createTextNode('\u27e9'))
    brac = self.dom.createElement('mrow')
    brac.appendChild(left)
    brac.appendChild(self._print(shift))
    brac.appendChild(right)
    sup = self.dom.createElement('msup')
    sup.appendChild(brac)
    sup.appendChild(self._print(power))
    return sup

sympy.sympy.printing.mathml._print_NaN

def _print_NaN(self, e):
    return self.dom.createElement('notanumber')

sympy.sympy.printing.mathml._print_bernoulli

def _print_bernoulli(self, e):
    return self._print_number_function(e, 'B')

sympy.sympy.printing.mathml._print_catalan

def _print_catalan(self, e):
    return self._print_number_function(e, 'C')

sympy.sympy.printing.mathml._print_euler

def _print_euler(self, e):
    return self._print_number_function(e, 'E')

sympy.sympy.printing.mathml._print_fibonacci

def _print_fibonacci(self, e):
    return self._print_number_function(e, 'F')

sympy.sympy.printing.mathml._print_lucas

def _print_lucas(self, e):
    return self._print_number_function(e, 'L')

sympy.sympy.printing.mathml._print_stieltjes

def _print_stieltjes(self, e):
    return self._print_number_function(e, '&#x03B3;')

sympy.sympy.printing.mathml._print_tribonacci

def _print_tribonacci(self, e):
    return self._print_number_function(e, 'T')

sympy.sympy.printing.mathml._print_ComplexInfinity

def _print_ComplexInfinity(self, e):
    x = self.dom.createElement('mover')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x221E;'))
    x.appendChild(mo)
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('~'))
    x.appendChild(mo)
    return x

sympy.sympy.printing.mathml._print_EmptySet

def _print_EmptySet(self, e):
    return self.dom.createElement('emptyset')

sympy.sympy.printing.mathml._print_UniversalSet

def _print_UniversalSet(self, e):
    x = self.dom.createElement('mo')
    x.appendChild(self.dom.createTextNode('&#x1D54C;'))
    return x

sympy.sympy.printing.mathml._print_Adjoint

def _print_Adjoint(self, expr):
    from sympy.matrices import MatrixSymbol
    mat = expr.arg
    sup = self.dom.createElement('msup')
    if not isinstance(mat, MatrixSymbol):
        brac = self.dom.createElement('mrow')
        brac.appendChild(self._l_paren())
        brac.appendChild(self._print(mat))
        brac.appendChild(self._r_paren())
        sup.appendChild(brac)
    else:
        sup.appendChild(self._print(mat))
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x2020;'))
    sup.appendChild(mo)
    return sup

sympy.sympy.printing.mathml._print_Transpose

def _print_Transpose(self, expr):
    from sympy.matrices import MatrixSymbol
    mat = expr.arg
    sup = self.dom.createElement('msup')
    if not isinstance(mat, MatrixSymbol):
        brac = self.dom.createElement('mrow')
        brac.appendChild(self._l_paren())
        brac.appendChild(self._print(mat))
        brac.appendChild(self._r_paren())
        sup.appendChild(brac)
    else:
        sup.appendChild(self._print(mat))
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('T'))
    sup.appendChild(mo)
    return sup

sympy.sympy.printing.mathml._print_Inverse

def _print_Inverse(self, expr):
    from sympy.matrices import MatrixSymbol
    mat = expr.arg
    sup = self.dom.createElement('msup')
    if not isinstance(mat, MatrixSymbol):
        brac = self.dom.createElement('mrow')
        brac.appendChild(self._l_paren())
        brac.appendChild(self._print(mat))
        brac.appendChild(self._r_paren())
        sup.appendChild(brac)
    else:
        sup.appendChild(self._print(mat))
    sup.appendChild(self._print(-1))
    return sup

sympy.sympy.printing.mathml._print_MatMul

def _print_MatMul(self, expr):
    from sympy.matrices.expressions.matmul import MatMul

    x = self.dom.createElement('mrow')
    args = expr.args
    if isinstance(args[0], Mul):
        args = args[0].as_ordered_factors() + list(args[1:])
    else:
        args = list(args)

    if isinstance(expr, MatMul) and expr.could_extract_minus_sign():
        if args[0] == -1:
            args = args[1:]
        else:
            args[0] = -args[0]
        mo = self.dom.createElement('mo')
        mo.appendChild(self.dom.createTextNode('-'))
        x.appendChild(mo)

    for arg in args[:-1]:
        x.appendChild(self.parenthesize(arg, precedence_traditional(expr),
                                        False))
        mo = self.dom.createElement('mo')
        mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))
        x.appendChild(mo)
    x.appendChild(self.parenthesize(args[-1], precedence_traditional(expr),
                                    False))
    return x

sympy.sympy.printing.mathml._print_MatPow

def _print_MatPow(self, expr):
    from sympy.matrices import MatrixSymbol
    base, exp = expr.base, expr.exp
    sup = self.dom.createElement('msup')
    if not isinstance(base, MatrixSymbol):
        brac = self.dom.createElement('mrow')
        brac.appendChild(self._l_paren())
        brac.appendChild(self._print(base))
        brac.appendChild(self._r_paren())
        sup.appendChild(brac)
    else:
        sup.appendChild(self._print(base))
    sup.appendChild(self._print(exp))
    return sup

sympy.sympy.printing.mathml._print_HadamardProduct

def _print_HadamardProduct(self, expr):
    x = self.dom.createElement('mrow')
    args = expr.args
    for arg in args[:-1]:
        x.appendChild(
            self.parenthesize(arg, precedence_traditional(expr), False))
        mo = self.dom.createElement('mo')
        mo.appendChild(self.dom.createTextNode('&#x2218;'))
        x.appendChild(mo)
    x.appendChild(
        self.parenthesize(args[-1], precedence_traditional(expr), False))
    return x

sympy.sympy.printing.mathml._print_ZeroMatrix

def _print_ZeroMatrix(self, Z):
    x = self.dom.createElement('mn')
    x.appendChild(self.dom.createTextNode('&#x1D7D8'))
    return x

sympy.sympy.printing.mathml._print_OneMatrix

def _print_OneMatrix(self, Z):
    x = self.dom.createElement('mn')
    x.appendChild(self.dom.createTextNode('&#x1D7D9'))
    return x

sympy.sympy.printing.mathml._print_Identity

def _print_Identity(self, I):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x1D540;'))
    return x

sympy.sympy.printing.mathml._print_floor

def _print_floor(self, e):
    left = self.dom.createElement('mo')
    left.appendChild(self.dom.createTextNode('\u230A'))
    right = self.dom.createElement('mo')
    right.appendChild(self.dom.createTextNode('\u230B'))
    mrow = self.dom.createElement('mrow')
    mrow.appendChild(left)
    mrow.appendChild(self._print(e.args[0]))
    mrow.appendChild(right)
    return mrow

sympy.sympy.printing.mathml._print_ceiling

def _print_ceiling(self, e):
    left = self.dom.createElement('mo')
    left.appendChild(self.dom.createTextNode('\u2308'))
    right = self.dom.createElement('mo')
    right.appendChild(self.dom.createTextNode('\u2309'))
    mrow = self.dom.createElement('mrow')
    mrow.appendChild(left)
    mrow.appendChild(self._print(e.args[0]))
    mrow.appendChild(right)
    return mrow

sympy.sympy.printing.mathml._print_Lambda

def _print_Lambda(self, e):
    # MathML reference for the lambda element:
    # https://www.w3.org/TR/MathML2/chapter4.html#id.4.2.1.7
    x = self.dom.createElement(self.mathml_tag(e))
    for arg in e.signature:
        x_1 = self.dom.createElement('bvar')
        x_1.appendChild(self._print(arg))
        x.appendChild(x_1)
    x.appendChild(self._print(e.expr))
    return x

sympy.sympy.printing.mathml._print_tuple

def _print_tuple(self, e):
    return self._paren_comma_separated(*e)

sympy.sympy.printing.mathml._print_IndexedBase

def _print_IndexedBase(self, e):
    return self._print(e.label)

sympy.sympy.printing.mathml._print_Indexed

def _print_Indexed(self, e):
    x = self.dom.createElement('msub')
    x.appendChild(self._print(e.base))
    if len(e.indices) == 1:
        x.appendChild(self._print(e.indices[0]))
        return x
    x.appendChild(self._print(e.indices))
    return x

sympy.sympy.printing.mathml._print_Add

def _print_Add(self, expr, order=None):
    mrow = self.dom.createElement('mrow')
    args = self._as_ordered_terms(expr, order=order)
    mrow.appendChild(self._print(args[0]))
    for arg in args[1:]:
        if arg.could_extract_minus_sign():
            # use minus
            x = self.dom.createElement('mo')
            x.appendChild(self.dom.createTextNode('-'))
            y = self._print(-arg)
            # invert expression since this is now minused
        else:
            x = self.dom.createElement('mo')
            x.appendChild(self.dom.createTextNode('+'))
            y = self._print(arg)
        mrow.appendChild(x)
        mrow.appendChild(y)

    return mrow

sympy.sympy.printing.mathml._print_MatrixElement

def _print_MatrixElement(self, e):
    x = self.dom.createElement('msub')
    x.appendChild(self.parenthesize(e.parent, PRECEDENCE["Atom"], strict = True))
    brac = self.dom.createElement('mrow')
    for i, arg in enumerate(e.indices):
        if i:
            brac.appendChild(self._comma())
        brac.appendChild(self._print(arg))
    x.appendChild(brac)
    return x

sympy.sympy.printing.mathml._print_elliptic_f

def _print_elliptic_f(self, e):
    x = self.dom.createElement('mrow')
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode('&#x1d5a5;'))
    x.appendChild(mi)
    x.appendChild(self._paren_bar_separated(*e.args))
    return x

sympy.sympy.printing.mathml._print_elliptic_e

def _print_elliptic_e(self, e):
    x = self.dom.createElement('mrow')
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode('&#x1d5a4;'))
    x.appendChild(mi)
    x.appendChild(self._paren_bar_separated(*e.args))
    return x

sympy.sympy.printing.mathml._print_elliptic_pi

def _print_elliptic_pi(self, e):
    x = self.dom.createElement('mrow')
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode('&#x1d6f1;'))
    x.appendChild(mi)
    y = self.dom.createElement('mrow')
    y.appendChild(self._l_paren())
    if len(e.args) == 2:
        n, m = e.args
        y.appendChild(self._print(n))
        y.appendChild(self._bar())
        y.appendChild(self._print(m))
    else:
        n, m, z = e.args
        y.appendChild(self._print(n))
        y.appendChild(self._semicolon())
        y.appendChild(self._print(m))
        y.appendChild(self._bar())
        y.appendChild(self._print(z))
    y.appendChild(self._r_paren())
    x.appendChild(y)
    return x

sympy.sympy.printing.mathml._print_Ei

def _print_Ei(self, e):
    x = self.dom.createElement('mrow')
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode('Ei'))
    x.appendChild(mi)
    x.appendChild(self._print(e.args))
    return x

sympy.sympy.printing.mathml._print_expint

def _print_expint(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msub')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('E'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[1:]))
    return x

sympy.sympy.printing.mathml._print_jacobi

def _print_jacobi(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msubsup')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('P'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    y.appendChild(self._print(e.args[1:3]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[3:]))
    return x

sympy.sympy.printing.mathml._print_gegenbauer

def _print_gegenbauer(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msubsup')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('C'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    y.appendChild(self._print(e.args[1:2]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[2:]))
    return x

sympy.sympy.printing.mathml._print_chebyshevt

def _print_chebyshevt(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msub')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('T'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[1:]))
    return x

sympy.sympy.printing.mathml._print_chebyshevu

def _print_chebyshevu(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msub')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('U'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[1:]))
    return x

sympy.sympy.printing.mathml._print_legendre

def _print_legendre(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msub')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('P'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[1:]))
    return x

sympy.sympy.printing.mathml._print_assoc_legendre

def _print_assoc_legendre(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msubsup')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('P'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    y.appendChild(self._print(e.args[1:2]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[2:]))
    return x

sympy.sympy.printing.mathml._print_laguerre

def _print_laguerre(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msub')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('L'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[1:]))
    return x

sympy.sympy.printing.mathml._print_assoc_laguerre

def _print_assoc_laguerre(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msubsup')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('L'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    y.appendChild(self._print(e.args[1:2]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[2:]))
    return x

sympy.sympy.printing.mathml._print_hermite

def _print_hermite(self, e):
    x = self.dom.createElement('mrow')
    y = self.dom.createElement('msub')
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('H'))
    y.appendChild(mo)
    y.appendChild(self._print(e.args[0]))
    x.appendChild(y)
    x.appendChild(self._print(e.args[1:]))
    return x

sympy.sympy.printing.mathml._print_Piecewise

def _print_Piecewise(self, expr):
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    root = self.dom.createElement('piecewise')
    for i, (e, c) in enumerate(expr.args):
        if i == len(expr.args) - 1 and c == True:
            piece = self.dom.createElement('otherwise')
            piece.appendChild(self._print(e))
        else:
            piece = self.dom.createElement('piece')
            piece.appendChild(self._print(e))
            piece.appendChild(self._print(c))
        root.appendChild(piece)
    return root

sympy.sympy.printing.mathml._print_MatrixBase

def _print_MatrixBase(self, m):
    table = self.dom.createElement('mtable')
    for i in range(m.rows):
        x = self.dom.createElement('mtr')
        for j in range(m.cols):
            y = self.dom.createElement('mtd')
            y.appendChild(self._print(m[i, j]))
            x.appendChild(y)
        table.appendChild(x)
    mat_delim = self._settings["mat_delim"]
    if mat_delim == '':
        return table
    left = self.dom.createElement('mo')
    right = self.dom.createElement('mo')
    if mat_delim == "[":
        left.appendChild(self.dom.createTextNode("["))
        right.appendChild(self.dom.createTextNode("]"))
    else:
        left.appendChild(self.dom.createTextNode("("))
        right.appendChild(self.dom.createTextNode(")"))
    mrow = self.dom.createElement('mrow')
    mrow.appendChild(left)
    mrow.appendChild(table)
    mrow.appendChild(right)
    return mrow

sympy.sympy.printing.mathml._print_Rational

def _print_Rational(self, e):
    if e.q == 1:
        # don't divide
        return self._print(e.p)

    return self._get_printed_Rational(e, self._settings["fold_short_frac"])

sympy.sympy.printing.mathml._print_Limit

def _print_Limit(self, e):
    mrow = self.dom.createElement('mrow')
    munder = self.dom.createElement('munder')
    mi = self.dom.createElement('mi')
    mi.appendChild(self.dom.createTextNode('lim'))

    x = self.dom.createElement('mrow')
    x_1 = self._print(e.args[1])
    arrow = self.dom.createElement('mo')
    arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
    x_2 = self._print(e.args[2])
    x.appendChild(x_1)
    x.appendChild(arrow)
    x.appendChild(x_2)

    munder.appendChild(mi)
    munder.appendChild(x)
    mrow.appendChild(munder)
    mrow.appendChild(self._print(e.args[0]))

    return mrow

sympy.sympy.printing.mathml._print_ImaginaryUnit

def _print_ImaginaryUnit(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&ImaginaryI;'))
    return x

sympy.sympy.printing.mathml._print_EulerGamma

def _print_EulerGamma(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x3B3;'))
    return x

sympy.sympy.printing.mathml._print_GoldenRatio

def _print_GoldenRatio(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x3A6;'))
    return x

sympy.sympy.printing.mathml._print_Exp1

def _print_Exp1(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&ExponentialE;'))
    return x

sympy.sympy.printing.mathml._print_Pi

def _print_Pi(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&pi;'))
    return x

sympy.sympy.printing.mathml._print_Infinity

def _print_Infinity(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x221E;'))
    return x

sympy.sympy.printing.mathml._print_BooleanTrue

def _print_BooleanTrue(self, e):
    return self.dom.createElement('true')

sympy.sympy.printing.mathml._print_BooleanFalse

def _print_BooleanFalse(self, e):
    return self.dom.createElement('false')

sympy.sympy.printing.mathml._print_Integral

def _print_Integral(self, expr):
    intsymbols = {1: "&#x222B;", 2: "&#x222C;", 3: "&#x222D;"}

    mrow = self.dom.createElement('mrow')
    if len(expr.limits) <= 3 and all(len(lim) == 1 for lim in expr.limits):
        # Only up to three-integral signs exists
        mo = self.dom.createElement('mo')
        mo.appendChild(self.dom.createTextNode(intsymbols[len(expr.limits)]))
        mrow.appendChild(mo)
    else:
        # Either more than three or limits provided
        for lim in reversed(expr.limits):
            mo = self.dom.createElement('mo')
            mo.appendChild(self.dom.createTextNode(intsymbols[1]))
            if len(lim) == 1:
                mrow.appendChild(mo)
            if len(lim) == 2:
                msup = self.dom.createElement('msup')
                msup.appendChild(mo)
                msup.appendChild(self._print(lim[1]))
                mrow.appendChild(msup)
            if len(lim) == 3:
                msubsup = self.dom.createElement('msubsup')
                msubsup.appendChild(mo)
                msubsup.appendChild(self._print(lim[1]))
                msubsup.appendChild(self._print(lim[2]))
                mrow.appendChild(msubsup)
    # print function
    mrow.appendChild(self.parenthesize(expr.function, PRECEDENCE["Mul"],
                                       strict=True))
    # print integration variables
    for lim in reversed(expr.limits):
        d = self.dom.createElement('mo')
        d.appendChild(self.dom.createTextNode('&dd;'))
        mrow.appendChild(d)
        mrow.appendChild(self._print(lim[0]))
    return mrow

sympy.sympy.printing.mathml._print_Sum

def _print_Sum(self, e):
    limits = list(e.limits)
    subsup = self.dom.createElement('munderover')
    low_elem = self._print(limits[0][1])
    up_elem = self._print(limits[0][2])
    summand = self.dom.createElement('mo')
    summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))

    low = self.dom.createElement('mrow')
    var = self._print(limits[0][0])
    equal = self.dom.createElement('mo')
    equal.appendChild(self.dom.createTextNode('='))
    low.appendChild(var)
    low.appendChild(equal)
    low.appendChild(low_elem)

    subsup.appendChild(summand)
    subsup.appendChild(low)
    subsup.appendChild(up_elem)

    mrow = self.dom.createElement('mrow')
    mrow.appendChild(subsup)
    mrow.appendChild(self.parenthesize(e.function, precedence_traditional(e)))
    return mrow

sympy.sympy.printing.mathml._print_Symbol

def _print_Symbol(self, sym, style='plain'):
    def join(items):
        if len(items) > 1:
            mrow = self.dom.createElement('mrow')
            for i, item in enumerate(items):
                if i > 0:
                    mo = self.dom.createElement('mo')
                    mo.appendChild(self.dom.createTextNode(" "))
                    mrow.appendChild(mo)
                mi = self.dom.createElement('mi')
                mi.appendChild(self.dom.createTextNode(item))
                mrow.appendChild(mi)
            return mrow
        else:
            mi = self.dom.createElement('mi')
            mi.appendChild(self.dom.createTextNode(items[0]))
            return mi

    # translate name, supers and subs to unicode characters
    def translate(s):
        if s in greek_unicode:
            return greek_unicode.get(s)
        else:
            return s

    name, supers, subs = self._split_super_sub(sym.name)
    name = translate(name)
    supers = [translate(sup) for sup in supers]
    subs = [translate(sub) for sub in subs]

    mname = self.dom.createElement('mi')
    mname.appendChild(self.dom.createTextNode(name))
    if len(supers) == 0:
        if len(subs) == 0:
            x = mname
        else:
            x = self.dom.createElement('msub')
            x.appendChild(mname)
            x.appendChild(join(subs))
    else:
        if len(subs) == 0:
            x = self.dom.createElement('msup')
            x.appendChild(mname)
            x.appendChild(join(supers))
        else:
            x = self.dom.createElement('msubsup')
            x.appendChild(mname)
            x.appendChild(join(subs))
            x.appendChild(join(supers))
    # Set bold font?
    if style == 'bold':
        x.setAttribute('mathvariant', 'bold')
    return x

sympy.sympy.printing.mathml._print_list

def _print_list(self, seq):
    """MathML reference for the <list> element:
    https://www.w3.org/TR/MathML2/chapter4.html#contm.list"""
    dom_element = self.dom.createElement('list')
    for item in seq:
        dom_element.appendChild(self._print(item))
    return dom_element

sympy.sympy.printing.mathml._print_NegativeInfinity

def _print_NegativeInfinity(self, e):
    mrow = self.dom.createElement('mrow')
    y = self.dom.createElement('mo')
    y.appendChild(self.dom.createTextNode('-'))
    x = self._print_Infinity(e)
    mrow.appendChild(y)
    mrow.appendChild(x)
    return mrow

sympy.sympy.printing.mathml._print_HBar

def _print_HBar(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x210F;'))
    return x

sympy.sympy.printing.mathml._print_TribonacciConstant

def _print_TribonacciConstant(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('TribonacciConstant'))
    return x

sympy.sympy.printing.mathml._print_Dagger

def _print_Dagger(self, e):
    msup = self.dom.createElement('msup')
    msup.appendChild(self._print(e.args[0]))
    msup.appendChild(self.dom.createTextNode('&#x2020;'))
    return msup

sympy.sympy.printing.mathml._print_Contains

def _print_Contains(self, e):
    mrow = self.dom.createElement('mrow')
    mrow.appendChild(self._print(e.args[0]))
    mo = self.dom.createElement('mo')
    mo.appendChild(self.dom.createTextNode('&#x2208;'))
    mrow.appendChild(mo)
    mrow.appendChild(self._print(e.args[1]))
    return mrow

sympy.sympy.printing.mathml._print_HilbertSpace

def _print_HilbertSpace(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x210B;'))
    return x

sympy.sympy.printing.mathml._print_ComplexSpace

def _print_ComplexSpace(self, e):
    msup = self.dom.createElement('msup')
    msup.appendChild(self.dom.createTextNode('&#x1D49E;'))
    msup.appendChild(self._print(e.args[0]))
    return msup

sympy.sympy.printing.mathml._print_FockSpace

def _print_FockSpace(self, e):
    x = self.dom.createElement('mi')
    x.appendChild(self.dom.createTextNode('&#x2131;'))
    return x

sympy.sympy.printing.numpy._print_MatrixSolve

def _print_MatrixSolve(self, expr):
    return "%s(%s, %s)" % (self._module_format(self._module + '.linalg.solve'),
                           self._print(expr.matrix),
                           self._print(expr.vector))

sympy.sympy.printing.numpy._print_ZeroMatrix

def _print_ZeroMatrix(self, expr):
    return '{}({})'.format(self._module_format(self._module + '.zeros'),
        self._print(expr.shape))

sympy.sympy.printing.numpy._print_OneMatrix

def _print_OneMatrix(self, expr):
    return '{}({})'.format(self._module_format(self._module + '.ones'),
        self._print(expr.shape))

sympy.sympy.printing.numpy._print_FunctionMatrix

def _print_FunctionMatrix(self, expr):
    from sympy.abc import i, j
    lamda = expr.lamda
    if not isinstance(lamda, Lambda):
        lamda = Lambda((i, j), lamda(i, j))
    return '{}(lambda {}: {}, {})'.format(self._module_format(self._module + '.fromfunction'),
        ', '.join(self._print(arg) for arg in lamda.args[0]),
        self._print(lamda.args[1]), self._print(expr.shape))

sympy.sympy.printing.numpy._print_HadamardProduct

def _print_HadamardProduct(self, expr):
    func = self._module_format(self._module + '.multiply')
    return ''.join('{}({}, '.format(func, self._print(arg)) \
        for arg in expr.args[:-1]) + "{}{}".format(self._print(expr.args[-1]),
        ')' * (len(expr.args) - 1))

sympy.sympy.printing.numpy._print_KroneckerProduct

def _print_KroneckerProduct(self, expr):
    func = self._module_format(self._module + '.kron')
    return ''.join('{}({}, '.format(func, self._print(arg)) \
        for arg in expr.args[:-1]) + "{}{}".format(self._print(expr.args[-1]),
        ')' * (len(expr.args) - 1))

sympy.sympy.printing.numpy._print_Adjoint

def _print_Adjoint(self, expr):
    return '{}({}({}))'.format(
        self._module_format(self._module + '.conjugate'),
        self._module_format(self._module + '.transpose'),
        self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_DiagonalOf

def _print_DiagonalOf(self, expr):
    vect = '{}({})'.format(
        self._module_format(self._module + '.diag'),
        self._print(expr.arg))
    return '{}({}, (-1, 1))'.format(
        self._module_format(self._module + '.reshape'), vect)

sympy.sympy.printing.numpy._print_DiagMatrix

def _print_DiagMatrix(self, expr):
    return '{}({})'.format(self._module_format(self._module + '.diagflat'),
        self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_DiagonalMatrix

def _print_DiagonalMatrix(self, expr):
    return '{}({}, {}({}, {}))'.format(self._module_format(self._module + '.multiply'),
        self._print(expr.arg), self._module_format(self._module + '.eye'),
        self._print(expr.shape[0]), self._print(expr.shape[1]))

sympy.sympy.printing.numpy._print_Piecewise

def _print_Piecewise(self, expr):
    "Piecewise function printer"
    from sympy.logic.boolalg import ITE, simplify_logic
    def print_cond(cond):
        """ Problem having an ITE in the cond. """
        if cond.has(ITE):
            return self._print(simplify_logic(cond))
        else:
            return self._print(cond)
    exprs = '[{}]'.format(','.join(self._print(arg.expr) for arg in expr.args))
    conds = '[{}]'.format(','.join(print_cond(arg.cond) for arg in expr.args))
    # If [default_value, True] is a (expr, cond) sequence in a Piecewise object
    #     it will behave the same as passing the 'default' kwarg to select()
    #     *as long as* it is the last element in expr.args.
    # If this is not the case, it may be triggered prematurely.
    return '{}({}, {}, default={})'.format(
        self._module_format(self._module + '.select'), conds, exprs,
        self._print(S.NaN))

sympy.sympy.printing.numpy._print_Relational

def _print_Relational(self, expr):
    "Relational printer for Equality and Unequality"
    op = {
        '==' :'equal',
        '!=' :'not_equal',
        '<'  :'less',
        '<=' :'less_equal',
        '>'  :'greater',
        '>=' :'greater_equal',
    }
    if expr.rel_op in op:
        lhs = self._print(expr.lhs)
        rhs = self._print(expr.rhs)
        return '{op}({lhs}, {rhs})'.format(op=self._module_format(self._module + '.'+op[expr.rel_op]),
                                           lhs=lhs, rhs=rhs)
    return super()._print_Relational(expr)

sympy.sympy.printing.numpy._print_Pow

def _print_Pow(self, expr, rational=False):
    # XXX Workaround for negative integer power error
    if expr.exp.is_integer and expr.exp.is_negative:
        expr = Pow(expr.base, expr.exp.evalf(), evaluate=False)
    return self._hprint_Pow(expr, rational=rational, sqrt=self._module + '.sqrt')

sympy.sympy.printing.numpy._print_Identity

def _print_Identity(self, expr):
    shape = expr.shape
    if all(dim.is_Integer for dim in shape):
        return "%s(%s)" % (self._module_format(self._module + '.eye'), self._print(expr.shape[0]))
    else:
        raise NotImplementedError("Symbolic matrix dimensions are not yet supported for identity matrices")

sympy.sympy.printing.numpy._print_NDimArray

def _print_NDimArray(self, expr):
    if expr.rank() == 0:
        func = self._module_format(f'{self._module}.array')
        return f"{func}({self._print(expr[()])})"
    if 0 in expr.shape:
        func = self._module_format(f'{self._module}.{self._zeros}')
        return f"{func}({self._print(expr.shape)})"
    func = self._module_format(f'{self._module}.array')
    return f"{func}({self._print(expr.tolist())})"

sympy.sympy.printing.numpy._print_SparseRepMatrix

def _print_SparseRepMatrix(self, expr):
    i, j, data = [], [], []
    for (r, c), v in expr.todok().items():
        i.append(r)
        j.append(c)
        data.append(v)

    return "{name}(({data}, ({i}, {j})), shape={shape})".format(
        name=self._module_format('scipy.sparse.coo_matrix'),
        data=data, i=i, j=j, shape=expr.shape
    )

sympy.sympy.printing.numpy._print_lowergamma

def _print_lowergamma(self, expr):
    return "{0}({2})*{1}({2}, {3})".format(
        self._module_format('scipy.special.gamma'),
        self._module_format('scipy.special.gammainc'),
        self._print(expr.args[0]),
        self._print(expr.args[1]))

sympy.sympy.printing.numpy._print_uppergamma

def _print_uppergamma(self, expr):
    return "{0}({2})*{1}({2}, {3})".format(
        self._module_format('scipy.special.gamma'),
        self._module_format('scipy.special.gammaincc'),
        self._print(expr.args[0]),
        self._print(expr.args[1]))

sympy.sympy.printing.numpy._print_fresnels

def _print_fresnels(self, expr):
    return "{}({})[0]".format(
            self._module_format("scipy.special.fresnel"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_fresnelc

def _print_fresnelc(self, expr):
    return "{}({})[1]".format(
            self._module_format("scipy.special.fresnel"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_airyai

def _print_airyai(self, expr):
    return "{}({})[0]".format(
            self._module_format("scipy.special.airy"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_airyaiprime

def _print_airyaiprime(self, expr):
    return "{}({})[1]".format(
            self._module_format("scipy.special.airy"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_airybi

def _print_airybi(self, expr):
    return "{}({})[2]".format(
            self._module_format("scipy.special.airy"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_airybiprime

def _print_airybiprime(self, expr):
    return "{}({})[3]".format(
            self._module_format("scipy.special.airy"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_Integral

def _print_Integral(self, e):
    integration_vars, limits = _unpack_integral_limits(e)

    if len(limits) == 1:
        # nicer (but not necessary) to prefer quad over nquad for 1D case
        module_str = self._module_format("scipy.integrate.quad")
        limit_str = "%s, %s" % tuple(map(self._print, limits[0]))
    else:
        module_str = self._module_format("scipy.integrate.nquad")
        limit_str = "({})".format(", ".join(
            "(%s, %s)" % tuple(map(self._print, l)) for l in limits))

    return "{}(lambda {}: {}, {})[0]".format(
            module_str,
            ", ".join(map(self._print, integration_vars)),
            self._print(e.args[0]),
            limit_str)

sympy.sympy.printing.numpy._print_Si

def _print_Si(self, expr):
    return "{}({})[0]".format(
            self._module_format("scipy.special.sici"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_Ci

def _print_Ci(self, expr):
    return "{}({})[1]".format(
            self._module_format("scipy.special.sici"),
            self._print(expr.args[0]))

sympy.sympy.printing.numpy._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-' + self._print(S.Infinity)

sympy.sympy.printing.numpy._print_MatPow

def _print_MatPow(self, expr):
    "Matrix power printer"
    return '{}({}, {})'.format(self._module_format(self._module + '.linalg.matrix_power'),
        self._print(expr.args[0]), self._print(expr.args[1]))

sympy.sympy.printing.numpy._print_Inverse

def _print_Inverse(self, expr):
    "Matrix inverse printer"
    return '{}({})'.format(self._module_format(self._module + '.linalg.inv'),
        self._print(expr.args[0]))

sympy.sympy.printing.octave._print_Mul

def _print_Mul(self, expr):
    # print complex numbers nicely in Octave
    if (expr.is_number and expr.is_imaginary and
            (S.ImaginaryUnit*expr).is_Integer):
        return "%si" % self._print(-S.ImaginaryUnit*expr)

    # cribbed from str.py
    prec = precedence(expr)

    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = "-"
    else:
        sign = ""

    a = []  # items in the numerator
    b = []  # items that are in the denominator (if any)

    pow_paren = []  # Will collect all pow with more than one base element and exp = -1

    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        # use make_args in case expr was something like -x -> x
        args = Mul.make_args(expr)

    # Gather args for numerator/denominator
    for item in args:
        if (item.is_commutative and item.is_Pow and item.exp.is_Rational
                and item.exp.is_negative):
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160
                    pow_paren.append(item)
                b.append(Pow(item.base, -item.exp))
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append(Rational(item.p))
            if item.q != 1:
                b.append(Rational(item.q))
        else:
            a.append(item)

    a = a or [S.One]

    a_str = [self.parenthesize(x, prec) for x in a]
    b_str = [self.parenthesize(x, prec) for x in b]

    # To parenthesize Pow with exp = -1 and having more than one Symbol
    for item in pow_paren:
        if item.base in b:
            b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]

    # from here it differs from str.py to deal with "*" and ".*"
    def multjoin(a, a_str):
        # here we probably are assuming the constants will come first
        r = a_str[0]
        for i in range(1, len(a)):
            mulsym = '*' if a[i-1].is_number else '.*'
            r = r + mulsym + a_str[i]
        return r

    if not b:
        return sign + multjoin(a, a_str)
    elif len(b) == 1:
        divsym = '/' if b[0].is_number else './'
        return sign + multjoin(a, a_str) + divsym + b_str[0]
    else:
        divsym = '/' if all(bi.is_number for bi in b) else './'
        return (sign + multjoin(a, a_str) +
                divsym + "(%s)" % multjoin(b, b_str))

sympy.sympy.printing.octave._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.octave._print_Pow

def _print_Pow(self, expr):
    powsymbol = '^' if all(x.is_number for x in expr.args) else '.^'

    PREC = precedence(expr)

    if equal_valued(expr.exp, 0.5):
        return "sqrt(%s)" % self._print(expr.base)

    if expr.is_commutative:
        if equal_valued(expr.exp, -0.5):
            sym = '/' if expr.base.is_number else './'
            return "1" + sym + "sqrt(%s)" % self._print(expr.base)
        if equal_valued(expr.exp, -1):
            sym = '/' if expr.base.is_number else './'
            return "1" + sym + "%s" % self.parenthesize(expr.base, PREC)

    return '%s%s%s' % (self.parenthesize(expr.base, PREC), powsymbol,
                       self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.octave._print_MatPow

def _print_MatPow(self, expr):
    PREC = precedence(expr)
    return '%s^%s' % (self.parenthesize(expr.base, PREC),
                      self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.octave._print_MatrixSolve

def _print_MatrixSolve(self, expr):
    PREC = precedence(expr)
    return "%s \\ %s" % (self.parenthesize(expr.matrix, PREC),
                         self.parenthesize(expr.vector, PREC))

sympy.sympy.printing.octave._print_Pi

def _print_Pi(self, expr):
    return 'pi'

sympy.sympy.printing.octave._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return "1i"

sympy.sympy.printing.octave._print_Exp1

def _print_Exp1(self, expr):
    return "exp(1)"

sympy.sympy.printing.octave._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    # FIXME: how to do better, e.g., for octave_code(2*GoldenRatio)?
    #return self._print((1+sqrt(S(5)))/2)
    return "(1+sqrt(5))/2"

sympy.sympy.printing.octave._print_Assignment

def _print_Assignment(self, expr):
    from sympy.codegen.ast import Assignment
    from sympy.functions.elementary.piecewise import Piecewise
    from sympy.tensor.indexed import IndexedBase
    # Copied from codeprinter, but remove special MatrixSymbol treatment
    lhs = expr.lhs
    rhs = expr.rhs
    # We special case assignments that take multiple lines
    if not self._settings["inline"] and isinstance(expr.rhs, Piecewise):
        # Here we modify Piecewise so each expression is now
        # an Assignment, and then continue on the print.
        expressions = []
        conditions = []
        for (e, c) in rhs.args:
            expressions.append(Assignment(lhs, e))
            conditions.append(c)
        temp = Piecewise(*zip(expressions, conditions))
        return self._print(temp)
    if self._settings["contract"] and (lhs.has(IndexedBase) or
            rhs.has(IndexedBase)):
        # Here we check if there is looping to be done, and if so
        # print the required loops.
        return self._doprint_loops(rhs, lhs)
    else:
        lhs_code = self._print(lhs)
        rhs_code = self._print(rhs)
        return self._get_statement("%s = %s" % (lhs_code, rhs_code))

sympy.sympy.printing.octave._print_Infinity

def _print_Infinity(self, expr):
    return 'inf'

sympy.sympy.printing.octave._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-inf'

sympy.sympy.printing.octave._print_NaN

def _print_NaN(self, expr):
    return 'NaN'

sympy.sympy.printing.octave._print_list

def _print_list(self, expr):
    return '{' + ', '.join(self._print(a) for a in expr) + '}'

sympy.sympy.printing.octave._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return "true"

sympy.sympy.printing.octave._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return "false"

sympy.sympy.printing.octave._print_MatrixBase

def _print_MatrixBase(self, A):
    # Handle zero dimensions:
    if (A.rows, A.cols) == (0, 0):
        return '[]'
    elif S.Zero in A.shape:
        return 'zeros(%s, %s)' % (A.rows, A.cols)
    elif (A.rows, A.cols) == (1, 1):
        # Octave does not distinguish between scalars and 1x1 matrices
        return self._print(A[0, 0])
    return "[%s]" % "; ".join(" ".join([self._print(a) for a in A[r, :]])
                              for r in range(A.rows))

sympy.sympy.printing.octave._print_SparseRepMatrix

def _print_SparseRepMatrix(self, A):
    from sympy.matrices import Matrix
    L = A.col_list()
    # make row vectors of the indices and entries
    I = Matrix([[k[0] + 1 for k in L]])
    J = Matrix([[k[1] + 1 for k in L]])
    AIJ = Matrix([[k[2] for k in L]])
    return "sparse(%s, %s, %s, %s, %s)" % (self._print(I), self._print(J),
                                        self._print(AIJ), A.rows, A.cols)

sympy.sympy.printing.octave._print_MatrixElement

def _print_MatrixElement(self, expr):
    return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
        + '(%s, %s)' % (expr.i + 1, expr.j + 1)

sympy.sympy.printing.octave._print_MatrixSlice

def _print_MatrixSlice(self, expr):
    def strslice(x, lim):
        l = x[0] + 1
        h = x[1]
        step = x[2]
        lstr = self._print(l)
        hstr = 'end' if h == lim else self._print(h)
        if step == 1:
            if l == 1 and h == lim:
                return ':'
            if l == h:
                return lstr
            else:
                return lstr + ':' + hstr
        else:
            return ':'.join((lstr, self._print(step), hstr))
    return (self._print(expr.parent) + '(' +
            strslice(expr.rowslice, expr.parent.shape[0]) + ', ' +
            strslice(expr.colslice, expr.parent.shape[1]) + ')')

sympy.sympy.printing.octave._print_Indexed

def _print_Indexed(self, expr):
    inds = [ self._print(i) for i in expr.indices ]
    return "%s(%s)" % (self._print(expr.base.label), ", ".join(inds))

sympy.sympy.printing.octave._print_KroneckerDelta

def _print_KroneckerDelta(self, expr):
    prec = PRECEDENCE["Pow"]
    return "double(%s == %s)" % tuple(self.parenthesize(x, prec)
                                      for x in expr.args)

sympy.sympy.printing.octave._print_HadamardProduct

def _print_HadamardProduct(self, expr):
    return '.*'.join([self.parenthesize(arg, precedence(expr))
                      for arg in expr.args])

sympy.sympy.printing.octave._print_HadamardPower

def _print_HadamardPower(self, expr):
    PREC = precedence(expr)
    return '.**'.join([
        self.parenthesize(expr.base, PREC),
        self.parenthesize(expr.exp, PREC)
        ])

sympy.sympy.printing.octave._print_Identity

def _print_Identity(self, expr):
    shape = expr.shape
    if len(shape) == 2 and shape[0] == shape[1]:
        shape = [shape[0]]
    s = ", ".join(self._print(n) for n in shape)
    return "eye(" + s + ")"

sympy.sympy.printing.octave._print_lowergamma

def _print_lowergamma(self, expr):
    # Octave implements regularized incomplete gamma function
    return "(gammainc({1}, {0}).*gamma({0}))".format(
        self._print(expr.args[0]), self._print(expr.args[1]))

sympy.sympy.printing.octave._print_uppergamma

def _print_uppergamma(self, expr):
    return "(gammainc({1}, {0}, 'upper').*gamma({0}))".format(
        self._print(expr.args[0]), self._print(expr.args[1]))

sympy.sympy.printing.octave._print_sinc

def _print_sinc(self, expr):
    #Note: Divide by pi because Octave implements normalized sinc function.
    return "sinc(%s)" % self._print(expr.args[0]/S.Pi)

sympy.sympy.printing.octave._print_hankel1

def _print_hankel1(self, expr):
    return "besselh(%s, 1, %s)" % (self._print(expr.order),
                                   self._print(expr.argument))

sympy.sympy.printing.octave._print_hankel2

def _print_hankel2(self, expr):
    return "besselh(%s, 2, %s)" % (self._print(expr.order),
                                   self._print(expr.argument))

sympy.sympy.printing.octave._print_jn

def _print_jn(self, expr):
    from sympy.functions import sqrt, besselj
    x = expr.argument
    expr2 = sqrt(S.Pi/(2*x))*besselj(expr.order + S.Half, x)
    return self._print(expr2)

sympy.sympy.printing.octave._print_yn

def _print_yn(self, expr):
    from sympy.functions import sqrt, bessely
    x = expr.argument
    expr2 = sqrt(S.Pi/(2*x))*bessely(expr.order + S.Half, x)
    return self._print(expr2)

sympy.sympy.printing.octave._print_airyai

def _print_airyai(self, expr):
    return "airy(0, %s)" % self._print(expr.args[0])

sympy.sympy.printing.octave._print_airyaiprime

def _print_airyaiprime(self, expr):
    return "airy(1, %s)" % self._print(expr.args[0])

sympy.sympy.printing.octave._print_airybi

def _print_airybi(self, expr):
    return "airy(2, %s)" % self._print(expr.args[0])

sympy.sympy.printing.octave._print_airybiprime

def _print_airybiprime(self, expr):
    return "airy(3, %s)" % self._print(expr.args[0])

sympy.sympy.printing.octave._print_expint

def _print_expint(self, expr):
    mu, x = expr.args
    if mu != 1:
        return self._print_not_supported(expr)
    return "expint(%s)" % self._print(x)

sympy.sympy.printing.octave._one_or_two_reversed_args

def _one_or_two_reversed_args(self, expr):
    assert len(expr.args) <= 2
    return '{name}({args})'.format(
        name=self.known_functions[expr.__class__.__name__],
        args=", ".join([self._print(x) for x in reversed(expr.args)])
    )

sympy.sympy.printing.octave._nested_binary_math_func

def _nested_binary_math_func(self, expr):
    return '{name}({arg1}, {arg2})'.format(
        name=self.known_functions[expr.__class__.__name__],
        arg1=self._print(expr.args[0]),
        arg2=self._print(expr.func(*expr.args[1:]))
        )

sympy.sympy.printing.octave._print_Piecewise

def _print_Piecewise(self, expr):
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []
    if self._settings["inline"]:
        # Express each (cond, expr) pair in a nested Horner form:
        #   (condition) .* (expr) + (not cond) .* (<others>)
        # Expressions that result in multiple statements won't work here.
        ecpairs = ["({0}).*({1}) + (~({0})).*(".format
                   (self._print(c), self._print(e))
                   for e, c in expr.args[:-1]]
        elast = "%s" % self._print(expr.args[-1].expr)
        pw = " ...\n".join(ecpairs) + elast + ")"*len(ecpairs)
        # Note: current need these outer brackets for 2*pw.  Would be
        # nicer to teach parenthesize() to do this for us when needed!
        return "(" + pw + ")"
    else:
        for i, (e, c) in enumerate(expr.args):
            if i == 0:
                lines.append("if (%s)" % self._print(c))
            elif i == len(expr.args) - 1 and c == True:
                lines.append("else")
            else:
                lines.append("elseif (%s)" % self._print(c))
            code0 = self._print(e)
            lines.append(code0)
            if i == len(expr.args) - 1:
                lines.append("end")
        return "\n".join(lines)

sympy.sympy.printing.octave._print_zeta

def _print_zeta(self, expr):
    if len(expr.args) == 1:
        return "zeta(%s)" % self._print(expr.args[0])
    else:
        # Matlab two argument zeta is not equivalent to SymPy's
        return self._print_not_supported(expr)

sympy.sympy.printing.pretty.pretty._print_DiscreteTransferFunction

def _print_DiscreteTransferFunction(self, expr):
    if not expr.num == 1:
        res = Mul(expr.num, Pow(expr.den, -1, evaluate=False),
                  evaluate=False)
        result = self._print_Mul(res)
    else:
        result =  self._print(1)/self._print(expr.den)

    result = prettyForm(\
        *result.right(f" [st: {expr.sampling_time}]"))
    return result

sympy.sympy.printing.pretty.pretty._print_Series

def _print_Series(self, expr):
    args = list(expr.args)
    for i, a in enumerate(expr.args):
        args[i] = prettyForm(*self._print(a).parens())
    return prettyForm.__mul__(*args)

sympy.sympy.printing.pretty.pretty._print_MIMOSeries

def _print_MIMOSeries(self, expr):
    from sympy.physics.control.lti import MIMOParallel
    args = list(expr.args)
    pretty_args = []
    for a in reversed(args):
        if (isinstance(a, MIMOParallel) and len(expr.args) > 1):
            expression = self._print(a)
            expression.baseline = expression.height()//2
            pretty_args.append(prettyForm(*expression.parens()))
        else:
            expression = self._print(a)
            expression.baseline = expression.height()//2
            pretty_args.append(expression)
    return prettyForm.__mul__(*pretty_args)

sympy.sympy.printing.pretty.pretty._print_Parallel

def _print_Parallel(self, expr):
    s = None
    for item in expr.args:
        pform = self._print(item)
        if s is None:
            s = pform     # First element
        else:
            s = prettyForm(*stringPict.next(s))
            s.baseline = s.height()//2
            s = prettyForm(*stringPict.next(s, ' + '))
            s = prettyForm(*stringPict.next(s, pform))
    return s

sympy.sympy.printing.pretty.pretty._print_MIMOParallel

def _print_MIMOParallel(self, expr):
    from sympy.physics.control.lti import TransferFunctionMatrix
    s = None
    for item in expr.args:
        pform = self._print(item)
        if s is None:
            s = pform     # First element
        else:
            s = prettyForm(*stringPict.next(s))
            s.baseline = s.height()//2
            s = prettyForm(*stringPict.next(s, ' + '))
            if isinstance(item, TransferFunctionMatrix):
                s.baseline = s.height() - 1
            s = prettyForm(*stringPict.next(s, pform))
        # s.baseline = s.height()//2
    return s

sympy.sympy.printing.pretty.pretty._print_Feedback

def _print_Feedback(self, expr):
    from sympy.physics.control import TransferFunction, Series

    num, tf = expr.sys1, TransferFunction(1, 1, expr.var)
    num_arg_list = list(num.args) if isinstance(num, Series) else [num]
    den_arg_list = list(expr.sys2.args) if \
        isinstance(expr.sys2, Series) else [expr.sys2]

    if isinstance(num, Series) and isinstance(expr.sys2, Series):
        den = Series(*num_arg_list, *den_arg_list)
    elif isinstance(num, Series) and isinstance(expr.sys2, TransferFunction):
        if expr.sys2 == tf:
            den = Series(*num_arg_list)
        else:
            den = Series(*num_arg_list, expr.sys2)
    elif isinstance(num, TransferFunction) and isinstance(expr.sys2, Series):
        if num == tf:
            den = Series(*den_arg_list)
        else:
            den = Series(num, *den_arg_list)
    else:
        if num == tf:
            den = Series(*den_arg_list)
        elif expr.sys2 == tf:
            den = Series(*num_arg_list)
        else:
            den = Series(*num_arg_list, *den_arg_list)

    denom = prettyForm(*stringPict.next(self._print(tf)))
    denom.baseline = denom.height()//2
    denom = prettyForm(*stringPict.next(denom, ' + ')) if expr.sign == -1 \
        else prettyForm(*stringPict.next(denom, ' - '))
    denom = prettyForm(*stringPict.next(denom, self._print(den)))

    return self._print(num)/denom

sympy.sympy.printing.pretty.pretty._print_Curl

def _print_Curl(self, e):
    vec = e._expr
    pform = self._print(vec)
    pform = prettyForm(*pform.left('('))
    pform = prettyForm(*pform.right(')'))
    pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
    pform = prettyForm(*pform.left(self._print(U('NABLA'))))
    return pform

sympy.sympy.printing.pretty.pretty._print_MIMOFeedback

def _print_MIMOFeedback(self, expr):
    from sympy.physics.control import MIMOSeries, TransferFunctionMatrix

    inv_mat = self._print(MIMOSeries(expr.sys2, expr.sys1))
    plant = self._print(expr.sys1)
    _feedback = prettyForm(*stringPict.next(inv_mat))
    _feedback = prettyForm(*stringPict.right("I + ", _feedback)) if expr.sign == -1 \
        else prettyForm(*stringPict.right("I - ", _feedback))
    _feedback = prettyForm(*stringPict.parens(_feedback))
    _feedback.baseline = 0
    _feedback = prettyForm(*stringPict.right(_feedback, '-1 '))
    _feedback.baseline = _feedback.height()//2
    _feedback = prettyForm.__mul__(_feedback, prettyForm(" "))
    if isinstance(expr.sys1, TransferFunctionMatrix):
        _feedback.baseline = _feedback.height() - 1
    _feedback = prettyForm(*stringPict.next(_feedback, plant))
    return _feedback

sympy.sympy.printing.pretty.pretty._print_TransferFunctionMatrix

def _print_TransferFunctionMatrix(self, expr):
    mat = self._print(expr._expr_mat)
    mat.baseline = mat.height() - 1
    if expr.sampling_time == 0:
        subscript = greek_unicode['tau'] if self._use_unicode else r'{t}'
    else:
        subscript = r'{k}'
    mat = prettyForm(*mat.right(subscript))

    if expr.sampling_time == 0:
        return mat

    return prettyForm(*mat.below(f"[st: {expr.sampling_time}]"))

sympy.sympy.printing.pretty.pretty._print_StateSpace

def _print_StateSpace(self, expr):
    from sympy.matrices.expressions.blockmatrix import BlockMatrix
    A = expr._A
    B = expr._B
    C = expr._C
    D = expr._D
    mat = BlockMatrix([[A, B], [C, D]])
    return self._print(mat.blocks)

sympy.sympy.printing.pretty.pretty._print_DiscreteStateSpace

def _print_DiscreteStateSpace(self, expr):
    from sympy.matrices.expressions.blockmatrix import BlockMatrix
    A = expr._A
    B = expr._B
    C = expr._C
    D = expr._D
    mat = BlockMatrix([[A, B], [C, D]])
    mat = self._print(mat)
    return prettyForm(*mat.below(f"\n[st: {expr.sampling_time}]"))

sympy.sympy.printing.pretty.pretty._print_BasisDependent

def _print_BasisDependent(self, expr):
    from sympy.vector import Vector

    if not self._use_unicode:
        raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")

    if expr == expr.zero:
        return prettyForm(expr.zero._pretty_form)
    o1 = []
    vectstrs = []
    if isinstance(expr, Vector):
        items = expr.separate().items()
    else:
        items = [(0, expr)]
    for system, vect in items:
        inneritems = list(vect.components.items())
        inneritems.sort(key = lambda x: x[0].__str__())
        for k, v in inneritems:
            #if the coef of the basis vector is 1
            #we skip the 1
            if v == 1:
                o1.append("" +
                          k._pretty_form)
            #Same for -1
            elif v == -1:
                o1.append("(-1) " +
                          k._pretty_form)
            #For a general expr
            else:
                #We always wrap the measure numbers in
                #parentheses
                arg_str = self._print(
                    v).parens()[0]

                o1.append(arg_str + ' ' + k._pretty_form)
            vectstrs.append(k._pretty_form)

    #outstr = u("").join(o1)
    if o1[0].startswith(" + "):
        o1[0] = o1[0][3:]
    elif o1[0].startswith(" "):
        o1[0] = o1[0][1:]
    #Fixing the newlines
    lengths = []
    strs = ['']
    flag = []
    for i, partstr in enumerate(o1):
        flag.append(0)
        # XXX: What is this hack?
        if '\n' in partstr:
            tempstr = partstr
            tempstr = tempstr.replace(vectstrs[i], '')
            if xobj(')_ext', 1) in tempstr:   # If scalar is a fraction
                for paren in range(len(tempstr)):
                    flag[i] = 1
                    if tempstr[paren] == xobj(')_ext', 1) and tempstr[paren + 1] == '\n':
                        # We want to place the vector string after all the right parentheses, because
                        # otherwise, the vector will be in the middle of the string
                        tempstr = tempstr[:paren] + xobj(')_ext', 1)\
                                     + ' '  + vectstrs[i] + tempstr[paren + 1:]
                        break
            elif xobj(')_lower_hook', 1) in tempstr:
                # We want to place the vector string after all the right parentheses, because
                # otherwise, the vector will be in the middle of the string. For this reason,
                # we insert the vector string at the rightmost index.
                index = tempstr.rfind(xobj(')_lower_hook', 1))
                if index != -1: # then this character was found in this string
                    flag[i] = 1
                    tempstr = tempstr[:index] + xobj(')_lower_hook', 1)\
                                 + ' '  + vectstrs[i] + tempstr[index + 1:]
            o1[i] = tempstr

    o1 = [x.split('\n') for x in o1]
    n_newlines = max(len(x) for x in o1)  # Width of part in its pretty form

    if 1 in flag:                           # If there was a fractional scalar
        for i, parts in enumerate(o1):
            if len(parts) == 1:             # If part has no newline
                parts.insert(0, ' ' * (len(parts[0])))
                flag[i] = 1

    for i, parts in enumerate(o1):
        lengths.append(len(parts[flag[i]]))
        for j in range(n_newlines):
            if j+1 <= len(parts):
                if j >= len(strs):
                    strs.append(' ' * (sum(lengths[:-1]) +
                                       3*(len(lengths)-1)))
                if j == flag[i]:
                    strs[flag[i]] += parts[flag[i]] + ' + '
                else:
                    strs[j] += parts[j] + ' '*(lengths[-1] -
                                               len(parts[j])+
                                               3)
            else:
                if j >= len(strs):
                    strs.append(' ' * (sum(lengths[:-1]) +
                                       3*(len(lengths)-1)))
                strs[j] += ' '*(lengths[-1]+3)

    return prettyForm('\n'.join([s[:-3] for s in strs]))

sympy.sympy.printing.pretty.pretty._print_Divergence

def _print_Divergence(self, e):
    vec = e._expr
    pform = self._print(vec)
    pform = prettyForm(*pform.left('('))
    pform = prettyForm(*pform.right(')'))
    pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
    pform = prettyForm(*pform.left(self._print(U('NABLA'))))
    return pform

sympy.sympy.printing.pretty.pretty._print_NDimArray

def _print_NDimArray(self, expr):
    from sympy.matrices.immutable import ImmutableMatrix

    if expr.rank() == 0:
        return self._print(expr[()])

    level_str = [[]] + [[] for i in range(expr.rank())]
    shape_ranges = [list(range(i)) for i in expr.shape]
    # leave eventual matrix elements unflattened
    mat = lambda x: ImmutableMatrix(x, evaluate=False)
    for outer_i in itertools.product(*shape_ranges):
        level_str[-1].append(expr[outer_i])
        even = True
        for back_outer_i in range(expr.rank()-1, -1, -1):
            if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
                break
            if even:
                level_str[back_outer_i].append(level_str[back_outer_i+1])
            else:
                level_str[back_outer_i].append(mat(
                    level_str[back_outer_i+1]))
                if len(level_str[back_outer_i + 1]) == 1:
                    level_str[back_outer_i][-1] = mat(
                        [[level_str[back_outer_i][-1]]])
            even = not even
            level_str[back_outer_i+1] = []

    out_expr = level_str[0][0]
    if expr.rank() % 2 == 1:
        out_expr = mat([out_expr])

    return self._print(out_expr)

sympy.sympy.printing.pretty.pretty._print_Dot

def _print_Dot(self, e):
    vec1 = e._expr1
    vec2 = e._expr2
    pform = self._print(vec2)
    pform = prettyForm(*pform.left('('))
    pform = prettyForm(*pform.right(')'))
    pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
    pform = prettyForm(*pform.left(')'))
    pform = prettyForm(*pform.left(self._print(vec1)))
    pform = prettyForm(*pform.left('('))
    return pform

sympy.sympy.printing.pretty.pretty._print_Tensor

def _print_Tensor(self, expr):
    name = expr.args[0].name
    indices = expr.get_indices()
    return self._printer_tensor_indices(name, indices)

sympy.sympy.printing.pretty.pretty._print_TensorElement

def _print_TensorElement(self, expr):
    name = expr.expr.args[0].name
    indices = expr.expr.get_indices()
    index_map = expr.index_map
    return self._printer_tensor_indices(name, indices, index_map)

sympy.sympy.printing.pretty.pretty._print_TensMul

def _print_TensMul(self, expr):
    sign, args = expr._get_args_for_traditional_printer()
    args = [
        prettyForm(*self._print(i).parens()) if
        precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
        for i in args
    ]
    pform = prettyForm.__mul__(*args)
    if sign:
        return prettyForm(*pform.left(sign))
    else:
        return pform

sympy.sympy.printing.pretty.pretty._print_TensAdd

def _print_TensAdd(self, expr):
    args = [
        prettyForm(*self._print(i).parens()) if
        precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
        for i in expr.args
    ]
    return prettyForm.__add__(*args)

sympy.sympy.printing.pretty.pretty._print_TensorIndex

def _print_TensorIndex(self, expr):
    sym = expr.args[0]
    if not expr.is_up:
        sym = -sym
    return self._print(sym)

sympy.sympy.printing.pretty.pretty._print_PartialDerivative

def _print_PartialDerivative(self, deriv):
    if self._use_unicode:
        deriv_symbol = U('PARTIAL DIFFERENTIAL')
    else:
        deriv_symbol = r'd'
    x = None

    for variable in reversed(deriv.variables):
        s = self._print(variable)
        ds = prettyForm(*s.left(deriv_symbol))

        if x is None:
            x = ds
        else:
            x = prettyForm(*x.right(' '))
            x = prettyForm(*x.right(ds))

    f = prettyForm(
        binding=prettyForm.FUNC, *self._print(deriv.expr).parens())

    pform = prettyForm(deriv_symbol)

    if len(deriv.variables) > 1:
        pform = pform**self._print(len(deriv.variables))

    pform = prettyForm(*pform.below(stringPict.LINE, x))
    pform.baseline = pform.baseline + 1
    pform = prettyForm(*stringPict.next(pform, f))
    pform.binding = prettyForm.MUL

    return pform

sympy.sympy.printing.pretty.pretty._print_Gradient

def _print_Gradient(self, e):
    func = e._expr
    pform = self._print(func)
    pform = prettyForm(*pform.left('('))
    pform = prettyForm(*pform.right(')'))
    pform = prettyForm(*pform.left(self._print(U('NABLA'))))
    return pform

sympy.sympy.printing.pretty.pretty._print_Piecewise

def _print_Piecewise(self, pexpr):

    P = {}
    for n, ec in enumerate(pexpr.args):
        P[n, 0] = self._print(ec.expr)
        if ec.cond == True:
            P[n, 1] = prettyForm('otherwise')
        else:
            P[n, 1] = prettyForm(
                *prettyForm('for ').right(self._print(ec.cond)))
    hsep = 2
    vsep = 1
    len_args = len(pexpr.args)

    # max widths
    maxw = [max(P[i, j].width() for i in range(len_args))
            for j in range(2)]

    # FIXME: Refactor this code and matrix into some tabular environment.
    # drawing result
    D = None

    for i in range(len_args):
        D_row = None
        for j in range(2):
            p = P[i, j]
            assert p.width() <= maxw[j]

            wdelta = maxw[j] - p.width()
            wleft = wdelta // 2
            wright = wdelta - wleft

            p = prettyForm(*p.right(' '*wright))
            p = prettyForm(*p.left(' '*wleft))

            if D_row is None:
                D_row = p
                continue

            D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
            D_row = prettyForm(*D_row.right(p))
        if D is None:
            D = D_row       # first row in a picture
            continue

        # v-spacer
        for _ in range(vsep):
            D = prettyForm(*D.below(' '))

        D = prettyForm(*D.below(D_row))

    D = prettyForm(*D.parens('{', ''))
    D.baseline = D.height()//2
    D.binding = prettyForm.OPEN
    return D

sympy.sympy.printing.pretty.pretty._print_ITE

def _print_ITE(self, ite):
    from sympy.functions.elementary.piecewise import Piecewise
    return self._print(ite.rewrite(Piecewise))

sympy.sympy.printing.pretty.pretty._print_Laplacian

def _print_Laplacian(self, e):
    func = e._expr
    pform = self._print(func)
    pform = prettyForm(*pform.left('('))
    pform = prettyForm(*pform.right(')'))
    pform = prettyForm(*pform.left(self._print(U('INCREMENT'))))
    return pform

sympy.sympy.printing.pretty.pretty._print_hyper

def _print_hyper(self, e):
    # FIXME refactor Matrix, Piecewise, and this into a tabular environment
    ap = [self._print(a) for a in e.ap]
    bq = [self._print(b) for b in e.bq]

    P = self._print(e.argument)
    P.baseline = P.height()//2

    # Drawing result - first create the ap, bq vectors
    D = None
    for v in [ap, bq]:
        D_row = self._hprint_vec(v)
        if D is None:
            D = D_row       # first row in a picture
        else:
            D = prettyForm(*D.below(' '))
            D = prettyForm(*D.below(D_row))

    # make sure that the argument `z' is centred vertically
    D.baseline = D.height()//2

    # insert horizontal separator
    P = prettyForm(*P.left(' '))
    D = prettyForm(*D.right(' '))

    # insert separating `|`
    D = self._hprint_vseparator(D, P)

    # add parens
    D = prettyForm(*D.parens('(', ')'))

    # create the F symbol
    above = D.height()//2 - 1
    below = D.height() - above - 1

    sz, t, b, add, img = annotated('F')
    F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
                   baseline=above + sz)
    add = (sz + 1)//2

    F = prettyForm(*F.left(self._print(len(e.ap))))
    F = prettyForm(*F.right(self._print(len(e.bq))))
    F.baseline = above + add

    D = prettyForm(*F.right(' ', D))

    return D

sympy.sympy.printing.pretty.pretty._print_meijerg

def _print_meijerg(self, e):
    # FIXME refactor Matrix, Piecewise, and this into a tabular environment

    v = {}
    v[(0, 0)] = [self._print(a) for a in e.an]
    v[(0, 1)] = [self._print(a) for a in e.aother]
    v[(1, 0)] = [self._print(b) for b in e.bm]
    v[(1, 1)] = [self._print(b) for b in e.bother]

    P = self._print(e.argument)
    P.baseline = P.height()//2

    vp = {}
    for idx in v:
        vp[idx] = self._hprint_vec(v[idx])

    for i in range(2):
        maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
        for j in range(2):
            s = vp[(j, i)]
            left = (maxw - s.width()) // 2
            right = maxw - left - s.width()
            s = prettyForm(*s.left(' ' * left))
            s = prettyForm(*s.right(' ' * right))
            vp[(j, i)] = s

    D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
    D1 = prettyForm(*D1.below(' '))
    D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
    D = prettyForm(*D1.below(D2))

    # make sure that the argument `z' is centred vertically
    D.baseline = D.height()//2

    # insert horizontal separator
    P = prettyForm(*P.left(' '))
    D = prettyForm(*D.right(' '))

    # insert separating `|`
    D = self._hprint_vseparator(D, P)

    # add parens
    D = prettyForm(*D.parens('(', ')'))

    # create the G symbol
    above = D.height()//2 - 1
    below = D.height() - above - 1

    sz, t, b, add, img = annotated('G')
    F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
                   baseline=above + sz)

    pp = self._print(len(e.ap))
    pq = self._print(len(e.bq))
    pm = self._print(len(e.bm))
    pn = self._print(len(e.an))

    def adjust(p1, p2):
        diff = p1.width() - p2.width()
        if diff == 0:
            return p1, p2
        elif diff > 0:
            return p1, prettyForm(*p2.left(' '*diff))
        else:
            return prettyForm(*p1.left(' '*-diff)), p2
    pp, pm = adjust(pp, pm)
    pq, pn = adjust(pq, pn)
    pu = prettyForm(*pm.right(', ', pn))
    pl = prettyForm(*pp.right(', ', pq))

    ht = F.baseline - above - 2
    if ht > 0:
        pu = prettyForm(*pu.below('\n'*ht))
    p = prettyForm(*pu.below(pl))

    F.baseline = above
    F = prettyForm(*F.right(p))

    F.baseline = above + add

    D = prettyForm(*F.right(' ', D))

    return D

sympy.sympy.printing.pretty.pretty._print_Atom

def _print_Atom(self, e):
    try:
        # print atoms like Exp1 or Pi
        return prettyForm(pretty_atom(e.__class__.__name__, printer=self))
    except KeyError:
        return self.emptyPrinter(e)

sympy.sympy.printing.pretty.pretty._print_ExpBase

def _print_ExpBase(self, e):
    # TODO should exp_polar be printed differently?
    #      what about exp_polar(0), exp_polar(1)?
    base = prettyForm(pretty_atom('Exp1', 'e'))
    return base ** self._print(e.args[0])

sympy.sympy.printing.pretty.pretty._print_Exp1

def _print_Exp1(self, e):
    return prettyForm(pretty_atom('Exp1', 'e'))

sympy.sympy.printing.pretty.pretty._print_Function

def _print_Function(self, e, sort=False, func_name=None, left='(',
                    right=')'):
    # optional argument func_name for supplying custom names
    # XXX works only for applied functions
    return self._helper_print_function(e.func, e.args, sort=sort, func_name=func_name, left=left, right=right)

sympy.sympy.printing.pretty.pretty._print_mathieuc

def _print_mathieuc(self, e):
    return self._print_Function(e, func_name='C')

sympy.sympy.printing.pretty.pretty._print_mathieus

def _print_mathieus(self, e):
    return self._print_Function(e, func_name='S')

sympy.sympy.printing.pretty.pretty._print_mathieucprime

def _print_mathieucprime(self, e):
    return self._print_Function(e, func_name="C'")

sympy.sympy.printing.pretty.pretty._print_mathieusprime

def _print_mathieusprime(self, e):
    return self._print_Function(e, func_name="S'")

sympy.sympy.printing.pretty.pretty._print_ElementwiseApplyFunction

def _print_ElementwiseApplyFunction(self, e):
    func = e.function
    arg = e.expr
    args = [arg]
    return self._helper_print_function(func, args, delimiter="", elementwise=True)

sympy.sympy.printing.pretty.pretty._print_FunctionClass

def _print_FunctionClass(self, expr):
    for cls in self._special_function_classes:
        if issubclass(expr, cls) and expr.__name__ == cls.__name__:
            if self._use_unicode:
                return prettyForm(self._special_function_classes[cls][0])
            else:
                return prettyForm(self._special_function_classes[cls][1])
    func_name = expr.__name__
    return prettyForm(pretty_symbol(func_name))

sympy.sympy.printing.pretty.pretty._print_GeometryEntity

def _print_GeometryEntity(self, expr):
    # GeometryEntity is based on Tuple but should not print like a Tuple
    return self.emptyPrinter(expr)

sympy.sympy.printing.pretty.pretty._print_polylog

def _print_polylog(self, e):
    subscript = self._print(e.args[0])
    if self._use_unicode and is_subscriptable_in_unicode(subscript):
        return self._print_Function(Function('Li_%s' % subscript)(e.args[1]))
    return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_lerchphi

def _print_lerchphi(self, e):
    func_name = greek_unicode['Phi'] if self._use_unicode else 'lerchphi'
    return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_dirichlet_eta

def _print_dirichlet_eta(self, e):
    func_name = greek_unicode['eta'] if self._use_unicode else 'dirichlet_eta'
    return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_Heaviside

def _print_Heaviside(self, e):
    func_name = greek_unicode['theta'] if self._use_unicode else 'Heaviside'
    if e.args[1] is S.Half:
        pform = prettyForm(*self._print(e.args[0]).parens())
        pform = prettyForm(*pform.left(func_name))
        return pform
    else:
        return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_Reals

def _print_Reals(self, e):
    if self._use_unicode:
        return self._print_Atom(e)
    else:
        inf_list = ['-oo', 'oo']
        return self._print_seq(inf_list, '(', ')')

sympy.sympy.printing.pretty.pretty._print_fresnels

def _print_fresnels(self, e):
    return self._print_Function(e, func_name="S")

sympy.sympy.printing.pretty.pretty._print_fresnelc

def _print_fresnelc(self, e):
    return self._print_Function(e, func_name="C")

sympy.sympy.printing.pretty.pretty._print_airyai

def _print_airyai(self, e):
    return self._print_Function(e, func_name="Ai")

sympy.sympy.printing.pretty.pretty._print_airybi

def _print_airybi(self, e):
    return self._print_Function(e, func_name="Bi")

sympy.sympy.printing.pretty.pretty._print_airyaiprime

def _print_airyaiprime(self, e):
    return self._print_Function(e, func_name="Ai'")

sympy.sympy.printing.pretty.pretty._print_airybiprime

def _print_airybiprime(self, e):
    return self._print_Function(e, func_name="Bi'")

sympy.sympy.printing.pretty.pretty._print_LambertW

def _print_LambertW(self, e):
    return self._print_Function(e, func_name="W")

sympy.sympy.printing.pretty.pretty._print_Covariance

def _print_Covariance(self, e):
    return self._print_Function(e, func_name="Cov")

sympy.sympy.printing.pretty.pretty._print_Variance

def _print_Variance(self, e):
    return self._print_Function(e, func_name="Var")

sympy.sympy.printing.pretty.pretty._print_Probability

def _print_Probability(self, e):
    return self._print_Function(e, func_name="P")

sympy.sympy.printing.pretty.pretty._print_Expectation

def _print_Expectation(self, e):
    return self._print_Function(e, func_name="E", left='[', right=']')

sympy.sympy.printing.pretty.pretty._print_Lambda

def _print_Lambda(self, e):
    expr = e.expr
    sig = e.signature
    if self._use_unicode:
        arrow = f" {pretty_atom('ArrowFromBar')} "
    else:
        arrow = " -> "
    if len(sig) == 1 and sig[0].is_symbol:
        sig = sig[0]
    var_form = self._print(sig)

    return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)

sympy.sympy.printing.pretty.pretty._print_Order

def _print_Order(self, expr):
    pform = self._print(expr.expr)
    if (expr.point and any(p != S.Zero for p in expr.point)) or \
       len(expr.variables) > 1:
        pform = prettyForm(*pform.right("; "))
        if len(expr.variables) > 1:
            pform = prettyForm(*pform.right(self._print(expr.variables)))
        elif len(expr.variables):
            pform = prettyForm(*pform.right(self._print(expr.variables[0])))
        if self._use_unicode:
            pform = prettyForm(*pform.right(f" {pretty_atom('Arrow')} "))
        else:
            pform = prettyForm(*pform.right(" -> "))
        if len(expr.point) > 1:
            pform = prettyForm(*pform.right(self._print(expr.point)))
        else:
            pform = prettyForm(*pform.right(self._print(expr.point[0])))
    pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left("O"))
    return pform

sympy.sympy.printing.pretty.pretty._print_subfactorial

def _print_subfactorial(self, e):
    x = e.args[0]
    pform = self._print(x)
    # Add parentheses if needed
    if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
        pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left('!'))
    return pform

sympy.sympy.printing.pretty.pretty._print_SingularityFunction

def _print_SingularityFunction(self, e):
    if self._use_unicode:
        shift = self._print(e.args[0]-e.args[1])
        n = self._print(e.args[2])
        base = prettyForm("<")
        base = prettyForm(*base.right(shift))
        base = prettyForm(*base.right(">"))
        pform = base**n
        return pform
    else:
        n = self._print(e.args[2])
        shift = self._print(e.args[0]-e.args[1])
        base = self._print_seq(shift, "<", ">", ' ')
        return base**n

sympy.sympy.printing.pretty.pretty._print_beta

def _print_beta(self, e):
    func_name = greek_unicode['Beta'] if self._use_unicode else 'B'
    return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_gamma

def _print_gamma(self, e):
    func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
    return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_uppergamma

def _print_uppergamma(self, e):
    func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
    return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_lowergamma

def _print_lowergamma(self, e):
    func_name = greek_unicode['gamma'] if self._use_unicode else 'lowergamma'
    return self._print_Function(e, func_name=func_name)

sympy.sympy.printing.pretty.pretty._print_DiracDelta

def _print_DiracDelta(self, e):
    if self._use_unicode:
        if len(e.args) == 2:
            a = prettyForm(greek_unicode['delta'])
            b = self._print(e.args[1])
            b = prettyForm(*b.parens())
            c = self._print(e.args[0])
            c = prettyForm(*c.parens())
            pform = a**b
            pform = prettyForm(*pform.right(' '))
            pform = prettyForm(*pform.right(c))
            return pform
        pform = self._print(e.args[0])
        pform = prettyForm(*pform.parens())
        pform = prettyForm(*pform.left(greek_unicode['delta']))
        return pform
    else:
        return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_expint

def _print_expint(self, e):
    subscript = self._print(e.args[0])
    if self._use_unicode and is_subscriptable_in_unicode(subscript):
        return self._print_Function(Function('E_%s' % subscript)(e.args[1]))
    return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_Chi

def _print_Chi(self, e):
    # This needs a special case since otherwise it comes out as greek
    # letter chi...
    prettyFunc = prettyForm("Chi")
    prettyArgs = prettyForm(*self._print_seq(e.args).parens())

    pform = prettyForm(
        binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))

    # store pform parts so it can be reassembled e.g. when powered
    pform.prettyFunc = prettyFunc
    pform.prettyArgs = prettyArgs

    return pform

sympy.sympy.printing.pretty.pretty._print_elliptic_e

def _print_elliptic_e(self, e):
    pforma0 = self._print(e.args[0])
    if len(e.args) == 1:
        pform = pforma0
    else:
        pforma1 = self._print(e.args[1])
        pform = self._hprint_vseparator(pforma0, pforma1)
    pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left('E'))
    return pform

sympy.sympy.printing.pretty.pretty._print_factorial

def _print_factorial(self, e):
    x = e.args[0]
    pform = self._print(x)
    # Add parentheses if needed
    if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
        pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.right('!'))
    return pform

sympy.sympy.printing.pretty.pretty._print_elliptic_k

def _print_elliptic_k(self, e):
    pform = self._print(e.args[0])
    pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left('K'))
    return pform

sympy.sympy.printing.pretty.pretty._print_elliptic_f

def _print_elliptic_f(self, e):
    pforma0 = self._print(e.args[0])
    pforma1 = self._print(e.args[1])
    pform = self._hprint_vseparator(pforma0, pforma1)
    pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left('F'))
    return pform

sympy.sympy.printing.pretty.pretty._print_elliptic_pi

def _print_elliptic_pi(self, e):
    name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
    pforma0 = self._print(e.args[0])
    pforma1 = self._print(e.args[1])
    if len(e.args) == 2:
        pform = self._hprint_vseparator(pforma0, pforma1)
    else:
        pforma2 = self._print(e.args[2])
        pforma = self._hprint_vseparator(pforma1, pforma2, ifascii_nougly=False)
        pforma = prettyForm(*pforma.left('; '))
        pform = prettyForm(*pforma.left(pforma0))
    pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left(name))
    return pform

sympy.sympy.printing.pretty.pretty._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_symbol('phi'))
    return self._print(Symbol("GoldenRatio"))

sympy.sympy.printing.pretty.pretty._print_EulerGamma

def _print_EulerGamma(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_symbol('gamma'))
    return self._print(Symbol("EulerGamma"))

sympy.sympy.printing.pretty.pretty._print_Catalan

def _print_Catalan(self, expr):
    return self._print(Symbol("G"))

sympy.sympy.printing.pretty.pretty._print_Mod

def _print_Mod(self, expr):
    pform = self._print(expr.args[0])
    if pform.binding > prettyForm.MUL:
        pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.right(' mod '))
    pform = prettyForm(*pform.right(self._print(expr.args[1])))
    pform.binding = prettyForm.OPEN
    return pform

sympy.sympy.printing.pretty.pretty._print_Add

def _print_Add(self, expr, order=None):
    terms = self._as_ordered_terms(expr, order=order)
    pforms, indices = [], []

    def pretty_negative(pform, index):
        """Prepend a minus sign to a pretty form. """
        #TODO: Move this code to prettyForm
        if index == 0:
            if pform.height() > 1:
                pform_neg = '- '
            else:
                pform_neg = '-'
        else:
            pform_neg = ' - '

        if (pform.binding > prettyForm.NEG
            or pform.binding == prettyForm.ADD):
            p = stringPict(*pform.parens())
        else:
            p = pform
        p = stringPict.next(pform_neg, p)
        # Lower the binding to NEG, even if it was higher. Otherwise, it
        # will print as a + ( - (b)), instead of a - (b).
        return prettyForm(binding=prettyForm.NEG, *p)

    for i, term in enumerate(terms):
        if term.is_Mul and term.could_extract_minus_sign():
            coeff, other = term.as_coeff_mul(rational=False)
            if coeff == -1:
                negterm = Mul(*other, evaluate=False)
            else:
                negterm = Mul(-coeff, *other, evaluate=False)
            pform = self._print(negterm)
            pforms.append(pretty_negative(pform, i))
        elif term.is_Rational and term.q > 1:
            pforms.append(None)
            indices.append(i)
        elif term.is_Number and term < 0:
            pform = self._print(-term)
            pforms.append(pretty_negative(pform, i))
        elif term.is_Relational:
            pforms.append(prettyForm(*self._print(term).parens()))
        else:
            pforms.append(self._print(term))

    if indices:
        large = True

        for pform in pforms:
            if pform is not None and pform.height() > 1:
                break
        else:
            large = False

        for i in indices:
            term, negative = terms[i], False

            if term < 0:
                term, negative = -term, True

            if large:
                pform = prettyForm(str(term.p))/prettyForm(str(term.q))
            else:
                pform = self._print(term)

            if negative:
                pform = pretty_negative(pform, i)

            pforms[i] = pform

    return prettyForm.__add__(*pforms)

sympy.sympy.printing.pretty.pretty._print_factorial2

def _print_factorial2(self, e):
    x = e.args[0]
    pform = self._print(x)
    # Add parentheses if needed
    if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
        pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.right('!!'))
    return pform

sympy.sympy.printing.pretty.pretty._print_Mul

def _print_Mul(self, product):
    from sympy.physics.units import Quantity

    # Check for unevaluated Mul. In this case we need to make sure the
    # identities are visible, multiple Rational factors are not combined
    # etc so we display in a straight-forward form that fully preserves all
    # args and their order.
    args = product.args
    if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
        strargs = list(map(self._print, args))
        # XXX: This is a hack to work around the fact that
        # prettyForm.__mul__ absorbs a leading -1 in the args. Probably it
        # would be better to fix this in prettyForm.__mul__ instead.
        negone = strargs[0] == '-1'
        if negone:
            strargs[0] = prettyForm('1', 0, 0)
        obj = prettyForm.__mul__(*strargs)
        if negone:
            obj = prettyForm('-' + obj.s, obj.baseline, obj.binding)
        return obj

    a = []  # items in the numerator
    b = []  # items that are in the denominator (if any)

    if self.order not in ('old', 'none'):
        args = product.as_ordered_factors()
    else:
        args = list(product.args)

    # If quantities are present append them at the back
    args = sorted(args, key=lambda x: isinstance(x, Quantity) or
                 (isinstance(x, Pow) and isinstance(x.base, Quantity)))

    # Gather terms for numerator/denominator
    for item in args:
        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
            if item.exp != -1:
                b.append(Pow(item.base, -item.exp, evaluate=False))
            else:
                b.append(Pow(item.base, -item.exp))
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append( Rational(item.p) )
            if item.q != 1:
                b.append( Rational(item.q) )
        else:
            a.append(item)

    # Convert to pretty forms. Parentheses are added by `__mul__`.
    a = [self._print(ai) for ai in a]
    b = [self._print(bi) for bi in b]

    # Construct a pretty form
    if len(b) == 0:
        return prettyForm.__mul__(*a)
    else:
        if len(a) == 0:
            a.append( self._print(S.One) )
        return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)

sympy.sympy.printing.pretty.pretty._print_binomial

def _print_binomial(self, e):
    n, k = e.args

    n_pform = self._print(n)
    k_pform = self._print(k)

    bar = ' '*max(n_pform.width(), k_pform.width())

    pform = prettyForm(*k_pform.above(bar))
    pform = prettyForm(*pform.above(n_pform))
    pform = prettyForm(*pform.parens('(', ')'))

    pform.baseline = (pform.baseline + 1)//2

    return pform

sympy.sympy.printing.pretty.pretty._print_Pow

def _print_Pow(self, power):
    from sympy.simplify.simplify import fraction
    b, e = power.as_base_exp()
    if power.is_commutative:
        if e is S.NegativeOne:
            return prettyForm("1")/self._print(b)
        n, d = fraction(e)
        if n is S.One and d.is_Atom and not e.is_Integer and (e.is_Rational or d.is_Symbol) \
                and self._settings['root_notation']:
            return self._print_nth_root(b, d)
        if e.is_Rational and e < 0:
            return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))

    if b.is_Relational:
        return prettyForm(*self._print(b).parens()).__pow__(self._print(e))

    return self._print(b)**self._print(e)

sympy.sympy.printing.pretty.pretty._print_UnevaluatedExpr

def _print_UnevaluatedExpr(self, expr):
    return self._print(expr.args[0])

sympy.sympy.printing.pretty.pretty._print_Rational

def _print_Rational(self, expr):
    result = self.__print_numer_denom(expr.p, expr.q)

    if result is not None:
        return result
    else:
        return self.emptyPrinter(expr)

sympy.sympy.printing.pretty.pretty._print_ProductSet

def _print_ProductSet(self, p):
    if len(p.sets) >= 1 and not has_variety(p.sets):
        return self._print(p.sets[0]) ** self._print(len(p.sets))
    else:
        prod_char = pretty_atom('Multiplication') if self._use_unicode else 'x'
        return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
                               parenthesize=lambda set: set.is_Union or
                               set.is_Intersection or set.is_ProductSet)

sympy.sympy.printing.pretty.pretty._print_FiniteSet

def _print_FiniteSet(self, s):
    items = sorted(s.args, key=default_sort_key)
    return self._print_seq(items, '{', '}', ', ' )

sympy.sympy.printing.pretty.pretty._print_Range

def _print_Range(self, s):

    if self._use_unicode:
        dots = pretty_atom('Dots')
    else:
        dots = '...'

    if s.start.is_infinite and s.stop.is_infinite:
        if s.step.is_positive:
            printset = dots, -1, 0, 1, dots
        else:
            printset = dots, 1, 0, -1, dots
    elif s.start.is_infinite:
        printset = dots, s[-1] - s.step, s[-1]
    elif s.stop.is_infinite:
        it = iter(s)
        printset = next(it), next(it), dots
    elif len(s) > 4:
        it = iter(s)
        printset = next(it), next(it), dots, s[-1]
    else:
        printset = tuple(s)

    return self._print_seq(printset, '{', '}', ', ' )

sympy.sympy.printing.pretty.pretty._print_Interval

def _print_Interval(self, i):
    if i.start == i.end:
        return self._print_seq(i.args[:1], '{', '}')

    else:
        if i.left_open:
            left = '('
        else:
            left = '['

        if i.right_open:
            right = ')'
        else:
            right = ']'

        return self._print_seq(i.args[:2], left, right)

sympy.sympy.printing.pretty.pretty._print_Relational

def _print_Relational(self, e):
    op = prettyForm(' ' + xsym(e.rel_op) + ' ')

    l = self._print(e.lhs)
    r = self._print(e.rhs)
    pform = prettyForm(*stringPict.next(l, op, r), binding=prettyForm.OPEN)
    return pform

sympy.sympy.printing.pretty.pretty._print_Intersection

def _print_Intersection(self, u):

    delimiter = ' %s ' % pretty_atom('Intersection', 'n')

    return self._print_seq(u.args, None, None, delimiter,
                           parenthesize=lambda set: set.is_ProductSet or
                           set.is_Union or set.is_Complement)

sympy.sympy.printing.pretty.pretty._print_Union

def _print_Union(self, u):

    union_delimiter = ' %s ' % pretty_atom('Union', 'U')

    return self._print_seq(u.args, None, None, union_delimiter,
                           parenthesize=lambda set: set.is_ProductSet or
                           set.is_Intersection or set.is_Complement)

sympy.sympy.printing.pretty.pretty._print_SymmetricDifference

def _print_SymmetricDifference(self, u):
    if not self._use_unicode:
        raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")

    sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')

    return self._print_seq(u.args, None, None, sym_delimeter)

sympy.sympy.printing.pretty.pretty._print_Complement

def _print_Complement(self, u):

    delimiter = r' \ '

    return self._print_seq(u.args, None, None, delimiter,
         parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
                           or set.is_Union)

sympy.sympy.printing.pretty.pretty._print_ImageSet

def _print_ImageSet(self, ts):
    if self._use_unicode:
        inn = pretty_atom("SmallElementOf")
    else:
        inn = 'in'
    fun = ts.lamda
    sets = ts.base_sets
    signature = fun.signature
    expr = self._print(fun.expr)

    # TODO: the stuff to the left of the | and the stuff to the right of
    # the | should have independent baselines, that way something like
    # ImageSet(Lambda(x, 1/x**2), S.Naturals) prints the "x in N" part
    # centered on the right instead of aligned with the fraction bar on
    # the left. The same also applies to ConditionSet and ComplexRegion
    if len(signature) == 1:
        S = self._print_seq((signature[0], inn, sets[0]),
                            delimiter=' ')
        return self._hprint_vseparator(expr, S,
                                       left='{', right='}',
                                       ifascii_nougly=True, delimiter=' ')
    else:
        pargs = tuple(j for var, setv in zip(signature, sets) for j in
                      (var, ' ', inn, ' ', setv, ", "))
        S = self._print_seq(pargs[:-1], delimiter='')
        return self._hprint_vseparator(expr, S,
                                       left='{', right='}',
                                       ifascii_nougly=True, delimiter=' ')

sympy.sympy.printing.pretty.pretty._print_ConditionSet

def _print_ConditionSet(self, ts):
    if self._use_unicode:
        inn = pretty_atom('SmallElementOf')
        # using _and because and is a keyword and it is bad practice to
        # overwrite them
        _and = pretty_atom('And')
    else:
        inn = 'in'
        _and = 'and'

    variables = self._print_seq(Tuple(ts.sym))
    as_expr = getattr(ts.condition, 'as_expr', None)
    if as_expr is not None:
        cond = self._print(ts.condition.as_expr())
    else:
        cond = self._print(ts.condition)
        if self._use_unicode:
            cond = self._print(cond)
            cond = prettyForm(*cond.parens())

    if ts.base_set is S.UniversalSet:
        return self._hprint_vseparator(variables, cond, left="{",
                                       right="}", ifascii_nougly=True,
                                       delimiter=' ')

    base = self._print(ts.base_set)
    C = self._print_seq((variables, inn, base, _and, cond),
                        delimiter=' ')
    return self._hprint_vseparator(variables, C, left="{", right="}",
                                   ifascii_nougly=True, delimiter=' ')

sympy.sympy.printing.pretty.pretty._print_Not

def _print_Not(self, e):
    from sympy.logic.boolalg import (Equivalent, Implies)
    if self._use_unicode:
        arg = e.args[0]
        pform = self._print(arg)
        if isinstance(arg, Equivalent):
            return self._print_Equivalent(arg, altchar=pretty_atom('NotEquiv'))
        if isinstance(arg, Implies):
            return self._print_Implies(arg, altchar=pretty_atom('NotArrow'))

        if arg.is_Boolean and not arg.is_Not:
            pform = prettyForm(*pform.parens())

        return prettyForm(*pform.left(pretty_atom('Not')))
    else:
        return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_ComplexRegion

def _print_ComplexRegion(self, ts):
    if self._use_unicode:
        inn = pretty_atom('SmallElementOf')
    else:
        inn = 'in'
    variables = self._print_seq(ts.variables)
    expr = self._print(ts.expr)
    prodsets = self._print(ts.sets)

    C = self._print_seq((variables, inn, prodsets),
                        delimiter=' ')
    return self._hprint_vseparator(expr, C, left="{", right="}",
                                   ifascii_nougly=True, delimiter=' ')

sympy.sympy.printing.pretty.pretty._print_Contains

def _print_Contains(self, e):
    var, set = e.args
    if self._use_unicode:
        el = f" {pretty_atom('ElementOf')} "
        return prettyForm(*stringPict.next(self._print(var),
                                           el, self._print(set)), binding=8)
    else:
        return prettyForm(sstr(e))

sympy.sympy.printing.pretty.pretty._print_FourierSeries

def _print_FourierSeries(self, s):
    if s.an.formula is S.Zero and s.bn.formula is S.Zero:
        return self._print(s.a0)
    if self._use_unicode:
        dots = pretty_atom('Dots')
    else:
        dots = '...'
    return self._print_Add(s.truncate()) + self._print(dots)

sympy.sympy.printing.pretty.pretty._print_FormalPowerSeries

def _print_FormalPowerSeries(self, s):
    return self._print_Add(s.infinite)

sympy.sympy.printing.pretty.pretty._print_SetExpr

def _print_SetExpr(self, se):
    pretty_set = prettyForm(*self._print(se.set).parens())
    pretty_name = self._print(Symbol("SetExpr"))
    return prettyForm(*pretty_name.right(pretty_set))

sympy.sympy.printing.pretty.pretty._print_SeqFormula

def _print_SeqFormula(self, s):
    if self._use_unicode:
        dots = pretty_atom('Dots')
    else:
        dots = '...'

    if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
        raise NotImplementedError("Pretty printing of sequences with symbolic bound not implemented")

    if s.start is S.NegativeInfinity:
        stop = s.stop
        printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
            s.coeff(stop - 1), s.coeff(stop))
    elif s.stop is S.Infinity or s.length > 4:
        printset = s[:4]
        printset.append(dots)
        printset = tuple(printset)
    else:
        printset = tuple(s)
    return self._print_list(printset)

sympy.sympy.printing.pretty.pretty._print_list

def _print_list(self, l):
    return self._print_seq(l, '[', ']')

sympy.sympy.printing.pretty.pretty._print_tuple

def _print_tuple(self, t):
    if len(t) == 1:
        ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
        return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
    else:
        return self._print_seq(t, '(', ')')

sympy.sympy.printing.pretty.pretty._print_Tuple

def _print_Tuple(self, expr):
    return self._print_tuple(expr)

sympy.sympy.printing.pretty.pretty._print_dict

def _print_dict(self, d):
    keys = sorted(d.keys(), key=default_sort_key)
    items = []

    for k in keys:
        K = self._print(k)
        V = self._print(d[k])
        s = prettyForm(*stringPict.next(K, ': ', V))

        items.append(s)

    return self._print_seq(items, '{', '}')

sympy.sympy.printing.pretty.pretty._print_Dict

def _print_Dict(self, d):
    return self._print_dict(d)

sympy.sympy.printing.pretty.pretty._print_set

def _print_set(self, s):
    if not s:
        return prettyForm('set()')
    items = sorted(s, key=default_sort_key)
    pretty = self._print_seq(items)
    pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
    return pretty

sympy.sympy.printing.pretty.pretty._print_frozenset

def _print_frozenset(self, s):
    if not s:
        return prettyForm('frozenset()')
    items = sorted(s, key=default_sort_key)
    pretty = self._print_seq(items)
    pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
    pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
    pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
    return pretty

sympy.sympy.printing.pretty.pretty._print_UniversalSet

def _print_UniversalSet(self, s):
    if self._use_unicode:
        return prettyForm(pretty_atom('Universe'))
    else:
        return prettyForm('UniversalSet')

sympy.sympy.printing.pretty.pretty._print_PolyElement

def _print_PolyElement(self, poly):
    return prettyForm(sstr(poly))

sympy.sympy.printing.pretty.pretty._print_FracElement

def _print_FracElement(self, frac):
    return prettyForm(sstr(frac))

sympy.sympy.printing.pretty.pretty._print_ComplexRootOf

def _print_ComplexRootOf(self, expr):
    args = [self._print_Add(expr.expr, order='lex'), expr.index]
    pform = prettyForm(*self._print_seq(args).parens())
    pform = prettyForm(*pform.left('CRootOf'))
    return pform

sympy.sympy.printing.pretty.pretty._print_RootSum

def _print_RootSum(self, expr):
    args = [self._print_Add(expr.expr, order='lex')]

    if expr.fun is not S.IdentityFunction:
        args.append(self._print(expr.fun))

    pform = prettyForm(*self._print_seq(args).parens())
    pform = prettyForm(*pform.left('RootSum'))

    return pform

sympy.sympy.printing.pretty.pretty._print_FiniteField

def _print_FiniteField(self, expr):
    if self._use_unicode:
        form = f"{pretty_atom('Integers')}_%d"
    else:
        form = 'GF(%d)'

    return prettyForm(pretty_symbol(form % expr.mod))

sympy.sympy.printing.pretty.pretty._print_IntegerRing

def _print_IntegerRing(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_atom('Integers'))
    else:
        return prettyForm('ZZ')

sympy.sympy.printing.pretty.pretty._print_RationalField

def _print_RationalField(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_atom('Rationals'))
    else:
        return prettyForm('QQ')

sympy.sympy.printing.pretty.pretty._print_RealField

def _print_RealField(self, domain):
    if self._use_unicode:
        prefix = pretty_atom("Reals")
    else:
        prefix = 'RR'

    if domain.has_default_precision:
        return prettyForm(prefix)
    else:
        return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))

sympy.sympy.printing.pretty.pretty._print_PolynomialRing

def _print_PolynomialRing(self, expr):
    args = list(expr.symbols)

    if not expr.order.is_default:
        order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
        args.append(order)

    pform = self._print_seq(args, '[', ']')
    pform = prettyForm(*pform.left(self._print(expr.domain)))

    return pform

sympy.sympy.printing.pretty.pretty._print_FractionField

def _print_FractionField(self, expr):
    args = list(expr.symbols)

    if not expr.order.is_default:
        order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
        args.append(order)

    pform = self._print_seq(args, '(', ')')
    pform = prettyForm(*pform.left(self._print(expr.domain)))

    return pform

sympy.sympy.printing.pretty.pretty._print_PolynomialRingBase

def _print_PolynomialRingBase(self, expr):
    g = expr.symbols
    if str(expr.order) != str(expr.default_order):
        g = g + ("order=" + str(expr.order),)
    pform = self._print_seq(g, '[', ']')
    pform = prettyForm(*pform.left(self._print(expr.domain)))

    return pform

sympy.sympy.printing.pretty.pretty._print_GroebnerBasis

def _print_GroebnerBasis(self, basis):
    exprs = [ self._print_Add(arg, order=basis.order)
              for arg in basis.exprs ]
    exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))

    gens = [ self._print(gen) for gen in basis.gens ]

    domain = prettyForm(
        *prettyForm("domain=").right(self._print(basis.domain)))
    order = prettyForm(
        *prettyForm("order=").right(self._print(basis.order)))

    pform = self.join(", ", [exprs] + gens + [domain, order])

    pform = prettyForm(*pform.parens())
    pform = prettyForm(*pform.left(basis.__class__.__name__))

    return pform

sympy.sympy.printing.pretty.pretty._print_Subs

def _print_Subs(self, e):
    pform = self._print(e.expr)
    pform = prettyForm(*pform.parens())

    h = pform.height() if pform.height() > 1 else 2
    rvert = stringPict(vobj('|', h), baseline=pform.baseline)
    pform = prettyForm(*pform.right(rvert))

    b = pform.baseline
    pform.baseline = pform.height() - 1
    pform = prettyForm(*pform.right(self._print_seq([
        self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
            delimiter='') for v in zip(e.variables, e.point) ])))

    pform.baseline = b
    return pform

sympy.sympy.printing.pretty.pretty._print_euler

def _print_euler(self, e):
    return self._print_number_function(e, "E")

sympy.sympy.printing.pretty.pretty._print_catalan

def _print_catalan(self, e):
    return self._print_number_function(e, "C")

sympy.sympy.printing.pretty.pretty._print_bernoulli

def _print_bernoulli(self, e):
    return self._print_number_function(e, "B")

sympy.sympy.printing.pretty.pretty._print_lucas

def _print_lucas(self, e):
    return self._print_number_function(e, "L")

sympy.sympy.printing.pretty.pretty._print_fibonacci

def _print_fibonacci(self, e):
    return self._print_number_function(e, "F")

sympy.sympy.printing.pretty.pretty._print_tribonacci

def _print_tribonacci(self, e):
    return self._print_number_function(e, "T")

sympy.sympy.printing.pretty.pretty._print_stieltjes

def _print_stieltjes(self, e):
    if self._use_unicode:
        return self._print_number_function(e, greek_unicode['gamma'])
    else:
        return self._print_number_function(e, "stieltjes")

sympy.sympy.printing.pretty.pretty._print_KroneckerDelta

def _print_KroneckerDelta(self, e):
    pform = self._print(e.args[0])
    pform = prettyForm(*pform.right(prettyForm(',')))
    pform = prettyForm(*pform.right(self._print(e.args[1])))
    if self._use_unicode:
        a = stringPict(pretty_symbol('delta'))
    else:
        a = stringPict('d')
    b = pform
    top = stringPict(*b.left(' '*a.width()))
    bot = stringPict(*a.right(' '*b.width()))
    return prettyForm(binding=prettyForm.POW, *bot.below(top))

sympy.sympy.printing.pretty.pretty._print_RandomDomain

def _print_RandomDomain(self, d):
    if hasattr(d, 'as_boolean'):
        pform = self._print('Domain: ')
        pform = prettyForm(*pform.right(self._print(d.as_boolean())))
        return pform
    elif hasattr(d, 'set'):
        pform = self._print('Domain: ')
        pform = prettyForm(*pform.right(self._print(d.symbols)))
        pform = prettyForm(*pform.right(self._print(' in ')))
        pform = prettyForm(*pform.right(self._print(d.set)))
        return pform
    elif hasattr(d, 'symbols'):
        pform = self._print('Domain on ')
        pform = prettyForm(*pform.right(self._print(d.symbols)))
        return pform
    else:
        return self._print(None)

sympy.sympy.printing.pretty.pretty._print_And

def _print_And(self, e):
    if self._use_unicode:
        return self.__print_Boolean(e, pretty_atom('And'))
    else:
        return self._print_Function(e, sort=True)

sympy.sympy.printing.pretty.pretty._print_Object

def _print_Object(self, object):
    return self._print(pretty_symbol(object.name))

sympy.sympy.printing.pretty.pretty._print_NamedMorphism

def _print_NamedMorphism(self, morphism):
    pretty_name = self._print(pretty_symbol(morphism.name))
    pretty_morphism = self._print_Morphism(morphism)
    return prettyForm(pretty_name.right(":", pretty_morphism)[0])

sympy.sympy.printing.pretty.pretty._print_IdentityMorphism

def _print_IdentityMorphism(self, morphism):
    from sympy.categories import NamedMorphism
    return self._print_NamedMorphism(
        NamedMorphism(morphism.domain, morphism.codomain, "id"))

sympy.sympy.printing.pretty.pretty._print_CompositeMorphism

def _print_CompositeMorphism(self, morphism):

    circle = xsym(".")

    # All components of the morphism have names and it is thus
    # possible to build the name of the composite.
    component_names_list = [pretty_symbol(component.name) for
                            component in morphism.components]
    component_names_list.reverse()
    component_names = circle.join(component_names_list) + ":"

    pretty_name = self._print(component_names)
    pretty_morphism = self._print_Morphism(morphism)
    return prettyForm(pretty_name.right(pretty_morphism)[0])

sympy.sympy.printing.pretty.pretty._print_Or

def _print_Or(self, e):
    if self._use_unicode:
        return self.__print_Boolean(e, pretty_atom('Or'))
    else:
        return self._print_Function(e, sort=True)

sympy.sympy.printing.pretty.pretty._print_Category

def _print_Category(self, category):
    return self._print(pretty_symbol(category.name))

sympy.sympy.printing.pretty.pretty._print_Diagram

def _print_Diagram(self, diagram):
    if not diagram.premises:
        # This is an empty diagram.
        return self._print(S.EmptySet)

    pretty_result = self._print(diagram.premises)
    if diagram.conclusions:
        results_arrow = " %s " % xsym("==>")

        pretty_conclusions = self._print(diagram.conclusions)[0]
        pretty_result = pretty_result.right(
            results_arrow, pretty_conclusions)

    return prettyForm(pretty_result[0])

sympy.sympy.printing.pretty.pretty._print_DiagramGrid

def _print_DiagramGrid(self, grid):
    from sympy.matrices import Matrix
    matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
                      for j in range(grid.width)]
                     for i in range(grid.height)])
    return self._print_matrix_contents(matrix)

sympy.sympy.printing.pretty.pretty._print_SubModule

def _print_SubModule(self, M):
    gens = [[M.ring.to_sympy(g) for g in gen] for gen in M.gens]
    return self._print_seq(gens, '<', '>')

sympy.sympy.printing.pretty.pretty._print_FreeModule

def _print_FreeModule(self, M):
    return self._print(M.ring)**self._print(M.rank)

sympy.sympy.printing.pretty.pretty._print_ModuleImplementedIdeal

def _print_ModuleImplementedIdeal(self, M):
    sym = M.ring.to_sympy
    return self._print_seq([sym(x) for [x] in M._module.gens], '<', '>')

sympy.sympy.printing.pretty.pretty._print_QuotientRing

def _print_QuotientRing(self, R):
    return self._print(R.ring) / self._print(R.base_ideal)

sympy.sympy.printing.pretty.pretty._print_QuotientRingElement

def _print_QuotientRingElement(self, R):
    return self._print(R.ring.to_sympy(R)) + self._print(R.ring.base_ideal)

sympy.sympy.printing.pretty.pretty._print_QuotientModule

def _print_QuotientModule(self, M):
    return self._print(M.base) / self._print(M.killed_module)

sympy.sympy.printing.pretty.pretty._print_MatrixHomomorphism

def _print_MatrixHomomorphism(self, h):
    matrix = self._print(h._sympy_matrix())
    matrix.baseline = matrix.height() // 2
    pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
        ' %s> ' % hobj('-', 2), self._print(h.codomain)))
    return pform

sympy.sympy.printing.pretty.pretty._print_Xor

def _print_Xor(self, e):
    if self._use_unicode:
        return self.__print_Boolean(e, pretty_atom("Xor"))
    else:
        return self._print_Function(e, sort=True)

sympy.sympy.printing.pretty.pretty._print_Manifold

def _print_Manifold(self, manifold):
    return self._print(manifold.name)

sympy.sympy.printing.pretty.pretty._print_Patch

def _print_Patch(self, patch):
    return self._print(patch.name)

sympy.sympy.printing.pretty.pretty._print_CoordSystem

def _print_CoordSystem(self, coords):
    return self._print(coords.name)

sympy.sympy.printing.pretty.pretty._print_BaseScalarField

def _print_BaseScalarField(self, field):
    string = field._coord_sys.symbols[field._index].name
    return self._print(pretty_symbol(string))

sympy.sympy.printing.pretty.pretty._print_Differential

def _print_Differential(self, diff):
    if self._use_unicode:
        d = pretty_atom('Differential')
    else:
        d = 'd'
    field = diff._form_field
    if hasattr(field, '_coord_sys'):
        string = field._coord_sys.symbols[field._index].name
        return self._print(d + ' ' + pretty_symbol(string))
    else:
        pform = self._print(field)
        pform = prettyForm(*pform.parens())
        return prettyForm(*pform.left(d))

sympy.sympy.printing.pretty.pretty._print_Tr

def _print_Tr(self, p):
    #TODO: Handle indices
    pform = self._print(p.args[0])
    pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
    pform = prettyForm(*pform.right(')'))
    return pform

sympy.sympy.printing.pretty.pretty._print_primenu

def _print_primenu(self, e):
    pform = self._print(e.args[0])
    pform = prettyForm(*pform.parens())
    if self._use_unicode:
        pform = prettyForm(*pform.left(greek_unicode['nu']))
    else:
        pform = prettyForm(*pform.left('nu'))
    return pform

sympy.sympy.printing.pretty.pretty._print_primeomega

def _print_primeomega(self, e):
    pform = self._print(e.args[0])
    pform = prettyForm(*pform.parens())
    if self._use_unicode:
        pform = prettyForm(*pform.left(greek_unicode['Omega']))
    else:
        pform = prettyForm(*pform.left('Omega'))
    return pform

sympy.sympy.printing.pretty.pretty._print_Quantity

def _print_Quantity(self, e):
    if e.name.name == 'degree':
        if self._use_unicode:
            pform = self._print(pretty_atom('Degree'))
        else:
            pform = self._print(chr(176))
        return pform
    else:
        return self.emptyPrinter(e)

sympy.sympy.printing.pretty.pretty._print_Nand

def _print_Nand(self, e):
    if self._use_unicode:
        return self.__print_Boolean(e, pretty_atom('Nand'))
    else:
        return self._print_Function(e, sort=True)

sympy.sympy.printing.pretty.pretty._print_AssignmentBase

def _print_AssignmentBase(self, e):

    op = prettyForm(' ' + xsym(e.op) + ' ')

    l = self._print(e.lhs)
    r = self._print(e.rhs)
    pform = prettyForm(*stringPict.next(l, op, r))
    return pform

sympy.sympy.printing.pretty.pretty._print_Str

def _print_Str(self, s):
    return self._print(s.name)

sympy.sympy.printing.pretty.pretty._print_Nor

def _print_Nor(self, e):
    if self._use_unicode:
        return self.__print_Boolean(e, pretty_atom('Nor'))
    else:
        return self._print_Function(e, sort=True)

sympy.sympy.printing.pretty.pretty._print_Implies

def _print_Implies(self, e, altchar=None):
    if self._use_unicode:
        return self.__print_Boolean(e, altchar or pretty_atom('Arrow'), sort=False)
    else:
        return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_Equivalent

def _print_Equivalent(self, e, altchar=None):
    if self._use_unicode:
        return self.__print_Boolean(e, altchar or pretty_atom('Equiv'))
    else:
        return self._print_Function(e, sort=True)

sympy.sympy.printing.pretty.pretty._print_conjugate

def _print_conjugate(self, e):
    pform = self._print(e.args[0])
    return prettyForm( *pform.above( hobj('_', pform.width())) )

sympy.sympy.printing.pretty.pretty._print_Abs

def _print_Abs(self, e):
    pform = self._print(e.args[0])
    pform = prettyForm(*pform.parens('|', '|'))
    return pform

sympy.sympy.printing.pretty.pretty._print_floor

def _print_floor(self, e):
    if self._use_unicode:
        pform = self._print(e.args[0])
        pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
        return pform
    else:
        return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_ceiling

def _print_ceiling(self, e):
    if self._use_unicode:
        pform = self._print(e.args[0])
        pform = prettyForm(*pform.parens('lceil', 'rceil'))
        return pform
    else:
        return self._print_Function(e)

sympy.sympy.printing.pretty.pretty._print_Derivative

def _print_Derivative(self, deriv):
    if requires_partial(deriv.expr) and self._use_unicode:
        deriv_symbol = U('PARTIAL DIFFERENTIAL')
    else:
        deriv_symbol = r'd'
    x = None
    count_total_deriv = 0

    for sym, num in reversed(deriv.variable_count):
        s = self._print(sym)
        ds = prettyForm(*s.left(deriv_symbol))
        count_total_deriv += num

        if (not num.is_Integer) or (num > 1):
            ds = ds**prettyForm(str(num))

        if x is None:
            x = ds
        else:
            x = prettyForm(*x.right(' '))
            x = prettyForm(*x.right(ds))

    f = prettyForm(
        binding=prettyForm.FUNC, *self._print(deriv.expr).parens())

    pform = prettyForm(deriv_symbol)

    if (count_total_deriv > 1) != False:
        pform = pform**prettyForm(str(count_total_deriv))

    pform = prettyForm(*pform.below(stringPict.LINE, x))
    pform.baseline = pform.baseline + 1
    pform = prettyForm(*stringPict.next(pform, f))
    pform.binding = prettyForm.MUL

    return pform

sympy.sympy.printing.pretty.pretty._print_Cycle

def _print_Cycle(self, dc):
    from sympy.combinatorics.permutations import Permutation, Cycle
    # for Empty Cycle
    if dc == Cycle():
        cyc = stringPict('')
        return prettyForm(*cyc.parens())

    dc_list = Permutation(dc.list()).cyclic_form
    # for Identity Cycle
    if dc_list == []:
        cyc = self._print(dc.size - 1)
        return prettyForm(*cyc.parens())

    cyc = stringPict('')
    for i in dc_list:
        l = self._print(str(tuple(i)).replace(',', ''))
        cyc = prettyForm(*cyc.right(l))
    return cyc

sympy.sympy.printing.pretty.pretty._print_Permutation

def _print_Permutation(self, expr):
    from sympy.combinatorics.permutations import Permutation, Cycle

    perm_cyclic = Permutation.print_cyclic
    if perm_cyclic is not None:
        sympy_deprecation_warning(
            f"""
            Setting Permutation.print_cyclic is deprecated. Instead use
            init_printing(perm_cyclic={perm_cyclic}).
            """,
            deprecated_since_version="1.6",
            active_deprecations_target="deprecated-permutation-print_cyclic",
            stacklevel=7,
        )
    else:
        perm_cyclic = self._settings.get("perm_cyclic", True)

    if perm_cyclic:
        return self._print_Cycle(Cycle(expr))

    lower = expr.array_form
    upper = list(range(len(lower)))

    result = stringPict('')
    first = True
    for u, l in zip(upper, lower):
        s1 = self._print(u)
        s2 = self._print(l)
        col = prettyForm(*s1.below(s2))
        if first:
            first = False
        else:
            col = prettyForm(*col.left(" "))
        result = prettyForm(*result.right(col))
    return prettyForm(*result.parens())

sympy.sympy.printing.pretty.pretty._print_Integral

def _print_Integral(self, integral):
    f = integral.function

    # Add parentheses if arg involves addition of terms and
    # create a pretty form for the argument
    prettyF = self._print(f)
    # XXX generalize parens
    if f.is_Add:
        prettyF = prettyForm(*prettyF.parens())

    # dx dy dz ...
    arg = prettyF
    for x in integral.limits:
        prettyArg = self._print(x[0])
        # XXX qparens (parens if needs-parens)
        if prettyArg.width() > 1:
            prettyArg = prettyForm(*prettyArg.parens())

        arg = prettyForm(*arg.right(' d', prettyArg))

    # \int \int \int ...
    firstterm = True
    s = None
    for lim in integral.limits:
        # Create bar based on the height of the argument
        h = arg.height()
        H = h + 2

        # XXX hack!
        ascii_mode = not self._use_unicode
        if ascii_mode:
            H += 2

        vint = vobj('int', H)

        # Construct the pretty form with the integral sign and the argument
        pform = prettyForm(vint)
        pform.baseline = arg.baseline + (
            H - h)//2    # covering the whole argument

        if len(lim) > 1:
            # Create pretty forms for endpoints, if definite integral.
            # Do not print empty endpoints.
            if len(lim) == 2:
                prettyA = prettyForm("")
                prettyB = self._print(lim[1])
            if len(lim) == 3:
                prettyA = self._print(lim[1])
                prettyB = self._print(lim[2])

            if ascii_mode:  # XXX hack
                # Add spacing so that endpoint can more easily be
                # identified with the correct integral sign
                spc = max(1, 3 - prettyB.width())
                prettyB = prettyForm(*prettyB.left(' ' * spc))

                spc = max(1, 4 - prettyA.width())
                prettyA = prettyForm(*prettyA.right(' ' * spc))

            pform = prettyForm(*pform.above(prettyB))
            pform = prettyForm(*pform.below(prettyA))

        if not ascii_mode:  # XXX hack
            pform = prettyForm(*pform.right(' '))

        if firstterm:
            s = pform   # first term
            firstterm = False
        else:
            s = prettyForm(*s.left(pform))

    pform = prettyForm(*arg.left(s))
    pform.binding = prettyForm.MUL
    return pform

sympy.sympy.printing.pretty.pretty._print_Product

def _print_Product(self, expr):
    func = expr.term
    pretty_func = self._print(func)

    horizontal_chr = xobj('_', 1)
    corner_chr = xobj('_', 1)
    vertical_chr = xobj('|', 1)

    if self._use_unicode:
        # use unicode corners
        horizontal_chr = xobj('-', 1)
        corner_chr = xobj('UpTack', 1)

    func_height = pretty_func.height()

    first = True
    max_upper = 0
    sign_height = 0

    for lim in expr.limits:
        pretty_lower, pretty_upper = self.__print_SumProduct_Limits(lim)

        width = (func_height + 2) * 5 // 3 - 2
        sign_lines = [horizontal_chr + corner_chr + (horizontal_chr * (width-2)) + corner_chr + horizontal_chr]
        for _ in range(func_height + 1):
            sign_lines.append(' ' + vertical_chr + (' ' * (width-2)) + vertical_chr + ' ')

        pretty_sign = stringPict('')
        pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))


        max_upper = max(max_upper, pretty_upper.height())

        if first:
            sign_height = pretty_sign.height()

        pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
        pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))

        if first:
            pretty_func.baseline = 0
            first = False

        height = pretty_sign.height()
        padding = stringPict('')
        padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
        pretty_sign = prettyForm(*pretty_sign.right(padding))

        pretty_func = prettyForm(*pretty_sign.right(pretty_func))

    pretty_func.baseline = max_upper + sign_height//2
    pretty_func.binding = prettyForm.MUL
    return pretty_func

sympy.sympy.printing.pretty.pretty.emptyPrinter

def emptyPrinter(self, expr):
    return prettyForm(str(expr))

sympy.sympy.printing.pretty.pretty._print_Sum

def _print_Sum(self, expr):
    ascii_mode = not self._use_unicode

    def asum(hrequired, lower, upper, use_ascii):
        def adjust(s, wid=None, how='<^>'):
            if not wid or len(s) > wid:
                return s
            need = wid - len(s)
            if how in ('<^>', "<") or how not in list('<^>'):
                return s + ' '*need
            half = need//2
            lead = ' '*half
            if how == ">":
                return " "*need + s
            return lead + s + ' '*(need - len(lead))

        h = max(hrequired, 2)
        d = h//2
        w = d + 1
        more = hrequired % 2

        lines = []
        if use_ascii:
            lines.append("_"*(w) + ' ')
            lines.append(r"\%s`" % (' '*(w - 1)))
            for i in range(1, d):
                lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
            if more:
                lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
            for i in reversed(range(1, d)):
                lines.append('%s/%s' % (' '*i, ' '*(w - i)))
            lines.append("/" + "_"*(w - 1) + ',')
            return d, h + more, lines, more
        else:
            w = w + more
            d = d + more
            vsum = vobj('sum', 4)
            lines.append("_"*(w))
            for i in range(0, d):
                lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
            for i in reversed(range(0, d)):
                lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
            lines.append(vsum[8]*(w))
            return d, h + 2*more, lines, more

    f = expr.function

    prettyF = self._print(f)

    if f.is_Add:  # add parens
        prettyF = prettyForm(*prettyF.parens())

    H = prettyF.height() + 2

    # \sum \sum \sum ...
    first = True
    max_upper = 0
    sign_height = 0

    for lim in expr.limits:
        prettyLower, prettyUpper = self.__print_SumProduct_Limits(lim)

        max_upper = max(max_upper, prettyUpper.height())

        # Create sum sign based on the height of the argument
        d, h, slines, adjustment = asum(
            H, prettyLower.width(), prettyUpper.width(), ascii_mode)
        prettySign = stringPict('')
        prettySign = prettyForm(*prettySign.stack(*slines))

        if first:
            sign_height = prettySign.height()

        prettySign = prettyForm(*prettySign.above(prettyUpper))
        prettySign = prettyForm(*prettySign.below(prettyLower))

        if first:
            # change F baseline so it centers on the sign
            prettyF.baseline -= d - (prettyF.height()//2 -
                                     prettyF.baseline)
            first = False

        # put padding to the right
        pad = stringPict('')
        pad = prettyForm(*pad.stack(*[' ']*h))
        prettySign = prettyForm(*prettySign.right(pad))
        # put the present prettyF to the right
        prettyF = prettyForm(*prettySign.right(prettyF))

    # adjust baseline of ascii mode sigma with an odd height so that it is
    # exactly through the center
    ascii_adjustment = ascii_mode if not adjustment else 0
    prettyF.baseline = max_upper + sign_height//2 + ascii_adjustment

    prettyF.binding = prettyForm.MUL
    return prettyF

sympy.sympy.printing.pretty.pretty._print_Limit

def _print_Limit(self, l):
    e, z, z0, dir = l.args

    E = self._print(e)
    if precedence(e) <= PRECEDENCE["Mul"]:
        E = prettyForm(*E.parens('(', ')'))
    Lim = prettyForm('lim')

    LimArg = self._print(z)
    if self._use_unicode:
        LimArg = prettyForm(*LimArg.right(f"{xobj('-', 1)}{pretty_atom('Arrow')}"))
    else:
        LimArg = prettyForm(*LimArg.right('->'))
    LimArg = prettyForm(*LimArg.right(self._print(z0)))

    if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
        dir = ""
    else:
        if self._use_unicode:
            dir = pretty_atom('SuperscriptPlus') if str(dir) == "+" else pretty_atom('SuperscriptMinus')

    LimArg = prettyForm(*LimArg.right(self._print(dir)))

    Lim = prettyForm(*Lim.below(LimArg))
    Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)

    return Lim

sympy.sympy.printing.pretty.pretty._print_stringPict

def _print_stringPict(self, e):
    return e

sympy.sympy.printing.pretty.pretty._print_atan2

def _print_atan2(self, e):
    pform = prettyForm(*self._print_seq(e.args).parens())
    pform = prettyForm(*pform.left('atan2'))
    return pform

sympy.sympy.printing.pretty.pretty._print_MatrixBase

def _print_MatrixBase(self, e, lparens='[', rparens=']'):
    D = self._print_matrix_contents(e)
    D.baseline = D.height()//2
    D = prettyForm(*D.parens(lparens, rparens))
    return D

sympy.sympy.printing.pretty.pretty._print_Determinant

def _print_Determinant(self, e):
    mat = e.arg
    if mat.is_MatrixExpr:
        from sympy.matrices.expressions.blockmatrix import BlockMatrix
        if isinstance(mat, BlockMatrix):
            return self._print_MatrixBase(mat.blocks, lparens='|', rparens='|')
        D = self._print(mat)
        D.baseline = D.height()//2
        return prettyForm(*D.parens('|', '|'))
    else:
        return self._print_MatrixBase(mat, lparens='|', rparens='|')

sympy.sympy.printing.pretty.pretty._print_TensorProduct

def _print_TensorProduct(self, expr):
    # This should somehow share the code with _print_WedgeProduct:
    if self._use_unicode:
        circled_times = "\u2297"
    else:
        circled_times = ".*"
    return self._print_seq(expr.args, None, None, circled_times,
        parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])

sympy.sympy.printing.pretty.pretty._print_WedgeProduct

def _print_WedgeProduct(self, expr):
    # This should somehow share the code with _print_TensorProduct:
    if self._use_unicode:
        wedge_symbol = "\u2227"
    else:
        wedge_symbol = '/\\'
    return self._print_seq(expr.args, None, None, wedge_symbol,
        parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])

sympy.sympy.printing.pretty.pretty._print_Trace

def _print_Trace(self, e):
    D = self._print(e.arg)
    D = prettyForm(*D.parens('(',')'))
    D.baseline = D.height()//2
    D = prettyForm(*D.left('\n'*(0) + 'tr'))
    return D

sympy.sympy.printing.pretty.pretty._print_MatrixElement

def _print_MatrixElement(self, expr):
    from sympy.matrices import MatrixSymbol
    if (isinstance(expr.parent, MatrixSymbol)
            and expr.i.is_number and expr.j.is_number):
        return self._print(
                Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))
    else:
        prettyFunc = self._print(expr.parent)
        prettyFunc = prettyForm(*prettyFunc.parens())
        prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
                ).parens(left='[', right=']')[0]
        pform = prettyForm(binding=prettyForm.FUNC,
                *stringPict.next(prettyFunc, prettyIndices))

        # store pform parts so it can be reassembled e.g. when powered
        pform.prettyFunc = prettyFunc
        pform.prettyArgs = prettyIndices

        return pform

sympy.sympy.printing.pretty.pretty._print_Symbol

def _print_Symbol(self, e, bold_name=False):
    symb = pretty_symbol(e.name, bold_name)
    return prettyForm(symb)

sympy.sympy.printing.pretty.pretty._print_MatrixSlice

def _print_MatrixSlice(self, m):
    # XXX works only for applied functions
    from sympy.matrices import MatrixSymbol
    prettyFunc = self._print(m.parent)
    if not isinstance(m.parent, MatrixSymbol):
        prettyFunc = prettyForm(*prettyFunc.parens())
    def ppslice(x, dim):
        x = list(x)
        if x[2] == 1:
            del x[2]
        if x[0] == 0:
            x[0] = ''
        if x[1] == dim:
            x[1] = ''
        return prettyForm(*self._print_seq(x, delimiter=':'))
    prettyArgs = self._print_seq((ppslice(m.rowslice, m.parent.rows),
        ppslice(m.colslice, m.parent.cols)), delimiter=', ').parens(left='[', right=']')[0]

    pform = prettyForm(
        binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))

    # store pform parts so it can be reassembled e.g. when powered
    pform.prettyFunc = prettyFunc
    pform.prettyArgs = prettyArgs

    return pform

sympy.sympy.printing.pretty.pretty._print_MatrixSymbol

def _print_MatrixSymbol(self, e):
    return self._print_Symbol(e, self._settings['mat_symbol_style'] == "bold")

sympy.sympy.printing.pretty.pretty._print_Transpose

def _print_Transpose(self, expr):
    mat = expr.arg
    pform = self._print(mat)
    from sympy.matrices import MatrixSymbol, BlockMatrix
    if (not isinstance(mat, MatrixSymbol) and
        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):
        pform = prettyForm(*pform.parens())
    pform = pform**(prettyForm('T'))
    return pform

sympy.sympy.printing.pretty.pretty._print_Adjoint

def _print_Adjoint(self, expr):
    mat = expr.arg
    pform = self._print(mat)
    if self._use_unicode:
        dag = prettyForm(pretty_atom('Dagger'))
    else:
        dag = prettyForm('+')
    from sympy.matrices import MatrixSymbol, BlockMatrix
    if (not isinstance(mat, MatrixSymbol) and
        not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):
        pform = prettyForm(*pform.parens())
    pform = pform**dag
    return pform

sympy.sympy.printing.pretty.pretty._print_BlockMatrix

def _print_BlockMatrix(self, B):
    if B.blocks.shape == (1, 1):
        return self._print(B.blocks[0, 0])
    return self._print(B.blocks)

sympy.sympy.printing.pretty.pretty._print_Float

def _print_Float(self, e):
    # we will use StrPrinter's Float printer, but we need to handle the
    # full_prec ourselves, according to the self._print_level
    full_prec = self._settings["full_prec"]
    if full_prec == "auto":
        full_prec = self._print_level == 1
    return prettyForm(sstr(e, full_prec=full_prec))

sympy.sympy.printing.pretty.pretty._print_MatAdd

def _print_MatAdd(self, expr):
    s = None
    for item in expr.args:
        pform = self._print(item)
        if s is None:
            s = pform     # First element
        else:
            coeff = item.as_coeff_mmul()[0]
            if S(coeff).could_extract_minus_sign():
                s = prettyForm(*stringPict.next(s, ' '))
                pform = self._print(item)
            else:
                s = prettyForm(*stringPict.next(s, ' + '))
            s = prettyForm(*stringPict.next(s, pform))

    return s

sympy.sympy.printing.pretty.pretty._print_MatMul

def _print_MatMul(self, expr):
    args = list(expr.args)
    from sympy.matrices.expressions.hadamard import HadamardProduct
    from sympy.matrices.expressions.kronecker import KroneckerProduct
    from sympy.matrices.expressions.matadd import MatAdd
    for i, a in enumerate(args):
        if (isinstance(a, (Add, MatAdd, HadamardProduct, KroneckerProduct))
                and len(expr.args) > 1):
            args[i] = prettyForm(*self._print(a).parens())
        else:
            args[i] = self._print(a)

    return prettyForm.__mul__(*args)

sympy.sympy.printing.pretty.pretty._print_Identity

def _print_Identity(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_atom('IdentityMatrix'))
    else:
        return prettyForm('I')

sympy.sympy.printing.pretty.pretty._print_ZeroMatrix

def _print_ZeroMatrix(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_atom('ZeroMatrix'))
    else:
        return prettyForm('0')

sympy.sympy.printing.pretty.pretty._print_OneMatrix

def _print_OneMatrix(self, expr):
    if self._use_unicode:
        return prettyForm(pretty_atom("OneMatrix"))
    else:
        return prettyForm('1')

sympy.sympy.printing.pretty.pretty._print_MatrixUnit

def _print_MatrixUnit(self, expr):
    if self._use_unicode:
        s = self._print(Symbol(f'{pretty_atom("MatrixUnit")}_{expr._i}{expr._j}'))
    else:
        s = self._print(Symbol(f'E_{expr._i}{expr._j}'))
    return s

sympy.sympy.printing.pretty.pretty._print_DotProduct

def _print_DotProduct(self, expr):
    args = list(expr.args)

    for i, a in enumerate(args):
        args[i] = self._print(a)
    return prettyForm.__mul__(*args)

sympy.sympy.printing.pretty.pretty._print_MatPow

def _print_MatPow(self, expr):
    pform = self._print(expr.base)
    from sympy.matrices import MatrixSymbol
    if not isinstance(expr.base, MatrixSymbol) and expr.base.is_MatrixExpr:
        pform = prettyForm(*pform.parens())
    pform = pform**(self._print(expr.exp))
    return pform

sympy.sympy.printing.pretty.pretty._print_Cross

def _print_Cross(self, e):
    vec1 = e._expr1
    vec2 = e._expr2
    pform = self._print(vec2)
    pform = prettyForm(*pform.left('('))
    pform = prettyForm(*pform.right(')'))
    pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
    pform = prettyForm(*pform.left(')'))
    pform = prettyForm(*pform.left(self._print(vec1)))
    pform = prettyForm(*pform.left('('))
    return pform

sympy.sympy.printing.pretty.pretty._print_HadamardPower

def _print_HadamardPower(self, expr):
    # from sympy import MatAdd, MatMul
    if self._use_unicode:
        circ = pretty_atom('Ring')
    else:
        circ = self._print('.')
    pretty_base = self._print(expr.base)
    pretty_exp = self._print(expr.exp)
    if precedence(expr.exp) < PRECEDENCE["Mul"]:
        pretty_exp = prettyForm(*pretty_exp.parens())
    pretty_circ_exp = prettyForm(
        binding=prettyForm.LINE,
        *stringPict.next(circ, pretty_exp)
    )
    return pretty_base**pretty_circ_exp

sympy.sympy.printing.pretty.pretty._print_KroneckerProduct

def _print_KroneckerProduct(self, expr):
    from sympy.matrices.expressions.matadd import MatAdd
    from sympy.matrices.expressions.matmul import MatMul
    if self._use_unicode:
        delim = f" {pretty_atom('TensorProduct')} "
    else:
        delim = ' x '
    return self._print_seq(expr.args, None, None, delim,
            parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))

sympy.sympy.printing.pretty.pretty._print_TransferFunction

def _print_TransferFunction(self, expr):
    if not expr.num == 1:
        num, den = expr.num, expr.den
        res = Mul(num, Pow(den, -1, evaluate=False), evaluate=False)
        return self._print_Mul(res)
    else:
        return self._print(1)/self._print(expr.den)

sympy.sympy.printing.printer.<genexpr>

classes = tuple(c for c in classes[:i] if \
    c.__name__ == classes[0].__name__ or \
    c.__name__.endswith("Base")) + classes[i:]


sympy.sympy.printing.pycode._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return "float('-inf')"

sympy.sympy.printing.pycode._print_Assignment

def _print_Assignment(self, expr):
    #XXX: maybe this needs to happen at a higher level e.g. at _print or
    #doprint?
    lhs = self._print(self._arrayify(expr.lhs))
    rhs = self._print(self._arrayify(expr.rhs))
    return "%s = %s" % ( lhs, rhs )

sympy.sympy.printing.pycode._print_Mod

def _print_Mod(self, expr):
    PREC = precedence(expr)
    return ('{} % {}'.format(*(self.parenthesize(x, PREC) for x in expr.args)))

sympy.sympy.printing.pycode._print_Piecewise

def _print_Piecewise(self, expr):
    result = []
    for i, arg in enumerate(expr.args):
        e = arg.expr
        c = arg.cond
        if i == 0:
            result.append('(')
        result.append('(')
        result.append(self._print(e))
        result.append(')')
        result.append(' if ')
        result.append(self._print(c))
        result.append(' else ')
    result = result[:-1]
    if result[-1] == 'True':
        result = result[:-2]
        result.append(')')
    else:
        result.append(' else None)')
    return ''.join(result)

sympy.sympy.printing.pycode._print_Relational

def _print_Relational(self, expr):
    "Relational printer for Equality and Unequality"
    op = {
        '==' :'equal',
        '!=' :'not_equal',
        '<'  :'less',
        '<=' :'less_equal',
        '>'  :'greater',
        '>=' :'greater_equal',
    }
    if expr.rel_op in op:
        lhs = self._print(expr.lhs)
        rhs = self._print(expr.rhs)
        return '({lhs} {op} {rhs})'.format(op=expr.rel_op, lhs=lhs, rhs=rhs)
    return super()._print_Relational(expr)

sympy.sympy.printing.pycode._print_ITE

def _print_ITE(self, expr):
    from sympy.functions.elementary.piecewise import Piecewise
    return self._print(expr.rewrite(Piecewise))

sympy.sympy.printing.pycode._print_Sum

def _print_Sum(self, expr):
    loops = (
        'for {i} in range({a}, {b}+1)'.format(
            i=self._print(i),
            a=self._print(a),
            b=self._print(b))
        for i, a, b in expr.limits[::-1])
    return '(builtins.sum({function} {loops}))'.format(
        function=self._print(expr.function),
        loops=' '.join(loops))

sympy.sympy.printing.pycode._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return '1j'

sympy.sympy.printing.pycode._print_KroneckerDelta

def _print_KroneckerDelta(self, expr):
    a, b = expr.args

    return '(1 if {a} == {b} else 0)'.format(
        a = self._print(a),
        b = self._print(b)
    )

sympy.sympy.printing.pycode.<lambda>

lambda self, expr: self._print_MatrixBase(expr)



sympy.sympy.printing.pycode._print_FunctionDefinition

def _print_FunctionDefinition(self, fd):
    body = '\n'.join((self._print(arg) for arg in fd.body))
    return "def {name}({parameters}):\n{body}".format(
        name=self._print(fd.name),
        parameters=', '.join([self._print(var.symbol) for var in fd.parameters]),
        body=self._indent_codestring(body)
    )

sympy.sympy.printing.pycode._print_While

def _print_While(self, whl):
    body = '\n'.join((self._print(arg) for arg in whl.body))
    return "while {cond}:\n{body}".format(
        cond=self._print(whl.condition),
        body=self._indent_codestring(body)
    )

sympy.sympy.printing.pycode._print_Declaration

def _print_Declaration(self, decl):
    return '%s = %s' % (
        self._print(decl.variable.symbol),
        self._print(decl.variable.value)
    )

sympy.sympy.printing.pycode._print_BreakToken

def _print_BreakToken(self, bt):
    return 'break'

sympy.sympy.printing.pycode._print_Return

def _print_Return(self, ret):
    arg, = ret.args
    return 'return %s' % self._print(arg)

sympy.sympy.printing.pycode._print_Raise

def _print_Raise(self, rs):
    arg, = rs.args
    return 'raise %s' % self._print(arg)

sympy.sympy.printing.pycode._print_RuntimeError_

def _print_RuntimeError_(self, re):
    message, = re.args
    return "RuntimeError(%s)" % self._print(message)

sympy.sympy.printing.pycode._print_Print

def _print_Print(self, prnt):
    print_args = ', '.join((self._print(arg) for arg in prnt.print_args))
    from sympy.codegen.ast import none
    if prnt.format_string != none:
        print_args = '{} % ({}), end=""'.format(
            self._print(prnt.format_string),
            print_args
        )
    if prnt.file != None: # Must be '!= None', cannot be 'is not None'
        print_args += ', file=%s' % self._print(prnt.file)
    return 'print(%s)' % print_args

sympy.sympy.printing.pycode._print_NoneToken

def _print_NoneToken(self, arg):
    return 'None'

sympy.sympy.printing.pycode._print_ArrayContraction

def _print_ArrayContraction(self, expr):
    from sympy.tensor.array.expressions.array_expressions import ArrayTensorProduct
    base = expr.expr
    contraction_indices = expr.contraction_indices

    if isinstance(base, ArrayTensorProduct):
        elems = ",".join(["%s" % (self._print(arg)) for arg in base.args])
        ranks = base.subranks
    else:
        elems = self._print(base)
        ranks = [len(base.shape)]

    contraction_string, letters_free, letters_dum = self._get_einsum_string(ranks, contraction_indices)

    if not contraction_indices:
        return self._print(base)
    if isinstance(base, ArrayTensorProduct):
        elems = ",".join(["%s" % (self._print(arg)) for arg in base.args])
    else:
        elems = self._print(base)
    return "%s(\"%s\", %s)" % (
        self._module_format(self._module + "." + self._einsum),
        "{}->{}".format(contraction_string, "".join(sorted(letters_free))),
        elems,
    )

sympy.sympy.printing.pycode._print_ArrayDiagonal

def _print_ArrayDiagonal(self, expr):
    from sympy.tensor.array.expressions.array_expressions import ArrayTensorProduct
    diagonal_indices = list(expr.diagonal_indices)
    if isinstance(expr.expr, ArrayTensorProduct):
        subranks = expr.expr.subranks
        elems = expr.expr.args
    else:
        subranks = expr.subranks
        elems = [expr.expr]
    diagonal_string, letters_free, letters_dum = self._get_einsum_string(subranks, diagonal_indices)
    elems = [self._print(i) for i in elems]
    return '%s("%s", %s)' % (
        self._module_format(self._module + "." + self._einsum),
        "{}->{}".format(diagonal_string, "".join(letters_free+letters_dum)),
        ", ".join(elems)
    )

sympy.sympy.printing.pycode._print_OneArray

def _print_OneArray(self, expr):
    return "%s((%s,))" % (
        self._module_format(self._module+ "." + self._ones),
        ','.join(map(self._print,expr.args))
    )

sympy.sympy.printing.pycode._print_ZeroArray

def _print_ZeroArray(self, expr):
    return "%s((%s,))" % (
        self._module_format(self._module+ "." + self._zeros),
        ','.join(map(self._print,expr.args))
    )

sympy.sympy.printing.pycode._print_IndexedBase

def _print_IndexedBase(self, expr):
    return expr.name

sympy.sympy.printing.pycode._print_sign

def _print_sign(self, e):
    return '(0.0 if {e} == 0 else {f}(1, {e}))'.format(
        f=self._module_format('math.copysign'), e=self._print(e.args[0]))

sympy.sympy.printing.pycode._print_Not

def _print_Not(self, expr):
    PREC = precedence(expr)
    return self._operators['not'] + ' ' + self.parenthesize(expr.args[0], PREC)

sympy.sympy.printing.pycode._print_Indexed

def _print_Indexed(self, expr):
    base = expr.args[0]
    index = expr.args[1:]
    return "{}[{}]".format(self._print(base), ", ".join([self._print(ind) for ind in index]))

sympy.sympy.printing.pycode._print_Pow

def _print_Pow(self, expr, rational=False):
    return self._hprint_Pow(expr, rational=rational, sqrt='sympy.sqrt')

sympy.sympy.printing.pycode._print_Rational

def _print_Rational(self, e):
    return "{func}({p})/{func}({q})".format(
        func=self._module_format('mpmath.mpf'),
        q=self._print(e.q),
        p=self._print(e.p)
    )

sympy.sympy.printing.pycode._print_Half

def _print_Half(self, e):
    return self._print_Rational(e)

sympy.sympy.printing.pycode._print_frac

def _print_frac(self, expr):
    return self._print_Mod(Mod(expr.args[0], 1))

sympy.sympy.printing.pycode._print_Symbol

def _print_Symbol(self, expr):

    name = super()._print_Symbol(expr)

    if name in self.reserved_words:
        if self._settings['error_on_reserved']:
            msg = ('This expression includes the symbol "{}" which is a '
                   'reserved keyword in this language.')
            raise ValueError(msg.format(name))
        return name + self._settings['reserved_word_suffix']
    elif '{' in name:   # Remove curly braces from subscripted variables
        return name.replace('{', '').replace('}', '')
    else:
        return name

sympy.sympy.printing.pycode._print_known_func

def _print_known_func(self, expr):
    known = self.known_functions[expr.__class__.__name__]
    return '{name}({args})'.format(name=self._module_format(known),
                                   args=', '.join((self._print(arg) for arg in expr.args)))

sympy.sympy.printing.pycode._print_re

def _print_re(self, expr):
    """Prints `re(z)` as `z.real`"""
    return f"({self._print(expr.args[0])}).real"

sympy.sympy.printing.pycode._print_im

def _print_im(self, expr):
    """Prints `im(z)` as `z.imag`"""
    return f"({self._print(expr.args[0])}).imag"

sympy.sympy.printing.pycode._print_known_const

def _print_known_const(self, expr):
    known = self.known_constants[expr.__class__.__name__]
    return self._module_format(known)

sympy.sympy.printing.pycode._print_Float

def _print_Float(self, e):
    # XXX: This does not handle setting mpmath.mp.dps. It is assumed that
    # the caller of the lambdified function will have set it to sufficient
    # precision to match the Floats in the expression.

    # Remove 'mpz' if gmpy is installed.
    args = str(tuple(map(int, e._mpf_)))
    return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)

sympy.sympy.printing.pycode._print_uppergamma

def _print_uppergamma(self, e):
    return "{}({}, {}, {})".format(
        self._module_format('mpmath.gammainc'),
        self._print(e.args[0]),
        self._print(e.args[1]),
        self._module_format('mpmath.inf'))

sympy.sympy.printing.pycode._print_lowergamma

def _print_lowergamma(self, e):
    return "{}({}, 0, {})".format(
        self._module_format('mpmath.gammainc'),
        self._print(e.args[0]),
        self._print(e.args[1]))

sympy.sympy.printing.pycode._print_log1p

def _print_log1p(self, e):
    return '{}({})'.format(
        self._module_format('mpmath.log1p'), self._print(e.args[0]))

sympy.sympy.printing.pycode._print_Integral

def _print_Integral(self, e):
    integration_vars, limits = _unpack_integral_limits(e)

    return "{}(lambda {}: {}, {})".format(
            self._module_format("mpmath.quad"),
            ", ".join(map(self._print, integration_vars)),
            self._print(e.args[0]),
            ", ".join("(%s, %s)" % tuple(map(self._print, l)) for l in limits))

sympy.sympy.printing.pycode._print_Function

def _print_Function(self, expr):
    mod = expr.func.__module__ or ''
    return '%s(%s)' % (self._module_format(mod + ('.' if mod else '') + expr.func.__name__),
                       ', '.join((self._print(arg) for arg in expr.args)))

sympy.sympy.printing.python._print_Function

def _print_Function(self, expr):
    func = expr.func.__name__
    if not hasattr(sympy, func) and func not in self.functions:
        self.functions.append(func)
    return StrPrinter._print_Function(self, expr)

sympy.sympy.printing.python._print_Symbol

def _print_Symbol(self, expr):
    symbol = self._str(expr)
    if symbol not in self.symbols:
        self.symbols.append(symbol)
    return StrPrinter._print_Symbol(self, expr)

sympy.sympy.printing.pytorch._print_Derivative

def _print_Derivative(self, expr):
    # this version handles multi-variable and mixed partial derivatives. The tensorflow version does not.
    variables = expr.variables
    expr_arg = expr.expr

    # Handle multi-variable or repeated derivatives
    if len(variables) > 1 or (
        len(variables) == 1 and not isinstance(variables[0], tuple) and variables.count(variables[0]) > 1):
        result = self._print(expr_arg)
        var_groups = {}

        # Group variables by base symbol
        for var in variables:
            if isinstance(var, tuple):
                base_var, order = var
                var_groups[base_var] = var_groups.get(base_var, 0) + order
            else:
                var_groups[var] = var_groups.get(var, 0) + 1

        # Apply gradients in sequence
        for var, order in var_groups.items():
            for _ in range(order):
                result = "torch.autograd.grad({}, {}, create_graph=True)[0]".format(result, self._print(var))
        return result

    # Handle single variable case
    if len(variables) == 1:
        variable = variables[0]
        if isinstance(variable, tuple) and len(variable) == 2:
            base_var, order = variable
            if not isinstance(order, Integer): raise NotImplementedError("Only integer orders are supported")
            result = self._print(expr_arg)
            for _ in range(order):
                result = "torch.autograd.grad({}, {}, create_graph=True)[0]".format(result, self._print(base_var))
            return result
        return "torch.autograd.grad({}, {})[0]".format(self._print(expr_arg), self._print(variable))

    return self._print(expr_arg)  # Empty variables case

sympy.sympy.printing.pytorch._print_Function

def _print_Function(self, expr):

    op = self.mapping.get(type(expr), None)
    if op is None:
        return super()._print_Basic(expr)
    children = [self._print(arg) for arg in expr.args]
    if len(children) == 1:
        return "%s(%s)" % (
            self._module_format(op),
            children[0]
        )
    else:
        return self._expand_fold_binary_op(op, children)

sympy.sympy.printing.rcode._print_Pow

def _print_Pow(self, expr):
    if "Pow" in self.known_functions:
        return self._print_Function(expr)
    PREC = precedence(expr)
    if equal_valued(expr.exp, -1):
        return '1.0/%s' % (self.parenthesize(expr.base, PREC))
    elif equal_valued(expr.exp, 0.5):
        return 'sqrt(%s)' % self._print(expr.base)
    else:
        return '%s^%s' % (self.parenthesize(expr.base, PREC),
                             self.parenthesize(expr.exp, PREC))

sympy.sympy.printing.rcode._print_Rational

def _print_Rational(self, expr):
    p, q = int(expr.p), int(expr.q)
    return '%d.0/%d.0' % (p, q)

sympy.sympy.printing.rcode._print_Indexed

def _print_Indexed(self, expr):
    inds = [ self._print(i) for i in expr.indices ]
    return "%s[%s]" % (self._print(expr.base.label), ", ".join(inds))

sympy.sympy.printing.rcode._print_Exp1

def _print_Exp1(self, expr):
    return "exp(1)"

sympy.sympy.printing.rcode._print_Pi

def _print_Pi(self, expr):
    return 'pi'

sympy.sympy.printing.rcode._print_Infinity

def _print_Infinity(self, expr):
    return 'Inf'

sympy.sympy.printing.rcode._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-Inf'

sympy.sympy.printing.rcode._print_Assignment

def _print_Assignment(self, expr):
    from sympy.codegen.ast import Assignment

    from sympy.matrices.expressions.matexpr import MatrixSymbol
    from sympy.tensor.indexed import IndexedBase
    lhs = expr.lhs
    rhs = expr.rhs
    # We special case assignments that take multiple lines
    #if isinstance(expr.rhs, Piecewise):
    #    from sympy.functions.elementary.piecewise import Piecewise
    #    # Here we modify Piecewise so each expression is now
    #    # an Assignment, and then continue on the print.
    #    expressions = []
    #    conditions = []
    #    for (e, c) in rhs.args:
    #        expressions.append(Assignment(lhs, e))
    #        conditions.append(c)
    #    temp = Piecewise(*zip(expressions, conditions))
    #    return self._print(temp)
    #elif isinstance(lhs, MatrixSymbol):
    if isinstance(lhs, MatrixSymbol):
        # Here we form an Assignment for each element in the array,
        # printing each one.
        lines = []
        for (i, j) in self._traverse_matrix_indices(lhs):
            temp = Assignment(lhs[i, j], rhs[i, j])
            code0 = self._print(temp)
            lines.append(code0)
        return "\n".join(lines)
    elif self._settings["contract"] and (lhs.has(IndexedBase) or
            rhs.has(IndexedBase)):
        # Here we check if there is looping to be done, and if so
        # print the required loops.
        return self._doprint_loops(rhs, lhs)
    else:
        lhs_code = self._print(lhs)
        rhs_code = self._print(rhs)
        return self._get_statement("%s = %s" % (lhs_code, rhs_code))

sympy.sympy.printing.rcode._print_Piecewise

def _print_Piecewise(self, expr):
    # This method is called only for inline if constructs
    # Top level piecewise is handled in doprint()
    if expr.args[-1].cond == True:
        last_line = "%s" % self._print(expr.args[-1].expr)
    else:
        last_line = "ifelse(%s,%s,NA)" % (self._print(expr.args[-1].cond), self._print(expr.args[-1].expr))
    code=last_line
    for e, c in reversed(expr.args[:-1]):
        code= "ifelse(%s,%s," % (self._print(c), self._print(e))+code+")"
    return(code)

sympy.sympy.printing.rcode._print_ITE

def _print_ITE(self, expr):
    from sympy.functions import Piecewise
    return self._print(expr.rewrite(Piecewise))

sympy.sympy.printing.rcode._print_MatrixElement

def _print_MatrixElement(self, expr):
    return "{}[{}]".format(self.parenthesize(expr.parent, PRECEDENCE["Atom"],
        strict=True), expr.j + expr.i*expr.parent.shape[1])

sympy.sympy.printing.rcode._print_Symbol

def _print_Symbol(self, expr):
    name = super()._print_Symbol(expr)
    if expr in self._dereference:
        return '(*{})'.format(name)
    else:
        return name

sympy.sympy.printing.rcode._print_Relational

def _print_Relational(self, expr):
    lhs_code = self._print(expr.lhs)
    rhs_code = self._print(expr.rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.rcode._print_AugmentedAssignment

def _print_AugmentedAssignment(self, expr):
    lhs_code = self._print(expr.lhs)
    op = expr.op
    rhs_code = self._print(expr.rhs)
    return "{} {} {};".format(lhs_code, op, rhs_code)

sympy.sympy.printing.rcode._print_For

def _print_For(self, expr):
    target = self._print(expr.target)
    if isinstance(expr.iterable, Range):
        start, stop, step = expr.iterable.args
    else:
        raise NotImplementedError("Only iterable currently supported is Range")
    body = self._print(expr.body)
    return 'for({target} in seq(from={start}, to={stop}, by={step}){{\n{body}\n}}'.format(target=target, start=start,
            stop=stop-1, step=step, body=body)

sympy.sympy.printing.repr._print_Function

def _print_Function(self, expr):
    r = self._print(expr.func)
    r += '(%s)' % ', '.join([self._print(a) for a in expr.args])
    return r

sympy.sympy.printing.repr._print_Heaviside

def _print_Heaviside(self, expr):
    # Same as _print_Function but uses pargs to suppress default value for
    # 2nd arg.
    r = self._print(expr.func)
    r += '(%s)' % ', '.join([self._print(a) for a in expr.pargs])
    return r

sympy.sympy.printing.repr._print_FunctionClass

def _print_FunctionClass(self, expr):
    if issubclass(expr, AppliedUndef):
        return 'Function(%r)' % (expr.__name__)
    else:
        return expr.__name__

sympy.sympy.printing.repr._print_Half

def _print_Half(self, expr):
    return 'Rational(1, 2)'

sympy.sympy.printing.repr._print_AtomicExpr

def _print_AtomicExpr(self, expr):
    return str(expr)

sympy.sympy.printing.repr._print_NumberSymbol

def _print_NumberSymbol(self, expr):
    return str(expr)

sympy.sympy.printing.repr._print_Integer

def _print_Integer(self, expr):
    return 'Integer(%i)' % expr.p

sympy.sympy.printing.repr._print_Complexes

def _print_Complexes(self, expr):
    return 'Complexes'

sympy.sympy.printing.repr._print_Integers

def _print_Integers(self, expr):
    return 'Integers'

sympy.sympy.printing.repr._print_Naturals

def _print_Naturals(self, expr):
    return 'Naturals'

sympy.sympy.printing.repr._print_Naturals0

def _print_Naturals0(self, expr):
    return 'Naturals0'

sympy.sympy.printing.repr._print_Rationals

def _print_Rationals(self, expr):
    return 'Rationals'

sympy.sympy.printing.repr._print_Reals

def _print_Reals(self, expr):
    return 'Reals'

sympy.sympy.printing.repr._print_EmptySet

def _print_EmptySet(self, expr):
    return 'EmptySet'

sympy.sympy.printing.repr._print_UniversalSet

def _print_UniversalSet(self, expr):
    return 'UniversalSet'

sympy.sympy.printing.repr._print_EmptySequence

def _print_EmptySequence(self, expr):
    return 'EmptySequence'

sympy.sympy.printing.repr._print_list

def _print_list(self, expr):
    return "[%s]" % self.reprify(expr, ", ")

sympy.sympy.printing.repr._print_dict

def _print_dict(self, expr):
    sep = ", "
    dict_kvs = ["%s: %s" % (self.doprint(key), self.doprint(value)) for key, value in expr.items()]
    return "{%s}" % sep.join(dict_kvs)

sympy.sympy.printing.repr._print_set

def _print_set(self, expr):
    if not expr:
        return "set()"
    return "{%s}" % self.reprify(expr, ", ")

sympy.sympy.printing.repr._print_MatrixBase

def _print_MatrixBase(self, expr):
    # special case for some empty matrices
    if (expr.rows == 0) ^ (expr.cols == 0):
        return '%s(%s, %s, %s)' % (expr.__class__.__name__,
                                   self._print(expr.rows),
                                   self._print(expr.cols),
                                   self._print([]))
    l = []
    for i in range(expr.rows):
        l.append([])
        for j in range(expr.cols):
            l[-1].append(expr[i, j])
    return '%s(%s)' % (expr.__class__.__name__, self._print(l))

sympy.sympy.printing.repr._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return "true"

sympy.sympy.printing.repr._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return "false"

sympy.sympy.printing.repr._print_NaN

def _print_NaN(self, expr):
    return "nan"

sympy.sympy.printing.repr._print_Mul

def _print_Mul(self, expr, order=None):
    args = Mul.make_args(expr)
    args = map(self._print, args)
    clsname = type(expr).__name__
    return clsname + "(%s)" % ", ".join(args)

sympy.sympy.printing.repr._print_Rational

def _print_Rational(self, expr):
    return 'Rational(%s, %s)' % (self._print(expr.p), self._print(expr.q))

sympy.sympy.printing.repr._print_Float

def _print_Float(self, expr):
    r = mlib_to_str(expr._mpf_, repr_dps(expr._prec))
    return "%s('%s', precision=%i)" % (expr.__class__.__name__, r, expr._prec)

sympy.sympy.printing.repr._print_Str

def _print_Str(self, s):
    return "%s(%s)" % (s.__class__.__name__, self._print(s.name))

sympy.sympy.printing.repr._print_Symbol

def _print_Symbol(self, expr):
    d = expr._assumptions_orig
    # print the dummy_index like it was an assumption
    if expr.is_Dummy:
        d = d.copy()
        d['dummy_index'] = expr.dummy_index

    if d == {}:
        return "%s(%s)" % (expr.__class__.__name__, self._print(expr.name))
    else:
        attr = ['%s=%s' % (k, v) for k, v in d.items()]
        return "%s(%s, %s)" % (expr.__class__.__name__,
                               self._print(expr.name), ', '.join(attr))

sympy.sympy.printing.repr._print_Predicate

def _print_Predicate(self, expr):
    return "Q.%s" % expr.name

sympy.sympy.printing.repr._print_AppliedPredicate

def _print_AppliedPredicate(self, expr):
    # will be changed to just expr.args when args overriding is removed
    args = expr._args
    return "%s(%s)" % (expr.__class__.__name__, self.reprify(args, ", "))

sympy.sympy.printing.repr._print_str

def _print_str(self, expr):
    return repr(expr)

sympy.sympy.printing.repr._print_tuple

def _print_tuple(self, expr):
    if len(expr) == 1:
        return "(%s,)" % self._print(expr[0])
    else:
        return "(%s)" % self.reprify(expr, ", ")

sympy.sympy.printing.repr._print_WildFunction

def _print_WildFunction(self, expr):
    return "%s('%s')" % (expr.__class__.__name__, expr.name)

sympy.sympy.printing.repr._print_AlgebraicNumber

def _print_AlgebraicNumber(self, expr):
    return "%s(%s, %s)" % (expr.__class__.__name__,
        self._print(expr.root), self._print(expr.coeffs()))

sympy.sympy.printing.repr._print_PolyRing

def _print_PolyRing(self, ring):
    return "%s(%s, %s, %s)" % (ring.__class__.__name__,
        self._print(ring.symbols), self._print(ring.domain), self._print(ring.order))

sympy.sympy.printing.repr._print_FracField

def _print_FracField(self, field):
    return "%s(%s, %s, %s)" % (field.__class__.__name__,
        self._print(field.symbols), self._print(field.domain), self._print(field.order))

sympy.sympy.printing.repr._print_PolyElement

def _print_PolyElement(self, poly):
    terms = list(poly.terms())
    terms.sort(key=poly.ring.order, reverse=True)
    return "%s(%s, %s)" % (poly.__class__.__name__, self._print(poly.ring), self._print(terms))

sympy.sympy.printing.repr._print_FracElement

def _print_FracElement(self, frac):
    numer_terms = list(frac.numer.terms())
    numer_terms.sort(key=frac.field.order, reverse=True)
    denom_terms = list(frac.denom.terms())
    denom_terms.sort(key=frac.field.order, reverse=True)
    numer = self._print(numer_terms)
    denom = self._print(denom_terms)
    return "%s(%s, %s, %s)" % (frac.__class__.__name__, self._print(frac.field), numer, denom)

sympy.sympy.printing.repr._print_FractionField

def _print_FractionField(self, domain):
    cls = domain.__class__.__name__
    field = self._print(domain.field)
    return "%s(%s)" % (cls, field)

sympy.sympy.printing.repr._print_PolynomialRingBase

def _print_PolynomialRingBase(self, ring):
    cls = ring.__class__.__name__
    dom = self._print(ring.domain)
    gens = ', '.join(map(self._print, ring.gens))
    order = str(ring.order)
    if order != ring.default_order:
        orderstr = ", order=" + order
    else:
        orderstr = ""
    return "%s(%s, %s%s)" % (cls, dom, gens, orderstr)

sympy.sympy.printing.repr._print_DMP

def _print_DMP(self, p):
    cls = p.__class__.__name__
    rep = self._print(p.to_list())
    dom = self._print(p.dom)
    return "%s(%s, %s)" % (cls, rep, dom)

sympy.sympy.printing.repr._print_MonogenicFiniteExtension

def _print_MonogenicFiniteExtension(self, ext):
    # The expanded tree shown by srepr(ext.modulus)
    # is not practical.
    return "FiniteExtension(%s)" % str(ext.modulus)

sympy.sympy.printing.repr._print_ExtensionElement

def _print_ExtensionElement(self, f):
    rep = self._print(f.rep)
    ext = self._print(f.ext)
    return "ExtElem(%s, %s)" % (rep, ext)

sympy.sympy.printing.repr.emptyPrinter

def emptyPrinter(self, expr):
    """
    The fallback printer.
    """
    if isinstance(expr, str):
        return expr
    elif hasattr(expr, "__srepr__"):
        return expr.__srepr__()
    elif hasattr(expr, "args") and hasattr(expr.args, "__iter__"):
        l = []
        for o in expr.args:
            l.append(self._print(o))
        return expr.__class__.__name__ + '(%s)' % ', '.join(l)
    elif hasattr(expr, "__module__") and hasattr(expr, "__name__"):
        return "<'%s.%s'>" % (expr.__module__, expr.__name__)
    else:
        return str(expr)

sympy.sympy.printing.repr._print_Add

def _print_Add(self, expr, order=None):
    args = Add.make_args(expr)
    args = map(self._print, args)
    clsname = type(expr).__name__
    return clsname + "(%s)" % ", ".join(args)

sympy.sympy.printing.repr._print_Cycle

def _print_Cycle(self, expr):
    return expr.__repr__()

sympy.sympy.printing.repr._print_Permutation

def _print_Permutation(self, expr):
    from sympy.combinatorics.permutations import Permutation, Cycle
    from sympy.utilities.exceptions import sympy_deprecation_warning

    perm_cyclic = Permutation.print_cyclic
    if perm_cyclic is not None:
        sympy_deprecation_warning(
            f"""
            Setting Permutation.print_cyclic is deprecated. Instead use
            init_printing(perm_cyclic={perm_cyclic}).
            """,
            deprecated_since_version="1.6",
            active_deprecations_target="deprecated-permutation-print_cyclic",
            stacklevel=7,
        )
    else:
        perm_cyclic = self._settings.get("perm_cyclic", True)

    if perm_cyclic:
        if not expr.size:
            return 'Permutation()'
        # before taking Cycle notation, see if the last element is
        # a singleton and move it to the head of the string
        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]
        last = s.rfind('(')
        if not last == 0 and ',' not in s[last:]:
            s = s[last:] + s[:last]
        return 'Permutation%s' %s
    else:
        s = expr.support()
        if not s:
            if expr.size < 5:
                return 'Permutation(%s)' % str(expr.array_form)
            return 'Permutation([], size=%s)' % expr.size
        trim = str(expr.array_form[:s[-1] + 1]) + ', size=%s' % expr.size
        use = full = str(expr.array_form)
        if len(trim) < len(full):
            use = trim
        return 'Permutation(%s)' % use

sympy.sympy.printing.rust._print_Function

def _print_Function(self, expr):
    """
    basic function for printing `Function`

    Function Style :

    1. args[0].func(args[1:]), method with arguments
    2. args[0].func(), method without arguments
    3. args[1].func(), method without arguments (e.g. (e, x) => x.exp())
    4. func(args), function with arguments
    """

    if expr.func.__name__ in self.known_functions:
        cond_func = self.known_functions[expr.func.__name__]
        func = None
        style = 1
        if isinstance(cond_func, str):
            func = cond_func
        else:
            for cond, func, style in cond_func:
                if cond(*expr.args):
                    break
        if func is not None:
            if style == 1:
                ret = "%(var)s.%(method)s(%(args)s)" % {
                    'var': self._print_caller_var(expr.args[0]),
                    'method': func,
                    'args': self.stringify(expr.args[1:], ", ") if len(expr.args) > 1 else ''
                }
            elif style == 2:
                ret = "%(var)s.%(method)s()" % {
                    'var': self._print_caller_var(expr.args[0]),
                    'method': func,
                }
            elif style == 3:
                ret = "%(var)s.%(method)s()" % {
                    'var': self._print_caller_var(expr.args[1]),
                    'method': func,
                }
            else:
                ret = "%(func)s(%(args)s)" % {
                    'func': func,
                    'args': self.stringify(expr.args, ", "),
                }
            return ret
    elif hasattr(expr, '_imp_') and isinstance(expr._imp_, Lambda):
        # inlined function
        return self._print(expr._imp_(*expr.args))
    else:
        return self._print_not_supported(expr)

sympy.sympy.printing.rust._print_Mul

def _print_Mul(self, expr):
    contains_floats = any(arg.is_real and not arg.is_integer for arg in expr.args)
    if contains_floats:
        expr = reduce(operator.mul,(self._cast_to_float(arg) if arg != -1 else arg for arg in expr.args))

    return super()._print_Mul(expr)

sympy.sympy.printing.rust._print_Add

def _print_Add(self, expr, order=None):
    contains_floats = any(arg.is_real and not arg.is_integer for arg in expr.args)
    if contains_floats:
        expr = reduce(operator.add, (self._cast_to_float(arg) for arg in expr.args))

    return super()._print_Add(expr, order)

sympy.sympy.printing.rust._print_Pow

def _print_Pow(self, expr):
    if expr.base.is_integer and not expr.exp.is_integer:
        expr = type(expr)(Float(expr.base), expr.exp)
        return self._print(expr)
    return self._print_Function(expr)

sympy.sympy.printing.rust._print_TypeCast

def _print_TypeCast(self, expr):
    if not expr.explicit:
        return self._print(expr.expr)
    else:
        return self._print(expr.expr) + ' as %s' % self.type_mappings[self.type_aliases[expr.type_]]

sympy.sympy.printing.rust._print_Float

def _print_Float(self, expr, _type=False):
    ret = super()._print_Float(expr)
    if _type:
        return ret + '_%s' % self.type_mappings[self.type_aliases[real]]
    else:
        return ret

sympy.sympy.printing.rust._print_Integer

def _print_Integer(self, expr, _type=False):
    ret = super()._print_Integer(expr)
    if _type:
        return ret + '_%s' % self.type_mappings[self.type_aliases[integer]]
    else:
        return ret

sympy.sympy.printing.rust._print_Rational

def _print_Rational(self, expr):
    p, q = int(expr.p), int(expr.q)
    float_suffix = self.type_mappings[self.type_aliases[real]]
    return '%d_%s/%d.0' % (p, float_suffix, q)

sympy.sympy.printing.rust._print_Relational

def _print_Relational(self, expr):
    if (expr.lhs.is_integer and not expr.rhs.is_integer) or (expr.rhs.is_integer and not expr.lhs.is_integer):
        lhs = self._cast_to_float(expr.lhs)
        rhs = self._cast_to_float(expr.rhs)
    else:
        lhs = expr.lhs
        rhs = expr.rhs
    lhs_code = self._print(lhs)
    rhs_code = self._print(rhs)
    op = expr.rel_op
    return "{} {} {}".format(lhs_code, op, rhs_code)

sympy.sympy.printing.rust._print_Indexed

def _print_Indexed(self, expr):
    # calculate index for 1d array
    dims = expr.shape
    elem = S.Zero
    offset = S.One
    for i in reversed(range(expr.rank)):
        elem += expr.indices[i]*offset
        offset *= dims[i]
    return "%s[%s]" % (self._print(expr.base.label), self._print(elem))

sympy.sympy.printing.rust._print_Idx

def _print_Idx(self, expr):
    return expr.label.name

sympy.sympy.printing.rust._print_Dummy

def _print_Dummy(self, expr):
    return expr.name

sympy.sympy.printing.rust._print_Exp1

def _print_Exp1(self, expr, _type=False):
    return "E"

sympy.sympy.printing.rust._print_Pi

def _print_Pi(self, expr, _type=False):
    return 'PI'

sympy.sympy.printing.rust._print_Infinity

def _print_Infinity(self, expr, _type=False):
    return 'INFINITY'

sympy.sympy.printing.rust._print_NegativeInfinity

def _print_NegativeInfinity(self, expr, _type=False):
    return 'NEG_INFINITY'

sympy.sympy.printing.rust._print_BooleanTrue

def _print_BooleanTrue(self, expr, _type=False):
    return "true"

sympy.sympy.printing.rust._print_BooleanFalse

def _print_BooleanFalse(self, expr, _type=False):
    return "false"

sympy.sympy.printing.rust._print_NaN

def _print_NaN(self, expr, _type=False):
    return "NAN"

sympy.sympy.printing.rust._print_Piecewise

def _print_Piecewise(self, expr):
    if expr.args[-1].cond != True:
        # We need the last conditional to be a True, otherwise the resulting
        # function may not return a result.
        raise ValueError("All Piecewise expressions must contain an "
                         "(expr, True) statement to be used as a default "
                         "condition. Without one, the generated "
                         "expression may not evaluate to anything under "
                         "some condition.")
    lines = []

    for i, (e, c) in enumerate(expr.args):
        if i == 0:
            lines.append("if (%s) {" % self._print(c))
        elif i == len(expr.args) - 1 and c == True:
            lines[-1] += " else {"
        else:
            lines[-1] += " else if (%s) {" % self._print(c)
        code0 = self._print(e)
        lines.append(code0)
        lines.append("}")

    if self._settings['inline']:
        return " ".join(lines)
    else:
        return "\n".join(lines)

sympy.sympy.printing.rust._print_ITE

def _print_ITE(self, expr):
    from sympy.functions import Piecewise
    return self._print(expr.rewrite(Piecewise, deep=False))

sympy.sympy.printing.rust._print_MatrixBase

def _print_MatrixBase(self, A):
    if A.cols == 1:
        return "[%s]" % ", ".join(self._print(a) for a in A)
    else:
        raise ValueError("Full Matrix Support in Rust need Crates (https://crates.io/keywords/matrix).")

sympy.sympy.printing.rust._print_SparseRepMatrix

def _print_SparseRepMatrix(self, mat):
    # do not allow sparse matrices to be made dense
    return self._print_not_supported(mat)

sympy.sympy.printing.rust._print_MatrixElement

def _print_MatrixElement(self, expr):
    return "%s[%s]" % (expr.parent,
                       expr.j + expr.i*expr.parent.shape[1])

sympy.sympy.printing.rust._print_Symbol

def _print_Symbol(self, expr):

    name = super()._print_Symbol(expr)

    if expr in self._dereference:
        return '(*%s)' % name
    else:
        return name

sympy.sympy.printing.rust._print_Assignment

def _print_Assignment(self, expr):
    from sympy.tensor.indexed import IndexedBase
    lhs = expr.lhs
    rhs = expr.rhs
    if self._settings["contract"] and (lhs.has(IndexedBase) or
            rhs.has(IndexedBase)):
        # Here we check if there is looping to be done, and if so
        # print the required loops.
        return self._doprint_loops(rhs, lhs)
    else:
        lhs_code = self._print(lhs)
        rhs_code = self._print(rhs)
        return self._get_statement("%s = %s" % (lhs_code, rhs_code))

sympy.sympy.printing.rust._print_sign

def _print_sign(self, expr):
    arg = self._print(expr.args[0])
    return "(if (%s == 0.0) { 0.0 } else { (%s).signum() })" % (arg, arg)

sympy.sympy.printing.smtlib._print_Function

def _print_Function(self, e):
    if e in self._known_functions:
        op = self._known_functions[e]
    elif type(e) in self._known_functions:
        op = self._known_functions[type(e)]
    elif type(type(e)) == UndefinedFunction:
        op = e.name
    elif isinstance(e, AppliedBinaryRelation) and e.function in self._known_functions:
        op = self._known_functions[e.function]
        return self._s_expr(op, e.arguments)
    else:
        op = self._known_functions[e]  # throw KeyError

    return self._s_expr(op, e.args)

sympy.sympy.printing.smtlib._print_Relational

def _print_Relational(self, e: Relational):
    return self._print_Function(e)

sympy.sympy.printing.smtlib._print_BooleanFunction

def _print_BooleanFunction(self, e: BooleanFunction):
    return self._print_Function(e)

sympy.sympy.printing.smtlib._print_Expr

def _print_Expr(self, e: Expr):
    return self._print_Function(e)

sympy.sympy.printing.smtlib._print_Unequality

def _print_Unequality(self, e: Unequality):
    if type(e) in self._known_functions:
        return self._print_Relational(e)  # default
    else:
        eq_op = self._known_functions[Equality]
        not_op = self._known_functions[Not]
        return self._s_expr(not_op, [self._s_expr(eq_op, e.args)])

sympy.sympy.printing.smtlib._print_Piecewise

def _print_Piecewise(self, e: Piecewise):
    def _print_Piecewise_recursive(args: typing.Union[list, tuple]):
        e, c = args[0]
        if len(args) == 1:
            assert (c is True) or isinstance(c, BooleanTrue)
            return self._print(e)
        else:
            ite = self._known_functions[ITE]
            return self._s_expr(ite, [
                c, e, _print_Piecewise_recursive(args[1:])
            ])

    return _print_Piecewise_recursive(e.args)

sympy.sympy.printing.smtlib._print_Interval

def _print_Interval(self, e: Interval):
    if e.start.is_infinite and e.end.is_infinite:
        return ''
    elif e.start.is_infinite != e.end.is_infinite:
        raise ValueError(f'One-sided intervals (`{e}`) are not supported in SMT.')
    else:
        return f'[{e.start}, {e.end}]'

sympy.sympy.printing.smtlib._print_AppliedPredicate

def _print_AppliedPredicate(self, e: AppliedPredicate):
    if e.function == Q.positive:
        rel = Q.gt(e.arguments[0],0)
    elif e.function == Q.negative:
        rel = Q.lt(e.arguments[0], 0)
    elif e.function == Q.zero:
        rel = Q.eq(e.arguments[0], 0)
    elif e.function == Q.nonpositive:
        rel = Q.le(e.arguments[0], 0)
    elif e.function == Q.nonnegative:
        rel = Q.ge(e.arguments[0], 0)
    elif e.function == Q.nonzero:
        rel = Q.ne(e.arguments[0], 0)
    else:
        raise ValueError(f"Predicate (`{e}`) is not handled.")

    return self._print_AppliedBinaryRelation(rel)

sympy.sympy.printing.smtlib._print_AppliedBinaryRelation

def _print_AppliedBinaryRelation(self, e: AppliedPredicate):
    if e.function == Q.ne:
        return self._print_Unequality(Unequality(*e.arguments))
    else:
        return self._print_Function(e)

sympy.sympy.printing.smtlib._print_BooleanTrue

def _print_BooleanTrue(self, x: BooleanTrue):
    return 'true'

sympy.sympy.printing.smtlib._print_BooleanFalse

def _print_BooleanFalse(self, x: BooleanFalse):
    return 'false'

sympy.sympy.printing.smtlib._print_Float

def _print_Float(self, x: Float):
    dps = prec_to_dps(x._prec)
    str_real = mlib_to_str(x._mpf_, dps, strip_zeros=True, min_fixed=None, max_fixed=None)

    if 'e' in str_real:
        (mant, exp) = str_real.split('e')

        if exp[0] == '+':
            exp = exp[1:]

        mul = self._known_functions[Mul]
        pow = self._known_functions[Pow]

        return r"(%s %s (%s 10 %s))" % (mul, mant, pow, exp)
    elif str_real in ["+inf", "-inf"]:
        raise ValueError("Infinite values are not supported in SMT.")
    else:
        return str_real

sympy.sympy.printing.smtlib._print_Rational

def _print_Rational(self, x: Rational):
    return self._s_expr('/', [x.p, x.q])

sympy.sympy.printing.smtlib._print_Integer

def _print_Integer(self, x: Integer):
    assert x.q == 1
    return str(x.p)

sympy.sympy.printing.smtlib._print_int

def _print_int(self, x: int):
    return str(x)

sympy.sympy.printing.smtlib._print_Symbol

def _print_Symbol(self, x: Symbol):
    assert self._is_legal_name(x.name)
    return x.name

sympy.sympy.printing.smtlib._print_NumberSymbol

def _print_NumberSymbol(self, x):
    name = self._known_constants.get(x)
    if name:
        return name
    else:
        f = x.evalf(self._precision) if self._precision else x.evalf()
        return self._print_Float(f)

sympy.sympy.printing.smtlib._print_UndefinedFunction

def _print_UndefinedFunction(self, x):
    assert self._is_legal_name(x.name)
    return x.name

sympy.sympy.printing.smtlib._print_Exp1

def _print_Exp1(self, x):
    return (
        self._print_Function(exp(1, evaluate=False))
        if exp in self._known_functions else
        self._print_NumberSymbol(x)
    )

sympy.sympy.printing.str._print_str

def _print_str(self, expr):
    return str(expr)

sympy.sympy.printing.str._print_Str

def _print_Str(self, s):
    return self._print(s.name)

sympy.sympy.printing.str._print_Basic

def _print_Basic(self, expr):
    l = [self._print(o) for o in expr.args]
    return expr.__class__.__name__ + "(%s)" % ", ".join(l)

sympy.sympy.printing.str._print_BlockMatrix

def _print_BlockMatrix(self, B):
    if B.blocks.shape == (1, 1):
        self._print(B.blocks[0, 0])
    return self._print(B.blocks)

sympy.sympy.printing.str._print_Catalan

def _print_Catalan(self, expr):
    return 'Catalan'

sympy.sympy.printing.str._print_ComplexInfinity

def _print_ComplexInfinity(self, expr):
    return 'zoo'

sympy.sympy.printing.str._print_ConditionSet

def _print_ConditionSet(self, s):
    args = tuple([self._print(i) for i in (s.sym, s.condition)])
    if s.base_set is S.UniversalSet:
        return 'ConditionSet(%s, %s)' % args
    args += (self._print(s.base_set),)
    return 'ConditionSet(%s, %s, %s)' % args

sympy.sympy.printing.str._print_Derivative

def _print_Derivative(self, expr):
    dexpr = expr.expr
    dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
    return 'Derivative(%s)' % ", ".join((self._print(arg) for arg in [dexpr] + dvars))

sympy.sympy.printing.str._print_dict

def _print_dict(self, d):
    keys = sorted(d.keys(), key=default_sort_key)
    items = []

    for key in keys:
        item = "%s: %s" % (self._print(key), self._print(d[key]))
        items.append(item)

    return "{%s}" % ", ".join(items)

sympy.sympy.printing.str._print_Dict

def _print_Dict(self, expr):
    return self._print_dict(expr)

sympy.sympy.printing.str._print_RandomDomain

def _print_RandomDomain(self, d):
    if hasattr(d, 'as_boolean'):
        return 'Domain: ' + self._print(d.as_boolean())
    elif hasattr(d, 'set'):
        return ('Domain: ' + self._print(d.symbols) + ' in ' +
                self._print(d.set))
    else:
        return 'Domain on ' + self._print(d.symbols)

sympy.sympy.printing.str._print_Dummy

def _print_Dummy(self, expr):
    return '_' + expr.name

sympy.sympy.printing.str._print_EulerGamma

def _print_EulerGamma(self, expr):
    return 'EulerGamma'

sympy.sympy.printing.str._print_Exp1

def _print_Exp1(self, expr):
    return 'E'

sympy.sympy.printing.str._print_ExprCondPair

def _print_ExprCondPair(self, expr):
    return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))

sympy.sympy.printing.str._print_Function

def _print_Function(self, expr):
    return expr.func.__name__ + "(%s)" % self.stringify(expr.args, ", ")

sympy.sympy.printing.str._print_GoldenRatio

def _print_GoldenRatio(self, expr):
    return 'GoldenRatio'

sympy.sympy.printing.str._print_Heaviside

def _print_Heaviside(self, expr):
    # Same as _print_Function but uses pargs to suppress default 1/2 for
    # 2nd args
    return expr.func.__name__ + "(%s)" % self.stringify(expr.pargs, ", ")

sympy.sympy.printing.str._print_TribonacciConstant

def _print_TribonacciConstant(self, expr):
    return 'TribonacciConstant'

sympy.sympy.printing.str._print_ImaginaryUnit

def _print_ImaginaryUnit(self, expr):
    return 'I'

sympy.sympy.printing.str._print_Infinity

def _print_Infinity(self, expr):
    return 'oo'

sympy.sympy.printing.str._print_Integral

def _print_Integral(self, expr):
    def _xab_tostr(xab):
        if len(xab) == 1:
            return self._print(xab[0])
        else:
            return self._print((xab[0],) + tuple(xab[1:]))
    L = ', '.join([_xab_tostr(l) for l in expr.limits])
    return 'Integral(%s, %s)' % (self._print(expr.function), L)

sympy.sympy.printing.str._print_Interval

def _print_Interval(self, i):
    fin =  'Interval{m}({a}, {b})'
    a, b, l, r = i.args
    if a.is_infinite and b.is_infinite:
        m = ''
    elif a.is_infinite and not r:
        m = ''
    elif b.is_infinite and not l:
        m = ''
    elif not l and not r:
        m = ''
    elif l and r:
        m = '.open'
    elif l:
        m = '.Lopen'
    else:
        m = '.Ropen'
    return fin.format(**{'a': a, 'b': b, 'm': m})

sympy.sympy.printing.str._print_AccumulationBounds

def _print_AccumulationBounds(self, i):
    return "AccumBounds(%s, %s)" % (self._print(i.min),
                                    self._print(i.max))

sympy.sympy.printing.str._print_Inverse

def _print_Inverse(self, I):
    return "%s**(-1)" % self.parenthesize(I.arg, PRECEDENCE["Pow"])

sympy.sympy.printing.str._print_Lambda

def _print_Lambda(self, obj):
    expr = obj.expr
    sig = obj.signature
    if len(sig) == 1 and sig[0].is_symbol:
        sig = sig[0]
    return "Lambda(%s, %s)" % (self._print(sig), self._print(expr))

sympy.sympy.printing.str._print_LatticeOp

def _print_LatticeOp(self, expr):
    args = sorted(expr.args, key=default_sort_key)
    return expr.func.__name__ + "(%s)" % ", ".join(self._print(arg) for arg in args)

sympy.sympy.printing.str._print_Limit

def _print_Limit(self, expr):
    e, z, z0, dir = expr.args
    return "Limit(%s, %s, %s, dir='%s')" % tuple(map(self._print, (e, z, z0, dir)))

sympy.sympy.printing.str._print_list

def _print_list(self, expr):
    return "[%s]" % self.stringify(expr, ", ")

sympy.sympy.printing.str._print_List

def _print_List(self, expr):
    return self._print_list(expr)

sympy.sympy.printing.str._print_MatrixBase

def _print_MatrixBase(self, expr):
    return expr._format_str(self)

sympy.sympy.printing.str._print_MatrixElement

def _print_MatrixElement(self, expr):
    return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
        + '[%s, %s]' % (self._print(expr.i), self._print(expr.j))

sympy.sympy.printing.str._print_MatrixSlice

def _print_MatrixSlice(self, expr):
    def strslice(x, dim):
        x = list(x)
        if x[2] == 1:
            del x[2]
        if x[0] == 0:
            x[0] = ''
        if x[1] == dim:
            x[1] = ''
        return ':'.join((self._print(arg) for arg in x))
    return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + '[' +
            strslice(expr.rowslice, expr.parent.rows) + ', ' +
            strslice(expr.colslice, expr.parent.cols) + ']')

sympy.sympy.printing.str._print_DeferredVector

def _print_DeferredVector(self, expr):
    return expr.name

sympy.sympy.printing.str._print_Mul

def _print_Mul(self, expr):

    prec = precedence(expr)

    # Check for unevaluated Mul. In this case we need to make sure the
    # identities are visible, multiple Rational factors are not combined
    # etc so we display in a straight-forward form that fully preserves all
    # args and their order.
    args = expr.args
    if args[0] is S.One or any(
            isinstance(a, Number) or
            a.is_Pow and all(ai.is_Integer for ai in a.args)
            for a in args[1:]):
        d, n = sift(args, lambda x:
            isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0),
            binary=True)
        for i, di in enumerate(d):
            if di.exp.is_Number:
                e = -di.exp
            else:
                dargs = list(di.exp.args)
                dargs[0] = -dargs[0]
                e = Mul._from_args(dargs)
            d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base

        pre = []
        # don't parenthesize first factor if negative
        if n and not n[0].is_Add and n[0].could_extract_minus_sign():
            pre = [self._print(n.pop(0))]

        nfactors = pre + [self.parenthesize(a, prec, strict=False)
            for a in n]
        if not nfactors:
            nfactors = ['1']

        # don't parenthesize first of denominator unless singleton
        if len(d) > 1 and d[0].could_extract_minus_sign():
            pre = [self._print(d.pop(0))]
        else:
            pre = []
        dfactors = pre + [self.parenthesize(a, prec, strict=False)
            for a in d]

        n = '*'.join(nfactors)
        d = '*'.join(dfactors)
        if len(dfactors) > 1:
            return '%s/(%s)' % (n, d)
        elif dfactors:
            return '%s/%s' % (n, d)
        return n

    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = "-"
    else:
        sign = ""

    a = []  # items in the numerator
    b = []  # items that are in the denominator (if any)

    pow_paren = []  # Will collect all pow with more than one base element and exp = -1

    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        # use make_args in case expr was something like -x -> x
        args = Mul.make_args(expr)

    # Gather args for numerator/denominator
    def apow(i):
        b, e = i.as_base_exp()
        eargs = list(Mul.make_args(e))
        if eargs[0] is S.NegativeOne:
            eargs = eargs[1:]
        else:
            eargs[0] = -eargs[0]
        e = Mul._from_args(eargs)
        if isinstance(i, Pow):
            return i.func(b, e, evaluate=False)
        return i.func(e, evaluate=False)
    for item in args:
        if (item.is_commutative and
                isinstance(item, Pow) and
                bool(item.exp.as_coeff_Mul()[0] < 0)):
            if item.exp is not S.NegativeOne:
                b.append(apow(item))
            else:
                if (len(item.args[0].args) != 1 and
                        isinstance(item.base, (Mul, Pow))):
                    # To avoid situations like #14160
                    pow_paren.append(item)
                b.append(item.base)
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append(Rational(item.p))
            if item.q != 1:
                b.append(Rational(item.q))
        else:
            a.append(item)

    a = a or [S.One]

    a_str = [self.parenthesize(x, prec, strict=False) for x in a]
    b_str = [self.parenthesize(x, prec, strict=False) for x in b]

    # To parenthesize Pow with exp = -1 and having more than one Symbol
    for item in pow_paren:
        if item.base in b:
            b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]

    if not b:
        return sign + '*'.join(a_str)
    elif len(b) == 1:
        return sign + '*'.join(a_str) + "/" + b_str[0]
    else:
        return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)

sympy.sympy.printing.str._print_MatMul

def _print_MatMul(self, expr):
    c, m = expr.as_coeff_mmul()

    sign = ""
    if c.is_number:
        re, im = c.as_real_imag()
        if im.is_zero and re.is_negative:
            expr = _keep_coeff(-c, m)
            sign = "-"
        elif re.is_zero and im.is_negative:
            expr = _keep_coeff(-c, m)
            sign = "-"

    return sign + '*'.join(
        [self.parenthesize(arg, precedence(expr)) for arg in expr.args]
    )

sympy.sympy.printing.str._print_ElementwiseApplyFunction

def _print_ElementwiseApplyFunction(self, expr):
    return "{}.({})".format(
        expr.function,
        self._print(expr.expr),
    )

sympy.sympy.printing.str._print_NaN

def _print_NaN(self, expr):
    return 'nan'

sympy.sympy.printing.str._print_NegativeInfinity

def _print_NegativeInfinity(self, expr):
    return '-oo'

sympy.sympy.printing.str._print_Order

def _print_Order(self, expr):
    if not expr.variables or all(p is S.Zero for p in expr.point):
        if len(expr.variables) <= 1:
            return 'O(%s)' % self._print(expr.expr)
        else:
            return 'O(%s)' % self.stringify((expr.expr,) + expr.variables, ', ', 0)
    else:
        return 'O(%s)' % self.stringify(expr.args, ', ', 0)

sympy.sympy.printing.str._print_Cycle

def _print_Cycle(self, expr):
    return expr.__str__()

sympy.sympy.printing.str._print_Permutation

def _print_Permutation(self, expr):
    from sympy.combinatorics.permutations import Permutation, Cycle
    from sympy.utilities.exceptions import sympy_deprecation_warning

    perm_cyclic = Permutation.print_cyclic
    if perm_cyclic is not None:
        sympy_deprecation_warning(
            f"""
            Setting Permutation.print_cyclic is deprecated. Instead use
            init_printing(perm_cyclic={perm_cyclic}).
            """,
            deprecated_since_version="1.6",
            active_deprecations_target="deprecated-permutation-print_cyclic",
            stacklevel=7,
        )
    else:
        perm_cyclic = self._settings.get("perm_cyclic", True)

    if perm_cyclic:
        if not expr.size:
            return '()'
        # before taking Cycle notation, see if the last element is
        # a singleton and move it to the head of the string
        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]
        last = s.rfind('(')
        if not last == 0 and ',' not in s[last:]:
            s = s[last:] + s[:last]
        s = s.replace(',', '')
        return s
    else:
        s = expr.support()
        if not s:
            if expr.size < 5:
                return 'Permutation(%s)' % self._print(expr.array_form)
            return 'Permutation([], size=%s)' % self._print(expr.size)
        trim = self._print(expr.array_form[:s[-1] + 1]) + ', size=%s' % self._print(expr.size)
        use = full = self._print(expr.array_form)
        if len(trim) < len(full):
            use = trim
        return 'Permutation(%s)' % use

sympy.sympy.printing.str.emptyPrinter

def emptyPrinter(self, expr):
    if isinstance(expr, str):
        return expr
    elif isinstance(expr, Basic):
        return repr(expr)
    else:
        return str(expr)

sympy.sympy.printing.str._print_Subs

def _print_Subs(self, obj):
    expr, old, new = obj.args
    if len(obj.point) == 1:
        old = old[0]
        new = new[0]
    return "Subs(%s, %s, %s)" % (
        self._print(expr), self._print(old), self._print(new))

sympy.sympy.printing.str._print_TensorIndex

def _print_TensorIndex(self, expr):
    return expr._print()

sympy.sympy.printing.str._print_TensorHead

def _print_TensorHead(self, expr):
    return expr._print()

sympy.sympy.printing.str._print_Tensor

def _print_Tensor(self, expr):
    return expr._print()

sympy.sympy.printing.str._print_TensMul

def _print_TensMul(self, expr):
    # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
    sign, args = expr._get_args_for_traditional_printer()
    return sign + "*".join(
        [self.parenthesize(arg, precedence(expr)) for arg in args]
    )

sympy.sympy.printing.str._print_TensAdd

def _print_TensAdd(self, expr):
    return expr._print()

sympy.sympy.printing.str._print_ArraySymbol

def _print_ArraySymbol(self, expr):
    return self._print(expr.name)

sympy.sympy.printing.str._print_ArrayElement

def _print_ArrayElement(self, expr):
    return "%s[%s]" % (
        self.parenthesize(expr.name, PRECEDENCE["Func"], True), ", ".join([self._print(i) for i in expr.indices]))

sympy.sympy.printing.str._print_Pi

def _print_Pi(self, expr):
    return 'pi'

sympy.sympy.printing.str._print_PolyRing

def _print_PolyRing(self, ring):
    return "Polynomial ring in %s over %s with %s order" % \
        (", ".join((self._print(rs) for rs in ring.symbols)),
        self._print(ring.domain), self._print(ring.order))

sympy.sympy.printing.str._print_FracField

def _print_FracField(self, field):
    return "Rational function field in %s over %s with %s order" % \
        (", ".join((self._print(fs) for fs in field.symbols)),
        self._print(field.domain), self._print(field.order))

sympy.sympy.printing.str._print_GaussianElement

def _print_GaussianElement(self, poly):
    return "(%s + %s*I)" % (poly.x, poly.y)

sympy.sympy.printing.str._print_PolyElement

def _print_PolyElement(self, poly):
    return poly.str(self, PRECEDENCE, "%s**%s", "*")

sympy.sympy.printing.str._print_FracElement

def _print_FracElement(self, frac):
    if frac.denom == 1:
        return self._print(frac.numer)
    else:
        numer = self.parenthesize(frac.numer, PRECEDENCE["Mul"], strict=True)
        denom = self.parenthesize(frac.denom, PRECEDENCE["Atom"], strict=True)
        return numer + "/" + denom

sympy.sympy.printing.str._print_Add

def _print_Add(self, expr, order=None):
    terms = self._as_ordered_terms(expr, order=order)

    prec = precedence(expr)
    l = []
    for term in terms:
        t = self._print(term)
        if t.startswith('-') and not term.is_Add:
            sign = "-"
            t = t[1:]
        else:
            sign = "+"
        if precedence(term) < prec or term.is_Add:
            l.extend([sign, "(%s)" % t])
        else:
            l.extend([sign, t])
    sign = l.pop(0)
    if sign == '+':
        sign = ""
    return sign + ' '.join(l)

sympy.sympy.printing.str._print_Poly

def _print_Poly(self, expr):
    ATOM_PREC = PRECEDENCE["Atom"] - 1
    terms, gens = [], [ self.parenthesize(s, ATOM_PREC) for s in expr.gens ]

    for monom, coeff in expr.terms():
        s_monom = []

        for i, e in enumerate(monom):
            if e > 0:
                if e == 1:
                    s_monom.append(gens[i])
                else:
                    s_monom.append(gens[i] + "**%d" % e)

        s_monom = "*".join(s_monom)

        if coeff.is_Add:
            if s_monom:
                s_coeff = "(" + self._print(coeff) + ")"
            else:
                s_coeff = self._print(coeff)
        else:
            if s_monom:
                if coeff is S.One:
                    terms.extend(['+', s_monom])
                    continue

                if coeff is S.NegativeOne:
                    terms.extend(['-', s_monom])
                    continue

            s_coeff = self._print(coeff)

        if not s_monom:
            s_term = s_coeff
        else:
            s_term = s_coeff + "*" + s_monom

        if s_term.startswith('-'):
            terms.extend(['-', s_term[1:]])
        else:
            terms.extend(['+', s_term])

    if terms[0] in ('-', '+'):
        modifier = terms.pop(0)

        if modifier == '-':
            terms[0] = '-' + terms[0]

    format = expr.__class__.__name__ + "(%s, %s"

    from sympy.polys.polyerrors import PolynomialError

    try:
        format += ", modulus=%s" % expr.get_modulus()
    except PolynomialError:
        format += ", domain='%s'" % expr.get_domain()

    format += ")"

    for index, item in enumerate(gens):
        if len(item) > 2 and (item[:1] == "(" and item[len(item) - 1:] == ")"):
            gens[index] = item[1:len(item) - 1]

    return format % (' '.join(terms), ', '.join(gens))

sympy.sympy.printing.str._print_UniversalSet

def _print_UniversalSet(self, p):
    return 'UniversalSet'

sympy.sympy.printing.str._print_AlgebraicNumber

def _print_AlgebraicNumber(self, expr):
    if expr.is_aliased:
        return self._print(expr.as_poly().as_expr())
    else:
        return self._print(expr.as_expr())

sympy.sympy.printing.str._print_Pow

def _print_Pow(self, expr, rational=False):
    """Printing helper function for ``Pow``

    Parameters
    ==========

    rational : bool, optional
        If ``True``, it will not attempt printing ``sqrt(x)`` or
        ``x**S.Half`` as ``sqrt``, and will use ``x**(1/2)``
        instead.

        See examples for additional details

    Examples
    ========

    >>> from sympy import sqrt, StrPrinter
    >>> from sympy.abc import x

    How ``rational`` keyword works with ``sqrt``:

    >>> printer = StrPrinter()
    >>> printer._print_Pow(sqrt(x), rational=True)
    'x**(1/2)'
    >>> printer._print_Pow(sqrt(x), rational=False)
    'sqrt(x)'
    >>> printer._print_Pow(1/sqrt(x), rational=True)
    'x**(-1/2)'
    >>> printer._print_Pow(1/sqrt(x), rational=False)
    '1/sqrt(x)'

    Notes
    =====

    ``sqrt(x)`` is canonicalized as ``Pow(x, S.Half)`` in SymPy,
    so there is no need of defining a separate printer for ``sqrt``.
    Instead, it should be handled here as well.
    """
    PREC = precedence(expr)

    if expr.exp is S.Half and not rational:
        return "sqrt(%s)" % self._print(expr.base)

    if expr.is_commutative:
        if -expr.exp is S.Half and not rational:
            # Note: Don't test "expr.exp == -S.Half" here, because that will
            # match -0.5, which we don't want.
            return "%s/sqrt(%s)" % tuple((self._print(arg) for arg in (S.One, expr.base)))
        if expr.exp is -S.One:
            # Similarly to the S.Half case, don't test with "==" here.
            return '%s/%s' % (self._print(S.One),
                              self.parenthesize(expr.base, PREC, strict=False))

    e = self.parenthesize(expr.exp, PREC, strict=False)
    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and expr.exp.q != 1:
        # the parenthesized exp should be '(Rational(a, b))' so strip parens,
        # but just check to be sure.
        if e.startswith('(Rational'):
            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)

sympy.sympy.printing.str._print_UnevaluatedExpr

def _print_UnevaluatedExpr(self, expr):
    return self._print(expr.args[0])

sympy.sympy.printing.str._print_MatPow

def _print_MatPow(self, expr):
    PREC = precedence(expr)
    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False),
                     self.parenthesize(expr.exp, PREC, strict=False))

sympy.sympy.printing.str._print_Integer

def _print_Integer(self, expr):
    if self._settings.get("sympy_integers", False):
        return "S(%s)" % (expr)
    return str(expr.p)

sympy.sympy.printing.str._print_Integers

def _print_Integers(self, expr):
    return 'Integers'

sympy.sympy.printing.str._print_Naturals

def _print_Naturals(self, expr):
    return 'Naturals'

sympy.sympy.printing.str._print_Naturals0

def _print_Naturals0(self, expr):
    return 'Naturals0'

sympy.sympy.printing.str._print_Reals

def _print_Reals(self, expr):
    return 'Reals'

sympy.sympy.printing.str._print_Complexes

def _print_Complexes(self, expr):
    return 'Complexes'

sympy.sympy.printing.str._print_EmptySet

def _print_EmptySet(self, expr):
    return 'EmptySet'

sympy.sympy.printing.str._print_int

def _print_int(self, expr):
    return str(expr)

sympy.sympy.printing.str._print_Rational

def _print_Rational(self, expr):
    if expr.q == 1:
        return str(expr.p)
    else:
        if self._settings.get("sympy_integers", False):
            return "S(%s)/%s" % (expr.p, expr.q)
        return "%s/%s" % (expr.p, expr.q)

sympy.sympy.printing.str._print_Float

def _print_Float(self, expr):
    prec = expr._prec
    dps = self._settings.get('dps', None)
    if dps is None:
        dps = 0 if prec < 5 else prec_to_dps(expr._prec)
    if self._settings["full_prec"] is True:
        strip = False
    elif self._settings["full_prec"] is False:
        strip = True
    elif self._settings["full_prec"] == "auto":
        strip = self._print_level > 1
    low = self._settings["min"] if "min" in self._settings else None
    high = self._settings["max"] if "max" in self._settings else None
    rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
    if rv.startswith('-.0'):
        rv = '-0.' + rv[3:]
    elif rv.startswith('.0'):
        rv = '0.' + rv[2:]
    rv = rv.removeprefix('+') # e.g., +inf -> inf
    return rv

sympy.sympy.printing.str._print_BooleanTrue

def _print_BooleanTrue(self, expr):
    return "True"

sympy.sympy.printing.str._print_Relational

def _print_Relational(self, expr):

    charmap = {
        "==": "Eq",
        "!=": "Ne",
        ":=": "Assignment",
        '+=': "AddAugmentedAssignment",
        "-=": "SubAugmentedAssignment",
        "*=": "MulAugmentedAssignment",
        "/=": "DivAugmentedAssignment",
        "%=": "ModAugmentedAssignment",
    }

    if expr.rel_op in charmap:
        return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs),
                               self._print(expr.rhs))

    return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
                       self._relationals.get(expr.rel_op) or expr.rel_op,
                       self.parenthesize(expr.rhs, precedence(expr)))

sympy.sympy.printing.str._print_BooleanFalse

def _print_BooleanFalse(self, expr):
    return "False"

sympy.sympy.printing.str._print_ComplexRootOf

def _print_ComplexRootOf(self, expr):
    return "CRootOf(%s, %d)" % (self._print_Add(expr.expr,  order='lex'),
                                expr.index)

sympy.sympy.printing.str._print_RootSum

def _print_RootSum(self, expr):
    args = [self._print_Add(expr.expr, order='lex')]

    if expr.fun is not S.IdentityFunction:
        args.append(self._print(expr.fun))

    return "RootSum(%s)" % ", ".join(args)

sympy.sympy.printing.str._print_GroebnerBasis

def _print_GroebnerBasis(self, basis):
    cls = basis.__class__.__name__

    exprs = [self._print_Add(arg, order=basis.order) for arg in basis.exprs]
    exprs = "[%s]" % ", ".join(exprs)

    gens = [ self._print(gen) for gen in basis.gens ]
    domain = "domain='%s'" % self._print(basis.domain)
    order = "order='%s'" % self._print(basis.order)

    args = [exprs] + gens + [domain, order]

    return "%s(%s)" % (cls, ", ".join(args))

sympy.sympy.printing.str._print_Not

def _print_Not(self, expr):
    return '~%s' %(self.parenthesize(expr.args[0],PRECEDENCE["Not"]))

sympy.sympy.printing.str._print_set

def _print_set(self, s):
    items = sorted(s, key=default_sort_key)

    args = ', '.join(self._print(item) for item in items)
    if not args:
        return "set()"
    return '{%s}' % args

sympy.sympy.printing.str._print_FiniteSet

def _print_FiniteSet(self, s):
    from sympy.sets.sets import FiniteSet
    items = sorted(s, key=default_sort_key)

    args = ', '.join(self._print(item) for item in items)
    if any(item.has(FiniteSet) for item in items):
        return 'FiniteSet({})'.format(args)
    return '{{{}}}'.format(args)

sympy.sympy.printing.str._print_Partition

def _print_Partition(self, s):
    items = sorted(s, key=default_sort_key)

    args = ', '.join(self._print(arg) for arg in items)
    return 'Partition({})'.format(args)

sympy.sympy.printing.str._print_frozenset

def _print_frozenset(self, s):
    if not s:
        return "frozenset()"
    return "frozenset(%s)" % self._print_set(s)

sympy.sympy.printing.str._print_And

def _print_And(self, expr):
    args = list(expr.args)
    for j, i in enumerate(args):
        if isinstance(i, Relational) and (
                i.canonical.rhs is S.NegativeInfinity):
            args.insert(0, args.pop(j))
    return self.stringify(args, " & ", PRECEDENCE["BitwiseAnd"])

sympy.sympy.printing.str._print_Sum

def _print_Sum(self, expr):
    def _xab_tostr(xab):
        if len(xab) == 1:
            return self._print(xab[0])
        else:
            return self._print((xab[0],) + tuple(xab[1:]))
    L = ', '.join([_xab_tostr(l) for l in expr.limits])
    return 'Sum(%s, %s)' % (self._print(expr.function), L)

sympy.sympy.printing.str._print_Symbol

def _print_Symbol(self, expr):
    return expr.name

sympy.sympy.printing.str._print_Identity

def _print_Identity(self, expr):
    return "I"

sympy.sympy.printing.str._print_ZeroMatrix

def _print_ZeroMatrix(self, expr):
    return "0"

sympy.sympy.printing.str._print_OneMatrix

def _print_OneMatrix(self, expr):
    return "1"

sympy.sympy.printing.str._print_Predicate

def _print_Predicate(self, expr):
    return "Q.%s" % expr.name

sympy.sympy.printing.str._print_tuple

def _print_tuple(self, expr):
    if len(expr) == 1:
        return "(%s,)" % self._print(expr[0])
    else:
        return "(%s)" % self.stringify(expr, ", ")

sympy.sympy.printing.str._print_Tuple

def _print_Tuple(self, expr):
    return self._print_tuple(expr)

sympy.sympy.printing.str._print_Transpose

def _print_Transpose(self, T):
    return "%s.T" % self.parenthesize(T.arg, PRECEDENCE["Pow"])

sympy.sympy.printing.str._print_Quantity

def _print_Quantity(self, expr):
    if self._settings.get("abbrev", False):
        return "%s" % expr.abbrev
    return "%s" % expr.name

sympy.sympy.printing.str._print_Quaternion

def _print_Quaternion(self, expr):
    s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
    a = [s[0]] + [i+"*"+j for i, j in zip(s[1:], "ijk")]
    return " + ".join(a)

sympy.sympy.printing.str._print_Wild

def _print_Wild(self, expr):
    return expr.name + '_'

sympy.sympy.printing.str._print_WildFunction

def _print_WildFunction(self, expr):
    return expr.name + '_'

sympy.sympy.printing.str._print_Zero

def _print_Zero(self, expr):
    if self._settings.get("sympy_integers", False):
        return "S(0)"
    return self._print_Integer(Integer(0))

sympy.sympy.printing.str._print_Or

def _print_Or(self, expr):
    return self.stringify(expr.args, " | ", PRECEDENCE["BitwiseOr"])

sympy.sympy.printing.str._print_DMF

def _print_DMF(self, expr):
    cls = expr.__class__.__name__
    num = self._print(expr.num)
    den = self._print(expr.den)
    dom = self._print(expr.dom)

    return "%s(%s, %s, %s)" % (cls, num, den, dom)

sympy.sympy.printing.str._print_Object

def _print_Object(self, obj):
    return 'Object("%s")' % obj.name

sympy.sympy.printing.str._print_IdentityMorphism

def _print_IdentityMorphism(self, morphism):
    return 'IdentityMorphism(%s)' % morphism.domain

sympy.sympy.printing.str._print_NamedMorphism

def _print_NamedMorphism(self, morphism):
    return 'NamedMorphism(%s, %s, "%s")' % \
           (morphism.domain, morphism.codomain, morphism.name)

sympy.sympy.printing.str._print_Category

def _print_Category(self, category):
    return 'Category("%s")' % category.name

sympy.sympy.printing.str._print_Manifold

def _print_Manifold(self, manifold):
    return manifold.name.name

sympy.sympy.printing.str._print_Xor

def _print_Xor(self, expr):
    return self.stringify(expr.args, " ^ ", PRECEDENCE["BitwiseXor"])

sympy.sympy.printing.str._print_Patch

def _print_Patch(self, patch):
    return patch.name.name

sympy.sympy.printing.str._print_CoordSystem

def _print_CoordSystem(self, coords):
    return coords.name.name

sympy.sympy.printing.str._print_BaseScalarField

def _print_BaseScalarField(self, field):
    return field._coord_sys.symbols[field._index].name

sympy.sympy.printing.str._print_Tr

def _print_Tr(self, expr):
    #TODO : Handle indices
    return "%s(%s)" % ("Tr", self._print(expr.args[0]))

sympy.sympy.printing.str._print_AppliedBinaryRelation

def _print_AppliedBinaryRelation(self, expr):
    rel = expr.function
    return '%s(%s, %s)' % (self._print(rel),
                           self._print(expr.lhs),
                           self._print(expr.rhs))

sympy.sympy.printing.str._print_AppliedPredicate

def _print_AppliedPredicate(self, expr):
    return '%s(%s)' % (
        self._print(expr.function), self.stringify(expr.arguments, ", "))

sympy.sympy.printing.tableform._sympystr

def _sympystr(self, p):
    """
    Returns the string representation of 'self'.

    Examples
    ========

    >>> from sympy import TableForm
    >>> t = TableForm([[5, 7], [4, 2], [10, 3]])
    >>> s = t.as_str()

    """
    column_widths = [0] * self._w
    lines = []
    for line in self._lines:
        new_line = []
        for i in range(self._w):
            # Format the item somehow if needed:
            s = str(line[i])
            if self._wipe_zeros and (s == "0"):
                s = " "
            w = len(s)
            if w > column_widths[i]:
                column_widths[i] = w
            new_line.append(s)
        lines.append(new_line)

    # Check heading:
    if self._headings[0]:
        self._headings[0] = [str(x) for x in self._headings[0]]
        _head_width = max(len(x) for x in self._headings[0])

    if self._headings[1]:
        new_line = []
        for i in range(self._w):
            # Format the item somehow if needed:
            s = str(self._headings[1][i])
            w = len(s)
            if w > column_widths[i]:
                column_widths[i] = w
            new_line.append(s)
        self._headings[1] = new_line

    format_str = []

    def _align(align, w):
        return '%%%s%ss' % (
            ("-" if align == "l" else ""),
            str(w))
    format_str = [_align(align, w) for align, w in
                  zip(self._alignments, column_widths)]
    if self._headings[0]:
        format_str.insert(0, _align(self._head_align, _head_width))
        format_str.insert(1, '|')
    format_str = ' '.join(format_str) + '\n'

    s = []
    if self._headings[1]:
        d = self._headings[1]
        if self._headings[0]:
            d = [""] + d
        first_line = format_str % tuple(d)
        s.append(first_line)
        s.append("-" * (len(first_line) - 1) + "\n")
    for i, line in enumerate(lines):
        d = [l if self._alignments[j] != 'c' else
             l.center(column_widths[j]) for j, l in enumerate(line)]
        if self._headings[0]:
            l = self._headings[0][i]
            l = (l if self._head_align != 'c' else
                 l.center(_head_width))
            d = [l] + d
        s.append(format_str % tuple(d))
    return ''.join(s)[:-1]  # don't include trailing newline

sympy.sympy.printing.tableform._latex

def _latex(self, printer):
    """
    Returns the string representation of 'self'.
    """
    # Check heading:
    if self._headings[1]:
        new_line = []
        for i in range(self._w):
            # Format the item somehow if needed:
            new_line.append(str(self._headings[1][i]))
        self._headings[1] = new_line

    alignments = []
    if self._headings[0]:
        self._headings[0] = [str(x) for x in self._headings[0]]
        alignments = [self._head_align]
    alignments.extend(self._alignments)

    s = r"\begin{tabular}{" + " ".join(alignments) + "}\n"

    if self._headings[1]:
        d = self._headings[1]
        if self._headings[0]:
            d = [""] + d
        first_line = " & ".join(d) + r" \\" + "\n"
        s += first_line
        s += r"\hline" + "\n"
    for i, line in enumerate(self._lines):
        d = []
        for j, x in enumerate(line):
            if self._wipe_zeros and (x in (0, "0")):
                d.append(" ")
                continue
            f = self._column_formats[j]
            if f:
                if isinstance(f, FunctionType):
                    v = f(x, i, j)
                    if v is None:
                        v = printer._print(x)
                else:
                    v = f % x
                d.append(v)
            else:
                v = printer._print(x)
                d.append("$%s$" % v)
        if self._headings[0]:
            d = [self._headings[0][i]] + d
        s += " & ".join(d) + r" \\" + "\n"
    s += r"\end{tabular}"
    return s

sympy.sympy.printing.tensorflow._print_Derivative

def _print_Derivative(self, expr):
    variables = expr.variables
    if any(isinstance(i, Iterable) for i in variables):
        raise NotImplementedError("derivation by multiple variables is not supported")
    def unfold(expr, args):
        if not args:
            return self._print(expr)
        return "%s(%s, %s)[0]" % (
                self._module_format("tensorflow.gradients"),
                unfold(expr, args[:-1]),
                self._print(args[-1]),
            )
    return unfold(expr.expr, variables)

sympy.sympy.printing.tensorflow._print_MatMul

def _print_MatMul(self, expr):
    from sympy.matrices.expressions import MatrixExpr
    mat_args = [arg for arg in expr.args if isinstance(arg, MatrixExpr)]
    args = [arg for arg in expr.args if arg not in mat_args]
    if args:
        return "%s*%s" % (
            self.parenthesize(Mul.fromiter(args), PRECEDENCE["Mul"]),
            self._expand_fold_binary_op(
                "tensorflow.linalg.matmul", mat_args)
        )
    else:
        return self._expand_fold_binary_op(
            "tensorflow.linalg.matmul", mat_args)

sympy.sympy.printing.tensorflow._print_Function

def _print_Function(self, expr):
    op = self.mapping.get(type(expr), None)
    if op is None:
        return super()._print_Basic(expr)
    children = [self._print(arg) for arg in expr.args]
    if len(children) == 1:
        return "%s(%s)" % (
            self._module_format(op),
            children[0]
        )
    else:
        return self._expand_fold_binary_op(op, children)

sympy.sympy.sets.fancysets.__iter__

def __iter__(self):
    n = self.size  # validate
    if not (n.has(S.Infinity) or n.has(S.NegativeInfinity) or n.is_Integer):
        raise TypeError("Cannot iterate over symbolic Range")
    if self.start in [S.NegativeInfinity, S.Infinity]:
        raise TypeError("Cannot iterate over Range with infinite start")
    elif self.start != self.stop:
        i = self.start
        if n.is_infinite:
            while True:
                yield i
                i += self.step
        else:
            for _ in range(n):
                yield i
                i += self.step

sympy.sympy.sets.setexpr._latex

def _latex(self, printer):
    return r"SetExpr\left({}\right)".format(printer._print(self.set))

sympy.sympy.simplify.cse_main.<genexpr>

symbols = (_ for _ in symbols if _.name not in excluded_symbols)



sympy.sympy.stats.rv.__getattr__

def __getattr__(self, attr):
    try:
        return self.args[self._argnames.index(attr)]
    except ValueError:
        raise AttributeError("'%s' object has no attribute '%s'" % (
            type(self).__name__, attr))

sympy.sympy.tensor.array.ndim_array._sympystr

def _sympystr(self, printer):
    def f(sh, shape_left, i, j):
        if len(shape_left) == 1:
            return "["+", ".join([printer._print(self[self._get_tuple_index(e)]) for e in range(i, j)])+"]"

        sh //= shape_left[0]
        return "[" + ", ".join([f(sh, shape_left[1:], i+e*sh, i+(e+1)*sh) for e in range(shape_left[0])]) + "]" # + "\n"*len(shape_left)

    if self.rank() == 0:
        return printer._print(self[()])
    if 0 in self.shape:
        return f"{self.__class__.__name__}([], {self.shape})"
    return f(self._loop_size, self.shape, 0, self._loop_size)

sympy.sympy.tensor.indexed._sympystr

def _sympystr(self, p):
    return p.doprint(self.label)

sympy.sympy.utilities.iterables.numbered_symbols

def numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions):
    """
    Generate an infinite stream of Symbols consisting of a prefix and
    increasing subscripts provided that they do not occur in ``exclude``.

    Parameters
    ==========

    prefix : str, optional
        The prefix to use. By default, this function will generate symbols of
        the form "x0", "x1", etc.

    cls : class, optional
        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``
        or ``Dummy``.

    start : int, optional
        The start number.  By default, it is 0.

    exclude : list, tuple, set of cls, optional
        Symbols to be excluded.

    *args, **kwargs
        Additional positional and keyword arguments are passed to the *cls* class.

    Returns
    =======

    sym : Symbol
        The subscripted symbols.
    """
    exclude = set(exclude or [])
    if cls is None:
        # We can't just make the default cls=Symbol because it isn't
        # imported yet.
        from sympy.core import Symbol
        cls = Symbol

    while True:
        name = '%s%s' % (prefix, start)
        s = cls(name, *args, **assumptions)
        if s not in exclude:
            yield s
        start += 1

sympy.sympy.vector.basisdependent._sympystr

def _sympystr(self, printer):
    return '0'

sympy.sympy.vector.coordsysrect._sympystr

def _sympystr(self, printer):
    return self._name

sympy.sympy.vector.dyadic._sympystr

def _sympystr(self, printer):
    items = list(self.components.items())
    items.sort(key=lambda x: x[0].__str__())
    return " + ".join(printer._print(k * v) for k, v in items)

sympy.sympy.vector.dyadic._sympyrepr

def _sympyrepr(self, printer):
    return "BaseDyadic({}, {})".format(
        printer._print(self.args[0]), printer._print(self.args[1]))

sympy.sympy.vector.scalar._latex

def _latex(self, printer=None):
    return self._latex_form

sympy.sympy.vector.scalar._pretty

def _pretty(self, printer=None):
    return prettyForm(self._pretty_form)

sympy.sympy.vector.scalar._sympystr

def _sympystr(self, printer):
    return self._name

sympy.sympy.vector.vector._sympystr

def _sympystr(self, printer):
    ret_str = ''
    items = list(self.separate().items())
    items.sort(key=lambda x: x[0].__str__())
    for system, vect in items:
        base_vects = system.base_vectors()
        for x in base_vects:
            if x in vect.components:
                temp_vect = self.components[x] * x
                ret_str += printer._print(temp_vect) + " + "
    return ret_str[:-3]

sympy.sympy.vector.vector._sympyrepr

def _sympyrepr(self, printer):
    index, system = self._id
    return printer._print(system) + '.' + system._vector_names[index]


[/PYTHON]
What will be the input of `_print`, given the following output:
[OUTPUT]
```
{
    "output": "phi"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_str": XXX,
        "_settings": {
            "order": XXX,
            "full_prec": XXX,
            "sympy_integers": XXX,
            "abbrev": XXX,
            "perm_cyclic": XXX,
            "min": XXX,
            "max": XXX,
            "dps": XXX
        },
        "_context": {},
        "_print_level": XXX
    },
    "args": {
        "expr": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
