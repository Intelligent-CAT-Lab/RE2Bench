You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [/INPUT]. You should maintain the structure when printing inputs. Do not change anything else.  ONLY print the input, DO NOT print any reasoning process.
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from typing import Callable, TYPE_CHECKING
from .singleton import S
from .expr import Expr
from .logic import fuzzy_bool, fuzzy_not, fuzzy_and, fuzzy_or
from .numbers import Integer, Rational

class Pow(Expr):
    is_Pow = True
    __slots__ = ('is_commutative',)
    if TYPE_CHECKING:

        @property
        def args(self) -> tuple[Expr, Expr]:
            ...

    @property
    def base(self) -> Expr:
        return self.args[0]

    @property
    def exp(self) -> Expr:
        return self.args[1]

    def as_base_exp(self):
        b, e = self.args
        if b.is_Rational and b.p == 1 and (b.q != 1):
            return (Integer(b.q), -e)
        return (b, e)

    def _eval_is_rational(self):
        if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):
            return True
        p = self.func(*self.as_base_exp())
        if not p.is_Pow:
            return p.is_rational
        b, e = p.as_base_exp()
        if e.is_Rational and b.is_Rational:
            return False
        if e.is_integer:
            if b.is_rational:
                if fuzzy_not(b.is_zero) or e.is_nonnegative:
                    return True
                if b == e:
                    return True
            elif b.is_irrational:
                return e.is_zero
        if b is S.Exp1:
            if e.is_rational and e.is_nonzero:
                return False
[/PYTHON]

Functions called during the execution:
[PYTHON]
sympy.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

sympy.sympy.core.basic.__eq__

def __eq__(self, other):
    """Return a boolean indicating whether a == b on the basis of
    their symbolic trees.

    This is the same as a.compare(b) == 0 but faster.

    Notes
    =====

    If a class that overrides __eq__() needs to retain the
    implementation of __hash__() from a parent class, the
    interpreter must be told this explicitly by setting
    __hash__ : Callable[[object], int] = <ParentClass>.__hash__.
    Otherwise the inheritance of __hash__() will be blocked,
    just as if __hash__ had been explicitly set to None.

    References
    ==========

    from https://docs.python.org/dev/reference/datamodel.html#object.__hash__
    """
    if self is other:
        return True

    if not isinstance(other, Basic):
        return self._do_eq_sympify(other)

    # check for pure number expr
    if  not (self.is_Number and other.is_Number) and (
            type(self) != type(other)):
        return False
    a, b = self._hashable_content(), other._hashable_content()
    if a != b:
        return False
    # check number *in* an expression
    for a, b in zip(a, b):
        if not isinstance(a, Basic):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

sympy.sympy.core.basic.func

@property
def func(self):
    """
    The top-level function in an expression.

    The following should hold for all objects::

        >> x == x.func(*x.args)

    Examples
    ========

    >>> from sympy.abc import x
    >>> a = 2*x
    >>> a.func
    <class 'sympy.core.mul.Mul'>
    >>> a.args
    (2, x)
    >>> a.func(*a.args)
    2*x
    >>> a == a.func(*a.args)
    True

    """
    return self.__class__

sympy.sympy.core.cache.wrapper

@wraps(func)
def wrapper(*args, **kwargs):
    try:
        retval = cfunc(*args, **kwargs)
    except TypeError as e:
        if not e.args or not e.args[0].startswith('unhashable type:'):
            raise
        retval = func(*args, **kwargs)
    return retval

sympy.sympy.core.logic.fuzzy_and

def fuzzy_and(args):
    """Return True (all True), False (any False) or None.

    Examples
    ========

    >>> from sympy.core.logic import fuzzy_and
    >>> from sympy import Dummy

    If you had a list of objects to test the commutivity of
    and you want the fuzzy_and logic applied, passing an
    iterator will allow the commutativity to only be computed
    as many times as necessary. With this list, False can be
    returned after analyzing the first symbol:

    >>> syms = [Dummy(commutative=False), Dummy()]
    >>> fuzzy_and(s.is_commutative for s in syms)
    False

    That False would require less work than if a list of pre-computed
    items was sent:

    >>> fuzzy_and([s.is_commutative for s in syms])
    False
    """

    rv = True
    for ai in args:
        ai = fuzzy_bool(ai)
        if ai is False:
            return False
        if rv:  # this will stop updating if a None is ever trapped
            rv = ai
    return rv

sympy.sympy.core.logic.fuzzy_not

def fuzzy_not(v):
    """
    Not in fuzzy logic

    Return None if `v` is None else `not v`.

    Examples
    ========

    >>> from sympy.core.logic import fuzzy_not
    >>> fuzzy_not(True)
    False
    >>> fuzzy_not(None)
    >>> fuzzy_not(False)
    True

    """
    if v is None:
        return v
    else:
        return not v

sympy.sympy.core.numbers.__eq__

def __eq__(self, other):
    if isinstance(other, int):
        return (self.p == other)
    elif isinstance(other, Integer):
        return (self.p == other.p)
    return Rational.__eq__(self, other)

sympy.sympy.core.power.base

@property
def base(self) -> Expr:
    return self.args[0]

sympy.sympy.core.power.exp

@property
def exp(self) -> Expr:
    return self.args[1]

sympy.sympy.core.power.as_base_exp

def as_base_exp(self):
    """Return base and exp of self.

    Explanation
    ===========

    If base a Rational less than 1, then return 1/Rational, -exp.
    If this extra processing is not needed, the base and exp
    properties will give the raw arguments.

    Examples
    ========

    >>> from sympy import Pow, S
    >>> p = Pow(S.Half, 2, evaluate=False)
    >>> p.as_base_exp()
    (2, -2)
    >>> p.args
    (1/2, 2)
    >>> p.base, p.exp
    (1/2, 2)

    """
    b, e = self.args
    if b.is_Rational and b.p == 1 and b.q != 1:
        return Integer(b.q), -e
    return b, e


[/PYTHON]
What will be the input of `_eval_is_rational`, given the following output:
[OUTPUT]
```
{
    "output": null
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": XXX,
    "args": {},
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
