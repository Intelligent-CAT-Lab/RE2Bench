You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [/INPUT]. You should maintain the structure when printing inputs. Do not change anything else. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import os
import re
from importlib import import_module
from django import get_version
from django.apps import apps
from django.conf import SettingsReference
from django.db import migrations
from django.db.migrations.loader import MigrationLoader
from django.db.migrations.serializer import Serializer, serializer_factory
from django.utils.inspect import get_func_args
from django.utils.module_loading import module_dir
from django.utils.timezone import now
MIGRATION_HEADER_TEMPLATE = '# Generated by Django %(version)s on %(timestamp)s\n\n'
MIGRATION_TEMPLATE = '%(migration_header)s%(imports)s\n\nclass Migration(migrations.Migration):\n%(replaces_str)s%(initial_str)s\n    dependencies = [\n%(dependencies)s    ]\n\n    operations = [\n%(operations)s    ]\n'

class MigrationWriter:

    def as_string(self):
        items = {'replaces_str': '', 'initial_str': ''}
        imports = set()
        operations = []
        for operation in self.migration.operations:
            operation_string, operation_imports = OperationWriter(operation).serialize()
            imports.update(operation_imports)
            operations.append(operation_string)
        items['operations'] = '\n'.join(operations) + '\n' if operations else ''
        dependencies = []
        for dependency in self.migration.dependencies:
            if dependency[0] == '__setting__':
                dependencies.append('        migrations.swappable_dependency(settings.%s),' % dependency[1])
                imports.add('from django.conf import settings')
            else:
                dependencies.append('        %s,' % self.serialize(dependency)[0])
        items['dependencies'] = '\n'.join(dependencies) + '\n' if dependencies else ''
        migration_imports = set()
        for line in list(imports):
            if re.match('^import (.*)\\.\\d+[^\\s]*$', line):
                migration_imports.add(line.split('import')[1].strip())
                imports.remove(line)
                self.needs_manual_porting = True
        if 'from django.db import models' in imports:
            imports.discard('from django.db import models')
            imports.add('from django.db import migrations, models')
        else:
            imports.add('from django.db import migrations')
        sorted_imports = sorted(imports, key=lambda i: (i.split()[0] == 'from', i.split()[1]))
        items['imports'] = '\n'.join(sorted_imports) + '\n' if imports else ''
        if migration_imports:
            items['imports'] += '\n\n# Functions from the following migrations need manual copying.\n# Move them and any dependencies into this file, then update the\n# RunPython operations to refer to the local versions:\n# %s' % '\n# '.join(sorted(migration_imports))
        if self.migration.replaces:
            items['replaces_str'] = '\n    replaces = %s\n' % self.serialize(self.migration.replaces)[0]
        if self.include_header:
            items['migration_header'] = MIGRATION_HEADER_TEMPLATE % {'version': get_version(), 'timestamp': now().strftime('%Y-%m-%d %H:%M')}
        else:
            items['migration_header'] = ''
        if self.migration.initial:
            items['initial_str'] = '\n    initial = True\n'
        return MIGRATION_TEMPLATE % items

    @classmethod
    def serialize(cls, value):
        return serializer_factory(value).serialize()
[/PYTHON]

Functions called during the execution:
[PYTHON]
.django.db.migrations.writer.OperationWriter.__init__

def __init__(self, operation, indentation=2):
    self.operation = operation
    self.buff = []
    self.indentation = indentation

.django.db.migrations.writer.OperationWriter.serialize

def serialize(self):

    def _write(_arg_name, _arg_value):
        if _arg_name in self.operation.serialization_expand_args and isinstance(_arg_value, (list, tuple, dict)):
            if isinstance(_arg_value, dict):
                self.feed('%s={' % _arg_name)
                self.indent()
                for key, value in _arg_value.items():
                    key_string, key_imports = MigrationWriter.serialize(key)
                    arg_string, arg_imports = MigrationWriter.serialize(value)
                    args = arg_string.splitlines()
                    if len(args) > 1:
                        self.feed('%s: %s' % (key_string, args[0]))
                        for arg in args[1:-1]:
                            self.feed(arg)
                        self.feed('%s,' % args[-1])
                    else:
                        self.feed('%s: %s,' % (key_string, arg_string))
                    imports.update(key_imports)
                    imports.update(arg_imports)
                self.unindent()
                self.feed('},')
            else:
                self.feed('%s=[' % _arg_name)
                self.indent()
                for item in _arg_value:
                    arg_string, arg_imports = MigrationWriter.serialize(item)
                    args = arg_string.splitlines()
                    if len(args) > 1:
                        for arg in args[:-1]:
                            self.feed(arg)
                        self.feed('%s,' % args[-1])
                    else:
                        self.feed('%s,' % arg_string)
                    imports.update(arg_imports)
                self.unindent()
                self.feed('],')
        else:
            arg_string, arg_imports = MigrationWriter.serialize(_arg_value)
            args = arg_string.splitlines()
            if len(args) > 1:
                self.feed('%s=%s' % (_arg_name, args[0]))
                for arg in args[1:-1]:
                    self.feed(arg)
                self.feed('%s,' % args[-1])
            else:
                self.feed('%s=%s,' % (_arg_name, arg_string))
            imports.update(arg_imports)
    imports = set()
    name, args, kwargs = self.operation.deconstruct()
    operation_args = get_func_args(self.operation.__init__)
    if getattr(migrations, name, None) == self.operation.__class__:
        self.feed('migrations.%s(' % name)
    else:
        imports.add('import %s' % self.operation.__class__.__module__)
        self.feed('%s.%s(' % (self.operation.__class__.__module__, name))
    self.indent()
    for i, arg in enumerate(args):
        arg_value = arg
        arg_name = operation_args[i]
        _write(arg_name, arg_value)
    i = len(args)
    for arg_name in operation_args[i:]:
        if arg_name in kwargs:
            arg_value = kwargs[arg_name]
            _write(arg_name, arg_value)
    self.unindent()
    self.feed('),')
    return (self.render(), imports)

.django.utils.inspect.get_func_args

def get_func_args(func):
    params = _get_callable_parameters(func)
    return [param.name for param in params if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD]

.django.utils.inspect._get_callable_parameters

def _get_callable_parameters(meth_or_func):
    is_method = inspect.ismethod(meth_or_func)
    func = meth_or_func.__func__ if is_method else meth_or_func
    return _get_func_parameters(func, remove_first=is_method)

.django.db.migrations.writer.OperationWriter.feed

def feed(self, line):
    self.buff.append(' ' * (self.indentation * 4) + line)

.django.db.migrations.writer.OperationWriter.indent

def indent(self):
    self.indentation += 1

.django.db.migrations.writer.OperationWriter.unindent

def unindent(self):
    self.indentation -= 1

.django.db.migrations.writer.OperationWriter.render

def render(self):
    return '\n'.join(self.buff)

.django.db.migrations.operations.models.CreateModel.deconstruct

def deconstruct(self):
    kwargs = {'name': self.name, 'fields': self.fields}
    if self.options:
        kwargs['options'] = self.options
    if self.bases and self.bases != (models.Model,):
        kwargs['bases'] = self.bases
    if self.managers and self.managers != [('objects', models.Manager())]:
        kwargs['managers'] = self.managers
    return (self.__class__.__qualname__, [], kwargs)

.django.utils.inspect._get_func_parameters

def _get_func_parameters(func, remove_first):
    parameters = tuple(inspect.signature(func).parameters.values())
    if remove_first:
        parameters = parameters[1:]
    return parameters

.django.db.migrations.writer.OperationWriter._write

def _write(_arg_name, _arg_value):
    if _arg_name in self.operation.serialization_expand_args and isinstance(_arg_value, (list, tuple, dict)):
        if isinstance(_arg_value, dict):
            self.feed('%s={' % _arg_name)
            self.indent()
            for key, value in _arg_value.items():
                key_string, key_imports = MigrationWriter.serialize(key)
                arg_string, arg_imports = MigrationWriter.serialize(value)
                args = arg_string.splitlines()
                if len(args) > 1:
                    self.feed('%s: %s' % (key_string, args[0]))
                    for arg in args[1:-1]:
                        self.feed(arg)
                    self.feed('%s,' % args[-1])
                else:
                    self.feed('%s: %s,' % (key_string, arg_string))
                imports.update(key_imports)
                imports.update(arg_imports)
            self.unindent()
            self.feed('},')
        else:
            self.feed('%s=[' % _arg_name)
            self.indent()
            for item in _arg_value:
                arg_string, arg_imports = MigrationWriter.serialize(item)
                args = arg_string.splitlines()
                if len(args) > 1:
                    for arg in args[:-1]:
                        self.feed(arg)
                    self.feed('%s,' % args[-1])
                else:
                    self.feed('%s,' % arg_string)
                imports.update(arg_imports)
            self.unindent()
            self.feed('],')
    else:
        arg_string, arg_imports = MigrationWriter.serialize(_arg_value)
        args = arg_string.splitlines()
        if len(args) > 1:
            self.feed('%s=%s' % (_arg_name, args[0]))
            for arg in args[1:-1]:
                self.feed(arg)
            self.feed('%s,' % args[-1])
        else:
            self.feed('%s=%s,' % (_arg_name, arg_string))
        imports.update(arg_imports)

.django.db.migrations.serializer.serializer_factory

def serializer_factory(value):
    if isinstance(value, Promise):
        value = str(value)
    elif isinstance(value, LazyObject):
        value = value.__reduce__()[1][0]
    if isinstance(value, models.Field):
        return ModelFieldSerializer(value)
    if isinstance(value, models.manager.BaseManager):
        return ModelManagerSerializer(value)
    if isinstance(value, Operation):
        return OperationSerializer(value)
    if isinstance(value, type):
        return TypeSerializer(value)
    if hasattr(value, 'deconstruct'):
        return DeconstructableSerializer(value)
    for type_, serializer_cls in Serializer._registry.items():
        if isinstance(value, type_):
            return serializer_cls(value)
    raise ValueError('Cannot serialize: %r\nThere are some values Django cannot serialize into migration files.\nFor more, see https://docs.djangoproject.com/en/%s/topics/migrations/#migration-serializing' % (value, get_docs_version()))

.django.db.migrations.serializer.BaseSerializer.__init__

def __init__(self, value):
    self.value = value

.django.db.migrations.serializer.BaseSimpleSerializer.serialize

def serialize(self):
    return (repr(self.value), set())

.django.utils.version.get_version

def get_version(version=None):
    version = get_complete_version(version)
    main = get_main_version(version)
    sub = ''
    if version[3] == 'alpha' and version[4] == 0:
        git_changeset = get_git_changeset()
        if git_changeset:
            sub = '.dev%s' % git_changeset
    elif version[3] != 'final':
        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}
        sub = mapping[version[3]] + str(version[4])
    return main + sub

.django.utils.version.get_complete_version

def get_complete_version(version=None):
    if version is None:
        from django import VERSION as version
    else:
        assert len(version) == 5
        assert version[3] in ('alpha', 'beta', 'rc', 'final')
    return version

.django.utils.version.get_main_version

def get_main_version(version=None):
    version = get_complete_version(version)
    parts = 2 if version[2] == 0 else 3
    return '.'.join((str(x) for x in version[:parts]))

.django.utils.timezone.now

def now():
    return datetime.now(tz=timezone.utc if settings.USE_TZ else None)

.django.utils.functional.LazyObject.__getattribute__

def __getattribute__(self, name):
    if name == '_wrapped':
        return super().__getattribute__(name)
    value = super().__getattribute__(name)
    if not getattr(value, '_mask_wrapped', True):
        raise AttributeError
    return value

.django.db.migrations.operations.models.AlterModelOptions.deconstruct

def deconstruct(self):
    kwargs = {'name': self.name, 'options': self.options}
    return (self.__class__.__qualname__, [], kwargs)

.django.db.migrations.serializer.DictionarySerializer.serialize

def serialize(self):
    imports = set()
    strings = []
    for k, v in sorted(self.value.items()):
        k_string, k_imports = serializer_factory(k).serialize()
        v_string, v_imports = serializer_factory(v).serialize()
        imports.update(k_imports)
        imports.update(v_imports)
        strings.append((k_string, v_string))
    return ('{%s}' % ', '.join(('%s: %s' % (k, v) for k, v in strings)), imports)

.django.conf.__init__.LazySettings.__getattr__

def __getattr__(self, name):
    if (_wrapped := self._wrapped) is empty:
        self._setup(name)
        _wrapped = self._wrapped
    val = getattr(_wrapped, name)
    if name in {'MEDIA_URL', 'STATIC_URL'} and val is not None:
        val = self._add_script_prefix(val)
    elif name == 'SECRET_KEY' and (not val):
        raise ImproperlyConfigured('The SECRET_KEY setting must not be empty.')
    self.__dict__[name] = val
    return val

.django.db.migrations.serializer.BaseSequenceSerializer.serialize

def serialize(self):
    imports = set()
    strings = []
    for item in self.value:
        item_string, item_imports = serializer_factory(item).serialize()
        imports.update(item_imports)
        strings.append(item_string)
    value = self._format()
    return (value % ', '.join(strings), imports)

.django.db.migrations.serializer.ModelFieldSerializer.serialize

def serialize(self):
    attr_name, path, args, kwargs = self.value.deconstruct()
    return self.serialize_deconstructed(path, args, kwargs)

.django.db.models.fields.__init__.DateField.deconstruct

def deconstruct(self):
    name, path, args, kwargs = super().deconstruct()
    if self.auto_now:
        kwargs['auto_now'] = True
    if self.auto_now_add:
        kwargs['auto_now_add'] = True
    if self.auto_now or self.auto_now_add:
        del kwargs['editable']
        del kwargs['blank']
    return (name, path, args, kwargs)

.django.db.models.fields.__init__.Field.deconstruct

def deconstruct(self):
    keywords = {}
    possibles = {'verbose_name': None, 'primary_key': False, 'max_length': None, 'unique': False, 'blank': False, 'null': False, 'db_index': False, 'default': NOT_PROVIDED, 'editable': True, 'serialize': True, 'unique_for_date': None, 'unique_for_month': None, 'unique_for_year': None, 'choices': None, 'help_text': '', 'db_column': None, 'db_comment': None, 'db_tablespace': None, 'auto_created': False, 'validators': [], 'error_messages': None}
    attr_overrides = {'unique': '_unique', 'error_messages': '_error_messages', 'validators': '_validators', 'verbose_name': '_verbose_name', 'db_tablespace': '_db_tablespace'}
    equals_comparison = {'choices', 'validators'}
    for name, default in possibles.items():
        value = getattr(self, attr_overrides.get(name, name))
        if name == 'choices' and isinstance(value, collections.abc.Iterable):
            value = list(value)
        if name in equals_comparison:
            if value != default:
                keywords[name] = value
        elif value is not default:
            keywords[name] = value
    path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)
    if path.startswith('django.db.models.fields.related'):
        path = path.replace('django.db.models.fields.related', 'django.db.models')
    elif path.startswith('django.db.models.fields.files'):
        path = path.replace('django.db.models.fields.files', 'django.db.models')
    elif path.startswith('django.db.models.fields.json'):
        path = path.replace('django.db.models.fields.json', 'django.db.models')
    elif path.startswith('django.db.models.fields.proxy'):
        path = path.replace('django.db.models.fields.proxy', 'django.db.models')
    elif path.startswith('django.db.models.fields'):
        path = path.replace('django.db.models.fields', 'django.db.models')
    return (self.name, path, [], keywords)

.django.db.migrations.serializer.DeconstructableSerializer.serialize_deconstructed

def serialize_deconstructed(path, args, kwargs):
    name, imports = DeconstructableSerializer._serialize_path(path)
    strings = []
    for arg in args:
        arg_string, arg_imports = serializer_factory(arg).serialize()
        strings.append(arg_string)
        imports.update(arg_imports)
    for kw, arg in sorted(kwargs.items()):
        arg_string, arg_imports = serializer_factory(arg).serialize()
        imports.update(arg_imports)
        strings.append('%s=%s' % (kw, arg_string))
    return ('%s(%s)' % (name, ', '.join(strings)), imports)

.django.db.migrations.serializer.DeconstructableSerializer._serialize_path

def _serialize_path(path):
    module, name = path.rsplit('.', 1)
    if module == 'django.db.models':
        imports = {'from django.db import models'}
        name = 'models.%s' % name
    else:
        imports = {'import %s' % module}
        name = path
    return (name, imports)

.django.db.migrations.serializer.FunctionTypeSerializer.serialize

def serialize(self):
    if getattr(self.value, '__self__', None) and isinstance(self.value.__self__, type):
        klass = self.value.__self__
        module = klass.__module__
        return ('%s.%s.%s' % (module, klass.__name__, self.value.__name__), {'import %s' % module})
    if self.value.__name__ == '<lambda>':
        raise ValueError('Cannot serialize function: lambda')
    if self.value.__module__ is None:
        raise ValueError('Cannot serialize function %r: No module' % self.value)
    module_name = self.value.__module__
    if '<' not in self.value.__qualname__:
        return ('%s.%s' % (module_name, self.value.__qualname__), {'import %s' % self.value.__module__})
    raise ValueError('Could not find function %s in %s.\n' % (self.value.__name__, module_name))

.django.db.migrations.serializer.TupleSerializer._format

def _format(self):
    return '(%s)' if len(self.value) != 1 else '(%s,)'

.django.db.migrations.operations.models.DeleteModel.deconstruct

def deconstruct(self):
    kwargs = {'name': self.name}
    return (self.__class__.__qualname__, [], kwargs)

.django.db.migrations.operations.fields.AddField.deconstruct

def deconstruct(self):
    kwargs = {'model_name': self.model_name, 'name': self.name, 'field': self.field}
    if self.preserve_default is not True:
        kwargs['preserve_default'] = self.preserve_default
    return (self.__class__.__name__, [], kwargs)

.django.db.migrations.serializer.DatetimeDatetimeSerializer.serialize

def serialize(self):
    if self.value.tzinfo is not None and self.value.tzinfo != datetime.timezone.utc:
        self.value = self.value.astimezone(datetime.timezone.utc)
    imports = ['import datetime']
    return (repr(self.value), set(imports))


[/PYTHON]
What will be the input of `as_string`, given the following output:
[OUTPUT]
```
{
    "output": "from django.db import migrations\n\n\nclass \"Migration(migrations.Migration)\":\n\n    dependencies = [\n    ]\n\n    operations = [\n    ]\n"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "migration": {
            "operations": XXX,
            "__module__": XXX,
            "__doc__": XXX
        },
        "include_header": XXX,
        "needs_manual_porting": XXX
    },
    "args": {},
    "kwargs": {}
}
```
[/STRUCTURE]

[THOUGHT]
