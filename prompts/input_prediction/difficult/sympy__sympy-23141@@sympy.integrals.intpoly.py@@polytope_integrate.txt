You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [/OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [/STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [/INPUT]. You should maintain the structure when printing inputs. Do not change anything else. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from functools import cmp_to_key
from sympy.abc import x, y, z
from sympy.core import S, diff, Expr, Symbol
from sympy.core.sympify import _sympify
from sympy.geometry import Segment2D, Polygon, Point, Point2D
from sympy.polys.polytools import LC, gcd_list, degree_list, Poly
from sympy.simplify.simplify import nsimplify
from sympy.plotting.plot import Plot, List2DSeries
from sympy.plotting.plot import plot3d, plot

def polytope_integrate(poly, expr=None, *, clockwise=False, max_degree=None):
    if clockwise:
        if isinstance(poly, Polygon):
            poly = Polygon(*point_sort(poly.vertices), evaluate=False)
        else:
            raise TypeError('clockwise=True works for only 2-PolytopeV-representation input')
    if isinstance(poly, Polygon):
        hp_params = hyperplane_parameters(poly)
        facets = poly.sides
    elif len(poly[0]) == 2:
        plen = len(poly)
        if len(poly[0][0]) == 2:
            intersections = [intersection(poly[(i - 1) % plen], poly[i], 'plane2D') for i in range(0, plen)]
            hp_params = poly
            lints = len(intersections)
            facets = [Segment2D(intersections[i], intersections[(i + 1) % lints]) for i in range(0, lints)]
        else:
            raise NotImplementedError('Integration for H-representation 3Dcase not implemented yet.')
    else:
        vertices = poly[0]
        facets = poly[1:]
        hp_params = hyperplane_parameters(facets, vertices)
        if max_degree is None:
            if expr is None:
                raise TypeError('Input expression must be a valid SymPy expression')
            return main_integrate3d(expr, facets, vertices, hp_params)
    if max_degree is not None:
        result = {}
        if expr is not None:
            f_expr = []
            for e in expr:
                _ = decompose(e)
                if len(_) == 1 and (not _.popitem()[0]):
                    f_expr.append(e)
                elif Poly(e).total_degree() <= max_degree:
                    f_expr.append(e)
            expr = f_expr
        if not isinstance(expr, list) and expr is not None:
            raise TypeError('Input polynomials must be list of expressions')
        if len(hp_params[0][0]) == 3:
            result_dict = main_integrate3d(0, facets, vertices, hp_params, max_degree)
        else:
            result_dict = main_integrate(0, facets, hp_params, max_degree)
        if expr is None:
            return result_dict
        for poly in expr:
            poly = _sympify(poly)
            if poly not in result:
                if poly.is_zero:
                    result[S.Zero] = S.Zero
                    continue
                integral_value = S.Zero
                monoms = decompose(poly, separate=True)
                for monom in monoms:
                    monom = nsimplify(monom)
                    coeff, m = strip(monom)
                    integral_value += result_dict[m] * coeff
                result[poly] = integral_value
        return result
    if expr is None:
        raise TypeError('Input expression must be a valid SymPy expression')
    return main_integrate(expr, facets, hp_params)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.integrals.intpoly.hyperplane_parameters

def hyperplane_parameters(poly, vertices=None):
    if isinstance(poly, Polygon):
        vertices = list(poly.vertices) + [poly.vertices[0]]
        params = [None] * (len(vertices) - 1)
        for i in range(len(vertices) - 1):
            v1 = vertices[i]
            v2 = vertices[i + 1]
            a1 = v1[1] - v2[1]
            a2 = v2[0] - v1[0]
            b = v2[0] * v1[1] - v2[1] * v1[0]
            factor = gcd_list([a1, a2, b])
            b = S(b) / factor
            a = (S(a1) / factor, S(a2) / factor)
            params[i] = (a, b)
    else:
        params = [None] * len(poly)
        for i, polygon in enumerate(poly):
            v1, v2, v3 = [vertices[vertex] for vertex in polygon[:3]]
            normal = cross_product(v1, v2, v3)
            b = sum([normal[j] * v1[j] for j in range(0, 3)])
            fac = gcd_list(normal)
            if fac.is_zero:
                fac = 1
            normal = [j / fac for j in normal]
            b = b / fac
            params[i] = (normal, b)
    return params

.sympy.geometry.polygon.Triangle.vertices

def vertices(self):
    return self.args

.sympy.core.basic.Basic.args

def args(self) -> 'Tuple[Basic, ...]':
    return self._args

.sympy.geometry.point.Point.__getitem__

def __getitem__(self, key):
    return self.args[key]

.sympy.core.numbers.Integer.__sub__

def __sub__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, str):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)
    if ival == 1:
        return S.One
    if ival == -1:
        return S.NegativeOne
    if ival == 0:
        return S.Zero
    obj = Expr.__new__(cls)
    obj.p = ival
    return obj

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.polys.polytools.gcd_list

def gcd_list(seq, *gens, **args):
    seq = sympify(seq)

    def try_non_polynomial_gcd(seq):
        if not gens and (not args):
            domain, numbers = construct_domain(seq)
            if not numbers:
                return domain.zero
            elif domain.is_Numerical:
                result, numbers = (numbers[0], numbers[1:])
                for number in numbers:
                    result = domain.gcd(result, number)
                    if domain.is_one(result):
                        break
                return domain.to_sympy(result)
        return None
    result = try_non_polynomial_gcd(seq)
    if result is not None:
        return result
    options.allowed_flags(args, ['polys'])
    try:
        polys, opt = parallel_poly_from_expr(seq, *gens, **args)
        if len(seq) > 1 and all((elt.is_algebraic and elt.is_irrational for elt in seq)):
            a = seq[-1]
            lst = [(a / elt).ratsimp() for elt in seq[:-1]]
            if all((frc.is_rational for frc in lst)):
                lc = 1
                for frc in lst:
                    lc = lcm(lc, frc.as_numer_denom()[0])
                return abs(a / lc)
    except PolificationFailed as exc:
        result = try_non_polynomial_gcd(exc.exprs)
        if result is not None:
            return result
        else:
            raise ComputationFailed('gcd_list', len(seq), exc)
    if not polys:
        if not opt.polys:
            return S.Zero
        else:
            return Poly(0, opt=opt)
    result, polys = (polys[0], polys[1:])
    for poly in polys:
        result = result.gcd(poly)
        if result.is_one:
            break
    if not opt.polys:
        return result.as_expr()
    else:
        return result

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    is_sympy = getattr(a, '__sympy__', None)
    if is_sympy is True:
        return a
    elif is_sympy is not None:
        if not strict:
            return a
        else:
            raise SympifyError(a)
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    cls = getattr(a, '__class__', None)
    for superclass in getmro(cls):
        conv = _external_converter.get(superclass)
        if conv is None:
            conv = _sympy_converter.get(superclass)
        if conv is not None:
            return conv(a)
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if _is_numpy_instance(a):
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
    _sympy_ = getattr(a, '_sympy_', None)
    if _sympy_ is not None:
        try:
            return a._sympy_()
        except AttributeError:
            pass
    if not strict:
        flat = getattr(a, 'flat', None)
        if flat is not None:
            shape = getattr(a, 'shape', None)
            if shape is not None:
                from sympy.tensor.array import Array
                return Array(a.flat, a.shape)
    if not isinstance(a, str):
        if _is_numpy_instance(a):
            import numpy as np
            assert not isinstance(a, np.number)
            if isinstance(a, np.ndarray):
                if a.ndim == 0:
                    try:
                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
                    except SympifyError:
                        pass
        else:
            for coerce in (float, int):
                try:
                    return sympify(coerce(a))
                except (TypeError, ValueError, AttributeError, SympifyError):
                    continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])
        except TypeError:
            pass
    if not isinstance(a, str):
        try:
            a = str(a)
        except Exception as exc:
            raise SympifyError(a, exc)
        sympy_deprecation_warning(f'\nThe string fallback in sympify() is deprecated.\n\nTo explicitly convert the string form of an object, use\nsympify(str(obj)). To add define sympify behavior on custom\nobjects, use sympy.core.sympify.converter or define obj._sympy_\n(see the sympify() docstring).\n\nsympify() performed the string fallback resulting in the following string:\n\n{a!r}\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.sympify._is_numpy_instance

def _is_numpy_instance(a):
    return any((type_.__module__ == 'numpy' for type_ in type(a).__mro__))

.sympy.utilities.iterables.iterable

def iterable(i, exclude=(str, dict, NotIterable)):
    if hasattr(i, '_iterable'):
        return i._iterable
    try:
        iter(i)
    except TypeError:
        return False
    if exclude:
        return not isinstance(i, exclude)
    return True

.sympy.polys.polytools.try_non_polynomial_gcd

def try_non_polynomial_gcd(seq):
    if not gens and (not args):
        domain, numbers = construct_domain(seq)
        if not numbers:
            return domain.zero
        elif domain.is_Numerical:
            result, numbers = (numbers[0], numbers[1:])
            for number in numbers:
                result = domain.gcd(result, number)
                if domain.is_one(result):
                    break
            return domain.to_sympy(result)
    return None

.sympy.polys.constructor.construct_domain

def construct_domain(obj, **args):
    opt = build_options(args)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            if not obj:
                monoms, coeffs = ([], [])
            else:
                monoms, coeffs = list(zip(*list(obj.items())))
        else:
            coeffs = obj
    else:
        coeffs = [obj]
    coeffs = list(map(sympify, coeffs))
    result = _construct_simple(coeffs, opt)
    if result is not None:
        if result is not False:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    else:
        if opt.composite is False:
            result = None
        else:
            result = _construct_composite(coeffs, opt)
        if result is not None:
            domain, coeffs = result
        else:
            domain, coeffs = _construct_expression(coeffs, opt)
    if hasattr(obj, '__iter__'):
        if isinstance(obj, dict):
            return (domain, dict(list(zip(monoms, coeffs))))
        else:
            return (domain, coeffs)
    else:
        return (domain, coeffs[0])

.sympy.polys.polyoptions.build_options

def build_options(gens, args=None):
    if args is None:
        gens, args = ((), gens)
    if len(args) != 1 or 'opt' not in args or gens:
        return Options(gens, args)
    else:
        return args['opt']

.sympy.polys.polyoptions.Options.__init__

def __init__(self, gens, args, flags=None, strict=False):
    dict.__init__(self)
    if gens and args.get('gens', ()):
        raise OptionError("both '*gens' and keyword argument 'gens' supplied")
    elif gens:
        args = dict(args)
        args['gens'] = gens
    defaults = args.pop('defaults', {})

    def preprocess_options(args):
        for option, value in args.items():
            try:
                cls = self.__options__[option]
            except KeyError:
                raise OptionError("'%s' is not a valid option" % option)
            if issubclass(cls, Flag):
                if flags is None or option not in flags:
                    if strict:
                        raise OptionError("'%s' flag is not allowed in this context" % option)
            if value is not None:
                self[option] = cls.preprocess(value)
    preprocess_options(args)
    for key, value in dict(defaults).items():
        if key in self:
            del defaults[key]
        else:
            for option in self.keys():
                cls = self.__options__[option]
                if key in cls.excludes:
                    del defaults[key]
                    break
    preprocess_options(defaults)
    for option in self.keys():
        cls = self.__options__[option]
        for require_option in cls.requires:
            if self.get(require_option) is None:
                raise OptionError("'%s' option is only allowed together with '%s'" % (option, require_option))
        for exclude_option in cls.excludes:
            if self.get(exclude_option) is not None:
                raise OptionError("'%s' option is not allowed together with '%s'" % (option, exclude_option))
    for option in self.__order__:
        self.__options__[option].postprocess(self)

.sympy.polys.polyoptions.Options.preprocess_options

def preprocess_options(args):
    for option, value in args.items():
        try:
            cls = self.__options__[option]
        except KeyError:
            raise OptionError("'%s' is not a valid option" % option)
        if issubclass(cls, Flag):
            if flags is None or option not in flags:
                if strict:
                    raise OptionError("'%s' flag is not allowed in this context" % option)
        if value is not None:
            self[option] = cls.preprocess(value)

.sympy.polys.polyoptions.Option.postprocess

def postprocess(cls, options):
    pass

.sympy.polys.polyoptions.Extension.postprocess

def postprocess(cls, options):
    if 'extension' in options and options['extension'] is not True:
        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])

.sympy.polys.polyoptions.Gaussian.postprocess

def postprocess(cls, options):
    if 'gaussian' in options and options['gaussian'] is True:
        options['domain'] = sympy.polys.domains.QQ_I
        Extension.postprocess(options)

.sympy.polys.polyoptions.Domain.postprocess

def postprocess(cls, options):
    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):
        raise GeneratorsError('ground domain and generators interfere together')
    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):
        raise GeneratorsError('you have to provide generators because EX domain was requested')

.sympy.polys.polyoptions.Auto.postprocess

def postprocess(cls, options):
    if ('domain' in options or 'field' in options) and 'auto' not in options:
        options['auto'] = False

.sympy.polys.polyoptions.Modulus.postprocess

def postprocess(cls, options):
    if 'modulus' in options:
        modulus = options['modulus']
        symmetric = options.get('symmetric', True)
        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)

.sympy.polys.polyoptions.Split.postprocess

def postprocess(cls, options):
    if 'split' in options:
        raise NotImplementedError("'split' option is not implemented yet")

.sympy.polys.constructor._construct_simple

def _construct_simple(coeffs, opt):
    rationals = floats = complexes = algebraics = False
    float_numbers = []
    if opt.extension is True:
        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic
    else:
        is_algebraic = lambda coeff: False
    for coeff in coeffs:
        if coeff.is_Rational:
            if not coeff.is_Integer:
                rationals = True
        elif coeff.is_Float:
            if algebraics:
                return False
            else:
                floats = True
                float_numbers.append(coeff)
        else:
            is_complex = pure_complex(coeff)
            if is_complex:
                complexes = True
                x, y = is_complex
                if x.is_Rational and y.is_Rational:
                    if not (x.is_Integer and y.is_Integer):
                        rationals = True
                    continue
                else:
                    floats = True
                    if x.is_Float:
                        float_numbers.append(x)
                    if y.is_Float:
                        float_numbers.append(y)
            elif is_algebraic(coeff):
                if floats:
                    return False
                algebraics = True
            else:
                return None
    max_prec = max((c._prec for c in float_numbers)) if float_numbers else 53
    if algebraics:
        domain, result = _construct_algebraic(coeffs, opt)
    else:
        if floats and complexes:
            domain = ComplexField(prec=max_prec)
        elif floats:
            domain = RealField(prec=max_prec)
        elif rationals or opt.field:
            domain = QQ_I if complexes else QQ
        else:
            domain = ZZ_I if complexes else ZZ
        result = [domain.from_sympy(coeff) for coeff in coeffs]
    return (domain, result)

.sympy.polys.polyoptions.OptionType.getter

def getter(self):
    try:
        return self[cls.option]
    except KeyError:
        return cls.default()

.sympy.polys.polyoptions.Option.default

def default(cls):
    return None

.sympy.polys.domains.integerring.IntegerRing.from_sympy

def from_sympy(self, a):
    if a.is_Integer:
        return MPZ(a.p)
    elif a.is_Float and int(a) == a:
        return MPZ(int(a))
    else:
        raise CoercionFailed('expected an integer, got %s' % a)

.sympy.polys.domains.integerring.IntegerRing.gcd

def gcd(self, a, b):
    return gcd(a, b)

.sympy.polys.domains.domain.Domain.is_one

def is_one(self, a):
    return a == self.one

.sympy.polys.domains.integerring.IntegerRing.to_sympy

def to_sympy(self, a):
    return SymPyInteger(int(a))

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.numbers.Rational.__truediv__

def __truediv__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            if self.p and other.p == S.Zero:
                return S.ComplexInfinity
            else:
                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))
        elif isinstance(other, Rational):
            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))
        elif isinstance(other, Float):
            return self * (1 / other)
        else:
            return Number.__truediv__(self, other)
    return Number.__truediv__(self, other)

.sympy.core.numbers.igcd

def igcd(*args):
    if len(args) < 2:
        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))
    args_temp = [abs(as_int(i)) for i in args]
    if 1 in args_temp:
        return 1
    a = args_temp.pop()
    if HAS_GMPY:
        for b in args_temp:
            a = gmpy.gcd(a, b) if b else a
        return as_int(a)
    for b in args_temp:
        a = math.gcd(a, b)
    return a

.sympy.utilities.misc.as_int

def as_int(n, strict=True):
    if strict:
        try:
            if isinstance(n, bool):
                raise TypeError
            return operator.index(n)
        except TypeError:
            raise ValueError('%s is not an integer' % (n,))
    else:
        try:
            result = int(n)
        except TypeError:
            raise ValueError('%s is not an integer' % (n,))
        if n != result:
            raise ValueError('%s is not an integer' % (n,))
        return result

.sympy.core.numbers.Rational.__new__

def __new__(cls, p, q=None, gcd=None):
    if q is None:
        if isinstance(p, Rational):
            return p
        if isinstance(p, SYMPY_INTS):
            pass
        else:
            if isinstance(p, (float, Float)):
                return Rational(*_as_integer_ratio(p))
            if not isinstance(p, str):
                try:
                    p = sympify(p)
                except (SympifyError, SyntaxError):
                    pass
            else:
                if p.count('/') > 1:
                    raise TypeError('invalid input: %s' % p)
                p = p.replace(' ', '')
                pq = p.rsplit('/', 1)
                if len(pq) == 2:
                    p, q = pq
                    fp = fractions.Fraction(p)
                    fq = fractions.Fraction(q)
                    p = fp / fq
                try:
                    p = fractions.Fraction(p)
                except ValueError:
                    pass
                else:
                    return Rational(p.numerator, p.denominator, 1)
            if not isinstance(p, Rational):
                raise TypeError('invalid input: %s' % p)
        q = 1
        gcd = 1
    if not isinstance(p, SYMPY_INTS):
        p = Rational(p)
        q *= p.q
        p = p.p
    else:
        p = int(p)
    if not isinstance(q, SYMPY_INTS):
        q = Rational(q)
        p *= q.q
        q = q.p
    else:
        q = int(q)
    if q == 0:
        if p == 0:
            if _errdict['divide']:
                raise ValueError('Indeterminate 0/0')
            else:
                return S.NaN
        return S.ComplexInfinity
    if q < 0:
        q = -q
        p = -p
    if not gcd:
        gcd = igcd(abs(p), q)
    if gcd > 1:
        p //= gcd
        q //= gcd
    if q == 1:
        return Integer(p)
    if p == 1 and q == 2:
        return S.Half
    obj = Expr.__new__(cls)
    obj.p = p
    obj.q = q
    return obj

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, int):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.geometry.polygon.Polygon.sides

def sides(self):
    res = []
    args = self.vertices
    for i in range(-len(args), 0):
        res.append(Segment(args[i], args[i + 1]))
    return res

.sympy.geometry.line.Segment.__new__

def __new__(cls, p1, p2, **kwargs):
    p1, p2 = Point._normalize_dimension(Point(p1), Point(p2))
    dim = len(p1)
    if dim == 2:
        return Segment2D(p1, p2, **kwargs)
    elif dim == 3:
        return Segment3D(p1, p2, **kwargs)
    return LinearEntity.__new__(cls, p1, p2, **kwargs)

.sympy.geometry.point.Point.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_parameters.evaluate)
    on_morph = kwargs.get('on_morph', 'ignore')
    coords = args[0] if len(args) == 1 else args
    if isinstance(coords, Point):
        evaluate = False
        if len(coords) == kwargs.get('dim', len(coords)):
            return coords
    if not is_sequence(coords):
        raise TypeError(filldedent('\n            Expecting sequence of coordinates, not `{}`'.format(func_name(coords))))
    if len(coords) == 0 and kwargs.get('dim', None):
        coords = (S.Zero,) * kwargs.get('dim')
    coords = Tuple(*coords)
    dim = kwargs.get('dim', len(coords))
    if len(coords) < 2:
        raise ValueError(filldedent('\n            Point requires 2 or more coordinates or\n            keyword `dim` > 1.'))
    if len(coords) != dim:
        message = 'Dimension of {} needs to be changed from {} to {}.'.format(coords, len(coords), dim)
        if on_morph == 'ignore':
            pass
        elif on_morph == 'error':
            raise ValueError(message)
        elif on_morph == 'warn':
            warnings.warn(message, stacklevel=2)
        else:
            raise ValueError(filldedent("\n                    on_morph value should be 'error',\n                    'warn' or 'ignore'."))
    if any(coords[dim:]):
        raise ValueError('Nonzero coordinates cannot be removed.')
    if any((a.is_number and im(a).is_zero is False for a in coords)):
        raise ValueError('Imaginary coordinates are not permitted.')
    if not all((isinstance(a, Expr) for a in coords)):
        raise TypeError('Coordinates must be valid SymPy expressions.')
    coords = coords[:dim] + (S.Zero,) * (dim - len(coords))
    if evaluate:
        coords = coords.xreplace({f: simplify(nsimplify(f, rational=True)) for f in coords.atoms(Float)})
    if len(coords) == 2:
        kwargs['_nocheck'] = True
        return Point2D(*coords, **kwargs)
    elif len(coords) == 3:
        kwargs['_nocheck'] = True
        return Point3D(*coords, **kwargs)
    return GeometryEntity.__new__(cls, *coords)

.sympy.geometry.point.Point.__len__

def __len__(self):
    return len(self.args)

.sympy.geometry.point.Point._normalize_dimension

def _normalize_dimension(cls, *points, **kwargs):
    dim = getattr(cls, '_ambient_dimension', None)
    dim = kwargs.get('dim', dim)
    if dim is None:
        dim = max((i.ambient_dimension for i in points))
    if all((i.ambient_dimension == dim for i in points)):
        return list(points)
    kwargs['dim'] = dim
    kwargs['on_morph'] = kwargs.get('on_morph', 'warn')
    return [Point(i, **kwargs) for i in points]

.sympy.geometry.point.Point.ambient_dimension

def ambient_dimension(self):
    return getattr(self, '_ambient_dimension', len(self))

.sympy.geometry.line.Segment2D.__new__

def __new__(cls, p1, p2, **kwargs):
    p1 = Point(p1, dim=2)
    p2 = Point(p2, dim=2)
    if p1 == p2:
        return p1
    return LinearEntity2D.__new__(cls, p1, p2, **kwargs)

.sympy.geometry.point.Point.__eq__

def __eq__(self, other):
    if not isinstance(other, Point) or len(self.args) != len(other.args):
        return False
    return self.args == other.args

.sympy.geometry.line.LinearEntity.__new__

def __new__(cls, p1, p2=None, **kwargs):
    p1, p2 = Point._normalize_dimension(p1, p2)
    if p1 == p2:
        raise ValueError('%s.__new__ requires two unique Points.' % cls.__name__)
    if len(p1) != len(p2):
        raise ValueError('%s.__new__ requires two Points of equal dimension.' % cls.__name__)
    return GeometryEntity.__new__(cls, p1, p2, **kwargs)

.sympy.geometry.entity.GeometryEntity.__new__

def __new__(cls, *args, **kwargs):

    def is_seq_and_not_point(a):
        if hasattr(a, 'is_Point') and a.is_Point:
            return False
        return is_sequence(a)
    args = [Tuple(*a) if is_seq_and_not_point(a) else sympify(a) for a in args]
    return Basic.__new__(cls, *args)

.sympy.geometry.entity.GeometryEntity.is_seq_and_not_point

def is_seq_and_not_point(a):
    if hasattr(a, 'is_Point') and a.is_Point:
        return False
    return is_sequence(a)

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.integrals.intpoly.point_sort

def point_sort(poly, normal=None, clockwise=True):
    pts = poly.vertices if isinstance(poly, Polygon) else poly
    n = len(pts)
    if n < 2:
        return list(pts)
    order = S.One if clockwise else S.NegativeOne
    dim = len(pts[0])
    if dim == 2:
        center = Point(sum(map(lambda vertex: vertex.x, pts)) / n, sum(map(lambda vertex: vertex.y, pts)) / n)
    else:
        center = Point(sum(map(lambda vertex: vertex.x, pts)) / n, sum(map(lambda vertex: vertex.y, pts)) / n, sum(map(lambda vertex: vertex.z, pts)) / n)

    def compare(a, b):
        if a.x - center.x >= S.Zero and b.x - center.x < S.Zero:
            return -order
        elif a.x - center.x < 0 and b.x - center.x >= 0:
            return order
        elif a.x - center.x == 0 and b.x - center.x == 0:
            if a.y - center.y >= 0 or b.y - center.y >= 0:
                return -order if a.y > b.y else order
            return -order if b.y > a.y else order
        det = (a.x - center.x) * (b.y - center.y) - (b.x - center.x) * (a.y - center.y)
        if det < 0:
            return -order
        elif det > 0:
            return order
        first = (a.x - center.x) * (a.x - center.x) + (a.y - center.y) * (a.y - center.y)
        second = (b.x - center.x) * (b.x - center.x) + (b.y - center.y) * (b.y - center.y)
        return -order if first > second else order

    def compare3d(a, b):
        det = cross_product(center, a, b)
        dot_product = sum([det[i] * normal[i] for i in range(0, 3)])
        if dot_product < 0:
            return -order
        elif dot_product > 0:
            return order
    return sorted(pts, key=cmp_to_key(compare if dim == 2 else compare3d))

.sympy.geometry.point.Point2D.x

def x(self):
    return self.args[0]

.sympy.core.numbers.Integer.__radd__

def __radd__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(other + self.p)
        elif isinstance(other, Rational):
            return Rational(other.p + self.p * other.q, other.q, 1)
        return Rational.__radd__(self, other)
    return Rational.__radd__(self, other)

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.geometry.point.Point2D.y

def y(self):
    return self.args[1]

.sympy.utilities.iterables.is_sequence

def is_sequence(i, include=None):
    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.containers.Tuple.__len__

def __len__(self):
    return len(self.args)

.sympy.core.containers.Tuple.__getitem__

def __getitem__(self, i):
    if isinstance(i, slice):
        indices = i.indices(len(self))
        return Tuple(*(self.args[j] for j in range(*indices)))
    return self.args[i]

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_parameters.evaluate)
    result = super().__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_parameters.evaluate)
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return S.EmptySet
    else:
        args = list(map(sympify, args))
    dargs = {}
    for i in reversed(list(ordered(args))):
        if i.is_Symbol:
            dargs[i] = i
        else:
            try:
                dargs[i.as_dummy()] = i
            except TypeError:
                dargs[i] = i
    _args_set = set(dargs.values())
    args = list(ordered(_args_set, Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._args_set = _args_set
    return obj

.sympy.core.sorting.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        yield from d[k]
        d.pop(k)

.sympy.core.basic.Basic.as_dummy

def as_dummy(self):
    from .symbol import Dummy, Symbol

    def can(x):
        free = x.free_symbols
        bound = set(x.bound_symbols)
        d = {i: Dummy() for i in bound & free}
        x = x.subs(d)
        x = x.xreplace(x.canonical_variables)
        return x.xreplace({v: k for k, v in d.items()})
    if not self.has(Symbol):
        return self
    return self.replace(lambda x: hasattr(x, 'bound_symbols'), can, simultaneous=False)

.sympy.core.basic.Basic.has

def has(self, *patterns):
    return self._has(iterargs, *patterns)

.sympy.core.basic.Basic._has

def _has(self, iterargs, *patterns):
    type_set = set()
    p_set = set()
    for p in patterns:
        if isinstance(p, BasicMeta):
            type_set.add(p)
            continue
        if not isinstance(p, Basic):
            try:
                p = _sympify(p)
            except SympifyError:
                continue
        p_set.add(p)
    types = tuple(type_set)
    for i in iterargs(self):
        if i in p_set:
            return True
        if isinstance(i, types):
            return True
    for i in p_set - type_set:
        if not hasattr(i, '_has_matcher'):
            continue
        match = i._has_matcher()
        if any((match(arg) for arg in iterargs(self))):
            return True
    return False

.sympy.core.traversal.iterargs

def iterargs(expr):
    args = [expr]
    for i in args:
        yield i
        try:
            args.extend(i.args)
        except TypeError:
            pass

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
        infimum = infimum.evalf()
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.core.basic.Basic.__hash__

def __hash__(self) -> int:
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    other = _sympify(other)
    c = self._contains(other)
    b = tfn[c]
    if b is None:
        raise TypeError('did not evaluate to a bool: %r' % c)
    return b

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    if other in self._args_set:
        return True
    else:
        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))

.sympy.logic.boolalg.BooleanTrue.__bool__

def __bool__(self):
    return True

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_parameters.evaluate)
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super().__new__(cls, *args, **options)
    sentinel = object()
    objnargs = getattr(obj, 'nargs', sentinel)
    if objnargs is not sentinel:
        if is_sequence(objnargs):
            nargs = tuple(ordered(set(objnargs)))
        elif objnargs is not None:
            nargs = (as_int(objnargs),)
        else:
            nargs = None
    else:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.functions.elementary.complexes.im.eval

def eval(cls, arg):
    if arg is S.NaN:
        return S.NaN
    elif arg is S.ComplexInfinity:
        return S.NaN
    elif arg.is_extended_real:
        return S.Zero
    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:
        return -S.ImaginaryUnit * arg
    elif arg.is_Matrix:
        return arg.as_real_imag()[1]
    elif arg.is_Function and isinstance(arg, conjugate):
        return -im(arg.args[0])
    else:
        included, reverted, excluded = ([], [], [])
        args = Add.make_args(arg)
        for term in args:
            coeff = term.as_coefficient(S.ImaginaryUnit)
            if coeff is not None:
                if not coeff.is_extended_real:
                    reverted.append(coeff)
                else:
                    excluded.append(coeff)
            elif term.has(S.ImaginaryUnit) or not term.is_extended_real:
                real_imag = term.as_real_imag(ignore=arg)
                if real_imag:
                    excluded.append(real_imag[1])
                else:
                    included.append(term)
        if len(args) != len(included):
            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])
            return cls(a) + re(b) + c

.sympy.core.containers.Tuple.__add__

def __add__(self, other):
    if isinstance(other, Tuple):
        return Tuple(*self.args + other.args)
    elif isinstance(other, tuple):
        return Tuple(*self.args + other)
    else:
        return NotImplemented

.sympy.core.basic.Basic.atoms

def atoms(self, *types):
    if types:
        types = tuple([t if isinstance(t, type) else type(t) for t in types])
    nodes = _preorder_traversal(self)
    if types:
        result = {node for node in nodes if isinstance(node, types)}
    else:
        result = {node for node in nodes if not node.args}
    return result

.sympy.core.traversal.preorder_traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

.sympy.core.traversal.preorder_traversal.__iter__

def __iter__(self):
    return self

.sympy.core.traversal.preorder_traversal.__next__

def __next__(self):
    return next(self._pt)

.sympy.core.traversal.preorder_traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            yield from self._preorder_traversal(arg, keys)
    elif iterable(node):
        for item in node:
            yield from self._preorder_traversal(item, keys)

.sympy.core.basic.Basic.xreplace

def xreplace(self, rule):
    value, _ = self._xreplace(rule)
    return value

.sympy.core.basic.Basic._xreplace

def _xreplace(self, rule):
    if self in rule:
        return (rule[self], True)
    elif rule:
        args = []
        changed = False
        for a in self.args:
            _xreplace = getattr(a, '_xreplace', None)
            if _xreplace is not None:
                a_xr = _xreplace(rule)
                args.append(a_xr[0])
                changed |= a_xr[1]
            else:
                args.append(a)
        args = tuple(args)
        if changed:
            return (self.func(*args), True)
    return (self, False)

.sympy.core.containers.Tuple.__hash__

def __hash__(self):
    return hash(self.args)

.sympy.core.numbers.Rational.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.core.numbers.Rational._hashable_content

def _hashable_content(self):
    return (self.p, self.q)

.sympy.geometry.point.Point2D.__new__

def __new__(cls, *args, _nocheck=False, **kwargs):
    if not _nocheck:
        kwargs['dim'] = 2
        args = Point(*args, **kwargs)
    return GeometryEntity.__new__(cls, *args)

.sympy.integrals.intpoly.compare

def compare(a, b):
    if a.x - center.x >= S.Zero and b.x - center.x < S.Zero:
        return -order
    elif a.x - center.x < 0 and b.x - center.x >= 0:
        return order
    elif a.x - center.x == 0 and b.x - center.x == 0:
        if a.y - center.y >= 0 or b.y - center.y >= 0:
            return -order if a.y > b.y else order
        return -order if b.y > a.y else order
    det = (a.x - center.x) * (b.y - center.y) - (b.x - center.x) * (a.y - center.y)
    if det < 0:
        return -order
    elif det > 0:
        return order
    first = (a.x - center.x) * (a.x - center.x) + (a.y - center.y) * (a.y - center.y)
    second = (b.x - center.x) * (b.x - center.x) + (b.y - center.y) * (b.y - center.y)
    return -order if first > second else order

.sympy.core.numbers.Integer.__le__

def __le__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p <= other.p)
    return Rational.__le__(self, other)

.sympy.core.numbers.Rational.__le__

def __le__(self, other):
    rv = self._Rrel(other, '__ge__')
    if rv is None:
        rv = (self, other)
    elif not isinstance(rv, tuple):
        return rv
    return Expr.__le__(*rv)

.sympy.core.numbers.Rational._Rrel

def _Rrel(self, other, attr):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Number:
        op = None
        s, o = (self, other)
        if other.is_NumberSymbol:
            op = getattr(o, attr)
        elif other.is_Float:
            op = getattr(o, attr)
        elif other.is_Rational:
            s, o = (Integer(s.p * o.q), Integer(s.q * o.p))
            op = getattr(o, attr)
        if op:
            return op(s)
        if o.is_number and o.is_extended_real:
            return (Integer(s.p), s.q * o)

.sympy.core.numbers.Integer.__ge__

def __ge__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p >= other.p)
    return Rational.__ge__(self, other)

.sympy.core.numbers.Integer.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p > other.p)
    return Rational.__gt__(self, other)

.sympy.core.numbers.Rational.__gt__

def __gt__(self, other):
    rv = self._Rrel(other, '__lt__')
    if rv is None:
        rv = (self, other)
    elif not isinstance(rv, tuple):
        return rv
    return Expr.__gt__(*rv)

.sympy.core.numbers.Integer.__lt__

def __lt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p < other.p)
    return Rational.__lt__(self, other)

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.logic.boolalg.BooleanFalse.__bool__

def __bool__(self):
    return False

.sympy.core.numbers.Rational.__lt__

def __lt__(self, other):
    rv = self._Rrel(other, '__gt__')
    if rv is None:
        rv = (self, other)
    elif not isinstance(rv, tuple):
        return rv
    return Expr.__lt__(*rv)

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not isinstance(other, Number):
        return False
    if not self:
        return not other
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Rational:
        return self.p == other.p and self.q == other.q
    if other.is_Float:
        if self.q & self.q - 1:
            return False
        s, m, t = other._mpf_[:3]
        if s:
            m = -m
        if not t:
            if not self.is_Integer or self.is_even:
                return False
            return m == self.p
        from .power import integer_log
        if t > 0:
            if not self.is_Integer:
                return False
            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))
        if self.is_Integer:
            return False
        return m == self.p and integer_log(self.q, 2) == (-t, True)
    return False

.sympy.core.numbers.Rational.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))
        elif isinstance(other, Float):
            return other * self
        else:
            return Number.__mul__(self, other)
    return Number.__mul__(self, other)

.sympy.core.numbers.Rational.__sub__

def __sub__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p - self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return -other + self
        else:
            return Number.__sub__(self, other)
    return Number.__sub__(self, other)

.sympy.geometry.polygon.Polygon.__new__

def __new__(cls, *args, n=0, **kwargs):
    if n:
        args = list(args)
        if len(args) == 2:
            args.append(n)
        elif len(args) == 3:
            args.insert(2, n)
        return RegularPolygon(*args, **kwargs)
    vertices = [Point(a, dim=2, **kwargs) for a in args]
    nodup = []
    for p in vertices:
        if nodup and p == nodup[-1]:
            continue
        nodup.append(p)
    if len(nodup) > 1 and nodup[-1] == nodup[0]:
        nodup.pop()
    i = -3
    while i < len(nodup) - 3 and len(nodup) > 2:
        a, b, c = (nodup[i], nodup[i + 1], nodup[i + 2])
        if Point.is_collinear(a, b, c):
            nodup.pop(i + 1)
            if a == c:
                nodup.pop(i)
        else:
            i += 1
    vertices = list(nodup)
    if len(vertices) > 3:
        return GeometryEntity.__new__(cls, *vertices, **kwargs)
    elif len(vertices) == 3:
        return Triangle(*vertices, **kwargs)
    elif len(vertices) == 2:
        return Segment(*vertices, **kwargs)
    else:
        return Point(*vertices, **kwargs)

.sympy.geometry.point.Point.is_collinear

def is_collinear(self, *args):
    points = (self,) + args
    points = Point._normalize_dimension(*[Point(i) for i in points])
    points = list(uniq(points))
    return Point.affine_rank(*points) <= 1

.sympy.utilities.iterables.uniq

def uniq(seq, result=None):
    try:
        n = len(seq)
    except TypeError:
        n = None

    def check():
        if n is not None and len(seq) != n:
            raise RuntimeError('sequence changed size during iteration')
    try:
        seen = set()
        result = result or []
        for i, s in enumerate(seq):
            if not (s in seen or seen.add(s)):
                yield s
                check()
    except TypeError:
        if s not in result:
            yield s
            check()
            result.append(s)
        if hasattr(seq, '__getitem__'):
            yield from uniq(seq[i + 1:], result)
        else:
            yield from uniq(seq, result)

.sympy.geometry.point.Point.__hash__

def __hash__(self):
    return hash(self.args)

.sympy.utilities.iterables.check

def check():
    if n is not None and len(seq) != n:
        raise RuntimeError('sequence changed size during iteration')

.sympy.geometry.point.Point.affine_rank

def affine_rank(*args):
    if len(args) == 0:
        return -1
    points = Point._normalize_dimension(*[Point(i) for i in args])
    origin = points[0]
    points = [i - origin for i in points[1:]]
    m = Matrix([i.args for i in points])
    return m.rank(iszerofunc=lambda x: abs(x.n(2)) < 1e-12 if x.is_number else x.is_zero)

.sympy.geometry.point.Point.__sub__

def __sub__(self, other):
    return self + [-x for x in other]

.sympy.geometry.point.Point.__iter__

def __iter__(self):
    return self.args.__iter__()

.sympy.geometry.point.Point.__add__

def __add__(self, other):
    try:
        s, o = Point._normalize_dimension(self, Point(other, evaluate=False))
    except TypeError:
        raise GeometryError("Don't know how to add {} and a Point object".format(other))
    coords = [simplify(a + b) for a, b in zip(s, o)]
    return Point(coords, evaluate=False)

.sympy.simplify.simplify.simplify

def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):

    def shorter(*choices):
        if not has_variety(choices):
            return choices[0]
        return min(choices, key=measure)

    def done(e):
        rv = e.doit() if doit else e
        return shorter(rv, collect_abs(rv))
    expr = sympify(expr, rational=rational)
    kwargs = dict(ratio=kwargs.get('ratio', ratio), measure=kwargs.get('measure', measure), rational=kwargs.get('rational', rational), inverse=kwargs.get('inverse', inverse), doit=kwargs.get('doit', doit))
    if isinstance(expr, Expr) and expr.is_zero:
        return S.Zero if not expr.is_Number else expr
    _eval_simplify = getattr(expr, '_eval_simplify', None)
    if _eval_simplify is not None:
        return _eval_simplify(**kwargs)
    original_expr = expr = collect_abs(signsimp(expr))
    if not isinstance(expr, Basic) or not expr.args:
        return expr
    if inverse and expr.has(Function):
        expr = inversecombine(expr)
        if not expr.args:
            return expr
    handled = (Add, Mul, Pow, ExpBase)
    expr = expr.replace(lambda x: isinstance(x, Expr) and x.args and (not isinstance(x, handled)), lambda x: x.func(*[simplify(i, **kwargs) for i in x.args]), simultaneous=False)
    if not isinstance(expr, handled):
        return done(expr)
    if not expr.is_commutative:
        expr = nc_simplify(expr)
    floats = False
    if rational is not False and expr.has(Float):
        floats = True
        expr = nsimplify(expr, rational=True)
    expr = _bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())
    expr = Mul(*powsimp(expr).as_content_primitive())
    _e = cancel(expr)
    expr1 = shorter(_e, _mexpand(_e).cancel())
    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
    if ratio is S.Infinity:
        expr = expr2
    else:
        expr = shorter(expr2, expr1, expr)
    if not isinstance(expr, Basic):
        return expr
    expr = factor_terms(expr, sign=False)
    if expr.has(sign):
        expr = expr.rewrite(Abs)
    if expr.has(Piecewise):
        expr = piecewise_fold(expr)
        expr = done(expr)
        if expr.has(Piecewise):
            expr = piecewise_fold(expr)
            if expr.has(KroneckerDelta):
                expr = kroneckersimp(expr)
            if expr.has(Piecewise):
                expr = piecewise_simplify(expr, deep=True, doit=False)
                if expr.has(Piecewise):
                    expr = shorter(expr, factor_terms(expr))
                    return expr
    expr = hyperexpand(expr)
    if expr.has(KroneckerDelta):
        expr = kroneckersimp(expr)
    if expr.has(BesselBase):
        expr = besselsimp(expr)
    if expr.has(TrigonometricFunction, HyperbolicFunction):
        expr = trigsimp(expr, deep=True)
    if expr.has(log):
        expr = shorter(expand_log(expr, deep=True), logcombine(expr))
    if expr.has(CombinatorialFunction, gamma):
        expr = combsimp(expr)
    if expr.has(Sum):
        expr = sum_simplify(expr, **kwargs)
    if expr.has(Integral):
        expr = expr.xreplace({i: factor_terms(i) for i in expr.atoms(Integral)})
    if expr.has(Product):
        expr = product_simplify(expr)
    from sympy.physics.units import Quantity
    if expr.has(Quantity):
        from sympy.physics.units.util import quantity_simplify
        expr = quantity_simplify(expr)
    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
    short = shorter(short, cancel(short))
    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase, exp):
        short = exptrigsimp(short)
    hollow_mul = Transform(lambda x: Mul(*x.args), lambda x: x.is_Mul and len(x.args) == 2 and x.args[0].is_Number and x.args[1].is_Add and x.is_commutative)
    expr = short.xreplace(hollow_mul)
    numer, denom = expr.as_numer_denom()
    if denom.is_Add:
        n, d = fraction(radsimp(1 / denom, symbolic=False, max_terms=1))
        if n is not S.One:
            expr = (numer * n).expand() / d
    if expr.could_extract_minus_sign():
        n, d = fraction(expr)
        if d != 0:
            expr = signsimp(-n / -d)
    if measure(expr) > ratio * measure(original_expr):
        expr = original_expr
    if floats and rational is None:
        expr = nfloat(expr, exponent=False)
    return done(expr)

.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.basic.Atom._eval_simplify

def _eval_simplify(self, **kwargs):
    return self

.sympy.matrices.repmatrix.MutableRepMatrix.__new__

def __new__(cls, *args, **kwargs):
    return cls._new(*args, **kwargs)

.sympy.matrices.repmatrix.MutableRepMatrix._new

def _new(cls, *args, copy=True, **kwargs):
    if copy is False:
        if len(args) != 3:
            raise TypeError("'copy=False' requires a matrix be initialized as rows,cols,[list]")
        rows, cols, flat_list = args
    else:
        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)
        flat_list = list(flat_list)
    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)
    return cls._fromrep(rep)

.sympy.matrices.matrices.MatrixBase._handle_creation_inputs

def _handle_creation_inputs(cls, *args, **kwargs):
    from sympy.matrices import SparseMatrix
    from sympy.matrices.expressions.matexpr import MatrixSymbol
    from sympy.matrices.expressions.blockmatrix import BlockMatrix
    flat_list = None
    if len(args) == 1:
        if isinstance(args[0], SparseMatrix):
            return (args[0].rows, args[0].cols, flatten(args[0].tolist()))
        elif isinstance(args[0], MatrixBase):
            return (args[0].rows, args[0].cols, args[0].flat())
        elif isinstance(args[0], Basic) and args[0].is_Matrix:
            return (args[0].rows, args[0].cols, args[0].as_explicit().flat())
        elif isinstance(args[0], mp.matrix):
            M = args[0]
            flat_list = [cls._sympify(x) for x in M]
            return (M.rows, M.cols, flat_list)
        elif hasattr(args[0], '__array__'):
            return cls._handle_ndarray(args[0])
        elif is_sequence(args[0]) and (not isinstance(args[0], DeferredVector)):
            dat = list(args[0])
            ismat = lambda i: isinstance(i, MatrixBase) and (evaluate or isinstance(i, BlockMatrix) or isinstance(i, MatrixSymbol))
            raw = lambda i: is_sequence(i) and (not ismat(i))
            evaluate = kwargs.get('evaluate', True)
            if evaluate:

                def make_explicit(x):
                    if isinstance(x, BlockMatrix):
                        return x.as_explicit()
                    elif isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape)):
                        return x.as_explicit()
                    else:
                        return x

                def make_explicit_row(row):
                    if isinstance(row, (list, tuple)):
                        return [make_explicit(x) for x in row]
                    else:
                        return make_explicit(row)
                if isinstance(dat, (list, tuple)):
                    dat = [make_explicit_row(row) for row in dat]
            if dat in ([], [[]]):
                rows = cols = 0
                flat_list = []
            elif not any((raw(i) or ismat(i) for i in dat)):
                flat_list = [cls._sympify(i) for i in dat]
                rows = len(flat_list)
                cols = 1 if rows else 0
            elif evaluate and all((ismat(i) for i in dat)):
                ncol = {i.cols for i in dat if any(i.shape)}
                if ncol:
                    if len(ncol) != 1:
                        raise ValueError('mismatched dimensions')
                    flat_list = [_ for i in dat for r in i.tolist() for _ in r]
                    cols = ncol.pop()
                    rows = len(flat_list) // cols
                else:
                    rows = cols = 0
                    flat_list = []
            elif evaluate and any((ismat(i) for i in dat)):
                ncol = set()
                flat_list = []
                for i in dat:
                    if ismat(i):
                        flat_list.extend([k for j in i.tolist() for k in j])
                        if any(i.shape):
                            ncol.add(i.cols)
                    elif raw(i):
                        if i:
                            ncol.add(len(i))
                            flat_list.extend([cls._sympify(ij) for ij in i])
                    else:
                        ncol.add(1)
                        flat_list.append(i)
                    if len(ncol) > 1:
                        raise ValueError('mismatched dimensions')
                cols = ncol.pop()
                rows = len(flat_list) // cols
            else:
                flat_list = []
                ncol = set()
                rows = cols = 0
                for row in dat:
                    if not is_sequence(row) and (not getattr(row, 'is_Matrix', False)):
                        raise ValueError('expecting list of lists')
                    if hasattr(row, '__array__'):
                        if 0 in row.shape:
                            continue
                    elif not row:
                        continue
                    if evaluate and all((ismat(i) for i in row)):
                        r, c, flatT = cls._handle_creation_inputs([i.T for i in row])
                        T = reshape(flatT, [c])
                        flat = [T[i][j] for j in range(c) for i in range(r)]
                        r, c = (c, r)
                    else:
                        r = 1
                        if getattr(row, 'is_Matrix', False):
                            c = 1
                            flat = [row]
                        else:
                            c = len(row)
                            flat = [cls._sympify(i) for i in row]
                    ncol.add(c)
                    if len(ncol) > 1:
                        raise ValueError('mismatched dimensions')
                    flat_list.extend(flat)
                    rows += r
                cols = ncol.pop() if ncol else 0
    elif len(args) == 3:
        rows = as_int(args[0])
        cols = as_int(args[1])
        if rows < 0 or cols < 0:
            raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))
        if len(args) == 3 and isinstance(args[2], Callable):
            op = args[2]
            flat_list = []
            for i in range(rows):
                flat_list.extend([cls._sympify(op(cls._sympify(i), cls._sympify(j))) for j in range(cols)])
        elif len(args) == 3 and is_sequence(args[2]):
            flat_list = args[2]
            if len(flat_list) != rows * cols:
                raise ValueError('List length should be equal to rows*columns')
            flat_list = [cls._sympify(i) for i in flat_list]
    elif len(args) == 0:
        rows = cols = 0
        flat_list = []
    if flat_list is None:
        raise TypeError(filldedent('\n            Data type not understood; expecting list of lists\n            or lists of values.'))
    return (rows, cols, flat_list)

.sympy.matrices.matrices.MatrixBase.make_explicit_row

def make_explicit_row(row):
    if isinstance(row, (list, tuple)):
        return [make_explicit(x) for x in row]
    else:
        return make_explicit(row)

.sympy.matrices.matrices.MatrixBase.make_explicit

def make_explicit(x):
    if isinstance(x, BlockMatrix):
        return x.as_explicit()
    elif isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape)):
        return x.as_explicit()
    else:
        return x

.sympy.matrices.repmatrix.RepMatrix._flat_list_to_DomainMatrix

def _flat_list_to_DomainMatrix(cls, rows, cols, flat_list):
    elements_dod = defaultdict(dict)
    for n, element in enumerate(flat_list):
        if element != 0:
            i, j = divmod(n, cols)
            elements_dod[i][j] = element
    types = set(map(type, flat_list))
    rep = cls._dod_to_DomainMatrix(rows, cols, elements_dod, types)
    return rep

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.matrices.repmatrix.RepMatrix._dod_to_DomainMatrix

def _dod_to_DomainMatrix(cls, rows, cols, dod, types):
    if not all((issubclass(typ, Expr) for typ in types)):
        sympy_deprecation_warning('\n            non-Expr objects in a Matrix is deprecated. Matrix represents\n            a mathematical matrix. To represent a container of non-numeric\n            entities, Use a list of lists, TableForm, NumPy array, or some\n            other data structure instead.\n            ', deprecated_since_version='1.9', active_deprecations_target='deprecated-non-expr-in-matrix', stacklevel=6)
    rep = DomainMatrix(dod, (rows, cols), EXRAW)
    if all((issubclass(typ, Rational) for typ in types)):
        if all((issubclass(typ, Integer) for typ in types)):
            rep = rep.convert_to(ZZ)
        else:
            rep = rep.convert_to(QQ)
    return rep

.sympy.polys.matrices.domainmatrix.DomainMatrix.__new__

def __new__(cls, rows, shape, domain, *, fmt=None):
    if isinstance(rows, (DDM, SDM)):
        raise TypeError('Use from_rep to initialise from SDM/DDM')
    elif isinstance(rows, list):
        rep = DDM(rows, shape, domain)
    elif isinstance(rows, dict):
        rep = SDM(rows, shape, domain)
    else:
        msg = 'Input should be list-of-lists or dict-of-dicts'
        raise TypeError(msg)
    if fmt is not None:
        if fmt == 'sparse':
            rep = rep.to_sdm()
        elif fmt == 'dense':
            rep = rep.to_ddm()
        else:
            raise ValueError("fmt should be 'sparse' or 'dense'")
    return cls.from_rep(rep)

.sympy.polys.matrices.sdm.SDM.__init__

def __init__(self, elemsdict, shape, domain):
    super().__init__(elemsdict)
    self.shape = self.rows, self.cols = m, n = shape
    self.domain = domain
    if not all((0 <= r < m for r in self)):
        raise DMBadInputError('Row out of range')
    if not all((0 <= c < n for row in self.values() for c in row)):
        raise DMBadInputError('Column out of range')

.sympy.polys.matrices.domainmatrix.DomainMatrix.from_rep

def from_rep(cls, rep):
    if not isinstance(rep, (DDM, SDM)):
        raise TypeError('rep should be of type DDM or SDM')
    self = super().__new__(cls)
    self.rep = rep
    self.shape = rep.shape
    self.domain = rep.domain
    return self

.sympy.polys.matrices.domainmatrix.DomainMatrix.convert_to

def convert_to(self, K):
    if K is None:
        return self.copy()
    return self.from_rep(self.rep.convert_to(K))

.sympy.polys.matrices.sdm.SDM.convert_to

def convert_to(A, K):
    Kold = A.domain
    if K == Kold:
        return A.copy()
    Ak = unop_dict(A, lambda e: K.convert_from(e, Kold))
    return A.new(Ak, A.shape, K)

.sympy.polys.domains.domain.Domain.__eq__

def __eq__(self, other):
    return isinstance(other, Domain) and self.dtype == other.dtype

.sympy.polys.matrices.sdm.unop_dict

def unop_dict(A, f):
    B = {}
    for i, Ai in A.items():
        Bi = {}
        for j, Aij in Ai.items():
            Bij = f(Aij)
            if Bij:
                Bi[j] = Bij
        if Bi:
            B[i] = Bi
    return B

.sympy.polys.domains.domain.Domain.convert_from

def convert_from(self, element, base):
    if base.alias is not None:
        method = 'from_' + base.alias
    else:
        method = 'from_' + base.__class__.__name__
    _convert = getattr(self, method)
    if _convert is not None:
        result = _convert(element, base)
        if result is not None:
            return result
    raise CoercionFailed('Cannot convert %s of type %s from %s to %s' % (element, type(element), base, self))

.sympy.polys.domains.domain.Domain.from_ExpressionRawDomain

def from_ExpressionRawDomain(K1, a, K0):
    return K1.from_sympy(a)

.sympy.polys.matrices.sdm.SDM.new

def new(cls, sdm, shape, domain):
    return cls(sdm, shape, domain)

.sympy.matrices.repmatrix.MutableRepMatrix._fromrep

def _fromrep(cls, rep):
    obj = super().__new__(cls)
    obj.rows, obj.cols = rep.shape
    obj._rep = rep
    return obj

.sympy.matrices.matrices.MatrixReductions.rank

def rank(self, iszerofunc=_iszero, simplify=False):
    return _rank(self, iszerofunc=iszerofunc, simplify=simplify)

.sympy.matrices.reductions._rank

def _rank(M, iszerofunc=_iszero, simplify=False):

    def _permute_complexity_right(M, iszerofunc):

        def complexity(i):
            return sum((1 if iszerofunc(e) is None else 0 for e in M[:, i]))
        complex = [(complexity(i), i) for i in range(M.cols)]
        perm = [j for i, j in sorted(complex)]
        return (M.permute(perm, orientation='cols'), perm)
    simpfunc = simplify if isinstance(simplify, FunctionType) else _simplify
    if M.rows <= 0 or M.cols <= 0:
        return 0
    if M.rows <= 1 or M.cols <= 1:
        zeros = [iszerofunc(x) for x in M]
        if False in zeros:
            return 1
    if M.rows == 2 and M.cols == 2:
        zeros = [iszerofunc(x) for x in M]
        if False not in zeros and None not in zeros:
            return 0
        d = M.det()
        if iszerofunc(d) and False in zeros:
            return 1
        if iszerofunc(d) is False:
            return 2
    mat, _ = _permute_complexity_right(M, iszerofunc=iszerofunc)
    _, pivots, _ = _row_reduce(mat, iszerofunc, simpfunc, normalize_last=True, normalize=False, zero_above=False)
    return len(pivots)

.sympy.matrices.repmatrix.RepMatrix.__getitem__

def __getitem__(self, key):
    return _getitem_RepMatrix(self, key)

.sympy.matrices.repmatrix._getitem_RepMatrix

def _getitem_RepMatrix(self, key):
    if isinstance(key, tuple):
        i, j = key
        try:
            return self._rep.getitem_sympy(index_(i), index_(j))
        except (TypeError, IndexError):
            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):
                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):
                    raise ValueError('index out of boundary')
                from sympy.matrices.expressions.matexpr import MatrixElement
                return MatrixElement(self, i, j)
            if isinstance(i, slice):
                i = range(self.rows)[i]
            elif is_sequence(i):
                pass
            else:
                i = [i]
            if isinstance(j, slice):
                j = range(self.cols)[j]
            elif is_sequence(j):
                pass
            else:
                j = [j]
            return self.extract(i, j)
    else:
        rows, cols = self.shape
        if not rows * cols:
            return [][key]
        rep = self._rep.rep
        domain = rep.domain
        is_slice = isinstance(key, slice)
        if is_slice:
            values = [rep.getitem(*divmod(n, cols)) for n in range(rows * cols)[key]]
        else:
            values = [rep.getitem(*divmod(index_(key), cols))]
        if domain != EXRAW:
            to_sympy = domain.to_sympy
            values = [to_sympy(val) for val in values]
        if is_slice:
            return values
        else:
            return values[0]

.sympy.matrices.common.MatrixShaping.shape

def shape(self):
    return (self.rows, self.cols)

.sympy.polys.matrices.sdm.SDM.getitem

def getitem(self, i, j):
    try:
        return self[i][j]
    except KeyError:
        m, n = self.shape
        if -m <= i < m and -n <= j < n:
            try:
                return self[i % m][j % n]
            except KeyError:
                return self.domain.zero
        else:
            raise IndexError('index out of range')

.sympy.polys.domains.domain.Domain.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.evalf.EvalfMixin.evalf

def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
    from .numbers import Float, Number
    n = n if n is not None else 15
    if subs and is_sequence(subs):
        raise TypeError('subs must be given as a dictionary')
    if n == 1 and isinstance(self, Number):
        from .expr import _mag
        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
        m = _mag(rv)
        rv = rv.round(1 - m)
        return rv
    if not evalf_table:
        _create_evalf_table()
    prec = dps_to_prec(n)
    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}
    if subs is not None:
        options['subs'] = subs
    if quad is not None:
        options['quad'] = quad
    try:
        result = evalf(self, prec + 4, options)
    except NotImplementedError:
        if hasattr(self, 'subs') and subs is not None:
            v = self.subs(subs)._eval_evalf(prec)
        else:
            v = self._eval_evalf(prec)
        if v is None:
            return self
        elif not v.is_number:
            return v
        try:
            result = evalf(v, prec, options)
        except NotImplementedError:
            return v
    if result is S.ComplexInfinity:
        return result
    re, im, re_acc, im_acc = result
    if re is S.NaN or im is S.NaN:
        return S.NaN
    if re:
        p = max(min(prec, re_acc), 1)
        re = Float._new(re, p)
    else:
        re = S.Zero
    if im:
        p = max(min(prec, im_acc), 1)
        im = Float._new(im, p)
        return re + im * S.ImaginaryUnit
    else:
        return re

.sympy.core.evalf.evalf

def evalf(x: 'Expr', prec: int, options: OPT_DICT) -> TMP_RES:
    from sympy.functions.elementary.complexes import re as re_, im as im_
    try:
        rf = evalf_table[type(x)]
        r = rf(x, prec, options)
    except KeyError:
        if 'subs' in options:
            x = x.subs(evalf_subs(prec, options['subs']))
        xe = x._eval_evalf(prec)
        if xe is None:
            raise NotImplementedError
        as_real_imag = getattr(xe, 'as_real_imag', None)
        if as_real_imag is None:
            raise NotImplementedError
        re, im = as_real_imag()
        if re.has(re_) or im.has(im_):
            raise NotImplementedError
        if re == 0:
            re = None
            reprec = None
        elif re.is_number:
            re = re._to_mpmath(prec, allow_ints=False)._mpf_
            reprec = prec
        else:
            raise NotImplementedError
        if im == 0:
            im = None
            imprec = None
        elif im.is_number:
            im = im._to_mpmath(prec, allow_ints=False)._mpf_
            imprec = prec
        else:
            raise NotImplementedError
        r = (re, im, reprec, imprec)
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.numbers.Zero.__abs__

def __abs__():
    return S.Zero

.sympy.core.numbers.Float.__new__

def __new__(cls, num, dps=None, precision=None):
    if dps is not None and precision is not None:
        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')
    if isinstance(num, str):
        num = num.replace(' ', '').lower()
        if num.startswith('.') and len(num) > 1:
            num = '0' + num
        elif num.startswith('-.') and len(num) > 2:
            num = '-0.' + num[2:]
        elif num in ('inf', '+inf'):
            return S.Infinity
        elif num == '-inf':
            return S.NegativeInfinity
    elif isinstance(num, float) and num == 0:
        num = '0'
    elif isinstance(num, float) and num == float('inf'):
        return S.Infinity
    elif isinstance(num, float) and num == float('-inf'):
        return S.NegativeInfinity
    elif isinstance(num, float) and math.isnan(num):
        return S.NaN
    elif isinstance(num, (SYMPY_INTS, Integer)):
        num = str(num)
    elif num is S.Infinity:
        return num
    elif num is S.NegativeInfinity:
        return num
    elif num is S.NaN:
        return num
    elif _is_numpy_instance(num):
        num = _convert_numpy_types(num)
    elif isinstance(num, mpmath.mpf):
        if precision is None:
            if dps is None:
                precision = num.context.prec
        num = num._mpf_
    if dps is None and precision is None:
        dps = 15
        if isinstance(num, Float):
            return num
        if isinstance(num, str) and _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                dps = max(15, dps)
                precision = dps_to_prec(dps)
    elif precision == '' and dps is None or (precision is None and dps == ''):
        if not isinstance(num, str):
            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')
        ok = None
        if _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                    precision = dps_to_prec(dps)
                ok = True
        if ok is None:
            raise ValueError('string-float not recognized: %s' % num)
    if precision is None or precision == '':
        precision = dps_to_prec(dps)
    precision = int(precision)
    if isinstance(num, float):
        _mpf_ = mlib.from_float(num, precision, rnd)
    elif isinstance(num, str):
        _mpf_ = mlib.from_str(num, precision, rnd)
    elif isinstance(num, decimal.Decimal):
        if num.is_finite():
            _mpf_ = mlib.from_str(str(num), precision, rnd)
        elif num.is_nan():
            return S.NaN
        elif num.is_infinite():
            if num > 0:
                return S.Infinity
            return S.NegativeInfinity
        else:
            raise ValueError('unexpected decimal value %s' % str(num))
    elif isinstance(num, tuple) and len(num) in (3, 4):
        if isinstance(num[1], str):
            num = list(num)
            if num[1].endswith('L'):
                num[1] = num[1][:-1]
            if num[1].startswith('0x'):
                num[1] = num[1][2:]
            num[1] = MPZ(num[1], 16)
            _mpf_ = tuple(num)
        elif len(num) == 4:
            return Float._new(num, precision)
        else:
            if not all((num[0] in (0, 1), num[1] >= 0, all((type(i) in (int, int) for i in num)))):
                raise ValueError('malformed mpf: %s' % (num,))
            return Float._new((num[0], num[1], num[2], bitcount(num[1])), precision)
    else:
        try:
            _mpf_ = num._as_mpf_val(precision)
        except (NotImplementedError, AttributeError):
            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
    return cls._new(_mpf_, precision, zero=False)

.sympy.core.numbers.Float._new

def _new(cls, _mpf_, _prec, zero=True):
    if zero and _mpf_ == fzero:
        return S.Zero
    elif _mpf_ == _mpf_nan:
        return S.NaN
    elif _mpf_ == _mpf_inf:
        return S.Infinity
    elif _mpf_ == _mpf_ninf:
        return S.NegativeInfinity
    obj = Expr.__new__(cls)
    obj._mpf_ = mpf_norm(_mpf_, _prec)
    obj._prec = _prec
    return obj

.sympy.core.numbers.mpf_norm

def mpf_norm(mpf, prec):
    sign, man, expt, bc = mpf
    if not man:
        if not bc:
            return fzero
        else:
            return mpf
    from mpmath.libmp.backend import MPZ
    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
    return rv

.sympy.core.numbers.Float.__gt__

def __gt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__lt__(self)
    rv = self._Frel(other, mlib.mpf_gt)
    if rv is None:
        return Expr.__gt__(self, other)
    return rv

.sympy.core.numbers.Float._Frel

def _Frel(self, other, op):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Rational:
        '\n        >>> f = Float(.1,2)\n        >>> i = 1234567890\n        >>> (f*i)._mpf_\n        (0, 471, 18, 9)\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\n        (0, 505555550955, -12, 39)\n        '
        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
        ompf = mlib.from_int(other.p)
        return _sympify(bool(op(smpf, ompf)))
    elif other.is_Float:
        return _sympify(bool(op(self._mpf_, other._mpf_)))
    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):
        other = other.evalf(prec_to_dps(self._prec))
        if other._prec > 1:
            if other.is_Number:
                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))

.sympy.core.numbers.Float.__abs__

def __abs__(self):
    return Float._new(mlib.mpf_abs(self._mpf_), self._prec)

.sympy.core.numbers.Float.__lt__

def __lt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__gt__(self)
    rv = self._Frel(other, mlib.mpf_lt)
    if rv is None:
        return Expr.__lt__(self, other)
    return rv

.sympy.logic.boolalg.BooleanTrue.__eq__

def __eq__(self, other):
    if other is True:
        return True
    if other is False:
        return False
    return super().__eq__(other)

.sympy.logic.boolalg.BooleanFalse.__eq__

def __eq__(self, other):
    if other is True:
        return False
    if other is False:
        return True
    return super().__eq__(other)

.sympy.matrices.matrices.MatrixDeterminant.det

def det(self, method='bareiss', iszerofunc=None):
    return _det(self, method=method, iszerofunc=iszerofunc)

.sympy.matrices.determinant._det

def _det(M, method='bareiss', iszerofunc=None):
    method = method.lower()
    if method == 'bareis':
        method = 'bareiss'
    elif method == 'det_lu':
        method = 'lu'
    if method not in ('bareiss', 'berkowitz', 'lu', 'domain-ge'):
        raise ValueError("Determinant method '%s' unrecognized" % method)
    if iszerofunc is None:
        if method == 'bareiss':
            iszerofunc = _is_zero_after_expand_mul
        elif method == 'lu':
            iszerofunc = _iszero
    elif not isinstance(iszerofunc, FunctionType):
        raise ValueError("Zero testing method '%s' unrecognized" % iszerofunc)
    n = M.rows
    if n == M.cols:
        if n == 0:
            return M.one
        elif n == 1:
            return M[0, 0]
        elif n == 2:
            m = M[0, 0] * M[1, 1] - M[0, 1] * M[1, 0]
            return _get_intermediate_simp(_dotprodsimp)(m)
        elif n == 3:
            m = M[0, 0] * M[1, 1] * M[2, 2] + M[0, 1] * M[1, 2] * M[2, 0] + M[0, 2] * M[1, 0] * M[2, 1] - M[0, 2] * M[1, 1] * M[2, 0] - M[0, 0] * M[1, 2] * M[2, 1] - M[0, 1] * M[1, 0] * M[2, 2]
            return _get_intermediate_simp(_dotprodsimp)(m)
    dets = []
    for b in M.strongly_connected_components():
        if method == 'domain-ge':
            det = _det_DOM(M[b, b])
        elif method == 'bareiss':
            det = M[b, b]._eval_det_bareiss(iszerofunc=iszerofunc)
        elif method == 'berkowitz':
            det = M[b, b]._eval_det_berkowitz()
        elif method == 'lu':
            det = M[b, b]._eval_det_lu(iszerofunc=iszerofunc)
        dets.append(det)
    return Mul(*dets)

.sympy.polys.matrices.domainmatrix.DomainMatrix.getitem_sympy

def getitem_sympy(self, i, j):
    return self.domain.to_sympy(self.rep.getitem(i, j))

.sympy.matrices.utilities._get_intermediate_simp

def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x, onfunc=_dotprodsimp, dotprodsimp=None):
    if dotprodsimp is False or _dotprodsimp_state.state is False:
        return offfunc
    if dotprodsimp is True or _dotprodsimp_state.state is True:
        return onfunc
    return deffunc

.sympy.matrices.utilities._dotprodsimp

def _dotprodsimp(expr, withsimp=False):
    from sympy.simplify.simplify import dotprodsimp as dps
    return dps(expr, withsimp=withsimp)

.sympy.simplify.simplify.dotprodsimp

def dotprodsimp(expr, withsimp=False):

    def count_ops_alg(expr):
        ops = 0
        args = [expr]
        ratfunc = False
        while args:
            a = args.pop()
            if not isinstance(a, Basic):
                continue
            if a.is_Rational:
                if a is not S.One:
                    ops += bool(a.p < 0) + bool(a.q != 1)
            elif a.is_Mul:
                if a.could_extract_minus_sign():
                    ops += 1
                    if a.args[0] is S.NegativeOne:
                        a = a.as_two_terms()[1]
                    else:
                        a = -a
                n, d = fraction(a)
                if n.is_Integer:
                    ops += 1 + bool(n < 0)
                    args.append(d)
                elif d is not S.One:
                    if not d.is_Integer:
                        args.append(d)
                        ratfunc = True
                    ops += 1
                    args.append(n)
                else:
                    ops += len(a.args) - 1
                    args.extend(a.args)
            elif a.is_Add:
                laargs = len(a.args)
                negs = 0
                for ai in a.args:
                    if ai.could_extract_minus_sign():
                        negs += 1
                        ai = -ai
                    args.append(ai)
                ops += laargs - (negs != laargs)
            elif a.is_Pow:
                ops += 1
                args.append(a.base)
                if not ratfunc:
                    ratfunc = a.exp.is_negative is not False
        return (ops, ratfunc)

    def nonalg_subs_dummies(expr, dummies):
        if not expr.args:
            return expr
        if expr.is_Add or expr.is_Mul or expr.is_Pow:
            args = None
            for i, a in enumerate(expr.args):
                c = nonalg_subs_dummies(a, dummies)
                if c is a:
                    continue
                if args is None:
                    args = list(expr.args)
                args[i] = c
            if args is None:
                return expr
            return expr.func(*args)
        return dummies.setdefault(expr, Dummy())
    simplified = False
    if isinstance(expr, Basic) and (expr.is_Add or expr.is_Mul or expr.is_Pow):
        expr2 = expr.expand(deep=True, modulus=None, power_base=False, power_exp=False, mul=True, log=False, multinomial=True, basic=False)
        if expr2 != expr:
            expr = expr2
            simplified = True
        exprops, ratfunc = count_ops_alg(expr)
        if exprops >= 6:
            if ratfunc:
                dummies = {}
                expr2 = nonalg_subs_dummies(expr, dummies)
                if expr2 is expr or count_ops_alg(expr2)[0] >= 6:
                    expr3 = cancel(expr2)
                    if expr3 != expr2:
                        expr = expr3.subs([(d, e) for e, d in dummies.items()])
                        simplified = True
        elif exprops == 5 and expr.is_Add and expr.args[0].is_Mul and expr.args[1].is_Mul and expr.args[0].args[-1].is_Pow and expr.args[1].args[-1].is_Pow and (expr.args[0].args[-1].exp is S.NegativeOne) and (expr.args[1].args[-1].exp is S.NegativeOne):
            expr2 = together(expr)
            expr2ops = count_ops_alg(expr2)[0]
            if expr2ops < exprops:
                expr = expr2
                simplified = True
        else:
            simplified = True
    return (expr, simplified) if withsimp else expr

.sympy.matrices.reductions._permute_complexity_right

def _permute_complexity_right(M, iszerofunc):

    def complexity(i):
        return sum((1 if iszerofunc(e) is None else 0 for e in M[:, i]))
    complex = [(complexity(i), i) for i in range(M.cols)]
    perm = [j for i, j in sorted(complex)]
    return (M.permute(perm, orientation='cols'), perm)

.sympy.matrices.reductions.complexity

def complexity(i):
    return sum((1 if iszerofunc(e) is None else 0 for e in M[:, i]))

.sympy.matrices.common.MatrixShaping.extract

def extract(self, rowsList, colsList):
    if not is_sequence(rowsList) or not is_sequence(colsList):
        raise TypeError('rowsList and colsList must be iterable')
    if rowsList and all((isinstance(i, bool) for i in rowsList)):
        rowsList = [index for index, item in enumerate(rowsList) if item]
    if colsList and all((isinstance(i, bool) for i in colsList)):
        colsList = [index for index, item in enumerate(colsList) if item]
    rowsList = [a2idx(k, self.rows) for k in rowsList]
    colsList = [a2idx(k, self.cols) for k in colsList]
    return self._eval_extract(rowsList, colsList)

.sympy.matrices.common.a2idx

def a2idx(j, n=None):
    if not isinstance(j, int):
        jindex = getattr(j, '__index__', None)
        if jindex is not None:
            j = jindex()
        else:
            raise IndexError('Invalid index a[%r]' % (j,))
    if n is not None:
        if j < 0:
            j += n
        if not (j >= 0 and j < n):
            raise IndexError('Index out of range: a[%s]' % (j,))
    return int(j)

.sympy.matrices.repmatrix.RepMatrix._eval_extract

def _eval_extract(self, rowsList, colsList):
    return self._fromrep(self._rep.extract(rowsList, colsList))

.sympy.polys.matrices.domainmatrix.DomainMatrix.extract

def extract(self, rowslist, colslist):
    return self.from_rep(self.rep.extract(rowslist, colslist))

.sympy.polys.matrices.sdm.SDM.extract

def extract(self, rows, cols):
    if not (self and rows and cols):
        return self.zeros((len(rows), len(cols)), self.domain)
    m, n = self.shape
    if not -m <= min(rows) <= max(rows) < m:
        raise IndexError('Row index out of range')
    if not -n <= min(cols) <= max(cols) < n:
        raise IndexError('Column index out of range')
    rowmap = defaultdict(list)
    colmap = defaultdict(list)
    for i2, i1 in enumerate(rows):
        rowmap[i1 % m].append(i2)
    for j2, j1 in enumerate(cols):
        colmap[j1 % n].append(j2)
    rowset = set(rowmap)
    colset = set(colmap)
    sdm1 = self
    sdm2 = {}
    for i1 in rowset & set(sdm1):
        row1 = sdm1[i1]
        row2 = {}
        for j1 in colset & set(row1):
            row1_j1 = row1[j1]
            for j2 in colmap[j1]:
                row2[j2] = row1_j1
        if row2:
            for i2 in rowmap[i1]:
                sdm2[i2] = row2.copy()
    return self.new(sdm2, (len(rows), len(cols)), self.domain)

.sympy.matrices.common.MatrixOperations.permute

def permute(self, perm, orientation='rows', direction='forward'):
    from sympy.combinatorics import Permutation
    if direction == 'forwards':
        direction = 'forward'
    if direction == 'backwards':
        direction = 'backward'
    if orientation == 'columns':
        orientation = 'cols'
    if direction not in ('forward', 'backward'):
        raise TypeError("direction='{}' is an invalid kwarg. Try 'forward' or 'backward'".format(direction))
    if orientation not in ('rows', 'cols'):
        raise TypeError("orientation='{}' is an invalid kwarg. Try 'rows' or 'cols'".format(orientation))
    if not isinstance(perm, (Permutation, Iterable)):
        raise ValueError('{} must be a list, a list of lists, or a SymPy permutation object.'.format(perm))
    max_index = self.rows if orientation == 'rows' else self.cols
    if not all((0 <= t <= max_index for t in flatten(list(perm)))):
        raise IndexError('`swap` indices out of range.')
    if perm and (not isinstance(perm, Permutation)) and isinstance(perm[0], Iterable):
        if direction == 'forward':
            perm = list(reversed(perm))
        perm = Permutation(perm, size=max_index + 1)
    else:
        perm = Permutation(perm, size=max_index + 1)
    if orientation == 'rows':
        return self._eval_permute_rows(perm)
    if orientation == 'cols':
        return self._eval_permute_cols(perm)

.sympy.utilities.iterables.flatten

def flatten(iterable, levels=None, cls=None):
    from sympy.tensor.array import NDimArray
    if levels is not None:
        if not levels:
            return iterable
        elif levels > 0:
            levels -= 1
        else:
            raise ValueError('expected non-negative number of levels, got %s' % levels)
    if cls is None:
        reducible = lambda x: is_sequence(x, set)
    else:
        reducible = lambda x: isinstance(x, cls)
    result = []
    for el in iterable:
        if reducible(el):
            if hasattr(el, 'args') and (not isinstance(el, NDimArray)):
                el = el.args
            result.extend(flatten(el, levels=levels, cls=cls))
        else:
            result.append(el)
    return result

.sympy.combinatorics.permutations.Permutation.__new__

def __new__(cls, *args, size=None, **kwargs):
    if size is not None:
        size = int(size)
    ok = True
    if not args:
        return cls._af_new(list(range(size or 0)))
    elif len(args) > 1:
        return cls._af_new(Cycle(*args).list(size))
    if len(args) == 1:
        a = args[0]
        if isinstance(a, cls):
            if size is None or size == a.size:
                return a
            return cls(a.array_form, size=size)
        if isinstance(a, Cycle):
            return cls._af_new(a.list(size))
        if not is_sequence(a):
            if size is not None and a + 1 > size:
                raise ValueError('size is too small when max is %s' % a)
            return cls._af_new(list(range(a + 1)))
        if has_variety((is_sequence(ai) for ai in a)):
            ok = False
    else:
        ok = False
    if not ok:
        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')
    args = list(args[0])
    is_cycle = args and is_sequence(args[0])
    if is_cycle:
        args = [[int(i) for i in c] for c in args]
    else:
        args = [int(i) for i in args]
    temp = flatten(args)
    if has_dups(temp) and (not is_cycle):
        raise ValueError('there were repeated elements.')
    temp = set(temp)
    if not is_cycle:
        if temp != set(range(len(temp))):
            raise ValueError('Integers 0 through %s must be present.' % max(temp))
        if size is not None and temp and (max(temp) + 1 > size):
            raise ValueError('max element should not exceed %s' % (size - 1))
    if is_cycle:
        c = Cycle()
        for ci in args:
            c = c(*ci)
        aform = c.list()
    else:
        aform = list(args)
    if size and size > len(aform):
        aform.extend(list(range(len(aform), size)))
    return cls._af_new(aform)

.sympy.utilities.iterables.has_variety

def has_variety(seq):
    for i, s in enumerate(seq):
        if i == 0:
            sentinel = s
        elif s != sentinel:
            return True
    return False

.sympy.utilities.iterables.has_dups

def has_dups(seq):
    from sympy.core.containers import Dict
    from sympy.sets.sets import Set
    if isinstance(seq, (dict, set, Dict, Set)):
        return False
    unique = set()
    try:
        return any((True for s in seq if s in unique or unique.add(s)))
    except TypeError:
        return len(seq) != len(list(uniq(seq)))

.sympy.combinatorics.permutations.Permutation._af_new

def _af_new(cls, perm):
    p = super().__new__(cls)
    p._array_form = perm
    p._size = len(perm)
    return p

.sympy.matrices.common.MatrixOperations._eval_permute_cols

def _eval_permute_cols(self, perm):
    mapping = list(perm)

    def entry(i, j):
        return self[i, mapping[j]]
    return self._new(self.rows, self.cols, entry)

.sympy.combinatorics.permutations.Permutation.__iter__

def __iter__(self):
    yield from self.array_form

.sympy.combinatorics.permutations.Permutation.array_form

def array_form(self):
    return self._array_form[:]

.sympy.matrices.common.MatrixOperations.entry

def entry(i, j):
    return self[i, j] if i + k >= j else self.zero

.sympy.core.numbers.Integer.__index__

def __index__(self):
    return self.p

.sympy.matrices.reductions._row_reduce

def _row_reduce(M, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):
    mat, pivot_cols, swaps = _row_reduce_list(list(M), M.rows, M.cols, M.one, iszerofunc, simpfunc, normalize_last=normalize_last, normalize=normalize, zero_above=zero_above)
    return (M._new(M.rows, M.cols, mat), pivot_cols, swaps)

.sympy.matrices.matrices.MatrixBase.__len__

def __len__(self):
    return self.rows * self.cols

.sympy.matrices.reductions._row_reduce_list

def _row_reduce_list(mat, rows, cols, one, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):

    def get_col(i):
        return mat[i::cols]

    def row_swap(i, j):
        mat[i * cols:(i + 1) * cols], mat[j * cols:(j + 1) * cols] = (mat[j * cols:(j + 1) * cols], mat[i * cols:(i + 1) * cols])

    def cross_cancel(a, i, b, j):
        q = (j - i) * cols
        for p in range(i * cols, (i + 1) * cols):
            mat[p] = isimp(a * mat[p] - b * mat[p + q])
    isimp = _get_intermediate_simp(_dotprodsimp)
    piv_row, piv_col = (0, 0)
    pivot_cols = []
    swaps = []
    while piv_col < cols and piv_row < rows:
        pivot_offset, pivot_val, assumed_nonzero, newly_determined = _find_reasonable_pivot(get_col(piv_col)[piv_row:], iszerofunc, simpfunc)
        for offset, val in newly_determined:
            offset += piv_row
            mat[offset * cols + piv_col] = val
        if pivot_offset is None:
            piv_col += 1
            continue
        pivot_cols.append(piv_col)
        if pivot_offset != 0:
            row_swap(piv_row, pivot_offset + piv_row)
            swaps.append((piv_row, pivot_offset + piv_row))
        if normalize_last is False:
            i, j = (piv_row, piv_col)
            mat[i * cols + j] = one
            for p in range(i * cols + j + 1, (i + 1) * cols):
                mat[p] = isimp(mat[p] / pivot_val)
            pivot_val = one
        for row in range(rows):
            if row == piv_row:
                continue
            if zero_above is False and row < piv_row:
                continue
            val = mat[row * cols + piv_col]
            if iszerofunc(val):
                continue
            cross_cancel(pivot_val, row, val, piv_row)
        piv_row += 1
    if normalize_last is True and normalize is True:
        for piv_i, piv_j in enumerate(pivot_cols):
            pivot_val = mat[piv_i * cols + piv_j]
            mat[piv_i * cols + piv_j] = one
            for p in range(piv_i * cols + piv_j + 1, (piv_i + 1) * cols):
                mat[p] = isimp(mat[p] / pivot_val)
    return (mat, tuple(pivot_cols), tuple(swaps))

.sympy.matrices.reductions.get_col

def get_col(i):
    return mat[i::cols]

.sympy.matrices.determinant._find_reasonable_pivot

def _find_reasonable_pivot(col, iszerofunc=_iszero, simpfunc=_simplify):
    newly_determined = []
    col = list(col)
    if all((isinstance(x, (Float, Integer)) for x in col)) and any((isinstance(x, Float) for x in col)):
        col_abs = [abs(x) for x in col]
        max_value = max(col_abs)
        if iszerofunc(max_value):
            if max_value != 0:
                newly_determined = [(i, 0) for i, x in enumerate(col) if x != 0]
            return (None, None, False, newly_determined)
        index = col_abs.index(max_value)
        return (index, col[index], False, newly_determined)
    possible_zeros = []
    for i, x in enumerate(col):
        is_zero = iszerofunc(x)
        if is_zero == False:
            return (i, x, False, newly_determined)
        possible_zeros.append(is_zero)
    if all(possible_zeros):
        return (None, None, False, newly_determined)
    for i, x in enumerate(col):
        if possible_zeros[i] is not None:
            continue
        simped = simpfunc(x)
        is_zero = iszerofunc(simped)
        if is_zero in (True, False):
            newly_determined.append((i, simped))
        if is_zero == False:
            return (i, simped, False, newly_determined)
        possible_zeros[i] = is_zero
    if all(possible_zeros):
        return (None, None, False, newly_determined)
    for i, x in enumerate(col):
        if possible_zeros[i] is not None:
            continue
        if x.equals(S.Zero):
            possible_zeros[i] = True
            newly_determined.append((i, S.Zero))
    if all(possible_zeros):
        return (None, None, False, newly_determined)
    i = possible_zeros.index(None)
    return (i, col[i], True, newly_determined)

.sympy.matrices.reductions.row_swap

def row_swap(i, j):
    mat[i * cols:(i + 1) * cols], mat[j * cols:(j + 1) * cols] = (mat[j * cols:(j + 1) * cols], mat[i * cols:(i + 1) * cols])

.sympy.core.numbers.Zero.__neg__

def __neg__():
    return S.Zero

.sympy.matrices.reductions.cross_cancel

def cross_cancel(a, i, b, j):
    q = (j - i) * cols
    for p in range(i * cols, (i + 1) * cols):
        mat[p] = isimp(a * mat[p] - b * mat[p + q])

.sympy.geometry.polygon.Triangle.__new__

def __new__(cls, *args, **kwargs):
    if len(args) != 3:
        if 'sss' in kwargs:
            return _sss(*[simplify(a) for a in kwargs['sss']])
        if 'asa' in kwargs:
            return _asa(*[simplify(a) for a in kwargs['asa']])
        if 'sas' in kwargs:
            return _sas(*[simplify(a) for a in kwargs['sas']])
        msg = 'Triangle instantiates with three points or a valid keyword.'
        raise GeometryError(msg)
    vertices = [Point(a, dim=2, **kwargs) for a in args]
    nodup = []
    for p in vertices:
        if nodup and p == nodup[-1]:
            continue
        nodup.append(p)
    if len(nodup) > 1 and nodup[-1] == nodup[0]:
        nodup.pop()
    i = -3
    while i < len(nodup) - 3 and len(nodup) > 2:
        a, b, c = sorted([nodup[i], nodup[i + 1], nodup[i + 2]], key=default_sort_key)
        if Point.is_collinear(a, b, c):
            nodup[i] = a
            nodup[i + 1] = None
            nodup.pop(i + 1)
        i += 1
    vertices = list(filter(lambda x: x is not None, nodup))
    if len(vertices) == 3:
        return GeometryEntity.__new__(cls, *vertices, **kwargs)
    elif len(vertices) == 2:
        return Segment(*vertices, **kwargs)
    else:
        return Point(*vertices, **kwargs)

.sympy.core.sorting.default_sort_key

def default_sort_key(item, order=None):
    from .basic import Basic
    from .singleton import S
    if isinstance(item, Basic):
        return item.sort_key(order=order)
    if iterable(item, exclude=str):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            args = list(item)
            unordered = False
        args = [default_sort_key(arg, order=order) for arg in args]
        if unordered:
            args = sorted(args)
        cls_index, args = (10, (len(args), tuple(args)))
    else:
        if not isinstance(item, str):
            try:
                item = sympify(item, strict=True)
            except SympifyError:
                pass
            else:
                if isinstance(item, Basic):
                    return default_sort_key(item)
        cls_index, args = (0, (1, (str(item),)))
    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)

.sympy.core.basic.Basic.sort_key

def sort_key(self, order=None):

    def inner_key(arg):
        if isinstance(arg, Basic):
            return arg.sort_key(order)
        else:
            return arg
    args = self._sorted_args
    args = (len(args), tuple([inner_key(arg) for arg in args]))
    return (self.class_key(), args, S.One.sort_key(), S.One)

.sympy.core.basic.Basic._sorted_args

def _sorted_args(self):
    return self.args

.sympy.core.basic.Basic.inner_key

def inner_key(arg):
    if isinstance(arg, Basic):
        return arg.sort_key(order)
    else:
        return arg

.sympy.core.numbers.Number.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (0, ()), (), self)

.sympy.core.numbers.Number.class_key

def class_key(cls):
    return (1, 0, 'Number')

.sympy.core.basic.Basic.class_key

def class_key(cls):
    return (5, 0, cls.__name__)

.sympy.geometry.polygon.Polygon.vertices

def vertices(self):
    return list(self.args)

.sympy.polys.domains.rationalfield.RationalField.from_sympy

def from_sympy(self, a):
    if a.is_Rational:
        return MPQ(a.p, a.q)
    elif a.is_Float:
        from sympy.polys.domains import RR
        return MPQ(*map(int, RR.to_rational(a)))
    else:
        raise CoercionFailed('expected `Rational` object, got %s' % a)

.sympy.external.pythonmpq.PythonMPQ.__new__

def __new__(cls, numerator, denominator=None):
    if denominator is not None:
        if isinstance(numerator, int) and isinstance(denominator, int):
            divisor = gcd(numerator, denominator)
            numerator //= divisor
            denominator //= divisor
            return cls._new_check(numerator, denominator)
    else:
        if isinstance(numerator, int):
            return cls._new(numerator, 1)
        elif isinstance(numerator, PythonMPQ):
            return cls._new(numerator.numerator, numerator.denominator)
        if isinstance(numerator, (Decimal, float, str)):
            numerator = Fraction(numerator)
        if isinstance(numerator, Fraction):
            return cls._new(numerator.numerator, numerator.denominator)
    raise TypeError('PythonMPQ() requires numeric or string argument')

.sympy.external.pythonmpq.PythonMPQ._new_check

def _new_check(cls, numerator, denominator):
    if not denominator:
        raise ZeroDivisionError(f'Zero divisor {numerator}/{denominator}')
    elif denominator < 0:
        numerator = -numerator
        denominator = -denominator
    return cls._new(numerator, denominator)

.sympy.external.pythonmpq.PythonMPQ._new

def _new(cls, numerator, denominator):
    obj = super().__new__(cls)
    obj.numerator = numerator
    obj.denominator = denominator
    return obj

.sympy.polys.domains.field.Field.gcd

def gcd(self, a, b):
    try:
        ring = self.get_ring()
    except DomainError:
        return self.one
    p = ring.gcd(self.numer(a), self.numer(b))
    q = ring.lcm(self.denom(a), self.denom(b))
    return self.convert(p, ring) / q

.sympy.polys.domains.rationalfield.RationalField.get_ring

def get_ring(self):
    from sympy.polys.domains import ZZ
    return ZZ

.sympy.polys.domains.rationalfield.RationalField.numer

def numer(self, a):
    return a.numerator

.sympy.polys.domains.rationalfield.RationalField.denom

def denom(self, a):
    return a.denominator

.sympy.polys.domains.integerring.IntegerRing.lcm

def lcm(self, a, b):
    return lcm(a, b)

.sympy.core.numbers.ilcm

def ilcm(*args):
    if len(args) < 2:
        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))
    if 0 in args:
        return 0
    a = args[0]
    for b in args[1:]:
        a = a // igcd(a, b) * b
    return a

.sympy.polys.domains.domain.Domain.convert

def convert(self, element, base=None):
    if base is not None:
        if _not_a_coeff(element):
            raise CoercionFailed('%s is not in any domain' % element)
        return self.convert_from(element, base)
    if self.of_type(element):
        return element
    if _not_a_coeff(element):
        raise CoercionFailed('%s is not in any domain' % element)
    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField
    if ZZ.of_type(element):
        return self.convert_from(element, ZZ)
    if isinstance(element, int):
        return self.convert_from(ZZ(element), ZZ)
    if HAS_GMPY:
        integers = ZZ
        if isinstance(element, integers.tp):
            return self.convert_from(element, integers)
        rationals = QQ
        if isinstance(element, rationals.tp):
            return self.convert_from(element, rationals)
    if isinstance(element, float):
        parent = RealField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, complex):
        parent = ComplexField(tol=False)
        return self.convert_from(parent(element), parent)
    if isinstance(element, DomainElement):
        return self.convert_from(element, element.parent())
    if self.is_Numerical and getattr(element, 'is_ground', False):
        return self.convert(element.LC())
    if isinstance(element, Basic):
        try:
            return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    elif not is_sequence(element):
        try:
            element = sympify(element, strict=True)
            if isinstance(element, Basic):
                return self.from_sympy(element)
        except (TypeError, ValueError):
            pass
    raise CoercionFailed('Cannot convert %s of type %s to %s' % (element, type(element), self))

.sympy.polys.polyutils._not_a_coeff

def _not_a_coeff(expr):
    if type(expr) in illegal_types or expr in finf:
        return True
    if isinstance(expr, float) and float(expr) != expr:
        return True
    return

.sympy.polys.domains.rationalfield.RationalField.from_ZZ

def from_ZZ(K1, a, K0):
    return MPQ(a)

.sympy.external.pythonmpq.PythonMPQ.__truediv__

def __truediv__(self, other):
    if isinstance(other, PythonMPQ):
        ap, aq = (self.numerator, self.denominator)
        bp, bq = (other.numerator, other.denominator)
        x1 = gcd(ap, bp)
        x2 = gcd(bq, aq)
        p, q = (ap // x1 * (bq // x2), aq // x2 * (bp // x1))
    elif isinstance(other, int):
        x = gcd(other, self.numerator)
        p = self.numerator // x
        q = self.denominator * (other // x)
    else:
        return NotImplemented
    return self._new_check(p, q)

.sympy.external.pythonmpq.PythonMPQ.__eq__

def __eq__(self, other):
    if isinstance(other, PythonMPQ):
        return self.numerator == other.numerator and self.denominator == other.denominator
    elif isinstance(other, self._compatible_types):
        return self.__eq__(PythonMPQ(other))
    else:
        return NotImplemented

.sympy.polys.domains.rationalfield.RationalField.to_sympy

def to_sympy(self, a):
    return SymPyRational(int(a.numerator), int(a.denominator))

.sympy.integrals.intpoly.decompose

def decompose(expr, separate=False):
    poly_dict = {}
    if isinstance(expr, Expr) and (not expr.is_number):
        if expr.is_Symbol:
            poly_dict[1] = expr
        elif expr.is_Add:
            symbols = expr.atoms(Symbol)
            degrees = [(sum(degree_list(monom, *symbols)), monom) for monom in expr.args]
            if separate:
                return {monom[1] for monom in degrees}
            else:
                for monom in degrees:
                    degree, term = monom
                    if poly_dict.get(degree):
                        poly_dict[degree] += term
                    else:
                        poly_dict[degree] = term
        elif expr.is_Pow:
            _, degree = expr.args
            poly_dict[degree] = expr
        else:
            degree = 0
            for term in expr.args:
                term_type = len(term.args)
                if term_type == 0 and term.is_Symbol:
                    degree += 1
                elif term_type == 2:
                    degree += term.args[1]
            poly_dict[degree] = expr
    else:
        poly_dict[0] = expr
    if separate:
        return set(poly_dict.values())
    return poly_dict

.sympy.polys.polytools.Poly.__new__

def __new__(cls, rep, *gens, **args):
    opt = options.build_options(gens, args)
    if 'order' in opt:
        raise NotImplementedError("'order' keyword is not implemented yet")
    if isinstance(rep, (DMP, DMF, ANP, DomainElement)):
        return cls._from_domain_element(rep, opt)
    elif iterable(rep, exclude=str):
        if isinstance(rep, dict):
            return cls._from_dict(rep, opt)
        else:
            return cls._from_list(list(rep), opt)
    else:
        rep = sympify(rep)
        if rep.is_Poly:
            return cls._from_poly(rep, opt)
        else:
            return cls._from_expr(rep, opt)

.sympy.polys.polytools.Poly._from_expr

def _from_expr(cls, rep, opt):
    rep, opt = _dict_from_expr(rep, opt)
    return cls._from_dict(rep, opt)

.sympy.polys.polyutils._dict_from_expr

def _dict_from_expr(expr, opt):
    if expr.is_commutative is False:
        raise PolynomialError('non-commutative expressions are not supported')

    def _is_expandable_pow(expr):
        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add
    if opt.expand is not False:
        if not isinstance(expr, (Expr, Eq)):
            raise PolynomialError('expression must be of type Expr')
        expr = expr.expand()
        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):
            expr = expand_multinomial(expr)
        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):
            expr = expand_mul(expr)
    if opt.gens:
        rep, gens = _dict_from_expr_if_gens(expr, opt)
    else:
        rep, gens = _dict_from_expr_no_gens(expr, opt)
    return (rep, opt.clone({'gens': gens}))

.sympy.polys.polyoptions.Expand.default

def default(cls):
    return True

.sympy.core.expr.Expr.expand

def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):
    from sympy.simplify.radsimp import fraction
    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)
    expr = self
    if hints.pop('frac', False):
        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]
        return n / d
    elif hints.pop('denom', False):
        n, d = fraction(self)
        return n / d.expand(deep=deep, modulus=modulus, **hints)
    elif hints.pop('numer', False):
        n, d = fraction(self)
        return n.expand(deep=deep, modulus=modulus, **hints) / d

    def _expand_hint_key(hint):
        if hint == 'mul':
            return 'mulz'
        return hint
    for hint in sorted(hints.keys(), key=_expand_hint_key):
        use_hint = hints[hint]
        if use_hint:
            hint = '_eval_expand_' + hint
            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
    while True:
        was = expr
        if hints.get('multinomial', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)
        if hints.get('mul', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)
        if hints.get('log', False):
            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)
        if expr == was:
            break
    if modulus is not None:
        modulus = sympify(modulus)
        if not modulus.is_Integer or modulus <= 0:
            raise ValueError('modulus must be a positive integer, got %s' % modulus)
        terms = []
        for term in Add.make_args(expr):
            coeff, tail = term.as_coeff_Mul(rational=True)
            coeff %= modulus
            if coeff:
                terms.append(coeff * tail)
        expr = Add(*terms)
    return expr

.sympy.core.expr.Expr._expand_hint_key

def _expand_hint_key(hint):
    if hint == 'mul':
        return 'mulz'
    return hint

.sympy.core.expr.Expr._expand_hint

def _expand_hint(expr, hint, deep=True, **hints):
    hit = False
    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):
        sargs = []
        for arg in expr.args:
            arg, arghit = Expr._expand_hint(arg, hint, **hints)
            hit |= arghit
            sargs.append(arg)
        if hit:
            expr = expr.func(*sargs)
    if hasattr(expr, hint):
        newexpr = getattr(expr, hint)(**hints)
        if newexpr != expr:
            return (newexpr, True)
    return (expr, hit)

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    if self is other:
        return True
    if not isinstance(other, Basic):
        return self._do_eq_sympify(other)
    if not (self.is_Number and other.is_Number) and type(self) != type(other):
        return False
    a, b = (self._hashable_content(), other._hashable_content())
    if a != b:
        return False
    for a, b in zip(a, b):
        if not isinstance(a, Basic):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

.sympy.core.operations.AssocOp.make_args

def make_args(cls, expr):
    if isinstance(expr, cls):
        return expr.args
    else:
        return (sympify(expr),)

.sympy.polys.polyutils._is_expandable_pow

def _is_expandable_pow(expr):
    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add

.sympy.polys.polyoptions.Gens.default

def default(cls):
    return ()

.sympy.polys.polyutils._dict_from_expr_no_gens

def _dict_from_expr_no_gens(expr, opt):
    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)
    return (poly, gens)

.sympy.polys.polyutils._parallel_dict_from_expr_no_gens

def _parallel_dict_from_expr_no_gens(exprs, opt):
    if opt.domain is not None:

        def _is_coeff(factor):
            return factor in opt.domain
    elif opt.extension is True:

        def _is_coeff(factor):
            return factor.is_algebraic
    elif opt.greedy is not False:

        def _is_coeff(factor):
            return factor is S.ImaginaryUnit
    else:

        def _is_coeff(factor):
            return factor.is_number
    gens, reprs = (set(), [])
    for expr in exprs:
        terms = []
        if expr.is_Equality:
            expr = expr.lhs - expr.rhs
        for term in Add.make_args(expr):
            coeff, elements = ([], {})
            for factor in Mul.make_args(term):
                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):
                    coeff.append(factor)
                else:
                    if opt.series is False:
                        base, exp = decompose_power(factor)
                        if exp < 0:
                            exp, base = (-exp, Pow(base, -S.One))
                    else:
                        base, exp = decompose_power_rat(factor)
                    elements[base] = elements.setdefault(base, 0) + exp
                    gens.add(base)
            terms.append((coeff, elements))
        reprs.append(terms)
    gens = _sort_gens(gens, opt=opt)
    k, indices = (len(gens), {})
    for i, g in enumerate(gens):
        indices[g] = i
    polys = []
    for terms in reprs:
        poly = {}
        for coeff, term in terms:
            monom = [0] * k
            for base, exp in term.items():
                monom[indices[base]] = exp
            monom = tuple(monom)
            if monom in poly:
                poly[monom] += Mul(*coeff)
            else:
                poly[monom] = Mul(*coeff)
        polys.append(poly)
    return (polys, tuple(gens))

.sympy.core.basic.Basic._do_eq_sympify

def _do_eq_sympify(self, other):
    for superclass in type(other).__mro__:
        conv = _external_converter.get(superclass)
        if conv is not None:
            return self == conv(other)
    if hasattr(other, '_sympy_'):
        return self == other._sympy_()
    return NotImplemented

.sympy.polys.polyutils._is_coeff

def _is_coeff(factor):
    return factor.is_number

.sympy.polys.polyoptions.Series.default

def default(cls):
    return False

.sympy.core.exprtools.decompose_power

def decompose_power(expr: Expr) -> tTuple[Expr, int]:
    base, exp = expr.as_base_exp()
    if exp.is_Number:
        if exp.is_Rational:
            if not exp.is_Integer:
                base = Pow(base, Rational(1, exp.q))
            e = exp.p
        else:
            base, e = (expr, 1)
    else:
        exp, tail = exp.as_coeff_Mul(rational=True)
        if exp is S.NegativeOne:
            base, e = (Pow(base, tail), -1)
        elif exp is not S.One:
            tail = _keep_coeff(Rational(1, exp.q), tail)
            base, e = (Pow(base, tail), exp.p)
        else:
            base, e = (expr, 1)
    return (base, e)

.sympy.core.expr.Expr.as_base_exp

def as_base_exp(self) -> tTuple['Expr', 'Expr']:
    return (self, S.One)

.sympy.polys.polyutils._sort_gens

def _sort_gens(gens, **args):
    opt = build_options(args)
    gens_order, wrt = ({}, None)
    if opt is not None:
        gens_order, wrt = ({}, opt.wrt)
        for i, gen in enumerate(opt.sort):
            gens_order[gen] = i + 1

    def order_key(gen):
        gen = str(gen)
        if wrt is not None:
            try:
                return (-len(wrt) + wrt.index(gen), gen, 0)
            except ValueError:
                pass
        name, index = _re_gen.match(gen).groups()
        if index:
            index = int(index)
        else:
            index = 0
        try:
            return (gens_order[name], name, index)
        except KeyError:
            pass
        try:
            return (_gens_order[name], name, index)
        except KeyError:
            pass
        return (_max_order, name, index)
    try:
        gens = sorted(gens, key=order_key)
    except TypeError:
        pass
    return tuple(gens)

.sympy.polys.polyoptions.Sort.default

def default(cls):
    return []

.sympy.polys.polyutils.order_key

def order_key(gen):
    gen = str(gen)
    if wrt is not None:
        try:
            return (-len(wrt) + wrt.index(gen), gen, 0)
        except ValueError:
            pass
    name, index = _re_gen.match(gen).groups()
    if index:
        index = int(index)
    else:
        index = 0
    try:
        return (gens_order[name], name, index)
    except KeyError:
        pass
    try:
        return (_gens_order[name], name, index)
    except KeyError:
        pass
    return (_max_order, name, index)

.sympy.core._print_helpers.Printable.__str__

def __str__(self):
    from sympy.printing.str import sstr
    return sstr(self, order=None)

.sympy.printing.printer._PrintFunction.__call__

def __call__(self, *args, **kwargs):
    return self.__wrapped__(*args, **kwargs)

.sympy.printing.str.sstr

def sstr(expr, **settings):
    p = StrPrinter(settings)
    s = p.doprint(expr)
    return s

.sympy.printing.printer.Printer.__init__

def __init__(self, settings=None):
    self._str = str
    self._settings = self._get_initial_settings()
    self._context = dict()
    if settings is not None:
        self._settings.update(settings)
        if len(self._settings) > len(self._default_settings):
            for key in self._settings:
                if key not in self._default_settings:
                    raise TypeError("Unknown setting '%s'." % key)
    self._print_level = 0

.sympy.printing.printer.Printer._get_initial_settings

def _get_initial_settings(cls):
    settings = cls._default_settings.copy()
    for key, val in cls._global_settings.items():
        if key in cls._default_settings:
            settings[key] = val
    return settings

.sympy.printing.printer.Printer.doprint

def doprint(self, expr):
    return self._str(self._print(expr))

.sympy.printing.printer.Printer._print

def _print(self, expr, **kwargs):
    self._print_level += 1
    try:
        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):
            return getattr(expr, self.printmethod)(self, **kwargs)
        classes = type(expr).__mro__
        if AppliedUndef in classes:
            classes = classes[classes.index(AppliedUndef):]
        if UndefinedFunction in classes:
            classes = classes[classes.index(UndefinedFunction):]
        if Function in classes:
            i = classes.index(Function)
            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]
        for cls in classes:
            printmethodname = '_print_' + cls.__name__
            printmethod = getattr(self, printmethodname, None)
            if printmethod is not None:
                return printmethod(expr, **kwargs)
        return self.emptyPrinter(expr)
    finally:
        self._print_level -= 1

.sympy.printing.str.StrPrinter._print_Symbol

def _print_Symbol(self, expr):
    return expr.name

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, evaluate=None, _sympify=True):
    if _sympify:
        args = list(map(_sympify_, args))
    typ = cls._args_type
    if typ is not None:
        from .relational import Relational
        if any((isinstance(arg, Relational) for arg in args)):
            raise TypeError('Relational cannot be used in %s' % cls.__name__)
        for arg in args:
            if not isinstance(arg, typ):
                sympy_deprecation_warning(f'\n\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\nthe arguments has type {type(arg).__name__!r}).\n\nIf you really did intend to use a multiplication or addition operation with\nthis object, use the * or + operator instead.\n\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if not evaluate:
        obj = cls._from_args(args)
        obj = cls._exec_constructor_postprocessors(obj)
        return obj
    args = [a for a in args if a is not cls.identity]
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        from sympy.series.order import Order
        return Order(obj, *order_symbols)
    return obj

.sympy.polys.polyoptions.Options.clone

def clone(self, updates={}):
    obj = dict.__new__(self.__class__)
    for option, value in self.items():
        obj[option] = value
    for option, value in updates.items():
        obj[option] = value
    return obj

.sympy.polys.polytools.Poly._from_dict

def _from_dict(cls, rep, opt):
    gens = opt.gens
    if not gens:
        raise GeneratorsNeeded("Cannot initialize from 'dict' without generators")
    level = len(gens) - 1
    domain = opt.domain
    if domain is None:
        domain, rep = construct_domain(rep, opt=opt)
    else:
        for monom, coeff in rep.items():
            rep[monom] = domain.convert(coeff)
    return cls.new(DMP.from_dict(rep, level, domain), *gens)

.sympy.polys.polyclasses.DMP.from_dict

def from_dict(cls, rep, lev, dom):
    return cls(dmp_from_dict(rep, lev, dom), dom, lev)

.sympy.polys.densebasic.dmp_from_dict

def dmp_from_dict(f, u, K):
    if not u:
        return dup_from_dict(f, K)
    if not f:
        return dmp_zero(u)
    coeffs = {}
    for monom, coeff in f.items():
        head, tail = (monom[0], monom[1:])
        if head in coeffs:
            coeffs[head][tail] = coeff
        else:
            coeffs[head] = {tail: coeff}
    n, v, h = (max(coeffs.keys()), u - 1, [])
    for k in range(n, -1, -1):
        coeff = coeffs.get(k)
        if coeff is not None:
            h.append(dmp_from_dict(coeff, v, K))
        else:
            h.append(dmp_zero(v))
    return dmp_strip(h, u)

.sympy.polys.densebasic.dup_from_dict

def dup_from_dict(f, K):
    if not f:
        return []
    n, h = (max(f.keys()), [])
    if isinstance(n, int):
        for k in range(n, -1, -1):
            h.append(f.get(k, K.zero))
    else:
        n, = n
        for k in range(n, -1, -1):
            h.append(f.get((k,), K.zero))
    return dup_strip(h)

.sympy.polys.densebasic.dup_strip

def dup_strip(f):
    if not f or f[0]:
        return f
    i = 0
    for cf in f:
        if cf:
            break
        else:
            i += 1
    return f[i:]

.sympy.polys.polyclasses.DMP.__init__

def __init__(self, rep, dom, lev=None, ring=None):
    if lev is not None:
        if type(rep) is dict:
            rep = dmp_from_dict(rep, lev, dom)
        elif not isinstance(rep, list):
            rep = dmp_ground(dom.convert(rep), lev)
    else:
        rep, lev = dmp_validate(rep)
    self.rep = rep
    self.lev = lev
    self.dom = dom
    self.ring = ring

.sympy.polys.polytools.Poly.new

def new(cls, rep, *gens):
    if not isinstance(rep, DMP):
        raise PolynomialError('invalid polynomial representation: %s' % rep)
    elif rep.lev != len(gens) - 1:
        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))
    obj = Basic.__new__(cls)
    obj.rep = rep
    obj.gens = gens
    return obj

.sympy.polys.polytools.Poly.total_degree

def total_degree(f):
    if hasattr(f.rep, 'total_degree'):
        return f.rep.total_degree()
    else:
        raise OperationNotSupported(f, 'total_degree')

.sympy.polys.polyclasses.DMP.total_degree

def total_degree(f):
    return max((sum(m) for m in f.monoms()))

.sympy.polys.polyclasses.DMP.monoms

def monoms(f, order=None):
    return [m for m, _ in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]

.sympy.polys.densebasic.dmp_list_terms

def dmp_list_terms(f, u, K, order=None):

    def sort(terms, O):
        return sorted(terms, key=lambda term: O(term[0]), reverse=True)
    terms = _rec_list_terms(f, u, ())
    if not terms:
        return [((0,) * (u + 1), K.zero)]
    if order is None:
        return terms
    else:
        return sort(terms, monomial_key(order))

.sympy.polys.densebasic._rec_list_terms

def _rec_list_terms(g, v, monom):
    d, terms = (dmp_degree(g, v), [])
    if not v:
        for i, c in enumerate(g):
            if not c:
                continue
            terms.append((monom + (d - i,), c))
    else:
        w = v - 1
        for i, c in enumerate(g):
            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))
    return terms

.sympy.polys.densebasic.dmp_degree

def dmp_degree(f, u):
    if dmp_zero_p(f, u):
        return -oo
    else:
        return len(f) - 1

.sympy.polys.densebasic.dmp_zero_p

def dmp_zero_p(f, u):
    while u:
        if len(f) != 1:
            return False
        f = f[0]
        u -= 1
    return not f

.sympy.core.expr.Expr.is_number

def is_number(self):
    return all((obj.is_number for obj in self.args))

.sympy.core.mul.Mul._eval_expand_mul

def _eval_expand_mul(self, **hints):
    from sympy.simplify.radsimp import fraction
    expr = self
    n, d = fraction(expr)
    if d.is_Mul:
        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]
    expr = n / d
    if not expr.is_Mul:
        return expr
    plain, sums, rewrite = ([], [], False)
    for factor in expr.args:
        if factor.is_Add:
            sums.append(factor)
            rewrite = True
        elif factor.is_commutative:
            plain.append(factor)
        else:
            sums.append(Basic(factor))
    if not rewrite:
        return expr
    else:
        plain = self.func(*plain)
        if sums:
            deep = hints.get('deep', False)
            terms = self.func._expandsums(sums)
            args = []
            for term in terms:
                t = self.func(plain, term)
                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:
                    t = t._eval_expand_mul()
                args.append(t)
            return Add(*args)
        else:
            return plain

.sympy.simplify.radsimp.fraction

def fraction(expr, exact=False):
    expr = sympify(expr)
    numer, denom = ([], [])
    for term in Mul.make_args(expr):
        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):
            b, ex = term.as_base_exp()
            if ex.is_negative:
                if ex is S.NegativeOne:
                    denom.append(b)
                elif exact:
                    if ex.is_constant():
                        denom.append(Pow(b, -ex))
                    else:
                        numer.append(term)
                else:
                    denom.append(Pow(b, -ex))
            elif ex.is_positive:
                numer.append(term)
            elif not exact and ex.is_Mul:
                n, d = term.as_numer_denom()
                if n != 1:
                    numer.append(n)
                denom.append(d)
            else:
                numer.append(term)
        elif term.is_Rational and (not term.is_Integer):
            if term.p != 1:
                numer.append(term.p)
            denom.append(term.q)
        else:
            numer.append(term)
    return (Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact))

.sympy.functions.elementary.exponential.ExpMeta.__instancecheck__

def __instancecheck__(cls, instance):
    if exp in instance.__class__.__mro__:
        return True
    return isinstance(instance, Pow) and instance.base is S.Exp1

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.accumulationbounds import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
            seq = [a, b]
        assert a is not S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    ar = a * r
                    if ar is S.One:
                        arb = b
                    else:
                        arb = cls(a * r, b, evaluate=False)
                    rv = ([arb], [], None)
                elif global_parameters.distribute and b.is_commutative:
                    newb = Add(*[_keep_coeff(a, bi) for bi in b.args])
                    rv = ([newb], [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number or isinstance(coeff, AccumBounds):
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):
                    return ([S.NaN], [], None)
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len({b for b, e in new_c_powers}) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff in (S.Infinity, S.NegativeInfinity):

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_extended_positive:
                    continue
                if t.is_extended_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
    elif coeff.is_zero:
        if any((isinstance(c, MatrixExpr) for c in nc_part)):
            return ([coeff], nc_part, order_symbols)
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_parameters.distribute and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.numbers.Rational.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (self, S.One)

.sympy.core.numbers.Zero.__bool__

def __bool__(self):
    return False

.sympy.core.numbers.Infinity.__eq__

def __eq__(self, other):
    return other is S.Infinity or other == float('inf')

.sympy.core.numbers.NegativeInfinity.__eq__

def __eq__(self, other):
    return other is S.NegativeInfinity or other == float('-inf')

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.basic.Basic.compare

def compare(self, other):
    if self is other:
        return 0
    n1 = self.__class__
    n2 = other.__class__
    c = (n1 > n2) - (n1 < n2)
    if c:
        return c
    st = self._hashable_content()
    ot = other._hashable_content()
    c = (len(st) > len(ot)) - (len(st) < len(ot))
    if c:
        return c
    for l, r in zip(st, ot):
        l = Basic(*l) if isinstance(l, frozenset) else l
        r = Basic(*r) if isinstance(r, frozenset) else r
        if isinstance(l, Basic):
            c = l.compare(r)
        else:
            c = (l > r) - (l < r)
        if c:
            return c
    return 0

.sympy.core.core.BasicMeta.__gt__

def __gt__(cls, other):
    if cls.__cmp__(other) == 1:
        return True
    return False

.sympy.core.core.BasicMeta.__cmp__

def __cmp__(cls, other):
    if not isinstance(other, BasicMeta):
        return -1
    n1 = cls.__name__
    n2 = other.__name__
    if n1 == n2:
        return 0
    UNKNOWN = len(ordering_of_classes) + 1
    try:
        i1 = ordering_of_classes.index(n1)
    except ValueError:
        i1 = UNKNOWN
    try:
        i2 = ordering_of_classes.index(n2)
    except ValueError:
        i2 = UNKNOWN
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)
    return (i1 > i2) - (i1 < i2)

.sympy.core.core.BasicMeta.__lt__

def __lt__(cls, other):
    if cls.__cmp__(other) == -1:
        return True
    return False

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return {key: value for key, value in self._assumptions.items() if value is not None}

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super().__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
            for k, v in chain.from_iterable(postprocessor_mappings):
                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    return obj

.sympy.core.decorators._SympifyWrapper._func

def _func(self, other):
    if not hasattr(other, '_op_priority'):
        try:
            other = sympify(other, strict=True)
        except SympifyError:
            return retval
    if not isinstance(other, expectedcls):
        return retval
    return func(self, other)

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            f = getattr(other, method_name, None)
            if f is not None:
                return f(self)
    return func(self, other)

.sympy.core.expr.Expr.__truediv__

def __truediv__(self, other):
    denom = Pow(other, S.NegativeOne)
    if self is S.One:
        return denom
    else:
        return Mul(self, denom)

.sympy.core.power.Pow.__new__

def __new__(cls, b, e, evaluate=None):
    if evaluate is None:
        evaluate = global_parameters.evaluate
    b = _sympify(b)
    e = _sympify(e)
    from .relational import Relational
    if isinstance(b, Relational) or isinstance(e, Relational):
        raise TypeError('Relational cannot be used in Pow')
    for arg in [b, e]:
        if not isinstance(arg, Expr):
            sympy_deprecation_warning(f'\nUsing non-Expr arguments in Pow is deprecated (in this case, one of the\narguments is of type {type(arg).__name__!r}).\n\nIf you really did intend to construct a power with this base, use the **\noperator instead.', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)
    if evaluate:
        if e is S.ComplexInfinity:
            return S.NaN
        if e is S.Infinity:
            if is_gt(b, S.One):
                return S.Infinity
            if is_gt(b, S.NegativeOne) and is_lt(b, S.One):
                return S.Zero
            if is_lt(b, S.NegativeOne):
                if b.is_finite:
                    return S.ComplexInfinity
                if b.is_finite is False:
                    return S.NaN
        if e is S.Zero:
            return S.One
        elif e is S.One:
            return b
        elif e == -1 and (not b):
            return S.ComplexInfinity
        elif e.__class__.__name__ == 'AccumulationBounds':
            if b == S.Exp1:
                from sympy.calculus.accumulationbounds import AccumBounds
                return AccumBounds(Pow(b, e.min), Pow(b, e.max))
        elif (e.is_Symbol and e.is_integer or e.is_Integer) and (b.is_number and b.is_Mul or b.is_Number) and b.could_extract_minus_sign():
            if e.is_even:
                b = -b
            elif e.is_odd:
                return -Pow(-b, e)
        if S.NaN in (b, e):
            return S.NaN
        elif b is S.One:
            if abs(e).is_infinite:
                return S.NaN
            return S.One
        else:
            from sympy.functions.elementary.exponential import exp_polar
            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):
                from .exprtools import factor_terms
                from sympy.functions.elementary.exponential import log
                from sympy.simplify.radsimp import fraction
                c, ex = factor_terms(e, sign=False).as_coeff_Mul()
                num, den = fraction(ex)
                if isinstance(den, log) and den.args[0] == b:
                    return S.Exp1 ** (c * num)
                elif den.is_Add:
                    from sympy.functions.elementary.complexes import sign, im
                    s = sign(im(b))
                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):
                        return S.Exp1 ** (c * num)
            obj = b._eval_power(e)
            if obj is not None:
                return obj
    obj = Expr.__new__(cls, b, e)
    obj = cls._exec_constructor_postprocessors(obj)
    if not isinstance(obj, Pow):
        return obj
    obj.is_commutative = b.is_commutative and e.is_commutative
    return obj

.sympy.core.numbers.Number.could_extract_minus_sign

def could_extract_minus_sign(self):
    return bool(self.is_extended_negative)

.sympy.core.numbers.NegativeOne.__abs__

def __abs__():
    return S.One

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.expr.Expr._hashable_content

def _hashable_content(self):
    return self._args

.sympy.polys.densebasic.dmp_zero

def dmp_zero(u):
    r = []
    for i in range(u):
        r = [r]
    return r

.sympy.polys.densebasic.dmp_strip

def dmp_strip(f, u):
    if not u:
        return dup_strip(f)
    if dmp_zero_p(f, u):
        return f
    i, v = (0, u - 1)
    for c in f:
        if not dmp_zero_p(c, v):
            break
        else:
            i += 1
    if i == len(f):
        return dmp_zero(u)
    else:
        return f[i:]

.sympy.core.numbers.Infinity.__neg__

def __neg__(self):
    return S.NegativeInfinity

.sympy.core.power.Pow._eval_expand_multinomial

def _eval_expand_multinomial(self, **hints):
    base, exp = self.args
    result = self
    if exp.is_Rational and exp.p > 0 and base.is_Add:
        if not exp.is_Integer:
            n = Integer(exp.p // exp.q)
            if not n:
                return result
            else:
                radical, result = (self.func(base, exp - n), [])
                expanded_base_n = self.func(base, n)
                if expanded_base_n.is_Pow:
                    expanded_base_n = expanded_base_n._eval_expand_multinomial()
                for term in Add.make_args(expanded_base_n):
                    result.append(term * radical)
                return Add(*result)
        n = int(exp)
        if base.is_commutative:
            order_terms, other_terms = ([], [])
            for b in base.args:
                if b.is_Order:
                    order_terms.append(b)
                else:
                    other_terms.append(b)
            if order_terms:
                f = Add(*other_terms)
                o = Add(*order_terms)
                if n == 2:
                    return expand_multinomial(f ** n, deep=False) + n * f * o
                else:
                    g = expand_multinomial(f ** (n - 1), deep=False)
                    return expand_mul(f * g, deep=False) + n * g * o
            if base.is_number:
                a, b = base.as_real_imag()
                if a.is_Rational and b.is_Rational:
                    if not a.is_Integer:
                        if not b.is_Integer:
                            k = self.func(a.q * b.q, n)
                            a, b = (a.p * b.q, a.q * b.p)
                        else:
                            k = self.func(a.q, n)
                            a, b = (a.p, a.q * b)
                    elif not b.is_Integer:
                        k = self.func(b.q, n)
                        a, b = (a * b.q, b.p)
                    else:
                        k = 1
                    a, b, c, d = (int(a), int(b), 1, 0)
                    while n:
                        if n & 1:
                            c, d = (a * c - b * d, b * c + a * d)
                            n -= 1
                        a, b = (a * a - b * b, 2 * a * b)
                        n //= 2
                    I = S.ImaginaryUnit
                    if k == 1:
                        return c + I * d
                    else:
                        return Integer(c) / k + I * d / k
            p = other_terms
            from sympy.ntheory.multinomial import multinomial_coefficients
            from sympy.polys.polyutils import basic_from_dict
            expansion_dict = multinomial_coefficients(len(p), n)
            return basic_from_dict(expansion_dict, *p)
        elif n == 2:
            return Add(*[f * g for f in base.args for g in base.args])
        else:
            multi = (base ** (n - 1))._eval_expand_multinomial()
            if multi.is_Add:
                return Add(*[f * g for f in base.args for g in multi.args])
            else:
                return Add(*[f * multi for f in base.args])
    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):
        return 1 / self.func(base, -exp)._eval_expand_multinomial()
    elif exp.is_Add and base.is_Number:
        coeff, tail = (S.One, S.Zero)
        for term in exp.args:
            if term.is_Number:
                coeff *= self.func(base, term)
            else:
                tail += term
        return coeff * self.func(base, tail)
    else:
        return result

.sympy.core.power.Pow.as_base_exp

def as_base_exp(self):
    b, e = self.args
    if b.is_Rational and b.p == 1 and (b.q != 1):
        return (Integer(b.q), -e)
    return (b, e)

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    try:
        assumptions._tell(fact, None)
    except InconsistentAssumptions:
        return assumptions[fact]
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.expr.Expr._eval_is_negative

def _eval_is_negative(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_negative = self.is_extended_negative
    if finite is True:
        return extended_negative
    if extended_negative is False:
        return False

.sympy.core.expr.Expr._eval_is_extended_negative

def _eval_is_extended_negative(self):
    return self._eval_is_extended_positive_negative(positive=False)

.sympy.core.expr.Expr._eval_is_extended_positive_negative

def _eval_is_extended_positive_negative(self, positive):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_extended_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
        except ValueError:
            return None
        if n2 is None:
            return None
        if getattr(n2, '_prec', 1) == 1:
            return None
        if n2 is S.NaN:
            return None
        f = self.evalf(2)
        if f.is_Float:
            match = (f, S.Zero)
        else:
            match = pure_complex(f)
        if match is None:
            return False
        r, i = match
        if not (i.is_Number and r.is_Number):
            return False
        if r._prec != 1 and i._prec != 1:
            return bool(not i and (r > 0 if positive else r < 0))
        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.numbers.Number._eval_evalf

def _eval_evalf(self, prec):
    return Float._new(self._as_mpf_val(prec), prec)

.sympy.core.numbers.Integer._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_int(self.p, prec, rnd)

.sympy.core.evalf.evalf_integer

def evalf_integer(expr: 'Integer', prec: int, options: OPT_DICT) -> TMP_RES:
    return (from_int(expr.p, prec), None, prec, None)

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    super().__init__(_assume_rules)
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.facts.FactKB.__init__

def __init__(self, rules):
    self.rules = rules

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.numbers.Rational._eval_is_zero

def _eval_is_zero(self):
    return self.p == 0

.sympy.core.expr.Expr._eval_power

def _eval_power(self, other):
    return None

.sympy.core.power.Pow._eval_expand_power_base

def _eval_expand_power_base(self, **hints):
    force = hints.get('force', False)
    b = self.base
    e = self.exp
    if not b.is_Mul:
        return self
    cargs, nc = b.args_cnc(split_1=False)
    if nc:
        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]
        if e.is_Integer:
            if e.is_positive:
                rv = Mul(*nc * e)
            else:
                rv = Mul(*[i ** (-1) for i in nc[::-1]] * -e)
            if cargs:
                rv *= Mul(*cargs) ** e
            return rv
        if not cargs:
            return self.func(Mul(*nc), e, evaluate=False)
        nc = [Mul(*nc)]
    other, maybe_real = sift(cargs, lambda x: x.is_extended_real is False, binary=True)

    def pred(x):
        if x is S.ImaginaryUnit:
            return S.ImaginaryUnit
        polar = x.is_polar
        if polar:
            return True
        if polar is None:
            return fuzzy_bool(x.is_extended_nonnegative)
    sifted = sift(maybe_real, pred)
    nonneg = sifted[True]
    other += sifted[None]
    neg = sifted[False]
    imag = sifted[S.ImaginaryUnit]
    if imag:
        I = S.ImaginaryUnit
        i = len(imag) % 4
        if i == 0:
            pass
        elif i == 1:
            other.append(I)
        elif i == 2:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
        else:
            if neg:
                nonn = -neg.pop()
                if nonn is not S.One:
                    nonneg.append(nonn)
            else:
                neg.append(S.NegativeOne)
            other.append(I)
        del imag
    if force or e.is_integer:
        cargs = nonneg + neg + other
        other = nc
    else:
        assert not e.is_Integer
        if len(neg) > 1:
            o = S.One
            if not other and neg[0].is_Number:
                o *= neg.pop(0)
            if len(neg) % 2:
                o = -o
            for n in neg:
                nonneg.append(-n)
            if o is not S.One:
                other.append(o)
        elif neg and other:
            if neg[0].is_Number and neg[0] is not S.NegativeOne:
                other.append(S.NegativeOne)
                nonneg.append(-neg[0])
            else:
                other.extend(neg)
        else:
            other.extend(neg)
        del neg
        cargs = nonneg
        other += nc
    rv = S.One
    if cargs:
        if e.is_Rational:
            npow, cargs = sift(cargs, lambda x: x.is_Pow and x.exp.is_Rational and x.base.is_number, binary=True)
            rv = Mul(*[self.func(b.func(*b.args), e) for b in npow])
        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])
    if other:
        rv *= self.func(Mul(*other), e, evaluate=False)
    return rv

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.core.power.Pow._eval_expand_power_exp

def _eval_expand_power_exp(self, **hints):
    b = self.base
    e = self.exp
    if b == S.Exp1:
        from sympy.concrete.summations import Sum
        if isinstance(e, Sum) and e.is_commutative:
            from sympy.concrete.products import Product
            return Product(self.func(b, e.function), *e.limits)
    if e.is_Add and e.is_commutative:
        expr = []
        for x in e.args:
            expr.append(self.func(b, x))
        return Mul(*expr)
    return self.func(b, e)

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.integrals.intpoly.main_integrate

def main_integrate(expr, facets, hp_params, max_degree=None):
    dims = (x, y)
    dim_length = len(dims)
    result = {}
    if max_degree:
        grad_terms = [[0, 0, 0, 0]] + gradient_terms(max_degree)
        for facet_count, hp in enumerate(hp_params):
            a, b = (hp[0], hp[1])
            x0 = facets[facet_count].points[0]
            for i, monom in enumerate(grad_terms):
                m, x_d, y_d, _ = monom
                value = result.get(m, None)
                degree = S.Zero
                if b.is_zero:
                    value_over_boundary = S.Zero
                else:
                    degree = x_d + y_d
                    value_over_boundary = integration_reduction_dynamic(facets, facet_count, a, b, m, degree, dims, x_d, y_d, max_degree, x0, grad_terms, i)
                monom[3] = value_over_boundary
                if value is not None:
                    result[m] += value_over_boundary * (b / norm(a)) / (dim_length + degree)
                else:
                    result[m] = value_over_boundary * (b / norm(a)) / (dim_length + degree)
        return result
    elif not isinstance(expr, list):
        polynomials = decompose(expr)
        return _polynomial_integrate(polynomials, facets, hp_params)
    else:
        return {e: _polynomial_integrate(decompose(e), facets, hp_params) for e in expr}

.sympy.integrals.intpoly.gradient_terms

def gradient_terms(binomial_power=0, no_of_gens=2):
    if no_of_gens == 2:
        count = 0
        terms = [None] * int((binomial_power ** 2 + 3 * binomial_power + 2) / 2)
        for x_count in range(0, binomial_power + 1):
            for y_count in range(0, binomial_power - x_count + 1):
                terms[count] = [x ** x_count * y ** y_count, x_count, y_count, 0]
                count += 1
    else:
        terms = [[[[x ** x_count * y ** y_count * z ** (z_count - y_count - x_count), x_count, y_count, z_count - y_count - x_count, z_count, x_count, z_count - y_count - x_count, 0] for y_count in range(z_count - x_count, -1, -1)] for x_count in range(0, z_count + 1)] for z_count in range(0, binomial_power + 1)]
    return terms

.sympy.core.expr.Expr.__pow__

def __pow__(self, other, mod=None):
    if mod is None:
        return self._pow(other)
    try:
        _self, other, mod = (as_int(self), as_int(other), as_int(mod))
        if other >= 0:
            return pow(_self, other, mod)
        else:
            from .numbers import mod_inverse
            return mod_inverse(pow(_self, -other, mod), mod)
    except ValueError:
        power = self._pow(other)
        try:
            return power % mod
        except TypeError:
            return NotImplemented

.sympy.core.expr.Expr._pow

def _pow(self, other):
    return Pow(self, other)

.sympy.core.numbers.Number.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_parameters.evaluate:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.Infinity
            else:
                return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.NegativeInfinity
            else:
                return S.Infinity
    elif isinstance(other, Tuple):
        return NotImplemented
    return AtomicExpr.__mul__(self, other)

.sympy.core.expr.Expr.__mul__

def __mul__(self, other):
    return Mul(self, other)

.sympy.core.power.Pow._eval_is_zero

def _eval_is_zero(self):
    if self.base.is_zero:
        if self.exp.is_extended_positive:
            return True
        elif self.exp.is_extended_nonpositive:
            return False
    elif self.base == S.Exp1:
        return self.exp is S.NegativeInfinity
    elif self.base.is_zero is False:
        if self.base.is_finite and self.exp.is_finite:
            return False
        elif self.exp.is_negative:
            return self.base.is_infinite
        elif self.exp.is_nonnegative:
            return False
        elif self.exp.is_infinite and self.exp.is_extended_real:
            if (1 - abs(self.base)).is_extended_positive:
                return self.exp.is_extended_positive
            elif (1 - abs(self.base)).is_extended_negative:
                return self.exp.is_extended_negative
    elif self.base.is_finite and self.exp.is_negative:
        return False

.sympy.core.power.Pow._eval_is_rational

def _eval_is_rational(self):
    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):
        return True
    p = self.func(*self.as_base_exp())
    if not p.is_Pow:
        return p.is_rational
    b, e = p.as_base_exp()
    if e.is_Rational and b.is_Rational:
        return False
    if e.is_integer:
        if b.is_rational:
            if fuzzy_not(b.is_zero) or e.is_nonnegative:
                return True
            if b == e:
                return True
        elif b.is_irrational:
            return e.is_zero
    if b is S.Exp1:
        if e.is_rational and e.is_nonzero:
            return False

.sympy.core.power.Pow._eval_is_imaginary

def _eval_is_imaginary(self):
    if self.base.is_imaginary:
        if self.exp.is_integer:
            odd = self.exp.is_odd
            if odd is not None:
                return odd
            return
    if self.base == S.Exp1:
        f = 2 * self.exp / (S.Pi * S.ImaginaryUnit)
        if f.is_even:
            return False
        if f.is_odd:
            return True
        return None
    if self.exp.is_imaginary:
        from sympy.functions.elementary.exponential import log
        imlog = log(self.base).is_imaginary
        if imlog is not None:
            return False
    if self.base.is_extended_real and self.exp.is_extended_real:
        if self.base.is_positive:
            return False
        else:
            rat = self.exp.is_rational
            if not rat:
                return rat
            if self.exp.is_integer:
                return False
            else:
                half = (2 * self.exp).is_integer
                if half:
                    return self.base.is_negative
                return half
    if self.base.is_extended_real is False:
        from sympy.functions.elementary.complexes import arg
        i = arg(self.base) * self.exp / S.Pi
        isodd = (2 * i).is_odd
        if isodd is not None:
            return isodd

.sympy.core.power.Pow._eval_is_extended_positive

def _eval_is_extended_positive(self):
    if self.base == self.exp:
        if self.base.is_extended_nonnegative:
            return True
    elif self.base.is_positive:
        if self.exp.is_real:
            return True
    elif self.base.is_extended_negative:
        if self.exp.is_even:
            return True
        if self.exp.is_odd:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return self.exp.is_zero
    elif self.base.is_extended_nonpositive:
        if self.exp.is_odd:
            return False
    elif self.base.is_imaginary:
        if self.exp.is_integer:
            m = self.exp % 4
            if m.is_zero:
                return True
            if m.is_integer and m.is_zero is False:
                return False
        if self.exp.is_imaginary:
            from sympy.functions.elementary.exponential import log
            return log(self.base).is_imaginary

.sympy.core.power.Pow._eval_is_positive

def _eval_is_positive(self):
    ext_pos = Pow._eval_is_extended_positive(self)
    if ext_pos is True:
        return self.is_finite
    return ext_pos

.sympy.core.power.Pow._eval_is_complex

def _eval_is_complex(self):
    if self.base == S.Exp1:
        return fuzzy_or([self.exp.is_complex, self.exp.is_extended_negative])
    if all((a.is_complex for a in self.args)) and self._eval_is_finite():
        return True

.sympy.core.power.Pow._eval_is_integer

def _eval_is_integer(self):
    b, e = self.args
    if b.is_rational:
        if b.is_integer is False and e.is_positive:
            return False
    if b.is_integer and e.is_integer:
        if b is S.NegativeOne:
            return True
        if e.is_nonnegative or e.is_positive:
            return True
    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
            return False
    if b.is_Number and e.is_Number:
        check = self.func(*self.args)
        return check.is_Integer
    if e.is_negative and b.is_positive and (b - 1).is_positive:
        return False
    if e.is_negative and b.is_negative and (b + 1).is_negative:
        return False

.sympy.core.power.Pow._eval_is_algebraic

def _eval_is_algebraic(self):

    def _is_one(expr):
        try:
            return (expr - 1).is_zero
        except ValueError:
            return False
    if self.base.is_zero or _is_one(self.base):
        return True
    elif self.base is S.Exp1:
        s = self.func(*self.args)
        if s.func == self.func:
            if self.exp.is_nonzero:
                if self.exp.is_algebraic:
                    return False
                elif (self.exp / S.Pi).is_rational:
                    return False
                elif (self.exp / (S.ImaginaryUnit * S.Pi)).is_rational:
                    return True
        else:
            return s.is_algebraic
    elif self.exp.is_rational:
        if self.base.is_algebraic is False:
            return self.exp.is_zero
        if self.base.is_zero is False:
            if self.exp.is_nonzero:
                return self.base.is_algebraic
            elif self.base.is_algebraic:
                return True
        if self.exp.is_positive:
            return self.base.is_algebraic
    elif self.base.is_algebraic and self.exp.is_algebraic:
        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:
            return self.exp.is_rational

.sympy.core.power.Pow._is_one

def _is_one(expr):
    try:
        return (expr - 1).is_zero
    except ValueError:
        return False

.sympy.core.expr.Expr.__sub__

def __sub__(self, other):
    return Add(self, -other)

.sympy.core.add.Add.flatten

def flatten(cls, seq):
    from sympy.calculus.accumulationbounds import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    from sympy.tensor.tensor import TensExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        if a.is_Rational:
            if b.is_Mul:
                rv = ([a, b], [], None)
        if rv:
            if all((s.is_commutative for s in rv[0])):
                return rv
            return ([], rv[0], None)
    terms = {}
    coeff = S.Zero
    order_factors = []
    extra = []
    for o in seq:
        if o.is_Order:
            if o.expr.is_zero:
                continue
            for o1 in order_factors:
                if o1.contains(o):
                    o = None
                    break
            if o is None:
                continue
            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]
            continue
        elif o.is_Number:
            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):
                return ([S.NaN], [], None)
            if coeff.is_Number or isinstance(coeff, AccumBounds):
                coeff += o
                if coeff is S.NaN and (not extra):
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__add__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            extra.append(o)
            continue
        elif isinstance(o, TensExpr):
            coeff = o.__add__(coeff) if coeff else o
            continue
        elif o is S.ComplexInfinity:
            if coeff.is_finite is False and (not extra):
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o.is_Add:
            seq.extend(o.args)
            continue
        elif o.is_Mul:
            c, s = o.as_coeff_Mul()
        elif o.is_Pow:
            b, e = o.as_base_exp()
            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):
                seq.append(b ** e)
                continue
            c, s = (S.One, o)
        else:
            c = S.One
            s = o
        if s in terms:
            terms[s] += c
            if terms[s] is S.NaN and (not extra):
                return ([S.NaN], [], None)
        else:
            terms[s] = c
    newseq = []
    noncommutative = False
    for s, c in terms.items():
        if c.is_zero:
            continue
        elif c is S.One:
            newseq.append(s)
        elif s.is_Mul:
            cs = s._new_rawargs(*(c,) + s.args)
            newseq.append(cs)
        elif s.is_Add:
            newseq.append(Mul(c, s, evaluate=False))
        else:
            newseq.append(Mul(c, s))
        noncommutative = noncommutative or not s.is_commutative
    if coeff is S.Infinity:
        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]
    elif coeff is S.NegativeInfinity:
        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]
    if coeff is S.ComplexInfinity:
        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]
    if order_factors:
        newseq2 = []
        for t in newseq:
            for o in order_factors:
                if o.contains(t):
                    t = None
                    break
            if t is not None:
                newseq2.append(t)
        newseq = newseq2 + order_factors
        for o in order_factors:
            if o.contains(coeff):
                coeff = S.Zero
                break
    _addsort(newseq)
    if coeff is not S.Zero:
        newseq.insert(0, coeff)
    if extra:
        newseq += extra
        noncommutative = True
    if noncommutative:
        return ([], newseq, None)
    else:
        return (newseq, [], None)

.sympy.core.add._addsort

def _addsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.add.Add._eval_is_zero

def _eval_is_zero(self):
    if self.is_commutative is False:
        return
    nz = []
    z = 0
    im_or_z = False
    im = 0
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                z += 1
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im += 1
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_or_z = True
        else:
            return
    if z == len(self.args):
        return True
    if len(nz) in [0, len(self.args)]:
        return None
    b = self.func(*nz)
    if b.is_zero:
        if not im_or_z:
            if im == 0:
                return True
            elif im == 1:
                return False
    if b.is_zero is False:
        return False

.sympy.core.numbers.Rational.as_numer_denom

def as_numer_denom(self):
    return (Integer(self.p), Integer(self.q))

.sympy.core.numbers.Integer.__divmod__

def __divmod__(self, other):
    if isinstance(other, Integer) and global_parameters.evaluate:
        return Tuple(*divmod(self.p, other.p))
    else:
        return Number.__divmod__(self, other)

.sympy.core.numbers.Integer.__mod__

def __mod__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p % other)
        elif isinstance(other, Integer):
            return Integer(self.p % other.p)
        return Rational.__mod__(self, other)
    return Rational.__mod__(self, other)

.sympy.core.mul.Mul._eval_is_extended_real

def _eval_is_extended_real(self):
    return self._eval_real_imag(True)

.sympy.core.mul.Mul._eval_real_imag

def _eval_real_imag(self, real):
    zero = False
    t_not_re_im = None
    for t in self.args:
        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:
            return False
        elif t.is_imaginary:
            real = not real
        elif t.is_extended_real:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_extended_real is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        elif t.is_imaginary is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        else:
            return
    if t_not_re_im:
        if t_not_re_im.is_extended_real is False:
            if real:
                return zero
        if t_not_re_im.is_imaginary is False:
            if not real:
                return zero
    elif zero is False:
        return real
    elif real:
        return real

.sympy.core.mul.Mul._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):
                return True
            return
        if a is None:
            return
    if all((x.is_real for x in self.args)):
        return False

.sympy.core.mul.Mul._eval_is_imaginary

def _eval_is_imaginary(self):
    z = self.is_zero
    if z:
        return False
    if self.is_finite is False:
        return False
    elif z is False and self.is_finite is True:
        return self._eval_real_imag(False)

.sympy.core.mul.Mul._eval_is_zero

def _eval_is_zero(self):
    zero = infinite = False
    for a in self.args:
        z = a.is_zero
        if z:
            if infinite:
                return
            zero = True
        else:
            if not a.is_finite:
                if zero:
                    return
                infinite = True
            if zero is False and z is None:
                zero = None
    return zero

.sympy.core.mul.Mul._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return self._eval_pos_neg(1)

.sympy.core.mul.Mul._eval_pos_neg

def _eval_pos_neg(self, sign):
    saw_NON = saw_NOT = False
    for t in self.args:
        if t.is_extended_positive:
            continue
        elif t.is_extended_negative:
            sign = -sign
        elif t.is_zero:
            if all((a.is_finite for a in self.args)):
                return False
            return
        elif t.is_extended_nonpositive:
            sign = -sign
            saw_NON = True
        elif t.is_extended_nonnegative:
            saw_NON = True
        elif t.is_positive is False:
            sign = -sign
            if saw_NOT:
                return
            saw_NOT = True
        elif t.is_negative is False:
            if saw_NOT:
                return
            saw_NOT = True
        else:
            return
    if sign == 1 and saw_NON is False and (saw_NOT is False):
        return True
    if sign < 0:
        return False

.sympy.core.mul.Mul._eval_is_composite

def _eval_is_composite(self):
    number_of_args = 0
    for arg in self.args:
        if not (arg.is_integer and arg.is_positive):
            return None
        if (arg - 1).is_positive:
            number_of_args += 1
    if number_of_args > 1:
        return True

.sympy.core.mul.Mul._eval_is_integer

def _eval_is_integer(self):
    from sympy.ntheory.factor_ import trailing
    is_rational = self._eval_is_rational()
    if is_rational is False:
        return False
    numerators = []
    denominators = []
    unknown = False
    for a in self.args:
        hit = False
        if a.is_integer:
            if abs(a) is not S.One:
                numerators.append(a)
        elif a.is_Rational:
            n, d = a.as_numer_denom()
            if abs(n) is not S.One:
                numerators.append(n)
            if d is not S.One:
                denominators.append(d)
        elif a.is_Pow:
            b, e = a.as_base_exp()
            if not b.is_integer or not e.is_integer:
                hit = unknown = True
            if e.is_negative:
                denominators.append(2 if a is S.Half else Pow(a, S.NegativeOne))
            elif not hit:
                assert not e.is_positive
                assert not e.is_zero
                return
        else:
            return
    if not denominators and (not unknown):
        return True
    allodd = lambda x: all((i.is_odd for i in x))
    alleven = lambda x: all((i.is_even for i in x))
    anyeven = lambda x: any((i.is_even for i in x))
    from .relational import is_gt
    if not numerators and denominators and all((is_gt(_, S.One) for _ in denominators)):
        return False
    elif unknown:
        return
    elif allodd(numerators) and anyeven(denominators):
        return False
    elif anyeven(numerators) and denominators == [2]:
        return True
    elif alleven(numerators) and allodd(denominators) and (Mul(*denominators, evaluate=False) - 1).is_positive:
        return False
    if len(denominators) == 1:
        d = denominators[0]
        if d.is_Integer and d.is_even:
            if (Add(*[i.as_base_exp()[1] for i in numerators if i.is_even]) - trailing(d.p)).is_nonnegative:
                return True
    if len(numerators) == 1:
        n = numerators[0]
        if n.is_Integer and n.is_even:
            if (Add(*[i.as_base_exp()[1] for i in denominators if i.is_even]) - trailing(n.p)).is_positive:
                return False

.sympy.core.mul.Mul._eval_is_rational

def _eval_is_rational(self):
    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.logic._fuzzy_group

def _fuzzy_group(args, quick_exit=False):
    saw_other = False
    for a in args:
        if a is True:
            continue
        if a is None:
            return
        if quick_exit and saw_other:
            return
        saw_other = True
    return not saw_other

.sympy.core.mul.Mul._eval_is_finite

def _eval_is_finite(self):
    if all((a.is_finite for a in self.args)):
        return True
    if any((a.is_infinite for a in self.args)):
        if all((a.is_zero is False for a in self.args)):
            return False

.sympy.core.mul.Mul._eval_is_complex

def _eval_is_complex(self):
    comp = _fuzzy_group((a.is_complex for a in self.args))
    if comp is False:
        if any((a.is_infinite for a in self.args)):
            if any((a.is_zero is not False for a in self.args)):
                return None
            return False
    return comp

.sympy.core.mul.Mul._eval_is_odd

def _eval_is_odd(self):
    is_integer = self.is_integer
    if is_integer:
        if self.is_zero:
            return False
        from sympy.simplify.radsimp import fraction
        n, d = fraction(self)
        if d.is_Integer and d.is_even:
            from sympy.ntheory.factor_ import trailing
            if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(n) if i.is_even]) - trailing(d.p)).is_positive:
                return False
            return
        r, acc = (True, 1)
        for t in self.args:
            if abs(t) is S.One:
                continue
            assert t.is_integer
            if t.is_even:
                return False
            if r is False:
                pass
            elif acc != 1 and (acc + t).is_odd:
                r = False
            elif t.is_even is None:
                r = None
            acc = t
        return r
    return is_integer

.sympy.core.mul.Mul._eval_is_even

def _eval_is_even(self):
    is_integer = self.is_integer
    if is_integer:
        return fuzzy_not(self.is_odd)
    from sympy.simplify.radsimp import fraction
    n, d = fraction(self)
    if n.is_Integer and n.is_even:
        from sympy.ntheory.factor_ import trailing
        if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(d) if i.is_even]) - trailing(n.p)).is_nonnegative:
            return False
    return is_integer

.sympy.core.mul.Mul._eval_is_algebraic

def _eval_is_algebraic(self):
    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.mul.Mul._eval_is_infinite

def _eval_is_infinite(self):
    if any((a.is_infinite for a in self.args)):
        if any((a.is_zero for a in self.args)):
            return S.NaN.is_infinite
        if any((a.is_zero is None for a in self.args)):
            return None
        return True

.sympy.core.mul.Mul._eval_is_extended_negative

def _eval_is_extended_negative(self):
    return self._eval_pos_neg(-1)

.sympy.core.expr.Expr._eval_is_positive

def _eval_is_positive(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_positive = self.is_extended_positive
    if finite is True:
        return extended_positive
    if extended_positive is False:
        return False

.sympy.core.mul.Mul._eval_is_hermitian

def _eval_is_hermitian(self):
    return self._eval_herm_antiherm(True)

.sympy.core.mul.Mul._eval_herm_antiherm

def _eval_herm_antiherm(self, real):
    one_nc = zero = one_neither = False
    for t in self.args:
        if not t.is_commutative:
            if one_nc:
                return
            one_nc = True
        if t.is_antihermitian:
            real = not real
        elif t.is_hermitian:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_hermitian is False:
            if one_neither:
                return
            one_neither = True
        else:
            return
    if one_neither:
        if real:
            return zero
    elif zero is False or real:
        return real

.sympy.core.mul.Mul._eval_is_antihermitian

def _eval_is_antihermitian(self):
    z = self.is_zero
    if z:
        return False
    elif z is False:
        return self._eval_herm_antiherm(False)

.sympy.core.add.Add._eval_is_infinite

def _eval_is_infinite(self):
    sawinf = False
    for a in self.args:
        ainf = a.is_infinite
        if ainf is None:
            return None
        elif ainf is True:
            if sawinf is True:
                return None
            sawinf = True
    return sawinf

.sympy.core.add.Add._eval_is_odd

def _eval_is_odd(self):
    l = [f for f in self.args if not f.is_even is True]
    if not l:
        return False
    if l[0].is_odd:
        return self._new_rawargs(*l[1:]).is_even

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, reeval=True, **kwargs):
    if reeval and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.core.add.Add._eval_is_imaginary

def _eval_is_imaginary(self):
    nz = []
    im_I = []
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                pass
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im_I.append(a * S.ImaginaryUnit)
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_I.append(a * S.ImaginaryUnit)
        else:
            return
    b = self.func(*nz)
    if b.is_zero:
        return fuzzy_not(self.func(*im_I).is_zero)
    elif b.is_zero is False:
        return False

.sympy.core.add.Add._eval_is_extended_nonnegative

def _eval_is_extended_nonnegative(self):
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonnegative:
            from .exprtools import _monotonic_sign
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonnegative:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonnegative:
                        return True

.sympy.core.add.Add.as_coeff_Add

def as_coeff_Add(self, rational=False, deps=None):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number and (not rational) or coeff.is_Rational:
        return (coeff, self._new_rawargs(*args))
    return (S.Zero, self)

.sympy.core.add.Add._eval_is_extended_positive

def _eval_is_extended_positive(self):
    if self.is_number:
        return super()._eval_is_extended_positive()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        from .exprtools import _monotonic_sign
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_positive and a.is_extended_nonnegative:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_positive:
                    return True
    pos = nonneg = nonpos = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        ispos = a.is_extended_positive
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))
            if True in saw_INF and False in saw_INF:
                return
        if ispos:
            pos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonpos and (not nonneg) and pos:
        return True
    elif not nonpos and pos:
        return True
    elif not pos and (not nonneg):
        return False

.sympy.core.exprtools._monotonic_sign

def _monotonic_sign(self):
    if not self.is_extended_real:
        return
    if (-self).is_Symbol:
        rv = _monotonic_sign(-self)
        return rv if rv is None else -rv
    if not self.is_Add and self.as_numer_denom()[1].is_number:
        s = self
        if s.is_prime:
            if s.is_odd:
                return Integer(3)
            else:
                return Integer(2)
        elif s.is_composite:
            if s.is_odd:
                return Integer(9)
            else:
                return Integer(4)
        elif s.is_positive:
            if s.is_even:
                if s.is_prime is False:
                    return Integer(4)
                else:
                    return Integer(2)
            elif s.is_integer:
                return S.One
            else:
                return _eps
        elif s.is_extended_negative:
            if s.is_even:
                return Integer(-2)
            elif s.is_integer:
                return S.NegativeOne
            else:
                return -_eps
        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:
            return S.Zero
        return None
    free = self.free_symbols
    if len(free) == 1:
        if self.is_polynomial():
            from sympy.polys.polytools import real_roots
            from sympy.polys.polyroots import roots
            from sympy.polys.polyerrors import PolynomialError
            x = free.pop()
            x0 = _monotonic_sign(x)
            if x0 in (_eps, -_eps):
                x0 = S.Zero
            if x0 is not None:
                d = self.diff(x)
                if d.is_number:
                    currentroots = []
                else:
                    try:
                        currentroots = real_roots(d)
                    except (PolynomialError, NotImplementedError):
                        currentroots = [r for r in roots(d, x) if r.is_extended_real]
                y = self.subs(x, x0)
                if x.is_nonnegative and all(((r - x0).is_nonpositive for r in currentroots)):
                    if y.is_nonnegative and d.is_positive:
                        if y:
                            return y if y.is_positive else Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_negative:
                        if y:
                            return y if y.is_negative else Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
                elif x.is_nonpositive and all(((r - x0).is_nonnegative for r in currentroots)):
                    if y.is_nonnegative and d.is_negative:
                        if y:
                            return Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_positive:
                        if y:
                            return Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
        else:
            n, d = self.as_numer_denom()
            den = None
            if n.is_number:
                den = _monotonic_sign(d)
            elif not d.is_number:
                if _monotonic_sign(n) is not None:
                    den = _monotonic_sign(d)
            if den is not None and (den.is_positive or den.is_negative):
                v = n * den
                if v.is_positive:
                    return Dummy('pos', positive=True)
                elif v.is_nonnegative:
                    return Dummy('nneg', nonnegative=True)
                elif v.is_negative:
                    return Dummy('neg', negative=True)
                elif v.is_nonpositive:
                    return Dummy('npos', nonpositive=True)
        return None
    c, a = self.as_coeff_Add()
    v = None
    if not a.is_polynomial():
        n, d = a.as_numer_denom()
        if not (n.is_number or d.is_number):
            return
        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):
            v = S.One
            for ai in Mul.make_args(a):
                if ai.is_number:
                    v *= ai
                    continue
                reps = {}
                for x in ai.free_symbols:
                    reps[x] = _monotonic_sign(x)
                    if reps[x] is None:
                        return
                v *= ai.subs(reps)
    elif c:
        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):
            free = list(a.free_symbols)
            p = {}
            for i in free:
                v = _monotonic_sign(i)
                if v is None:
                    return
                p[i] = v or (_eps if i.is_nonnegative else -_eps)
            v = a.xreplace(p)
    if v is not None:
        rv = v + c
        if v.is_nonnegative and rv.is_positive:
            return rv.subs(_eps, 0)
        if v.is_nonpositive and rv.is_negative:
            return rv.subs(_eps, 0)

.sympy.core.add.Add._eval_is_extended_negative

def _eval_is_extended_negative(self):
    if self.is_number:
        return super()._eval_is_extended_negative()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        from .exprtools import _monotonic_sign
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_negative and a.is_extended_nonpositive:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_negative:
                    return True
    neg = nonpos = nonneg = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        isneg = a.is_extended_negative
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))
            if True in saw_INF and False in saw_INF:
                return
        if isneg:
            neg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonneg and (not nonpos) and neg:
        return True
    elif not nonneg and neg:
        return True
    elif not neg and (not nonpos):
        return False

.sympy.core.add.Add._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all((x.is_rational is True for x in others)):
                return True
            return None
        if a is None:
            return
    return False

.sympy.core.add.Add._eval_is_extended_nonpositive

def _eval_is_extended_nonpositive(self):
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonpositive:
            from .exprtools import _monotonic_sign
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonpositive:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonpositive:
                        return True

.sympy.core.numbers.Rational._eval_is_positive

def _eval_is_positive(self):
    return self.p > 0

.sympy.core.power.Pow._eval_is_finite

def _eval_is_finite(self):
    if self.exp.is_negative:
        if self.base.is_zero:
            return False
        if self.base.is_infinite or self.base.is_nonzero:
            return True
    c1 = self.base.is_finite
    if c1 is None:
        return
    c2 = self.exp.is_finite
    if c2 is None:
        return
    if c1 and c2:
        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):
            return True

.sympy.core.power.Pow._eval_is_even

def _eval_is_even(self):
    if self.exp.is_integer and self.exp.is_positive:
        return self.base.is_even

.sympy.core.power.Pow._eval_is_extended_real

def _eval_is_extended_real(self):
    if self.base is S.Exp1:
        if self.exp.is_extended_real:
            return True
        elif self.exp.is_imaginary:
            return (2 * S.ImaginaryUnit * self.exp / S.Pi).is_even
    from sympy.functions.elementary.exponential import log, exp
    real_b = self.base.is_extended_real
    if real_b is None:
        if self.base.func == exp and self.base.exp.is_imaginary:
            return self.exp.is_imaginary
        if self.base.func == Pow and self.base.base is S.Exp1 and self.base.exp.is_imaginary:
            return self.exp.is_imaginary
        return
    real_e = self.exp.is_extended_real
    if real_e is None:
        return
    if real_b and real_e:
        if self.base.is_extended_positive:
            return True
        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:
            return True
        elif self.exp.is_integer and self.base.is_extended_nonzero:
            return True
        elif self.exp.is_integer and self.exp.is_nonnegative:
            return True
        elif self.base.is_extended_negative:
            if self.exp.is_Rational:
                return False
    if real_e and self.exp.is_extended_negative and (self.base.is_zero is False):
        return Pow(self.base, -self.exp).is_extended_real
    im_b = self.base.is_imaginary
    im_e = self.exp.is_imaginary
    if im_b:
        if self.exp.is_integer:
            if self.exp.is_even:
                return True
            elif self.exp.is_odd:
                return False
        elif im_e and log(self.base).is_imaginary:
            return True
        elif self.exp.is_Add:
            c, a = self.exp.as_coeff_Add()
            if c and c.is_Integer:
                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real
        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
            if (self.exp / 2).is_integer is False:
                return False
    if real_b and im_e:
        if self.base is S.NegativeOne:
            return True
        c = self.exp.coeff(S.ImaginaryUnit)
        if c:
            if self.base.is_rational and c.is_rational:
                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:
                    return False
            ok = (c * log(self.base) / S.Pi).is_integer
            if ok is not None:
                return ok
    if real_b is False:
        from sympy.functions.elementary.complexes import arg
        i = arg(self.base) * self.exp / S.Pi
        if i.is_complex:
            return i.is_integer

.sympy.core.power.Pow._eval_is_negative

def _eval_is_negative(self):
    ext_neg = Pow._eval_is_extended_negative(self)
    if ext_neg is True:
        return self.is_finite
    return ext_neg

.sympy.core.power.Pow._eval_is_extended_negative

def _eval_is_extended_negative(self):
    if self.exp is S.Half:
        if self.base.is_complex or self.base.is_extended_real:
            return False
    if self.base.is_extended_negative:
        if self.exp.is_odd and self.base.is_finite:
            return True
        if self.exp.is_even:
            return False
    elif self.base.is_extended_positive:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_extended_nonnegative:
        if self.exp.is_extended_nonnegative:
            return False
    elif self.base.is_extended_nonpositive:
        if self.exp.is_even:
            return False
    elif self.base.is_extended_real:
        if self.exp.is_even:
            return False

.sympy.core.power.Pow._eval_is_composite

def _eval_is_composite(self):
    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):
        return True

.sympy.core.power.Pow._eval_is_prime

def _eval_is_prime(self):
    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:
        return False

.sympy.core.power.Pow._eval_is_odd

def _eval_is_odd(self):
    if self.exp.is_integer:
        if self.exp.is_positive:
            return self.base.is_odd
        elif self.exp.is_nonnegative and self.base.is_odd:
            return True
        elif self.base is S.NegativeOne:
            return True

.sympy.geometry.line.LinearEntity.points

def points(self):
    return (self.p1, self.p2)

.sympy.geometry.line.LinearEntity.p1

def p1(self):
    return self.args[0]

.sympy.geometry.line.LinearEntity.p2

def p2(self):
    return self.args[1]

.sympy.integrals.intpoly.norm

def norm(point):
    half = S.Half
    if isinstance(point, (list, tuple)):
        return sum([coord ** 2 for coord in point]) ** half
    elif isinstance(point, Point):
        if isinstance(point, Point2D):
            return (point.x ** 2 + point.y ** 2) ** half
        else:
            return (point.x ** 2 + point.y ** 2 + point.z) ** half
    elif isinstance(point, dict):
        return sum((i ** 2 for i in point.values())) ** half

.sympy.core.numbers.Integer._eval_is_odd

def _eval_is_odd(self):
    return bool(self.p % 2)

.sympy.core.numbers.NegativeOne.__neg__

def __neg__():
    return S.One

.sympy.core.numbers.Integer.__abs__

def __abs__(self):
    if self.p >= 0:
        return self
    else:
        return Integer(-self.p)

.sympy.core.numbers.Zero._eval_power

def _eval_power(self, expt):
    if expt.is_extended_positive:
        return self
    if expt.is_extended_negative:
        return S.ComplexInfinity
    if expt.is_extended_real is False:
        return S.NaN
    coeff, terms = expt.as_coeff_Mul()
    if coeff.is_negative:
        return S.ComplexInfinity ** terms
    if coeff is not S.One:
        return self ** terms

.sympy.core.expr.Expr._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return self._eval_is_extended_positive_negative(positive=True)

.sympy.core.numbers.Half.__abs__

def __abs__():
    return S.Half

.sympy.integrals.intpoly.integration_reduction_dynamic

def integration_reduction_dynamic(facets, index, a, b, expr, degree, dims, x_index, y_index, max_index, x0, monomial_values, monom_index, vertices=None, hp_param=None):
    value = S.Zero
    m = len(facets)
    if expr == S.Zero:
        return expr
    if len(dims) == 2:
        if not expr.is_number:
            _, x_degree, y_degree, _ = monomial_values[monom_index]
            x_index = monom_index - max_index + x_index - 2 if x_degree > 0 else 0
            y_index = monom_index - 1 if y_degree > 0 else 0
            x_value, y_value = (monomial_values[x_index][3], monomial_values[y_index][3])
            value += x_degree * x_value * x0[0] + y_degree * y_value * x0[1]
        value += left_integral2D(m, index, facets, x0, expr, dims)
    else:
        z_index = max_index
        if not expr.is_number:
            x_degree, y_degree, z_degree = (y_index, z_index - x_index - y_index, x_index)
            x_value = monomial_values[z_index - 1][y_index - 1][x_index][7] if x_degree > 0 else 0
            y_value = monomial_values[z_index - 1][y_index][x_index][7] if y_degree > 0 else 0
            z_value = monomial_values[z_index - 1][y_index][x_index - 1][7] if z_degree > 0 else 0
            value += x_degree * x_value * x0[0] + y_degree * y_value * x0[1] + z_degree * z_value * x0[2]
        value += left_integral3D(facets, index, expr, vertices, hp_param, degree)
    return value / (len(dims) + degree - 1)

.sympy.core.numbers.Integer.__rmul__

def __rmul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(other * self.p)
        elif isinstance(other, Rational):
            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))
        return Rational.__rmul__(self, other)
    return Rational.__rmul__(self, other)

.sympy.integrals.intpoly.left_integral2D

def left_integral2D(m, index, facets, x0, expr, gens):
    value = S.Zero
    for j in range(0, m):
        intersect = ()
        if j in ((index - 1) % m, (index + 1) % m):
            intersect = intersection(facets[index], facets[j], 'segment2D')
        if intersect:
            distance_origin = norm(tuple(map(lambda x, y: x - y, intersect, x0)))
            if is_vertex(intersect):
                if isinstance(expr, Expr):
                    if len(gens) == 3:
                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1], gens[2]: intersect[2]}
                    else:
                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1]}
                    value += distance_origin * expr.subs(expr_dict)
                else:
                    value += distance_origin * expr
    return value

.sympy.integrals.intpoly.intersection

def intersection(geom_1, geom_2, intersection_type):
    if intersection_type[:-2] == 'segment':
        if intersection_type == 'segment2D':
            x1, y1 = geom_1.points[0]
            x2, y2 = geom_1.points[1]
            x3, y3 = geom_2.points[0]
            x4, y4 = geom_2.points[1]
        elif intersection_type == 'segment3D':
            x1, y1, z1 = geom_1.points[0]
            x2, y2, z2 = geom_1.points[1]
            x3, y3, z3 = geom_2.points[0]
            x4, y4, z4 = geom_2.points[1]
        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        if denom:
            t1 = x1 * y2 - y1 * x2
            t2 = x3 * y4 - x4 * y3
            return (S(t1 * (x3 - x4) - t2 * (x1 - x2)) / denom, S(t1 * (y3 - y4) - t2 * (y1 - y2)) / denom)
    if intersection_type[:-2] == 'plane':
        if intersection_type == 'plane2D':
            a1x, a1y = geom_1[0]
            a2x, a2y = geom_2[0]
            b1, b2 = (geom_1[1], geom_2[1])
            denom = a1x * a2y - a2x * a1y
            if denom:
                return (S(b1 * a2y - b2 * a1y) / denom, S(b2 * a1x - b1 * a2x) / denom)

.sympy.integrals.intpoly.is_vertex

def is_vertex(ent):
    if isinstance(ent, tuple):
        if len(ent) in [2, 3]:
            return True
    elif isinstance(ent, Point):
        return True
    return False

.sympy.core.basic.Basic.subs

def subs(self, *args, **kwargs):
    from .containers import Dict
    from .symbol import Dummy, Symbol
    from .numbers import _illegal
    unordered = False
    if len(args) == 1:
        sequence = args[0]
        if isinstance(sequence, set):
            unordered = True
        elif isinstance(sequence, (Dict, Mapping)):
            unordered = True
            sequence = sequence.items()
        elif not iterable(sequence):
            raise ValueError(filldedent('\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.'))
    elif len(args) == 2:
        sequence = [args]
    else:
        raise ValueError('subs accepts either 1 or 2 arguments')
    sequence = list(sequence)
    for i, s in enumerate(sequence):
        if isinstance(s[0], str):
            s = (Symbol(s[0]), s[1])
        try:
            s = [sympify(_, strict=not isinstance(_, (str, type))) for _ in s]
        except SympifyError:
            sequence[i] = None
            continue
        sequence[i] = None if _aresame(*s) else tuple(s)
    sequence = list(filter(None, sequence))
    simultaneous = kwargs.pop('simultaneous', False)
    if unordered:
        from .sorting import _nodes, default_sort_key
        sequence = dict(sequence)
        k = list(ordered(sequence, default=False, keys=(lambda x: -_nodes(x), default_sort_key)))
        sequence = [(k, sequence[k]) for k in k]
        if not simultaneous:
            redo = []
            for i in range(len(sequence)):
                if sequence[i][1] in _illegal:
                    redo.append(i)
            for i in reversed(redo):
                sequence.insert(0, sequence.pop(i))
    if simultaneous:
        reps = {}
        rv = self
        kwargs['hack2'] = True
        m = Dummy('subs_m')
        for old, new in sequence:
            com = new.is_commutative
            if com is None:
                com = True
            d = Dummy('subs_d', commutative=com)
            rv = rv._subs(old, d * m, **kwargs)
            if not isinstance(rv, Basic):
                break
            reps[d] = new
        reps[m] = S.One
        return rv.xreplace(reps)
    else:
        rv = self
        for old, new in sequence:
            rv = rv._subs(old, new, **kwargs)
            if not isinstance(rv, Basic):
                break
        return rv

.sympy.core.basic._aresame

def _aresame(a, b):
    from .numbers import Number
    from .function import AppliedUndef, UndefinedFunction as UndefFunc
    if isinstance(a, Number) and isinstance(b, Number):
        return a == b and a.__class__ == b.__class__
    for i, j in zip_longest(_preorder_traversal(a), _preorder_traversal(b)):
        if i != j or type(i) != type(j):
            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):
                if i.class_key() != j.class_key():
                    return False
            else:
                return False
    return True

.sympy.core.sorting._nodes

def _nodes(e):
    from .basic import Basic
    from .function import Derivative
    if isinstance(e, Basic):
        if isinstance(e, Derivative):
            return _nodes(e.expr) + sum((i[1] if i[1].is_Number else _nodes(i[1]) for i in e.variable_count))
        return _node_count(e)
    elif iterable(e):
        return 1 + sum((_nodes(ei) for ei in e))
    elif isinstance(e, dict):
        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))
    else:
        return 1

.sympy.core.sorting._node_count

def _node_count(e):
    if e.is_Float:
        return 0.5
    return 1 + sum(map(_node_count, e.args))

.sympy.core.symbol.Symbol.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)

.sympy.core.basic.Atom.class_key

def class_key(cls):
    return (2, 0, cls.__name__)

.sympy.core.numbers.NaN.__eq__

def __eq__(self, other):
    return other is S.NaN

.sympy.core.basic.Basic._subs

def _subs(self, old, new, **hints):

    def fallback(self, old, new):
        hit = False
        args = list(self.args)
        for i, arg in enumerate(args):
            if not hasattr(arg, '_eval_subs'):
                continue
            arg = arg._subs(old, new, **hints)
            if not _aresame(arg, args[i]):
                hit = True
                args[i] = arg
        if hit:
            rv = self.func(*args)
            hack2 = hints.get('hack2', False)
            if hack2 and self.is_Mul and (not rv.is_Mul):
                coeff = S.One
                nonnumber = []
                for i in args:
                    if i.is_Number:
                        coeff *= i
                    else:
                        nonnumber.append(i)
                nonnumber = self.func(*nonnumber)
                if coeff is S.One:
                    return nonnumber
                else:
                    return self.func(coeff, nonnumber, evaluate=False)
            return rv
        return self
    if _aresame(self, old):
        return new
    rv = self._eval_subs(old, new)
    if rv is None:
        rv = fallback(self, old, new)
    return rv

.sympy.core.numbers.Number._eval_subs

def _eval_subs(self, old, new):
    if old == -self:
        return -new
    return self

.sympy.core.symbol.Symbol._eval_subs

def _eval_subs(self, old, new):
    if old.is_Pow:
        from sympy.core.power import Pow
        return Pow(self, S.One, evaluate=False)._eval_subs(old, new)

.sympy.core.basic.Basic.fallback

def fallback(self, old, new):
    hit = False
    args = list(self.args)
    for i, arg in enumerate(args):
        if not hasattr(arg, '_eval_subs'):
            continue
        arg = arg._subs(old, new, **hints)
        if not _aresame(arg, args[i]):
            hit = True
            args[i] = arg
    if hit:
        rv = self.func(*args)
        hack2 = hints.get('hack2', False)
        if hack2 and self.is_Mul and (not rv.is_Mul):
            coeff = S.One
            nonnumber = []
            for i in args:
                if i.is_Number:
                    coeff *= i
                else:
                    nonnumber.append(i)
            nonnumber = self.func(*nonnumber)
            if coeff is S.One:
                return nonnumber
            else:
                return self.func(coeff, nonnumber, evaluate=False)
        return rv
    return self

.sympy.core.power.Pow._eval_subs

def _eval_subs(self, old, new):
    from sympy.calculus.accumulationbounds import AccumBounds
    if isinstance(self.exp, AccumBounds):
        b = self.base.subs(old, new)
        e = self.exp.subs(old, new)
        if isinstance(e, AccumBounds):
            return e.__rpow__(b)
        return self.func(b, e)
    from sympy.functions.elementary.exponential import exp, log

    def _check(ct1, ct2, old):
        coeff1, terms1 = ct1
        coeff2, terms2 = ct2
        if terms1 == terms2:
            if old.is_commutative:
                pow = coeff1 / coeff2
                try:
                    as_int(pow, strict=False)
                    combines = True
                except ValueError:
                    b, e = old.as_base_exp()
                    combines = b.is_positive and e.is_real or (b.is_nonnegative and e.is_nonnegative)
                return (combines, pow, None)
            else:
                if not isinstance(terms1, tuple):
                    terms1 = (terms1,)
                if not all((term.is_integer for term in terms1)):
                    return (False, None, None)
                try:
                    pow, remainder = divmod(as_int(coeff1), as_int(coeff2))
                    if pow < 0 and remainder != 0:
                        pow += 1
                        remainder -= as_int(coeff2)
                    if remainder == 0:
                        remainder_pow = None
                    else:
                        remainder_pow = Mul(remainder, *terms1)
                    return (True, pow, remainder_pow)
                except ValueError:
                    pass
        return (False, None, None)
    if old == self.base or (old == exp and self.base == S.Exp1):
        if new.is_Function and isinstance(new, Callable):
            return new(self.exp._subs(old, new))
        else:
            return new ** self.exp._subs(old, new)
    if isinstance(old, self.func) and self.exp == old.exp:
        l = log(self.base, old.base)
        if l.is_Number:
            return Pow(new, l)
    if isinstance(old, self.func) and self.base == old.base:
        if self.exp.is_Add is False:
            ct1 = self.exp.as_independent(Symbol, as_Add=False)
            ct2 = old.exp.as_independent(Symbol, as_Add=False)
            ok, pow, remainder_pow = _check(ct1, ct2, old)
            if ok:
                result = self.func(new, pow)
                if remainder_pow is not None:
                    result = Mul(result, Pow(old.base, remainder_pow))
                return result
        else:
            oarg = old.exp
            new_l = []
            o_al = []
            ct2 = oarg.as_coeff_mul()
            for a in self.exp.args:
                newa = a._subs(old, new)
                ct1 = newa.as_coeff_mul()
                ok, pow, remainder_pow = _check(ct1, ct2, old)
                if ok:
                    new_l.append(new ** pow)
                    if remainder_pow is not None:
                        o_al.append(remainder_pow)
                    continue
                elif not old.is_commutative and (not newa.is_integer):
                    return
                o_al.append(newa)
            if new_l:
                expo = Add(*o_al)
                new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)
                return Mul(*new_l)
    if (isinstance(old, exp) or (old.is_Pow and old.base is S.Exp1)) and self.exp.is_extended_real and self.base.is_positive:
        ct1 = old.exp.as_independent(Symbol, as_Add=False)
        ct2 = (self.exp * log(self.base)).as_independent(Symbol, as_Add=False)
        ok, pow, remainder_pow = _check(ct1, ct2, old)
        if ok:
            result = self.func(new, pow)
            if remainder_pow is not None:
                result = Mul(result, Pow(old.base, remainder_pow))
            return result

.sympy.core.numbers.Integer.__neg__

def __neg__(self):
    return Integer(-self.p)

.sympy.core.mul.Mul._eval_subs

def _eval_subs(self, old, new):
    from sympy.functions.elementary.complexes import sign
    from sympy.ntheory.factor_ import multiplicity
    from sympy.simplify.powsimp import powdenest
    from sympy.simplify.radsimp import fraction
    if not old.is_Mul:
        return None
    if old.args[0].is_Number and old.args[0] < 0:
        if self.args[0].is_Number:
            if self.args[0] < 0:
                return self._subs(-old, -new)
            return None

    def base_exp(a):
        from sympy.functions.elementary.exponential import exp
        if a.is_Pow or isinstance(a, exp):
            return a.as_base_exp()
        return (a, S.One)

    def breakup(eq):
        c, nc = (defaultdict(int), list())
        for a in Mul.make_args(eq):
            a = powdenest(a)
            b, e = base_exp(a)
            if e is not S.One:
                co, _ = e.as_coeff_mul()
                b = Pow(b, e / co)
                e = co
            if a.is_commutative:
                c[b] += e
            else:
                nc.append([b, e])
        return (c, nc)

    def rejoin(b, co):
        b, e = base_exp(b)
        return Pow(b, e * co)

    def ndiv(a, b):
        if not b.q % a.q or not a.q % b.q:
            return int(a / b)
        return 0
    rv = None
    n, d = fraction(self)
    self2 = self
    if d is not S.One:
        self2 = n._subs(old, new) / d._subs(old, new)
        if not self2.is_Mul:
            return self2._subs(old, new)
        if self2 != self:
            rv = self2
    co_self = self2.args[0]
    co_old = old.args[0]
    co_xmul = None
    if co_old.is_Rational and co_self.is_Rational:
        if co_old != co_self:
            co_xmul = co_self.extract_multiplicatively(co_old)
    elif co_old.is_Rational:
        return rv
    c, nc = breakup(self2)
    old_c, old_nc = breakup(old)
    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):
        mult = S(multiplicity(abs(co_old), co_self))
        c.pop(co_self)
        if co_old in c:
            c[co_old] += mult
        else:
            c[co_old] = mult
        co_residual = co_self / co_old ** mult
    else:
        co_residual = 1
    ok = True
    if len(old_nc) > len(nc):
        ok = False
    elif len(old_c) > len(c):
        ok = False
    elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):
        ok = False
    elif set(old_c).difference(set(c)):
        ok = False
    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):
        ok = False
    if not ok:
        return rv
    if not old_c:
        cdid = None
    else:
        rat = []
        for b, old_e in old_c.items():
            c_e = c[b]
            rat.append(ndiv(c_e, old_e))
            if not rat[-1]:
                return rv
        cdid = min(rat)
    if not old_nc:
        ncdid = None
        for i in range(len(nc)):
            nc[i] = rejoin(*nc[i])
    else:
        ncdid = 0
        take = len(old_nc)
        limit = cdid or S.Infinity
        failed = []
        i = 0
        while limit and i + take <= len(nc):
            hit = False
            rat = []
            for j in range(take):
                if nc[i + j][0] != old_nc[j][0]:
                    break
                elif j == 0:
                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
                elif j == take - 1:
                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
                elif nc[i + j][1] != old_nc[j][1]:
                    break
                else:
                    rat.append(1)
                j += 1
            else:
                ndo = min(rat)
                if ndo:
                    if take == 1:
                        if cdid:
                            ndo = min(cdid, ndo)
                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])
                    else:
                        ndo = 1
                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])
                        mid = new
                        ir = i + take - 1
                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])
                        if r[1]:
                            if i + take < len(nc):
                                nc[i:i + take] = [l * mid, r]
                            else:
                                r = rejoin(*r)
                                nc[i:i + take] = [l * mid * r]
                        else:
                            nc[i:i + take] = [l * mid]
                    limit -= ndo
                    ncdid += ndo
                    hit = True
            if not hit:
                failed.append(i)
            i += 1
        else:
            if not ncdid:
                return rv
            failed.extend(range(i, len(nc)))
            for i in failed:
                nc[i] = rejoin(*nc[i]).subs(old, new)
    if cdid is None:
        do = ncdid
    elif ncdid is None:
        do = cdid
    else:
        do = min(ncdid, cdid)
    margs = []
    for b in c:
        if b in old_c:
            e = c[b] - old_c[b] * do
            margs.append(rejoin(b, e))
        else:
            margs.append(rejoin(b.subs(old, new), c[b]))
    if cdid and (not ncdid):
        margs = [Pow(new, cdid)] + margs
    return co_residual * self2.func(*margs) * self2.func(*nc)

.sympy.core.numbers.Rational.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p + self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return other + self
        else:
            return Number.__add__(self, other)
    return Number.__add__(self, other)

.sympy.simplify.simplify.nsimplify

def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None, rational_conversion='base10'):
    try:
        return sympify(as_int(expr))
    except (TypeError, ValueError):
        pass
    expr = sympify(expr).xreplace({Float('inf'): S.Infinity, Float('-inf'): S.NegativeInfinity})
    if expr is S.Infinity or expr is S.NegativeInfinity:
        return expr
    if rational or expr.free_symbols:
        return _real_to_rational(expr, tolerance, rational_conversion)
    if tolerance is None:
        tolerance = 10 ** (-min([15] + [mpmath.libmp.libmpf.prec_to_dps(n._prec) for n in expr.atoms(Float)]))
    prec = 30
    bprec = int(prec * 3.33)
    constants_dict = {}
    for constant in constants:
        constant = sympify(constant)
        v = constant.evalf(prec)
        if not v.is_Float:
            raise ValueError('constants must be real-valued')
        constants_dict[str(constant)] = v._to_mpmath(bprec)
    exprval = expr.evalf(prec, chop=True)
    re, im = exprval.as_real_imag()
    if not (re.is_Number and im.is_Number):
        return expr

    def nsimplify_real(x):
        orig = mpmath.mp.dps
        xv = x._to_mpmath(bprec)
        try:
            if not (tolerance or full):
                mpmath.mp.dps = 15
                rat = mpmath.pslq([xv, 1])
                if rat is not None:
                    return Rational(-int(rat[1]), int(rat[0]))
            mpmath.mp.dps = prec
            newexpr = mpmath.identify(xv, constants=constants_dict, tol=tolerance, full=full)
            if not newexpr:
                raise ValueError
            if full:
                newexpr = newexpr[0]
            expr = sympify(newexpr)
            if x and (not expr):
                raise ValueError
            if expr.is_finite is False and xv not in [mpmath.inf, mpmath.ninf]:
                raise ValueError
            return expr
        finally:
            mpmath.mp.dps = orig
    try:
        if re:
            re = nsimplify_real(re)
        if im:
            im = nsimplify_real(im)
    except ValueError:
        if rational is None:
            return _real_to_rational(expr, rational_conversion=rational_conversion)
        return expr
    rv = re + im * S.ImaginaryUnit
    if rv != expr or rational is False:
        return rv
    return _real_to_rational(expr, rational_conversion=rational_conversion)

.sympy.integrals.intpoly.strip

def strip(monom):
    if monom.is_zero:
        return (S.Zero, S.Zero)
    elif monom.is_number:
        return (monom, S.One)
    else:
        coeff = LC(monom)
        return (coeff, monom / coeff)

.sympy.core.numbers.NegativeInfinity.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.core.basic.Atom.xreplace

def xreplace(self, rule, hack2=False):
    return rule.get(self, self)

.sympy.core.symbol.Symbol.free_symbols

def free_symbols(self):
    return {self}

.sympy.simplify.simplify._real_to_rational

def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):
    expr = _sympify(expr)
    inf = Float('inf')
    p = expr
    reps = {}
    reduce_num = None
    if tolerance is not None and tolerance < 1:
        reduce_num = ceiling(1 / tolerance)
    for fl in p.atoms(Float):
        key = fl
        if reduce_num is not None:
            r = Rational(fl).limit_denominator(reduce_num)
        elif tolerance is not None and tolerance >= 1 and (fl.is_Integer is False):
            r = Rational(tolerance * round(fl / tolerance)).limit_denominator(int(tolerance))
        else:
            if rational_conversion == 'exact':
                r = Rational(fl)
                reps[key] = r
                continue
            elif rational_conversion != 'base10':
                raise ValueError("rational_conversion must be 'base10' or 'exact'")
            r = nsimplify(fl, rational=False)
            if fl and (not r):
                r = Rational(fl)
            elif not r.is_Rational:
                if fl in (inf, -inf):
                    r = S.ComplexInfinity
                elif fl < 0:
                    fl = -fl
                    d = Pow(10, int(mpmath.log(fl) / mpmath.log(10)))
                    r = -Rational(str(fl / d)) * d
                elif fl > 0:
                    d = Pow(10, int(mpmath.log(fl) / mpmath.log(10)))
                    r = Rational(str(fl / d)) * d
                else:
                    r = S.Zero
        reps[key] = r
    return p.subs(reps, simultaneous=True)

.sympy.core.symbol.Dummy.__new__

def __new__(cls, name=None, dummy_index=None, **assumptions):
    if dummy_index is not None:
        assert name is not None, 'If you specify a dummy_index, you must also provide a name'
    if name is None:
        name = 'Dummy_' + str(Dummy._count)
    if dummy_index is None:
        dummy_index = Dummy._base_dummy_index + Dummy._count
        Dummy._count += 1
    cls._sanitize(assumptions, cls)
    obj = Symbol.__xnew__(cls, name, **assumptions)
    obj.dummy_index = dummy_index
    return obj

.sympy.core.symbol.Symbol._sanitize

def _sanitize(assumptions, obj=None):
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    if is_commutative is None:
        whose = '%s ' % obj.__name__ if obj else ''
        raise ValueError('%scommutativity must be True or False.' % whose)
    for key in list(assumptions.keys()):
        v = assumptions[key]
        if v is None:
            assumptions.pop(key)
            continue
        assumptions[key] = bool(v)

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.core.symbol.Symbol.__new_stage2__

def __new_stage2__(cls, name, **assumptions):
    if not isinstance(name, str):
        raise TypeError('name should be a string, not %s' % repr(type(name)))
    obj = Expr.__new__(cls)
    obj.name = name
    tmp_asm_copy = assumptions.copy()
    is_commutative = fuzzy_bool(assumptions.get('commutative', True))
    assumptions['commutative'] = is_commutative
    obj._assumptions = StdFactKB(assumptions)
    obj._assumptions._generator = tmp_asm_copy
    return obj

.sympy.core.symbol.Dummy._hashable_content

def _hashable_content(self):
    return Symbol._hashable_content(self) + (self.dummy_index,)

.sympy.polys.polytools.LC

def LC(f, *gens, **args):
    options.allowed_flags(args, ['polys'])
    try:
        F, opt = poly_from_expr(f, *gens, **args)
    except PolificationFailed as exc:
        raise ComputationFailed('LC', 1, exc)
    return F.LC(order=opt.order)

.sympy.polys.polyoptions.allowed_flags

def allowed_flags(args, flags):
    flags = set(flags)
    for arg in args.keys():
        try:
            if Options.__options__[arg].is_Flag and arg not in flags:
                raise FlagError("'%s' flag is not allowed in this context" % arg)
        except KeyError:
            raise OptionError("'%s' is not a valid option" % arg)

.sympy.polys.polytools.poly_from_expr

def poly_from_expr(expr, *gens, **args):
    opt = options.build_options(gens, args)
    return _poly_from_expr(expr, opt)

.sympy.polys.polytools._poly_from_expr

def _poly_from_expr(expr, opt):
    orig, expr = (expr, sympify(expr))
    if not isinstance(expr, Basic):
        raise PolificationFailed(opt, orig, expr)
    elif expr.is_Poly:
        poly = expr.__class__._from_poly(expr, opt)
        opt.gens = poly.gens
        opt.domain = poly.domain
        if opt.polys is None:
            opt.polys = True
        return (poly, opt)
    elif opt.expand:
        expr = expr.expand()
    rep, opt = _dict_from_expr(expr, opt)
    if not opt.gens:
        raise PolificationFailed(opt, orig, expr)
    monoms, coeffs = list(zip(*list(rep.items())))
    domain = opt.domain
    if domain is None:
        opt.domain, coeffs = construct_domain(coeffs, opt=opt)
    else:
        coeffs = list(map(domain.from_sympy, coeffs))
    rep = dict(list(zip(monoms, coeffs)))
    poly = Poly._from_dict(rep, opt)
    if opt.polys is None:
        opt.polys = False
    return (poly, opt)

.sympy.polys.polyoptions.Options.__setattr__

def __setattr__(self, attr, value):
    if attr in self.__options__:
        self[attr] = value
    else:
        super().__setattr__(attr, value)

.sympy.polys.domains.domain.Domain.of_type

def of_type(self, element):
    return isinstance(element, self.tp)

.sympy.polys.polyoptions.Order.default

def default(cls):
    return sympy.polys.orderings.lex

.sympy.polys.polytools.Poly.LC

def LC(f, order=None):
    if order is not None:
        return f.coeffs(order)[0]
    if hasattr(f.rep, 'LC'):
        result = f.rep.LC()
    else:
        raise OperationNotSupported(f, 'LC')
    return f.rep.dom.to_sympy(result)

.sympy.polys.polytools.Poly.coeffs

def coeffs(f, order=None):
    return [f.rep.dom.to_sympy(c) for c in f.rep.coeffs(order=order)]

.sympy.polys.polyclasses.DMP.coeffs

def coeffs(f, order=None):
    return [c for _, c in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]

.sympy.polys.orderings.monomial_key

def monomial_key(order=None, gens=None):
    if order is None:
        order = lex
    if isinstance(order, Symbol):
        order = str(order)
    if isinstance(order, str):
        try:
            order = _monomial_key[order]
        except KeyError:
            raise ValueError("supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r" % order)
    if hasattr(order, '__call__'):
        if gens is not None:

            def _order(expr):
                return order(expr.as_poly(*gens).degree_list())
            return _order
        return order
    else:
        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)

.sympy.polys.densebasic.sort

def sort(terms, O):
    return sorted(terms, key=lambda term: O(term[0]), reverse=True)

.sympy.polys.orderings.LexOrder.__call__

def __call__(self, monomial):
    return monomial

.sympy.printing.str.StrPrinter._print_Mul

def _print_Mul(self, expr):
    prec = precedence(expr)
    args = expr.args
    if args[0] is S.One or any((isinstance(a, Number) or (a.is_Pow and all((ai.is_Integer for ai in a.args))) for a in args[1:])):
        d, n = sift(args, lambda x: isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0), binary=True)
        for i, di in enumerate(d):
            if di.exp.is_Number:
                e = -di.exp
            else:
                dargs = list(di.exp.args)
                dargs[0] = -dargs[0]
                e = Mul._from_args(dargs)
            d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base
        pre = []
        if n and n[0].could_extract_minus_sign():
            pre = [str(n.pop(0))]
        nfactors = pre + [self.parenthesize(a, prec, strict=False) for a in n]
        if not nfactors:
            nfactors = ['1']
        if len(d) > 1 and d[0].could_extract_minus_sign():
            pre = [str(d.pop(0))]
        else:
            pre = []
        dfactors = pre + [self.parenthesize(a, prec, strict=False) for a in d]
        n = '*'.join(nfactors)
        d = '*'.join(dfactors)
        if len(dfactors) > 1:
            return '%s/(%s)' % (n, d)
        elif dfactors:
            return '%s/%s' % (n, d)
        return n
    c, e = expr.as_coeff_Mul()
    if c < 0:
        expr = _keep_coeff(-c, e)
        sign = '-'
    else:
        sign = ''
    a = []
    b = []
    pow_paren = []
    if self.order not in ('old', 'none'):
        args = expr.as_ordered_factors()
    else:
        args = Mul.make_args(expr)

    def apow(i):
        b, e = i.as_base_exp()
        eargs = list(Mul.make_args(e))
        if eargs[0] is S.NegativeOne:
            eargs = eargs[1:]
        else:
            eargs[0] = -eargs[0]
        e = Mul._from_args(eargs)
        if isinstance(i, Pow):
            return i.func(b, e, evaluate=False)
        return i.func(e, evaluate=False)
    for item in args:
        if item.is_commutative and isinstance(item, Pow) and bool(item.exp.as_coeff_Mul()[0] < 0):
            if item.exp is not S.NegativeOne:
                b.append(apow(item))
            else:
                if len(item.args[0].args) != 1 and isinstance(item.base, (Mul, Pow)):
                    pow_paren.append(item)
                b.append(item.base)
        elif item.is_Rational and item is not S.Infinity:
            if item.p != 1:
                a.append(Rational(item.p))
            if item.q != 1:
                b.append(Rational(item.q))
        else:
            a.append(item)
    a = a or [S.One]
    a_str = [self.parenthesize(x, prec, strict=False) for x in a]
    b_str = [self.parenthesize(x, prec, strict=False) for x in b]
    for item in pow_paren:
        if item.base in b:
            b_str[b.index(item.base)] = '(%s)' % b_str[b.index(item.base)]
    if not b:
        return sign + '*'.join(a_str)
    elif len(b) == 1:
        return sign + '*'.join(a_str) + '/' + b_str[0]
    else:
        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)

.sympy.printing.precedence.precedence

def precedence(item):
    if hasattr(item, 'precedence'):
        return item.precedence
    try:
        mro = item.__class__.__mro__
    except AttributeError:
        return PRECEDENCE['Atom']
    for i in mro:
        n = i.__name__
        if n in PRECEDENCE_FUNCTIONS:
            return PRECEDENCE_FUNCTIONS[n](item)
        elif n in PRECEDENCE_VALUES:
            return PRECEDENCE_VALUES[n]
    return PRECEDENCE['Atom']

.sympy.printing.precedence.precedence_Mul

def precedence_Mul(item):
    if item.could_extract_minus_sign():
        return PRECEDENCE['Add']
    return PRECEDENCE['Mul']

.sympy.core.mul.Mul.could_extract_minus_sign

def could_extract_minus_sign(self):
    if self == -self:
        return False
    c = self.args[0]
    return c.is_Number and c.is_extended_negative

.sympy.core.mul.Mul.__neg__

def __neg__(self):
    c, args = self.as_coeff_mul()
    if args[0] is not S.ComplexInfinity:
        c = -c
    if c is not S.One:
        if args[0].is_Number:
            args = list(args)
            if c is S.NegativeOne:
                args[0] = -args[0]
            else:
                args[0] *= c
        else:
            args = (c,) + args
    return self._from_args(args, self.is_commutative)

.sympy.core.mul.Mul.as_coeff_mul

def as_coeff_mul(self, *deps, rational=True, **kwargs):
    if deps:
        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)
        return (self._new_rawargs(*l2), tuple(l1))
    args = self.args
    if args[0].is_Number:
        if not rational or args[0].is_Rational:
            return (args[0], args[1:])
        elif args[0].is_extended_negative:
            return (S.NegativeOne, (-args[0],) + args[1:])
    return (S.One, args)

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_extended_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.printing.printer.Printer.order

def order(self):
    if 'order' in self._settings:
        return self._settings['order']
    else:
        raise AttributeError('No order defined.')

.sympy.core.mul.Mul.as_ordered_factors

def as_ordered_factors(self, order=None):
    cpart, ncpart = self.args_cnc()
    cpart.sort(key=lambda expr: expr.sort_key(order=order))
    return cpart + ncpart

.sympy.core.expr.Expr.args_cnc

def args_cnc(self, cset=False, warn=True, split_1=True):
    if self.is_Mul:
        args = list(self.args)
    else:
        args = [self]
    for i, mi in enumerate(args):
        if not mi.is_commutative:
            c = args[:i]
            nc = args[i:]
            break
    else:
        c = args
        nc = []
    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):
        c[:1] = [S.NegativeOne, -c[0]]
    if cset:
        clen = len(c)
        c = set(c)
        if clen and warn and (len(c) != clen):
            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])
    return [c, nc]

.sympy.printing.str.StrPrinter.parenthesize

def parenthesize(self, item, level, strict=False):
    if precedence(item) < level or (not strict and precedence(item) <= level):
        return '(%s)' % self._print(item)
    else:
        return self._print(item)

.sympy.core.basic.Basic.free_symbols

def free_symbols(self) -> 'Set[Basic]':
    empty: 'Set[Basic]' = set()
    return empty.union(*(a.free_symbols for a in self.args))

.sympy.core.expr.Expr.sort_key

def sort_key(self, order=None):
    coeff, expr = self.as_coeff_Mul()
    if expr.is_Pow:
        if expr.base is S.Exp1:
            expr, exp = (Function('exp')(expr.exp), S.One)
        else:
            expr, exp = expr.args
    else:
        exp = S.One
    if expr.is_Dummy:
        args = (expr.sort_key(),)
    elif expr.is_Atom:
        args = (str(expr),)
    else:
        if expr.is_Add:
            args = expr.as_ordered_terms(order=order)
        elif expr.is_Mul:
            args = expr.as_ordered_factors(order=order)
        else:
            args = expr.args
        args = tuple([default_sort_key(arg, order=order) for arg in args])
    args = (len(args), tuple(args))
    exp = exp.sort_key(order=order)
    return (expr.class_key(), args, exp, coeff)

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational: bool=False) -> tTuple['Number', 'Expr']:
    return (S.One, self)

.sympy.printing.str.StrPrinter._print_Pow

def _print_Pow(self, expr, rational=False):
    PREC = precedence(expr)
    if expr.exp is S.Half and (not rational):
        return 'sqrt(%s)' % self._print(expr.base)
    if expr.is_commutative:
        if -expr.exp is S.Half and (not rational):
            return '%s/sqrt(%s)' % tuple(map(lambda arg: self._print(arg), (S.One, expr.base)))
        if expr.exp is -S.One:
            return '%s/%s' % (self._print(S.One), self.parenthesize(expr.base, PREC, strict=False))
    e = self.parenthesize(expr.exp, PREC, strict=False)
    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and (expr.exp.q != 1):
        if e.startswith('(Rational'):
            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)

.sympy.printing.precedence.precedence_Integer

def precedence_Integer(item):
    if item.p < 0:
        return PRECEDENCE['Add']
    return PRECEDENCE['Atom']

.sympy.printing.str.StrPrinter._print_Integer

def _print_Integer(self, expr):
    if self._settings.get('sympy_integers', False):
        return 'S(%s)' % expr
    return str(expr.p)


[/PYTHON]
What will be the input of `polytope_integrate`, given the following output:
[OUTPUT]
```
{
    "output": "1/8"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {},
    "args": {
        "poly": {},
        "expr": XXX
    },
    "kwargs": {
        "clockwise": XXX
    }
}
```
[/STRUCTURE]

[THOUGHT]
