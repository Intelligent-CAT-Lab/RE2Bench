You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. You need to predict output variable values, and print output between [OUTPUT] and [/OUTPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[PYTHON]
from functools import cmp_to_key
from sympy.abc import x, y, z
from sympy.core import S, diff, Expr, Symbol
from sympy.core.sympify import _sympify
from sympy.geometry import Segment2D, Polygon, Point, Point2D
from sympy.polys.polytools import LC, gcd_list, degree_list, Poly
from sympy.simplify.simplify import nsimplify
from sympy.plotting.plot import Plot, List2DSeries
from sympy.plotting.plot import plot3d, plot

def _polynomial_integrate(polynomials, facets, hp_params):
    dims = (x, y)
    dim_length = len(dims)
    integral_value = S.Zero
    for deg in polynomials:
        poly_contribute = S.Zero
        facet_count = 0
        for hp in hp_params:
            value_over_boundary = integration_reduction(facets, facet_count, hp[0], hp[1], polynomials[deg], dims, deg)
            poly_contribute += value_over_boundary * (hp[1] / norm(hp[0]))
            facet_count += 1
        poly_contribute /= dim_length + deg
        integral_value += poly_contribute
    return integral_value
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.integrals.intpoly.integration_reduction

def integration_reduction(facets, index, a, b, expr, dims, degree):
    expr = _sympify(expr)
    if expr.is_zero:
        return expr
    value = S.Zero
    x0 = facets[index].points[0]
    m = len(facets)
    gens = (x, y)
    inner_product = diff(expr, gens[0]) * x0[0] + diff(expr, gens[1]) * x0[1]
    if inner_product != 0:
        value += integration_reduction(facets, index, a, b, inner_product, dims, degree - 1)
    value += left_integral2D(m, index, facets, x0, expr, gens)
    return value / (len(dims) + degree - 1)

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    is_sympy = getattr(a, '__sympy__', None)
    if is_sympy is True:
        return a
    elif is_sympy is not None:
        if not strict:
            return a
        else:
            raise SympifyError(a)
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    cls = getattr(a, '__class__', None)
    for superclass in getmro(cls):
        conv = _external_converter.get(superclass)
        if conv is None:
            conv = _sympy_converter.get(superclass)
        if conv is not None:
            return conv(a)
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if _is_numpy_instance(a):
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
    _sympy_ = getattr(a, '_sympy_', None)
    if _sympy_ is not None:
        try:
            return a._sympy_()
        except AttributeError:
            pass
    if not strict:
        flat = getattr(a, 'flat', None)
        if flat is not None:
            shape = getattr(a, 'shape', None)
            if shape is not None:
                from sympy.tensor.array import Array
                return Array(a.flat, a.shape)
    if not isinstance(a, str):
        if _is_numpy_instance(a):
            import numpy as np
            assert not isinstance(a, np.number)
            if isinstance(a, np.ndarray):
                if a.ndim == 0:
                    try:
                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)
                    except SympifyError:
                        pass
        else:
            for coerce in (float, int):
                try:
                    return sympify(coerce(a))
                except (TypeError, ValueError, AttributeError, SympifyError):
                    continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])
        except TypeError:
            pass
    if not isinstance(a, str):
        try:
            a = str(a)
        except Exception as exc:
            raise SympifyError(a, exc)
        sympy_deprecation_warning(f'\nThe string fallback in sympify() is deprecated.\n\nTo explicitly convert the string form of an object, use\nsympify(str(obj)). To add define sympify behavior on custom\nobjects, use sympy.core.sympify.converter or define obj._sympy_\n(see the sympify() docstring).\n\nsympify() performed the string fallback resulting in the following string:\n\n{a!r}\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')
    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations
    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
    from sympy.parsing.sympy_parser import rationalize as t_rationalize
    transformations = standard_transformations
    if rational:
        transformations += (t_rationalize,)
    if convert_xor:
        transformations += (t_convert_xor,)
    try:
        a = a.replace('\n', '')
        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
    except (TokenError, SyntaxError) as exc:
        raise SympifyError('could not parse %r' % a, exc)
    return expr

.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

.sympy.core.assumptions.StdFactKB.copy

def copy(self):
    return self.__class__(self)

.sympy.core.assumptions.StdFactKB.__init__

def __init__(self, facts=None):
    super().__init__(_assume_rules)
    if not facts:
        self._generator = {}
    elif not isinstance(facts, FactKB):
        self._generator = facts.copy()
    else:
        self._generator = facts.generator
    if facts:
        self.deduce_all_facts(facts)

.sympy.core.facts.FactKB.__init__

def __init__(self, rules):
    self.rules = rules

.sympy.core.assumptions._ask

def _ask(fact, obj):
    assumptions = obj._assumptions
    handler_map = obj._prop_handler
    try:
        assumptions._tell(fact, None)
    except InconsistentAssumptions:
        return assumptions[fact]
    try:
        evaluate = handler_map[fact]
    except KeyError:
        pass
    else:
        a = evaluate(obj)
        if a is not None:
            assumptions.deduce_all_facts(((fact, a),))
            return a
    prereq = list(_assume_rules.prereq[fact])
    shuffle(prereq)
    for pk in prereq:
        if pk in assumptions:
            continue
        if pk in handler_map:
            _ask(pk, obj)
            ret_val = assumptions.get(fact)
            if ret_val is not None:
                return ret_val
    return None

.sympy.core.facts.FactKB._tell

def _tell(self, k, v):
    if k in self and self[k] is not None:
        if self[k] == v:
            return False
        else:
            raise InconsistentAssumptions(self, k, v)
    else:
        self[k] = v
        return True

.sympy.core.mul.Mul._eval_is_zero

def _eval_is_zero(self):
    zero = infinite = False
    for a in self.args:
        z = a.is_zero
        if z:
            if infinite:
                return
            zero = True
        else:
            if not a.is_finite:
                if zero:
                    return
                infinite = True
            if zero is False and z is None:
                zero = None
    return zero

.sympy.core.basic.Basic.args

def args(self) -> 'Tuple[Basic, ...]':
    return self._args

.sympy.core.mul.Mul._eval_is_rational

def _eval_is_rational(self):
    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.logic._fuzzy_group

def _fuzzy_group(args, quick_exit=False):
    saw_other = False
    for a in args:
        if a is True:
            continue
        if a is None:
            return
        if quick_exit and saw_other:
            return
        saw_other = True
    return not saw_other

.sympy.core.mul.Mul._eval_is_extended_real

def _eval_is_extended_real(self):
    return self._eval_real_imag(True)

.sympy.core.mul.Mul._eval_real_imag

def _eval_real_imag(self, real):
    zero = False
    t_not_re_im = None
    for t in self.args:
        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:
            return False
        elif t.is_imaginary:
            real = not real
        elif t.is_extended_real:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_extended_real is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        elif t.is_imaginary is False:
            if t_not_re_im:
                return
            t_not_re_im = t
        else:
            return
    if t_not_re_im:
        if t_not_re_im.is_extended_real is False:
            if real:
                return zero
        if t_not_re_im.is_imaginary is False:
            if not real:
                return zero
    elif zero is False:
        return real
    elif real:
        return real

.sympy.core.mul.Mul._eval_is_imaginary

def _eval_is_imaginary(self):
    z = self.is_zero
    if z:
        return False
    if self.is_finite is False:
        return False
    elif z is False and self.is_finite is True:
        return self._eval_real_imag(False)

.sympy.core.mul.Mul._eval_is_finite

def _eval_is_finite(self):
    if all((a.is_finite for a in self.args)):
        return True
    if any((a.is_infinite for a in self.args)):
        if all((a.is_zero is False for a in self.args)):
            return False

.sympy.core.mul.Mul._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):
                return True
            return
        if a is None:
            return
    if all((x.is_real for x in self.args)):
        return False

.sympy.core.facts.FactKB.deduce_all_facts

def deduce_all_facts(self, facts):
    full_implications = self.rules.full_implications
    beta_triggers = self.rules.beta_triggers
    beta_rules = self.rules.beta_rules
    if isinstance(facts, dict):
        facts = facts.items()
    while facts:
        beta_maytrigger = set()
        for k, v in facts:
            if not self._tell(k, v) or v is None:
                continue
            for key, value in full_implications[k, v]:
                self._tell(key, value)
            beta_maytrigger.update(beta_triggers[k, v])
        facts = []
        for bidx in beta_maytrigger:
            bcond, bimpl = beta_rules[bidx]
            if all((self.get(k) is v for k, v in bcond)):
                facts.append(bimpl)

.sympy.core.mul.Mul._eval_is_odd

def _eval_is_odd(self):
    is_integer = self.is_integer
    if is_integer:
        if self.is_zero:
            return False
        from sympy.simplify.radsimp import fraction
        n, d = fraction(self)
        if d.is_Integer and d.is_even:
            from sympy.ntheory.factor_ import trailing
            if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(n) if i.is_even]) - trailing(d.p)).is_positive:
                return False
            return
        r, acc = (True, 1)
        for t in self.args:
            if abs(t) is S.One:
                continue
            assert t.is_integer
            if t.is_even:
                return False
            if r is False:
                pass
            elif acc != 1 and (acc + t).is_odd:
                r = False
            elif t.is_even is None:
                r = None
            acc = t
        return r
    return is_integer

.sympy.core.mul.Mul._eval_is_integer

def _eval_is_integer(self):
    from sympy.ntheory.factor_ import trailing
    is_rational = self._eval_is_rational()
    if is_rational is False:
        return False
    numerators = []
    denominators = []
    unknown = False
    for a in self.args:
        hit = False
        if a.is_integer:
            if abs(a) is not S.One:
                numerators.append(a)
        elif a.is_Rational:
            n, d = a.as_numer_denom()
            if abs(n) is not S.One:
                numerators.append(n)
            if d is not S.One:
                denominators.append(d)
        elif a.is_Pow:
            b, e = a.as_base_exp()
            if not b.is_integer or not e.is_integer:
                hit = unknown = True
            if e.is_negative:
                denominators.append(2 if a is S.Half else Pow(a, S.NegativeOne))
            elif not hit:
                assert not e.is_positive
                assert not e.is_zero
                return
        else:
            return
    if not denominators and (not unknown):
        return True
    allodd = lambda x: all((i.is_odd for i in x))
    alleven = lambda x: all((i.is_even for i in x))
    anyeven = lambda x: any((i.is_even for i in x))
    from .relational import is_gt
    if not numerators and denominators and all((is_gt(_, S.One) for _ in denominators)):
        return False
    elif unknown:
        return
    elif allodd(numerators) and anyeven(denominators):
        return False
    elif anyeven(numerators) and denominators == [2]:
        return True
    elif alleven(numerators) and allodd(denominators) and (Mul(*denominators, evaluate=False) - 1).is_positive:
        return False
    if len(denominators) == 1:
        d = denominators[0]
        if d.is_Integer and d.is_even:
            if (Add(*[i.as_base_exp()[1] for i in numerators if i.is_even]) - trailing(d.p)).is_nonnegative:
                return True
    if len(numerators) == 1:
        n = numerators[0]
        if n.is_Integer and n.is_even:
            if (Add(*[i.as_base_exp()[1] for i in denominators if i.is_even]) - trailing(n.p)).is_positive:
                return False

.sympy.core.mul.Mul._eval_is_algebraic

def _eval_is_algebraic(self):
    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
    if r:
        return r
    elif r is False:
        return self.is_zero

.sympy.core.mul.Mul._eval_is_complex

def _eval_is_complex(self):
    comp = _fuzzy_group((a.is_complex for a in self.args))
    if comp is False:
        if any((a.is_infinite for a in self.args)):
            if any((a.is_zero is not False for a in self.args)):
                return None
            return False
    return comp

.sympy.core.mul.Mul._eval_is_composite

def _eval_is_composite(self):
    number_of_args = 0
    for arg in self.args:
        if not (arg.is_integer and arg.is_positive):
            return None
        if (arg - 1).is_positive:
            number_of_args += 1
    if number_of_args > 1:
        return True

.sympy.core.mul.Mul._eval_is_infinite

def _eval_is_infinite(self):
    if any((a.is_infinite for a in self.args)):
        if any((a.is_zero for a in self.args)):
            return S.NaN.is_infinite
        if any((a.is_zero is None for a in self.args)):
            return None
        return True

.sympy.core.expr.Expr._eval_is_negative

def _eval_is_negative(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_negative = self.is_extended_negative
    if finite is True:
        return extended_negative
    if extended_negative is False:
        return False

.sympy.core.mul.Mul._eval_is_extended_negative

def _eval_is_extended_negative(self):
    return self._eval_pos_neg(-1)

.sympy.core.mul.Mul._eval_pos_neg

def _eval_pos_neg(self, sign):
    saw_NON = saw_NOT = False
    for t in self.args:
        if t.is_extended_positive:
            continue
        elif t.is_extended_negative:
            sign = -sign
        elif t.is_zero:
            if all((a.is_finite for a in self.args)):
                return False
            return
        elif t.is_extended_nonpositive:
            sign = -sign
            saw_NON = True
        elif t.is_extended_nonnegative:
            saw_NON = True
        elif t.is_positive is False:
            sign = -sign
            if saw_NOT:
                return
            saw_NOT = True
        elif t.is_negative is False:
            if saw_NOT:
                return
            saw_NOT = True
        else:
            return
    if sign == 1 and saw_NON is False and (saw_NOT is False):
        return True
    if sign < 0:
        return False

.sympy.core.expr.Expr._eval_is_positive

def _eval_is_positive(self):
    finite = self.is_finite
    if finite is False:
        return False
    extended_positive = self.is_extended_positive
    if finite is True:
        return extended_positive
    if extended_positive is False:
        return False

.sympy.core.mul.Mul._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return self._eval_pos_neg(1)

.sympy.core.mul.Mul._eval_is_hermitian

def _eval_is_hermitian(self):
    return self._eval_herm_antiherm(True)

.sympy.core.mul.Mul._eval_herm_antiherm

def _eval_herm_antiherm(self, real):
    one_nc = zero = one_neither = False
    for t in self.args:
        if not t.is_commutative:
            if one_nc:
                return
            one_nc = True
        if t.is_antihermitian:
            real = not real
        elif t.is_hermitian:
            if not zero:
                z = t.is_zero
                if not z and zero is False:
                    zero = z
                elif z:
                    if all((a.is_finite for a in self.args)):
                        return True
                    return
        elif t.is_hermitian is False:
            if one_neither:
                return
            one_neither = True
        else:
            return
    if one_neither:
        if real:
            return zero
    elif zero is False or real:
        return real

.sympy.core.mul.Mul._eval_is_even

def _eval_is_even(self):
    is_integer = self.is_integer
    if is_integer:
        return fuzzy_not(self.is_odd)
    from sympy.simplify.radsimp import fraction
    n, d = fraction(self)
    if n.is_Integer and n.is_even:
        from sympy.ntheory.factor_ import trailing
        if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(d) if i.is_even]) - trailing(n.p)).is_nonnegative:
            return False
    return is_integer

.sympy.simplify.radsimp.fraction

def fraction(expr, exact=False):
    expr = sympify(expr)
    numer, denom = ([], [])
    for term in Mul.make_args(expr):
        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):
            b, ex = term.as_base_exp()
            if ex.is_negative:
                if ex is S.NegativeOne:
                    denom.append(b)
                elif exact:
                    if ex.is_constant():
                        denom.append(Pow(b, -ex))
                    else:
                        numer.append(term)
                else:
                    denom.append(Pow(b, -ex))
            elif ex.is_positive:
                numer.append(term)
            elif not exact and ex.is_Mul:
                n, d = term.as_numer_denom()
                if n != 1:
                    numer.append(n)
                denom.append(d)
            else:
                numer.append(term)
        elif term.is_Rational and (not term.is_Integer):
            if term.p != 1:
                numer.append(term.p)
            denom.append(term.q)
        else:
            numer.append(term)
    return (Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact))

.sympy.core.operations.AssocOp.make_args

def make_args(cls, expr):
    if isinstance(expr, cls):
        return expr.args
    else:
        return (sympify(expr),)

.sympy.functions.elementary.exponential.ExpMeta.__instancecheck__

def __instancecheck__(cls, instance):
    if exp in instance.__class__.__mro__:
        return True
    return isinstance(instance, Pow) and instance.base is S.Exp1

.sympy.core.operations.AssocOp.__new__

def __new__(cls, *args, evaluate=None, _sympify=True):
    if _sympify:
        args = list(map(_sympify_, args))
    typ = cls._args_type
    if typ is not None:
        from .relational import Relational
        if any((isinstance(arg, Relational) for arg in args)):
            raise TypeError('Relational cannot be used in %s' % cls.__name__)
        for arg in args:
            if not isinstance(arg, typ):
                sympy_deprecation_warning(f'\n\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\nthe arguments has type {type(arg).__name__!r}).\n\nIf you really did intend to use a multiplication or addition operation with\nthis object, use the * or + operator instead.\n\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)
    if evaluate is None:
        evaluate = global_parameters.evaluate
    if not evaluate:
        obj = cls._from_args(args)
        obj = cls._exec_constructor_postprocessors(obj)
        return obj
    args = [a for a in args if a is not cls.identity]
    if len(args) == 0:
        return cls.identity
    if len(args) == 1:
        return args[0]
    c_part, nc_part, order_symbols = cls.flatten(args)
    is_commutative = not nc_part
    obj = cls._from_args(c_part + nc_part, is_commutative)
    obj = cls._exec_constructor_postprocessors(obj)
    if order_symbols is not None:
        from sympy.series.order import Order
        return Order(obj, *order_symbols)
    return obj

.sympy.core.mul.Mul.flatten

def flatten(cls, seq):
    from sympy.calculus.accumulationbounds import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
            seq = [a, b]
        assert a is not S.One
        if not a.is_zero and a.is_Rational:
            r, b = b.as_coeff_Mul()
            if b.is_Add:
                if r is not S.One:
                    ar = a * r
                    if ar is S.One:
                        arb = b
                    else:
                        arb = cls(a * r, b, evaluate=False)
                    rv = ([arb], [], None)
                elif global_parameters.distribute and b.is_commutative:
                    newb = Add(*[_keep_coeff(a, bi) for bi in b.args])
                    rv = ([newb], [], None)
        if rv:
            return rv
    c_part = []
    nc_part = []
    nc_seq = []
    coeff = S.One
    c_powers = []
    num_exp = []
    neg1e = S.Zero
    pnum_rat = {}
    order_symbols = None
    for o in seq:
        if o.is_Order:
            o, order_symbols = o.as_expr_variables(order_symbols)
        if o.is_Mul:
            if o.is_commutative:
                seq.extend(o.args)
            else:
                for q in o.args:
                    if q.is_commutative:
                        seq.append(q)
                    else:
                        nc_seq.append(q)
                seq.append(NC_Marker)
            continue
        elif o.is_Number:
            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):
                return ([S.NaN], [], None)
            elif coeff.is_Number or isinstance(coeff, AccumBounds):
                coeff *= o
                if coeff is S.NaN:
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__mul__(coeff)
            continue
        elif o is S.ComplexInfinity:
            if not coeff:
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o is S.ImaginaryUnit:
            neg1e += S.Half
            continue
        elif o.is_commutative:
            b, e = o.as_base_exp()
            if o.is_Pow:
                if b.is_Number:
                    if e.is_Rational:
                        if e.is_Integer:
                            coeff *= Pow(b, e)
                            continue
                        elif e.is_negative:
                            seq.append(Pow(b, e))
                            continue
                        elif b.is_negative:
                            neg1e += e
                            b = -b
                        if b is not S.One:
                            pnum_rat.setdefault(b, []).append(e)
                        continue
                    elif b.is_positive or e.is_integer:
                        num_exp.append((b, e))
                        continue
            c_powers.append((b, e))
        else:
            if o is not NC_Marker:
                nc_seq.append(o)
            while nc_seq:
                o = nc_seq.pop(0)
                if not nc_part:
                    nc_part.append(o)
                    continue
                o1 = nc_part.pop()
                b1, e1 = o1.as_base_exp()
                b2, e2 = o.as_base_exp()
                new_exp = e1 + e2
                if b1 == b2 and (not new_exp.is_Add):
                    o12 = b1 ** new_exp
                    if o12.is_commutative:
                        seq.append(o12)
                        continue
                    else:
                        nc_seq.insert(0, o12)
                else:
                    nc_part.append(o1)
                    nc_part.append(o)

    def _gather(c_powers):
        common_b = {}
        for b, e in c_powers:
            co = e.as_coeff_Mul()
            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
        for b, d in common_b.items():
            for di, li in d.items():
                d[di] = Add(*li)
        new_c_powers = []
        for b, e in common_b.items():
            new_c_powers.extend([(b, c * t) for t, c in e.items()])
        return new_c_powers
    c_powers = _gather(c_powers)
    num_exp = _gather(num_exp)
    for i in range(2):
        new_c_powers = []
        changed = False
        for b, e in c_powers:
            if e.is_zero:
                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):
                    return ([S.NaN], [], None)
                continue
            if e is S.One:
                if b.is_Number:
                    coeff *= b
                    continue
                p = b
            if e is not S.One:
                p = Pow(b, e)
                if p.is_Pow and (not b.is_Pow):
                    bi = b
                    b, e = p.as_base_exp()
                    if b != bi:
                        changed = True
            c_part.append(p)
            new_c_powers.append((b, e))
        if changed and len({b for b, e in new_c_powers}) != len(new_c_powers):
            c_part = []
            c_powers = _gather(new_c_powers)
        else:
            break
    inv_exp_dict = {}
    for b, e in num_exp:
        inv_exp_dict.setdefault(e, []).append(b)
    for e, b in inv_exp_dict.items():
        inv_exp_dict[e] = cls(*b)
    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
    comb_e = {}
    for b, e in pnum_rat.items():
        comb_e.setdefault(Add(*e), []).append(b)
    del pnum_rat
    num_rat = []
    for e, b in comb_e.items():
        b = cls(*b)
        if e.q == 1:
            coeff *= Pow(b, e)
            continue
        if e.p > e.q:
            e_i, ep = divmod(e.p, e.q)
            coeff *= Pow(b, e_i)
            e = Rational(ep, e.q)
        num_rat.append((b, e))
    del comb_e
    pnew = defaultdict(list)
    i = 0
    while i < len(num_rat):
        bi, ei = num_rat[i]
        grow = []
        for j in range(i + 1, len(num_rat)):
            bj, ej = num_rat[j]
            g = bi.gcd(bj)
            if g is not S.One:
                e = ei + ej
                if e.q == 1:
                    coeff *= Pow(g, e)
                else:
                    if e.p > e.q:
                        e_i, ep = divmod(e.p, e.q)
                        coeff *= Pow(g, e_i)
                        e = Rational(ep, e.q)
                    grow.append((g, e))
                num_rat[j] = (bj / g, ej)
                bi = bi / g
                if bi is S.One:
                    break
        if bi is not S.One:
            obj = Pow(bi, ei)
            if obj.is_Number:
                coeff *= obj
            else:
                for obj in Mul.make_args(obj):
                    if obj.is_Number:
                        coeff *= obj
                    else:
                        assert obj.is_Pow
                        bi, ei = obj.args
                        pnew[ei].append(bi)
        num_rat.extend(grow)
        i += 1
    for e, b in pnew.items():
        pnew[e] = cls(*b)
    if neg1e:
        p, q = neg1e.as_numer_denom()
        n, p = divmod(p, q)
        if n % 2:
            coeff = -coeff
        if q == 2:
            c_part.append(S.ImaginaryUnit)
        elif p:
            neg1e = Rational(p, q)
            for e, b in pnew.items():
                if e == neg1e and b.is_positive:
                    pnew[e] = -b
                    break
            else:
                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
    c_part.extend([Pow(b, e) for e, b in pnew.items()])
    if coeff in (S.Infinity, S.NegativeInfinity):

        def _handle_for_oo(c_part, coeff_sign):
            new_c_part = []
            for t in c_part:
                if t.is_extended_positive:
                    continue
                if t.is_extended_negative:
                    coeff_sign *= -1
                    continue
                new_c_part.append(t)
            return (new_c_part, coeff_sign)
        c_part, coeff_sign = _handle_for_oo(c_part, 1)
        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
        coeff *= coeff_sign
    if coeff is S.ComplexInfinity:
        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]
    elif coeff.is_zero:
        if any((isinstance(c, MatrixExpr) for c in nc_part)):
            return ([coeff], nc_part, order_symbols)
        if any((c.is_finite == False for c in c_part)):
            return ([S.NaN], [], order_symbols)
        return ([coeff], [], order_symbols)
    _new = []
    for i in c_part:
        if i.is_Number:
            coeff *= i
        else:
            _new.append(i)
    c_part = _new
    _mulsort(c_part)
    if coeff is not S.One:
        c_part.insert(0, coeff)
    if global_parameters.distribute and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:
        coeff = c_part[0]
        c_part = [Add(*[coeff * f for f in c_part[1].args])]
    return (c_part, nc_part, order_symbols)

.sympy.core.expr.Expr.as_base_exp

def as_base_exp(self) -> tTuple['Expr', 'Expr']:
    return (self, S.One)

.sympy.core.mul.Mul._gather

def _gather(c_powers):
    common_b = {}
    for b, e in c_powers:
        co = e.as_coeff_Mul()
        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])
    for b, d in common_b.items():
        for di, li in d.items():
            d[di] = Add(*li)
    new_c_powers = []
    for b, e in common_b.items():
        new_c_powers.extend([(b, c * t) for t, c in e.items()])
    return new_c_powers

.sympy.core.numbers.Rational.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    return (self, S.One)

.sympy.core.basic.Basic.__hash__

def __hash__(self) -> int:
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.numbers.Integer.__hash__

def __hash__(self):
    return hash(self.p)

.sympy.core.numbers.Integer.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p * other)
        elif isinstance(other, Integer):
            return Integer(self.p * other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

.sympy.core.numbers.Integer.__new__

def __new__(cls, i):
    if isinstance(i, str):
        i = i.replace(' ', '')
    try:
        ival = int(i)
    except TypeError:
        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)
    if ival == 1:
        return S.One
    if ival == -1:
        return S.NegativeOne
    if ival == 0:
        return S.Zero
    obj = Expr.__new__(cls)
    obj.p = ival
    return obj

.sympy.core.numbers.Zero.__bool__

def __bool__(self):
    return False

.sympy.core.numbers.Infinity.__eq__

def __eq__(self, other):
    return other is S.Infinity or other == float('inf')

.sympy.core.numbers.Integer.__eq__

def __eq__(self, other):
    if isinstance(other, int):
        return self.p == other
    elif isinstance(other, Integer):
        return self.p == other.p
    return Rational.__eq__(self, other)

.sympy.core.numbers.Rational.__eq__

def __eq__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if not isinstance(other, Number):
        return False
    if not self:
        return not other
    if other.is_NumberSymbol:
        if other.is_irrational:
            return False
        return other.__eq__(self)
    if other.is_Rational:
        return self.p == other.p and self.q == other.q
    if other.is_Float:
        if self.q & self.q - 1:
            return False
        s, m, t = other._mpf_[:3]
        if s:
            m = -m
        if not t:
            if not self.is_Integer or self.is_even:
                return False
            return m == self.p
        from .power import integer_log
        if t > 0:
            if not self.is_Integer:
                return False
            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))
        if self.is_Integer:
            return False
        return m == self.p and integer_log(self.q, 2) == (-t, True)
    return False

.sympy.core.numbers.Float.__new__

def __new__(cls, num, dps=None, precision=None):
    if dps is not None and precision is not None:
        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')
    if isinstance(num, str):
        num = num.replace(' ', '').lower()
        if num.startswith('.') and len(num) > 1:
            num = '0' + num
        elif num.startswith('-.') and len(num) > 2:
            num = '-0.' + num[2:]
        elif num in ('inf', '+inf'):
            return S.Infinity
        elif num == '-inf':
            return S.NegativeInfinity
    elif isinstance(num, float) and num == 0:
        num = '0'
    elif isinstance(num, float) and num == float('inf'):
        return S.Infinity
    elif isinstance(num, float) and num == float('-inf'):
        return S.NegativeInfinity
    elif isinstance(num, float) and math.isnan(num):
        return S.NaN
    elif isinstance(num, (SYMPY_INTS, Integer)):
        num = str(num)
    elif num is S.Infinity:
        return num
    elif num is S.NegativeInfinity:
        return num
    elif num is S.NaN:
        return num
    elif _is_numpy_instance(num):
        num = _convert_numpy_types(num)
    elif isinstance(num, mpmath.mpf):
        if precision is None:
            if dps is None:
                precision = num.context.prec
        num = num._mpf_
    if dps is None and precision is None:
        dps = 15
        if isinstance(num, Float):
            return num
        if isinstance(num, str) and _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                dps = max(15, dps)
                precision = dps_to_prec(dps)
    elif precision == '' and dps is None or (precision is None and dps == ''):
        if not isinstance(num, str):
            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')
        ok = None
        if _literal_float(num):
            try:
                Num = decimal.Decimal(num)
            except decimal.InvalidOperation:
                pass
            else:
                isint = '.' not in num
                num, dps = _decimal_to_Rational_prec(Num)
                if num.is_Integer and isint:
                    dps = max(dps, len(str(num).lstrip('-')))
                    precision = dps_to_prec(dps)
                ok = True
        if ok is None:
            raise ValueError('string-float not recognized: %s' % num)
    if precision is None or precision == '':
        precision = dps_to_prec(dps)
    precision = int(precision)
    if isinstance(num, float):
        _mpf_ = mlib.from_float(num, precision, rnd)
    elif isinstance(num, str):
        _mpf_ = mlib.from_str(num, precision, rnd)
    elif isinstance(num, decimal.Decimal):
        if num.is_finite():
            _mpf_ = mlib.from_str(str(num), precision, rnd)
        elif num.is_nan():
            return S.NaN
        elif num.is_infinite():
            if num > 0:
                return S.Infinity
            return S.NegativeInfinity
        else:
            raise ValueError('unexpected decimal value %s' % str(num))
    elif isinstance(num, tuple) and len(num) in (3, 4):
        if isinstance(num[1], str):
            num = list(num)
            if num[1].endswith('L'):
                num[1] = num[1][:-1]
            if num[1].startswith('0x'):
                num[1] = num[1][2:]
            num[1] = MPZ(num[1], 16)
            _mpf_ = tuple(num)
        elif len(num) == 4:
            return Float._new(num, precision)
        else:
            if not all((num[0] in (0, 1), num[1] >= 0, all((type(i) in (int, int) for i in num)))):
                raise ValueError('malformed mpf: %s' % (num,))
            return Float._new((num[0], num[1], num[2], bitcount(num[1])), precision)
    else:
        try:
            _mpf_ = num._as_mpf_val(precision)
        except (NotImplementedError, AttributeError):
            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
    return cls._new(_mpf_, precision, zero=False)

.sympy.core.numbers.NegativeInfinity.__eq__

def __eq__(self, other):
    return other is S.NegativeInfinity or other == float('-inf')

.sympy.core.mul._mulsort

def _mulsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.basic.Basic.compare

def compare(self, other):
    if self is other:
        return 0
    n1 = self.__class__
    n2 = other.__class__
    c = (n1 > n2) - (n1 < n2)
    if c:
        return c
    st = self._hashable_content()
    ot = other._hashable_content()
    c = (len(st) > len(ot)) - (len(st) < len(ot))
    if c:
        return c
    for l, r in zip(st, ot):
        l = Basic(*l) if isinstance(l, frozenset) else l
        r = Basic(*r) if isinstance(r, frozenset) else r
        if isinstance(l, Basic):
            c = l.compare(r)
        else:
            c = (l > r) - (l < r)
        if c:
            return c
    return 0

.sympy.core.core.BasicMeta.__gt__

def __gt__(cls, other):
    if cls.__cmp__(other) == 1:
        return True
    return False

.sympy.core.core.BasicMeta.__cmp__

def __cmp__(cls, other):
    if not isinstance(other, BasicMeta):
        return -1
    n1 = cls.__name__
    n2 = other.__name__
    if n1 == n2:
        return 0
    UNKNOWN = len(ordering_of_classes) + 1
    try:
        i1 = ordering_of_classes.index(n1)
    except ValueError:
        i1 = UNKNOWN
    try:
        i2 = ordering_of_classes.index(n2)
    except ValueError:
        i2 = UNKNOWN
    if i1 == UNKNOWN and i2 == UNKNOWN:
        return (n1 > n2) - (n1 < n2)
    return (i1 > i2) - (i1 < i2)

.sympy.core.core.BasicMeta.__lt__

def __lt__(cls, other):
    if cls.__cmp__(other) == -1:
        return True
    return False

.sympy.core.symbol.Symbol._hashable_content

def _hashable_content(self):
    return (self.name,) + tuple(sorted(self.assumptions0.items()))

.sympy.core.symbol.Symbol.assumptions0

def assumptions0(self):
    return {key: value for key, value in self._assumptions.items() if value is not None}

.sympy.core.operations.AssocOp._from_args

def _from_args(cls, args, is_commutative=None):
    if len(args) == 0:
        return cls.identity
    elif len(args) == 1:
        return args[0]
    obj = super().__new__(cls, *args)
    if is_commutative is None:
        is_commutative = fuzzy_and((a.is_commutative for a in args))
    obj.is_commutative = is_commutative
    return obj

.sympy.core.basic.Basic.__new__

def __new__(cls, *args):
    obj = object.__new__(cls)
    obj._assumptions = cls.default_assumptions
    obj._mhash = None
    obj._args = args
    return obj

.sympy.core.basic.Basic._exec_constructor_postprocessors

def _exec_constructor_postprocessors(cls, obj):
    clsname = obj.__class__.__name__
    postprocessors = defaultdict(list)
    for i in obj.args:
        try:
            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)
            for k, v in chain.from_iterable(postprocessor_mappings):
                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
        except TypeError:
            pass
    for f in postprocessors.get(clsname, []):
        obj = f(obj)
    return obj

.sympy.core.mul.Mul._eval_is_antihermitian

def _eval_is_antihermitian(self):
    z = self.is_zero
    if z:
        return False
    elif z is False:
        return self._eval_herm_antiherm(False)

.sympy.geometry.line.LinearEntity.points

def points(self):
    return (self.p1, self.p2)

.sympy.geometry.line.LinearEntity.p1

def p1(self):
    return self.args[0]

.sympy.geometry.line.LinearEntity.p2

def p2(self):
    return self.args[1]

.sympy.core.function.diff

def diff(f, *symbols, **kwargs):
    if hasattr(f, 'diff'):
        return f.diff(*symbols, **kwargs)
    kwargs.setdefault('evaluate', True)
    return _derivative_dispatch(f, *symbols, **kwargs)

.sympy.core.expr.Expr.diff

def diff(self, *symbols, **assumptions):
    assumptions.setdefault('evaluate', True)
    return _derivative_dispatch(self, *symbols, **assumptions)

.sympy.core.function._derivative_dispatch

def _derivative_dispatch(expr, *variables, **kwargs):
    from sympy.matrices.common import MatrixCommon
    from sympy.matrices.expressions.matexpr import MatrixExpr
    from sympy.tensor.array import NDimArray
    array_types = (MatrixCommon, MatrixExpr, NDimArray, list, tuple, Tuple)
    if isinstance(expr, array_types) or any((isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables)):
        from sympy.tensor.array.array_derivatives import ArrayDerivative
        return ArrayDerivative(expr, *variables, **kwargs)
    return Derivative(expr, *variables, **kwargs)

.sympy.core.function.Derivative.__new__

def __new__(cls, expr, *variables, **kwargs):
    expr = sympify(expr)
    symbols_or_none = getattr(expr, 'free_symbols', None)
    has_symbol_set = isinstance(symbols_or_none, set)
    if not has_symbol_set:
        raise ValueError(filldedent('\n            Since there are no variables in the expression %s,\n            it cannot be differentiated.' % expr))
    if not variables:
        variables = expr.free_symbols
        if len(variables) != 1:
            if expr.is_number:
                return S.Zero
            if len(variables) == 0:
                raise ValueError(filldedent('\n                    Since there are no variables in the expression,\n                    the variable(s) of differentiation must be supplied\n                    to differentiate %s' % expr))
            else:
                raise ValueError(filldedent('\n                    Since there is more than one variable in the\n                    expression, the variable(s) of differentiation\n                    must be supplied to differentiate %s' % expr))
    variable_count = []
    array_likes = (tuple, list, Tuple)
    from sympy.tensor.array import Array, NDimArray
    for i, v in enumerate(variables):
        if isinstance(v, UndefinedFunction):
            raise TypeError('cannot differentiate wrt UndefinedFunction: %s' % v)
        if isinstance(v, array_likes):
            if len(v) == 0:
                continue
            if isinstance(v[0], array_likes):
                if len(v) == 1:
                    v = Array(v[0])
                    count = 1
                else:
                    v, count = v
                    v = Array(v)
            else:
                v, count = v
            if count == 0:
                continue
            variable_count.append(Tuple(v, count))
            continue
        v = _sympify(v)
        if isinstance(v, Integer):
            if i == 0:
                raise ValueError('First variable cannot be a number: %i' % v)
            count = v
            prev, prevcount = variable_count[-1]
            if prevcount != 1:
                raise TypeError('tuple {} followed by number {}'.format((prev, prevcount), v))
            if count == 0:
                variable_count.pop()
            else:
                variable_count[-1] = Tuple(prev, count)
        else:
            count = 1
            variable_count.append(Tuple(v, count))
    merged = []
    for t in variable_count:
        v, c = t
        if c.is_negative:
            raise ValueError('order of differentiation must be nonnegative')
        if merged and merged[-1][0] == v:
            c += merged[-1][1]
            if not c:
                merged.pop()
            else:
                merged[-1] = Tuple(v, c)
        else:
            merged.append(t)
    variable_count = merged
    for v, c in variable_count:
        if not v._diff_wrt:
            __ = ''
            raise ValueError(filldedent("\n                Can't calculate derivative wrt %s.%s" % (v, __)))
    if len(variable_count) == 0:
        return expr
    evaluate = kwargs.get('evaluate', False)
    if evaluate:
        if isinstance(expr, Derivative):
            expr = expr.canonical
        variable_count = [(v.canonical if isinstance(v, Derivative) else v, c) for v, c in variable_count]
        zero = False
        free = expr.free_symbols
        from sympy.matrices.expressions.matexpr import MatrixExpr
        for v, c in variable_count:
            vfree = v.free_symbols
            if c.is_positive and vfree:
                if isinstance(v, AppliedUndef):
                    D = Dummy()
                    if not expr.xreplace({v: D}).has(D):
                        zero = True
                        break
                elif isinstance(v, MatrixExpr):
                    zero = False
                    break
                elif isinstance(v, Symbol) and v not in free:
                    zero = True
                    break
                elif not free & vfree:
                    zero = True
                    break
        if zero:
            return cls._get_zero_with_shape_like(expr)
        variable_count = cls._sort_variable_count(variable_count)
    if isinstance(expr, Derivative):
        variable_count = list(expr.variable_count) + variable_count
        expr = expr.expr
        return _derivative_dispatch(expr, *variable_count, **kwargs)
    if not evaluate or not hasattr(expr, '_eval_derivative'):
        if evaluate and variable_count == [(expr, 1)] and expr.is_scalar:
            return S.One
        return Expr.__new__(cls, expr, *variable_count)
    nderivs = 0
    unhandled = []
    from sympy.matrices.common import MatrixCommon
    for i, (v, count) in enumerate(variable_count):
        old_expr = expr
        old_v = None
        is_symbol = v.is_symbol or isinstance(v, (Iterable, Tuple, MatrixCommon, NDimArray))
        if not is_symbol:
            old_v = v
            v = Dummy('xi')
            expr = expr.xreplace({old_v: v})
            clashing = not (isinstance(old_v, Derivative) or isinstance(old_v, AppliedUndef))
            if v not in expr.free_symbols and (not clashing):
                return expr.diff(v)
            if not old_v.is_scalar and (not hasattr(old_v, '_eval_derivative')):
                expr *= old_v.diff(old_v)
        obj = cls._dispatch_eval_derivative_n_times(expr, v, count)
        if obj is not None and obj.is_zero:
            return obj
        nderivs += count
        if old_v is not None:
            if obj is not None:
                obj = obj.subs(v, old_v)
            expr = old_expr
        if obj is None:
            unhandled = variable_count[i:]
            break
        expr = obj
    expr = expr.replace(lambda x: isinstance(x, Derivative), lambda x: x.canonical)
    if unhandled:
        if isinstance(expr, Derivative):
            unhandled = list(expr.variable_count) + unhandled
            expr = expr.expr
        expr = Expr.__new__(cls, expr, *unhandled)
    if (nderivs > 1) == True and kwargs.get('simplify', True):
        from .exprtools import factor_terms
        from sympy.simplify.simplify import signsimp
        expr = factor_terms(signsimp(expr))
    return expr

.sympy.core.basic.Basic.free_symbols

def free_symbols(self) -> 'Set[Basic]':
    empty: 'Set[Basic]' = set()
    return empty.union(*(a.free_symbols for a in self.args))

.sympy.core.symbol.Symbol.free_symbols

def free_symbols(self):
    return {self}

.sympy.core.containers.Tuple.__new__

def __new__(cls, *args, **kwargs):
    if kwargs.get('sympify', True):
        args = (sympify(arg) for arg in args)
    obj = Basic.__new__(cls, *args)
    return obj

.sympy.core.containers.Tuple.__iter__

def __iter__(self):
    return iter(self.args)

.sympy.core.symbol.Symbol._diff_wrt

def _diff_wrt(self):
    return True

.sympy.core.function.Derivative._sort_variable_count

def _sort_variable_count(cls, vc):
    if not vc:
        return []
    vc = list(vc)
    if len(vc) == 1:
        return [Tuple(*vc[0])]
    V = list(range(len(vc)))
    E = []
    v = lambda i: vc[i][0]
    D = Dummy()

    def _block(d, v, wrt=False):
        if d == v:
            return wrt
        if d.is_Symbol:
            return False
        if isinstance(d, Derivative):
            if any((_block(k, v, wrt=True) for k in d._wrt_variables)):
                return True
            return False
        if not wrt and isinstance(d, AppliedUndef):
            return False
        if v.is_Symbol:
            return v in d.free_symbols
        if isinstance(v, AppliedUndef):
            return _block(d.xreplace({v: D}), D)
        return d.free_symbols & v.free_symbols
    for i in range(len(vc)):
        for j in range(i):
            if _block(v(j), v(i)):
                E.append((j, i))
    O = dict(zip(ordered(uniq([i for i, c in vc])), range(len(vc))))
    ix = topological_sort((V, E), key=lambda i: O[v(i)])
    merged = []
    for v, c in [vc[i] for i in ix]:
        if merged and merged[-1][0] == v:
            merged[-1][1] += c
        else:
            merged.append([v, c])
    return [Tuple(*i) for i in merged]

.sympy.core.function.Derivative._dispatch_eval_derivative_n_times

def _dispatch_eval_derivative_n_times(cls, expr, v, count):
    return expr._eval_derivative_n_times(v, count)

.sympy.core.mul.Mul._eval_derivative_n_times

def _eval_derivative_n_times(self, s, n):
    from .function import AppliedUndef
    from .symbol import Symbol, symbols, Dummy
    if not isinstance(s, (AppliedUndef, Symbol)):
        return super()._eval_derivative_n_times(s, n)
    from .numbers import Integer
    args = self.args
    m = len(args)
    if isinstance(n, (int, Integer)):
        terms = []
        from sympy.ntheory.multinomial import multinomial_coefficients_iterator
        for kvals, c in multinomial_coefficients_iterator(m, n):
            p = prod([arg.diff((s, k)) for k, arg in zip(kvals, args)])
            terms.append(c * p)
        return Add(*terms)
    from sympy.concrete.summations import Sum
    from sympy.functions.combinatorial.factorials import factorial
    from sympy.functions.elementary.miscellaneous import Max
    kvals = symbols('k1:%i' % m, cls=Dummy)
    klast = n - sum(kvals)
    nfact = factorial(n)
    e, l = (nfact / prod(map(factorial, kvals)) / factorial(klast) * prod([args[t].diff((s, kvals[t])) for t in range(m - 1)]) * args[-1].diff((s, Max(0, klast))), [(k, 0, n) for k in kvals])
    return Sum(e, *l)

.sympy.ntheory.multinomial.multinomial_coefficients_iterator

def multinomial_coefficients_iterator(m, n, _tuple=tuple):
    m = as_int(m)
    n = as_int(n)
    if m < 2 * n or n == 1:
        mc = multinomial_coefficients(m, n)
        yield from mc.items()
    else:
        mc = multinomial_coefficients(n, n)
        mc1 = {}
        for k, v in mc.items():
            mc1[_tuple(filter(None, k))] = v
        mc = mc1
        t = [n] + [0] * (m - 1)
        t1 = _tuple(t)
        b = _tuple(filter(None, t1))
        yield (t1, mc[b])
        if n:
            j = 0
        else:
            j = m
        while j < m - 1:
            tj = t[j]
            if j:
                t[j] = 0
                t[0] = tj
            if tj > 1:
                t[j + 1] += 1
                j = 0
            else:
                j += 1
                t[j] += 1
            t[0] -= 1
            t1 = _tuple(t)
            b = _tuple(filter(None, t1))
            yield (t1, mc[b])

.sympy.utilities.misc.as_int

def as_int(n, strict=True):
    if strict:
        try:
            if isinstance(n, bool):
                raise TypeError
            return operator.index(n)
        except TypeError:
            raise ValueError('%s is not an integer' % (n,))
    else:
        try:
            result = int(n)
        except TypeError:
            raise ValueError('%s is not an integer' % (n,))
        if n != result:
            raise ValueError('%s is not an integer' % (n,))
        return result

.sympy.core.numbers.Integer.__index__

def __index__(self):
    return self.p

.sympy.ntheory.multinomial.multinomial_coefficients

def multinomial_coefficients(m, n):
    m = as_int(m)
    n = as_int(n)
    if not m:
        if n:
            return {}
        return {(): 1}
    if m == 2:
        return binomial_coefficients(n)
    if m >= 2 * n and n > 1:
        return dict(multinomial_coefficients_iterator(m, n))
    t = [n] + [0] * (m - 1)
    r = {tuple(t): 1}
    if n:
        j = 0
    else:
        j = m
    while j < m - 1:
        tj = t[j]
        if j:
            t[j] = 0
            t[0] = tj
        if tj > 1:
            t[j + 1] += 1
            j = 0
            start = 1
            v = 0
        else:
            j += 1
            start = j + 1
            v = r[tuple(t)]
            t[j] += 1
        for k in range(start, m):
            if t[k]:
                t[k] -= 1
                v += r[tuple(t)]
                t[k] += 1
        t[0] -= 1
        r[tuple(t)] = v * tj // (n - t[0])
    return r

.sympy.ntheory.multinomial.binomial_coefficients

def binomial_coefficients(n):
    n = as_int(n)
    d = {(0, n): 1, (n, 0): 1}
    a = 1
    for k in range(1, n // 2 + 1):
        a = a * (n - k + 1) // k
        d[k, n - k] = d[n - k, k] = a
    return d

.sympy.core.function.Derivative._get_zero_with_shape_like

def _get_zero_with_shape_like(cls, expr):
    return S.Zero

.sympy.core.mul.prod

def prod(a, start=1):
    return reduce(operator.mul, a, start)

.sympy.core.decorators._SympifyWrapper._func

def _func(self, other):
    if not hasattr(other, '_op_priority'):
        try:
            other = sympify(other, strict=True)
        except SympifyError:
            return retval
    if not isinstance(other, expectedcls):
        return retval
    return func(self, other)

.sympy.core.decorators.binary_op_wrapper

def binary_op_wrapper(self, other):
    if hasattr(other, '_op_priority'):
        if other._op_priority > self._op_priority:
            f = getattr(other, method_name, None)
            if f is not None:
                return f(self)
    return func(self, other)

.sympy.core.expr.Expr.__rmul__

def __rmul__(self, other):
    return Mul(other, self)

.sympy.core.expr.Expr.__mul__

def __mul__(self, other):
    return Mul(self, other)

.sympy.core.numbers.Integer.__rmul__

def __rmul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(other * self.p)
        elif isinstance(other, Rational):
            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))
        return Rational.__rmul__(self, other)
    return Rational.__rmul__(self, other)

.sympy.core.expr.AtomicExpr._eval_derivative_n_times

def _eval_derivative_n_times(self, s, n):
    from .containers import Tuple
    from sympy.matrices.expressions.matexpr import MatrixExpr
    from sympy.matrices.common import MatrixCommon
    if isinstance(s, (MatrixCommon, Tuple, Iterable, MatrixExpr)):
        return super()._eval_derivative_n_times(s, n)
    from .relational import Eq
    from sympy.functions.elementary.piecewise import Piecewise
    if self == s:
        return Piecewise((self, Eq(n, 0)), (1, Eq(n, 1)), (0, True))
    else:
        return Piecewise((self, Eq(n, 0)), (0, True))

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    if self is other:
        return True
    if not isinstance(other, Basic):
        return self._do_eq_sympify(other)
    if not (self.is_Number and other.is_Number) and type(self) != type(other):
        return False
    a, b = (self._hashable_content(), other._hashable_content())
    if a != b:
        return False
    for a, b in zip(a, b):
        if not isinstance(a, Basic):
            continue
        if a.is_Number and type(a) != type(b):
            return False
    return True

.sympy.core.relational.Equality.__new__

def __new__(cls, lhs, rhs=None, **options):
    if rhs is None:
        sympy_deprecation_warning('\n            Eq(expr) with a single argument with the right-hand side\n            defaulting to 0 is deprecated. Use Eq(expr, 0) instead.\n            ', deprecated_since_version='1.5', active_deprecations_target='deprecated-eq-expr')
        rhs = 0
    evaluate = options.pop('evaluate', global_parameters.evaluate)
    lhs = _sympify(lhs)
    rhs = _sympify(rhs)
    if evaluate:
        val = is_eq(lhs, rhs)
        if val is None:
            return cls(lhs, rhs, evaluate=False)
        else:
            return _sympify(val)
    return Relational.__new__(cls, lhs, rhs)

.sympy.core.relational.is_eq

def is_eq(lhs, rhs, assumptions=None):
    for side1, side2 in ((lhs, rhs), (rhs, lhs)):
        eval_func = getattr(side1, '_eval_Eq', None)
        if eval_func is not None:
            retval = eval_func(side2)
            if retval is not None:
                return retval
    retval = _eval_is_eq(lhs, rhs)
    if retval is not None:
        return retval
    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):
        retval = _eval_is_eq(rhs, lhs)
        if retval is not None:
            return retval
    if lhs == rhs:
        return True
    elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):
        return False
    elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):
        return False
    from sympy.assumptions.wrapper import AssumptionsWrapper, is_infinite, is_extended_real
    from .add import Add
    _lhs = AssumptionsWrapper(lhs, assumptions)
    _rhs = AssumptionsWrapper(rhs, assumptions)
    if _lhs.is_infinite or _rhs.is_infinite:
        if fuzzy_xor([_lhs.is_infinite, _rhs.is_infinite]):
            return False
        if fuzzy_xor([_lhs.is_extended_real, _rhs.is_extended_real]):
            return False
        if fuzzy_and([_lhs.is_extended_real, _rhs.is_extended_real]):
            return fuzzy_xor([_lhs.is_extended_positive, fuzzy_not(_rhs.is_extended_positive)])
        I = S.ImaginaryUnit

        def split_real_imag(expr):
            real_imag = lambda t: 'real' if is_extended_real(t, assumptions) else 'imag' if is_extended_real(I * t, assumptions) else None
            return sift(Add.make_args(expr), real_imag)
        lhs_ri = split_real_imag(lhs)
        if not lhs_ri[None]:
            rhs_ri = split_real_imag(rhs)
            if not rhs_ri[None]:
                eq_real = is_eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']), assumptions)
                eq_imag = is_eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']), assumptions)
                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))
        from sympy.functions.elementary.complexes import arg
        arglhs = arg(lhs)
        argrhs = arg(rhs)
        if not (arglhs == S.NaN and argrhs == S.NaN):
            return fuzzy_bool(is_eq(arglhs, argrhs, assumptions))
    if all((isinstance(i, Expr) for i in (lhs, rhs))):
        dif = lhs - rhs
        _dif = AssumptionsWrapper(dif, assumptions)
        z = _dif.is_zero
        if z is not None:
            if z is False and _dif.is_commutative:
                return False
            if z:
                return True
        n2 = _n2(lhs, rhs)
        if n2 is not None:
            return _sympify(n2 == 0)
        n, d = dif.as_numer_denom()
        rv = None
        _n = AssumptionsWrapper(n, assumptions)
        _d = AssumptionsWrapper(d, assumptions)
        if _n.is_zero:
            rv = _d.is_nonzero
        elif _n.is_finite:
            if _d.is_infinite:
                rv = True
            elif _n.is_zero is False:
                rv = _d.is_infinite
                if rv is None:
                    from sympy.simplify.simplify import clear_coefficients
                    l, r = clear_coefficients(d, S.Infinity)
                    args = [_.subs(l, r) for _ in (lhs, rhs)]
                    if args != [lhs, rhs]:
                        rv = fuzzy_bool(is_eq(*args, assumptions))
                        if rv is True:
                            rv = None
        elif any((is_infinite(a, assumptions) for a in Add.make_args(n))):
            rv = False
        if rv is not None:
            return rv

.sympy.multipledispatch.dispatcher.Dispatcher.__call__

def __call__(self, *args, **kwargs):
    types = tuple([type(arg) for arg in args])
    try:
        func = self._cache[types]
    except KeyError:
        func = self.dispatch(*types)
        if not func:
            raise NotImplementedError('Could not find signature for %s: <%s>' % (self.name, str_signature(types)))
        self._cache[types] = func
    try:
        return func(*args, **kwargs)
    except MDNotImplementedError:
        funcs = self.dispatch_iter(*types)
        next(funcs)
        for func in funcs:
            try:
                return func(*args, **kwargs)
            except MDNotImplementedError:
                pass
        raise NotImplementedError('Matching functions for %s: <%s> found, but none completed successfully' % (self.name, str_signature(types)))

.sympy.multipledispatch.dispatcher.Dispatcher.dispatch

def dispatch(self, *types):
    if types in self.funcs:
        return self.funcs[types]
    try:
        return next(self.dispatch_iter(*types))
    except StopIteration:
        return None

.sympy.multipledispatch.dispatcher.Dispatcher.dispatch_iter

def dispatch_iter(self, *types):
    n = len(types)
    for signature in self.ordering:
        if len(signature) == n and all(map(issubclass, types, signature)):
            result = self.funcs[signature]
            yield result

.sympy.core.relational._eval_is_eq

def _eval_is_eq(lhs, rhs):
    return None

.sympy.multipledispatch.core.dispatch

def dispatch(*types, namespace=global_namespace, on_ambiguity=ambiguity_warn):
    types = tuple(types)

    def _(func):
        name = func.__name__
        if ismethod(func):
            dispatcher = inspect.currentframe().f_back.f_locals.get(name, MethodDispatcher(name))
        else:
            if name not in namespace:
                namespace[name] = Dispatcher(name)
            dispatcher = namespace[name]
        dispatcher.add(types, func, on_ambiguity=on_ambiguity)
        return dispatcher
    return _

.sympy.assumptions.wrapper.AssumptionsWrapper.__new__

def __new__(cls, expr, assumptions=None):
    if assumptions is None:
        return expr
    obj = super().__new__(cls, expr, _sympify(assumptions))
    obj.expr = expr
    obj.assumptions = assumptions
    return obj

.sympy.core.numbers.Integer.__sub__

def __sub__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p - other)
        elif isinstance(other, Integer):
            return Integer(self.p - other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - other.p, other.q, 1)
        return Rational.__sub__(self, other)
    return Rational.__sub__(self, other)

.sympy.functions.elementary.piecewise.Piecewise.__new__

def __new__(cls, *args, **options):
    if len(args) == 0:
        raise TypeError('At least one (expr, cond) pair expected.')
    newargs = []
    for ec in args:
        pair = ExprCondPair(*getattr(ec, 'args', ec))
        cond = pair.cond
        if cond is false:
            continue
        newargs.append(pair)
        if cond is true:
            break
    eval = options.pop('evaluate', global_parameters.evaluate)
    if eval:
        r = cls.eval(*newargs)
        if r is not None:
            return r
    elif len(newargs) == 1 and newargs[0].cond == True:
        return newargs[0].expr
    return Basic.__new__(cls, *newargs, **options)

.sympy.functions.elementary.piecewise.ExprCondPair.__new__

def __new__(cls, expr, cond):
    expr = as_Basic(expr)
    if cond == True:
        return Tuple.__new__(cls, expr, true)
    elif cond == False:
        return Tuple.__new__(cls, expr, false)
    elif isinstance(cond, Basic) and cond.has(Piecewise):
        cond = piecewise_fold(cond)
        if isinstance(cond, Piecewise):
            cond = cond.rewrite(ITE)
    if not isinstance(cond, Boolean):
        raise TypeError(filldedent('\n            Second argument must be a Boolean,\n            not `%s`' % func_name(cond)))
    return Tuple.__new__(cls, expr, cond)

.sympy.core.basic.as_Basic

def as_Basic(expr):
    try:
        return _sympify(expr)
    except SympifyError:
        raise TypeError('Argument must be a Basic object, not `%s`' % func_name(expr))

.sympy.logic.boolalg.BooleanFalse.__eq__

def __eq__(self, other):
    if other is True:
        return False
    if other is False:
        return True
    return super().__eq__(other)

.sympy.functions.elementary.piecewise.ExprCondPair.cond

def cond(self):
    return self.args[1]

.sympy.logic.boolalg.BooleanTrue.__eq__

def __eq__(self, other):
    if other is True:
        return True
    if other is False:
        return False
    return super().__eq__(other)

.sympy.functions.elementary.piecewise.Piecewise.eval

def eval(cls, *_args):
    if not _args:
        return Undefined
    if len(_args) == 1 and _args[0][-1] == True:
        return _args[0][0]
    newargs = []
    current_cond = set()
    for expr, cond in _args:
        cond = cond.replace(lambda _: _.is_Relational, _canonical_coeff)
        if isinstance(expr, Piecewise):
            unmatching = []
            for i, (e, c) in enumerate(expr.args):
                if c in current_cond:
                    continue
                if c == cond:
                    if c != True:
                        if unmatching:
                            expr = Piecewise(*unmatching + [(e, c)])
                        else:
                            expr = e
                    break
                else:
                    unmatching.append((e, c))
        got = False
        for i in [cond] + (list(cond.args) if isinstance(cond, And) else []):
            if i in current_cond:
                got = True
                break
        if got:
            continue
        if isinstance(cond, And):
            nonredundant = []
            for c in cond.args:
                if isinstance(c, Relational):
                    if c.negated.canonical in current_cond:
                        continue
                    if isinstance(c, (Lt, Gt)) and c.weak in current_cond:
                        cond = False
                        break
                nonredundant.append(c)
            else:
                cond = cond.func(*nonredundant)
        elif isinstance(cond, Relational):
            if cond.negated.canonical in current_cond:
                cond = S.true
        current_cond.add(cond)
        if newargs:
            if newargs[-1].expr == expr:
                orcond = Or(cond, newargs[-1].cond)
                if isinstance(orcond, (And, Or)):
                    orcond = distribute_and_over_or(orcond)
                newargs[-1] = ExprCondPair(expr, orcond)
                continue
            elif newargs[-1].cond == cond:
                newargs[-1] = ExprCondPair(expr, cond)
                continue
        newargs.append(ExprCondPair(expr, cond))
    missing = len(newargs) != len(_args)
    same = all((a == b for a, b in zip(newargs, _args)))
    if not newargs:
        raise ValueError(filldedent('\n            There are no conditions (or none that\n            are not trivially false) to define an\n            expression.'))
    if missing or not same:
        return cls(*newargs)

.sympy.core.containers.Tuple.__getitem__

def __getitem__(self, i):
    if isinstance(i, slice):
        indices = i.indices(len(self))
        return Tuple(*(self.args[j] for j in range(*indices)))
    return self.args[i]

.sympy.core.numbers.Integer.__radd__

def __radd__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(other + self.p)
        elif isinstance(other, Rational):
            return Rational(other.p + self.p * other.q, other.q, 1)
        return Rational.__radd__(self, other)
    return Rational.__radd__(self, other)

.sympy.core.basic.Basic.replace

def replace(self, query, value, map=False, simultaneous=True, exact=None):
    try:
        query = _sympify(query)
    except SympifyError:
        pass
    try:
        value = _sympify(value)
    except SympifyError:
        pass
    if isinstance(query, type):
        _query = lambda expr: isinstance(expr, query)
        if isinstance(value, type):
            _value = lambda expr, result: value(*expr.args)
        elif callable(value):
            _value = lambda expr, result: value(*expr.args)
        else:
            raise TypeError('given a type, replace() expects another type or a callable')
    elif isinstance(query, Basic):
        _query = lambda expr: expr.match(query)
        if exact is None:
            from .symbol import Wild
            exact = len(query.atoms(Wild)) > 1
        if isinstance(value, Basic):
            if exact:
                _value = lambda expr, result: value.subs(result) if all(result.values()) else expr
            else:
                _value = lambda expr, result: value.subs(result)
        elif callable(value):
            if exact:
                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()}) if all((val for val in result.values())) else expr
            else:
                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()})
        else:
            raise TypeError('given an expression, replace() expects another expression or a callable')
    elif callable(query):
        _query = query
        if callable(value):
            _value = lambda expr, result: value(expr)
        else:
            raise TypeError('given a callable, replace() expects another callable')
    else:
        raise TypeError('first argument to replace() must be a type, an expression or a callable')

    def walk(rv, F):
        args = getattr(rv, 'args', None)
        if args is not None:
            if args:
                newargs = tuple([walk(a, F) for a in args])
                if args != newargs:
                    rv = rv.func(*newargs)
                    if simultaneous:
                        for i, e in enumerate(args):
                            if rv == e and e != newargs[i]:
                                return rv
            rv = F(rv)
        return rv
    mapping = {}

    def rec_replace(expr):
        result = _query(expr)
        if result or result == {}:
            v = _value(expr, result)
            if v is not None and v != expr:
                if map:
                    mapping[expr] = v
                expr = v
        return expr
    rv = walk(self, rec_replace)
    return (rv, mapping) if map else rv

.sympy.core.sympify._is_numpy_instance

def _is_numpy_instance(a):
    return any((type_.__module__ == 'numpy' for type_ in type(a).__mro__))

.sympy.core.sympify.SympifyError.__init__

def __init__(self, expr, base_exc=None):
    self.expr = expr
    self.base_exc = base_exc

.sympy.core.basic.Basic.walk

def walk(rv, F):
    args = getattr(rv, 'args', None)
    if args is not None:
        if args:
            newargs = tuple([walk(a, F) for a in args])
            if args != newargs:
                rv = rv.func(*newargs)
                if simultaneous:
                    for i, e in enumerate(args):
                        if rv == e and e != newargs[i]:
                            return rv
        rv = F(rv)
    return rv

.sympy.core.basic.Basic.rec_replace

def rec_replace(expr):
    result = _query(expr)
    if result or result == {}:
        v = _value(expr, result)
        if v is not None and v != expr:
            if map:
                mapping[expr] = v
            expr = v
    return expr

.sympy.core.numbers.Integer.__gt__

def __gt__(self, other):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Integer:
        return _sympify(self.p > other.p)
    return Rational.__gt__(self, other)

.sympy.core.decorators.__sympifyit_wrapper

def __sympifyit_wrapper(a, b):
    try:
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

.sympy.core.numbers.Rational.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))
        elif isinstance(other, Rational):
            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))
        elif isinstance(other, Float):
            return other * self
        else:
            return Number.__mul__(self, other)
    return Number.__mul__(self, other)

.sympy.core.numbers.Number.__mul__

def __mul__(self, other):
    if isinstance(other, Number) and global_parameters.evaluate:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.Infinity
            else:
                return S.NegativeInfinity
        elif other is S.NegativeInfinity:
            if self.is_zero:
                return S.NaN
            elif self.is_positive:
                return S.NegativeInfinity
            else:
                return S.Infinity
    elif isinstance(other, Tuple):
        return NotImplemented
    return AtomicExpr.__mul__(self, other)

.sympy.geometry.point.Point.__getitem__

def __getitem__(self, key):
    return self.args[key]

.sympy.core.numbers.Integer.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p + other)
        elif isinstance(other, Integer):
            return Integer(self.p + other.p)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + other.p, other.q, 1)
        return Rational.__add__(self, other)
    else:
        return Add(self, other)

.sympy.core.numbers.Integer.__ne__

def __ne__(self, other):
    return not self == other

.sympy.integrals.intpoly.left_integral2D

def left_integral2D(m, index, facets, x0, expr, gens):
    value = S.Zero
    for j in range(0, m):
        intersect = ()
        if j in ((index - 1) % m, (index + 1) % m):
            intersect = intersection(facets[index], facets[j], 'segment2D')
        if intersect:
            distance_origin = norm(tuple(map(lambda x, y: x - y, intersect, x0)))
            if is_vertex(intersect):
                if isinstance(expr, Expr):
                    if len(gens) == 3:
                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1], gens[2]: intersect[2]}
                    else:
                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1]}
                    value += distance_origin * expr.subs(expr_dict)
                else:
                    value += distance_origin * expr
    return value

.sympy.integrals.intpoly.intersection

def intersection(geom_1, geom_2, intersection_type):
    if intersection_type[:-2] == 'segment':
        if intersection_type == 'segment2D':
            x1, y1 = geom_1.points[0]
            x2, y2 = geom_1.points[1]
            x3, y3 = geom_2.points[0]
            x4, y4 = geom_2.points[1]
        elif intersection_type == 'segment3D':
            x1, y1, z1 = geom_1.points[0]
            x2, y2, z2 = geom_1.points[1]
            x3, y3, z3 = geom_2.points[0]
            x4, y4, z4 = geom_2.points[1]
        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        if denom:
            t1 = x1 * y2 - y1 * x2
            t2 = x3 * y4 - x4 * y3
            return (S(t1 * (x3 - x4) - t2 * (x1 - x2)) / denom, S(t1 * (y3 - y4) - t2 * (y1 - y2)) / denom)
    if intersection_type[:-2] == 'plane':
        if intersection_type == 'plane2D':
            a1x, a1y = geom_1[0]
            a2x, a2y = geom_2[0]
            b1, b2 = (geom_1[1], geom_2[1])
            denom = a1x * a2y - a2x * a1y
            if denom:
                return (S(b1 * a2y - b2 * a1y) / denom, S(b2 * a1x - b1 * a2x) / denom)

.sympy.geometry.point.Point.__iter__

def __iter__(self):
    return self.args.__iter__()

.sympy.core.numbers.Rational.__truediv__

def __truediv__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            if self.p and other.p == S.Zero:
                return S.ComplexInfinity
            else:
                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))
        elif isinstance(other, Rational):
            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))
        elif isinstance(other, Float):
            return self * (1 / other)
        else:
            return Number.__truediv__(self, other)
    return Number.__truediv__(self, other)

.sympy.core.numbers.Rational.__new__

def __new__(cls, p, q=None, gcd=None):
    if q is None:
        if isinstance(p, Rational):
            return p
        if isinstance(p, SYMPY_INTS):
            pass
        else:
            if isinstance(p, (float, Float)):
                return Rational(*_as_integer_ratio(p))
            if not isinstance(p, str):
                try:
                    p = sympify(p)
                except (SympifyError, SyntaxError):
                    pass
            else:
                if p.count('/') > 1:
                    raise TypeError('invalid input: %s' % p)
                p = p.replace(' ', '')
                pq = p.rsplit('/', 1)
                if len(pq) == 2:
                    p, q = pq
                    fp = fractions.Fraction(p)
                    fq = fractions.Fraction(q)
                    p = fp / fq
                try:
                    p = fractions.Fraction(p)
                except ValueError:
                    pass
                else:
                    return Rational(p.numerator, p.denominator, 1)
            if not isinstance(p, Rational):
                raise TypeError('invalid input: %s' % p)
        q = 1
        gcd = 1
    if not isinstance(p, SYMPY_INTS):
        p = Rational(p)
        q *= p.q
        p = p.p
    else:
        p = int(p)
    if not isinstance(q, SYMPY_INTS):
        q = Rational(q)
        p *= q.q
        q = q.p
    else:
        q = int(q)
    if q == 0:
        if p == 0:
            if _errdict['divide']:
                raise ValueError('Indeterminate 0/0')
            else:
                return S.NaN
        return S.ComplexInfinity
    if q < 0:
        q = -q
        p = -p
    if not gcd:
        gcd = igcd(abs(p), q)
    if gcd > 1:
        p //= gcd
        q //= gcd
    if q == 1:
        return Integer(p)
    if p == 1 and q == 2:
        return S.Half
    obj = Expr.__new__(cls)
    obj.p = p
    obj.q = q
    return obj

.sympy.integrals.intpoly.norm

def norm(point):
    half = S.Half
    if isinstance(point, (list, tuple)):
        return sum([coord ** 2 for coord in point]) ** half
    elif isinstance(point, Point):
        if isinstance(point, Point2D):
            return (point.x ** 2 + point.y ** 2) ** half
        else:
            return (point.x ** 2 + point.y ** 2 + point.z) ** half
    elif isinstance(point, dict):
        return sum((i ** 2 for i in point.values())) ** half

.sympy.core.expr.Expr.__pow__

def __pow__(self, other, mod=None):
    if mod is None:
        return self._pow(other)
    try:
        _self, other, mod = (as_int(self), as_int(other), as_int(mod))
        if other >= 0:
            return pow(_self, other, mod)
        else:
            from .numbers import mod_inverse
            return mod_inverse(pow(_self, -other, mod), mod)
    except ValueError:
        power = self._pow(other)
        try:
            return power % mod
        except TypeError:
            return NotImplemented

.sympy.core.expr.Expr._pow

def _pow(self, other):
    return Pow(self, other)

.sympy.core.power.Pow.__new__

def __new__(cls, b, e, evaluate=None):
    if evaluate is None:
        evaluate = global_parameters.evaluate
    b = _sympify(b)
    e = _sympify(e)
    from .relational import Relational
    if isinstance(b, Relational) or isinstance(e, Relational):
        raise TypeError('Relational cannot be used in Pow')
    for arg in [b, e]:
        if not isinstance(arg, Expr):
            sympy_deprecation_warning(f'\nUsing non-Expr arguments in Pow is deprecated (in this case, one of the\narguments is of type {type(arg).__name__!r}).\n\nIf you really did intend to construct a power with this base, use the **\noperator instead.', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)
    if evaluate:
        if e is S.ComplexInfinity:
            return S.NaN
        if e is S.Infinity:
            if is_gt(b, S.One):
                return S.Infinity
            if is_gt(b, S.NegativeOne) and is_lt(b, S.One):
                return S.Zero
            if is_lt(b, S.NegativeOne):
                if b.is_finite:
                    return S.ComplexInfinity
                if b.is_finite is False:
                    return S.NaN
        if e is S.Zero:
            return S.One
        elif e is S.One:
            return b
        elif e == -1 and (not b):
            return S.ComplexInfinity
        elif e.__class__.__name__ == 'AccumulationBounds':
            if b == S.Exp1:
                from sympy.calculus.accumulationbounds import AccumBounds
                return AccumBounds(Pow(b, e.min), Pow(b, e.max))
        elif (e.is_Symbol and e.is_integer or e.is_Integer) and (b.is_number and b.is_Mul or b.is_Number) and b.could_extract_minus_sign():
            if e.is_even:
                b = -b
            elif e.is_odd:
                return -Pow(-b, e)
        if S.NaN in (b, e):
            return S.NaN
        elif b is S.One:
            if abs(e).is_infinite:
                return S.NaN
            return S.One
        else:
            from sympy.functions.elementary.exponential import exp_polar
            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):
                from .exprtools import factor_terms
                from sympy.functions.elementary.exponential import log
                from sympy.simplify.radsimp import fraction
                c, ex = factor_terms(e, sign=False).as_coeff_Mul()
                num, den = fraction(ex)
                if isinstance(den, log) and den.args[0] == b:
                    return S.Exp1 ** (c * num)
                elif den.is_Add:
                    from sympy.functions.elementary.complexes import sign, im
                    s = sign(im(b))
                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):
                        return S.Exp1 ** (c * num)
            obj = b._eval_power(e)
            if obj is not None:
                return obj
    obj = Expr.__new__(cls, b, e)
    obj = cls._exec_constructor_postprocessors(obj)
    if not isinstance(obj, Pow):
        return obj
    obj.is_commutative = b.is_commutative and e.is_commutative
    return obj

.sympy.core.numbers.Number.could_extract_minus_sign

def could_extract_minus_sign(self):
    return bool(self.is_extended_negative)

.sympy.core.numbers.Integer.__abs__

def __abs__(self):
    if self.p >= 0:
        return self
    else:
        return Integer(-self.p)

.sympy.core.numbers.Zero._eval_power

def _eval_power(self, expt):
    if expt.is_extended_positive:
        return self
    if expt.is_extended_negative:
        return S.ComplexInfinity
    if expt.is_extended_real is False:
        return S.NaN
    coeff, terms = expt.as_coeff_Mul()
    if coeff.is_negative:
        return S.ComplexInfinity ** terms
    if coeff is not S.One:
        return self ** terms

.sympy.core.assumptions.StdFactKB.generator

def generator(self):
    return self._generator.copy()

.sympy.core.expr.Expr._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return self._eval_is_extended_positive_negative(positive=True)

.sympy.core.expr.Expr._eval_is_extended_positive_negative

def _eval_is_extended_positive_negative(self, positive):
    from sympy.polys.numberfields import minimal_polynomial
    from sympy.polys.polyerrors import NotAlgebraic
    if self.is_number:
        if self.is_extended_real is False:
            return False
        try:
            n2 = self._eval_evalf(2)
        except ValueError:
            return None
        if n2 is None:
            return None
        if getattr(n2, '_prec', 1) == 1:
            return None
        if n2 is S.NaN:
            return None
        f = self.evalf(2)
        if f.is_Float:
            match = (f, S.Zero)
        else:
            match = pure_complex(f)
        if match is None:
            return False
        r, i = match
        if not (i.is_Number and r.is_Number):
            return False
        if r._prec != 1 and i._prec != 1:
            return bool(not i and (r > 0 if positive else r < 0))
        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):
            try:
                if minimal_polynomial(self).is_Symbol:
                    return False
            except (NotAlgebraic, NotImplementedError):
                pass

.sympy.core.numbers.Number._eval_evalf

def _eval_evalf(self, prec):
    return Float._new(self._as_mpf_val(prec), prec)

.sympy.core.numbers.Integer._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_int(self.p, prec, rnd)

.sympy.core.numbers.Float._new

def _new(cls, _mpf_, _prec, zero=True):
    if zero and _mpf_ == fzero:
        return S.Zero
    elif _mpf_ == _mpf_nan:
        return S.NaN
    elif _mpf_ == _mpf_inf:
        return S.Infinity
    elif _mpf_ == _mpf_ninf:
        return S.NegativeInfinity
    obj = Expr.__new__(cls)
    obj._mpf_ = mpf_norm(_mpf_, _prec)
    obj._prec = _prec
    return obj

.sympy.core.numbers.mpf_norm

def mpf_norm(mpf, prec):
    sign, man, expt, bc = mpf
    if not man:
        if not bc:
            return fzero
        else:
            return mpf
    from mpmath.libmp.backend import MPZ
    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
    return rv

.sympy.core.evalf.EvalfMixin.evalf

def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
    from .numbers import Float, Number
    n = n if n is not None else 15
    if subs and is_sequence(subs):
        raise TypeError('subs must be given as a dictionary')
    if n == 1 and isinstance(self, Number):
        from .expr import _mag
        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
        m = _mag(rv)
        rv = rv.round(1 - m)
        return rv
    if not evalf_table:
        _create_evalf_table()
    prec = dps_to_prec(n)
    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}
    if subs is not None:
        options['subs'] = subs
    if quad is not None:
        options['quad'] = quad
    try:
        result = evalf(self, prec + 4, options)
    except NotImplementedError:
        if hasattr(self, 'subs') and subs is not None:
            v = self.subs(subs)._eval_evalf(prec)
        else:
            v = self._eval_evalf(prec)
        if v is None:
            return self
        elif not v.is_number:
            return v
        try:
            result = evalf(v, prec, options)
        except NotImplementedError:
            return v
    if result is S.ComplexInfinity:
        return result
    re, im, re_acc, im_acc = result
    if re is S.NaN or im is S.NaN:
        return S.NaN
    if re:
        p = max(min(prec, re_acc), 1)
        re = Float._new(re, p)
    else:
        re = S.Zero
    if im:
        p = max(min(prec, im_acc), 1)
        im = Float._new(im, p)
        return re + im * S.ImaginaryUnit
    else:
        return re

.sympy.core.evalf.evalf

def evalf(x: 'Expr', prec: int, options: OPT_DICT) -> TMP_RES:
    from sympy.functions.elementary.complexes import re as re_, im as im_
    try:
        rf = evalf_table[type(x)]
        r = rf(x, prec, options)
    except KeyError:
        if 'subs' in options:
            x = x.subs(evalf_subs(prec, options['subs']))
        xe = x._eval_evalf(prec)
        if xe is None:
            raise NotImplementedError
        as_real_imag = getattr(xe, 'as_real_imag', None)
        if as_real_imag is None:
            raise NotImplementedError
        re, im = as_real_imag()
        if re.has(re_) or im.has(im_):
            raise NotImplementedError
        if re == 0:
            re = None
            reprec = None
        elif re.is_number:
            re = re._to_mpmath(prec, allow_ints=False)._mpf_
            reprec = prec
        else:
            raise NotImplementedError
        if im == 0:
            im = None
            imprec = None
        elif im.is_number:
            im = im._to_mpmath(prec, allow_ints=False)._mpf_
            imprec = prec
        else:
            raise NotImplementedError
        r = (re, im, reprec, imprec)
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.evalf.evalf_integer

def evalf_integer(expr: 'Integer', prec: int, options: OPT_DICT) -> TMP_RES:
    return (from_int(expr.p, prec), None, prec, None)

.sympy.core.numbers.Float.__gt__

def __gt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__lt__(self)
    rv = self._Frel(other, mlib.mpf_gt)
    if rv is None:
        return Expr.__gt__(self, other)
    return rv

.sympy.core.numbers.Float._Frel

def _Frel(self, other, op):
    try:
        other = _sympify(other)
    except SympifyError:
        return NotImplemented
    if other.is_Rational:
        '\n        >>> f = Float(.1,2)\n        >>> i = 1234567890\n        >>> (f*i)._mpf_\n        (0, 471, 18, 9)\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\n        (0, 505555550955, -12, 39)\n        '
        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
        ompf = mlib.from_int(other.p)
        return _sympify(bool(op(smpf, ompf)))
    elif other.is_Float:
        return _sympify(bool(op(self._mpf_, other._mpf_)))
    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):
        other = other.evalf(prec_to_dps(self._prec))
        if other._prec > 1:
            if other.is_Number:
                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))

.sympy.logic.boolalg.BooleanTrue.__bool__

def __bool__(self):
    return True

.sympy.core.numbers.Half.__abs__

def __abs__():
    return S.Half

.sympy.integrals.intpoly.is_vertex

def is_vertex(ent):
    if isinstance(ent, tuple):
        if len(ent) in [2, 3]:
            return True
    elif isinstance(ent, Point):
        return True
    return False

.sympy.core.basic.Basic.subs

def subs(self, *args, **kwargs):
    from .containers import Dict
    from .symbol import Dummy, Symbol
    from .numbers import _illegal
    unordered = False
    if len(args) == 1:
        sequence = args[0]
        if isinstance(sequence, set):
            unordered = True
        elif isinstance(sequence, (Dict, Mapping)):
            unordered = True
            sequence = sequence.items()
        elif not iterable(sequence):
            raise ValueError(filldedent('\n               When a single argument is passed to subs\n               it should be a dictionary of old: new pairs or an iterable\n               of (old, new) tuples.'))
    elif len(args) == 2:
        sequence = [args]
    else:
        raise ValueError('subs accepts either 1 or 2 arguments')
    sequence = list(sequence)
    for i, s in enumerate(sequence):
        if isinstance(s[0], str):
            s = (Symbol(s[0]), s[1])
        try:
            s = [sympify(_, strict=not isinstance(_, (str, type))) for _ in s]
        except SympifyError:
            sequence[i] = None
            continue
        sequence[i] = None if _aresame(*s) else tuple(s)
    sequence = list(filter(None, sequence))
    simultaneous = kwargs.pop('simultaneous', False)
    if unordered:
        from .sorting import _nodes, default_sort_key
        sequence = dict(sequence)
        k = list(ordered(sequence, default=False, keys=(lambda x: -_nodes(x), default_sort_key)))
        sequence = [(k, sequence[k]) for k in k]
        if not simultaneous:
            redo = []
            for i in range(len(sequence)):
                if sequence[i][1] in _illegal:
                    redo.append(i)
            for i in reversed(redo):
                sequence.insert(0, sequence.pop(i))
    if simultaneous:
        reps = {}
        rv = self
        kwargs['hack2'] = True
        m = Dummy('subs_m')
        for old, new in sequence:
            com = new.is_commutative
            if com is None:
                com = True
            d = Dummy('subs_d', commutative=com)
            rv = rv._subs(old, d * m, **kwargs)
            if not isinstance(rv, Basic):
                break
            reps[d] = new
        reps[m] = S.One
        return rv.xreplace(reps)
    else:
        rv = self
        for old, new in sequence:
            rv = rv._subs(old, new, **kwargs)
            if not isinstance(rv, Basic):
                break
        return rv

.sympy.core.basic._aresame

def _aresame(a, b):
    from .numbers import Number
    from .function import AppliedUndef, UndefinedFunction as UndefFunc
    if isinstance(a, Number) and isinstance(b, Number):
        return a == b and a.__class__ == b.__class__
    for i, j in zip_longest(_preorder_traversal(a), _preorder_traversal(b)):
        if i != j or type(i) != type(j):
            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):
                if i.class_key() != j.class_key():
                    return False
            else:
                return False
    return True

.sympy.core.traversal.preorder_traversal.__init__

def __init__(self, node, keys=None):
    self._skip_flag = False
    self._pt = self._preorder_traversal(node, keys)

.sympy.core.traversal.preorder_traversal.__iter__

def __iter__(self):
    return self

.sympy.core.traversal.preorder_traversal.__next__

def __next__(self):
    return next(self._pt)

.sympy.core.traversal.preorder_traversal._preorder_traversal

def _preorder_traversal(self, node, keys):
    yield node
    if self._skip_flag:
        self._skip_flag = False
        return
    if isinstance(node, Basic):
        if not keys and hasattr(node, '_argset'):
            args = node._argset
        else:
            args = node.args
        if keys:
            if keys != True:
                args = ordered(args, keys, default=False)
            else:
                args = ordered(args)
        for arg in args:
            yield from self._preorder_traversal(arg, keys)
    elif iterable(node):
        for item in node:
            yield from self._preorder_traversal(item, keys)

.sympy.core.basic.Basic.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.sorting.ordered

def ordered(seq, keys=None, default=True, warn=False):
    d = defaultdict(list)
    if keys:
        if not isinstance(keys, (list, tuple)):
            keys = [keys]
        keys = list(keys)
        f = keys.pop(0)
        for a in seq:
            d[f(a)].append(a)
    else:
        if not default:
            raise ValueError('if default=False then keys must be provided')
        d[None].extend(seq)
    for k in sorted(d.keys()):
        if len(d[k]) > 1:
            if keys:
                d[k] = ordered(d[k], keys, default, warn)
            elif default:
                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)
            elif warn:
                u = list(uniq(d[k]))
                if len(u) > 1:
                    raise ValueError('not enough keys to break ties: %s' % u)
        yield from d[k]
        d.pop(k)

.sympy.core.sorting._nodes

def _nodes(e):
    from .basic import Basic
    from .function import Derivative
    if isinstance(e, Basic):
        if isinstance(e, Derivative):
            return _nodes(e.expr) + sum((i[1] if i[1].is_Number else _nodes(i[1]) for i in e.variable_count))
        return _node_count(e)
    elif iterable(e):
        return 1 + sum((_nodes(ei) for ei in e))
    elif isinstance(e, dict):
        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))
    else:
        return 1

.sympy.core.sorting._node_count

def _node_count(e):
    if e.is_Float:
        return 0.5
    return 1 + sum(map(_node_count, e.args))

.sympy.core.sorting.default_sort_key

def default_sort_key(item, order=None):
    from .basic import Basic
    from .singleton import S
    if isinstance(item, Basic):
        return item.sort_key(order=order)
    if iterable(item, exclude=str):
        if isinstance(item, dict):
            args = item.items()
            unordered = True
        elif isinstance(item, set):
            args = item
            unordered = True
        else:
            args = list(item)
            unordered = False
        args = [default_sort_key(arg, order=order) for arg in args]
        if unordered:
            args = sorted(args)
        cls_index, args = (10, (len(args), tuple(args)))
    else:
        if not isinstance(item, str):
            try:
                item = sympify(item, strict=True)
            except SympifyError:
                pass
            else:
                if isinstance(item, Basic):
                    return default_sort_key(item)
        cls_index, args = (0, (1, (str(item),)))
    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)

.sympy.core.symbol.Symbol.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)

.sympy.core.basic.Atom.class_key

def class_key(cls):
    return (2, 0, cls.__name__)

.sympy.core.numbers.Number.sort_key

def sort_key(self, order=None):
    return (self.class_key(), (0, ()), (), self)

.sympy.core.numbers.Number.class_key

def class_key(cls):
    return (1, 0, 'Number')

.sympy.core.numbers.NaN.__eq__

def __eq__(self, other):
    return other is S.NaN

.sympy.core.basic.Basic._subs

def _subs(self, old, new, **hints):

    def fallback(self, old, new):
        hit = False
        args = list(self.args)
        for i, arg in enumerate(args):
            if not hasattr(arg, '_eval_subs'):
                continue
            arg = arg._subs(old, new, **hints)
            if not _aresame(arg, args[i]):
                hit = True
                args[i] = arg
        if hit:
            rv = self.func(*args)
            hack2 = hints.get('hack2', False)
            if hack2 and self.is_Mul and (not rv.is_Mul):
                coeff = S.One
                nonnumber = []
                for i in args:
                    if i.is_Number:
                        coeff *= i
                    else:
                        nonnumber.append(i)
                nonnumber = self.func(*nonnumber)
                if coeff is S.One:
                    return nonnumber
                else:
                    return self.func(coeff, nonnumber, evaluate=False)
            return rv
        return self
    if _aresame(self, old):
        return new
    rv = self._eval_subs(old, new)
    if rv is None:
        rv = fallback(self, old, new)
    return rv

.sympy.core.mul.Mul._eval_subs

def _eval_subs(self, old, new):
    from sympy.functions.elementary.complexes import sign
    from sympy.ntheory.factor_ import multiplicity
    from sympy.simplify.powsimp import powdenest
    from sympy.simplify.radsimp import fraction
    if not old.is_Mul:
        return None
    if old.args[0].is_Number and old.args[0] < 0:
        if self.args[0].is_Number:
            if self.args[0] < 0:
                return self._subs(-old, -new)
            return None

    def base_exp(a):
        from sympy.functions.elementary.exponential import exp
        if a.is_Pow or isinstance(a, exp):
            return a.as_base_exp()
        return (a, S.One)

    def breakup(eq):
        c, nc = (defaultdict(int), list())
        for a in Mul.make_args(eq):
            a = powdenest(a)
            b, e = base_exp(a)
            if e is not S.One:
                co, _ = e.as_coeff_mul()
                b = Pow(b, e / co)
                e = co
            if a.is_commutative:
                c[b] += e
            else:
                nc.append([b, e])
        return (c, nc)

    def rejoin(b, co):
        b, e = base_exp(b)
        return Pow(b, e * co)

    def ndiv(a, b):
        if not b.q % a.q or not a.q % b.q:
            return int(a / b)
        return 0
    rv = None
    n, d = fraction(self)
    self2 = self
    if d is not S.One:
        self2 = n._subs(old, new) / d._subs(old, new)
        if not self2.is_Mul:
            return self2._subs(old, new)
        if self2 != self:
            rv = self2
    co_self = self2.args[0]
    co_old = old.args[0]
    co_xmul = None
    if co_old.is_Rational and co_self.is_Rational:
        if co_old != co_self:
            co_xmul = co_self.extract_multiplicatively(co_old)
    elif co_old.is_Rational:
        return rv
    c, nc = breakup(self2)
    old_c, old_nc = breakup(old)
    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):
        mult = S(multiplicity(abs(co_old), co_self))
        c.pop(co_self)
        if co_old in c:
            c[co_old] += mult
        else:
            c[co_old] = mult
        co_residual = co_self / co_old ** mult
    else:
        co_residual = 1
    ok = True
    if len(old_nc) > len(nc):
        ok = False
    elif len(old_c) > len(c):
        ok = False
    elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):
        ok = False
    elif set(old_c).difference(set(c)):
        ok = False
    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):
        ok = False
    if not ok:
        return rv
    if not old_c:
        cdid = None
    else:
        rat = []
        for b, old_e in old_c.items():
            c_e = c[b]
            rat.append(ndiv(c_e, old_e))
            if not rat[-1]:
                return rv
        cdid = min(rat)
    if not old_nc:
        ncdid = None
        for i in range(len(nc)):
            nc[i] = rejoin(*nc[i])
    else:
        ncdid = 0
        take = len(old_nc)
        limit = cdid or S.Infinity
        failed = []
        i = 0
        while limit and i + take <= len(nc):
            hit = False
            rat = []
            for j in range(take):
                if nc[i + j][0] != old_nc[j][0]:
                    break
                elif j == 0:
                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
                elif j == take - 1:
                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
                elif nc[i + j][1] != old_nc[j][1]:
                    break
                else:
                    rat.append(1)
                j += 1
            else:
                ndo = min(rat)
                if ndo:
                    if take == 1:
                        if cdid:
                            ndo = min(cdid, ndo)
                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])
                    else:
                        ndo = 1
                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])
                        mid = new
                        ir = i + take - 1
                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])
                        if r[1]:
                            if i + take < len(nc):
                                nc[i:i + take] = [l * mid, r]
                            else:
                                r = rejoin(*r)
                                nc[i:i + take] = [l * mid * r]
                        else:
                            nc[i:i + take] = [l * mid]
                    limit -= ndo
                    ncdid += ndo
                    hit = True
            if not hit:
                failed.append(i)
            i += 1
        else:
            if not ncdid:
                return rv
            failed.extend(range(i, len(nc)))
            for i in failed:
                nc[i] = rejoin(*nc[i]).subs(old, new)
    if cdid is None:
        do = ncdid
    elif ncdid is None:
        do = cdid
    else:
        do = min(ncdid, cdid)
    margs = []
    for b in c:
        if b in old_c:
            e = c[b] - old_c[b] * do
            margs.append(rejoin(b, e))
        else:
            margs.append(rejoin(b.subs(old, new), c[b]))
    if cdid and (not ncdid):
        margs = [Pow(new, cdid)] + margs
    return co_residual * self2.func(*margs) * self2.func(*nc)

.sympy.core.basic.Basic.fallback

def fallback(self, old, new):
    hit = False
    args = list(self.args)
    for i, arg in enumerate(args):
        if not hasattr(arg, '_eval_subs'):
            continue
        arg = arg._subs(old, new, **hints)
        if not _aresame(arg, args[i]):
            hit = True
            args[i] = arg
    if hit:
        rv = self.func(*args)
        hack2 = hints.get('hack2', False)
        if hack2 and self.is_Mul and (not rv.is_Mul):
            coeff = S.One
            nonnumber = []
            for i in args:
                if i.is_Number:
                    coeff *= i
                else:
                    nonnumber.append(i)
            nonnumber = self.func(*nonnumber)
            if coeff is S.One:
                return nonnumber
            else:
                return self.func(coeff, nonnumber, evaluate=False)
        return rv
    return self

.sympy.core.symbol.Symbol._eval_subs

def _eval_subs(self, old, new):
    if old.is_Pow:
        from sympy.core.power import Pow
        return Pow(self, S.One, evaluate=False)._eval_subs(old, new)

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.numbers.igcd

def igcd(*args):
    if len(args) < 2:
        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))
    args_temp = [abs(as_int(i)) for i in args]
    if 1 in args_temp:
        return 1
    a = args_temp.pop()
    if HAS_GMPY:
        for b in args_temp:
            a = gmpy.gcd(a, b) if b else a
        return as_int(a)
    for b in args_temp:
        a = math.gcd(a, b)
    return a

.sympy.core.numbers.Rational._as_mpf_val

def _as_mpf_val(self, prec):
    return mlib.from_rational(self.p, self.q, prec, rnd)

.sympy.core.numbers.Number._eval_subs

def _eval_subs(self, old, new):
    if old == -self:
        return -new
    return self

.sympy.core.numbers.Zero.__neg__

def __neg__():
    return S.Zero

.sympy.core.expr.Expr.__add__

def __add__(self, other):
    return Add(self, other)

.sympy.core.basic.Basic._do_eq_sympify

def _do_eq_sympify(self, other):
    for superclass in type(other).__mro__:
        conv = _external_converter.get(superclass)
        if conv is not None:
            return self == conv(other)
    if hasattr(other, '_sympy_'):
        return self == other._sympy_()
    return NotImplemented

.sympy.core.numbers.Rational.__add__

def __add__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p + self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return other + self
        else:
            return Number.__add__(self, other)
    return Number.__add__(self, other)

.sympy.core.numbers.Integer._eval_is_odd

def _eval_is_odd(self):
    return bool(self.p % 2)

.sympy.core.numbers.NegativeOne.__neg__

def __neg__():
    return S.One

.sympy.core.add.Add.flatten

def flatten(cls, seq):
    from sympy.calculus.accumulationbounds import AccumBounds
    from sympy.matrices.expressions import MatrixExpr
    from sympy.tensor.tensor import TensExpr
    rv = None
    if len(seq) == 2:
        a, b = seq
        if b.is_Rational:
            a, b = (b, a)
        if a.is_Rational:
            if b.is_Mul:
                rv = ([a, b], [], None)
        if rv:
            if all((s.is_commutative for s in rv[0])):
                return rv
            return ([], rv[0], None)
    terms = {}
    coeff = S.Zero
    order_factors = []
    extra = []
    for o in seq:
        if o.is_Order:
            if o.expr.is_zero:
                continue
            for o1 in order_factors:
                if o1.contains(o):
                    o = None
                    break
            if o is None:
                continue
            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]
            continue
        elif o.is_Number:
            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):
                return ([S.NaN], [], None)
            if coeff.is_Number or isinstance(coeff, AccumBounds):
                coeff += o
                if coeff is S.NaN and (not extra):
                    return ([S.NaN], [], None)
            continue
        elif isinstance(o, AccumBounds):
            coeff = o.__add__(coeff)
            continue
        elif isinstance(o, MatrixExpr):
            extra.append(o)
            continue
        elif isinstance(o, TensExpr):
            coeff = o.__add__(coeff) if coeff else o
            continue
        elif o is S.ComplexInfinity:
            if coeff.is_finite is False and (not extra):
                return ([S.NaN], [], None)
            coeff = S.ComplexInfinity
            continue
        elif o.is_Add:
            seq.extend(o.args)
            continue
        elif o.is_Mul:
            c, s = o.as_coeff_Mul()
        elif o.is_Pow:
            b, e = o.as_base_exp()
            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):
                seq.append(b ** e)
                continue
            c, s = (S.One, o)
        else:
            c = S.One
            s = o
        if s in terms:
            terms[s] += c
            if terms[s] is S.NaN and (not extra):
                return ([S.NaN], [], None)
        else:
            terms[s] = c
    newseq = []
    noncommutative = False
    for s, c in terms.items():
        if c.is_zero:
            continue
        elif c is S.One:
            newseq.append(s)
        elif s.is_Mul:
            cs = s._new_rawargs(*(c,) + s.args)
            newseq.append(cs)
        elif s.is_Add:
            newseq.append(Mul(c, s, evaluate=False))
        else:
            newseq.append(Mul(c, s))
        noncommutative = noncommutative or not s.is_commutative
    if coeff is S.Infinity:
        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]
    elif coeff is S.NegativeInfinity:
        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]
    if coeff is S.ComplexInfinity:
        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]
    if order_factors:
        newseq2 = []
        for t in newseq:
            for o in order_factors:
                if o.contains(t):
                    t = None
                    break
            if t is not None:
                newseq2.append(t)
        newseq = newseq2 + order_factors
        for o in order_factors:
            if o.contains(coeff):
                coeff = S.Zero
                break
    _addsort(newseq)
    if coeff is not S.Zero:
        newseq.insert(0, coeff)
    if extra:
        newseq += extra
        noncommutative = True
    if noncommutative:
        return ([], newseq, None)
    else:
        return (newseq, [], None)

.sympy.core.add._addsort

def _addsort(args):
    args.sort(key=_args_sortkey)

.sympy.core.add.Add._eval_is_zero

def _eval_is_zero(self):
    if self.is_commutative is False:
        return
    nz = []
    z = 0
    im_or_z = False
    im = 0
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                z += 1
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im += 1
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_or_z = True
        else:
            return
    if z == len(self.args):
        return True
    if len(nz) in [0, len(self.args)]:
        return None
    b = self.func(*nz)
    if b.is_zero:
        if not im_or_z:
            if im == 0:
                return True
            elif im == 1:
                return False
    if b.is_zero is False:
        return False

.sympy.core.numbers.Rational.as_numer_denom

def as_numer_denom(self):
    return (Integer(self.p), Integer(self.q))

.sympy.core.numbers.Integer.__divmod__

def __divmod__(self, other):
    if isinstance(other, Integer) and global_parameters.evaluate:
        return Tuple(*divmod(self.p, other.p))
    else:
        return Number.__divmod__(self, other)

.sympy.core.numbers.Integer.__mod__

def __mod__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p % other)
        elif isinstance(other, Integer):
            return Integer(self.p % other.p)
        return Rational.__mod__(self, other)
    return Rational.__mod__(self, other)

.sympy.core.add.Add._eval_is_infinite

def _eval_is_infinite(self):
    sawinf = False
    for a in self.args:
        ainf = a.is_infinite
        if ainf is None:
            return None
        elif ainf is True:
            if sawinf is True:
                return None
            sawinf = True
    return sawinf

.sympy.core.add.Add._eval_is_irrational

def _eval_is_irrational(self):
    for t in self.args:
        a = t.is_irrational
        if a:
            others = list(self.args)
            others.remove(t)
            if all((x.is_rational is True for x in others)):
                return True
            return None
        if a is None:
            return
    return False

.sympy.core.add.Add._eval_is_extended_positive

def _eval_is_extended_positive(self):
    if self.is_number:
        return super()._eval_is_extended_positive()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        from .exprtools import _monotonic_sign
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_positive and a.is_extended_nonnegative:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_positive:
                    return True
    pos = nonneg = nonpos = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        ispos = a.is_extended_positive
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))
            if True in saw_INF and False in saw_INF:
                return
        if ispos:
            pos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonpos and (not nonneg) and pos:
        return True
    elif not nonpos and pos:
        return True
    elif not pos and (not nonneg):
        return False

.sympy.core.expr.Expr.is_number

def is_number(self):
    return all((obj.is_number for obj in self.args))

.sympy.core.add.Add.as_coeff_Add

def as_coeff_Add(self, rational=False, deps=None):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number and (not rational) or coeff.is_Rational:
        return (coeff, self._new_rawargs(*args))
    return (S.Zero, self)

.sympy.core.add.Add._eval_is_imaginary

def _eval_is_imaginary(self):
    nz = []
    im_I = []
    for a in self.args:
        if a.is_extended_real:
            if a.is_zero:
                pass
            elif a.is_zero is False:
                nz.append(a)
            else:
                return
        elif a.is_imaginary:
            im_I.append(a * S.ImaginaryUnit)
        elif (S.ImaginaryUnit * a).is_extended_real:
            im_I.append(a * S.ImaginaryUnit)
        else:
            return
    b = self.func(*nz)
    if b.is_zero:
        return fuzzy_not(self.func(*im_I).is_zero)
    elif b.is_zero is False:
        return False

.sympy.core.add.Add._eval_is_extended_negative

def _eval_is_extended_negative(self):
    if self.is_number:
        return super()._eval_is_extended_negative()
    c, a = self.as_coeff_Add()
    if not c.is_zero:
        from .exprtools import _monotonic_sign
        v = _monotonic_sign(a)
        if v is not None:
            s = v + c
            if s != self and s.is_extended_negative and a.is_extended_nonpositive:
                return True
            if len(self.free_symbols) == 1:
                v = _monotonic_sign(self)
                if v is not None and v != self and v.is_extended_negative:
                    return True
    neg = nonpos = nonneg = unknown_sign = False
    saw_INF = set()
    args = [a for a in self.args if not a.is_zero]
    if not args:
        return False
    for a in args:
        isneg = a.is_extended_negative
        infinite = a.is_infinite
        if infinite:
            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))
            if True in saw_INF and False in saw_INF:
                return
        if isneg:
            neg = True
            continue
        elif a.is_extended_nonpositive:
            nonpos = True
            continue
        elif a.is_extended_nonnegative:
            nonneg = True
            continue
        if infinite is None:
            return
        unknown_sign = True
    if saw_INF:
        if len(saw_INF) > 1:
            return
        return saw_INF.pop()
    elif unknown_sign:
        return
    elif not nonneg and (not nonpos) and neg:
        return True
    elif not nonneg and neg:
        return True
    elif not neg and (not nonpos):
        return False

.sympy.core.add.Add._eval_is_odd

def _eval_is_odd(self):
    l = [f for f in self.args if not f.is_even is True]
    if not l:
        return False
    if l[0].is_odd:
        return self._new_rawargs(*l[1:]).is_even

.sympy.core.add.Add._eval_is_extended_nonpositive

def _eval_is_extended_nonpositive(self):
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonpositive:
            from .exprtools import _monotonic_sign
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonpositive:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonpositive:
                        return True

.sympy.core.add.Add._eval_is_extended_nonnegative

def _eval_is_extended_nonnegative(self):
    if not self.is_number:
        c, a = self.as_coeff_Add()
        if not c.is_zero and a.is_extended_nonnegative:
            from .exprtools import _monotonic_sign
            v = _monotonic_sign(a)
            if v is not None:
                s = v + c
                if s != self and s.is_extended_nonnegative:
                    return True
                if len(self.free_symbols) == 1:
                    v = _monotonic_sign(self)
                    if v is not None and v != self and v.is_extended_nonnegative:
                        return True

.sympy.core.basic.Basic._eval_derivative_n_times

def _eval_derivative_n_times(self, s, n):
    from .numbers import Integer
    if isinstance(n, (int, Integer)):
        obj = self
        for i in range(n):
            obj2 = obj._eval_derivative(s)
            if obj == obj2 or obj2 is None:
                break
            obj = obj2
        return obj2
    else:
        return None

.sympy.core.add.Add._eval_derivative

def _eval_derivative(self, s):
    return self.func(*[a.diff(s) for a in self.args])

.sympy.core.numbers.Rational._eval_is_zero

def _eval_is_zero(self):
    return self.p == 0

.sympy.core.numbers.Integer._eval_power

def _eval_power(self, expt):
    from sympy.ntheory.factor_ import perfect_power
    if expt is S.Infinity:
        if self.p > S.One:
            return S.Infinity
        return S.Infinity + S.ImaginaryUnit * S.Infinity
    if expt is S.NegativeInfinity:
        return Rational(1, self, 1) ** S.Infinity
    if not isinstance(expt, Number):
        if self.is_negative and expt.is_even:
            return (-self) ** expt
    if isinstance(expt, Float):
        return super()._eval_power(expt)
    if not isinstance(expt, Rational):
        return
    if expt is S.Half and self.is_negative:
        return S.ImaginaryUnit * Pow(-self, expt)
    if expt.is_negative:
        ne = -expt
        if self.is_negative:
            return S.NegativeOne ** expt * Rational(1, -self, 1) ** ne
        else:
            return Rational(1, self.p, 1) ** ne
    x, xexact = integer_nthroot(abs(self.p), expt.q)
    if xexact:
        result = Integer(x ** abs(expt.p))
        if self.is_negative:
            result *= S.NegativeOne ** expt
        return result
    b_pos = int(abs(self.p))
    p = perfect_power(b_pos)
    if p is not False:
        dict = {p[0]: p[1]}
    else:
        dict = Integer(b_pos).factors(limit=2 ** 15)
    out_int = 1
    out_rad = 1
    sqr_int = 1
    sqr_gcd = 0
    sqr_dict = {}
    for prime, exponent in dict.items():
        exponent *= expt.p
        div_e, div_m = divmod(exponent, expt.q)
        if div_e > 0:
            out_int *= prime ** div_e
        if div_m > 0:
            g = igcd(div_m, expt.q)
            if g != 1:
                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g, 1))
            else:
                sqr_dict[prime] = div_m
    for p, ex in sqr_dict.items():
        if sqr_gcd == 0:
            sqr_gcd = ex
        else:
            sqr_gcd = igcd(sqr_gcd, ex)
            if sqr_gcd == 1:
                break
    for k, v in sqr_dict.items():
        sqr_int *= k ** (v // sqr_gcd)
    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):
        result = None
    else:
        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))
        if self.is_negative:
            result *= Pow(S.NegativeOne, expt)
    return result

.sympy.core.expr.Expr._eval_is_extended_negative

def _eval_is_extended_negative(self):
    return self._eval_is_extended_positive_negative(positive=False)

.sympy.core.numbers.Float.__lt__

def __lt__(self, other):
    if isinstance(other, NumberSymbol):
        return other.__gt__(self)
    rv = self._Frel(other, mlib.mpf_lt)
    if rv is None:
        return Expr.__lt__(self, other)
    return rv

.sympy.logic.boolalg.BooleanFalse.__bool__

def __bool__(self):
    return False

.sympy.core.power.integer_nthroot

def integer_nthroot(y, n):
    y, n = (as_int(y), as_int(n))
    if y < 0:
        raise ValueError('y must be nonnegative')
    if n < 1:
        raise ValueError('n must be positive')
    if HAS_GMPY and n < 2 ** 63:
        if HAS_GMPY >= 2:
            x, t = gmpy.iroot(y, n)
        else:
            x, t = gmpy.root(y, n)
        return (as_int(x), bool(t))
    return _integer_nthroot_python(y, n)

.sympy.core.power._integer_nthroot_python

def _integer_nthroot_python(y, n):
    if y in (0, 1):
        return (y, True)
    if n == 1:
        return (y, True)
    if n == 2:
        x, rem = mpmath_sqrtrem(y)
        return (int(x), not rem)
    if n > y:
        return (1, False)
    try:
        guess = int(y ** (1.0 / n) + 0.5)
    except OverflowError:
        exp = _log(y, 2) / n
        if exp > 53:
            shift = int(exp - 53)
            guess = int(2.0 ** (exp - shift) + 1) << shift
        else:
            guess = int(2.0 ** exp)
    if guess > 2 ** 50:
        xprev, x = (-1, guess)
        while 1:
            t = x ** (n - 1)
            xprev, x = (x, ((n - 1) * x + y // t) // n)
            if abs(x - xprev) < 2:
                break
    else:
        x = guess
    t = x ** n
    while t < y:
        x += 1
        t = x ** n
    while t > y:
        x -= 1
        t = x ** n
    return (int(x), t == y)

.sympy.ntheory.factor_.perfect_power

def perfect_power(n, candidates=None, big=True, factor=True):
    if isinstance(n, Rational) and (not n.is_Integer):
        p, q = n.as_numer_denom()
        if p is S.One:
            pp = perfect_power(q)
            if pp:
                pp = (n.func(1, pp[0]), pp[1])
        else:
            pp = perfect_power(p)
            if pp:
                num, e = pp
                pq = perfect_power(q, [e])
                if pq:
                    den, _ = pq
                    pp = (n.func(num, den), e)
        return pp
    n = as_int(n)
    if n < 0:
        pp = perfect_power(-n)
        if pp:
            b, e = pp
            if e % 2:
                return (-b, e)
        return False
    if n <= 3:
        return False
    logn = math.log(n, 2)
    max_possible = int(logn) + 2
    not_square = n % 10 in [2, 3, 7, 8]
    min_possible = 2 + not_square
    if not candidates:
        candidates = primerange(min_possible, max_possible)
    else:
        candidates = sorted([i for i in candidates if min_possible <= i < max_possible])
        if n % 2 == 0:
            e = trailing(n)
            candidates = [i for i in candidates if e % i == 0]
        if big:
            candidates = reversed(candidates)
        for e in candidates:
            r, ok = integer_nthroot(n, e)
            if ok:
                return (r, e)
        return False

    def _factors():
        rv = 2 + n % 2
        while True:
            yield rv
            rv = nextprime(rv)
    for fac, e in zip(_factors(), candidates):
        if factor and n % fac == 0:
            if fac == 2:
                e = trailing(n)
            else:
                e = multiplicity(fac, n)
            if e == 1:
                return False
            r, exact = integer_nthroot(n, e)
            if not exact:
                m = n // fac ** e
                rE = perfect_power(m, candidates=divisors(e, generator=True))
                if not rE:
                    return False
                else:
                    r, E = rE
                    r, e = (fac ** (e // E) * r, E)
            if not big:
                e0 = primefactors(e)
                if e0[0] != e:
                    r, e = (r ** (e // e0[0]), e0[0])
            return (r, e)
        if logn / e < 40:
            b = 2.0 ** (logn / e)
            if abs(int(b + 0.5) - b) > 0.01:
                continue
        r, exact = integer_nthroot(n, e)
        if exact:
            if big:
                m = perfect_power(r, big=big, factor=factor)
                if m:
                    r, e = (m[0], e * m[1])
            return (int(r), e)
    return False

.sympy.core.numbers.Rational.factors

def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):
    from sympy.ntheory.factor_ import factorrat
    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()

.sympy.ntheory.factor_.factorrat

def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):
    if multiple:
        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])
        return factorlist
    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()
    f = defaultdict(int, f)
    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():
        f[p] += -e
    if len(f) > 1 and 1 in f:
        del f[1]
    if not visual:
        return dict(f)
    else:
        if -1 in f:
            f.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])
        return Mul(*args, evaluate=False)

.sympy.ntheory.factor_.factorint

def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, use_ecm=True, verbose=False, visual=None, multiple=False):
    if isinstance(n, Dict):
        n = dict(n)
    if multiple:
        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)
        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p in sorted(fac)), [])
        return factorlist
    factordict = {}
    if visual and (not isinstance(n, (Mul, dict))):
        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
    elif isinstance(n, Mul):
        factordict = {int(k): int(v) for k, v in n.as_powers_dict().items()}
    elif isinstance(n, dict):
        factordict = n
    if factordict and isinstance(n, (Mul, dict)):
        for key in list(factordict.keys()):
            if isprime(key):
                continue
            e = factordict.pop(key)
            d = factorint(key, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
            for k, v in d.items():
                if k in factordict:
                    factordict[k] += v * e
                else:
                    factordict[k] = v * e
    if visual or (type(n) is dict and visual is not True and (visual is not False)):
        if factordict == {}:
            return S.One
        if -1 in factordict:
            factordict.pop(-1)
            args = [S.NegativeOne]
        else:
            args = []
        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])
        return Mul(*args, evaluate=False)
    elif isinstance(n, (dict, Mul)):
        return factordict
    assert use_trial or use_rho or use_pm1 or use_ecm
    from sympy.functions.combinatorial.factorials import factorial
    if isinstance(n, factorial):
        x = as_int(n.args[0])
        if x >= 20:
            factors = {}
            m = 2
            for p in sieve.primerange(2, x + 1):
                if m > 1:
                    m, q = (0, x // p)
                    while q != 0:
                        m += q
                        q //= p
                factors[p] = m
            if factors and verbose:
                for k in sorted(factors):
                    print(factor_msg % (k, factors[k]))
            if verbose:
                print(complete_msg)
            return factors
        else:
            n = n.func(x)
    n = as_int(n)
    if limit:
        limit = int(limit)
        use_ecm = False
    if n < 0:
        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)
        factors[-1] = 1
        return factors
    if limit and limit < 2:
        if n == 1:
            return {}
        return {n: 1}
    elif n < 10:
        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]
    factors = {}
    if verbose:
        sn = str(n)
        if len(sn) > 50:
            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])
        else:
            print('Factoring', n)
    if use_trial:
        small = 2 ** 15
        fail_max = 600
        small = min(small, limit or small)
        if verbose:
            print(trial_int_msg % (2, small, fail_max))
        n, next_p = _factorint_small(factors, n, small, fail_max)
    else:
        next_p = 2
    if factors and verbose:
        for k in sorted(factors):
            print(factor_msg % (k, factors[k]))
    if next_p == 0:
        if n > 1:
            factors[int(n)] = 1
        if verbose:
            print(complete_msg)
        return factors
    try:
        if limit and next_p > limit:
            if verbose:
                print('Exceeded limit:', limit)
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            if n > 1:
                factors[int(n)] = 1
            return factors
        else:
            sqrt_n = integer_nthroot(n, 2)[0]
            a = sqrt_n + 1
            a2 = a ** 2
            b2 = a2 - n
            for i in range(3):
                b, fermat = integer_nthroot(b2, 2)
                if fermat:
                    break
                b2 += 2 * a + 1
                a += 1
            if fermat:
                if verbose:
                    print(fermat_msg)
                if limit:
                    limit -= 1
                for r in [a - b, a + b]:
                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)
                    for k, v in facs.items():
                        factors[k] = factors.get(k, 0) + v
                raise StopIteration
            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
    except StopIteration:
        if verbose:
            print(complete_msg)
        return factors
    low, high = (next_p, 2 * next_p)
    limit = limit or sqrt_n
    limit += 1
    iteration = 0
    while 1:
        try:
            high_ = high
            if limit < high_:
                high_ = limit
            if use_trial:
                if verbose:
                    print(trial_msg % (low, high_))
                ps = sieve.primerange(low, high_)
                n, found_trial = _trial(factors, n, ps, verbose)
                if found_trial:
                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            else:
                found_trial = False
            if high > limit:
                if verbose:
                    print('Exceeded limit:', limit)
                if n > 1:
                    factors[int(n)] = 1
                raise StopIteration
            if not found_trial:
                if use_pm1 or use_rho:
                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)
                    if use_pm1:
                        if verbose:
                            print(pm1_msg % (high_root, high_))
                        c = pollard_pm1(n, B=high_root, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
                    if use_rho:
                        max_steps = high_root
                        if verbose:
                            print(rho_msg % (1, max_steps, high_))
                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)
                        if c:
                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)
                            n, _ = _trial(factors, n, ps, verbose=False)
                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
        except StopIteration:
            if verbose:
                print(complete_msg)
            return factors
        iteration += 1
        if use_ecm and iteration >= 3 and (len(str(n)) >= 25):
            break
        low, high = (high, high * 2)
    B1 = 10000
    B2 = 100 * B1
    num_curves = 50
    while 1:
        if verbose:
            print(ecm_msg % (B1, B2, num_curves))
        while 1:
            try:
                factor = _ecm_one_factor(n, B1, B2, num_curves)
                ps = factorint(factor, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)
                n, _ = _trial(factors, n, ps, verbose=False)
                _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)
            except ValueError:
                break
            except StopIteration:
                if verbose:
                    print(complete_msg)
                return factors
        B1 *= 5
        B2 = 100 * B1
        num_curves *= 4

.sympy.core.numbers.Integer.__neg__

def __neg__(self):
    return Integer(-self.p)

.sympy.core.expr.Expr.as_coeff_Mul

def as_coeff_Mul(self, rational: bool=False) -> tTuple['Number', 'Expr']:
    return (S.One, self)

.sympy.core.power.Pow.as_base_exp

def as_base_exp(self):
    b, e = self.args
    if b.is_Rational and b.p == 1 and (b.q != 1):
        return (Integer(b.q), -e)
    return (b, e)

.sympy.core.numbers.Rational.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.core.numbers.Number.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.core.numbers.Rational._hashable_content

def _hashable_content(self):
    return (self.p, self.q)

.sympy.core.numbers.Number.__add__

def __add__(self, other):
    if isinstance(other, Number) and global_parameters.evaluate:
        if other is S.NaN:
            return S.NaN
        elif other is S.Infinity:
            return S.Infinity
        elif other is S.NegativeInfinity:
            return S.NegativeInfinity
    return AtomicExpr.__add__(self, other)

.sympy.core.expr.Expr.__truediv__

def __truediv__(self, other):
    denom = Pow(other, S.NegativeOne)
    if self is S.One:
        return denom
    else:
        return Mul(self, denom)

.sympy.core.numbers.NegativeOne.__abs__

def __abs__():
    return S.One

.sympy.core.add.Add._eval_subs

def _eval_subs(self, old, new):
    if not old.is_Add:
        if old is S.Infinity and -old in self.args:
            return self.xreplace({-old: -new})
        return None
    coeff_self, terms_self = self.as_coeff_Add()
    coeff_old, terms_old = old.as_coeff_Add()
    if coeff_self.is_Rational and coeff_old.is_Rational:
        if terms_self == terms_old:
            return self.func(new, coeff_self, -coeff_old)
        if terms_self == -terms_old:
            return self.func(-new, coeff_self, coeff_old)
    if coeff_self.is_Rational and coeff_old.is_Rational or coeff_self == coeff_old:
        args_old, args_self = (self.func.make_args(terms_old), self.func.make_args(terms_self))
        if len(args_old) < len(args_self):
            self_set = set(args_self)
            old_set = set(args_old)
            if old_set < self_set:
                ret_set = self_set - old_set
                return self.func(new, coeff_self, -coeff_old, *[s._subs(old, new) for s in ret_set])
            args_old = self.func.make_args(-terms_old)
            old_set = set(args_old)
            if old_set < self_set:
                ret_set = self_set - old_set
                return self.func(-new, coeff_self, coeff_old, *[s._subs(old, new) for s in ret_set])

.sympy.core.power.Pow._eval_is_finite

def _eval_is_finite(self):
    if self.exp.is_negative:
        if self.base.is_zero:
            return False
        if self.base.is_infinite or self.base.is_nonzero:
            return True
    c1 = self.base.is_finite
    if c1 is None:
        return
    c2 = self.exp.is_finite
    if c2 is None:
        return
    if c1 and c2:
        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):
            return True

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.numbers.One.__neg__

def __neg__():
    return S.NegativeOne

.sympy.core.mul.Mul.as_coeff_Mul

def as_coeff_Mul(self, rational=False):
    coeff, args = (self.args[0], self.args[1:])
    if coeff.is_Number:
        if not rational or coeff.is_Rational:
            if len(args) == 1:
                return (coeff, args[0])
            else:
                return (coeff, self._new_rawargs(*args))
        elif coeff.is_extended_negative:
            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))
    return (S.One, self)

.sympy.core.numbers.Number.__truediv__

def __truediv__(self, other):
    if isinstance(other, Number) and global_parameters.evaluate:
        if other is S.NaN:
            return S.NaN
        elif other in (S.Infinity, S.NegativeInfinity):
            return S.Zero
    return AtomicExpr.__truediv__(self, other)

.sympy.core.power.Pow._eval_power

def _eval_power(self, other):
    b, e = self.as_base_exp()
    if b is S.NaN:
        return (b ** e) ** other
    s = None
    if other.is_integer:
        s = 1
    elif b.is_polar:
        s = 1
    elif e.is_extended_real is not None:
        from sympy.functions.elementary.complexes import arg, im, re, sign
        from sympy.functions.elementary.exponential import exp, log
        from sympy.functions.elementary.integers import floor

        def _half(e):
            if getattr(e, 'q', None) == 2:
                return True
            n, d = e.as_numer_denom()
            if n.is_integer and d == 2:
                return True

        def _n2(e):
            try:
                rv = e.evalf(2, strict=True)
                if rv.is_Number:
                    return rv
            except PrecisionExhausted:
                pass
        if e.is_extended_real:
            if e == -1:
                if _half(other):
                    if b.is_negative is True:
                        return S.NegativeOne ** other * Pow(-b, e * other)
                    elif b.is_negative is False:
                        return Pow(b, -other)
            elif e.is_even:
                if b.is_extended_real:
                    b = abs(b)
                if b.is_imaginary:
                    b = abs(im(b)) * S.ImaginaryUnit
            if (abs(e) < 1) == True or e == 1:
                s = 1
            elif b.is_extended_nonnegative:
                s = 1
            elif re(b).is_extended_nonnegative and (abs(e) < 2) == True:
                s = 1
            elif fuzzy_not(im(b).is_zero) and abs(e) == 2:
                s = 1
            elif _half(other):
                s = exp(2 * S.Pi * S.ImaginaryUnit * other * floor(S.Half - e * arg(b) / (2 * S.Pi)))
                if s.is_extended_real and _n2(sign(s) - s) == 0:
                    s = sign(s)
                else:
                    s = None
        else:
            try:
                s = exp(2 * S.ImaginaryUnit * S.Pi * other * floor(S.Half - im(e * log(b)) / 2 / S.Pi))
                if s.is_extended_real and _n2(sign(s) - s) == 0:
                    s = sign(s)
                else:
                    s = None
            except PrecisionExhausted:
                s = None
    if s is not None:
        return s * Pow(b, e * other)

.sympy.core.evalf.evalf_rational

def evalf_rational(expr: 'Rational', prec: int, options: OPT_DICT) -> TMP_RES:
    return (from_rational(expr.p, expr.q, prec), None, prec, None)

.sympy.core.numbers.Rational.__neg__

def __neg__(self):
    return Rational(-self.p, self.q)

.sympy.core.numbers.Rational._eval_power

def _eval_power(self, expt):
    if isinstance(expt, Number):
        if isinstance(expt, Float):
            return self._eval_evalf(expt._prec) ** expt
        if expt.is_extended_negative:
            ne = -expt
            if ne is S.One:
                return Rational(self.q, self.p)
            if self.is_negative:
                return S.NegativeOne ** expt * Rational(self.q, -self.p) ** ne
            else:
                return Rational(self.q, self.p) ** ne
        if expt is S.Infinity:
            if self.p > self.q:
                return S.Infinity
            if self.p < -self.q:
                return S.Infinity + S.Infinity * S.ImaginaryUnit
            return S.Zero
        if isinstance(expt, Integer):
            return Rational(self.p ** expt.p, self.q ** expt.p, 1)
        if isinstance(expt, Rational):
            intpart = expt.p // expt.q
            if intpart:
                intpart += 1
                remfracpart = intpart * expt.q - expt.p
                ratfracpart = Rational(remfracpart, expt.q)
                if self.p != 1:
                    return Integer(self.p) ** expt * Integer(self.q) ** ratfracpart * Rational(1, self.q ** intpart, 1)
                return Integer(self.q) ** ratfracpart * Rational(1, self.q ** intpart, 1)
            else:
                remfracpart = expt.q - expt.p
                ratfracpart = Rational(remfracpart, expt.q)
                if self.p != 1:
                    return Integer(self.p) ** expt * Integer(self.q) ** ratfracpart * Rational(1, self.q, 1)
                return Integer(self.q) ** ratfracpart * Rational(1, self.q, 1)
    if self.is_extended_negative and expt.is_even:
        return (-self) ** expt
    return

.sympy.core.power.Pow._eval_is_extended_real

def _eval_is_extended_real(self):
    if self.base is S.Exp1:
        if self.exp.is_extended_real:
            return True
        elif self.exp.is_imaginary:
            return (2 * S.ImaginaryUnit * self.exp / S.Pi).is_even
    from sympy.functions.elementary.exponential import log, exp
    real_b = self.base.is_extended_real
    if real_b is None:
        if self.base.func == exp and self.base.exp.is_imaginary:
            return self.exp.is_imaginary
        if self.base.func == Pow and self.base.base is S.Exp1 and self.base.exp.is_imaginary:
            return self.exp.is_imaginary
        return
    real_e = self.exp.is_extended_real
    if real_e is None:
        return
    if real_b and real_e:
        if self.base.is_extended_positive:
            return True
        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:
            return True
        elif self.exp.is_integer and self.base.is_extended_nonzero:
            return True
        elif self.exp.is_integer and self.exp.is_nonnegative:
            return True
        elif self.base.is_extended_negative:
            if self.exp.is_Rational:
                return False
    if real_e and self.exp.is_extended_negative and (self.base.is_zero is False):
        return Pow(self.base, -self.exp).is_extended_real
    im_b = self.base.is_imaginary
    im_e = self.exp.is_imaginary
    if im_b:
        if self.exp.is_integer:
            if self.exp.is_even:
                return True
            elif self.exp.is_odd:
                return False
        elif im_e and log(self.base).is_imaginary:
            return True
        elif self.exp.is_Add:
            c, a = self.exp.as_coeff_Add()
            if c and c.is_Integer:
                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real
        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
            if (self.exp / 2).is_integer is False:
                return False
    if real_b and im_e:
        if self.base is S.NegativeOne:
            return True
        c = self.exp.coeff(S.ImaginaryUnit)
        if c:
            if self.base.is_rational and c.is_rational:
                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:
                    return False
            ok = (c * log(self.base) / S.Pi).is_integer
            if ok is not None:
                return ok
    if real_b is False:
        from sympy.functions.elementary.complexes import arg
        i = arg(self.base) * self.exp / S.Pi
        if i.is_complex:
            return i.is_integer

.sympy.core.power.Pow._eval_is_extended_positive

def _eval_is_extended_positive(self):
    if self.base == self.exp:
        if self.base.is_extended_nonnegative:
            return True
    elif self.base.is_positive:
        if self.exp.is_real:
            return True
    elif self.base.is_extended_negative:
        if self.exp.is_even:
            return True
        if self.exp.is_odd:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return self.exp.is_zero
    elif self.base.is_extended_nonpositive:
        if self.exp.is_odd:
            return False
    elif self.base.is_imaginary:
        if self.exp.is_integer:
            m = self.exp % 4
            if m.is_zero:
                return True
            if m.is_integer and m.is_zero is False:
                return False
        if self.exp.is_imaginary:
            from sympy.functions.elementary.exponential import log
            return log(self.base).is_imaginary

.sympy.core.power.Pow._eval_is_composite

def _eval_is_composite(self):
    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):
        return True

.sympy.core.power.Pow._eval_is_positive

def _eval_is_positive(self):
    ext_pos = Pow._eval_is_extended_positive(self)
    if ext_pos is True:
        return self.is_finite
    return ext_pos

.sympy.core.power.Pow._eval_is_negative

def _eval_is_negative(self):
    ext_neg = Pow._eval_is_extended_negative(self)
    if ext_neg is True:
        return self.is_finite
    return ext_neg

.sympy.core.power.Pow._eval_is_extended_negative

def _eval_is_extended_negative(self):
    if self.exp is S.Half:
        if self.base.is_complex or self.base.is_extended_real:
            return False
    if self.base.is_extended_negative:
        if self.exp.is_odd and self.base.is_finite:
            return True
        if self.exp.is_even:
            return False
    elif self.base.is_extended_positive:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_zero:
        if self.exp.is_extended_real:
            return False
    elif self.base.is_extended_nonnegative:
        if self.exp.is_extended_nonnegative:
            return False
    elif self.base.is_extended_nonpositive:
        if self.exp.is_even:
            return False
    elif self.base.is_extended_real:
        if self.exp.is_even:
            return False

.sympy.core.power.Pow._eval_is_imaginary

def _eval_is_imaginary(self):
    if self.base.is_imaginary:
        if self.exp.is_integer:
            odd = self.exp.is_odd
            if odd is not None:
                return odd
            return
    if self.base == S.Exp1:
        f = 2 * self.exp / (S.Pi * S.ImaginaryUnit)
        if f.is_even:
            return False
        if f.is_odd:
            return True
        return None
    if self.exp.is_imaginary:
        from sympy.functions.elementary.exponential import log
        imlog = log(self.base).is_imaginary
        if imlog is not None:
            return False
    if self.base.is_extended_real and self.exp.is_extended_real:
        if self.base.is_positive:
            return False
        else:
            rat = self.exp.is_rational
            if not rat:
                return rat
            if self.exp.is_integer:
                return False
            else:
                half = (2 * self.exp).is_integer
                if half:
                    return self.base.is_negative
                return half
    if self.base.is_extended_real is False:
        from sympy.functions.elementary.complexes import arg
        i = arg(self.base) * self.exp / S.Pi
        isodd = (2 * i).is_odd
        if isodd is not None:
            return isodd

.sympy.core.power.Pow._eval_is_integer

def _eval_is_integer(self):
    b, e = self.args
    if b.is_rational:
        if b.is_integer is False and e.is_positive:
            return False
    if b.is_integer and e.is_integer:
        if b is S.NegativeOne:
            return True
        if e.is_nonnegative or e.is_positive:
            return True
    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
            return False
    if b.is_Number and e.is_Number:
        check = self.func(*self.args)
        return check.is_Integer
    if e.is_negative and b.is_positive and (b - 1).is_positive:
        return False
    if e.is_negative and b.is_negative and (b + 1).is_negative:
        return False

.sympy.core.power.Pow._eval_is_zero

def _eval_is_zero(self):
    if self.base.is_zero:
        if self.exp.is_extended_positive:
            return True
        elif self.exp.is_extended_nonpositive:
            return False
    elif self.base == S.Exp1:
        return self.exp is S.NegativeInfinity
    elif self.base.is_zero is False:
        if self.base.is_finite and self.exp.is_finite:
            return False
        elif self.exp.is_negative:
            return self.base.is_infinite
        elif self.exp.is_nonnegative:
            return False
        elif self.exp.is_infinite and self.exp.is_extended_real:
            if (1 - abs(self.base)).is_extended_positive:
                return self.exp.is_extended_positive
            elif (1 - abs(self.base)).is_extended_negative:
                return self.exp.is_extended_negative
    elif self.base.is_finite and self.exp.is_negative:
        return False

.sympy.core.power.Pow._eval_is_prime

def _eval_is_prime(self):
    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:
        return False

.sympy.core.power.Pow._eval_is_rational

def _eval_is_rational(self):
    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):
        return True
    p = self.func(*self.as_base_exp())
    if not p.is_Pow:
        return p.is_rational
    b, e = p.as_base_exp()
    if e.is_Rational and b.is_Rational:
        return False
    if e.is_integer:
        if b.is_rational:
            if fuzzy_not(b.is_zero) or e.is_nonnegative:
                return True
            if b == e:
                return True
        elif b.is_irrational:
            return e.is_zero
    if b is S.Exp1:
        if e.is_rational and e.is_nonzero:
            return False

.sympy.core.expr.Expr._eval_power

def _eval_power(self, other):
    return None

.sympy.core.power.Pow._eval_is_complex

def _eval_is_complex(self):
    if self.base == S.Exp1:
        return fuzzy_or([self.exp.is_complex, self.exp.is_extended_negative])
    if all((a.is_complex for a in self.args)) and self._eval_is_finite():
        return True

.sympy.core.power.Pow._eval_is_odd

def _eval_is_odd(self):
    if self.exp.is_integer:
        if self.exp.is_positive:
            return self.base.is_odd
        elif self.exp.is_nonnegative and self.base.is_odd:
            return True
        elif self.base is S.NegativeOne:
            return True

.sympy.core.power.Pow._eval_is_algebraic

def _eval_is_algebraic(self):

    def _is_one(expr):
        try:
            return (expr - 1).is_zero
        except ValueError:
            return False
    if self.base.is_zero or _is_one(self.base):
        return True
    elif self.base is S.Exp1:
        s = self.func(*self.args)
        if s.func == self.func:
            if self.exp.is_nonzero:
                if self.exp.is_algebraic:
                    return False
                elif (self.exp / S.Pi).is_rational:
                    return False
                elif (self.exp / (S.ImaginaryUnit * S.Pi)).is_rational:
                    return True
        else:
            return s.is_algebraic
    elif self.exp.is_rational:
        if self.base.is_algebraic is False:
            return self.exp.is_zero
        if self.base.is_zero is False:
            if self.exp.is_nonzero:
                return self.base.is_algebraic
            elif self.base.is_algebraic:
                return True
        if self.exp.is_positive:
            return self.base.is_algebraic
    elif self.base.is_algebraic and self.exp.is_algebraic:
        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:
            return self.exp.is_rational

.sympy.core.power.Pow._is_one

def _is_one(expr):
    try:
        return (expr - 1).is_zero
    except ValueError:
        return False

.sympy.core.expr.Expr.__sub__

def __sub__(self, other):
    return Add(self, -other)

.sympy.core.operations.AssocOp._new_rawargs

def _new_rawargs(self, *args, reeval=True, **kwargs):
    if reeval and self.is_commutative is False:
        is_commutative = None
    else:
        is_commutative = self.is_commutative
    return self._from_args(args, is_commutative)

.sympy.core.exprtools._monotonic_sign

def _monotonic_sign(self):
    if not self.is_extended_real:
        return
    if (-self).is_Symbol:
        rv = _monotonic_sign(-self)
        return rv if rv is None else -rv
    if not self.is_Add and self.as_numer_denom()[1].is_number:
        s = self
        if s.is_prime:
            if s.is_odd:
                return Integer(3)
            else:
                return Integer(2)
        elif s.is_composite:
            if s.is_odd:
                return Integer(9)
            else:
                return Integer(4)
        elif s.is_positive:
            if s.is_even:
                if s.is_prime is False:
                    return Integer(4)
                else:
                    return Integer(2)
            elif s.is_integer:
                return S.One
            else:
                return _eps
        elif s.is_extended_negative:
            if s.is_even:
                return Integer(-2)
            elif s.is_integer:
                return S.NegativeOne
            else:
                return -_eps
        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:
            return S.Zero
        return None
    free = self.free_symbols
    if len(free) == 1:
        if self.is_polynomial():
            from sympy.polys.polytools import real_roots
            from sympy.polys.polyroots import roots
            from sympy.polys.polyerrors import PolynomialError
            x = free.pop()
            x0 = _monotonic_sign(x)
            if x0 in (_eps, -_eps):
                x0 = S.Zero
            if x0 is not None:
                d = self.diff(x)
                if d.is_number:
                    currentroots = []
                else:
                    try:
                        currentroots = real_roots(d)
                    except (PolynomialError, NotImplementedError):
                        currentroots = [r for r in roots(d, x) if r.is_extended_real]
                y = self.subs(x, x0)
                if x.is_nonnegative and all(((r - x0).is_nonpositive for r in currentroots)):
                    if y.is_nonnegative and d.is_positive:
                        if y:
                            return y if y.is_positive else Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_negative:
                        if y:
                            return y if y.is_negative else Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
                elif x.is_nonpositive and all(((r - x0).is_nonnegative for r in currentroots)):
                    if y.is_nonnegative and d.is_negative:
                        if y:
                            return Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_positive:
                        if y:
                            return Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
        else:
            n, d = self.as_numer_denom()
            den = None
            if n.is_number:
                den = _monotonic_sign(d)
            elif not d.is_number:
                if _monotonic_sign(n) is not None:
                    den = _monotonic_sign(d)
            if den is not None and (den.is_positive or den.is_negative):
                v = n * den
                if v.is_positive:
                    return Dummy('pos', positive=True)
                elif v.is_nonnegative:
                    return Dummy('nneg', nonnegative=True)
                elif v.is_negative:
                    return Dummy('neg', negative=True)
                elif v.is_nonpositive:
                    return Dummy('npos', nonpositive=True)
        return None
    c, a = self.as_coeff_Add()
    v = None
    if not a.is_polynomial():
        n, d = a.as_numer_denom()
        if not (n.is_number or d.is_number):
            return
        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):
            v = S.One
            for ai in Mul.make_args(a):
                if ai.is_number:
                    v *= ai
                    continue
                reps = {}
                for x in ai.free_symbols:
                    reps[x] = _monotonic_sign(x)
                    if reps[x] is None:
                        return
                v *= ai.subs(reps)
    elif c:
        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):
            free = list(a.free_symbols)
            p = {}
            for i in free:
                v = _monotonic_sign(i)
                if v is None:
                    return
                p[i] = v or (_eps if i.is_nonnegative else -_eps)
            v = a.xreplace(p)
    if v is not None:
        rv = v + c
        if v.is_nonnegative and rv.is_positive:
            return rv.subs(_eps, 0)
        if v.is_nonpositive and rv.is_negative:
            return rv.subs(_eps, 0)

.sympy.core.power.Pow._eval_is_even

def _eval_is_even(self):
    if self.exp.is_integer and self.exp.is_positive:
        return self.base.is_even

.sympy.core.numbers.Rational._eval_is_positive

def _eval_is_positive(self):
    return self.p > 0

.sympy.core.power.Pow._eval_derivative

def _eval_derivative(self, s):
    from sympy.functions.elementary.exponential import log
    dbase = self.base.diff(s)
    dexp = self.exp.diff(s)
    return self * (dexp * log(self.base) + dbase * self.exp / self.base)

.sympy.core.function.Function.__new__

def __new__(cls, *args, **options):
    if cls is Function:
        return UndefinedFunction(*args, **options)
    n = len(args)
    if n not in cls.nargs:
        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'
        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})
    evaluate = options.get('evaluate', global_parameters.evaluate)
    result = super().__new__(cls, *args, **options)
    if evaluate and isinstance(result, cls) and result.args:
        pr2 = min((cls._should_evalf(a) for a in result.args))
        if pr2 > 0:
            pr = max((cls._should_evalf(a) for a in result.args))
            result = result.evalf(prec_to_dps(pr))
    return result

.sympy.core.function.FunctionClass.nargs

def nargs(self):
    from sympy.sets.sets import FiniteSet
    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0

.sympy.sets.sets.FiniteSet.__new__

def __new__(cls, *args, **kwargs):
    evaluate = kwargs.get('evaluate', global_parameters.evaluate)
    if evaluate:
        args = list(map(sympify, args))
        if len(args) == 0:
            return S.EmptySet
    else:
        args = list(map(sympify, args))
    dargs = {}
    for i in reversed(list(ordered(args))):
        if i.is_Symbol:
            dargs[i] = i
        else:
            try:
                dargs[i.as_dummy()] = i
            except TypeError:
                dargs[i] = i
    _args_set = set(dargs.values())
    args = list(ordered(_args_set, Set._infimum_key))
    obj = Basic.__new__(cls, *args)
    obj._args_set = _args_set
    return obj

.sympy.core.basic.Basic.as_dummy

def as_dummy(self):
    from .symbol import Dummy, Symbol

    def can(x):
        free = x.free_symbols
        bound = set(x.bound_symbols)
        d = {i: Dummy() for i in bound & free}
        x = x.subs(d)
        x = x.xreplace(x.canonical_variables)
        return x.xreplace({v: k for k, v in d.items()})
    if not self.has(Symbol):
        return self
    return self.replace(lambda x: hasattr(x, 'bound_symbols'), can, simultaneous=False)

.sympy.core.basic.Basic.has

def has(self, *patterns):
    return self._has(iterargs, *patterns)

.sympy.core.basic.Basic._has

def _has(self, iterargs, *patterns):
    type_set = set()
    p_set = set()
    for p in patterns:
        if isinstance(p, BasicMeta):
            type_set.add(p)
            continue
        if not isinstance(p, Basic):
            try:
                p = _sympify(p)
            except SympifyError:
                continue
        p_set.add(p)
    types = tuple(type_set)
    for i in iterargs(self):
        if i in p_set:
            return True
        if isinstance(i, types):
            return True
    for i in p_set - type_set:
        if not hasattr(i, '_has_matcher'):
            continue
        match = i._has_matcher()
        if any((match(arg) for arg in iterargs(self))):
            return True
    return False

.sympy.core.traversal.iterargs

def iterargs(expr):
    args = [expr]
    for i in args:
        yield i
        try:
            args.extend(i.args)
        except TypeError:
            pass

.sympy.sets.sets.Set._infimum_key

def _infimum_key(expr):
    try:
        infimum = expr.inf
        assert infimum.is_comparable
        infimum = infimum.evalf()
    except (NotImplementedError, AttributeError, AssertionError, ValueError):
        infimum = S.Infinity
    return infimum

.sympy.core.numbers.Infinity.__hash__

def __hash__(self):
    return super().__hash__()

.sympy.sets.sets.Set.__contains__

def __contains__(self, other):
    other = _sympify(other)
    c = self._contains(other)
    b = tfn[c]
    if b is None:
        raise TypeError('did not evaluate to a bool: %r' % c)
    return b

.sympy.sets.sets.FiniteSet._contains

def _contains(self, other):
    if other in self._args_set:
        return True
    else:
        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))

.sympy.core.function.Application.__new__

def __new__(cls, *args, **options):
    from sympy.sets.fancysets import Naturals0
    from sympy.sets.sets import FiniteSet
    args = list(map(sympify, args))
    evaluate = options.pop('evaluate', global_parameters.evaluate)
    options.pop('nargs', None)
    if options:
        raise ValueError('Unknown options: %s' % options)
    if evaluate:
        evaluated = cls.eval(*args)
        if evaluated is not None:
            return evaluated
    obj = super().__new__(cls, *args, **options)
    sentinel = object()
    objnargs = getattr(obj, 'nargs', sentinel)
    if objnargs is not sentinel:
        if is_sequence(objnargs):
            nargs = tuple(ordered(set(objnargs)))
        elif objnargs is not None:
            nargs = (as_int(objnargs),)
        else:
            nargs = None
    else:
        nargs = obj._nargs
    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()
    return obj

.sympy.functions.elementary.exponential.log.eval

def eval(cls, arg, base=None):
    from sympy.calculus import AccumBounds
    from sympy.sets.setexpr import SetExpr
    arg = sympify(arg)
    if base is not None:
        base = sympify(base)
        if base == 1:
            if arg == 1:
                return S.NaN
            else:
                return S.ComplexInfinity
        try:
            n = multiplicity(base, arg)
            if n:
                return n + log(arg / base ** n) / log(base)
            else:
                return log(arg) / log(base)
        except ValueError:
            pass
        if base is not S.Exp1:
            return cls(arg) / cls(base)
        else:
            return cls(arg)
    if arg.is_Number:
        if arg.is_zero:
            return S.ComplexInfinity
        elif arg is S.One:
            return S.Zero
        elif arg is S.Infinity:
            return S.Infinity
        elif arg is S.NegativeInfinity:
            return S.Infinity
        elif arg is S.NaN:
            return S.NaN
        elif arg.is_Rational and arg.p == 1:
            return -cls(arg.q)
    if arg.is_Pow and arg.base is S.Exp1 and arg.exp.is_extended_real:
        return arg.exp
    I = S.ImaginaryUnit
    if isinstance(arg, exp) and arg.exp.is_extended_real:
        return arg.exp
    elif isinstance(arg, exp) and arg.exp.is_number:
        r_, i_ = match_real_imag(arg.exp)
        if i_ and i_.is_comparable:
            i_ %= 2 * S.Pi
            if i_ > S.Pi:
                i_ -= 2 * S.Pi
            return r_ + expand_mul(i_ * I, deep=False)
    elif isinstance(arg, exp_polar):
        return unpolarify(arg.exp)
    elif isinstance(arg, AccumBounds):
        if arg.min.is_positive:
            return AccumBounds(log(arg.min), log(arg.max))
        elif arg.min.is_zero:
            return AccumBounds(S.NegativeInfinity, log(arg.max))
        else:
            return S.NaN
    elif isinstance(arg, SetExpr):
        return arg._eval_func(cls)
    if arg.is_number:
        if arg.is_negative:
            return S.Pi * I + cls(-arg)
        elif arg is S.ComplexInfinity:
            return S.ComplexInfinity
        elif arg is S.Exp1:
            return S.One
    if arg.is_zero:
        return S.ComplexInfinity
    if not arg.is_Add:
        coeff = arg.as_coefficient(I)
        if coeff is not None:
            if coeff is S.Infinity:
                return S.Infinity
            elif coeff is S.NegativeInfinity:
                return S.Infinity
            elif coeff.is_Rational:
                if coeff.is_nonnegative:
                    return S.Pi * I * S.Half + cls(coeff)
                else:
                    return -S.Pi * I * S.Half + cls(-coeff)
    if arg.is_number and arg.is_algebraic:
        coeff, arg_ = arg.as_independent(I, as_Add=False)
        if coeff.is_negative:
            coeff *= -1
            arg_ *= -1
        arg_ = expand_mul(arg_, deep=False)
        r_, i_ = arg_.as_independent(I, as_Add=True)
        i_ = i_.as_coefficient(I)
        if coeff.is_real and i_ and i_.is_real and r_.is_real:
            if r_.is_zero:
                if i_.is_positive:
                    return S.Pi * I * S.Half + cls(coeff * i_)
                elif i_.is_negative:
                    return -S.Pi * I * S.Half + cls(coeff * -i_)
            else:
                from sympy.simplify import ratsimp
                t = (i_ / r_).cancel()
                t1 = (-t).cancel()
                atan_table = {sqrt(3): S.Pi / 3, 1: S.Pi / 4, sqrt(5 - 2 * sqrt(5)): S.Pi / 5, sqrt(2) * sqrt(5 - sqrt(5)) / (1 + sqrt(5)): S.Pi / 5, sqrt(5 + 2 * sqrt(5)): S.Pi * Rational(2, 5), sqrt(2) * sqrt(sqrt(5) + 5) / (-1 + sqrt(5)): S.Pi * Rational(2, 5), sqrt(3) / 3: S.Pi / 6, sqrt(2) - 1: S.Pi / 8, sqrt(2 - sqrt(2)) / sqrt(sqrt(2) + 2): S.Pi / 8, sqrt(2) + 1: S.Pi * Rational(3, 8), sqrt(sqrt(2) + 2) / sqrt(2 - sqrt(2)): S.Pi * Rational(3, 8), sqrt(1 - 2 * sqrt(5) / 5): S.Pi / 10, (-sqrt(2) + sqrt(10)) / (2 * sqrt(sqrt(5) + 5)): S.Pi / 10, sqrt(1 + 2 * sqrt(5) / 5): S.Pi * Rational(3, 10), (sqrt(2) + sqrt(10)) / (2 * sqrt(5 - sqrt(5))): S.Pi * Rational(3, 10), 2 - sqrt(3): S.Pi / 12, (-1 + sqrt(3)) / (1 + sqrt(3)): S.Pi / 12, 2 + sqrt(3): S.Pi * Rational(5, 12), (1 + sqrt(3)) / (-1 + sqrt(3)): S.Pi * Rational(5, 12)}
                if t in atan_table:
                    modulus = ratsimp(coeff * Abs(arg_))
                    if r_.is_positive:
                        return cls(modulus) + I * atan_table[t]
                    else:
                        return cls(modulus) + I * (atan_table[t] - S.Pi)
                elif t1 in atan_table:
                    modulus = ratsimp(coeff * Abs(arg_))
                    if r_.is_positive:
                        return cls(modulus) + I * -atan_table[t1]
                    else:
                        return cls(modulus) + I * (S.Pi - atan_table[t1])

.sympy.core.decorators._sympifyit

def _sympifyit(arg, retval=None):

    def deco(func):
        return __sympifyit(func, arg, retval)
    return deco

.sympy.core.decorators.call_highest_priority

def call_highest_priority(method_name):

    def priority_decorator(func):

        @wraps(func)
        def binary_op_wrapper(self, other):
            if hasattr(other, '_op_priority'):
                if other._op_priority > self._op_priority:
                    f = getattr(other, method_name, None)
                    if f is not None:
                        return f(self)
            return func(self, other)
        return binary_op_wrapper
    return priority_decorator

.sympy.core.decorators.priority_decorator

def priority_decorator(func):

    @wraps(func)
    def binary_op_wrapper(self, other):
        if hasattr(other, '_op_priority'):
            if other._op_priority > self._op_priority:
                f = getattr(other, method_name, None)
                if f is not None:
                    return f(self)
        return func(self, other)
    return binary_op_wrapper

.sympy.core.decorators.deco

def deco(func):
    return __sympifyit(func, arg, retval)

.sympy.core.decorators.__sympifyit

def __sympifyit(func, arg, retval=None):
    if not func.__code__.co_argcount:
        raise LookupError('func not found')
    assert func.__code__.co_varnames[1] == arg
    if retval is None:

        @wraps(func)
        def __sympifyit_wrapper(a, b):
            return func(a, sympify(b, strict=True))
    else:

        @wraps(func)
        def __sympifyit_wrapper(a, b):
            try:
                if not hasattr(b, '_op_priority'):
                    b = sympify(b, strict=True)
                return func(a, b)
            except SympifyError:
                return retval
    return __sympifyit_wrapper

.sympy.core.assumptions.ManagedProperties.__init__

def __init__(cls, *args, **kws):
    BasicMeta.__init__(cls, *args, **kws)
    local_defs = {}
    for k in _assume_defined:
        attrname = as_property(k)
        v = cls.__dict__.get(attrname, '')
        if isinstance(v, (bool, int, type(None))):
            if v is not None:
                v = bool(v)
            local_defs[k] = v
    defs = {}
    for base in reversed(cls.__bases__):
        assumptions = getattr(base, '_explicit_class_assumptions', None)
        if assumptions is not None:
            defs.update(assumptions)
    defs.update(local_defs)
    cls._explicit_class_assumptions = defs
    cls.default_assumptions = StdFactKB(defs)
    cls._prop_handler = {}
    for k in _assume_defined:
        eval_is_meth = getattr(cls, '_eval_is_%s' % k, None)
        if eval_is_meth is not None:
            cls._prop_handler[k] = eval_is_meth
    for k, v in cls.default_assumptions.items():
        setattr(cls, as_property(k), v)
    derived_from_bases = set()
    for base in cls.__bases__:
        default_assumptions = getattr(base, 'default_assumptions', None)
        if default_assumptions is not None:
            derived_from_bases.update(default_assumptions)
    for fact in derived_from_bases - set(cls.default_assumptions):
        pname = as_property(fact)
        if pname not in cls.__dict__:
            setattr(cls, pname, make_property(fact))
    for fact in _assume_defined:
        pname = as_property(fact)
        if not hasattr(cls, pname):
            setattr(cls, pname, make_property(fact))

.sympy.core.core.BasicMeta.__init__

def __init__(cls, *args, **kws):
    all_classes.add(cls)
    cls.__sympy__ = property(lambda self: True)

.sympy.core.assumptions.as_property

def as_property(fact):
    return 'is_%s' % fact

.sympy.core.expr.Expr.as_coefficient

def as_coefficient(self, expr):
    r = self.extract_multiplicatively(expr)
    if r and (not r.has(expr)):
        return r

.sympy.core.expr.Expr.extract_multiplicatively

def extract_multiplicatively(self, c):
    from sympy.functions.elementary.exponential import exp
    from .add import _unevaluated_Add
    c = sympify(c)
    if self is S.NaN:
        return None
    if c is S.One:
        return self
    elif c == self:
        return S.One
    if c.is_Add:
        cc, pc = c.primitive()
        if cc is not S.One:
            c = Mul(cc, pc, evaluate=False)
    if c.is_Mul:
        a, b = c.as_two_terms()
        x = self.extract_multiplicatively(a)
        if x is not None:
            return x.extract_multiplicatively(b)
        else:
            return x
    quotient = self / c
    if self.is_Number:
        if self is S.Infinity:
            if c.is_positive:
                return S.Infinity
        elif self is S.NegativeInfinity:
            if c.is_negative:
                return S.Infinity
            elif c.is_positive:
                return S.NegativeInfinity
        elif self is S.ComplexInfinity:
            if not c.is_zero:
                return S.ComplexInfinity
        elif self.is_Integer:
            if not quotient.is_Integer:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
        elif self.is_Rational:
            if not quotient.is_Rational:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
        elif self.is_Float:
            if not quotient.is_Float:
                return None
            elif self.is_positive and quotient.is_negative:
                return None
            else:
                return quotient
    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
        if quotient.is_Mul and len(quotient.args) == 2:
            if quotient.args[0].is_Integer and quotient.args[0].is_positive and (quotient.args[1] == self):
                return quotient
        elif quotient.is_Integer and c.is_Number:
            return quotient
    elif self.is_Add:
        cs, ps = self.primitive()
        if c.is_Number and c is not S.NegativeOne:
            if cs is not S.One:
                if c.is_negative:
                    xc = -cs.extract_multiplicatively(-c)
                else:
                    xc = cs.extract_multiplicatively(c)
                if xc is not None:
                    return xc * ps
            return
        if c == ps:
            return cs
        newargs = []
        for arg in ps.args:
            newarg = arg.extract_multiplicatively(c)
            if newarg is None:
                return
            newargs.append(newarg)
        if cs is not S.One:
            args = [cs * t for t in newargs]
            return _unevaluated_Add(*args)
        else:
            return Add._from_args(newargs)
    elif self.is_Mul:
        args = list(self.args)
        for i, arg in enumerate(args):
            newarg = arg.extract_multiplicatively(c)
            if newarg is not None:
                args[i] = newarg
                return Mul(*args)
    elif self.is_Pow or isinstance(self, exp):
        sb, se = self.as_base_exp()
        cb, ce = c.as_base_exp()
        if cb == sb:
            new_exp = se.extract_additively(ce)
            if new_exp is not None:
                return Pow(sb, new_exp)
        elif c == sb:
            new_exp = self.exp.extract_additively(1)
            if new_exp is not None:
                return Pow(sb, new_exp)

.sympy.core.numbers.ImaginaryUnit._eval_power

def _eval_power(self, expt):
    if isinstance(expt, Integer):
        expt = expt % 4
        if expt == 0:
            return S.One
        elif expt == 1:
            return S.ImaginaryUnit
        elif expt == 2:
            return S.NegativeOne
        elif expt == 3:
            return -S.ImaginaryUnit
    if isinstance(expt, Rational):
        i, r = divmod(expt, 2)
        rv = Pow(S.ImaginaryUnit, r, evaluate=False)
        if i % 2:
            return Mul(S.NegativeOne, rv, evaluate=False)
        return rv

.sympy.core.expr.Expr.__neg__

def __neg__(self):
    c = self.is_commutative
    return Mul._from_args((S.NegativeOne, self), c)

.sympy.core.function.Function._should_evalf

def _should_evalf(cls, arg):
    if arg.is_Float:
        return arg._prec
    if not arg.is_Add:
        return -1
    from .evalf import pure_complex
    m = pure_complex(arg)
    if m is None or not (m[0].is_Float or m[1].is_Float):
        return -1
    l = [i._prec for i in m if i.is_Float]
    l.append(-1)
    return max(l)

.sympy.core.function.Function._eval_is_commutative

def _eval_is_commutative(self):
    return fuzzy_and((a.is_commutative for a in self.args))

.sympy.core.logic.fuzzy_and

def fuzzy_and(args):
    rv = True
    for ai in args:
        ai = fuzzy_bool(ai)
        if ai is False:
            return False
        if rv:
            rv = ai
    return rv

.sympy.core.logic.fuzzy_bool

def fuzzy_bool(x):
    if x is None:
        return None
    if x in (True, False):
        return bool(x)

.sympy.functions.elementary.exponential.log.as_base_exp

def as_base_exp(self):
    return (self, S.One)

.sympy.core.expr.Expr._hashable_content

def _hashable_content(self):
    return self._args

.sympy.functions.elementary.exponential.log._eval_is_finite

def _eval_is_finite(self):
    arg = self.args[0]
    if arg.is_zero:
        return False
    return arg.is_finite

.sympy.functions.elementary.exponential.log._eval_is_algebraic

def _eval_is_algebraic(self):
    s = self.func(*self.args)
    if s.func == self.func:
        if (self.args[0] - 1).is_zero:
            return True
        elif fuzzy_not((self.args[0] - 1).is_zero):
            if self.args[0].is_algebraic:
                return False
    else:
        return s.is_algebraic

.sympy.core.function.Application.func

def func(self):
    return self.__class__

.sympy.core.logic.fuzzy_not

def fuzzy_not(v):
    if v is None:
        return v
    else:
        return not v

.sympy.functions.elementary.exponential.log._eval_is_rational

def _eval_is_rational(self):
    s = self.func(*self.args)
    if s.func == self.func:
        if (self.args[0] - 1).is_zero:
            return True
        if s.args[0].is_rational and fuzzy_not((self.args[0] - 1).is_zero):
            return False
    else:
        return s.is_rational

.sympy.functions.elementary.exponential.log._eval_is_zero

def _eval_is_zero(self):
    return (self.args[0] - 1).is_zero

.sympy.functions.elementary.exponential.log._eval_is_extended_positive

def _eval_is_extended_positive(self):
    return (self.args[0] - 1).is_extended_positive

.sympy.functions.elementary.exponential.log._eval_is_extended_nonnegative

def _eval_is_extended_nonnegative(self):
    return (self.args[0] - 1).is_extended_nonnegative

.sympy.functions.elementary.exponential.log._eval_is_complex

def _eval_is_complex(self):
    z = self.args[0]
    return fuzzy_and([z.is_complex, fuzzy_not(z.is_zero)])

.sympy.functions.elementary.exponential.log._eval_is_extended_real

def _eval_is_extended_real(self):
    return self.args[0].is_extended_positive

.sympy.core.mul._keep_coeff

def _keep_coeff(coeff, factors, clear=True, sign=False):
    if not coeff.is_Number:
        if factors.is_Number:
            factors, coeff = (coeff, factors)
        else:
            return coeff * factors
    if factors is S.One:
        return coeff
    if coeff is S.One:
        return factors
    elif coeff is S.NegativeOne and (not sign):
        return -factors
    elif factors.is_Add:
        if not clear and coeff.is_Rational and (coeff.q != 1):
            args = [i.as_coeff_Mul() for i in factors.args]
            args = [(_keep_coeff(c, coeff), m) for c, m in args]
            if any((c.is_Integer for c, _ in args)):
                return Add._from_args([Mul._from_args(i[1:] if i[0] == 1 else i) for i in args])
        return Mul(coeff, factors, evaluate=False)
    elif factors.is_Mul:
        margs = list(factors.args)
        if margs[0].is_Number:
            margs[0] *= coeff
            if margs[0] == 1:
                margs.pop(0)
        else:
            margs.insert(0, coeff)
        return Mul._from_args(margs)
    else:
        m = coeff * factors
        if m.is_Number and (not factors.is_Number):
            m = Mul._from_args((coeff, factors))
        return m

.sympy.core.numbers.Rational.__ne__

def __ne__(self, other):
    return not self == other

.sympy.core.numbers.Rational.__sub__

def __sub__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, Integer):
            return Rational(self.p - self.q * other.p, self.q, 1)
        elif isinstance(other, Rational):
            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)
        elif isinstance(other, Float):
            return -other + self
        else:
            return Number.__sub__(self, other)
    return Number.__sub__(self, other)

.sympy.ntheory.factor_._factors

def _factors():
    rv = 2 + n % 2
    while True:
        yield rv
        rv = nextprime(rv)

.sympy.ntheory.generate.primerange

def primerange(a, b=None):
    if b is None:
        a, b = (2, a)
    if a >= b:
        return
    if b <= sieve._list[-1]:
        yield from sieve.primerange(a, b)
        return
    a = _as_int_ceiling(a) - 1
    b = _as_int_ceiling(b)
    while 1:
        a = nextprime(a)
        if a < b:
            yield a
        else:
            return

.sympy.ntheory.generate._as_int_ceiling

def _as_int_ceiling(a):
    from sympy.functions.elementary.integers import ceiling
    return as_int(ceiling(a))

.sympy.functions.elementary.integers.RoundFunction.eval

def eval(cls, arg):
    v = cls._eval_number(arg)
    if v is not None:
        return v
    if arg.is_integer or arg.is_finite is False:
        return arg
    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:
        i = im(arg)
        if not i.has(S.ImaginaryUnit):
            return cls(i) * S.ImaginaryUnit
        return cls(arg, evaluate=False)
    ipart = npart = spart = S.Zero
    terms = Add.make_args(arg)
    for t in terms:
        if t.is_integer or (t.is_imaginary and im(t).is_integer):
            ipart += t
        elif t.has(Symbol):
            spart += t
        else:
            npart += t
    if not (npart or spart):
        return ipart
    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):
        try:
            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)
            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit
            npart = S.Zero
        except (PrecisionExhausted, NotImplementedError):
            pass
    spart += npart
    if not spart:
        return ipart
    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:
        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit
    elif isinstance(spart, (floor, ceiling)):
        return ipart + spart
    else:
        return ipart + cls(spart, evaluate=False)

.sympy.functions.elementary.integers.ceiling._eval_number

def _eval_number(cls, arg):
    if arg.is_Number:
        return arg.ceiling()
    elif any((isinstance(i, j) for i in (arg, -arg) for j in (floor, ceiling))):
        return arg
    if arg.is_NumberSymbol:
        return arg.approximation_interval(Integer)[1]

.sympy.core.numbers.Integer.ceiling

def ceiling(self):
    return Integer(self.p)

.sympy.ntheory.generate.nextprime

def nextprime(n, ith=1):
    n = int(n)
    i = as_int(ith)
    if i > 1:
        pr = n
        j = 1
        while 1:
            pr = nextprime(pr)
            j += 1
            if j > i:
                break
        return pr
    if n < 2:
        return 2
    if n < 7:
        return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]
    if n <= sieve._list[-2]:
        l, u = sieve.search(n)
        if l == u:
            return sieve[u + 1]
        else:
            return sieve[u]
    nn = 6 * (n // 6)
    if nn == n:
        n += 1
        if isprime(n):
            return n
        n += 4
    elif n - nn == 5:
        n += 2
        if isprime(n):
            return n
        n += 4
    else:
        n = nn + 5
    while 1:
        if isprime(n):
            return n
        n += 2
        if isprime(n):
            return n
        n += 4

.sympy.ntheory.generate.Sieve.search

def search(self, n):
    test = _as_int_ceiling(n)
    n = as_int(n)
    if n < 2:
        raise ValueError('n should be >= 2 but got: %s' % n)
    if n > self._list[-1]:
        self.extend(n)
    b = bisect(self._list, n)
    if self._list[b - 1] == test:
        return (b, b)
    else:
        return (b, b + 1)

.sympy.ntheory.generate.Sieve.__getitem__

def __getitem__(self, n):
    if isinstance(n, slice):
        self.extend_to_no(n.stop)
        start = n.start if n.start is not None else 0
        if start < 1:
            raise IndexError('Sieve indices start at 1.')
        return self._list[start - 1:n.stop - 1:n.step]
    else:
        if n < 1:
            raise IndexError('Sieve indices start at 1.')
        n = as_int(n)
        self.extend_to_no(n)
        return self._list[n - 1]

.sympy.ntheory.generate.Sieve.extend_to_no

def extend_to_no(self, i):
    i = as_int(i)
    while len(self._list) < i:
        self.extend(int(self._list[-1] * 1.5))

.sympy.ntheory.primetest.isprime

def isprime(n):
    try:
        n = as_int(n)
    except ValueError:
        return False
    if n in [2, 3, 5]:
        return True
    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):
        return False
    if n < 49:
        return True
    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):
        return False
    if n < 2809:
        return True
    if n <= 23001:
        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]
    from sympy.ntheory.generate import sieve as s
    if n <= s._list[-1]:
        l, u = s.search(n)
        return l == u
    if HAS_GMPY == 2:
        from gmpy2 import is_strong_prp, is_strong_selfridge_prp
        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)
    if n < 341531:
        return mr(n, [9345883071009581737])
    if n < 885594169:
        return mr(n, [725270293939359937, 3569819667048198375])
    if n < 350269456337:
        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])
    if n < 55245642489451:
        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])
    if n < 7999252175582851:
        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])
    if n < 585226005592931977:
        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])
    if n < 18446744073709551616:
        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])
    return mr(n, [2]) and is_strong_lucas_prp(n)

.sympy.ntheory.factor_._factorint_small

def _factorint_small(factors, n, limit, fail_max):

    def done(n, d):
        if d * d <= n:
            return (n, d)
        return (n, 0)
    d = 2
    m = trailing(n)
    if m:
        factors[d] = m
        n >>= m
    d = 3
    if limit < d:
        if n > 1:
            factors[n] = 1
        return done(n, d)
    m = 0
    while n % d == 0:
        n //= d
        m += 1
        if m == 20:
            mm = multiplicity(d, n)
            m += mm
            n //= d ** mm
            break
    if m:
        factors[d] = m
    if limit * limit > n:
        maxx = 0
    else:
        maxx = limit * limit
    dd = maxx or n
    d = 5
    fails = 0
    while fails < fail_max:
        if d * d > dd:
            break
        m = 0
        while n % d == 0:
            n //= d
            m += 1
            if m == 20:
                mm = multiplicity(d, n)
                m += mm
                n //= d ** mm
                break
        if m:
            factors[d] = m
            dd = maxx or n
            fails = 0
        else:
            fails += 1
        d += 2
        if d * d > dd:
            break
        m = 0
        while n % d == 0:
            n //= d
            m += 1
            if m == 20:
                mm = multiplicity(d, n)
                m += mm
                n //= d ** mm
                break
        if m:
            factors[d] = m
            dd = maxx or n
            fails = 0
        else:
            fails += 1
        d += 4
    return done(n, d)

.sympy.ntheory.factor_.trailing

def trailing(n):
    n = abs(int(n))
    if not n:
        return 0
    low_byte = n & 255
    if low_byte:
        return small_trailing[low_byte]
    z = bitcount(n) - 1
    if isinstance(z, SYMPY_INTS):
        if n == 1 << z:
            return z
    if z < 300:
        t = 8
        n >>= 8
        while not n & 255:
            n >>= 8
            t += 8
        return t + small_trailing[n & 255]
    t = 0
    p = 8
    while not n & 1:
        while not n & (1 << p) - 1:
            n >>= p
            t += p
            p *= 2
        p //= 2
    return t

.sympy.ntheory.factor_.done

def done(n, d):
    if d * d <= n:
        return (n, d)
    return (n, 0)

.sympy.core.power.Pow._eval_subs

def _eval_subs(self, old, new):
    from sympy.calculus.accumulationbounds import AccumBounds
    if isinstance(self.exp, AccumBounds):
        b = self.base.subs(old, new)
        e = self.exp.subs(old, new)
        if isinstance(e, AccumBounds):
            return e.__rpow__(b)
        return self.func(b, e)
    from sympy.functions.elementary.exponential import exp, log

    def _check(ct1, ct2, old):
        coeff1, terms1 = ct1
        coeff2, terms2 = ct2
        if terms1 == terms2:
            if old.is_commutative:
                pow = coeff1 / coeff2
                try:
                    as_int(pow, strict=False)
                    combines = True
                except ValueError:
                    b, e = old.as_base_exp()
                    combines = b.is_positive and e.is_real or (b.is_nonnegative and e.is_nonnegative)
                return (combines, pow, None)
            else:
                if not isinstance(terms1, tuple):
                    terms1 = (terms1,)
                if not all((term.is_integer for term in terms1)):
                    return (False, None, None)
                try:
                    pow, remainder = divmod(as_int(coeff1), as_int(coeff2))
                    if pow < 0 and remainder != 0:
                        pow += 1
                        remainder -= as_int(coeff2)
                    if remainder == 0:
                        remainder_pow = None
                    else:
                        remainder_pow = Mul(remainder, *terms1)
                    return (True, pow, remainder_pow)
                except ValueError:
                    pass
        return (False, None, None)
    if old == self.base or (old == exp and self.base == S.Exp1):
        if new.is_Function and isinstance(new, Callable):
            return new(self.exp._subs(old, new))
        else:
            return new ** self.exp._subs(old, new)
    if isinstance(old, self.func) and self.exp == old.exp:
        l = log(self.base, old.base)
        if l.is_Number:
            return Pow(new, l)
    if isinstance(old, self.func) and self.base == old.base:
        if self.exp.is_Add is False:
            ct1 = self.exp.as_independent(Symbol, as_Add=False)
            ct2 = old.exp.as_independent(Symbol, as_Add=False)
            ok, pow, remainder_pow = _check(ct1, ct2, old)
            if ok:
                result = self.func(new, pow)
                if remainder_pow is not None:
                    result = Mul(result, Pow(old.base, remainder_pow))
                return result
        else:
            oarg = old.exp
            new_l = []
            o_al = []
            ct2 = oarg.as_coeff_mul()
            for a in self.exp.args:
                newa = a._subs(old, new)
                ct1 = newa.as_coeff_mul()
                ok, pow, remainder_pow = _check(ct1, ct2, old)
                if ok:
                    new_l.append(new ** pow)
                    if remainder_pow is not None:
                        o_al.append(remainder_pow)
                    continue
                elif not old.is_commutative and (not newa.is_integer):
                    return
                o_al.append(newa)
            if new_l:
                expo = Add(*o_al)
                new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)
                return Mul(*new_l)
    if (isinstance(old, exp) or (old.is_Pow and old.base is S.Exp1)) and self.exp.is_extended_real and self.base.is_positive:
        ct1 = old.exp.as_independent(Symbol, as_Add=False)
        ct2 = (self.exp * log(self.base)).as_independent(Symbol, as_Add=False)
        ok, pow, remainder_pow = _check(ct1, ct2, old)
        if ok:
            result = self.func(new, pow)
            if remainder_pow is not None:
                result = Mul(result, Pow(old.base, remainder_pow))
            return result

.sympy.ntheory.factor_.multiplicity

def multiplicity(p, n):
    try:
        p, n = (as_int(p), as_int(n))
    except ValueError:
        from sympy.functions.combinatorial.factorials import factorial
        if all((isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n))):
            p = Rational(p)
            n = Rational(n)
            if p.q == 1:
                if n.p == 1:
                    return -multiplicity(p.p, n.q)
                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)
            elif p.p == 1:
                return multiplicity(p.q, n.q)
            else:
                like = min(multiplicity(p.p, n.p), multiplicity(p.q, n.q))
                cross = min(multiplicity(p.q, n.p), multiplicity(p.p, n.q))
                return like - cross
        elif isinstance(p, (SYMPY_INTS, Integer)) and isinstance(n, factorial) and isinstance(n.args[0], Integer) and (n.args[0] >= 0):
            return multiplicity_in_factorial(p, n.args[0])
        raise ValueError('expecting ints or fractions, got %s and %s' % (p, n))
    if n == 0:
        raise ValueError('no such integer exists: multiplicity of %s is not-defined' % n)
    if p == 2:
        return trailing(n)
    if p < 2:
        raise ValueError('p must be an integer, 2 or larger, but got %s' % p)
    if p == n:
        return 1
    m = 0
    n, rem = divmod(n, p)
    while not rem:
        m += 1
        if m > 5:
            e = 2
            while 1:
                ppow = p ** e
                if ppow < n:
                    nnew, rem = divmod(n, ppow)
                    if not rem:
                        m += e
                        e *= 2
                        n = nnew
                        continue
                return m + multiplicity(p, n)
        n, rem = divmod(n, p)
    return m

.sympy.ntheory.factor_.divisors

def divisors(n, generator=False, proper=False):
    n = as_int(abs(n))
    if isprime(n):
        if proper:
            return [1]
        return [1, n]
    if n == 1:
        if proper:
            return []
        return [1]
    if n == 0:
        return []
    rv = _divisors(n, proper)
    if not generator:
        return sorted(rv)
    return rv

.sympy.ntheory.factor_._divisors

def _divisors(n, proper=False):
    factordict = factorint(n)
    ps = sorted(factordict.keys())

    def rec_gen(n=0):
        if n == len(ps):
            yield 1
        else:
            pows = [1]
            for j in range(factordict[ps[n]]):
                pows.append(pows[-1] * ps[n])
            for q in rec_gen(n + 1):
                for p in pows:
                    yield (p * q)
    if proper:
        for p in rec_gen():
            if p != n:
                yield p
    else:
        yield from rec_gen()

.sympy.ntheory.factor_.rec_gen

def rec_gen(n=0):
    if n == len(ps):
        yield 1
    else:
        pows = [1]
        for j in range(factordict[ps[n]]):
            pows.append(pows[-1] * ps[n])
        for q in rec_gen(n + 1):
            for p in pows:
                yield (p * q)

.sympy.core.mul.Mul.could_extract_minus_sign

def could_extract_minus_sign(self):
    if self == -self:
        return False
    c = self.args[0]
    return c.is_Number and c.is_extended_negative

.sympy.core.mul.Mul.__neg__

def __neg__(self):
    c, args = self.as_coeff_mul()
    if args[0] is not S.ComplexInfinity:
        c = -c
    if c is not S.One:
        if args[0].is_Number:
            args = list(args)
            if c is S.NegativeOne:
                args[0] = -args[0]
            else:
                args[0] *= c
        else:
            args = (c,) + args
    return self._from_args(args, self.is_commutative)

.sympy.core.mul.Mul.as_coeff_mul

def as_coeff_mul(self, *deps, rational=True, **kwargs):
    if deps:
        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)
        return (self._new_rawargs(*l2), tuple(l1))
    args = self.args
    if args[0].is_Number:
        if not rational or args[0].is_Rational:
            return (args[0], args[1:])
        elif args[0].is_extended_negative:
            return (S.NegativeOne, (-args[0],) + args[1:])
    return (S.One, args)

.sympy.core.mul.Mul._eval_power

def _eval_power(self, e):
    cargs, nc = self.args_cnc(split_1=False)
    if e.is_Integer:
        return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * Pow(Mul._from_args(nc), e, evaluate=False)
    if e.is_Rational and e.q == 2:
        if self.is_imaginary:
            a = self.as_real_imag()[1]
            if a.is_Rational:
                from .power import integer_nthroot
                n, d = abs(a / 2).as_numer_denom()
                n, t = integer_nthroot(n, 2)
                if t:
                    d, t = integer_nthroot(d, 2)
                    if t:
                        from sympy.functions.elementary.complexes import sign
                        r = sympify(n) / d
                        return _unevaluated_Mul(r ** e.p, (1 + sign(a) * S.ImaginaryUnit) ** e.p)
    p = Pow(self, e, evaluate=False)
    if e.is_Rational or e.is_Float:
        return p._eval_expand_power_base()
    return p

.sympy.core.expr.Expr.args_cnc

def args_cnc(self, cset=False, warn=True, split_1=True):
    if self.is_Mul:
        args = list(self.args)
    else:
        args = [self]
    for i, mi in enumerate(args):
        if not mi.is_commutative:
            c = args[:i]
            nc = args[i:]
            break
    else:
        c = args
        nc = []
    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):
        c[:1] = [S.NegativeOne, -c[0]]
    if cset:
        clen = len(c)
        c = set(c)
        if clen and warn and (len(c) != clen):
            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])
    return [c, nc]

.sympy.ntheory.generate.Sieve.primerange

def primerange(self, a, b=None):
    if b is None:
        b = _as_int_ceiling(a)
        a = 2
    else:
        a = max(2, _as_int_ceiling(a))
        b = _as_int_ceiling(b)
    if a >= b:
        return
    self.extend(b)
    i = self.search(a)[1]
    maxi = len(self._list) + 1
    while i < maxi:
        p = self._list[i - 1]
        if p < b:
            yield p
            i += 1
        else:
            return

.sympy.ntheory.generate.Sieve.extend

def extend(self, n):
    n = int(n)
    if n <= self._list[-1]:
        return
    maxbase = int(n ** 0.5) + 1
    self.extend(maxbase)
    begin = self._list[-1] + 1
    newsieve = _arange(begin, n + 1)
    for p in self.primerange(maxbase):
        startindex = -begin % p
        for i in range(startindex, len(newsieve), p):
            newsieve[i] = 0
    self._list += _array('l', [x for x in newsieve if x])

.sympy.ntheory.factor_._check_termination

def _check_termination(factors, n, limitp1, use_trial, use_rho, use_pm1, verbose):
    if verbose:
        print('Check for termination')
    p = perfect_power(n, factor=False)
    if p is not False:
        base, exp = p
        if limitp1:
            limit = limitp1 - 1
        else:
            limit = limitp1
        facs = factorint(base, limit, use_trial, use_rho, use_pm1, verbose=False)
        for b, e in facs.items():
            if verbose:
                print(factor_msg % (b, e))
            factors[b] = exp * e
        raise StopIteration
    if isprime(n):
        factors[int(n)] = 1
        raise StopIteration
    if n == 1:
        raise StopIteration

.sympy.ntheory.primetest.mr

def mr(n, bases):
    from sympy.ntheory.factor_ import trailing
    from sympy.polys.domains import ZZ
    n = as_int(n)
    if n < 2:
        return False
    s = trailing(n - 1)
    t = n >> s
    for base in bases:
        if base >= n:
            base %= n
        if base >= 2:
            base = ZZ(base)
            if not _test(n, base, s, t):
                return False
    return True

.sympy.polys.domains.domain.Domain.__call__

def __call__(self, *args):
    return self.new(*args)

.sympy.polys.domains.domain.Domain.new

def new(self, *args):
    return self.dtype(*args)

.sympy.ntheory.primetest._test

def _test(n, base, s, t):
    b = pow(base, t, n)
    if b == 1 or b == n - 1:
        return True
    else:
        for j in range(1, s):
            b = pow(b, 2, n)
            if b == n - 1:
                return True
            if b == 1:
                return False
    return False

.sympy.ntheory.factor_._trial

def _trial(factors, n, candidates, verbose=False):
    if verbose:
        factors0 = list(factors.keys())
    nfactors = len(factors)
    for d in candidates:
        if n % d == 0:
            m = multiplicity(d, n)
            n //= d ** m
            factors[d] = m
    if verbose:
        for k in sorted(set(factors).difference(set(factors0))):
            print(factor_msg % (k, factors[k]))
    return (int(n), len(factors) != nfactors)

.sympy.ntheory.generate._arange

def _arange(a, b):
    return _array('l', range(a, b))


[/PYTHON]
What will be the output of `_polynomial_integrate`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "polynomials": {
            "2": "x*y"
        },
        "facets": null,
        "hp_params": null
    },
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
