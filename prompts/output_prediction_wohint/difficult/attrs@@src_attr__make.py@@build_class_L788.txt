You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. You need to predict output variable values, and print output between [OUTPUT] and [/OUTPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[PYTHON]
import abc
import contextlib
import inspect
import itertools
import sys
import weakref
from collections.abc import Callable, Mapping
from functools import cached_property
from typing import Any, NamedTuple, TypeVar
from . import _compat, _config, setters
from ._compat import PY_3_10_PLUS, PY_3_11_PLUS, PY_3_13_PLUS, _AnnotationExtractor, _get_annotations, get_generic_base

class _ClassBuilder:
    __slots__ = ('_add_method_dunders', '_attr_names', '_attrs', '_base_attr_map', '_base_names', '_cache_hash', '_cls', '_cls_dict', '_delete_attribs', '_frozen', '_has_custom_setattr', '_has_post_init', '_has_pre_init', '_is_exc', '_on_setattr', '_pre_init_has_args', '_repr_added', '_script_snippets', '_slots', '_weakref_slot', '_wrote_own_setattr')

    def __init__(self, cls: type, these, auto_attribs: bool, props: ClassProps, has_custom_setattr: bool):
        attrs, base_attrs, base_map = _transform_attrs(cls, these, auto_attribs, props.kw_only, props.collected_fields_by_mro, props.field_transformer)
        self._cls = cls
        self._cls_dict = dict(cls.__dict__) if props.is_slotted else {}
        self._attrs = attrs
        self._base_names = {a.name for a in base_attrs}
        self._base_attr_map = base_map
        self._attr_names = tuple((a.name for a in attrs))
        self._slots = props.is_slotted
        self._frozen = props.is_frozen
        self._weakref_slot = props.has_weakref_slot
        self._cache_hash = props.hashability is ClassProps.Hashability.HASHABLE_CACHED
        self._has_pre_init = bool(getattr(cls, '__attrs_pre_init__', False))
        self._pre_init_has_args = False
        if self._has_pre_init:
            pre_init_func = cls.__attrs_pre_init__
            pre_init_signature = inspect.signature(pre_init_func)
            self._pre_init_has_args = len(pre_init_signature.parameters) > 1
        self._has_post_init = bool(getattr(cls, '__attrs_post_init__', False))
        self._delete_attribs = not bool(these)
        self._is_exc = props.is_exception
        self._on_setattr = props.on_setattr_hook
        self._has_custom_setattr = has_custom_setattr
        self._wrote_own_setattr = False
        self._cls_dict['__attrs_attrs__'] = self._attrs
        self._cls_dict['__attrs_props__'] = props
        if props.is_frozen:
            self._cls_dict['__setattr__'] = _frozen_setattrs
            self._cls_dict['__delattr__'] = _frozen_delattrs
            self._wrote_own_setattr = True
        elif self._on_setattr in (_DEFAULT_ON_SETATTR, setters.validate, setters.convert):
            has_validator = has_converter = False
            for a in attrs:
                if a.validator is not None:
                    has_validator = True
                if a.converter is not None:
                    has_converter = True
                if has_validator and has_converter:
                    break
            if self._on_setattr == _DEFAULT_ON_SETATTR and (not (has_validator or has_converter)) or (self._on_setattr == setters.validate and (not has_validator)) or (self._on_setattr == setters.convert and (not has_converter)):
                self._on_setattr = None
        if props.added_pickling:
            self._cls_dict['__getstate__'], self._cls_dict['__setstate__'] = self._make_getstate_setstate()
        self._script_snippets: list[tuple[str, dict, Callable[[dict, dict], Any]]] = []
        self._repr_added = False
        if not hasattr(self._cls, '__module__') or not hasattr(self._cls, '__qualname__'):
            self._add_method_dunders = self._add_method_dunders_safe
        else:
            self._add_method_dunders = self._add_method_dunders_unsafe

    def _eval_snippets(self) -> None:
        script = '\n'.join([snippet[0] for snippet in self._script_snippets])
        globs = {}
        for _, snippet_globs, _ in self._script_snippets:
            globs.update(snippet_globs)
        locs = _linecache_and_compile(script, _generate_unique_filename(self._cls, 'methods'), globs)
        for _, _, hook in self._script_snippets:
            hook(self._cls_dict, locs)

    def build_class(self):
        self._eval_snippets()
        if self._slots is True:
            cls = self._create_slots_class()
            self._cls.__attrs_base_of_slotted__ = weakref.ref(cls)
        else:
            cls = self._patch_original_class()
            if PY_3_10_PLUS:
                cls = abc.update_abstractmethods(cls)
        if getattr(cls, '__attrs_init_subclass__', None) and '__attrs_init_subclass__' not in cls.__dict__:
            cls.__attrs_init_subclass__()
        return cls

    def _patch_original_class(self):
        cls = self._cls
        base_names = self._base_names
        if self._delete_attribs:
            for name in self._attr_names:
                if name not in base_names and getattr(cls, name, _SENTINEL) is not _SENTINEL:
                    with contextlib.suppress(AttributeError):
                        delattr(cls, name)
        for name, value in self._cls_dict.items():
            setattr(cls, name, value)
        if not self._wrote_own_setattr and getattr(cls, '__attrs_own_setattr__', False):
            cls.__attrs_own_setattr__ = False
            if not self._has_custom_setattr:
                cls.__setattr__ = _OBJ_SETATTR
        return cls

    def _create_slots_class(self):
        cd = {k: v for k, v in self._cls_dict.items() if k not in (*tuple(self._attr_names), '__dict__', '__weakref__')}
        if hasattr(sys, '_clear_type_descriptors'):
            sys._clear_type_descriptors(self._cls)
        if not self._wrote_own_setattr:
            cd['__attrs_own_setattr__'] = False
            if not self._has_custom_setattr:
                for base_cls in self._cls.__bases__:
                    if base_cls.__dict__.get('__attrs_own_setattr__', False):
                        cd['__setattr__'] = _OBJ_SETATTR
                        break
        existing_slots = {}
        weakref_inherited = False
        for base_cls in self._cls.__mro__[1:-1]:
            if base_cls.__dict__.get('__weakref__', None) is not None:
                weakref_inherited = True
            existing_slots.update({name: getattr(base_cls, name) for name in getattr(base_cls, '__slots__', [])})
        base_names = set(self._base_names)
        names = self._attr_names
        if self._weakref_slot and '__weakref__' not in getattr(self._cls, '__slots__', ()) and ('__weakref__' not in names) and (not weakref_inherited):
            names += ('__weakref__',)
        cached_properties = {name: cached_prop.func for name, cached_prop in cd.items() if isinstance(cached_prop, cached_property)}
        additional_closure_functions_to_update = []
        if cached_properties:
            class_annotations = _get_annotations(self._cls)
            for name, func in cached_properties.items():
                names += (name,)
                del cd[name]
                additional_closure_functions_to_update.append(func)
                annotation = inspect.signature(func).return_annotation
                if annotation is not inspect.Parameter.empty:
                    class_annotations[name] = annotation
            original_getattr = cd.get('__getattr__')
            if original_getattr is not None:
                additional_closure_functions_to_update.append(original_getattr)
            cd['__getattr__'] = _make_cached_property_getattr(cached_properties, original_getattr, self._cls)
        slot_names = [name for name in names if name not in base_names]
        reused_slots = {slot: slot_descriptor for slot, slot_descriptor in existing_slots.items() if slot in slot_names}
        slot_names = [name for name in slot_names if name not in reused_slots]
        cd.update(reused_slots)
        if self._cache_hash:
            slot_names.append(_HASH_CACHE_FIELD)
        cd['__slots__'] = tuple(slot_names)
        cd['__qualname__'] = self._cls.__qualname__
        cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)
        for item in itertools.chain(cls.__dict__.values(), additional_closure_functions_to_update):
            if isinstance(item, (classmethod, staticmethod)):
                closure_cells = getattr(item.__func__, '__closure__', None)
            elif isinstance(item, property):
                closure_cells = getattr(item.fget, '__closure__', None)
            else:
                closure_cells = getattr(item, '__closure__', None)
            if not closure_cells:
                continue
            for cell in closure_cells:
                try:
                    match = cell.cell_contents is self._cls
                except ValueError:
                    pass
                else:
                    if match:
                        cell.cell_contents = cls
        return cls

    def _make_getstate_setstate(self):
        state_attr_names = tuple((an for an in self._attr_names if an != '__weakref__'))

        def slots_getstate(self):
            return {name: getattr(self, name) for name in state_attr_names}
        hash_caching_enabled = self._cache_hash

        def slots_setstate(self, state):
            __bound_setattr = _OBJ_SETATTR.__get__(self)
            if isinstance(state, tuple):
                for name, value in zip(state_attr_names, state):
                    __bound_setattr(name, value)
            else:
                for name in state_attr_names:
                    if name in state:
                        __bound_setattr(name, state[name])
            if hash_caching_enabled:
                __bound_setattr(_HASH_CACHE_FIELD, None)
        return (slots_getstate, slots_setstate)

    def _add_method_dunders_unsafe(self, method: Callable) -> Callable:
        method.__module__ = self._cls.__module__
        method.__qualname__ = f'{self._cls.__qualname__}.{method.__name__}'
        method.__doc__ = f'Method generated by attrs for class {self._cls.__qualname__}.'
        return method

    def _add_method_dunders_safe(self, method: Callable) -> Callable:
        with contextlib.suppress(AttributeError):
            method.__module__ = self._cls.__module__
        with contextlib.suppress(AttributeError):
            method.__qualname__ = f'{self._cls.__qualname__}.{method.__name__}'
        with contextlib.suppress(AttributeError):
            method.__doc__ = f'Method generated by attrs for class {self._cls.__qualname__}.'
        return method
[/PYTHON]

Functions called during the execution:
[PYTHON]
attrs.src.attr._make._eval_snippets

def _eval_snippets(self) -> None:
    """
    Evaluate any registered snippets in one go.
    """
    script = "\n".join([snippet[0] for snippet in self._script_snippets])
    globs = {}
    for _, snippet_globs, _ in self._script_snippets:
        globs.update(snippet_globs)

    locs = _linecache_and_compile(
        script,
        _generate_unique_filename(self._cls, "methods"),
        globs,
    )

    for _, _, hook in self._script_snippets:
        hook(self._cls_dict, locs)

attrs.src.attr._make._patch_original_class

def _patch_original_class(self):
    """
    Apply accumulated methods and return the class.
    """
    cls = self._cls
    base_names = self._base_names

    # Clean class of attribute definitions (`attr.ib()`s).
    if self._delete_attribs:
        for name in self._attr_names:
            if (
                name not in base_names
                and getattr(cls, name, _SENTINEL) is not _SENTINEL
            ):
                # An AttributeError can happen if a base class defines a
                # class variable and we want to set an attribute with the
                # same name by using only a type annotation.
                with contextlib.suppress(AttributeError):
                    delattr(cls, name)

    # Attach our dunder methods.
    for name, value in self._cls_dict.items():
        setattr(cls, name, value)

    # If we've inherited an attrs __setattr__ and don't write our own,
    # reset it to object's.
    if not self._wrote_own_setattr and getattr(
        cls, "__attrs_own_setattr__", False
    ):
        cls.__attrs_own_setattr__ = False

        if not self._has_custom_setattr:
            cls.__setattr__ = _OBJ_SETATTR

    return cls

attrs.src.attr._make._create_slots_class

def _create_slots_class(self):
    """
    Build and return a new class with a `__slots__` attribute.
    """
    cd = {
        k: v
        for k, v in self._cls_dict.items()
        if k not in (*tuple(self._attr_names), "__dict__", "__weakref__")
    }

    # 3.14.0rc2+
    if hasattr(sys, "_clear_type_descriptors"):
        sys._clear_type_descriptors(self._cls)

    # If our class doesn't have its own implementation of __setattr__
    # (either from the user or by us), check the bases, if one of them has
    # an attrs-made __setattr__, that needs to be reset. We don't walk the
    # MRO because we only care about our immediate base classes.
    # XXX: This can be confused by subclassing a slotted attrs class with
    # XXX: a non-attrs class and subclass the resulting class with an attrs
    # XXX: class.  See `test_slotted_confused` for details.  For now that's
    # XXX: OK with us.
    if not self._wrote_own_setattr:
        cd["__attrs_own_setattr__"] = False

        if not self._has_custom_setattr:
            for base_cls in self._cls.__bases__:
                if base_cls.__dict__.get("__attrs_own_setattr__", False):
                    cd["__setattr__"] = _OBJ_SETATTR
                    break

    # Traverse the MRO to collect existing slots
    # and check for an existing __weakref__.
    existing_slots = {}
    weakref_inherited = False
    for base_cls in self._cls.__mro__[1:-1]:
        if base_cls.__dict__.get("__weakref__", None) is not None:
            weakref_inherited = True
        existing_slots.update(
            {
                name: getattr(base_cls, name)
                for name in getattr(base_cls, "__slots__", [])
            }
        )

    base_names = set(self._base_names)

    names = self._attr_names
    if (
        self._weakref_slot
        and "__weakref__" not in getattr(self._cls, "__slots__", ())
        and "__weakref__" not in names
        and not weakref_inherited
    ):
        names += ("__weakref__",)

    cached_properties = {
        name: cached_prop.func
        for name, cached_prop in cd.items()
        if isinstance(cached_prop, cached_property)
    }

    # Collect methods with a `__class__` reference that are shadowed in the new class.
    # To know to update them.
    additional_closure_functions_to_update = []
    if cached_properties:
        class_annotations = _get_annotations(self._cls)
        for name, func in cached_properties.items():
            # Add cached properties to names for slotting.
            names += (name,)
            # Clear out function from class to avoid clashing.
            del cd[name]
            additional_closure_functions_to_update.append(func)
            annotation = inspect.signature(func).return_annotation
            if annotation is not inspect.Parameter.empty:
                class_annotations[name] = annotation

        original_getattr = cd.get("__getattr__")
        if original_getattr is not None:
            additional_closure_functions_to_update.append(original_getattr)

        cd["__getattr__"] = _make_cached_property_getattr(
            cached_properties, original_getattr, self._cls
        )

    # We only add the names of attributes that aren't inherited.
    # Setting __slots__ to inherited attributes wastes memory.
    slot_names = [name for name in names if name not in base_names]

    # There are slots for attributes from current class
    # that are defined in parent classes.
    # As their descriptors may be overridden by a child class,
    # we collect them here and update the class dict
    reused_slots = {
        slot: slot_descriptor
        for slot, slot_descriptor in existing_slots.items()
        if slot in slot_names
    }
    slot_names = [name for name in slot_names if name not in reused_slots]
    cd.update(reused_slots)
    if self._cache_hash:
        slot_names.append(_HASH_CACHE_FIELD)

    cd["__slots__"] = tuple(slot_names)

    cd["__qualname__"] = self._cls.__qualname__

    # Create new class based on old class and our methods.
    cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)

    # The following is a fix for
    # <https://github.com/python-attrs/attrs/issues/102>.
    # If a method mentions `__class__` or uses the no-arg super(), the
    # compiler will bake a reference to the class in the method itself
    # as `method.__closure__`.  Since we replace the class with a
    # clone, we rewrite these references so it keeps working.
    for item in itertools.chain(
        cls.__dict__.values(), additional_closure_functions_to_update
    ):
        if isinstance(item, (classmethod, staticmethod)):
            # Class- and staticmethods hide their functions inside.
            # These might need to be rewritten as well.
            closure_cells = getattr(item.__func__, "__closure__", None)
        elif isinstance(item, property):
            # Workaround for property `super()` shortcut (PY3-only).
            # There is no universal way for other descriptors.
            closure_cells = getattr(item.fget, "__closure__", None)
        else:
            closure_cells = getattr(item, "__closure__", None)

        if not closure_cells:  # Catch None or the empty list.
            continue
        for cell in closure_cells:
            try:
                match = cell.cell_contents is self._cls
            except ValueError:  # noqa: PERF203
                # ValueError: Cell is empty
                pass
            else:
                if match:
                    cell.cell_contents = cls
    return cls


[/PYTHON]
What will be the output of `build_class`, given the following input:
[INPUT]
```
{
    "self": {
        "auto_attribs": false,
        "these": null,
        "has_custom_setattr": false
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
