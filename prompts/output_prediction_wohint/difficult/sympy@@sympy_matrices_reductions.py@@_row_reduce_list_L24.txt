You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [/INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. You need to predict output variable values, and print output between [OUTPUT] and [/OUTPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[PYTHON]
from .utilities import _get_intermediate_simp, _iszero, _dotprodsimp, _simplify
from .determinant import _find_reasonable_pivot

def _row_reduce_list(mat, rows, cols, one, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):

    def get_col(i):
        return mat[i::cols]

    def row_swap(i, j):
        mat[i * cols:(i + 1) * cols], mat[j * cols:(j + 1) * cols] = (mat[j * cols:(j + 1) * cols], mat[i * cols:(i + 1) * cols])

    def cross_cancel(a, i, b, j):
        q = (j - i) * cols
        for p in range(i * cols, (i + 1) * cols):
            mat[p] = isimp(a * mat[p] - b * mat[p + q])
    isimp = _get_intermediate_simp(_dotprodsimp)
    piv_row, piv_col = (0, 0)
    pivot_cols = []
    swaps = []
    while piv_col < cols and piv_row < rows:
        pivot_offset, pivot_val, assumed_nonzero, newly_determined = _find_reasonable_pivot(get_col(piv_col)[piv_row:], iszerofunc, simpfunc)
        for offset, val in newly_determined:
            offset += piv_row
            mat[offset * cols + piv_col] = val
        if pivot_offset is None:
            piv_col += 1
            continue
        pivot_cols.append(piv_col)
        if pivot_offset != 0:
            row_swap(piv_row, pivot_offset + piv_row)
            swaps.append((piv_row, pivot_offset + piv_row))
        if normalize_last is False or not pivot_val.is_commutative:
            i, j = (piv_row, piv_col)
            mat[i * cols + j] = one
            for p in range(i * cols + j + 1, (i + 1) * cols):
                mat[p] = isimp(pivot_val ** (-1) * mat[p])
            pivot_val = one
        for row in range(rows):
            if row == piv_row:
                continue
            if zero_above is False and row < piv_row:
                continue
            val = mat[row * cols + piv_col]
            if iszerofunc(val):
                continue
            cross_cancel(pivot_val, row, val, piv_row)
        piv_row += 1
    if normalize_last is True and normalize is True:
        for piv_i, piv_j in enumerate(pivot_cols):
            pivot_val = mat[piv_i * cols + piv_j]
            mat[piv_i * cols + piv_j] = one
            for p in range(piv_i * cols + piv_j + 1, (piv_i + 1) * cols):
                mat[p] = isimp(pivot_val ** (-1) * mat[p])
    return (mat, tuple(pivot_cols), tuple(swaps))
[/PYTHON]

Functions called during the execution:
[PYTHON]
sympy.sympy.core.assumptions.getit

def getit(self):
    try:
        return self._assumptions[fact]
    except KeyError:
        if self._assumptions is self.default_assumptions:
            self._assumptions = self.default_assumptions.copy()
        return _ask(fact, self)

sympy.sympy.core.decorators._func

@wraps(func)
def _func(self, other):
    # XXX: The check for _op_priority here should be removed. It is
    # needed to stop mutable matrices from being sympified to
    # immutable matrices which breaks things in quantum...
    if not hasattr(other, '_op_priority'):
        try:
            other = sympify(other, strict=True)
        except SympifyError:
            return retval
    if not isinstance(other, expectedcls):
        return retval
    return func(self, other)

sympy.sympy.core.decorators.__sympifyit_wrapper

@wraps(func)
def __sympifyit_wrapper(a, b):
    try:
        # If an external class has _op_priority, it knows how to deal
        # with SymPy objects. Otherwise, it must be converted.
        if not hasattr(b, '_op_priority'):
            b = sympify(b, strict=True)
        return func(a, b)
    except SympifyError:
        return retval

sympy.sympy.core.expr.__pow__

def __pow__(self, other, mod=None) -> Expr:
    power = self._pow(other)
    if mod is None:
        return power
    else:
        try:
            return power % mod
        except TypeError:
            return NotImplemented

sympy.sympy.core.numbers.__mul__

def __mul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(self.p*other)
        elif isinstance(other, Integer):
            return Integer(self.p*other.p)
        elif isinstance(other, Rational):
            return Rational._new(self.p*other.p, other.q, igcd(self.p, other.q))
        return Rational.__mul__(self, other)
    return Rational.__mul__(self, other)

sympy.sympy.core.numbers.__rmul__

def __rmul__(self, other):
    if global_parameters.evaluate:
        if isinstance(other, int):
            return Integer(other*self.p)
        elif isinstance(other, Rational):
            return Rational._new(other.p*self.p, other.q, igcd(self.p, other.q))
        return Rational.__rmul__(self, other)
    return Rational.__rmul__(self, other)

sympy.sympy.core.numbers.__pow__

def __pow__(self, other, mod=None):
    if mod is not None:
        try:
            other_int = as_int(other)
            mod_int = as_int(mod)
        except ValueError:
            pass
        else:
            return Integer(pow(self.p, other_int, mod_int))

    return super().__pow__(other, mod)

sympy.sympy.geometry.point.<lambda>

return m.rank(iszerofunc = lambda x:
    abs(x.n(2)) < 1e-12 if x.is_number else x.is_zero)



sympy.sympy.logic.boolalg.__bool__

def __bool__(self):
    return False

sympy.sympy.matrices.determinant._find_reasonable_pivot

def _find_reasonable_pivot(
        col: Iterable[Expr],
        iszerofunc: Callable[[Expr], bool | None] = _iszero,
        simpfunc: Callable[[Expr], Expr] = _simplify,
    ) -> tuple[int | None, Expr | None, bool, list[tuple[int, Expr]]]:
    """ Find the lowest index of an item in ``col`` that is
    suitable for a pivot.  If ``col`` consists only of
    Floats, the pivot with the largest norm is returned.
    Otherwise, the first element where ``iszerofunc`` returns
    False is used.  If ``iszerofunc`` does not return false,
    items are simplified and retested until a suitable
    pivot is found.

    Returns a 4-tuple
        (pivot_offset, pivot_val, assumed_nonzero, newly_determined)
    where pivot_offset is the index of the pivot, pivot_val is
    the (possibly simplified) value of the pivot, assumed_nonzero
    is True if an assumption that the pivot was non-zero
    was made without being proved, and newly_determined are
    elements that were simplified during the process of pivot
    finding."""

    newly_determined: list[tuple[int, Expr]] = []
    col = list(col)
    # a column that contains a mix of floats and integers
    # but at least one float is considered a numerical
    # column, and so we do partial pivoting
    if all(isinstance(x, (Float, Integer)) for x in col) and any(
            isinstance(x, Float) for x in col):
        col_abs = [abs(x) for x in col]
        max_value = max(col_abs)
        if iszerofunc(max_value):
            # just because iszerofunc returned True, doesn't
            # mean the value is numerically zero.  Make sure
            # to replace all entries with numerical zeros
            if max_value != 0:
                newly_determined = [(i, S.Zero) for i, x in enumerate(col) if x != 0]
            return (None, None, False, newly_determined)
        index = col_abs.index(max_value)
        return (index, col[index], False, newly_determined)

    # PASS 1 (iszerofunc directly)
    possible_zeros = []
    for i, x in enumerate(col):
        is_zero = iszerofunc(x)
        # is someone wrote a custom iszerofunc, it may return
        # BooleanFalse or BooleanTrue instead of True or False,
        # so use == for comparison instead of `is`
        if is_zero == False:
            # we found something that is definitely not zero
            return (i, x, False, newly_determined)
        possible_zeros.append(is_zero)

    # by this point, we've found no certain non-zeros
    if all(possible_zeros):
        # if everything is definitely zero, we have
        # no pivot
        return (None, None, False, newly_determined)

    # PASS 2 (iszerofunc after simplify)
    # we haven't found any for-sure non-zeros, so
    # go through the elements iszerofunc couldn't
    # make a determination about and opportunistically
    # simplify to see if we find something
    for i, x in enumerate(col):
        if possible_zeros[i] is not None:
            continue
        simped = simpfunc(x)
        is_zero = iszerofunc(simped)
        if is_zero in (True, False):
            newly_determined.append((i, simped))
        if is_zero == False:
            return (i, simped, False, newly_determined)
        possible_zeros[i] = is_zero

    # after simplifying, some things that were recognized
    # as zeros might be zeros
    if all(possible_zeros):
        # if everything is definitely zero, we have
        # no pivot
        return (None, None, False, newly_determined)

    # PASS 3 (.equals(0))
    # some expressions fail to simplify to zero, but
    # ``.equals(0)`` evaluates to True.  As a last-ditch
    # attempt, apply ``.equals`` to these expressions
    for i, x in enumerate(col):
        if possible_zeros[i] is not None:
            continue
        if x.equals(S.Zero):
            # ``.iszero`` may return False with
            # an implicit assumption (e.g., ``x.equals(0)``
            # when ``x`` is a symbol), so only treat it
            # as proved when ``.equals(0)`` returns True
            possible_zeros[i] = True
            newly_determined.append((i, S.Zero))

    if all(possible_zeros):
        return (None, None, False, newly_determined)

    # at this point there is nothing that could definitely
    # be a pivot.  To maintain compatibility with existing
    # behavior, we'll assume that an illdetermined thing is
    # non-zero.  We should probably raise a warning in this case
    i = possible_zeros.index(None)
    return (i, col[i], True, newly_determined)

sympy.sympy.matrices.reductions.get_col

def get_col(i):
    return mat[i::cols]

sympy.sympy.matrices.reductions.row_swap

def row_swap(i, j):
    mat[i*cols:(i + 1)*cols], mat[j*cols:(j + 1)*cols] = \
        mat[j*cols:(j + 1)*cols], mat[i*cols:(i + 1)*cols]

sympy.sympy.matrices.reductions.cross_cancel

def cross_cancel(a, i, b, j):
    """Does the row op row[i] = a*row[i] - b*row[j]"""
    q = (j - i)*cols
    for p in range(i*cols, (i + 1)*cols):
        mat[p] = isimp(a*mat[p] - b*mat[p + q])

sympy.sympy.matrices.utilities._dotprodsimp

def _dotprodsimp(expr: Expr, withsimp: bool = False) -> Expr | tuple[Expr, bool]:
    """Wrapper for simplify.dotprodsimp to avoid circular imports."""
    from sympy.simplify.simplify import dotprodsimp as dps
    return dps(expr, withsimp=withsimp)

sympy.sympy.matrices.utilities._get_intermediate_simp

def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x,
        onfunc=_dotprodsimp, dotprodsimp=None):
    """Support function for controlling intermediate simplification. Returns a
    simplification function according to the global setting of dotprodsimp
    operation.

    ``deffunc``     - Function to be used by default.
    ``offfunc``     - Function to be used if dotprodsimp has been turned off.
    ``onfunc``      - Function to be used if dotprodsimp has been turned on.
    ``dotprodsimp`` - True, False or None. Will be overridden by global
                      _dotprodsimp_state.state if that is not None.
    """

    if dotprodsimp is False or _dotprodsimp_state.state is False:
        return offfunc
    if dotprodsimp is True or _dotprodsimp_state.state is True:
        return onfunc

    return deffunc # None, None

sympy.sympy.matrices.utilities._iszero

def _iszero(x: Expr) -> bool | None:
    """Returns True if x is zero."""
    return getattr(x, 'is_zero', None)


[/PYTHON]
What will be the output of `_row_reduce_list`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "mat": [
            "-9",
            "-17",
            "-19",
            "-10",
            "-18",
            "-17",
            "-21",
            "-38",
            "-40"
        ],
        "rows": 3,
        "cols": 3,
        "one": "1",
        "iszerofunc": "<function _iszero at 0x755447f77240>",
        "simpfunc": "<function _simplify at 0x755447f77380>",
        "normalize_last": true,
        "normalize": false,
        "zero_above": false
    },
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
