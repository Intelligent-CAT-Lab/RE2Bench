You will be given:
1. A Python code snippet wrapped in [PYTHON] ... [/PYTHON]. The code includes branch markers in comments of the form # [BRANCH]taken=??[/BRANCH].
2. A method input wrapped in [INPUT] ... [/INPUT].
Your task is to replace every "??" in "taken=??" with your prediction of whether the branches are taken during execution for the given input.

Detailed Instructions:
* Replace ?? with a list (e.g., ['Y', 'N', ...]).
* For each time that branch point is encountered during execution:
   ** Append 'Y' if that branch is taken.
   ** Append 'N' if that branch is not taken.
* Determine branch outcomes by tracing the code step by step, paying special attention to conditionals and loop iterations. Wrap your reasoning in [THOUGHT] ... [/THOUGHT]
* Output the fully annotated code (with ?? replaced) wrapped in [ANSWER] ... [/ANSWER]
* Do not remove, reorder, or add any code lines. 
* Preserve the original line numbers exactly as they appear in the [PYTHON] ... [/PYTHON] block.

Please follow the format in the example below:


[EXAMPLE]
[PYTHON]
1   class TempPathFactory(object):
2       _given_basetemp = attr.ib(
3           converter=attr.converters.optional(
4               lambda p: Path(os.path.abspath(six.text_type(p)))
5           )
6       )
7       _trace = attr.ib()
8       _basetemp = attr.ib(default=None)
9
10      def mktemp(self, basename, numbered=True):
11          if not numbered: ## [BRANCH]taken=??[/BRANCH]
12              p = self.getbasetemp().joinpath(basename)
13              p.mkdir()
14          else: ## [BRANCH]taken=??[/BRANCH]
15              p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
16              self._trace("mktemp", p)
17          return p
18
19      def getbasetemp(self):
20          if self._basetemp is not None:
21              return self._basetemp
22
23          if self._given_basetemp is not None:
24              basetemp = self._given_basetemp
25              ensure_reset_dir(basetemp)
26              basetemp = basetemp.resolve()
27          else:
28              from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
29              temproot = Path(from_env or tempfile.gettempdir()).resolve()
30              user = get_user() or "unknown"
31              rootdir = temproot.joinpath("pytest-of-{}".format(user))
32              rootdir.mkdir(exist_ok=True)
33              basetemp = make_numbered_dir_with_cleanup(
34                  prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
35              )
36          assert basetemp is not None, basetemp
37          self._basetemp = t = basetemp
38          self._trace("new basetemp", t)
39          return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

The input to method ```mktemp``` is:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
[/INPUT]

Complete the branch annotation in the code with "Y" and "N".

[THOUGHT]
In mktemp, the condition `if not numbered:` is checked once. 
Since numbered=True, it is not taken â†’ ['N']. 
Therefore the execution goes to the else: branch.
[/THOUGHT]

[ANSWER]
1   class TempPathFactory(object):
2       _given_basetemp = attr.ib(
3           converter=attr.converters.optional(
4               lambda p: Path(os.path.abspath(six.text_type(p)))
5           )
6       )
7       _trace = attr.ib()
8       _basetemp = attr.ib(default=None)
9
10      def mktemp(self, basename, numbered=True):
11          if not numbered: ## [BRANCH]taken=[N][/BRANCH]
12              p = self.getbasetemp().joinpath(basename)
13              p.mkdir()
14          else: ## [BRANCH]taken=[Y][/BRANCH]
15              p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
16              self._trace("mktemp", p)
17          return p
18
19      def getbasetemp(self):
20          if self._basetemp is not None:
21              return self._basetemp
22
23          if self._given_basetemp is not None:
24              basetemp = self._given_basetemp
25              ensure_reset_dir(basetemp)
26              basetemp = basetemp.resolve()
27          else:
28              from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
29              temproot = Path(from_env or tempfile.gettempdir()).resolve()
30              user = get_user() or "unknown"
31              rootdir = temproot.joinpath("pytest-of-{}".format(user))
32              rootdir.mkdir(exist_ok=True)
33              basetemp = make_numbered_dir_with_cleanup(
34                  prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
35              )
36          assert basetemp is not None, basetemp
37          self._basetemp = t = basetemp
38          self._trace("new basetemp", t)
39          return t
[/ANSWER]
[/EXAMPLE]

1 import os
2 import re
3 import time
4 import hashlib
5 import logging
6 from base64 import b64encode
7 from .compat import urlparse, str
8 from .utils import parse_dict_header
9 
10 log = logging.getLogger(__name__)
11 CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'
12 CONTENT_TYPE_MULTI_PART = 'multipart/form-data'
13 
14 class HTTPDigestAuth(AuthBase):
15     def __init__(self, username, password):
16         self.username = username
17         self.password = password
18         self.last_nonce = ''
19         self.nonce_count = 0
20         self.chal = {}
21         self.pos = None
22 
23     def build_digest_header(self, method, url):
24 
25         realm = self.chal['realm']
26         nonce = self.chal['nonce']
27         qop = self.chal.get('qop')
28         algorithm = self.chal.get('algorithm')
29         opaque = self.chal.get('opaque')
30 
31         if algorithm is None: ## [BRANCH]taken=??[/BRANCH]
32             _algorithm = 'MD5'
33         else:
34             _algorithm = algorithm.upper()
35         if _algorithm == 'MD5' or _algorithm == 'MD5-SESS': ## [BRANCH]taken=??[/BRANCH]
36             def md5_utf8(x):
37                 if isinstance(x, str): ## [BRANCH]taken=??[/BRANCH]
38                     x = x.encode('utf-8')
39                 return hashlib.md5(x).hexdigest()
40             hash_utf8 = md5_utf8
41         elif _algorithm == 'SHA': ## [BRANCH]taken=??[/BRANCH]
42             def sha_utf8(x):
43                 if isinstance(x, str):
44                     x = x.encode('utf-8')
45                 return hashlib.sha1(x).hexdigest()
46             hash_utf8 = sha_utf8
47 
48         KD = lambda s, d: hash_utf8("%s:%s" % (s, d))
49 
50         if hash_utf8 is None: ## [BRANCH]taken=??[/BRANCH]
51             return None
52 
53         entdig = None
54         p_parsed = urlparse(url)
55         path = p_parsed.path
56         if p_parsed.query: ## [BRANCH]taken=??[/BRANCH]
57             path += '?' + p_parsed.query
58 
59         A1 = '%s:%s:%s' % (self.username, realm, self.password)
60         A2 = '%s:%s' % (method, path)
61 
62         HA1 = hash_utf8(A1)
63         HA2 = hash_utf8(A2)
64 
65         if nonce == self.last_nonce: ## [BRANCH]taken=??[/BRANCH]
66             self.nonce_count += 1
67         else:
68             self.nonce_count = 1
69         ncvalue = '%08x' % self.nonce_count
70         s = str(self.nonce_count).encode('utf-8')
71         s += nonce.encode('utf-8')
72         s += time.ctime().encode('utf-8')
73         s += os.urandom(8)
74 
75         cnonce = (hashlib.sha1(s).hexdigest()[:16])
76         noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, HA2)
77         if _algorithm == 'MD5-SESS': ## [BRANCH]taken=??[/BRANCH]
78             HA1 = hash_utf8('%s:%s:%s' % (HA1, nonce, cnonce))
79 
80         if qop is None: ## [BRANCH]taken=??[/BRANCH]
81             respdig = KD(HA1, "%s:%s" % (nonce, HA2))
82         elif qop == 'auth' or 'auth' in qop.split(','): ## [BRANCH]taken=??[/BRANCH]
83             respdig = KD(HA1, noncebit)
84         else:
85             return None
86 
87         self.last_nonce = nonce
88 
89         base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
90                'response="%s"' % (self.username, realm, nonce, path, respdig)
91         if opaque: ## [BRANCH]taken=??[/BRANCH]
92             base += ', opaque="%s"' % opaque
93         if algorithm: ## [BRANCH]taken=??[/BRANCH]
94             base += ', algorithm="%s"' % algorithm
95         if entdig: ## [BRANCH]taken=??[/BRANCH]
96             base += ', digest="%s"' % entdig
97         if qop: ## [BRANCH]taken=??[/BRANCH]
98             base += ', qop="auth", nc=%s, cnonce="%s"' % (ncvalue, cnonce)
99 
100         return 'Digest %s' % (base)
101 
102     def handle_401(self, r, **kwargs):
103 
104         if self.pos is not None:
105             r.request.body.seek(self.pos)
106         num_401_calls = getattr(self, 'num_401_calls', 1)
107         s_auth = r.headers.get('www-authenticate', '')
108 
109         if 'digest' in s_auth.lower() and num_401_calls < 2:
110 
111             setattr(self, 'num_401_calls', num_401_calls + 1)
112             pat = re.compile(r'digest ', flags=re.IGNORECASE)
113             self.chal = parse_dict_header(pat.sub('', s_auth, count=1))
114 
115             r.content
116             r.raw.release_conn()
117             prep = r.request.copy()
118             prep.prepare_cookies(r.cookies)
119 
120             prep.headers['Authorization'] = self.build_digest_header(
121                 prep.method, prep.url)
122             _r = r.connection.send(prep, **kwargs)
123             _r.history.append(r)
124             _r.request = prep
125 
126             return _r
127 
128         setattr(self, 'num_401_calls', 1)
129         return r
130 
131     def __call__(self, r):
132         if self.last_nonce:
133             r.headers['Authorization'] = self.build_digest_header(r.method, r.url)
134         try:
135             self.pos = r.body.tell()
136         except AttributeError:
137             pass
138         r.register_hook('response', self.handle_401)
139         return r
140 

The input to the method ```build_digest_header``` is: 
 {
    "self": {
        "username": "user",
        "password": "pass",
        "last_nonce": "",
        "nonce_count": 0,
        "chal": {
            "realm": "me@kennethreitz.com",
            "nonce": "2cb6ca3bd92f46300c21bc6652450899",
            "qop": "auth",
            "opaque": "3b88561378508443a8b14a91ec359904",
            "algorithm": "MD5",
            "stale": "FALSE"
        },
        "pos": null,
        "num_401_calls": 2
    },
    "args": {
        "method": "GET",
        "url": "http://httpbin.org/digest-auth/auth/user/pass"
    },
    "kwargs": {}
}

Complete the branch annotation in the code with "Y" and "N".
