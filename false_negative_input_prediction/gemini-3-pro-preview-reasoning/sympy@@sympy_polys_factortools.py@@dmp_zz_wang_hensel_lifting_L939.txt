<<FUNCTION_NAME>>

dmp_zz_wang_hensel_lifting

<<CODE>>

from sympy.polys.densebasic import (
    dup_LC, dmp_LC, dmp_ground_LC,
    dup_TC,
    dup_convert, dmp_convert,
    dup_degree, dmp_degree,
    dmp_degree_in, dmp_degree_list,
    dmp_from_dict,
    dmp_zero_p,
    dmp_one,
    dmp_nest, dmp_raise,
    dup_strip,
    dmp_ground,
    dup_inflate,
    dmp_exclude, dmp_include,
    dmp_inject, dmp_eject,
    dup_terms_gcd, dmp_terms_gcd)
from sympy.polys.densearith import (
    dup_neg, dmp_neg,
    dup_add, dmp_add,
    dup_sub, dmp_sub,
    dup_mul, dmp_mul,
    dup_sqr,
    dmp_pow,
    dup_div, dmp_div,
    dup_quo, dmp_quo,
    dmp_expand,
    dmp_add_mul,
    dup_sub_mul, dmp_sub_mul,
    dup_lshift,
    dup_max_norm, dmp_max_norm,
    dup_l1_norm,
    dup_mul_ground, dmp_mul_ground,
    dup_quo_ground, dmp_quo_ground)
from sympy.polys.densetools import (
    dup_clear_denoms, dmp_clear_denoms,
    dup_trunc, dmp_ground_trunc,
    dup_content,
    dup_monic, dmp_ground_monic,
    dup_primitive, dmp_ground_primitive,
    dmp_eval_tail,
    dmp_eval_in, dmp_diff_eval_in,
    dup_shift, dmp_shift, dup_mirror)
from sympy.polys.polyerrors import (
    ExtraneousFactors, DomainError, CoercionFailed, EvaluationFailed)

def dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K):
    """Wang/EEZ: Parallel Hensel lifting algorithm. """
    S, n, v = [f], len(A), u - 1

    H = list(H)

    for i, a in enumerate(reversed(A[1:])):
        s = dmp_eval_in(S[0], a, n - i, u - i, K)
        S.insert(0, dmp_ground_trunc(s, p, v - i, K))

    d = max(dmp_degree_list(f, u)[1:])

    for j, s, a in zip(range(2, n + 2), S, A):
        G, w = list(H), j - 1

        I, J = A[:j - 2], A[j - 1:]

        for i, (h, lc) in enumerate(zip(H, LC)):
            lc = dmp_ground_trunc(dmp_eval_tail(lc, J, v, K), p, w - 1, K)
            H[i] = [lc] + dmp_raise(h[1:], 1, w - 1, K)

        m = dmp_nest([K.one, -a], w, K)
        M = dmp_one(w, K)

        c = dmp_sub(s, dmp_expand(H, w, K), w, K)

        dj = dmp_degree_in(s, w, w)

        for k in range(0, dj):
            if dmp_zero_p(c, w):
                break

            M = dmp_mul(M, m, w, K)
            C = dmp_diff_eval_in(c, k + 1, a, w, w, K)

            if not dmp_zero_p(C, w - 1):
                C = dmp_quo_ground(C, K.factorial(K(k) + 1), w - 1, K)
                T = dmp_zz_diophantine(G, C, I, d, p, w - 1, K)

                for i, (h, t) in enumerate(zip(H, T)):
                    h = dmp_add_mul(h, dmp_raise(t, 1, w - 1, K), M, w, K)
                    H[i] = dmp_ground_trunc(h, p, w, K)

                h = dmp_sub(s, dmp_expand(H, w, K), w, K)
                c = dmp_ground_trunc(h, p, w, K)

    if dmp_expand(H, u, K) != f:
        raise ExtraneousFactors  # pragma: no cover
    else:
        return H


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'f': [[1], [], [-1, 0, 0]], 'H': [[1, -1], [1, 1]], 'LC': [[1], [1]], 'A': [-1], 'p': 37, 'u': 1, 'K': 'ZZ'}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

[[[1], [1, 0]], [[1], [-1, 0]]]

<<LLM_RESPONSE>>

To predict the input for the function `dmp_zz_wang_hensel_lifting`, we analyze the function logic and the provided output.

**Analysis Steps:**

1.  **Analyze the Output:**
    The output is `H_out`:
    ```json
    [
        [ [1], [1, 0] ],
        [ [1], [-1, 0] ]
    ]
    ```
    This represents a list of dense multivariate polynomials (`dmp`).
    - The outer structure lists two factors.
    - Each factor is in recursive dense representation.
    - Let's assume $u=1$ (2 variables, say $x$ and $y$).
    - Factor 1: `[ [1], [1, 0] ]`.
        - Coefficient of $x^1$: `[1]` (polynomial 1 in $y$).
        - Coefficient of $x^0$: `[1, 0]` (polynomial $y$ in $y$, i.e., $1\cdot y + 0$).
        - Factor is $1 \cdot x + y = x + y$.
    - Factor 2: `[ [1], [-1, 0] ]`.
        - Coefficient of $x^1$: `[1]` (1).
        - Coefficient of $x^0$: `[-1, 0]` ($-y$).
        - Factor is $x - y$.
    
    The function returns this list `H`. The code asserts `dmp_expand(H, u, K) == f`.
    So `f` must be the product: $(x+y)(x-y) = x^2 - y^2$.

2.  **Determine Input `f`:**
    - Variable $u=1$.
    - Polynomial $x^2 - y^2$.
    - Representation:
        - $x^2$ term: coefficient 1 (in $y$). `[1]` is `[1]`.
        - $x^1$ term: coefficient 0. `[]`.
        - $x^0$ term: coefficient $-y^2$. $-y^2$ in dense representation ($u=0$) is `[-1, 0, 0]`.
    - `f` = `[ [1], [], [-1, 0, 0] ]`.

3.  **Determine Input `H`, `A`, and `LC`:**
    - The algorithm lifts factors from a univariate domain (substituted $x_1...x_u$ with $A$) to the multivariate domain.
    - `H` (input) corresponds to the factors of $f$ evaluated at `A`.
    - `H_out` evaluated at `A` must match `H_in`.
    - Trying `A = [1]` (a standard choice for $x^2-y^2$ to ensure square-freeness).
        - $(x+y)$ at $y=1$ becomes $x+1$. Dense: `[1, 1]`.
        - $(x-y)$ at $y=1$ becomes $x-1$. Dense: `[1, -1]`.
    - Input `H` must be `[[1, 1], [1, -1]]`.
    - `LC` contains the leading coefficients of the target factors.
        - $x+y$ is monic in $x$. Leading coeff is $1$ (as polynomial in $y$: `[1]`).
        - $x-y$ is monic in $x$. Leading coeff is $1$ (`[1]`).
        - `LC` = `[[1], [1]]`.
    - `u` is `1`.
    - `K` is `ZZ` (Integer Ring).

4.  **Determine `p`:**
    - `p` is a prime used for coefficient truncation and solving Diophantine equations.
    - Since the result coefficients are $-1, 1$ and the calculation is over $\mathbb{Z}$, any prime $p \ge 3$ works (preserving $-1$ as $-1$ in symmetric representation).
    - `97` is a common default large prime in such tests. We will use `97`.

[INPUT]
```
{
    "self": {},
    "args": {
        "f": [[1], [], [-1, 0, 0]],
        "H": [[1, 1], [1, -1]],
        "LC": [[1], [1]],
        "A": [1],
        "p": 97,
        "u": 1,
        "K": "ZZ"
    },
    "kwargs": {}
}
```
[/INPUT]