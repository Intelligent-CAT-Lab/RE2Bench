<<FUNCTION_NAME>>

extract

<<CODE>>

from collections import defaultdict
from .exceptions import DMBadInputError, DMDomainError, DMShapeError

class SDM(dict):
    """Sparse matrix based on polys domain elements

    This is a dict subclass and is a wrapper for a dict of dicts that supports
    basic matrix arithmetic +, -, *, **.


    In order to create a new :py:class:`~.SDM`, a dict
    of dicts mapping non-zero elements to their
    corresponding row and column in the matrix is needed.

    We also need to specify the shape and :py:class:`~.Domain`
    of our :py:class:`~.SDM` object.

    We declare a 2x2 :py:class:`~.SDM` matrix belonging
    to QQ domain as shown below.
    The 2x2 Matrix in the example is

    .. math::
           A = \\left[\\begin{array}{ccc}
                0 & \\frac{1}{2} \\\\
                0 & 0 \\end{array} \\right]


    >>> from sympy.polys.matrices.sdm import SDM
    >>> from sympy import QQ
    >>> elemsdict = {0:{1:QQ(1, 2)}}
    >>> A = SDM(elemsdict, (2, 2), QQ)
    >>> A
    {0: {1: 1/2}}

    We can manipulate :py:class:`~.SDM` the same way
    as a Matrix class

    >>> from sympy import ZZ
    >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)
    >>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)
    >>> A + B
    {0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}}

    Multiplication

    >>> A*B
    {0: {1: 8}, 1: {0: 3}}
    >>> A*ZZ(2)
    {0: {1: 4}, 1: {0: 2}}

    """
    fmt = 'sparse'
    is_DFM = False
    is_DDM = False

    def __init__(self, elemsdict, shape, domain):
        super().__init__(elemsdict)
        self.shape = self.rows, self.cols = m, n = shape
        self.domain = domain
        if not all((0 <= r < m for r in self)):
            raise DMBadInputError('Row out of range')
        if not all((0 <= c < n for row in self.values() for c in row)):
            raise DMBadInputError('Column out of range')

    def extract(self, rows, cols):
        if not (self and rows and cols):
            return self.zeros((len(rows), len(cols)), self.domain)
        m, n = self.shape
        if not -m <= min(rows) <= max(rows) < m:
            raise IndexError('Row index out of range')
        if not -n <= min(cols) <= max(cols) < n:
            raise IndexError('Column index out of range')
        rowmap = defaultdict(list)
        colmap = defaultdict(list)
        for i2, i1 in enumerate(rows):
            rowmap[i1 % m].append(i2)
        for j2, j1 in enumerate(cols):
            colmap[j1 % n].append(j2)
        rowset = set(rowmap)
        colset = set(colmap)
        sdm1 = self
        sdm2 = {}
        for i1 in rowset & sdm1.keys():
            row1 = sdm1[i1]
            row2 = {}
            for j1 in colset & row1.keys():
                row1_j1 = row1[j1]
                for j2 in colmap[j1]:
                    row2[j2] = row1_j1
            if row2:
                for i2 in rowmap[i1]:
                    sdm2[i2] = row2.copy()
        return self.new(sdm2, (len(rows), len(cols)), self.domain)

    @classmethod
    def new(cls, sdm, shape, domain):
        """

        Parameters
        ==========

        sdm: A dict of dicts for non-zero elements in SDM
        shape: tuple representing dimension of SDM
        domain: Represents :py:class:`~.Domain` of SDM

        Returns
        =======

        An :py:class:`~.SDM` object

        Examples
        ========

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> elemsdict = {0:{1: QQ(2)}}
        >>> A = SDM.new(elemsdict, (2, 2), QQ)
        >>> A
        {0: {1: 2}}

        """
        return cls(sdm, shape, domain)

    @classmethod
    def zeros(cls, shape, domain):
        """

        Returns a :py:class:`~.SDM` of size shape,
        belonging to the specified domain

        In the example below we declare a matrix A where,

        .. math::
            A := \\left[\\begin{array}{ccc}
            0 & 0 & 0 \\\\
            0 & 0 & 0 \\end{array} \\right]

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> A = SDM.zeros((2, 3), QQ)
        >>> A
        {}

        """
        return cls({}, shape, domain)


<<GROUND_TRUTH_INPUT>>

{'self': {'shape': [3, 3], 'rows': 3, 'cols': 3, 'domain': 'ZZ'}, 'args': {'rows': [0, 1, 2], 'cols': [0]}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

{'0': {'0': 1}, '1': {'0': 1}, '2': {'0': 1}}

<<LLM_RESPONSE>>

[THOUGHT]
1.  **Analyze the Class and Method**: The code defines `SDM` (Sparse Dense Matrix?), which inherits from `dict`. It stores matrix elements in a dictionary of dictionaries format `{row: {col: value}}`. The `extract` method slices the matrix based on lists of row indices (`rows`) and column indices (`cols`). It supports modulo arithmetic for tiling if indices are out of bounds but valid `min/max` constraints checks exist (which seem to just enforce bounds relative to shape `m, n` when indices are interpreted directly, but the logic `i1 % m` suggests handling logic similar to wrapping or just mapping).
2.  **Analyze the Output**: The output is `{'0': {'0': 1}, '1': {'0': 1}, '2': {'0': 1}}`. This represents a matrix with 3 rows (indices 0, 1, 2) and 1 column (index 0). The value is `1` in all these positions.
3.  **Reverse Engineer Arguments**:
    *   Since the output has 3 rows, the `rows` argument passed to `extract` must calculate to 3 indices. The keys `0, 1, 2` in the output correspond to the indices of the `rows` list itself (variable `i2` in the code). Thus, `len(rows)` must be 3.
    *   Since the output has 1 column key `0` (variable `j2`), `len(cols)` must be 1.
    *   The values are all `1`. This implies the source matrix `self` contains `1` at the coordinates mapped by `rows` and `cols`.
4.  **Construct `self` state**:
    *   Minimal Assumption: `self` is a $1 \times 1$ matrix with `self[0][0] = 1`.
    *   `shape` should be `(1, 1)`. `rows` attribute (m) = 1, `cols` attribute (n) = 1.
    *   If `self` is $1 \times 1$, then `m=1`. The mapping `rowmap[i1 % m]` means any row index in the argument maps to row 0 of `self`.
    *   To get 3 rows in output, we can pass `rows=[0, 0, 0]`. All map to row 0.
    *   To get 1 col in output, we pass `cols=[0]`.
    *   Usage of `domain`: The function passes `self.domain` to `new`. Arguments don't rely on it. I'll set it to `null`.
    *   **Data Representation**: The `SDM` class is a `dict`. The JSON representation of `self` must include the dictionary items to be valid. The provided structure schema is skeletal. I must add the dictionary entry `"0": {"0": 1}` to `self` so that `extract` finds the data.
5.  **Final Values**:
    *   `self`: `{"0": {"0": 1}, "shape": [1, 1], "rows": 1, "cols": 1, "domain": null}`.
    *   `args`: `rows=[0, 0, 0]`, `cols=[0]`.

[/THOUGHT]

[INPUT]
```
{
    "self": {
        "0": {
            "0": 1
        },
        "shape": [
            1,
            1
        ],
        "rows": 1,
        "cols": 1,
        "domain": null
    },
    "args": {
        "rows": [
            0,
            0,
            0
        ],
        "cols": [
            0
        ]
    },
    "kwargs": {}
}
```
[/INPUT]