<<FUNCTION_NAME>>

_consumes_sample_weight

<<CODE>>

from sklearn.utils.metadata_routing import (
    MetadataRouter,
    MethodMapping,
    _raise_for_params,
    _routing_enabled,
    get_routing_for_object,
    process_routing,
)
from sklearn.utils.validation import (
    _check_method_params,
    _check_sample_weight,
    _estimator_has,
    check_is_fitted,
    has_fit_parameter,
    validate_data,
)

def _consumes_sample_weight(estimator):
    if _routing_enabled():
        request_or_router = get_routing_for_object(estimator)
        consumes_sample_weight = request_or_router.consumes("fit", ("sample_weight",))
    else:
        consumes_sample_weight = has_fit_parameter(estimator, "sample_weight")
    return consumes_sample_weight


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'estimator': 'KNeighborsClassifier()'}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

False

<<LLM_RESPONSE>>

[THOUGHT]
We need _consumes_sample_weight(estimator) to return false.

The function does:
- If _routing_enabled() is True, it queries get_routing_for_object(estimator) and calls .consumes('fit', ('sample_weight',)). That could return an empty set (falsy), but to keep it simple we assume routing is disabled (the default is False), so the else branch runs.
- In the else branch it returns has_fit_parameter(estimator, 'sample_weight') which is:
    hasattr(estimator, "fit") and 'sample_weight' in signature(estimator.fit).parameters

To get False, it's enough that the estimator does not have a fit attribute. A simple JSON representation that maps to a Python object without a fit attribute is an empty dict ({}). hasattr({}, "fit") is False, so has_fit_parameter returns False and thus the function returns False.

Therefore choose estimator = {}.
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "estimator": {}
    },
    "kwargs": {}
}
```
[/INPUT]