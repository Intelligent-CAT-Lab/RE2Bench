<<FUNCTION_NAME>>

extract

<<CODE>>

from collections import defaultdict
from .exceptions import DMBadInputError, DMDomainError, DMShapeError

class SDM(dict):
    """Sparse matrix based on polys domain elements

    This is a dict subclass and is a wrapper for a dict of dicts that supports
    basic matrix arithmetic +, -, *, **.


    In order to create a new :py:class:`~.SDM`, a dict
    of dicts mapping non-zero elements to their
    corresponding row and column in the matrix is needed.

    We also need to specify the shape and :py:class:`~.Domain`
    of our :py:class:`~.SDM` object.

    We declare a 2x2 :py:class:`~.SDM` matrix belonging
    to QQ domain as shown below.
    The 2x2 Matrix in the example is

    .. math::
           A = \\left[\\begin{array}{ccc}
                0 & \\frac{1}{2} \\\\
                0 & 0 \\end{array} \\right]


    >>> from sympy.polys.matrices.sdm import SDM
    >>> from sympy import QQ
    >>> elemsdict = {0:{1:QQ(1, 2)}}
    >>> A = SDM(elemsdict, (2, 2), QQ)
    >>> A
    {0: {1: 1/2}}

    We can manipulate :py:class:`~.SDM` the same way
    as a Matrix class

    >>> from sympy import ZZ
    >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)
    >>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)
    >>> A + B
    {0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}}

    Multiplication

    >>> A*B
    {0: {1: 8}, 1: {0: 3}}
    >>> A*ZZ(2)
    {0: {1: 4}, 1: {0: 2}}

    """
    fmt = 'sparse'
    is_DFM = False
    is_DDM = False

    def __init__(self, elemsdict, shape, domain):
        super().__init__(elemsdict)
        self.shape = self.rows, self.cols = m, n = shape
        self.domain = domain
        if not all((0 <= r < m for r in self)):
            raise DMBadInputError('Row out of range')
        if not all((0 <= c < n for row in self.values() for c in row)):
            raise DMBadInputError('Column out of range')

    def extract(self, rows, cols):
        if not (self and rows and cols):
            return self.zeros((len(rows), len(cols)), self.domain)
        m, n = self.shape
        if not -m <= min(rows) <= max(rows) < m:
            raise IndexError('Row index out of range')
        if not -n <= min(cols) <= max(cols) < n:
            raise IndexError('Column index out of range')
        rowmap = defaultdict(list)
        colmap = defaultdict(list)
        for i2, i1 in enumerate(rows):
            rowmap[i1 % m].append(i2)
        for j2, j1 in enumerate(cols):
            colmap[j1 % n].append(j2)
        rowset = set(rowmap)
        colset = set(colmap)
        sdm1 = self
        sdm2 = {}
        for i1 in rowset & sdm1.keys():
            row1 = sdm1[i1]
            row2 = {}
            for j1 in colset & row1.keys():
                row1_j1 = row1[j1]
                for j2 in colmap[j1]:
                    row2[j2] = row1_j1
            if row2:
                for i2 in rowmap[i1]:
                    sdm2[i2] = row2.copy()
        return self.new(sdm2, (len(rows), len(cols)), self.domain)

    @classmethod
    def new(cls, sdm, shape, domain):
        """

        Parameters
        ==========

        sdm: A dict of dicts for non-zero elements in SDM
        shape: tuple representing dimension of SDM
        domain: Represents :py:class:`~.Domain` of SDM

        Returns
        =======

        An :py:class:`~.SDM` object

        Examples
        ========

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> elemsdict = {0:{1: QQ(2)}}
        >>> A = SDM.new(elemsdict, (2, 2), QQ)
        >>> A
        {0: {1: 2}}

        """
        return cls(sdm, shape, domain)

    @classmethod
    def zeros(cls, shape, domain):
        """

        Returns a :py:class:`~.SDM` of size shape,
        belonging to the specified domain

        In the example below we declare a matrix A where,

        .. math::
            A := \\left[\\begin{array}{ccc}
            0 & 0 & 0 \\\\
            0 & 0 & 0 \\end{array} \\right]

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> A = SDM.zeros((2, 3), QQ)
        >>> A
        {}

        """
        return cls({}, shape, domain)


<<GROUND_TRUTH_INPUT>>

{'self': {'shape': [3, 3], 'rows': 3, 'cols': 3, 'domain': 'ZZ'}, 'args': {'rows': [0, 1, 2], 'cols': [0]}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

{'0': {'0': 1}, '1': {'0': 1}, '2': {'0': 1}}

<<LLM_RESPONSE>>

[THOUGHT]
We need extract to return an SDM whose dict representation is:
{
  "0": {"0": 1},
  "1": {"0": 1},
  "2": {"0": 1}
}

Looking at extract:
- The result shape is (len(rows), len(cols)), so to get three output rows and one output column we need rows length = 3 and cols length = 1.
- The output has entries at result row indices 0,1,2 and result column index 0 with value 1. That arises when:
  - The input rows list maps to original row indices i1 = 0,1,2 (so rowmap maps original rows 0,1,2 to result indices 0,1,2).
  - The input cols list maps to original column j1 = 0 (so colmap maps original col 0 to result col index 0).
- For these intersections to produce values 1, the original SDM (self) must have non-zero entries at rows 0,1,2 and column 0 with value 1, i.e. the internal elemsdict = {0:{0:1}, 1:{0:1}, 2:{0:1}} and shape (3,1).
- extract will build sdm2 identical to that mapping when called with rows=[0,1,2], cols=[0].

Therefore the input should have:
- self.shape = (3, 1), self.rows = 3, self.cols = 1, domain can be any domain (not used in the printed output).
- args.rows = [0, 1, 2], args.cols = [0]
- kwargs = {}

I fill the placeholders accordingly.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "QQ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
```
[/INPUT]