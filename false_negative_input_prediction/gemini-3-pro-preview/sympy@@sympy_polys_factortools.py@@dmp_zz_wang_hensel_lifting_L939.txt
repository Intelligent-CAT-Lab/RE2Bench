<<FUNCTION_NAME>>

dmp_zz_wang_hensel_lifting

<<CODE>>

from sympy.polys.densebasic import (
    dup_LC, dmp_LC, dmp_ground_LC,
    dup_TC,
    dup_convert, dmp_convert,
    dup_degree, dmp_degree,
    dmp_degree_in, dmp_degree_list,
    dmp_from_dict,
    dmp_zero_p,
    dmp_one,
    dmp_nest, dmp_raise,
    dup_strip,
    dmp_ground,
    dup_inflate,
    dmp_exclude, dmp_include,
    dmp_inject, dmp_eject,
    dup_terms_gcd, dmp_terms_gcd)
from sympy.polys.densearith import (
    dup_neg, dmp_neg,
    dup_add, dmp_add,
    dup_sub, dmp_sub,
    dup_mul, dmp_mul,
    dup_sqr,
    dmp_pow,
    dup_div, dmp_div,
    dup_quo, dmp_quo,
    dmp_expand,
    dmp_add_mul,
    dup_sub_mul, dmp_sub_mul,
    dup_lshift,
    dup_max_norm, dmp_max_norm,
    dup_l1_norm,
    dup_mul_ground, dmp_mul_ground,
    dup_quo_ground, dmp_quo_ground)
from sympy.polys.densetools import (
    dup_clear_denoms, dmp_clear_denoms,
    dup_trunc, dmp_ground_trunc,
    dup_content,
    dup_monic, dmp_ground_monic,
    dup_primitive, dmp_ground_primitive,
    dmp_eval_tail,
    dmp_eval_in, dmp_diff_eval_in,
    dup_shift, dmp_shift, dup_mirror)
from sympy.polys.polyerrors import (
    ExtraneousFactors, DomainError, CoercionFailed, EvaluationFailed)

def dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K):
    """Wang/EEZ: Parallel Hensel lifting algorithm. """
    S, n, v = [f], len(A), u - 1

    H = list(H)

    for i, a in enumerate(reversed(A[1:])):
        s = dmp_eval_in(S[0], a, n - i, u - i, K)
        S.insert(0, dmp_ground_trunc(s, p, v - i, K))

    d = max(dmp_degree_list(f, u)[1:])

    for j, s, a in zip(range(2, n + 2), S, A):
        G, w = list(H), j - 1

        I, J = A[:j - 2], A[j - 1:]

        for i, (h, lc) in enumerate(zip(H, LC)):
            lc = dmp_ground_trunc(dmp_eval_tail(lc, J, v, K), p, w - 1, K)
            H[i] = [lc] + dmp_raise(h[1:], 1, w - 1, K)

        m = dmp_nest([K.one, -a], w, K)
        M = dmp_one(w, K)

        c = dmp_sub(s, dmp_expand(H, w, K), w, K)

        dj = dmp_degree_in(s, w, w)

        for k in range(0, dj):
            if dmp_zero_p(c, w):
                break

            M = dmp_mul(M, m, w, K)
            C = dmp_diff_eval_in(c, k + 1, a, w, w, K)

            if not dmp_zero_p(C, w - 1):
                C = dmp_quo_ground(C, K.factorial(K(k) + 1), w - 1, K)
                T = dmp_zz_diophantine(G, C, I, d, p, w - 1, K)

                for i, (h, t) in enumerate(zip(H, T)):
                    h = dmp_add_mul(h, dmp_raise(t, 1, w - 1, K), M, w, K)
                    H[i] = dmp_ground_trunc(h, p, w, K)

                h = dmp_sub(s, dmp_expand(H, w, K), w, K)
                c = dmp_ground_trunc(h, p, w, K)

    if dmp_expand(H, u, K) != f:
        raise ExtraneousFactors  # pragma: no cover
    else:
        return H


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'f': [[1], [], [-1, 0, 0]], 'H': [[1, -1], [1, 1]], 'LC': [[1], [1]], 'A': [-1], 'p': 37, 'u': 1, 'K': 'ZZ'}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

[[[1], [1, 0]], [[1], [-1, 0]]]

<<LLM_RESPONSE>>

The function `dmp_zz_wang_hensel_lifting` lifts a univariate factorization of a polynomial `f` (evaluated at specific points for the other variables) to the full multivariate factorization.

Based on the output `[[[1], [1, 0]], [[1], [-1, 0]]]`:
1.  There are two factors.
2.  The output factors are in dense recursive representation (`dmp`).
3.  The structure `[[1], [1, 0]]` suggests `u=1` (2 variables, say $x$ and $y$). The first element `[1]` is the coefficient of $x^1$ (which is $1$). The second element `[1, 0]` is the coefficient of $x^0$, which is a polynomial in $y$: $1\cdot y + 0 = y$. Thus, the first factor is $x + y$.
4.  Similarly, `[[1], [-1, 0]]` represents $x - y$.
5.  Therefore, the polynomial being factored is $f = (x+y)(x-y) = x^2 - y^2$.

Reconstructing the input arguments:
*   `f`: The representation of $x^2 - y^2$ in `dmp` with `u=1` over `ZZ`.
    *   Degree in $x$ is 2.
    *   Coeff of $x^2$: $1$ $\to$ `[1]`.
    *   Coeff of $x^1$: $0$ $\to$ `[]`.
    *   Coeff of $x^0$: $-y^2$. $-y^2$ in $y$ is `[-1, 0, 0]`.
    *   So `f` is `[[1], [], [-1, 0, 0]]`.
*   `u`: The output implies 2 variables ($x, y$). In SymPy `dmp`, this corresponds to `u=1`.
*   `A`: The evaluation points used to reduce `f` to a univariate polynomial. The standard convenient point is $y=1$. If $y=1$, `f = x^2 - 1`. `A` is a list `[1]`.
*   `H`: The modular factors of $f$ evaluated at `A`. Factors of $x^2 - 1$ are $x+1$ and $x-1$.
    *   $x+1$ in `dmp` ($u=0$) is `[1, 1]`.
    *   $x-1$ in `dmp` ($u=0$) is `[1, -1]`.
    *   The output order matches $x+y$ then $x-y$. Since $x+y$ at $y=1$ is $x+1$, the first element of `H` must be `[1, 1]`. The second is `[1, -1]`.
    *   `H` is `[[1, 1], [1, -1]]`.
*   `LC`: Leading coefficients of the factors. Both $x+y$ and $x-y$ are monic in $x$. The leading coefficient (in $x$) is $1$ (as a polynomial in $y$). `[1]` represented as `dmp` with `u=0` is `[1]`. So `LC` is `[[1], [1]]`.
*   `p`: A prime or bound. Since the output coefficients are small (1, -1), a small prime like `5` is sufficient and typical (assuming `A=[1]` works modulo 5).
*   `K`: The domain. Based on imports and context (`dmp_zz...`), this is `ZZ`.

[INPUT]
```
{
    "self": {},
    "args": {
        "f": [[1], [], [-1, 0, 0]],
        "H": [[1, 1], [1, -1]],
        "LC": [[1], [1]],
        "A": [1],
        "p": 5,
        "u": 1,
        "K": "ZZ"
    },
    "kwargs": {}
}
```
[/INPUT]