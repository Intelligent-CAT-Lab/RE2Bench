<<FUNCTION_NAME>>

TR8

<<CODE>>

from sympy.core.exprtools import Factors, gcd_terms, factor_terms
from sympy.core.function import expand_mul
from sympy.core.mul import Mul
from sympy.core.traversal import bottom_up
from sympy.functions.elementary.trigonometric import (
    cos, sin, tan, cot, sec, csc, sqrt, TrigonometricFunction)

def TR8(rv, first=True):
    """Converting products of ``cos`` and/or ``sin`` to a sum or
    difference of ``cos`` and or ``sin`` terms.

    Examples
    ========

    >>> from sympy.simplify.fu import TR8
    >>> from sympy import cos, sin
    >>> TR8(cos(2)*cos(3))
    cos(5)/2 + cos(1)/2
    >>> TR8(cos(2)*sin(3))
    sin(5)/2 + sin(1)/2
    >>> TR8(sin(2)*sin(3))
    -cos(5)/2 + cos(1)/2
    """

    def f(rv):
        if not (
            rv.is_Mul or
            rv.is_Pow and
            rv.base.func in (cos, sin) and
            (rv.exp.is_integer or rv.base.is_positive)):
            return rv

        if first:
            n, d = [expand_mul(i) for i in rv.as_numer_denom()]
            newn = TR8(n, first=False)
            newd = TR8(d, first=False)
            if newn != n or newd != d:
                rv = gcd_terms(newn/newd)
                if rv.is_Mul and rv.args[0].is_Rational and \
                        len(rv.args) == 2 and rv.args[1].is_Add:
                    rv = Mul(*rv.as_coeff_Mul())
            return rv

        args = {cos: [], sin: [], None: []}
        for a in Mul.make_args(rv):
            if a.func in (cos, sin):
                args[type(a)].append(a.args[0])
            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \
                    a.base.func in (cos, sin)):
                # XXX this is ok but pathological expression could be handled
                # more efficiently as in TRmorrie
                args[type(a.base)].extend([a.base.args[0]]*a.exp)
            else:
                args[None].append(a)
        c = args[cos]
        s = args[sin]
        if not (c and s or len(c) > 1 or len(s) > 1):
            return rv

        args = args[None]
        n = min(len(c), len(s))
        for i in range(n):
            a1 = s.pop()
            a2 = c.pop()
            args.append((sin(a1 + a2) + sin(a1 - a2))/2)
        while len(c) > 1:
            a1 = c.pop()
            a2 = c.pop()
            args.append((cos(a1 + a2) + cos(a1 - a2))/2)
        if c:
            args.append(cos(c.pop()))
        while len(s) > 1:
            a1 = s.pop()
            a2 = s.pop()
            args.append((-cos(a1 + a2) + cos(a1 - a2))/2)
        if s:
            args.append(sin(s.pop()))
        return TR8(expand_mul(Mul(*args)))

    return bottom_up(rv, f)


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'rv': 'cos(phi)**2', 'first': False}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

cos(2*phi)/2 + 1/2

<<LLM_RESPONSE>>

The logic of the `TR8` function is to perform trigonometric power reduction. It converts products and powers of sines and cosines into sums of trigonometric functions with multiple angles. Specifically, it implements formulas like $\cos(a)\cos(b) = \frac{1}{2}(\cos(a-b) + \cos(a+b))$.

The output provided is `"cos(2*phi)/2 + 1/2"`.
This corresponds to the identity for cosine squared:
$$ \cos^2(\phi) = \frac{1 + \cos(2\phi)}{2} = \frac{1}{2} + \frac{\cos(2\phi)}{2} $$

Let's trace the execution of `TR8` with the proposed input `rv = cos(phi)**2`:
1.  **Call**: `TR8(cos(phi)**2, first=True)`.
2.  **`bottom_up`**: Helper traverses the expression tree. It calls the inner function `f` on the node `cos(phi)**2`.
3.  **`f` execution (first=True)**:
    *   The `first=True` block executes.
    *   It splits the expression into numerator `cos(phi)**2` and denominator `1`.
    *   It recursively calls `TR8(cos(phi)**2, first=False)`.
4.  **Recursive Call (first=False)**:
    *   `bottom_up` calls `f` on `cos(phi)**2`.
    *   The condition `rv.is_Pow` matches (base `cos`, exp `2`).
    *   It collects arguments: `args[cos]` becomes `[phi, phi]`.
    *   It enters the loop `while len(c) > 1`.
    *   It pops two `phi`s (`a1`, `a2`) and creates the term `(cos(a1+a2) + cos(a1-a2))/2`.
    *   This evaluates to `(cos(2*phi) + cos(0))/2` which is `cos(2*phi)/2 + 1/2`.
    *   The function returns this transformed expression.
5.  **Return**: The outer call receives this result, `gcd_terms` doesn't change it significantly structure-wise in this simple case, and it returns `cos(2*phi)/2 + 1/2`.

The logic holds. The input `rv` should be `"cos(phi)**2"`. The argument `first` defaults to `True` in the function signature, so `true` is the appropriate value.

[INPUT]
```
{
    "self": {},
    "args": {
        "rv": "cos(phi)**2",
        "first": true
    },
    "kwargs": {}
}
```
[/INPUT]