<<FUNCTION_NAME>>



<<CODE>>

a , b = map ( int , input ( ) . split ( ) )
if a <= 0 and 0 <= b :
    print ( "Zero" )
elif a < 0 and min ( b - a , - a ) % 2 == 0 :
    print ( "Negative" )
else :
    print ( "Positive" )



<<GROUND_TRUTH_INPUT>>

1 1000000000

<<GROUND_TRUTH_OUTPUT>>

Positive

<<LLM_RESPONSE>>

[THOUGHT]
The code takes two integers `a` and `b` as input. It then checks several conditions to determine what to print. The desired output is "Positive".

Let's break down the logic:
1.  `if a <= 0 and 0 <= b:` -> Prints "Zero".
    *   This happens if the interval $[a, b]$ contains the number 0. If `a` is non-positive and `b` is non-negative, the result is "Zero". We want "Positive", so this condition must be False.

2.  `elif a < 0 and min(b - a, -a) % 2 == 0:` -> Prints "Negative".
    *   This `elif` is only checked if the first `if` failed.
    *   If the first `if` failed, it means either `a > 0` or `b < 0`.
    *   However, this `elif` explicitly checks `a < 0`. So for this branch to be taken, we must have `a < 0`. Since the first `if` failed, if `a < 0`, then `b` must be `< 0` as well (otherwise `0 <= b` would be true, triggering the first condition).
    *   So this branch handles the case where both `a` and `b` are negative. The specific logic `min(b - a, -a) % 2 == 0` determines parity. This branch prints "Negative". We want "Positive", so this must also be False.

3.  `else:` -> Prints "Positive".
    *   This branch is taken if neither of the above conditions is met.
    *   Since the first condition covers cases where `0` is in $[a, b]$, and the second condition covers some cases where numbers are negative, the `else` block catches the remaining cases.
    *   The most straightforward way to fall into this `else` block is if `a > 0`.
    *   If `a > 0`, the first condition `a <= 0` is False.
    *   If `a > 0`, the second condition `a < 0` is False.
    *   Therefore, any input where `a > 0` and `b >= a` (assuming standard interval logic usually implies `a <= b` though the code doesn't strictly enforce it for execution, but usually in these problems `a` and `b` represent a range) will result in "Positive".
    *   Basically, if the product of the range is positive, it prints "Positive". If `a` is positive, all numbers in $[a, b]$ (assuming $a \le b$) are positive, so the product is positive.

Let's pick simple values where `a > 0`.
Let `a = 1`, `b = 5`.
1.  Check `if 1 <= 0 and 0 <= 5`: False (1 is not <= 0).
2.  Check `elif 1 < 0 ...`: False (1 is not < 0).
3.  `else`: Print "Positive".

This works. The input string needs to be two integers separated by a space.
Input: "1 5"

Let's double check another case, just to be sure. What if `a` and `b` are both negative, but the parity condition fails?
Suppose `a = -3`, `b = -1`.
1. `a <= 0` (True) and `0 <= -1` (False). Condition 1 fails.
2. `a < 0` (True). Check `min(-1 - (-3), -(-3)) % 2 == 0`.
   `min(2, 3)` is `2`. `2 % 2 == 0` is True. This prints "Negative". Not what we want.

Suppose `a = -2`, `b = -1`.
1. Condition 1 fails.
2. `a < 0` (True). Check `min(-1 - (-2), -(-2))`.
   `min(1, 2)` is `1`. `1 % 2 == 0` is False.
3. Else: Print "Positive".
So "-2 -1" is also a valid input. The problem asks for *the* input, implying any valid input works. "1 3" seems the simplest mental model.

Let's stick with `a = 1` and `b = 2`.
[/THOUGHT]

[INPUT]
```
{
    "input": "1 2"
}
```
[/INPUT]