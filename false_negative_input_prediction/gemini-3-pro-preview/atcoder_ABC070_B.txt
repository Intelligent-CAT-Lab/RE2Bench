<<FUNCTION_NAME>>



<<CODE>>

a , b , c , d = map ( int , input( ) . split ( ) )
print ( max ( 0 , min ( b , d ) - max ( a , c ) ) )



<<GROUND_TRUTH_INPUT>>

0 33 66 99

<<GROUND_TRUTH_OUTPUT>>

0

<<LLM_RESPONSE>>

The goal is to find an input `a b c d` such that `max(0, min(b, d) - max(a, c))` equals `0`.

**1. Understanding the Logic:**
The code calculates the length of the intersection of two intervals `[a, b)` and `[c, d)`.
*   `min(b, d)` is the smaller of the two end points.
*   `max(a, c)` is the larger of the two start points.
*   The intersection length is valid only if the end of the intersection is greater than the start.
*   `max(0, ...)` ensures that if the intervals don't overlap (result is negative), the length is 0.

**2. Condition for Output 0:**
We need `min(b, d) - max(a, c) <= 0`.
This implies `min(b, d) <= max(a, c)`.

Basically, the intervals `[a, b)` and `[c, d)` must not overlap, or touch only at the boundary (which counts as length 0 in this logic). Or, one of the intervals effectively has negative or zero length to begin with (e.g., `a >= b`).

**3. Constructing an Example:**
*   Let's define Interval 1: `a=1`, `b=5`. (Length 4)
*   Let's define Interval 2: `c=10`, `d=15`. (Length 5)

Let's check the math:
*   `min(b, d)` = `min(5, 15)` = 5
*   `max(a, c)` = `max(1, 10)` = 10
*   `min(b, d) - max(a, c)` = `5 - 10` = -5
*   `max(0, -5)` = 0.

This works. The input string would be "1 5 10 15".

Let's try another simple one where they just touch:
*   `a=1, b=5`
*   `c=5, d=10`
*   `min(5, 10)` = 5
*   `max(1, 5)` = 5
*   `5 - 5 = 0`
*   Input: "1 5 5 10"

Let's try one where the second interval is before the first:
*   `a=10, b=20`
*   `c=1, d=5`
*   `min(20, 5)` = 5
*   `max(10, 1)` = 10
*   `5 - 10` = -5
*   Input: "10 20 1 5"

Any of these valid sets of 4 integers works. I will use "1 5 10 15".

[INPUT]
```
{
    "input": "1 5 10 15"
}
```
[/INPUT]