<<FUNCTION_NAME>>



<<CODE>>

def GCD ( a , b ) :
    while a % b != 0 :
        a , b = b , a % b
    return b
def LCM ( a , b ) :
    return a * b // GCD ( a , b )
l = input ( ) . split ( ' ' )
x , y , a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) , int ( l [ 2 ] ) , int ( l [ 3 ] )
lcm = LCM ( x , y )
print ( b // lcm - ( a - 1 ) // lcm )



<<GROUND_TRUTH_INPUT>>

101 171 1 1000000000

<<GROUND_TRUTH_OUTPUT>>

57900

<<LLM_RESPONSE>>

[THOUGHT]
Let me trace through the code to understand what produces the output 57900.

The code calculates:
1. Reads 4 integers: x, y, a, b from input
2. Computes lcm = LCM(x, y)
3. Outputs: `b // lcm - (a - 1) // lcm`

This formula essentially counts how many multiples of `lcm` exist in the range [a, b].

For the output to be 57900, I need to find x, y, a, b such that:
`b // lcm - (a - 1) // lcm = 57900`

The simplest approach is to use lcm = 1:
- For lcm = 1, I need x = 1, y = 1 (since LCM(1,1) = 1)
- Then: `b // 1 - (a - 1) // 1 = b - (a - 1) = b - a + 1 = 57900`
- This means: `b = a + 57899`

Let me choose the simplest values: a = 1, b = 57900

Verification with x = 1, y = 1, a = 1, b = 57900:
- GCD(1,1): 1 % 1 = 0, so return 1
- LCM(1,1) = 1 × 1 // 1 = 1
- Result = 57900 // 1 - (1-1) // 1 = 57900 - 0 = 57900 ✓

This works perfectly!
[/THOUGHT]

[INPUT]
```
{
    "input": "1 1 1 57900"
}
```
[/INPUT]