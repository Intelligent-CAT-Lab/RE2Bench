<<FUNCTION_NAME>>



<<CODE>>

N , A , B = map ( int , input ( ) . split ( ) )
ans = N // ( A + B ) * A
rem = N % ( A + B )
ans += min ( rem , A )
print ( ans )



<<GROUND_TRUTH_INPUT>>

1 0 1

<<GROUND_TRUTH_OUTPUT>>

0

<<LLM_RESPONSE>>

[THOUGHT]
Let me trace through the code to find what input produces an output of 0.

The code computes:
- `ans = N // (A + B) * A`
- `rem = N % (A + B)`
- `ans += min(rem, A)`
- `print(ans)` outputs 0

Working backwards, I need `ans = 0` at the end.

Let me consider when this is possible:

**Case 1: N = 0**
- `ans = 0 // (A + B) * A = 0 * A = 0`
- `rem = 0 % (A + B) = 0`
- `ans += min(0, A) = 0 + 0 = 0` ✓

Let me verify with N = 0, A = 1, B = 1:
```
N = 0, A = 1, B = 1
ans = 0 // (1 + 1) * 1 = 0 // 2 * 1 = 0 * 1 = 0
rem = 0 % 2 = 0
ans += min(0, 1) = 0 + 0 = 0
print(0)  # outputs 0 ✓
```

This works! The simplest solution is to set N = 0 with any positive A and B values.
</THOUGHT>

[INPUT]
```
{
    "input": "0 1 1"
}
```
[/INPUT]