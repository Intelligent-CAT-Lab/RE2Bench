<<FUNCTION_NAME>>

TR8

<<CODE>>

from sympy.core.exprtools import Factors, gcd_terms, factor_terms
from sympy.core.function import expand_mul
from sympy.core.mul import Mul
from sympy.core.traversal import bottom_up
from sympy.functions.elementary.trigonometric import (
    cos, sin, tan, cot, sec, csc, sqrt, TrigonometricFunction)

def TR8(rv, first=True):
    """Converting products of ``cos`` and/or ``sin`` to a sum or
    difference of ``cos`` and or ``sin`` terms.

    Examples
    ========

    >>> from sympy.simplify.fu import TR8
    >>> from sympy import cos, sin
    >>> TR8(cos(2)*cos(3))
    cos(5)/2 + cos(1)/2
    >>> TR8(cos(2)*sin(3))
    sin(5)/2 + sin(1)/2
    >>> TR8(sin(2)*sin(3))
    -cos(5)/2 + cos(1)/2
    """

    def f(rv):
        if not (
            rv.is_Mul or
            rv.is_Pow and
            rv.base.func in (cos, sin) and
            (rv.exp.is_integer or rv.base.is_positive)):
            return rv

        if first:
            n, d = [expand_mul(i) for i in rv.as_numer_denom()]
            newn = TR8(n, first=False)
            newd = TR8(d, first=False)
            if newn != n or newd != d:
                rv = gcd_terms(newn/newd)
                if rv.is_Mul and rv.args[0].is_Rational and \
                        len(rv.args) == 2 and rv.args[1].is_Add:
                    rv = Mul(*rv.as_coeff_Mul())
            return rv

        args = {cos: [], sin: [], None: []}
        for a in Mul.make_args(rv):
            if a.func in (cos, sin):
                args[type(a)].append(a.args[0])
            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \
                    a.base.func in (cos, sin)):
                # XXX this is ok but pathological expression could be handled
                # more efficiently as in TRmorrie
                args[type(a.base)].extend([a.base.args[0]]*a.exp)
            else:
                args[None].append(a)
        c = args[cos]
        s = args[sin]
        if not (c and s or len(c) > 1 or len(s) > 1):
            return rv

        args = args[None]
        n = min(len(c), len(s))
        for i in range(n):
            a1 = s.pop()
            a2 = c.pop()
            args.append((sin(a1 + a2) + sin(a1 - a2))/2)
        while len(c) > 1:
            a1 = c.pop()
            a2 = c.pop()
            args.append((cos(a1 + a2) + cos(a1 - a2))/2)
        if c:
            args.append(cos(c.pop()))
        while len(s) > 1:
            a1 = s.pop()
            a2 = s.pop()
            args.append((-cos(a1 + a2) + cos(a1 - a2))/2)
        if s:
            args.append(sin(s.pop()))
        return TR8(expand_mul(Mul(*args)))

    return bottom_up(rv, f)


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'rv': 'cos(phi)**2', 'first': False}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

cos(2*phi)/2 + 1/2

<<LLM_RESPONSE>>

[THOUGHT]

Let me trace through the TR8 function to find what input would produce the output `"cos(2*phi)/2 + 1/2"`.

The function applies trigonometric product-to-sum transformations. The key transformation formulas are:
- `cos(a)*cos(b) = (cos(a+b) + cos(a-b))/2`
- `sin(a)*sin(b) = (-cos(a+b) + cos(a-b))/2`
- `sin(a)*cos(b) = (sin(a+b) + sin(a-b))/2`

The output `cos(2*phi)/2 + 1/2` can be rewritten as `(cos(2*phi) + 1)/2`.

This form is characteristic of the product-to-sum formula applied to `cos(phi)*cos(phi)`, or equivalently `cos(phi)**2`:

Let me trace through with input `cos(phi)**2`:

1. `TR8(cos(phi)**2, first=True)` calls `bottom_up(cos(phi)**2, f)`

2. `bottom_up` recursively processes from the bottom up and applies `f`

3. When `f(cos(phi)**2)` is called with `first=True`:
   - It's a `Mul` or matches the `Pow` condition: `rv.is_Pow and rv.base.func in (cos, sin) and rv.exp > 0`
   - Enters the `first=True` branch, expands numerator and denominator
   - Recursively calls `TR8` on them with `first=False`

4. When `f(cos(phi)**2)` is called with `first=False`:
   - Builds `args = {cos: [], sin: [], None: []}`
   - For `cos(phi)**2`: It's a `Pow` with integer exponent > 0, base is cos
   - Extends: `args[cos] = [cos(phi), cos(phi)]`
   - `c = [cos(phi), cos(phi)]`, `s = []`
   - Condition `not (c and s or len(c) > 1 or len(s) > 1)` is False (len(c) > 1)
   - Enters the while loop: `while len(c) > 1`
     - Pops two: `a1 = cos(phi)`, `a2 = cos(phi)`
     - Appends: `(cos(a1+a2) + cos(a1-a2))/2 = (cos(2*phi) + cos(0))/2 = (cos(2*phi) + 1)/2`
   - Returns `TR8(expand_mul((cos(2*phi) + 1)/2))`

5. This expands to `(cos(2*phi) + 1)/2` which displays as `cos(2*phi)/2 + 1/2`

The function returns an expression that when converted to string gives `"cos(2*phi)/2 + 1/2"`.

Therefore, the input is `cos(phi)**2` with `first=true` (default).

[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "rv": "cos(phi)**2",
        "first": true
    },
    "kwargs": {}
}
```
[/INPUT]