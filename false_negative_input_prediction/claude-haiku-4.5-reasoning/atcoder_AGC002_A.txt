<<FUNCTION_NAME>>



<<CODE>>

a , b = map ( int , input ( ) . split ( ) )
if a <= 0 and 0 <= b :
    print ( "Zero" )
elif a < 0 and min ( b - a , - a ) % 2 == 0 :
    print ( "Negative" )
else :
    print ( "Positive" )



<<GROUND_TRUTH_INPUT>>

1 1000000000

<<GROUND_TRUTH_OUTPUT>>

Positive

<<LLM_RESPONSE>>

[THOUGHT]
Let me work through this code to find what input produces "Positive" output.

The code has three branches:
1. If `a <= 0 and 0 <= b`, print "Zero"
2. Elif `a < 0 and min(b - a, -a) % 2 == 0`, print "Negative"
3. Else, print "Positive"

Since the output is "Positive", the code must reach the `else` branch, which means:
- The first condition `a <= 0 and 0 <= b` must be False
- The second condition `a < 0 and min(b - a, -a) % 2 == 0` must be False

For the first condition to be False: either `a > 0` or `b < 0`
For the second condition to be False: either `a >= 0` or `min(b - a, -a) % 2 != 0`

The simplest case would be when `a > 0` (any positive value for a). Then:
- First condition: `a <= 0 and ...` would be False (since `a > 0`)
- Second condition: `a < 0 and ...` would be False (since `a > 0`, so `a < 0` is False)
- Result: Goes to else, prints "Positive" ✓

For example, with `a = 1, b = 0`:
- First condition: `1 <= 0 and 0 <= 0` → `False and True` → `False`
- Second condition: `1 < 0 and ...` → `False and ...` → `False`
- Goes to else and prints "Positive" ✓
[/THOUGHT]

[INPUT]
```
{
    "input": "1 0"
}
```
[/INPUT]