<<FUNCTION_NAME>>

interval_contains

<<CODE>>

def interval_contains(interval, val):
    """
    Check, inclusively, whether an interval includes a given value.

    Parameters
    ----------
    interval : (float, float)
        The endpoints of the interval.
    val : float
        Value to check is within interval.

    Returns
    -------
    bool
        Whether *val* is within the *interval*.
    """
    a, b = interval
    if a > b:
        a, b = b, a
    return a <= val <= b


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'interval': 'array([-107.73502692,   -7.73502692])', 'val': -80.0}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

np.True_

<<LLM_RESPONSE>>

[THOUGHT]
1. The function returns the result of a <= val <= b (after swapping a and b if needed).
2. The observed output is "np.True_", i.e. a NumPy boolean scalar True (np.bool_).
3. To get a np.bool_ result, the comparisons should be performed on NumPy scalar values (e.g., np.int64 or 0-d np.array), since comparing plain Python ints would produce a Python bool.
4. If I choose a = np.int64(1), b = np.int64(3), and val = np.int64(2), then a <= val and val <= b both produce NumPy boolean scalars, and the chained expression yields a NumPy boolean scalar True (np.True_).
5. Therefore the input interval should be (np.int64(1), np.int64(3)) and val should be np.int64(2).

[INPUT]
```
{
    "self": {},
    "args": {
        "interval": ["np.int64(1)", "np.int64(3)"],
        "val": "np.int64(2)"
    },
    "kwargs": {}
}
```
