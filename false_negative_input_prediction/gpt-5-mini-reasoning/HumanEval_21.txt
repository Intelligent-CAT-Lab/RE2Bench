<<FUNCTION_NAME>>

rescale_to_unit

<<CODE>>

from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """

    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'numbers': [1.0, 2.0, 3.0, 4.0, 5.0]}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

[0.0, 0.25, 0.5, 0.75, 1.0]

<<LLM_RESPONSE>>

[THOUGHT]
We need a list numbers such that after applying (x - min) / (max - min) elementwise we get [0.0, 0.25, 0.5, 0.75, 1.0].

Let the list be five ascending values a0..a4 with min = a0 and max = a4. The rescaled values are (ai - a0)/(a4 - a0). To get 0.0, 0.25, 0.5, 0.75, 1.0, the numerators must be 0, 0.25*(a4-a0), 0.5*(a4-a0), 0.75*(a4-a0), (a4-a0). Choosing a4 - a0 = 4 makes those numerators 0,1,2,3,4, so a simple choice is [0.0, 1.0, 2.0, 3.0, 4.0]. min = 0.0, max = 4.0 yields rescaled values [0/4, 1/4, 2/4, 3/4, 4/4] = [0.0, 0.25, 0.5, 0.75, 1.0].

Thus the input numbers can be [0.0, 1.0, 2.0, 3.0, 4.0].
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "numbers": [0.0, 1.0, 2.0, 3.0, 4.0]
    },
    "kwargs": {}
}
```
[/INPUT]