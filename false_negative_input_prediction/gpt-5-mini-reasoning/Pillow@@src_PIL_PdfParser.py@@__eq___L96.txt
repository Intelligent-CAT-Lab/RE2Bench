<<FUNCTION_NAME>>

__eq__

<<CODE>>

class IndirectReference(IndirectReferenceTuple):

    def __eq__(self, other):
        return other.__class__ is self.__class__ and other.object_id == self.object_id and (other.generation == self.generation)


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'other': [1, 2]}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

False

<<LLM_RESPONSE>>

[THOUGHT]
The __eq__ implementation returns the conjunction of three tests:
1) other.__class__ is self.__class__
2) other.object_id == self.object_id
3) other.generation == self.generation

To make the overall result False it's sufficient to make any one of these tests false. The simplest is to make the class identity check fail by giving other a different __class__ value than self.__class__. Therefore I'll set other.__class__ to a different class marker (e.g. "NotIndirectReference") and include object_id and generation fields (their values don't matter once the first check fails). The provided "self" is left empty as in the structure.
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "other": {
            "__class__": "NotIndirectReference",
            "object_id": 123,
            "generation": 0
        }
    },
    "kwargs": {}
}
```
[/INPUT]