<<FUNCTION_NAME>>

extract

<<CODE>>

from collections import defaultdict
from .exceptions import DMBadInputError, DMDomainError, DMShapeError

class SDM(dict):
    """Sparse matrix based on polys domain elements

    This is a dict subclass and is a wrapper for a dict of dicts that supports
    basic matrix arithmetic +, -, *, **.


    In order to create a new :py:class:`~.SDM`, a dict
    of dicts mapping non-zero elements to their
    corresponding row and column in the matrix is needed.

    We also need to specify the shape and :py:class:`~.Domain`
    of our :py:class:`~.SDM` object.

    We declare a 2x2 :py:class:`~.SDM` matrix belonging
    to QQ domain as shown below.
    The 2x2 Matrix in the example is

    .. math::
           A = \\left[\\begin{array}{ccc}
                0 & \\frac{1}{2} \\\\
                0 & 0 \\end{array} \\right]


    >>> from sympy.polys.matrices.sdm import SDM
    >>> from sympy import QQ
    >>> elemsdict = {0:{1:QQ(1, 2)}}
    >>> A = SDM(elemsdict, (2, 2), QQ)
    >>> A
    {0: {1: 1/2}}

    We can manipulate :py:class:`~.SDM` the same way
    as a Matrix class

    >>> from sympy import ZZ
    >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)
    >>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)
    >>> A + B
    {0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}}

    Multiplication

    >>> A*B
    {0: {1: 8}, 1: {0: 3}}
    >>> A*ZZ(2)
    {0: {1: 4}, 1: {0: 2}}

    """
    fmt = 'sparse'
    is_DFM = False
    is_DDM = False

    def __init__(self, elemsdict, shape, domain):
        super().__init__(elemsdict)
        self.shape = self.rows, self.cols = m, n = shape
        self.domain = domain
        if not all((0 <= r < m for r in self)):
            raise DMBadInputError('Row out of range')
        if not all((0 <= c < n for row in self.values() for c in row)):
            raise DMBadInputError('Column out of range')

    def extract(self, rows, cols):
        if not (self and rows and cols):
            return self.zeros((len(rows), len(cols)), self.domain)
        m, n = self.shape
        if not -m <= min(rows) <= max(rows) < m:
            raise IndexError('Row index out of range')
        if not -n <= min(cols) <= max(cols) < n:
            raise IndexError('Column index out of range')
        rowmap = defaultdict(list)
        colmap = defaultdict(list)
        for i2, i1 in enumerate(rows):
            rowmap[i1 % m].append(i2)
        for j2, j1 in enumerate(cols):
            colmap[j1 % n].append(j2)
        rowset = set(rowmap)
        colset = set(colmap)
        sdm1 = self
        sdm2 = {}
        for i1 in rowset & sdm1.keys():
            row1 = sdm1[i1]
            row2 = {}
            for j1 in colset & row1.keys():
                row1_j1 = row1[j1]
                for j2 in colmap[j1]:
                    row2[j2] = row1_j1
            if row2:
                for i2 in rowmap[i1]:
                    sdm2[i2] = row2.copy()
        return self.new(sdm2, (len(rows), len(cols)), self.domain)

    @classmethod
    def new(cls, sdm, shape, domain):
        """

        Parameters
        ==========

        sdm: A dict of dicts for non-zero elements in SDM
        shape: tuple representing dimension of SDM
        domain: Represents :py:class:`~.Domain` of SDM

        Returns
        =======

        An :py:class:`~.SDM` object

        Examples
        ========

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> elemsdict = {0:{1: QQ(2)}}
        >>> A = SDM.new(elemsdict, (2, 2), QQ)
        >>> A
        {0: {1: 2}}

        """
        return cls(sdm, shape, domain)

    @classmethod
    def zeros(cls, shape, domain):
        """

        Returns a :py:class:`~.SDM` of size shape,
        belonging to the specified domain

        In the example below we declare a matrix A where,

        .. math::
            A := \\left[\\begin{array}{ccc}
            0 & 0 & 0 \\\\
            0 & 0 & 0 \\end{array} \\right]

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> A = SDM.zeros((2, 3), QQ)
        >>> A
        {}

        """
        return cls({}, shape, domain)


<<GROUND_TRUTH_INPUT>>

{'self': {'shape': [3, 3], 'rows': 3, 'cols': 3, 'domain': 'ZZ'}, 'args': {'rows': [0, 1, 2], 'cols': [0]}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

{'0': {'0': 1}, '1': {'0': 1}, '2': {'0': 1}}

<<LLM_RESPONSE>>

Let’s reason step-by-step.

---

We are given an output:

```json
{
    "0": { "0": 1 },
    "1": { "0": 1 },
    "2": { "0": 1 }
}
```

That means:

- Row indices in the result matrix: `0, 1, 2`
- Column index in the result matrix: `0`
- All nonzero entries are `1` at `(0,0)`, `(1,0)`, `(2,0)`.

---

The `SDM.extract(rows, cols)` logic takes:

1. `self` – original sparse matrix in dict-of-dicts format: `{row_index: {col_index: value}}`.
2. `rows` – list of row indices from original matrix to pick.
3. `cols` – list of col indices from original matrix to pick.

Result shape: `(len(rows), len(cols))`.

Here `len(rows) = 3` and `len(cols) = 1`.

---

The output suggests:

- In the **original** matrix, the extracted rows (in original indices) all had a nonzero in the same original column (call it `j_orig`).
- After extraction, `j_orig` maps to new column index `0` in `cols`.
- These original rows `i_orig` map to new row indices `0, 1, 2`.

---

Looking at the code:

Let `m, n = self.shape`.

- `rows`: list of original row indices (can be negative Python-style indexing: `i1 = rows[i2]`).
- `cols`: likewise for columns.

`rowmap` maps original row index `i1` to list of new row indices `i2` in the result.
`colmap` maps original col index `j1` to list of new col indices `j2` in the result.

Then for each `i1` in `rowset & sdm1.keys()` (original rows that exist in the matrix and are selected),  
for each `j1` in `colset & row1.keys()` (original columns that exist in this row and are selected),  
take entry `row1[j1]` and put it at `row2[j2]` for each `j2` in `colmap[j1]`.

---

For output `{0:{0:1}, 1:{0:1}, 2:{0:1}}`:

- For new row `0`: row `i2=0` comes from original row `i1` = `rows[0]`.
- For new row `1`: from `rows[1]`.
- For new row `2`: from `rows[2]`.

All have value `1` in extracted column `0` (original col `j1` = `cols[0]`).

Meaning: All original rows `rows[0], rows[1], rows[2]` must have value `1` at original column `cols[0]` in `self`.

---

So `self` SDM must be something like:

```
{ r0: { c0: 1 }, r1: { c0: 1 }, r2: { c0: 1 } }
```

Where `r0 = rows[0]`, `r1 = rows[1]`, `r2 = rows[2]`, and `c0 = cols[0]`.

---

We don’t know `rows` or `cols`. Could be nonsequential original indices, but simplest guess:  
Perhaps `rows = [0, 1, 2]` and `cols = [0]`? Then original matrix has those 3 rows and at least 1 column.

But then `self` would be `{0: {0: 1}, 1: {0: 1}, 2: {0: 1}}` and extraction just copies them with same indices in result.

They specifically give `SDM` output dict format — exactly the internal representation — so possibly input `self` is actually that same dict, and `rows = [0,1,2]`, `cols = [0]`.

---

But need to satisfy bounds:

- `m = self.shape[0]` ≥ max(rows)+1 if rows are positive. If rows has `2`, then m≥3.
- `n = self.shape[1]` ≥ max(cols)+1, so n≥1.

Choose minimal: `shape=(3,1)`.

Domain can be anything, e.g., `ZZ`.

Rows list `[0,1,2]`. Cols list `[0]`.

---

Check:  
`extract([0,1,2], [0])` from `self = {0:{0:1}, 1:{0:1}, 2:{0:1}}`, shape=(3,1), domain=ZZ.

`rowmap`: i1=0 → [0], i1=1 → [1], i1=2 → [2].  
`colmap`: j1=0 → [0].

Rowset = {0,1,2} & self.keys() = {0,1,2}. Intersection all present.

For i1=0: row1={0:1}, colset={0} ∩ row1.keys()={0} → j1=0, row1[0]=1, j2 in colmap[0]=[0] → row2={0:1}.  
Assign i2=0: sdm2[0]={0:1}.

Similarly i1=1: gives sdm2[1]={0:1}, i1=2 gives sdm2[2]={0:1}.

Matches output exactly.

---

Thus:

```
{
    "self": {
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "ZZ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
```

---

[THOUGHT]
The output SDM has rows 0,1,2 each with a single entry at column 0.  
This means the extracted slice chose all three rows and the first column of the original matrix.  
The simplest input is an original matrix with exactly those entries (1's in positions (0,0), (1,0), (2,0)), shape (3,1), domain ZZ, and extraction arguments rows=[0,1,2], cols=[0].
[/THOUGHT]

[INPUT]
{
    "self": {
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "ZZ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
[/INPUT]