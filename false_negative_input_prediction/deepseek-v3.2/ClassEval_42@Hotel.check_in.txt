<<FUNCTION_NAME>>

check_in

<<CODE>>

'''
# This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.

class Hotel:
    def __init__(self, name, rooms):
        """
        Initialize the three fields in Hotel System.
        name is the hotel name.
        available_rooms stores the remaining rooms in the hotel
        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.
        >>> hotel.name
        'peace hotel'
        >>> hotel.available_rooms
        available_rooms = {'single': 5, 'double': 3}
        >>> hotel.booked_rooms
        {'single': {'guest 1': 2, 'guest 2':1}, 'double': {'guest1': 1}}
        """
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        """
        Check if there are any rooms of the specified type available.
        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.
        :param room_type: str
        :param room_number: int, the expected number of specified type rooms to be booked
        :param name: str, guest name
        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'
                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).
                if exceeds and quantity is zero or the room_type isn't in available_room, return False.
        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})
        >>> hotel.book_room('single', 1, 'guest 1')
        'Success!'
        >>> hotel.book_room('single', 5, 'guest 1')
        4
        >>> hotel.book_room('single', 4, 'guest 1')
        'Success!'
        >>> hotel.book_room('single', 1, 'guest 1')
        False
        >>> hotel.book_room('triple', 1, 'guest 1')
        False
        """
    
    def check_in(self, room_type, room_number, name):
        """
        Check if the room of the specified type and number is booked by the person named name.
        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity
        :param room_type: str, check in room type
        :param room_number: int, check in room number
        :param name: str, person name
        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.
        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})
        >>> hotel.book_room('single', 1, 'guest 1')
        'Success!'
        >>> hotel.check_in('single', 2, 'guest 1')
        False
        >>> hotel.check_in('single', 1, 'guest 1')
        >>> hotel.booked_rooms
        {'single': {}}
        """

    def check_out(self, room_type, room_number):
        """
        Check out rooms, add number for specific type in available_rooms.
        If room_type is new, add new type in available_rooms.
        :param room_type: str, check out room type
        :param room_number: int, check out room number
        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})
        >>> hotel.check_out('single', 2)
        >>> hotel.available_rooms
        {'single': 7, 'double': 3}
        >>> hotel.check_out('triple', 2)
        >>> hotel.available_rooms
        {'single': 7, 'double': 3, 'triple': 2}
        """

    def get_available_rooms(self, room_type):
        """
        Get the number of specific type of available rooms.
        :param room_type: str, the room type that want to know
        :return: int, the remaining number of this type rooms.
        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})
        >>> hotel.get_available_rooms('single')
        5
        """

'''

class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return "Success!"
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]


<<GROUND_TRUTH_INPUT>>

{'self': {'name': 'Test Hotel', 'available_rooms': {'single': 1, 'double': 2}, 'booked_rooms': {'single': {}}}, 'args': {'room_type': 'single', 'room_number': 2, 'name': 'guest 1'}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

None

<<LLM_RESPONSE>>

Let's go step by step.  

First, look at the code:  

The `check_in` method:  
- Returns `False` if `room_type` not in `self.booked_rooms.keys()`.
- If `name` is in `self.booked_rooms[room_type]`, it checks `room_number`:
  1. If `room_number > self.booked_rooms[room_type][name]` → returns `False`.
  2. If `room_number == self.booked_rooms[room_type][name]` → removes `name` from dict.
  3. Otherwise (`room_number < booked`) → decrements count.
- If `name` is not in `self.booked_rooms[room_type]`, the method continues (but may do nothing visible in this code except returning `False` earlier — but wait, actually reading carefully, the only return `False` is in the two early checks; otherwise, no explicit return, so Python returns `None`).
- The output given is `null` → in Python, this corresponds to `None`.

Thus, for the output to be `None`, the method must **not** return `False`.  
So:  
1. `room_type` must be in `self.booked_rooms.keys()`. Given structure, `booked_rooms` has `"single": {}`.  
   So `room_type` could be `"single"`.  
2. `name` must be in `self.booked_rooms["single"]`, else no return `False` occurs, but then no logic after `if name in …` runs, so function ends and returns `None`. That's fine. But to make sure output is `None`, we just avoid returning `False`.

Also note `available_rooms` is given in structure but not used in `check_in`.

Possible input: `"single"` as room_type, `name` present in `booked_rooms["single"]`, and `room_number` equals to or less than booked count, but not greater.  

From structure: `"booked_rooms": { "single": {} }` is empty dict at start.  
That means if `name` is not in it, the condition `if name in self.booked_rooms[room_type]` will be false, so no return, function ends → returns `None`.  
So simplest way is: room_type `"single"` (present in booked_rooms), name not in dict (so empty dict case works).

Let’s pick:  
- `room_type`: `"single"`  
- `room_number`: `1`  
- `name`: `"Alice"` (since not in booked_rooms)  
That results in output `None`.

Check: `room_type` in booked_rooms → yes.  
`if name in self.booked_rooms[room_type]` → `"Alice" in {}` → `False`, so skip block.  
Method ends → return `None` → matches output.

[THOUGHT]
Given structure: booked_rooms["single"] is empty at start.
For output to be None, we must avoid returning False.
False occurs if room_type not in booked_rooms (but "single" is in it) OR if name in booked_rooms[room_type] AND room_number > booked count (which cannot happen if name not in dict).
Simplest: choose name not in booked_rooms dict, so condition fails, block skipped, returns None.
Pick: room_type="single", room_number=1, name="Alice" (any not in {}).
Self data from structure: name and available_rooms can be arbitrary, booked_rooms as given.

[/THOUGHT]

[INPUT]
```
{
    "self": {
        "name": "Grand Hotel",
        "available_rooms": {
            "single": 10,
            "double": 5
        },
        "booked_rooms": {
            "single": {}
        }
    },
    "args": {
        "room_type": "single",
        "room_number": 1,
        "name": "Alice"
    },
    "kwargs": {}
}
```
[/INPUT]