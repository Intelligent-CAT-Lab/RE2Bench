<<FUNCTION_NAME>>

add_repr

<<CODE>>

import contextlib
import inspect
from collections.abc import Callable, Mapping
from typing import Any, NamedTuple, TypeVar
from . import _compat, _config, setters

class _ClassBuilder:
    """
    Iteratively build *one* class.
    """
    __slots__ = ('_add_method_dunders', '_attr_names', '_attrs', '_base_attr_map', '_base_names', '_cache_hash', '_cls', '_cls_dict', '_delete_attribs', '_frozen', '_has_custom_setattr', '_has_post_init', '_has_pre_init', '_is_exc', '_on_setattr', '_pre_init_has_args', '_repr_added', '_script_snippets', '_slots', '_weakref_slot', '_wrote_own_setattr')

    def __init__(self, cls: type, these, auto_attribs: bool, props: ClassProps, has_custom_setattr: bool):
        attrs, base_attrs, base_map = _transform_attrs(cls, these, auto_attribs, props.kw_only, props.collected_fields_by_mro, props.field_transformer)
        self._cls = cls
        self._cls_dict = dict(cls.__dict__) if props.is_slotted else {}
        self._attrs = attrs
        self._base_names = {a.name for a in base_attrs}
        self._base_attr_map = base_map
        self._attr_names = tuple((a.name for a in attrs))
        self._slots = props.is_slotted
        self._frozen = props.is_frozen
        self._weakref_slot = props.has_weakref_slot
        self._cache_hash = props.hashability is ClassProps.Hashability.HASHABLE_CACHED
        self._has_pre_init = bool(getattr(cls, '__attrs_pre_init__', False))
        self._pre_init_has_args = False
        if self._has_pre_init:
            pre_init_func = cls.__attrs_pre_init__
            pre_init_signature = inspect.signature(pre_init_func)
            self._pre_init_has_args = len(pre_init_signature.parameters) > 1
        self._has_post_init = bool(getattr(cls, '__attrs_post_init__', False))
        self._delete_attribs = not bool(these)
        self._is_exc = props.is_exception
        self._on_setattr = props.on_setattr_hook
        self._has_custom_setattr = has_custom_setattr
        self._wrote_own_setattr = False
        self._cls_dict['__attrs_attrs__'] = self._attrs
        self._cls_dict['__attrs_props__'] = props
        if props.is_frozen:
            self._cls_dict['__setattr__'] = _frozen_setattrs
            self._cls_dict['__delattr__'] = _frozen_delattrs
            self._wrote_own_setattr = True
        elif self._on_setattr in (_DEFAULT_ON_SETATTR, setters.validate, setters.convert):
            has_validator = has_converter = False
            for a in attrs:
                if a.validator is not None:
                    has_validator = True
                if a.converter is not None:
                    has_converter = True
                if has_validator and has_converter:
                    break
            if self._on_setattr == _DEFAULT_ON_SETATTR and (not (has_validator or has_converter)) or (self._on_setattr == setters.validate and (not has_validator)) or (self._on_setattr == setters.convert and (not has_converter)):
                self._on_setattr = None
        if props.added_pickling:
            self._cls_dict['__getstate__'], self._cls_dict['__setstate__'] = self._make_getstate_setstate()
        self._script_snippets: list[tuple[str, dict, Callable[[dict, dict], Any]]] = []
        self._repr_added = False
        if not hasattr(self._cls, '__module__') or not hasattr(self._cls, '__qualname__'):
            self._add_method_dunders = self._add_method_dunders_safe
        else:
            self._add_method_dunders = self._add_method_dunders_unsafe

    def add_repr(self, ns):
        script, globs = _make_repr_script(self._attrs, ns)

        def _attach_repr(cls_dict, globs):
            cls_dict['__repr__'] = self._add_method_dunders(globs['__repr__'])
        self._script_snippets.append((script, globs, _attach_repr))
        self._repr_added = True
        return self

    def _make_getstate_setstate(self):
        """
        Create custom __setstate__ and __getstate__ methods.
        """
        state_attr_names = tuple((an for an in self._attr_names if an != '__weakref__'))

        def slots_getstate(self):
            """
            Automatically created by attrs.
            """
            return {name: getattr(self, name) for name in state_attr_names}
        hash_caching_enabled = self._cache_hash

        def slots_setstate(self, state):
            """
            Automatically created by attrs.
            """
            __bound_setattr = _OBJ_SETATTR.__get__(self)
            if isinstance(state, tuple):
                for name, value in zip(state_attr_names, state):
                    __bound_setattr(name, value)
            else:
                for name in state_attr_names:
                    if name in state:
                        __bound_setattr(name, state[name])
            if hash_caching_enabled:
                __bound_setattr(_HASH_CACHE_FIELD, None)
        return (slots_getstate, slots_setstate)

    def _add_method_dunders_unsafe(self, method: Callable) -> Callable:
        """
        Add __module__ and __qualname__ to a *method*.
        """
        method.__module__ = self._cls.__module__
        method.__qualname__ = f'{self._cls.__qualname__}.{method.__name__}'
        method.__doc__ = f'Method generated by attrs for class {self._cls.__qualname__}.'
        return method

    def _add_method_dunders_safe(self, method: Callable) -> Callable:
        """
        Add __module__ and __qualname__ to a *method* if possible.
        """
        with contextlib.suppress(AttributeError):
            method.__module__ = self._cls.__module__
        with contextlib.suppress(AttributeError):
            method.__qualname__ = f'{self._cls.__qualname__}.{method.__name__}'
        with contextlib.suppress(AttributeError):
            method.__doc__ = f'Method generated by attrs for class {self._cls.__qualname__}.'
        return method


<<GROUND_TRUTH_INPUT>>

{'self': '<_ClassBuilder(cls=Concrete)>', 'args': {'ns': None}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

<_ClassBuilder(cls=Concrete)>

<<LLM_RESPONSE>>

Let’s reason this through step by step.  

We have the `add_repr` method, which takes `self` (a `_ClassBuilder` instance) and `ns` (a namespace string or `None`).  

The output says:  
`"output": "<_ClassBuilder(cls=Concrete)>"`  

That looks like a `repr` of a `_ClassBuilder` instance, specifically showing `cls=Concrete`.  
The `__repr__` in `_ClassBuilder` is likely generated by `add_repr`.  

Inside `add_repr`, the code eventually creates a `__repr__` function using `_make_repr_script`.  
In `_make_repr_script`, if `ns` is `None`, it uses:  
`cls_name_fragment = '{self.__class__.__qualname__.rsplit(">.", 1)[-1]}'`  
But here the output shows `_ClassBuilder(cls=Concrete)`, meaning:  
- The class being printed is `_ClassBuilder` (so `self.__class__.__qualname__` is `_ClassBuilder`).  
- The attribute `cls` is inside `self` (it’s `self._cls`), and its `__name__` is `Concrete`.  

So in the generated `__repr__`, `cls` is one of the attributes included in the repr.  

From `_make_repr_script`, we know attributes are included only if `a.repr` is not `False`.  
Given that `cls` appears in the repr, `self._attrs` must contain an attribute named `cls` with `repr=True`.  

But wait — `_ClassBuilder`’s `__init__` has `self._cls = cls`. That’s not an `attrs` attribute (it’s not in `self._attrs`).  
Actually, `_ClassBuilder`’s `__slots__` includes `_cls`, but it’s not part of `self._attrs`. So `self._attrs` here must refer to the `cls` parameter being the class being built (not `_ClassBuilder`’s own attrs).  

That means the `self` in `add_repr` is a `_ClassBuilder` instance where `self._cls`’s `__name__` is `Concrete`.  
But the output is the `repr` of that `_ClassBuilder` instance, not of `Concrete`.  
So maybe the `repr` is being generated for `_ClassBuilder` itself, not for `self._cls`.  
But `add_repr` generates a repr for the class `self._cls`, not for `self`.  

But the output says `<_ClassBuilder(cls=Concrete)>` — that’s a `repr` of `self` (`_ClassBuilder` instance).  
So maybe the function `add_repr` returns `self` (for chaining), and the caller prints it, which triggers `_ClassBuilder`’s own `__repr__`.  

Thus, to get `<_ClassBuilder(cls=Concrete)>`, `self` must have a `_cls` attribute with value `Concrete` class.  

And `ns` — since the repr shows just `_ClassBuilder`, not `some.module._ClassBuilder`, likely `ns=None`.  

Let’s check:  
If `ns` is `None`, `cls_name_fragment` uses `self.__class__.__qualname__.rsplit(">.", 1)[-1]`.  
Here `self.__class__` is `_ClassBuilder`, so that yields `_ClassBuilder`.  

Thus, `ns` is `None`.  

Therefore:  

- `self` is a `_ClassBuilder` instance with `_cls = Concrete` class.  
- `ns = None`.  

Given the structure, `self` must be filled as an instance, but since it’s complex, we just need to satisfy the condition that `self._cls.__name__ == 'Concrete'`.  

So:  

```json
{
    "self": {
        "_cls": {
            "__name__": "Concrete"
        }
    },
    "args": {
        "ns": null
    },
    "kwargs": {}
}
```

But that’s not a complete `_ClassBuilder` instance. However, for reproducing the output, this minimal representation works.  

Actually, `self` must be a `_ClassBuilder` object, so it must have `_attrs` that includes an attribute named `cls` with `repr=True`.  

So maybe the `_attrs` list contains an attribute `Attribute(name='cls', repr=True, init=...)`.  

Thus `self._cls` is stored in `self._attrs` as `cls`, and in repr it prints as `cls=Concrete`.  

But in the `_make_repr_script`, `attr_names_with_reprs` is built from `attrs` passed to it — which is `self._attrs`.  

So `self._attrs` must have an attribute named `cls` with `repr=True`.  

Hence `self` is something like:  

```python
self = _ClassBuilder(
    cls=Concrete,
    # ... other init args,
)
```
But in `_ClassBuilder.__init__`, `cls` is stored as `self._cls`, not as an attrs attribute.  

Unless `_ClassBuilder` itself is an attrs class? It doesn’t look like it from given code — `__slots__` is defined, but not `__attrs_attrs__`. Wait, the given code shows `_ClassBuilder` has `__attrs_attrs__` and `__attrs_props__` added in `__init__` — but those are for the class being built (`self._cls`), not for `_ClassBuilder` itself.  

So `self` (`_ClassBuilder` instance) is not an attrs class. Then how does its `repr` look like `_ClassBuilder(cls=Concrete)`?  

Maybe the output is not from `_ClassBuilder`’s `repr`, but from `Concrete`’s `repr`?  
But the output says `<_ClassBuilder(cls=Concrete)>`, not `<Concrete(...)>`.  

So it’s the repr of `_ClassBuilder` itself. But `_ClassBuilder` doesn’t have a custom repr in given code — unless one was added via `add_repr` earlier? But `add_repr` is called on `self`, which is `_ClassBuilder`, but `add_repr` is meant for the class being built (`self._cls`).  

Hmm — maybe the snippet is from inside `add_repr` and the output is from the `repr` of `self` after adding `__repr__` to `self._cls`, and the caller prints `self`?  

Given the structure asks for input of `add_repr`, we need `self` = `_ClassBuilder` instance, `ns` = `None`.  

Let’s pick the minimal that fits output:  

`self._cls.__name__ = "Concrete"` and `ns = None`.  

Actually, `self` must have `_attrs` with at least one attribute named `cls` with `repr=True`.  

Thus:  

```json
{
    "self": {
        "_cls": {
            "__name__": "Concrete"
        },
        "_attrs": [
            {"name": "cls", "repr": true, "init": true}
        ]
    },
    "args": {
        "ns": null
    },
    "kwargs": {}
}
```

But `_attrs` is a tuple of `Attribute` objects. We can simplify as a list of dicts.  

---

Given the `_make_repr_script` logic, if `attrs` has one attribute `cls` with `repr=True` and `init=True`, then `attr_names_with_reprs` will contain `("cls", repr, True)`, so `accessor` = `"self.cls"` (since `i` is true), and `repr` uses `cls={self.cls!r}`, and `self.cls` is the `Concrete` class, so `repr(Concrete)` yields `<class '...Concrete'>` or just `Concrete` if it’s a class object’s repr? Wait, `self.cls` is a class, so `repr(self.cls)` gives `<class '__main__.Concrete'>`. That’s not matching `cls=Concrete`.  

But the output shows `cls=Concrete`, not `cls=<class '...'>`. So `repr` must be custom — maybe `a.repr` is a custom callable that returns just `cls.__name__`.  

So:  
`{"name": "cls", "repr": custom_func, "init": true}` where `custom_func` returns `cls.__name__`.  

Thus:  

```json
{
    "self": {
        "_cls": {
            "__name__": "Concrete"
        },
        "_attrs": [
            {"name": "cls", "repr": "<custom callable>", "init": true}
        ]
    },
    "args": {
        "ns": null
    },
    "kwargs": {}
}
```

But since we can’t embed a callable in JSON, we just indicate it’s a custom repr.  

Given the problem only needs to fill `XXX`, I’ll keep it simple:  

- `self`: a `_ClassBuilder` instance with `_cls.__name__ = "Concrete"` and `_attrs` containing attribute `"cls"` with `repr` not `False`.  
- `ns`: `null`.  

So final answer:  

[THOUGHT]  
1. Output `<_ClassBuilder(cls=Concrete)>` is the repr of a `_ClassBuilder` instance.  
2. That repr includes `cls=Concrete`, meaning `self._cls` is a class named `Concrete`.  
3. The repr is generated by `add_repr`, but `add_repr` creates repr for the class being built (`self._cls`), not for `_ClassBuilder`. But the output shows `_ClassBuilder`'s repr, so `self`'s class must have a custom `__repr__` already from `add_repr` in a previous call? Actually, the output could be from printing the `_ClassBuilder` object returned by `add_repr`.  
4. To get `cls=Concrete` in repr, `self._attrs` must contain an attribute named `cls` with `repr=True`.  
5. `ns` is `None` because the class name in output is just `_ClassBuilder` without module prefix.  
[/THOUGHT]  

[INPUT]  
```
{
    "self": {
        "_cls": {
            "__name__": "Concrete"
        },
        "_attrs": [
            {"name": "cls", "repr": true, "init": true}
        ]
    },
    "args": {
        "ns": null
    },
    "kwargs": {}
}
```
[/INPUT]