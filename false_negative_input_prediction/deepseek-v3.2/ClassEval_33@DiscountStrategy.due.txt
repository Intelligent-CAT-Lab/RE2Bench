<<FUNCTION_NAME>>

due

<<CODE>>

'''
# This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.

class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        """
        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.
        :param customer: dict, customer information
        :param cart: list of dicts, a cart of items with details
        :param promotion: function, optional promotion applied to the order
        >>> customer = {'name': 'John Doe', 'fidelity': 1200}
        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]
        >>> DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)

        """
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.total()

    def total(self):
        """
        Calculate the total cost of items in the cart.
        :return: float, total cost of items
        >>> customer = {'name': 'John Doe', 'fidelity': 1200}
        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]
        >>> ds = DiscountStrategy(customer, cart)
        >>> ds.total()
        329.0

        """


    def due(self):
        """
        Calculate the final amount to be paid after applying the discount.
        :return: float, final amount to be paid
        >>> customer = {'name': 'John Doe', 'fidelity': 1200}
        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]
        >>> ds = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)
        >>> ds.due()
        312.55

        """


    @staticmethod
    def FidelityPromo(order):
        """
        Calculate the discount based on the fidelity points of the customer.Customers with over 1000 points can enjoy a 5% discount on the entire order.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        >>> customer = {'name': 'John Doe', 'fidelity': 1200}
        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]
        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)
        >>> DiscountStrategy.FidelityPromo(order)
        16.45

        """


    @staticmethod
    def BulkItemPromo(order):
        """
        Calculate the discount based on bulk item quantity in the order.In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        >>> customer = {'name': 'John Doe', 'fidelity': 1200}
        >>> cart = [{'product': 'product', 'quantity': 20, 'price': 23.5}]
        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.BulkItemPromo)
        >>> DiscountStrategy.BulkItemPromo(order)
        47.0

        """


    @staticmethod
    def LargeOrderPromo(order):
        """
        Calculate the discount based on the number of different products in the order.If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        >>> customer = {'name': 'John Doe', 'fidelity': 1200}
        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]
        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.LargeOrderPromo)
        >>> DiscountStrategy.LargeOrderPromo(order)
        0.0

        """

'''


class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0




<<GROUND_TRUTH_INPUT>>

{'self': {'customer': {'name': 'John Doe', 'fidelity': 1200}, 'cart': [{'product': 'product0', 'quantity': 1, 'price': 10.0}, {'product': 'product1', 'quantity': 1, 'price': 10.0}, {'product': 'product2', 'quantity': 1, 'price': 10.0}, {'product': 'product3', 'quantity': 1, 'price': 10.0}, {'product': 'product4', 'quantity': 1, 'price': 10.0}, {'product': 'product5', 'quantity': 1, 'price': 10.0}, {'product': 'product6', 'quantity': 1, 'price': 10.0}, {'product': 'product7', 'quantity': 1, 'price': 10.0}, {'product': 'product8', 'quantity': 1, 'price': 10.0}, {'product': 'product9', 'quantity': 1, 'price': 10.0}, {'product': 'product10', 'quantity': 1, 'price': 10.0}, {'product': 'product11', 'quantity': 1, 'price': 10.0}, {'product': 'product12', 'quantity': 1, 'price': 10.0}, {'product': 'product13', 'quantity': 1, 'price': 10.0}, {'product': 'product14', 'quantity': 1, 'price': 10.0}], 'promotion': '<function inspect_code.<locals>.wrapper at 0x74bd8c9b5d30>', '_DiscountStrategy__total': 150.0}, 'args': {}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

139.5

<<LLM_RESPONSE>>

Let’s reason step by step.  

We know the `due` method returns `self.__total - discount`.  
From the class, `self.__total` is set in `__init__` as `self.total()`, but we aren't given the `total` method’s code — however, the structure shows `_DiscountStrategy__total` (which is the mangled name of `__total`) is part of the self we must provide.  

We are given output = 139.5, so:  

\[
139.5 = \text{__total} - \text{discount}
\]  

If `promotion` is `None`, `discount = 0` ⇒ `__total = 139.5`.  
But if `promotion` is a callable returning some discount, then `__total` could be larger.  

However, the input `self` we are to provide already has `_DiscountStrategy__total` fixed, so the `due` method will compute with those values.  

We need a consistent story:  

- `customer` is a dict with `name` and `fidelity`.  
- `cart` is likely a list of items (e.g., (`item_name`, quantity, price)).  
- `promotion` is a function that takes `self` and returns discount amount.  

But without knowing the promotion function logic, how do we choose?  
We can pick a simple case: suppose `promotion` is `None`, then `due = __total`.  
Then `__total = 139.5`.  

The problem may expect the simplest case: promotion = None, total = 139.5.  
Cart could be anything totaling 139.5 before discount, and customer arbitrary.  

But let’s see if there is a typical example. In many shopping cart examples, promotions can be:  
- fidelity discount (e.g., 5% if fidelity points > 1000)  
- bulk item discount  
- etc.  

Since output is 139.5, maybe total = 150, discount = 10.5 (7%?), but easier: total = 139.5, discount = 0.  

Given no promotion function is given in Python snippet, maybe they expect `promotion: null`.  

Thus input could be:  

- customer: `{"name": "John", "fidelity": 0}`  
- cart: `[("item1", 1, 139.5)]`  
- promotion: `null`  
- __total: `139.5`  

But total is calculated from cart in `__init__` by calling `self.total()`, so __total must match cart total. We must choose cart so its total is 139.5.  

Let’s assume `self.total()` sums quantity × price. Choose one item: `("book", 1, 139.5)`.  

We can test consistency: if we set promotion to None, due = total = 139.5 ✅.  

So minimal answer.  

I’ll write that.  

[THOUGHT]
Output 139.5 is the due amount. If promotion is None, then discount=0, so __total = 139.5. The __total comes from self.total() which sums cart items (quantity * price). To match, pick cart with one item of price 139.5. Customer details don't affect due when promotion is None, so pick default customer. Promotion None is simplest fit. So: customer = {"name": "test", "fidelity": 0}, cart = [("item", 1, 139.5)], promotion = null, __total = 139.5.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "customer": {
            "name": "test",
            "fidelity": 0
        },
        "cart": [["item", 1, 139.5]],
        "promotion": null,
        "_DiscountStrategy__total": 139.5
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]