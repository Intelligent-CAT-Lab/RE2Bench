<<FUNCTION_NAME>>

change_order_status

<<CODE>>

'''
# The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.

class Warehouse:
    def __init__(self):
        """
        Initialize two fields.
        self.inventory is a dict that stores the products.
        self.inventory = {Product ID: Product}
        self.orders is a dict that stores the products in a order.
        self.orders = {Order ID: Order}
        """
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        """
        Add product to inventory and plus the quantity if it has existed in inventory.
        Or just add new product to dict otherwise.
        :param product_id: int
        :param name: str, product name
        :param quantity: int, product quantity
        >>> warehouse.add_product(1, "product1", 3)
        >>> warehouse.inventory
        {1: {'name': 'product1', 'quantity': 3}}
        """

    def update_product_quantity(self, product_id, quantity):
        """
        According to product_id, add the quantity to the corresponding product in inventory.
        >>> warehouse.add_product(1, "product1", 3)
        >>> warehouse.update_product_quantity(1, -1)
        >>> warehouse.inventory
        {1: {'name': 'product1', 'quantity': 2}}
        """

    def get_product_quantity(self, product_id):
        """
        Get the quantity of specific product by product_id.
        :param product_id, int
        :return: if the product_id is in inventory then return the corresponding quantity,
                or False otherwise.
        >>> warehouse.add_product(1, "product1", 3)
        >>> warehouse.get_product_quantity(1)
        3
        >>> warehouse.get_product_quantity(2)
        False
        """

    def create_order(self, order_id, product_id, quantity):
        """
        Create a order which includes the infomation of product, like id and quantity.
        And put the new order into self.orders.
        The default value of status is 'Shipped'.
        :param order_id: int
        :param product_id: int
        :param quantity: the quantity of product that be selected.
        :return False: only if product_id is not in inventory or the quantity is not adequate
        >>> warehouse.add_product(1, "product1", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.orders
        {1: {'product_id': 1, 'quantity': 2, 'status': 'Shipped'}}
        >>> warehouse.create_order(1, 2, 2)
        False
        """

    def change_order_status(self, order_id, status):
        """
        Change the status of order if the input order_id is in self.orders.
        :param order_id: int
        :param status: str, the state that is going to change to
        :return False: only if the order_id is not in self.orders
        >>> warehouse.add_product(1, "product1", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.change_order_status(1, "done")
        >>> warehouse.orders
        {1: {'product_id': 1, 'quantity': 2, 'status': 'done'}}
        """

    def track_order(self, order_id):
        """
        Get the status of specific order.
        :param order_id: int
        :return False: only if the order_id is not in self.orders.
        >>> warehouse.add_product(1, "product1", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.track_order(1)
        'Shipped'
        """
'''

class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False


<<GROUND_TRUTH_INPUT>>

{'self': {'inventory': {'1': {'name': 'product 1', 'quantity': 5}}, 'orders': {'1': {'product_id': 1, 'quantity': 5, 'status': 'Delivered'}}}, 'args': {'order_id': 1, 'status': 'Delivered'}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

None

<<LLM_RESPONSE>>

We need to reason about the input to `change_order_status` given the code and output.

**Step 1: Understanding the code**
- `Warehouse` has `inventory` and `orders` as dicts.
- `change_order_status(order_id, status)`:
  1. Checks if `order_id` is in `self.orders`.
  2. If yes: updates `self.orders[order_id]['status']` to `status`, returns nothing (so output `null` in JSON).
  3. If no: returns `False`.

**Step 2: Interpreting the output**
The output is `null`, meaning the method succeeded in updating an order status (returned nothing), not `False`.  
So `order_id` **must exist** in `self.orders`.

**Step 3: Matching the structure**
We need to fill in:
- `self.inventory` with given keys "1": {name, quantity} — but this doesn’t affect our method call.
- `self.orders` with key "1": {product_id, quantity, status}.
- `args`: order_id, status.

**Step 4: Choosing example values**
We can choose plausible values:
- `order_id` must be `"1"` to match `self.orders` key.
- The status in `self.orders["1"]["status"]` before call can be anything (e.g., `"pending"`).
- The `status` argument in args is the new status (e.g., `"shipped"`).

The `inventory` and `orders` product_id/quantity fields don’t matter for the logic, just need placeholders.

**Step 5: Filling placeholders**
Let’s set:
- `self.inventory["1"]["name"] = "item1"`
- `self.inventory["1"]["quantity"] = 10`
- `self.orders["1"]["product_id"] = "1"`
- `self.orders["1"]["quantity"] = 2`
- `self.orders["1"]["status"] = "pending"` (original status)
- `args["order_id"] = "1"`
- `args["status"] = "shipped"`

Then calling `change_order_status("1", "shipped")` updates status in `self.orders["1"]` to `"shipped"`, returns `None` → `null` output.

[THOUGHT]
Given output is null, means order_id exists in self.orders.  
We can set order_id="1" to match structure example key "1".  
Inventory fields are arbitrary; orders entry must exist with some original status.  
Changing status to new value updates it, returns None → null output.  
So fill structure with example data: inventory name "item1", quantity 10; orders product_id "1", quantity 2, initial status "pending"; args order_id "1", new status "shipped".
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "inventory": {
            "1": {
                "name": "item1",
                "quantity": 10
            }
        },
        "orders": {
            "1": {
                "product_id": "1",
                "quantity": 2,
                "status": "pending"
            }
        }
    },
    "args": {
        "order_id": "1",
        "status": "shipped"
    },
    "kwargs": {}
}
```
[/INPUT]