<<FUNCTION_NAME>>

extract

<<CODE>>

from collections import defaultdict
from .exceptions import DMBadInputError, DMDomainError, DMShapeError

class SDM(dict):
    """Sparse matrix based on polys domain elements

    This is a dict subclass and is a wrapper for a dict of dicts that supports
    basic matrix arithmetic +, -, *, **.


    In order to create a new :py:class:`~.SDM`, a dict
    of dicts mapping non-zero elements to their
    corresponding row and column in the matrix is needed.

    We also need to specify the shape and :py:class:`~.Domain`
    of our :py:class:`~.SDM` object.

    We declare a 2x2 :py:class:`~.SDM` matrix belonging
    to QQ domain as shown below.
    The 2x2 Matrix in the example is

    .. math::
           A = \\left[\\begin{array}{ccc}
                0 & \\frac{1}{2} \\\\
                0 & 0 \\end{array} \\right]


    >>> from sympy.polys.matrices.sdm import SDM
    >>> from sympy import QQ
    >>> elemsdict = {0:{1:QQ(1, 2)}}
    >>> A = SDM(elemsdict, (2, 2), QQ)
    >>> A
    {0: {1: 1/2}}

    We can manipulate :py:class:`~.SDM` the same way
    as a Matrix class

    >>> from sympy import ZZ
    >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)
    >>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)
    >>> A + B
    {0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}}

    Multiplication

    >>> A*B
    {0: {1: 8}, 1: {0: 3}}
    >>> A*ZZ(2)
    {0: {1: 4}, 1: {0: 2}}

    """
    fmt = 'sparse'
    is_DFM = False
    is_DDM = False

    def __init__(self, elemsdict, shape, domain):
        super().__init__(elemsdict)
        self.shape = self.rows, self.cols = m, n = shape
        self.domain = domain
        if not all((0 <= r < m for r in self)):
            raise DMBadInputError('Row out of range')
        if not all((0 <= c < n for row in self.values() for c in row)):
            raise DMBadInputError('Column out of range')

    def extract(self, rows, cols):
        if not (self and rows and cols):
            return self.zeros((len(rows), len(cols)), self.domain)
        m, n = self.shape
        if not -m <= min(rows) <= max(rows) < m:
            raise IndexError('Row index out of range')
        if not -n <= min(cols) <= max(cols) < n:
            raise IndexError('Column index out of range')
        rowmap = defaultdict(list)
        colmap = defaultdict(list)
        for i2, i1 in enumerate(rows):
            rowmap[i1 % m].append(i2)
        for j2, j1 in enumerate(cols):
            colmap[j1 % n].append(j2)
        rowset = set(rowmap)
        colset = set(colmap)
        sdm1 = self
        sdm2 = {}
        for i1 in rowset & sdm1.keys():
            row1 = sdm1[i1]
            row2 = {}
            for j1 in colset & row1.keys():
                row1_j1 = row1[j1]
                for j2 in colmap[j1]:
                    row2[j2] = row1_j1
            if row2:
                for i2 in rowmap[i1]:
                    sdm2[i2] = row2.copy()
        return self.new(sdm2, (len(rows), len(cols)), self.domain)

    @classmethod
    def new(cls, sdm, shape, domain):
        """

        Parameters
        ==========

        sdm: A dict of dicts for non-zero elements in SDM
        shape: tuple representing dimension of SDM
        domain: Represents :py:class:`~.Domain` of SDM

        Returns
        =======

        An :py:class:`~.SDM` object

        Examples
        ========

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> elemsdict = {0:{1: QQ(2)}}
        >>> A = SDM.new(elemsdict, (2, 2), QQ)
        >>> A
        {0: {1: 2}}

        """
        return cls(sdm, shape, domain)

    @classmethod
    def zeros(cls, shape, domain):
        """

        Returns a :py:class:`~.SDM` of size shape,
        belonging to the specified domain

        In the example below we declare a matrix A where,

        .. math::
            A := \\left[\\begin{array}{ccc}
            0 & 0 & 0 \\\\
            0 & 0 & 0 \\end{array} \\right]

        >>> from sympy.polys.matrices.sdm import SDM
        >>> from sympy import QQ
        >>> A = SDM.zeros((2, 3), QQ)
        >>> A
        {}

        """
        return cls({}, shape, domain)


<<GROUND_TRUTH_INPUT>>

{'self': {'shape': [3, 3], 'rows': 3, 'cols': 3, 'domain': 'ZZ'}, 'args': {'rows': [0, 1, 2], 'cols': [0]}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

{'0': {'0': 1}, '1': {'0': 1}, '2': {'0': 1}}

<<LLM_RESPONSE>>

[THOUGHT]
Let me analyze the output and work backwards through the `extract` method.

The output is:
```
{
    "0": {
        "0": 1
    },
    "1": {
        "0": 1
    },
    "2": {
        "0": 1
    }
}
```

This is a sparse dictionary matrix (SDM) with 3 rows and 1 column, where all elements are 1.

Looking at the `extract` method:
1. It takes rows and cols as parameters
2. It creates rowmap and colmap to map original indices to new indices
3. It iterates through the intersection of rowset and sdm1.keys()
4. For each element in the result, it creates new row entries

The output shows the result has shape (3, 1) since there are rows 0, 1, 2 and each has column 0.

For the output to have exactly these rows (0, 1, 2) and column (0), the `rows` parameter passed to extract must have been a sequence with 3 elements that maps to rows 0, 1, 2 of the original matrix, and `cols` must map to column 0.

The simplest case would be:
- rows = [0, 1, 2] (or some equivalent indexing that results in these 3 rows)
- cols = [0] (selecting the first column)

For this to work with the modulo arithmetic in the code:
- `i1 % m` where i1 is the original row index
- `j1 % n` where j1 is the original column index

The self (SDM object) needs to:
1. Have shape such that it contains at least rows 0, 1, 2 and column 0
2. Have all these positions populated with value 1
3. Have a domain (let's assume a simple numeric domain like integers or rationals)

The minimum shape would be (3, 1) or larger. Let me assume (3, 1) with all elements being 1.

So the input should be:
- self._elemsdict (the sparse dict): {0: {0: 1}, 1: {0: 1}, 2: {0: 1}}
- self.shape: (3, 1)
- self.rows: 3
- self.cols: 1
- self.domain: Some domain object (let's use a generic placeholder)
- rows: [0, 1, 2]
- cols: [0]

Actually, looking more carefully at the output format - the keys are strings "0", "1", "2", which suggests this might be how it's being serialized to JSON. In the actual SDM, these would be integers.

Let me reconsider: the output dictionary shows keys as strings in JSON format. The actual SDM would have integer keys.

So for self, the elemsdict should be:
```python
{
    0: {0: 1},
    1: {0: 1},
    2: {0: 1}
}
```

And the parameters:
- rows = [0, 1, 2]
- cols = [0]

This would extract all 3 rows and the first column, resulting in the output shown.

[/THOUGHT]

[INPUT]
```
{
    "self": {
        "shape": [3, 1],
        "rows": 3,
        "cols": 1,
        "domain": "ZZ"
    },
    "args": {
        "rows": [0, 1, 2],
        "cols": [0]
    },
    "kwargs": {}
}
```
[/INPUT]