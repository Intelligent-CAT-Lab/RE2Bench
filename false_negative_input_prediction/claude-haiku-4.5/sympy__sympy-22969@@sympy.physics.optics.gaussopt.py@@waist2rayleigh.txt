<<FUNCTION_NAME>>

waist2rayleigh

<<CODE>>

from sympy.core.expr import Expr
from sympy.core.numbers import (I, pi)
from sympy.core.sympify import sympify
from sympy.functions.elementary.complexes import (im, re)
from sympy.functions.elementary.miscellaneous import sqrt
from sympy.functions.elementary.trigonometric import atan2
from sympy.matrices.dense import Matrix, MutableDenseMatrix
from sympy.polys.rationaltools import together
from sympy.utilities.misc import filldedent

__all__ = [
    'RayTransferMatrix',
    'FreeSpace',
    'FlatRefraction',
    'CurvedRefraction',
    'FlatMirror',
    'CurvedMirror',
    'ThinLens',
    'GeometricRay',
    'BeamParameter',
    'waist2rayleigh',
    'rayleigh2waist',
    'geometric_conj_ab',
    'geometric_conj_af',
    'geometric_conj_bf',
    'gaussian_conj',
    'conjugate_gauss_beams',
]
geometric_conj_bf = geometric_conj_af

def waist2rayleigh(w, wavelen, n=1):
    """
    Calculate the rayleigh range from the waist of a gaussian beam.

    See Also
    ========

    rayleigh2waist, BeamParameter

    Examples
    ========

    >>> from sympy.physics.optics import waist2rayleigh
    >>> from sympy import symbols
    >>> w, wavelen = symbols('w wavelen')
    >>> waist2rayleigh(w, wavelen)
    pi*w**2/wavelen
    """
    w, wavelen = map(sympify, (w, wavelen))
    return w**2*n*pi/wavelen


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'w': 'w_0', 'wavelen': 'l', 'n': '1'}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

pi*w_0**2/l

<<LLM_RESPONSE>>

[THOUGHT]
Let me trace through the `waist2rayleigh` function to understand what inputs would produce the output "pi*w_0**2/l".

The function is:
```python
def waist2rayleigh(w, wavelen, n=1):
    w, wavelen = map(sympify, (w, wavelen))
    return w ** 2 * n * pi / wavelen
```

The output is: "pi*w_0**2/l"

Let me work backwards:
- The formula computes: w^2 * n * pi / wavelen
- The output is: pi * w_0^2 / l

If I match these:
- w^2 * n * pi / wavelen = pi * w_0^2 / l
- So: w = w_0, n = 1 (the default), wavelen = l

The `map(sympify, (w, wavelen))` converts the inputs to symbolic expressions.
- If w = "w_0" (as a string), sympify("w_0") creates a Symbol named w_0
- If wavelen = "l" (as a string), sympify("l") creates a Symbol named l
- n = 1 (default value)

Then the calculation:
- w^2 * n * pi / wavelen
- = (w_0)^2 * 1 * pi / l
- = w_0^2 * pi / l
- = pi * w_0^2 / l

This matches the output!

So the inputs should be:
- w: "w_0"
- wavelen: "l"
- n: 1 (default, can be omitted or explicitly set)

</THOUGHT>

[INPUT]
```
{
    "self": {},
    "args": {
        "w": "w_0",
        "wavelen": "l",
        "n": 1
    },
    "kwargs": {}
}
```
[/INPUT]