<<FUNCTION_NAME>>

list_all

<<CODE>>

import importlib.metadata as im
from matplotlib import _parse_to_version_info

class BackendRegistry:
    """
    Registry of backends available within Matplotlib.

    This is the single source of truth for available backends.

    All use of ``BackendRegistry`` should be via the singleton instance
    ``backend_registry`` which can be imported from ``matplotlib.backends``.

    Each backend has a name, a module name containing the backend code, and an
    optional GUI framework that must be running if the backend is interactive.
    There are three sources of backends: built-in (source code is within the
    Matplotlib repository), explicit ``module://some.backend`` syntax (backend is
    obtained by loading the module), or via an entry point (self-registering
    backend in an external package).

    .. versionadded:: 3.9
    """
    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {'gtk3agg': 'gtk3', 'gtk3cairo': 'gtk3', 'gtk4agg': 'gtk4', 'gtk4cairo': 'gtk4', 'macosx': 'macosx', 'nbagg': 'nbagg', 'notebook': 'nbagg', 'qtagg': 'qt', 'qtcairo': 'qt', 'qt5agg': 'qt5', 'qt5cairo': 'qt5', 'tkagg': 'tk', 'tkcairo': 'tk', 'webagg': 'webagg', 'wx': 'wx', 'wxagg': 'wx', 'wxcairo': 'wx', 'agg': 'headless', 'cairo': 'headless', 'pdf': 'headless', 'pgf': 'headless', 'ps': 'headless', 'svg': 'headless', 'template': 'headless'}
    _GUI_FRAMEWORK_TO_BACKEND = {'gtk3': 'gtk3agg', 'gtk4': 'gtk4agg', 'headless': 'agg', 'macosx': 'macosx', 'qt': 'qtagg', 'qt5': 'qt5agg', 'qt6': 'qtagg', 'tk': 'tkagg', 'wx': 'wxagg'}

    def __init__(self):
        self._loaded_entry_points = False
        self._backend_to_gui_framework = {}
        self._name_to_module = {'notebook': 'nbagg'}

    def _ensure_entry_points_loaded(self):
        if not self._loaded_entry_points:
            entries = self._read_entry_points()
            self._validate_and_store_entry_points(entries)
            self._loaded_entry_points = True

    def _read_entry_points(self):
        import importlib.metadata as im
        entry_points = im.entry_points(group='matplotlib.backend')
        entries = [(entry.name, entry.value) for entry in entry_points]

        def backward_compatible_entry_points(entries, module_name, threshold_version, names, target):
            from matplotlib import _parse_to_version_info
            try:
                module_version = im.version(module_name)
                if _parse_to_version_info(module_version) < threshold_version:
                    for name in names:
                        entries.append((name, target))
            except im.PackageNotFoundError:
                pass
        names = [entry[0] for entry in entries]
        if 'inline' not in names:
            backward_compatible_entry_points(entries, 'matplotlib_inline', (0, 1, 7), ['inline'], 'matplotlib_inline.backend_inline')
        if 'ipympl' not in names:
            backward_compatible_entry_points(entries, 'ipympl', (0, 9, 4), ['ipympl', 'widget'], 'ipympl.backend_nbagg')
        return entries

    def _validate_and_store_entry_points(self, entries):
        for name, module in set(entries):
            name = name.lower()
            if name.startswith('module://'):
                raise RuntimeError(f"Entry point name '{name}' cannot start with 'module://'")
            if name in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK:
                raise RuntimeError(f"Entry point name '{name}' is a built-in backend")
            if name in self._backend_to_gui_framework:
                raise RuntimeError(f"Entry point name '{name}' duplicated")
            self._name_to_module[name] = 'module://' + module
            self._backend_to_gui_framework[name] = 'unknown'

    def list_all(self):
        """
        Return list of all known backends.

        These include built-in backends and those obtained at runtime either from entry
        points or explicit ``module://some.backend`` syntax.

        Entry points will be loaded if they haven't been already.

        Returns
        -------
        list of str
            Backend names.
        """
        self._ensure_entry_points_loaded()
        return [*self.list_builtin(), *self._backend_to_gui_framework]

    def list_builtin(self, filter_=None):
        """
        Return list of backends that are built into Matplotlib.

        Parameters
        ----------
        filter_ : `~.BackendFilter`, optional
            Filter to apply to returned backends. For example, to return only
            non-interactive backends use `.BackendFilter.NON_INTERACTIVE`.

        Returns
        -------
        list of str
            Backend names.
        """
        if filter_ == BackendFilter.INTERACTIVE:
            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items() if v != 'headless']
        elif filter_ == BackendFilter.NON_INTERACTIVE:
            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items() if v == 'headless']
        return [*self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK]


<<GROUND_TRUTH_INPUT>>

{'self': {'_loaded_entry_points': False, '_backend_to_gui_framework': {'module://matplotlib.backends.backend_agg': 'headless'}, '_name_to_module': {'notebook': 'nbagg'}}, 'args': {}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

['gtk3agg', 'gtk3cairo', 'gtk4agg', 'gtk4cairo', 'macosx', 'nbagg', 'notebook', 'qtagg', 'qtcairo', 'qt5agg', 'qt5cairo', 'tkagg', 'tkcairo', 'webagg', 'wx', 'wxagg', 'wxcairo', 'agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template', 'module://matplotlib.backends.backend_agg']

<<LLM_RESPONSE>>

[THOUGHT]
Let me trace through the `list_all()` method to understand what input would produce the given output.

1. `list_all()` calls `self._ensure_entry_points_loaded()` first.
2. Then it returns `[*self.list_builtin(), *self._backend_to_gui_framework]`

Looking at the output, I see:
- All the builtin backends from `_BUILTIN_BACKEND_TO_GUI_FRAMEWORK` (23 items)
- Plus one additional item: "module://matplotlib.backends.backend_agg"

The builtin backends are:
'gtk3agg', 'gtk3cairo', 'gtk4agg', 'gtk4cairo', 'macosx', 'nbagg', 'notebook', 'qtagg', 'qtcairo', 'qt5agg', 'qt5cairo', 'tkagg', 'tkcairo', 'webagg', 'wx', 'wxagg', 'wxcairo', 'agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template'

The extra item "module://matplotlib.backends.backend_agg" must come from `self._backend_to_gui_framework`.

So `_backend_to_gui_framework` should have at least one entry with key "module://matplotlib.backends.backend_agg" and its value should be 'unknown' (as set in `_validate_and_store_entry_points`).

For `_ensure_entry_points_loaded()` to work properly:
- `_loaded_entry_points` should be False initially so the method actually loads entry points
- After calling `_read_entry_points()` and `_validate_and_store_entry_points()`, the entry points are loaded
- The entry with key "module://matplotlib.backends.backend_agg" gets added to `_backend_to_gui_framework`

Since we're given the final state after `list_all()` is called:
- `_loaded_entry_points` should be True (after loading)
- `_backend_to_gui_framework` should have the entry: "module://matplotlib.backends.backend_agg": "unknown"
- `_name_to_module["notebook"]` should be "nbagg" (as initialized)

Wait, let me reconsider the structure. The input structure shows that we need to provide the INITIAL state of `self` before `list_all()` is called.

If `_loaded_entry_points` starts as True, then `_ensure_entry_points_loaded()` won't load anything, and `_backend_to_gui_framework` would need to already have the entry.

If `_loaded_entry_points` starts as False, then `_ensure_entry_points_loaded()` will call `_read_entry_points()` and `_validate_and_store_entry_points()`, which will populate `_backend_to_gui_framework`.

Given the structure only shows one entry in `_backend_to_gui_framework`, it seems like we should start with `_loaded_entry_points = False` and the entry points loading process should result in just one entry being added (the "module://matplotlib.backends.backend_agg" one).

Actually, looking more carefully at the structure, it appears to be asking for the initial state. The most logical initial state would be:
- `_loaded_entry_points`: False (so entry points get loaded)
- `_backend_to_gui_framework`: {} (empty, gets populated during loading)
- `_name_to_module["notebook"]`: "nbagg"

But the structure shows `_backend_to_gui_framework` with one entry already. This might be the state AFTER list_all() is called, or it could be a hint about what should be there.

Given that the structure specifically shows one entry in `_backend_to_gui_framework`, I think the intended initial state is:
- `_loaded_entry_points`: False (so entry points get loaded)
- `_backend_to_gui_framework`: {"module://matplotlib.backends.backend_agg": "unknown"}
- `_name_to_module["notebook"]`: "nbagg"

This makes sense because the entry point loading would have resulted in this one entry being added.

[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_loaded_entry_points": false,
        "_backend_to_gui_framework": {
            "module://matplotlib.backends.backend_agg": "unknown"
        },
        "_name_to_module": {
            "notebook": "nbagg"
        }
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]