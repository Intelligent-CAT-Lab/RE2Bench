<<FUNCTION_NAME>>

TR8

<<CODE>>

from sympy.core.exprtools import Factors, gcd_terms, factor_terms
from sympy.core.function import expand_mul
from sympy.core.mul import Mul
from sympy.core.traversal import bottom_up
from sympy.functions.elementary.trigonometric import (
    cos, sin, tan, cot, sec, csc, sqrt, TrigonometricFunction)

def TR8(rv, first=True):
    """Converting products of ``cos`` and/or ``sin`` to a sum or
    difference of ``cos`` and or ``sin`` terms.

    Examples
    ========

    >>> from sympy.simplify.fu import TR8
    >>> from sympy import cos, sin
    >>> TR8(cos(2)*cos(3))
    cos(5)/2 + cos(1)/2
    >>> TR8(cos(2)*sin(3))
    sin(5)/2 + sin(1)/2
    >>> TR8(sin(2)*sin(3))
    -cos(5)/2 + cos(1)/2
    """

    def f(rv):
        if not (
            rv.is_Mul or
            rv.is_Pow and
            rv.base.func in (cos, sin) and
            (rv.exp.is_integer or rv.base.is_positive)):
            return rv

        if first:
            n, d = [expand_mul(i) for i in rv.as_numer_denom()]
            newn = TR8(n, first=False)
            newd = TR8(d, first=False)
            if newn != n or newd != d:
                rv = gcd_terms(newn/newd)
                if rv.is_Mul and rv.args[0].is_Rational and \
                        len(rv.args) == 2 and rv.args[1].is_Add:
                    rv = Mul(*rv.as_coeff_Mul())
            return rv

        args = {cos: [], sin: [], None: []}
        for a in Mul.make_args(rv):
            if a.func in (cos, sin):
                args[type(a)].append(a.args[0])
            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \
                    a.base.func in (cos, sin)):
                # XXX this is ok but pathological expression could be handled
                # more efficiently as in TRmorrie
                args[type(a.base)].extend([a.base.args[0]]*a.exp)
            else:
                args[None].append(a)
        c = args[cos]
        s = args[sin]
        if not (c and s or len(c) > 1 or len(s) > 1):
            return rv

        args = args[None]
        n = min(len(c), len(s))
        for i in range(n):
            a1 = s.pop()
            a2 = c.pop()
            args.append((sin(a1 + a2) + sin(a1 - a2))/2)
        while len(c) > 1:
            a1 = c.pop()
            a2 = c.pop()
            args.append((cos(a1 + a2) + cos(a1 - a2))/2)
        if c:
            args.append(cos(c.pop()))
        while len(s) > 1:
            a1 = s.pop()
            a2 = s.pop()
            args.append((-cos(a1 + a2) + cos(a1 - a2))/2)
        if s:
            args.append(sin(s.pop()))
        return TR8(expand_mul(Mul(*args)))

    return bottom_up(rv, f)


<<GROUND_TRUTH_INPUT>>

{'self': {}, 'args': {'rv': 'cos(phi)**2', 'first': False}, 'kwargs': {}}

<<GROUND_TRUTH_OUTPUT>>

cos(2*phi)/2 + 1/2

<<LLM_RESPONSE>>

[THOUGHT]
Let me work backwards from the output to determine what input would produce `cos(2*phi)/2 + 1/2`.

The output `cos(2*phi)/2 + 1/2` is a simplified trigonometric expression. This looks like it could come from a product of trigonometric functions being simplified.

Let me think about what common trigonometric identities could produce this:
- `sin(phi)*cos(phi) = sin(2*phi)/2`
- `cos(phi)^2 = (1 + cos(2*phi))/2`
- `sin(phi)^2 = (1 - cos(2*phi))/2`

So if we had `cos(phi)^2`, it would expand to `(1 + cos(2*phi))/2 = 1/2 + cos(2*phi)/2`, which matches our output!

Let me verify this logic through the TR8 function:
1. Input: `cos(phi)**2` with `first=True` (default)
2. Since it's a Pow with cos base and integer exponent, it enters the function
3. When `first=True`, it expands numerator and denominator, then recursively calls TR8 with `first=False`
4. With `first=False`, it processes the cos terms and applies trigonometric reductions
5. For `cos(phi)**2`, using the identity `cos^2(x) = (1 + cos(2x))/2`, this should simplify

Actually, looking at the code more carefully, the TR8 function is designed to work with products of sin and cos terms using product-to-sum formulas. For a single `cos(phi)**2`, it would recognize this as `cos` with exponent 2.

In the args dictionary construction:
- `cos(phi)**2` would be recognized as `a.base.func in (cos, sin)` with `a.exp == 2`
- It would add `cos(phi)` twice to `args[cos]`
- Since `len(c) > 1` and no sin terms, it would pop two cosines and apply the product-to-sum formula
- For two cosines: `(cos(a1 + a2) + cos(a1 - a2))/2 = (cos(2*phi) + cos(0))/2 = (cos(2*phi) + 1)/2`

This matches our output!

So the input should be `cos(phi)**2` with `first=True` (the default).

Let me represent this in SymPy notation. I'll need to express this as a symbolic input. Based on the code, `rv` should be a SymPy expression.

```python
cos(phi)**2
```

Since `first` defaults to `True`, we should use that as the default value.

</THOUGHT>

[INPUT]
```
{
    "self": {},
    "args": {
        "rv": "cos(phi)**2",
        "first": true
    },
    "kwargs": {}
}
```
[/INPUT]