<<FUNCTION_NAME>>



<<CODE>>

def GCD ( a , b ) :
    while a % b != 0 :
        a , b = b , a % b
    return b
def LCM ( a , b ) :
    return a * b // GCD ( a , b )
l = input ( ) . split ( ' ' )
x , y , a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) , int ( l [ 2 ] ) , int ( l [ 3 ] )
lcm = LCM ( x , y )
print ( b // lcm - ( a - 1 ) // lcm )



<<GROUND_TRUTH_INPUT>>

101 171 1 1000000000

<<GROUND_TRUTH_OUTPUT>>

57900

<<LLM_RESPONSE>>

[THOUGHT]
Let me work backwards from the output to find the input.

The output is: `57900`

The code does:
1. Parse 4 integers from input: `x, y, a, b`
2. Calculate `lcm = LCM(x, y)` which uses GCD
3. Print `b // lcm - (a - 1) // lcm`

So: `b // lcm - (a - 1) // lcm = 57900`

This can be rewritten as: `(b - (a - 1)) // lcm = 57900` (when both divisions are exact)
Or more generally: `b // lcm - (a - 1) // lcm = 57900`

Let me think about this differently. The expression counts how many multiples of `lcm` exist in the range `[a, b]`.

Let me try some reasonable values. If `lcm = 1`, then:
- `b - (a - 1) = 57900`
- `b - a + 1 = 57900`
- This could be `a = 1, b = 57900`

If `x = 1, y = 1`, then `lcm = 1`.

Let's verify: `GCD(1, 1) = 1`, `LCM(1, 1) = 1 * 1 // 1 = 1`
Then: `57900 // 1 - (1 - 1) // 1 = 57900 - 0 = 57900` ✓

So one solution is: `x = 1, y = 1, a = 1, b = 57900`

Let me check if there are other reasonable solutions.

If `lcm = 2`:
- `b // 2 - (a - 1) // 2 = 57900`
- For `a = 1, b = 115800`: `115800 // 2 - 0 // 2 = 57900 - 0 = 57900` ✓
- This could be `x = 2, y = 2` (GCD(2,2) = 2, LCM(2,2) = 2)
- Input: `2 2 1 115800`

The simplest solution is `1 1 1 57900` which produces the output 57900.

Let me verify once more:
- `x = 1, y = 1, a = 1, b = 57900`
- `lcm = LCM(1, 1) = 1`
- Output: `57900 // 1 - (1 - 1) // 1 = 57900 - 0 = 57900` ✓
</THOUGHT>

[INPUT]
```
{
    "input": "1 1 1 57900"
}
```
[/INPUT]